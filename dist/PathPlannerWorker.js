function dash_initPathPlannerWorker() {/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./workers/PathPlannerWorker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/GPGPU.js":
/*!*********************!*\
  !*** ./js/GPGPU.js ***!
  \*********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return GPGPU; });\n/* Partially adapted from https://github.com/turbo/js/blob/master/turbo.js\n *\n * Turbo.js License:\n * Copyright (c) 2016 minxomat\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nconst vertexShaderCode = `#version 300 es\nin vec2 position;\nin vec2 texture;\nout vec2 kernelPosition;\n\nvoid main(void) {\n  kernelPosition = texture;\n  gl_Position = vec4(position.xy, 0.0, 1.0);\n}\n`;\n\nconst fragmentShaderHeader = `#version 300 es\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp sampler2DArray;\nprecision highp sampler3D;\nprecision highp samplerCube;\n\nin vec2 kernelPosition;\nout vec4 kernelOut;\nuniform ivec2 kernelSize;\n`;\n\nclass GPGPU {\n  static alloc(size, stride) {\n    if (!Number.isInteger(stride) || stride < 1 || stride > 4)\n      throw new Error(\"Data stride must be an integer between 1 and 4.\");\n\n    // Find the smallest perfect square greater than or equal to size\n    const squareSize = Math.pow(Math.ceil(Math.sqrt(size)), 2);\n\n    const data = new Float32Array(squareSize * stride);\n    data.gpgpuSize = size;\n    data.gpgpuStride = stride;\n    return data;\n  }\n\n  constructor(configs, shared = {}) {\n    this._setUpGL();\n\n    this.outputTextures = {};\n    this.sharedTextures = {};\n\n    this.programs = configs.map(c => this._prepareProgram(c));\n\n    for (const name in shared) {\n      const options = shared[name];\n      const { width, height, channels, data } = options;\n      this.sharedTextures[name] = this._createTexture(data, width, height, channels, options);\n    }\n  }\n\n  updateSharedTextures(shared) {\n    this.sharedTextures = {};\n\n    for (const name in shared) {\n      const options = shared[name];\n      const { width, height, channels, data } = options;\n      if (this.sharedTextures[name]) this.gl.deleteTexture(this.sharedTextures[name]);\n      this.sharedTextures[name] = this._createTexture(data, width, height, channels, options);\n    }\n  }\n\n  updateProgram(programOrProgramIndex, config) {\n    const program = typeof(programOrProgramIndex) == 'number' ? this.programs[programOrProgramIndex] : programOrProgramIndex;\n\n    if (!program)\n      throw new Error(`Program with index ${programOrProgramIndex} does not exist.`);\n\n    if (config.inputs)\n      throw new Error('The `updateProgram` function cannot be used to update inputs. Use `updateProgramInputs` instead.');\n\n    if (config.meta)\n      program.meta = Object.assign(program.meta, config.meta);\n\n    if (config.width !== undefined && config.height !== undefined)\n      this.updateProgramSize(program, config.width, config.height);\n\n    if (typeof(config.uniforms) == 'object')\n      this.updateProgramUniforms(program, config.uniforms);\n  }\n\n  updateProgramInputs(programIndex, inputs) {\n    const program = this.programs[programIndex];\n\n    if (!program)\n      throw new Error(`Program with index ${programIndex} does not exist.`);\n\n    if (program.inputTextures.length != inputs.length)\n      throw new Error(`You must provide the same number of inputs as when the program was set up: got ${inputs.length} but expected ${program.inputTextures.length}.`);\n\n    const previousInputWidth = program.inputWidth;\n    const previousInputHeight = program.inputHeight;\n\n    const config = program.config;\n\n    if (config.width === undefined || config.height === undefined) {\n      program.inputWidth = undefined;\n      program.inputHeight = undefined;\n      program.inputDataSize = undefined;\n    }\n\n    this._prepareProgramInputs(program, inputs);\n\n    if (program.inputWidth != previousInputWidth || program.inputHeight != previousInputHeight) {\n      this.gl.useProgram(program.glProgram);\n      this.gl.uniform2i(program.kernelSizeLocation, program.inputWidth, program.inputHeight);\n      this._prepareProgramOutput(program);\n    }\n  }\n\n  updateProgramSize(programOrProgramIndex, width, height) {\n    const program = typeof(programOrProgramIndex) == 'number' ? this.programs[programOrProgramIndex] : programOrProgramIndex;\n\n    if (!program)\n      throw new Error(`Program with index ${programOrProgramIndex} does not exist.`);\n\n    if (program.inputTextures.length != 0)\n      throw new Error(`Size can only be updated on programs with no inputs.`);\n\n    if (width == program.inputWidth && height == program.inputHeight) return;\n\n    program.inputWidth = width;\n    program.inputHeight = height;\n    program.inputDataSize = width * height;\n\n    this.gl.useProgram(program.glProgram);\n    this.gl.uniform2i(program.kernelSizeLocation, program.inputWidth, program.inputHeight);\n    this._prepareProgramOutput(program);\n  }\n\n  updateProgramUniforms(programOrProgramIndex, uniforms) {\n    const program = typeof(programOrProgramIndex) == 'number' ? this.programs[programOrProgramIndex] : programOrProgramIndex;\n    this.gl.useProgram(program.glProgram);\n\n    if (!program)\n      throw new Error(`Program with index ${programOrProgramIndex} does not exist.`);\n\n    for (const uniformName in uniforms) {\n      const value = uniforms[uniformName];\n      let uniform;\n\n      if (uniform = program.uniforms[uniformName]) {\n        this._setUniform(uniform.type, uniform.location, value)\n      } else if (uniform = program.uniformTextures[uniformName]) {\n        if (typeof(value) != 'object' || value.type != 'texture')\n          throw new Error(`Expected texture type for uniform ${uniformName}.`);\n\n        const { width, height, channels, data } = uniform;\n        if (program.uniformTextures[uniformName].texture) this.gl.deleteTexture(program.uniformTextures[uniformName].texture);\n        program.uniformTextures[uniformName].texture = this._createTexture(data, width, height, channels, uniform);\n      } else {\n        throw new Error(`The uniform ${uniformName} does not exist in this program.`);\n      }\n    }\n  }\n\n  run() {\n    const outputs = [];\n\n    for (const program of this.programs) {\n      this.gl.useProgram(program.glProgram);\n      this.gl.viewport(0, 0, program.inputWidth, program.inputHeight);\n      this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, program.frameBuffer);\n\n      for (const [index, inputTexture] of program.inputTextures.entries()) {\n        this.gl.activeTexture(this.gl.TEXTURE0 + index);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, inputTexture);\n      }\n\n      for (const uniformName in program.uniformTextures) {\n        const uniformTexture = program.uniformTextures[uniformName];\n        this.gl.activeTexture(this.gl.TEXTURE0 + uniformTexture.index);\n        this.gl.bindTexture(uniformTexture.target, uniformTexture.texture || this.sharedTextures[uniformTexture.name] || this.outputTextures[uniformTexture.name]);\n      }\n\n      if (typeof(program.draw) == 'function') {\n        program.draw(this, program);\n      } else {\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.textureBuffer);\n        this.gl.enableVertexAttribArray(program.textureLocation);\n        this.gl.vertexAttribPointer(program.textureLocation, 2, this.gl.FLOAT, false, 0, 0);\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.positionBuffer);\n        this.gl.enableVertexAttribArray(program.positionLocation);\n        this.gl.vertexAttribPointer(program.positionLocation, 2, this.gl.FLOAT, false, 0, 0);\n        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n        if (program.drawProxy) {\n          const draw = (() => this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0)).bind(this);\n          program.drawProxy(this, program, draw);\n        } else {\n          this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0);\n        }\n      }\n\n      if (program.output && program.output.name && !program.output.read) {\n        outputs.push(null);\n      } else {\n        const output = new Float32Array(program.inputWidth * program.inputHeight * 4);\n        this.gl.readPixels(0, 0, program.inputWidth, program.inputHeight, this.gl.RGBA, this.gl.FLOAT, output);\n        outputs.push(output.subarray(0, program.inputDataSize * 4));\n      }\n    }\n\n    return outputs;\n  }\n\n  _setUpGL() {\n    let canvas;\n\n    if (self.document)\n      canvas = document.createElement('canvas');\n    else if (self.OffscreenCanvas)\n      canvas = new OffscreenCanvas(0, 0);\n    else\n      throw new Error('Could not create a canvas.');\n\n    const attr = { alpha: false, antialias: false };\n    this.gl = canvas.getContext(\"webgl2\", attr) || canvas.getContext(\"experimental-webgl2\", attr);\n\n    if (!this.gl)\n      throw new Error(\"Unable to initialize WebGL2. Your browser may not support it.\");\n\n    if (!this.gl.getExtension('EXT_color_buffer_float'))\n      throw new Error('Required WebGL extension EXT_color_buffer_float not supported.');\n\n    if (!this.gl.getExtension('OES_texture_float_linear'))\n      throw new Error('Required WebGL extension OES_texture_float_linear not supported.');\n\n    this.positionBuffer = this._newBuffer([-1, -1, 1, -1, 1, 1, -1, 1]);\n    this.textureBuffer = this._newBuffer([0, 0, 1, 0, 1, 1, 0, 1]);\n    this.indexBuffer = this._newBuffer([1, 2, 0, 3, 0, 2], Uint16Array, this.gl.ELEMENT_ARRAY_BUFFER);\n  }\n\n  _prepareProgram(config) {\n    const program = { config };\n\n    program.draw = config.draw;\n    program.drawProxy = config.drawProxy;\n    program.meta = Object.assign({}, config.meta);\n\n    if (config.width && config.height) {\n      program.inputWidth = config.width;\n      program.inputHeight = config.height;\n      program.inputDataSize = config.width * config.height;\n    }\n\n    program.output = config.output;\n\n    const kernel = config.kernel;\n\n    if (typeof(kernel) != 'string' || kernel.length == 0)\n      throw new Error(\"Kernel code cannot be empty.\");\n\n    const inputs = config.inputs || [];\n    const uniforms = config.uniforms || {};\n\n    this._prepareProgramInputs(program, inputs);\n\n    let fragmentShaderConfig = \"\";\n    \n    for (const index in inputs)\n      fragmentShaderConfig += `uniform sampler2D _input${index};\\n`;\n\n    if (program.inputWidth === undefined || program.inputHeight === undefined)\n      throw new Error(\"Unknown kernel size. You must provide either an input or the `width` and `height` parameters in the kernel config.\");\n\n    program.uniformTextures = {};\n    program.uniforms = {};\n\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n\n      if (typeof(uniform) == 'number') {\n        program.uniforms[uniformName] = {\n          type: 'float',\n          value: uniform\n        };\n        fragmentShaderConfig += `uniform float ${uniformName};\\n`;\n      } else if (Array.isArray(uniform)) {\n        if (uniform.length < 2 || uniform.length > 4)\n          throw new Error(`Array uniforms can only have lengths of 2, 3, or 4 elements (corresponding to vec2, vec3, and vec4).`);\n\n        const type = ['vec2', 'vec3', 'vec4'][uniform.length - 2];\n        program.uniforms[uniformName] = {\n          type: type,\n          value: uniform\n        };\n        fragmentShaderConfig += `uniform ${type} ${uniformName};\\n`;\n      } else {\n        const { type, width, height, channels, data, value, length, name } = uniform;\n\n        if (type == 'texture' || type == 'outputTexture' || type == 'sharedTexture') {\n          let target, type;\n\n          if (uniform.textureType == '3D') {\n            target = this.gl.TEXTURE_3D;\n            type = 'sampler3D';\n          } else if (uniform.textureType == '2DArray') {\n            target = this.gl.TEXTURE_2D_ARRAY;\n            type = 'sampler2DArray';\n          } else {\n            target = this.gl.TEXTURE_2D;\n            type = 'sampler2D';\n          }\n\n          if (type == 'texture') {\n            program.uniformTextures[uniformName] = { target, texture: data ? this._createTexture(data, width, height, channels, uniform) : null };\n          } else {\n            program.uniformTextures[uniformName] = { target, texture: null, name: name || uniformName };\n          }\n\n          fragmentShaderConfig += `uniform ${type} ${uniformName};\\n`;\n        } else {\n          program.uniforms[uniformName] = { type, value };\n          if (length !== undefined)\n            fragmentShaderConfig += `uniform ${type} ${uniformName}[${length}];\\n`;\n          else\n            fragmentShaderConfig += `uniform ${type} ${uniformName};\\n`;\n        }\n      }\n    }\n\n    const vertexShader = this.gl.createShader(this.gl.VERTEX_SHADER);\n    this.gl.shaderSource(vertexShader, config.vertexShader || vertexShaderCode);\n    this.gl.compileShader(vertexShader);\n\n    if (!this.gl.getShaderParameter(vertexShader, this.gl.COMPILE_STATUS)) {\n      throw new Error(\n        \"Could not build vertex shader (fatal).\\n\" + \"\\n\" +\n        \"--- CODE DUMP ---\\n\" + (config.vertexShader || vertexShaderCode) + \"\\n\\n\" +\n        \"--- ERROR LOG ---\\n\" + this.gl.getShaderInfoLog(vertexShader)\n      );\n    }\n\n    const fragmentShaderMain = `\nvoid main() {\n  kernelOut = vec4(kernel(${[...Array(inputs.length).keys()].map(i => `texture(_input${i}, kernelPosition)`).join(', ')}));\n}\n    `;\n\n    const fragmentShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);\n    const fragmentShaderSource = fragmentShaderHeader + fragmentShaderConfig + kernel + fragmentShaderMain;\n    this.gl.shaderSource(fragmentShader, fragmentShaderSource);\n    this.gl.compileShader(fragmentShader);\n\n    if (!this.gl.getShaderParameter(fragmentShader, this.gl.COMPILE_STATUS)) {\n      const source = fragmentShaderSource.split('\\n');\n      let dbgMsg = \"ERROR: Could not build shader (fatal).\\n\\n------------------ KERNEL CODE DUMP ------------------\\n\"\n\n      for (let l = 0; l < source.length; l++)\n        dbgMsg += `${l + 1}> ${source[l]}\\n`;\n\n      dbgMsg += \"\\n--------------------- ERROR  LOG ---------------------\\n\" + this.gl.getShaderInfoLog(fragmentShader);\n\n      throw new Error(dbgMsg);\n    }\n\n    program.glProgram = this.gl.createProgram();\n    this.gl.attachShader(program.glProgram, vertexShader);\n    this.gl.attachShader(program.glProgram, fragmentShader);\n    this.gl.linkProgram(program.glProgram);\n    this.gl.useProgram(program.glProgram);\n\n    if (!this.gl.getProgramParameter(program.glProgram, this.gl.LINK_STATUS))\n      throw new Error('Failed to link GLSL program code.');\n\n    let textureIndex = 0;\n\n    for (const input of program.inputTextures) {\n      const location = this.gl.getUniformLocation(program.glProgram, `_input${textureIndex}`);\n      this.gl.uniform1i(location, textureIndex);\n      textureIndex++;\n    }\n\n    for (const uniformName in program.uniformTextures) {\n      program.uniformTextures[uniformName].index = textureIndex;\n      const location = this.gl.getUniformLocation(program.glProgram, uniformName);\n      this.gl.uniform1i(location, textureIndex);\n      textureIndex++;\n    }\n\n    for (const uniformName in program.uniforms) {\n      const { type, value } = program.uniforms[uniformName];\n      const location = program.uniforms[uniformName].location = this.gl.getUniformLocation(program.glProgram, uniformName);\n\n      if (value !== undefined)\n        this._setUniform(type, location, value);\n\n      delete program.uniforms[uniformName].value;\n    }\n\n    program.kernelSizeLocation = this.gl.getUniformLocation(program.glProgram, 'kernelSize');\n    this.gl.uniform2i(program.kernelSizeLocation, program.inputWidth, program.inputHeight);\n\n    program.positionLocation = this.gl.getAttribLocation(program.glProgram, 'position');\n    program.textureLocation = this.gl.getAttribLocation(program.glProgram, 'texture');\n\n    program.frameBuffer = this.gl.createFramebuffer();\n    this._prepareProgramOutput(program);\n\n    return program;\n  }\n\n  _prepareProgramInputs(program, inputs) {\n    if (program.inputTextures)\n      program.inputTextures.forEach(t => this.gl.deleteTexture(t));\n\n    program.inputTextures = [];\n\n    for (const [index, data] of inputs.entries()) {\n      if (data.gpgpuSize === undefined || data.gpgpuStride === undefined)\n        throw new Error('GPGPU inputs must be created by the `alloc` function.');\n\n      const size = Math.sqrt(data.length / data.gpgpuStride);\n      if (size <= 0 || size % 1 != 0)\n        throw new Error('GPGPU input size is expected to be a perfect square.');\n\n      if (program.inputWidth === undefined || program.inputHeight === undefined) {\n        program.inputWidth = size;\n        program.inputHeight = size;\n        program.inputDataSize = data.gpgpuSize;\n      } else if (size != program.inputWidth || size != program.inputHeight) {\n        throw new Error(`All GPGPU inputs must be of the same size. Received ${data.gpgpuSize} (internal ${size * size}) but expected ${program.inputDataSize} (internal ${program.inputWidth * program.inputHeight}).`);\n      }\n\n      program.inputTextures.push(this._createTexture(data, size, size, data.gpgpuStride));\n    }\n  }\n\n  _prepareProgramOutput(program) {\n    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, program.frameBuffer);\n\n    const outputTexture = this._createTexture(null, program.inputWidth, program.inputHeight, 4, program.output);\n\n    if (program.output && program.output.textureType !== '3D' && program.output.textureType !== '2DArray') {\n      this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, outputTexture, 0);\n      const frameBufferStatus = (this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER) == this.gl.FRAMEBUFFER_COMPLETE);\n      if (!frameBufferStatus)\n        throw new Error('Error attaching float texture to framebuffer. Your device is probably incompatible.');\n    }\n\n    if (program.outputTexture !== undefined)\n      this.gl.deleteTexture(program.outputTexture);\n    program.outputTexture = outputTexture;\n\n    if (program.output && program.output.name)\n      this.outputTextures[program.output.name] = outputTexture;\n  }\n\n  _setUniform(type, location, value) {\n    switch (type) {\n      case 'int': this.gl.uniform1i(location, value); break;\n      case 'float': Array.isArray(value) ? this.gl.uniform1fv(location, value) : this.gl.uniform1f(location, value); break;\n      case 'vec2': this.gl.uniform2fv(location, value); break;\n      case 'vec3': this.gl.uniform3fv(location, value); break;\n      case 'vec4': this.gl.uniform4fv(location, value); break;\n      case 'mat3': this.gl.uniformMatrix3fv(location, value); break;\n      default: throw new Error(`Unknown uniform type ${type}.`);\n    }\n  }\n\n  _newBuffer(data, klass, target) {\n    const buf = this.gl.createBuffer();\n\n    this.gl.bindBuffer((target || this.gl.ARRAY_BUFFER), buf);\n    this.gl.bufferData((target || this.gl.ARRAY_BUFFER), new (klass || Float32Array)(data), this.gl.STATIC_DRAW);\n\n    return buf;\n  }\n\n  _createTexture(data, width, height, channels, options = {}) {\n    const texture = this.gl.createTexture();\n\n    let internalFormat, format;\n\n    switch (channels) {\n      case 1:\n        internalFormat = this.gl.R32F;\n        format = this.gl.RED;\n        break;\n      case 2:\n        internalFormat = this.gl.RG32F;\n        format = this.gl.RG;\n        break;\n      case 3:\n        internalFormat = this.gl.RGB32F;\n        format = this.gl.RGB;\n        break;\n      case 4:\n        internalFormat = this.gl.RGBA32F;\n        format = this.gl.RGBA;\n        break;\n      default:\n        throw(\"Texture channels must between 1 and 4.\");\n    }\n\n    const target = options.textureType == '3D' ? this.gl.TEXTURE_3D : options.textureType == '2DArray' ? this.gl.TEXTURE_2D_ARRAY : this.gl.TEXTURE_2D;\n\n    this.gl.bindTexture(target, texture);\n    this.gl.texParameteri(target, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(target, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(target, this.gl.TEXTURE_WRAP_R, this.gl.CLAMP_TO_EDGE);\n    this.gl.texParameteri(target, this.gl.TEXTURE_MIN_FILTER, options.filter == 'linear' ? this.gl.LINEAR : this.gl.NEAREST);\n    this.gl.texParameteri(target, this.gl.TEXTURE_MAG_FILTER, options.filter == 'linear' ? this.gl.LINEAR : this.gl.NEAREST);\n\n    if (options.textureType == '3D' || options.textureType == '2DArray') {\n      this.gl.texImage3D(target, 0, internalFormat, width, height, options.depth, 0, format, this.gl.FLOAT, data);\n    } else {\n      this.gl.texImage2D(target, 0, internalFormat, width, height, 0, format, this.gl.FLOAT, data);\n    }\n\n    this.gl.bindTexture(target, null);\n\n    return texture;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9HUEdQVS5qcz80NDJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLGdDQUFnQztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDLHNCQUFzQjs7QUFFbEU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsYUFBYTs7QUFFekQ7QUFDQSx3R0FBd0csY0FBYyxnQkFBZ0IsNkJBQTZCOztBQUVuSztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsc0JBQXNCOztBQUVsRTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsc0JBQXNCOztBQUVsRTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUFDNUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0REFBNEQ7QUFDNUQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL2pzL0dQR1BVLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogUGFydGlhbGx5IGFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdHVyYm8vanMvYmxvYi9tYXN0ZXIvdHVyYm8uanNcbiAqXG4gKiBUdXJiby5qcyBMaWNlbnNlOlxuICogQ29weXJpZ2h0IChjKSAyMDE2IG1pbnhvbWF0XG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG5jb25zdCB2ZXJ0ZXhTaGFkZXJDb2RlID0gYCN2ZXJzaW9uIDMwMCBlc1xuaW4gdmVjMiBwb3NpdGlvbjtcbmluIHZlYzIgdGV4dHVyZTtcbm91dCB2ZWMyIGtlcm5lbFBvc2l0aW9uO1xuXG52b2lkIG1haW4odm9pZCkge1xuICBrZXJuZWxQb3NpdGlvbiA9IHRleHR1cmU7XG4gIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbi54eSwgMC4wLCAxLjApO1xufVxuYDtcblxuY29uc3QgZnJhZ21lbnRTaGFkZXJIZWFkZXIgPSBgI3ZlcnNpb24gMzAwIGVzXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG5wcmVjaXNpb24gaGlnaHAgaW50O1xucHJlY2lzaW9uIGhpZ2hwIHNhbXBsZXIyRDtcbnByZWNpc2lvbiBoaWdocCBzYW1wbGVyMkRBcnJheTtcbnByZWNpc2lvbiBoaWdocCBzYW1wbGVyM0Q7XG5wcmVjaXNpb24gaGlnaHAgc2FtcGxlckN1YmU7XG5cbmluIHZlYzIga2VybmVsUG9zaXRpb247XG5vdXQgdmVjNCBrZXJuZWxPdXQ7XG51bmlmb3JtIGl2ZWMyIGtlcm5lbFNpemU7XG5gO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHUEdQVSB7XG4gIHN0YXRpYyBhbGxvYyhzaXplLCBzdHJpZGUpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoc3RyaWRlKSB8fCBzdHJpZGUgPCAxIHx8IHN0cmlkZSA+IDQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIHN0cmlkZSBtdXN0IGJlIGFuIGludGVnZXIgYmV0d2VlbiAxIGFuZCA0LlwiKTtcblxuICAgIC8vIEZpbmQgdGhlIHNtYWxsZXN0IHBlcmZlY3Qgc3F1YXJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBzaXplXG4gICAgY29uc3Qgc3F1YXJlU2l6ZSA9IE1hdGgucG93KE1hdGguY2VpbChNYXRoLnNxcnQoc2l6ZSkpLCAyKTtcblxuICAgIGNvbnN0IGRhdGEgPSBuZXcgRmxvYXQzMkFycmF5KHNxdWFyZVNpemUgKiBzdHJpZGUpO1xuICAgIGRhdGEuZ3BncHVTaXplID0gc2l6ZTtcbiAgICBkYXRhLmdwZ3B1U3RyaWRlID0gc3RyaWRlO1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgY29uc3RydWN0b3IoY29uZmlncywgc2hhcmVkID0ge30pIHtcbiAgICB0aGlzLl9zZXRVcEdMKCk7XG5cbiAgICB0aGlzLm91dHB1dFRleHR1cmVzID0ge307XG4gICAgdGhpcy5zaGFyZWRUZXh0dXJlcyA9IHt9O1xuXG4gICAgdGhpcy5wcm9ncmFtcyA9IGNvbmZpZ3MubWFwKGMgPT4gdGhpcy5fcHJlcGFyZVByb2dyYW0oYykpO1xuXG4gICAgZm9yIChjb25zdCBuYW1lIGluIHNoYXJlZCkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHNoYXJlZFtuYW1lXTtcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgY2hhbm5lbHMsIGRhdGEgfSA9IG9wdGlvbnM7XG4gICAgICB0aGlzLnNoYXJlZFRleHR1cmVzW25hbWVdID0gdGhpcy5fY3JlYXRlVGV4dHVyZShkYXRhLCB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlU2hhcmVkVGV4dHVyZXMoc2hhcmVkKSB7XG4gICAgdGhpcy5zaGFyZWRUZXh0dXJlcyA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBuYW1lIGluIHNoYXJlZCkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHNoYXJlZFtuYW1lXTtcbiAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgY2hhbm5lbHMsIGRhdGEgfSA9IG9wdGlvbnM7XG4gICAgICBpZiAodGhpcy5zaGFyZWRUZXh0dXJlc1tuYW1lXSkgdGhpcy5nbC5kZWxldGVUZXh0dXJlKHRoaXMuc2hhcmVkVGV4dHVyZXNbbmFtZV0pO1xuICAgICAgdGhpcy5zaGFyZWRUZXh0dXJlc1tuYW1lXSA9IHRoaXMuX2NyZWF0ZVRleHR1cmUoZGF0YSwgd2lkdGgsIGhlaWdodCwgY2hhbm5lbHMsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVByb2dyYW0ocHJvZ3JhbU9yUHJvZ3JhbUluZGV4LCBjb25maWcpIHtcbiAgICBjb25zdCBwcm9ncmFtID0gdHlwZW9mKHByb2dyYW1PclByb2dyYW1JbmRleCkgPT0gJ251bWJlcicgPyB0aGlzLnByb2dyYW1zW3Byb2dyYW1PclByb2dyYW1JbmRleF0gOiBwcm9ncmFtT3JQcm9ncmFtSW5kZXg7XG5cbiAgICBpZiAoIXByb2dyYW0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFByb2dyYW0gd2l0aCBpbmRleCAke3Byb2dyYW1PclByb2dyYW1JbmRleH0gZG9lcyBub3QgZXhpc3QuYCk7XG5cbiAgICBpZiAoY29uZmlnLmlucHV0cylcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGB1cGRhdGVQcm9ncmFtYCBmdW5jdGlvbiBjYW5ub3QgYmUgdXNlZCB0byB1cGRhdGUgaW5wdXRzLiBVc2UgYHVwZGF0ZVByb2dyYW1JbnB1dHNgIGluc3RlYWQuJyk7XG5cbiAgICBpZiAoY29uZmlnLm1ldGEpXG4gICAgICBwcm9ncmFtLm1ldGEgPSBPYmplY3QuYXNzaWduKHByb2dyYW0ubWV0YSwgY29uZmlnLm1ldGEpO1xuXG4gICAgaWYgKGNvbmZpZy53aWR0aCAhPT0gdW5kZWZpbmVkICYmIGNvbmZpZy5oZWlnaHQgIT09IHVuZGVmaW5lZClcbiAgICAgIHRoaXMudXBkYXRlUHJvZ3JhbVNpemUocHJvZ3JhbSwgY29uZmlnLndpZHRoLCBjb25maWcuaGVpZ2h0KTtcblxuICAgIGlmICh0eXBlb2YoY29uZmlnLnVuaWZvcm1zKSA9PSAnb2JqZWN0JylcbiAgICAgIHRoaXMudXBkYXRlUHJvZ3JhbVVuaWZvcm1zKHByb2dyYW0sIGNvbmZpZy51bmlmb3Jtcyk7XG4gIH1cblxuICB1cGRhdGVQcm9ncmFtSW5wdXRzKHByb2dyYW1JbmRleCwgaW5wdXRzKSB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMucHJvZ3JhbXNbcHJvZ3JhbUluZGV4XTtcblxuICAgIGlmICghcHJvZ3JhbSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvZ3JhbSB3aXRoIGluZGV4ICR7cHJvZ3JhbUluZGV4fSBkb2VzIG5vdCBleGlzdC5gKTtcblxuICAgIGlmIChwcm9ncmFtLmlucHV0VGV4dHVyZXMubGVuZ3RoICE9IGlucHV0cy5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFlvdSBtdXN0IHByb3ZpZGUgdGhlIHNhbWUgbnVtYmVyIG9mIGlucHV0cyBhcyB3aGVuIHRoZSBwcm9ncmFtIHdhcyBzZXQgdXA6IGdvdCAke2lucHV0cy5sZW5ndGh9IGJ1dCBleHBlY3RlZCAke3Byb2dyYW0uaW5wdXRUZXh0dXJlcy5sZW5ndGh9LmApO1xuXG4gICAgY29uc3QgcHJldmlvdXNJbnB1dFdpZHRoID0gcHJvZ3JhbS5pbnB1dFdpZHRoO1xuICAgIGNvbnN0IHByZXZpb3VzSW5wdXRIZWlnaHQgPSBwcm9ncmFtLmlucHV0SGVpZ2h0O1xuXG4gICAgY29uc3QgY29uZmlnID0gcHJvZ3JhbS5jb25maWc7XG5cbiAgICBpZiAoY29uZmlnLndpZHRoID09PSB1bmRlZmluZWQgfHwgY29uZmlnLmhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwcm9ncmFtLmlucHV0V2lkdGggPSB1bmRlZmluZWQ7XG4gICAgICBwcm9ncmFtLmlucHV0SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgcHJvZ3JhbS5pbnB1dERhdGFTaXplID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHRoaXMuX3ByZXBhcmVQcm9ncmFtSW5wdXRzKHByb2dyYW0sIGlucHV0cyk7XG5cbiAgICBpZiAocHJvZ3JhbS5pbnB1dFdpZHRoICE9IHByZXZpb3VzSW5wdXRXaWR0aCB8fCBwcm9ncmFtLmlucHV0SGVpZ2h0ICE9IHByZXZpb3VzSW5wdXRIZWlnaHQpIHtcbiAgICAgIHRoaXMuZ2wudXNlUHJvZ3JhbShwcm9ncmFtLmdsUHJvZ3JhbSk7XG4gICAgICB0aGlzLmdsLnVuaWZvcm0yaShwcm9ncmFtLmtlcm5lbFNpemVMb2NhdGlvbiwgcHJvZ3JhbS5pbnB1dFdpZHRoLCBwcm9ncmFtLmlucHV0SGVpZ2h0KTtcbiAgICAgIHRoaXMuX3ByZXBhcmVQcm9ncmFtT3V0cHV0KHByb2dyYW0pO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZVByb2dyYW1TaXplKHByb2dyYW1PclByb2dyYW1JbmRleCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IHByb2dyYW0gPSB0eXBlb2YocHJvZ3JhbU9yUHJvZ3JhbUluZGV4KSA9PSAnbnVtYmVyJyA/IHRoaXMucHJvZ3JhbXNbcHJvZ3JhbU9yUHJvZ3JhbUluZGV4XSA6IHByb2dyYW1PclByb2dyYW1JbmRleDtcblxuICAgIGlmICghcHJvZ3JhbSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvZ3JhbSB3aXRoIGluZGV4ICR7cHJvZ3JhbU9yUHJvZ3JhbUluZGV4fSBkb2VzIG5vdCBleGlzdC5gKTtcblxuICAgIGlmIChwcm9ncmFtLmlucHV0VGV4dHVyZXMubGVuZ3RoICE9IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFNpemUgY2FuIG9ubHkgYmUgdXBkYXRlZCBvbiBwcm9ncmFtcyB3aXRoIG5vIGlucHV0cy5gKTtcblxuICAgIGlmICh3aWR0aCA9PSBwcm9ncmFtLmlucHV0V2lkdGggJiYgaGVpZ2h0ID09IHByb2dyYW0uaW5wdXRIZWlnaHQpIHJldHVybjtcblxuICAgIHByb2dyYW0uaW5wdXRXaWR0aCA9IHdpZHRoO1xuICAgIHByb2dyYW0uaW5wdXRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgcHJvZ3JhbS5pbnB1dERhdGFTaXplID0gd2lkdGggKiBoZWlnaHQ7XG5cbiAgICB0aGlzLmdsLnVzZVByb2dyYW0ocHJvZ3JhbS5nbFByb2dyYW0pO1xuICAgIHRoaXMuZ2wudW5pZm9ybTJpKHByb2dyYW0ua2VybmVsU2l6ZUxvY2F0aW9uLCBwcm9ncmFtLmlucHV0V2lkdGgsIHByb2dyYW0uaW5wdXRIZWlnaHQpO1xuICAgIHRoaXMuX3ByZXBhcmVQcm9ncmFtT3V0cHV0KHByb2dyYW0pO1xuICB9XG5cbiAgdXBkYXRlUHJvZ3JhbVVuaWZvcm1zKHByb2dyYW1PclByb2dyYW1JbmRleCwgdW5pZm9ybXMpIHtcbiAgICBjb25zdCBwcm9ncmFtID0gdHlwZW9mKHByb2dyYW1PclByb2dyYW1JbmRleCkgPT0gJ251bWJlcicgPyB0aGlzLnByb2dyYW1zW3Byb2dyYW1PclByb2dyYW1JbmRleF0gOiBwcm9ncmFtT3JQcm9ncmFtSW5kZXg7XG4gICAgdGhpcy5nbC51c2VQcm9ncmFtKHByb2dyYW0uZ2xQcm9ncmFtKTtcblxuICAgIGlmICghcHJvZ3JhbSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUHJvZ3JhbSB3aXRoIGluZGV4ICR7cHJvZ3JhbU9yUHJvZ3JhbUluZGV4fSBkb2VzIG5vdCBleGlzdC5gKTtcblxuICAgIGZvciAoY29uc3QgdW5pZm9ybU5hbWUgaW4gdW5pZm9ybXMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdW5pZm9ybXNbdW5pZm9ybU5hbWVdO1xuICAgICAgbGV0IHVuaWZvcm07XG5cbiAgICAgIGlmICh1bmlmb3JtID0gcHJvZ3JhbS51bmlmb3Jtc1t1bmlmb3JtTmFtZV0pIHtcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSh1bmlmb3JtLnR5cGUsIHVuaWZvcm0ubG9jYXRpb24sIHZhbHVlKVxuICAgICAgfSBlbHNlIGlmICh1bmlmb3JtID0gcHJvZ3JhbS51bmlmb3JtVGV4dHVyZXNbdW5pZm9ybU5hbWVdKSB7XG4gICAgICAgIGlmICh0eXBlb2YodmFsdWUpICE9ICdvYmplY3QnIHx8IHZhbHVlLnR5cGUgIT0gJ3RleHR1cmUnKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgdGV4dHVyZSB0eXBlIGZvciB1bmlmb3JtICR7dW5pZm9ybU5hbWV9LmApO1xuXG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgY2hhbm5lbHMsIGRhdGEgfSA9IHVuaWZvcm07XG4gICAgICAgIGlmIChwcm9ncmFtLnVuaWZvcm1UZXh0dXJlc1t1bmlmb3JtTmFtZV0udGV4dHVyZSkgdGhpcy5nbC5kZWxldGVUZXh0dXJlKHByb2dyYW0udW5pZm9ybVRleHR1cmVzW3VuaWZvcm1OYW1lXS50ZXh0dXJlKTtcbiAgICAgICAgcHJvZ3JhbS51bmlmb3JtVGV4dHVyZXNbdW5pZm9ybU5hbWVdLnRleHR1cmUgPSB0aGlzLl9jcmVhdGVUZXh0dXJlKGRhdGEsIHdpZHRoLCBoZWlnaHQsIGNoYW5uZWxzLCB1bmlmb3JtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHVuaWZvcm0gJHt1bmlmb3JtTmFtZX0gZG9lcyBub3QgZXhpc3QgaW4gdGhpcyBwcm9ncmFtLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJ1bigpIHtcbiAgICBjb25zdCBvdXRwdXRzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IHByb2dyYW0gb2YgdGhpcy5wcm9ncmFtcykge1xuICAgICAgdGhpcy5nbC51c2VQcm9ncmFtKHByb2dyYW0uZ2xQcm9ncmFtKTtcbiAgICAgIHRoaXMuZ2wudmlld3BvcnQoMCwgMCwgcHJvZ3JhbS5pbnB1dFdpZHRoLCBwcm9ncmFtLmlucHV0SGVpZ2h0KTtcbiAgICAgIHRoaXMuZ2wuYmluZEZyYW1lYnVmZmVyKHRoaXMuZ2wuRlJBTUVCVUZGRVIsIHByb2dyYW0uZnJhbWVCdWZmZXIpO1xuXG4gICAgICBmb3IgKGNvbnN0IFtpbmRleCwgaW5wdXRUZXh0dXJlXSBvZiBwcm9ncmFtLmlucHV0VGV4dHVyZXMuZW50cmllcygpKSB7XG4gICAgICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUwICsgaW5kZXgpO1xuICAgICAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgaW5wdXRUZXh0dXJlKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCB1bmlmb3JtTmFtZSBpbiBwcm9ncmFtLnVuaWZvcm1UZXh0dXJlcykge1xuICAgICAgICBjb25zdCB1bmlmb3JtVGV4dHVyZSA9IHByb2dyYW0udW5pZm9ybVRleHR1cmVzW3VuaWZvcm1OYW1lXTtcbiAgICAgICAgdGhpcy5nbC5hY3RpdmVUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRTAgKyB1bmlmb3JtVGV4dHVyZS5pbmRleCk7XG4gICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodW5pZm9ybVRleHR1cmUudGFyZ2V0LCB1bmlmb3JtVGV4dHVyZS50ZXh0dXJlIHx8IHRoaXMuc2hhcmVkVGV4dHVyZXNbdW5pZm9ybVRleHR1cmUubmFtZV0gfHwgdGhpcy5vdXRwdXRUZXh0dXJlc1t1bmlmb3JtVGV4dHVyZS5uYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YocHJvZ3JhbS5kcmF3KSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHByb2dyYW0uZHJhdyh0aGlzLCBwcm9ncmFtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy50ZXh0dXJlQnVmZmVyKTtcbiAgICAgICAgdGhpcy5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwcm9ncmFtLnRleHR1cmVMb2NhdGlvbik7XG4gICAgICAgIHRoaXMuZ2wudmVydGV4QXR0cmliUG9pbnRlcihwcm9ncmFtLnRleHR1cmVMb2NhdGlvbiwgMiwgdGhpcy5nbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMucG9zaXRpb25CdWZmZXIpO1xuICAgICAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHByb2dyYW0ucG9zaXRpb25Mb2NhdGlvbik7XG4gICAgICAgIHRoaXMuZ2wudmVydGV4QXR0cmliUG9pbnRlcihwcm9ncmFtLnBvc2l0aW9uTG9jYXRpb24sIDIsIHRoaXMuZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIHRoaXMuaW5kZXhCdWZmZXIpO1xuXG4gICAgICAgIGlmIChwcm9ncmFtLmRyYXdQcm94eSkge1xuICAgICAgICAgIGNvbnN0IGRyYXcgPSAoKCkgPT4gdGhpcy5nbC5kcmF3RWxlbWVudHModGhpcy5nbC5UUklBTkdMRVMsIDYsIHRoaXMuZ2wuVU5TSUdORURfU0hPUlQsIDApKS5iaW5kKHRoaXMpO1xuICAgICAgICAgIHByb2dyYW0uZHJhd1Byb3h5KHRoaXMsIHByb2dyYW0sIGRyYXcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZ2wuZHJhd0VsZW1lbnRzKHRoaXMuZ2wuVFJJQU5HTEVTLCA2LCB0aGlzLmdsLlVOU0lHTkVEX1NIT1JULCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAocHJvZ3JhbS5vdXRwdXQgJiYgcHJvZ3JhbS5vdXRwdXQubmFtZSAmJiAhcHJvZ3JhbS5vdXRwdXQucmVhZCkge1xuICAgICAgICBvdXRwdXRzLnB1c2gobnVsbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBuZXcgRmxvYXQzMkFycmF5KHByb2dyYW0uaW5wdXRXaWR0aCAqIHByb2dyYW0uaW5wdXRIZWlnaHQgKiA0KTtcbiAgICAgICAgdGhpcy5nbC5yZWFkUGl4ZWxzKDAsIDAsIHByb2dyYW0uaW5wdXRXaWR0aCwgcHJvZ3JhbS5pbnB1dEhlaWdodCwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLkZMT0FULCBvdXRwdXQpO1xuICAgICAgICBvdXRwdXRzLnB1c2gob3V0cHV0LnN1YmFycmF5KDAsIHByb2dyYW0uaW5wdXREYXRhU2l6ZSAqIDQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0cztcbiAgfVxuXG4gIF9zZXRVcEdMKCkge1xuICAgIGxldCBjYW52YXM7XG5cbiAgICBpZiAoc2VsZi5kb2N1bWVudClcbiAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGVsc2UgaWYgKHNlbGYuT2Zmc2NyZWVuQ2FudmFzKVxuICAgICAgY2FudmFzID0gbmV3IE9mZnNjcmVlbkNhbnZhcygwLCAwKTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBjcmVhdGUgYSBjYW52YXMuJyk7XG5cbiAgICBjb25zdCBhdHRyID0geyBhbHBoYTogZmFsc2UsIGFudGlhbGlhczogZmFsc2UgfTtcbiAgICB0aGlzLmdsID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbDJcIiwgYXR0cikgfHwgY2FudmFzLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2wyXCIsIGF0dHIpO1xuXG4gICAgaWYgKCF0aGlzLmdsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGluaXRpYWxpemUgV2ViR0wyLiBZb3VyIGJyb3dzZXIgbWF5IG5vdCBzdXBwb3J0IGl0LlwiKTtcblxuICAgIGlmICghdGhpcy5nbC5nZXRFeHRlbnNpb24oJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVxdWlyZWQgV2ViR0wgZXh0ZW5zaW9uIEVYVF9jb2xvcl9idWZmZXJfZmxvYXQgbm90IHN1cHBvcnRlZC4nKTtcblxuICAgIGlmICghdGhpcy5nbC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1aXJlZCBXZWJHTCBleHRlbnNpb24gT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyIG5vdCBzdXBwb3J0ZWQuJyk7XG5cbiAgICB0aGlzLnBvc2l0aW9uQnVmZmVyID0gdGhpcy5fbmV3QnVmZmVyKFstMSwgLTEsIDEsIC0xLCAxLCAxLCAtMSwgMV0pO1xuICAgIHRoaXMudGV4dHVyZUJ1ZmZlciA9IHRoaXMuX25ld0J1ZmZlcihbMCwgMCwgMSwgMCwgMSwgMSwgMCwgMV0pO1xuICAgIHRoaXMuaW5kZXhCdWZmZXIgPSB0aGlzLl9uZXdCdWZmZXIoWzEsIDIsIDAsIDMsIDAsIDJdLCBVaW50MTZBcnJheSwgdGhpcy5nbC5FTEVNRU5UX0FSUkFZX0JVRkZFUik7XG4gIH1cblxuICBfcHJlcGFyZVByb2dyYW0oY29uZmlnKSB7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHsgY29uZmlnIH07XG5cbiAgICBwcm9ncmFtLmRyYXcgPSBjb25maWcuZHJhdztcbiAgICBwcm9ncmFtLmRyYXdQcm94eSA9IGNvbmZpZy5kcmF3UHJveHk7XG4gICAgcHJvZ3JhbS5tZXRhID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLm1ldGEpO1xuXG4gICAgaWYgKGNvbmZpZy53aWR0aCAmJiBjb25maWcuaGVpZ2h0KSB7XG4gICAgICBwcm9ncmFtLmlucHV0V2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgICBwcm9ncmFtLmlucHV0SGVpZ2h0ID0gY29uZmlnLmhlaWdodDtcbiAgICAgIHByb2dyYW0uaW5wdXREYXRhU2l6ZSA9IGNvbmZpZy53aWR0aCAqIGNvbmZpZy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgcHJvZ3JhbS5vdXRwdXQgPSBjb25maWcub3V0cHV0O1xuXG4gICAgY29uc3Qga2VybmVsID0gY29uZmlnLmtlcm5lbDtcblxuICAgIGlmICh0eXBlb2Yoa2VybmVsKSAhPSAnc3RyaW5nJyB8fCBrZXJuZWwubGVuZ3RoID09IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXJuZWwgY29kZSBjYW5ub3QgYmUgZW1wdHkuXCIpO1xuXG4gICAgY29uc3QgaW5wdXRzID0gY29uZmlnLmlucHV0cyB8fCBbXTtcbiAgICBjb25zdCB1bmlmb3JtcyA9IGNvbmZpZy51bmlmb3JtcyB8fCB7fTtcblxuICAgIHRoaXMuX3ByZXBhcmVQcm9ncmFtSW5wdXRzKHByb2dyYW0sIGlucHV0cyk7XG5cbiAgICBsZXQgZnJhZ21lbnRTaGFkZXJDb25maWcgPSBcIlwiO1xuICAgIFxuICAgIGZvciAoY29uc3QgaW5kZXggaW4gaW5wdXRzKVxuICAgICAgZnJhZ21lbnRTaGFkZXJDb25maWcgKz0gYHVuaWZvcm0gc2FtcGxlcjJEIF9pbnB1dCR7aW5kZXh9O1xcbmA7XG5cbiAgICBpZiAocHJvZ3JhbS5pbnB1dFdpZHRoID09PSB1bmRlZmluZWQgfHwgcHJvZ3JhbS5pbnB1dEhlaWdodCA9PT0gdW5kZWZpbmVkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBrZXJuZWwgc2l6ZS4gWW91IG11c3QgcHJvdmlkZSBlaXRoZXIgYW4gaW5wdXQgb3IgdGhlIGB3aWR0aGAgYW5kIGBoZWlnaHRgIHBhcmFtZXRlcnMgaW4gdGhlIGtlcm5lbCBjb25maWcuXCIpO1xuXG4gICAgcHJvZ3JhbS51bmlmb3JtVGV4dHVyZXMgPSB7fTtcbiAgICBwcm9ncmFtLnVuaWZvcm1zID0ge307XG5cbiAgICBmb3IgKGNvbnN0IHVuaWZvcm1OYW1lIGluIHVuaWZvcm1zKSB7XG4gICAgICBjb25zdCB1bmlmb3JtID0gdW5pZm9ybXNbdW5pZm9ybU5hbWVdO1xuXG4gICAgICBpZiAodHlwZW9mKHVuaWZvcm0pID09ICdudW1iZXInKSB7XG4gICAgICAgIHByb2dyYW0udW5pZm9ybXNbdW5pZm9ybU5hbWVdID0ge1xuICAgICAgICAgIHR5cGU6ICdmbG9hdCcsXG4gICAgICAgICAgdmFsdWU6IHVuaWZvcm1cbiAgICAgICAgfTtcbiAgICAgICAgZnJhZ21lbnRTaGFkZXJDb25maWcgKz0gYHVuaWZvcm0gZmxvYXQgJHt1bmlmb3JtTmFtZX07XFxuYDtcbiAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh1bmlmb3JtKSkge1xuICAgICAgICBpZiAodW5pZm9ybS5sZW5ndGggPCAyIHx8IHVuaWZvcm0ubGVuZ3RoID4gNClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFycmF5IHVuaWZvcm1zIGNhbiBvbmx5IGhhdmUgbGVuZ3RocyBvZiAyLCAzLCBvciA0IGVsZW1lbnRzIChjb3JyZXNwb25kaW5nIHRvIHZlYzIsIHZlYzMsIGFuZCB2ZWM0KS5gKTtcblxuICAgICAgICBjb25zdCB0eXBlID0gWyd2ZWMyJywgJ3ZlYzMnLCAndmVjNCddW3VuaWZvcm0ubGVuZ3RoIC0gMl07XG4gICAgICAgIHByb2dyYW0udW5pZm9ybXNbdW5pZm9ybU5hbWVdID0ge1xuICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgdmFsdWU6IHVuaWZvcm1cbiAgICAgICAgfTtcbiAgICAgICAgZnJhZ21lbnRTaGFkZXJDb25maWcgKz0gYHVuaWZvcm0gJHt0eXBlfSAke3VuaWZvcm1OYW1lfTtcXG5gO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyB0eXBlLCB3aWR0aCwgaGVpZ2h0LCBjaGFubmVscywgZGF0YSwgdmFsdWUsIGxlbmd0aCwgbmFtZSB9ID0gdW5pZm9ybTtcblxuICAgICAgICBpZiAodHlwZSA9PSAndGV4dHVyZScgfHwgdHlwZSA9PSAnb3V0cHV0VGV4dHVyZScgfHwgdHlwZSA9PSAnc2hhcmVkVGV4dHVyZScpIHtcbiAgICAgICAgICBsZXQgdGFyZ2V0LCB0eXBlO1xuXG4gICAgICAgICAgaWYgKHVuaWZvcm0udGV4dHVyZVR5cGUgPT0gJzNEJykge1xuICAgICAgICAgICAgdGFyZ2V0ID0gdGhpcy5nbC5URVhUVVJFXzNEO1xuICAgICAgICAgICAgdHlwZSA9ICdzYW1wbGVyM0QnO1xuICAgICAgICAgIH0gZWxzZSBpZiAodW5pZm9ybS50ZXh0dXJlVHlwZSA9PSAnMkRBcnJheScpIHtcbiAgICAgICAgICAgIHRhcmdldCA9IHRoaXMuZ2wuVEVYVFVSRV8yRF9BUlJBWTtcbiAgICAgICAgICAgIHR5cGUgPSAnc2FtcGxlcjJEQXJyYXknO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQgPSB0aGlzLmdsLlRFWFRVUkVfMkQ7XG4gICAgICAgICAgICB0eXBlID0gJ3NhbXBsZXIyRCc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGUgPT0gJ3RleHR1cmUnKSB7XG4gICAgICAgICAgICBwcm9ncmFtLnVuaWZvcm1UZXh0dXJlc1t1bmlmb3JtTmFtZV0gPSB7IHRhcmdldCwgdGV4dHVyZTogZGF0YSA/IHRoaXMuX2NyZWF0ZVRleHR1cmUoZGF0YSwgd2lkdGgsIGhlaWdodCwgY2hhbm5lbHMsIHVuaWZvcm0pIDogbnVsbCB9O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9ncmFtLnVuaWZvcm1UZXh0dXJlc1t1bmlmb3JtTmFtZV0gPSB7IHRhcmdldCwgdGV4dHVyZTogbnVsbCwgbmFtZTogbmFtZSB8fCB1bmlmb3JtTmFtZSB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZyYWdtZW50U2hhZGVyQ29uZmlnICs9IGB1bmlmb3JtICR7dHlwZX0gJHt1bmlmb3JtTmFtZX07XFxuYDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9ncmFtLnVuaWZvcm1zW3VuaWZvcm1OYW1lXSA9IHsgdHlwZSwgdmFsdWUgfTtcbiAgICAgICAgICBpZiAobGVuZ3RoICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlckNvbmZpZyArPSBgdW5pZm9ybSAke3R5cGV9ICR7dW5pZm9ybU5hbWV9WyR7bGVuZ3RofV07XFxuYDtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBmcmFnbWVudFNoYWRlckNvbmZpZyArPSBgdW5pZm9ybSAke3R5cGV9ICR7dW5pZm9ybU5hbWV9O1xcbmA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSB0aGlzLmdsLmNyZWF0ZVNoYWRlcih0aGlzLmdsLlZFUlRFWF9TSEFERVIpO1xuICAgIHRoaXMuZ2wuc2hhZGVyU291cmNlKHZlcnRleFNoYWRlciwgY29uZmlnLnZlcnRleFNoYWRlciB8fCB2ZXJ0ZXhTaGFkZXJDb2RlKTtcbiAgICB0aGlzLmdsLmNvbXBpbGVTaGFkZXIodmVydGV4U2hhZGVyKTtcblxuICAgIGlmICghdGhpcy5nbC5nZXRTaGFkZXJQYXJhbWV0ZXIodmVydGV4U2hhZGVyLCB0aGlzLmdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNvdWxkIG5vdCBidWlsZCB2ZXJ0ZXggc2hhZGVyIChmYXRhbCkuXFxuXCIgKyBcIlxcblwiICtcbiAgICAgICAgXCItLS0gQ09ERSBEVU1QIC0tLVxcblwiICsgKGNvbmZpZy52ZXJ0ZXhTaGFkZXIgfHwgdmVydGV4U2hhZGVyQ29kZSkgKyBcIlxcblxcblwiICtcbiAgICAgICAgXCItLS0gRVJST1IgTE9HIC0tLVxcblwiICsgdGhpcy5nbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRleFNoYWRlcilcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXJNYWluID0gYFxudm9pZCBtYWluKCkge1xuICBrZXJuZWxPdXQgPSB2ZWM0KGtlcm5lbCgke1suLi5BcnJheShpbnB1dHMubGVuZ3RoKS5rZXlzKCldLm1hcChpID0+IGB0ZXh0dXJlKF9pbnB1dCR7aX0sIGtlcm5lbFBvc2l0aW9uKWApLmpvaW4oJywgJyl9KSk7XG59XG4gICAgYDtcblxuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gdGhpcy5nbC5jcmVhdGVTaGFkZXIodGhpcy5nbC5GUkFHTUVOVF9TSEFERVIpO1xuICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyU291cmNlID0gZnJhZ21lbnRTaGFkZXJIZWFkZXIgKyBmcmFnbWVudFNoYWRlckNvbmZpZyArIGtlcm5lbCArIGZyYWdtZW50U2hhZGVyTWFpbjtcbiAgICB0aGlzLmdsLnNoYWRlclNvdXJjZShmcmFnbWVudFNoYWRlciwgZnJhZ21lbnRTaGFkZXJTb3VyY2UpO1xuICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG5cbiAgICBpZiAoIXRoaXMuZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKGZyYWdtZW50U2hhZGVyLCB0aGlzLmdsLkNPTVBJTEVfU1RBVFVTKSkge1xuICAgICAgY29uc3Qgc291cmNlID0gZnJhZ21lbnRTaGFkZXJTb3VyY2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgbGV0IGRiZ01zZyA9IFwiRVJST1I6IENvdWxkIG5vdCBidWlsZCBzaGFkZXIgKGZhdGFsKS5cXG5cXG4tLS0tLS0tLS0tLS0tLS0tLS0gS0VSTkVMIENPREUgRFVNUCAtLS0tLS0tLS0tLS0tLS0tLS1cXG5cIlxuXG4gICAgICBmb3IgKGxldCBsID0gMDsgbCA8IHNvdXJjZS5sZW5ndGg7IGwrKylcbiAgICAgICAgZGJnTXNnICs9IGAke2wgKyAxfT4gJHtzb3VyY2VbbF19XFxuYDtcblxuICAgICAgZGJnTXNnICs9IFwiXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVSUk9SICBMT0cgLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIgKyB0aGlzLmdsLmdldFNoYWRlckluZm9Mb2coZnJhZ21lbnRTaGFkZXIpO1xuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZGJnTXNnKTtcbiAgICB9XG5cbiAgICBwcm9ncmFtLmdsUHJvZ3JhbSA9IHRoaXMuZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0uZ2xQcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xuICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0uZ2xQcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XG4gICAgdGhpcy5nbC5saW5rUHJvZ3JhbShwcm9ncmFtLmdsUHJvZ3JhbSk7XG4gICAgdGhpcy5nbC51c2VQcm9ncmFtKHByb2dyYW0uZ2xQcm9ncmFtKTtcblxuICAgIGlmICghdGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0uZ2xQcm9ncmFtLCB0aGlzLmdsLkxJTktfU1RBVFVTKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxpbmsgR0xTTCBwcm9ncmFtIGNvZGUuJyk7XG5cbiAgICBsZXQgdGV4dHVyZUluZGV4ID0gMDtcblxuICAgIGZvciAoY29uc3QgaW5wdXQgb2YgcHJvZ3JhbS5pbnB1dFRleHR1cmVzKSB7XG4gICAgICBjb25zdCBsb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0uZ2xQcm9ncmFtLCBgX2lucHV0JHt0ZXh0dXJlSW5kZXh9YCk7XG4gICAgICB0aGlzLmdsLnVuaWZvcm0xaShsb2NhdGlvbiwgdGV4dHVyZUluZGV4KTtcbiAgICAgIHRleHR1cmVJbmRleCsrO1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgdW5pZm9ybU5hbWUgaW4gcHJvZ3JhbS51bmlmb3JtVGV4dHVyZXMpIHtcbiAgICAgIHByb2dyYW0udW5pZm9ybVRleHR1cmVzW3VuaWZvcm1OYW1lXS5pbmRleCA9IHRleHR1cmVJbmRleDtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbS5nbFByb2dyYW0sIHVuaWZvcm1OYW1lKTtcbiAgICAgIHRoaXMuZ2wudW5pZm9ybTFpKGxvY2F0aW9uLCB0ZXh0dXJlSW5kZXgpO1xuICAgICAgdGV4dHVyZUluZGV4Kys7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCB1bmlmb3JtTmFtZSBpbiBwcm9ncmFtLnVuaWZvcm1zKSB7XG4gICAgICBjb25zdCB7IHR5cGUsIHZhbHVlIH0gPSBwcm9ncmFtLnVuaWZvcm1zW3VuaWZvcm1OYW1lXTtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gcHJvZ3JhbS51bmlmb3Jtc1t1bmlmb3JtTmFtZV0ubG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLmdsUHJvZ3JhbSwgdW5pZm9ybU5hbWUpO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgdGhpcy5fc2V0VW5pZm9ybSh0eXBlLCBsb2NhdGlvbiwgdmFsdWUpO1xuXG4gICAgICBkZWxldGUgcHJvZ3JhbS51bmlmb3Jtc1t1bmlmb3JtTmFtZV0udmFsdWU7XG4gICAgfVxuXG4gICAgcHJvZ3JhbS5rZXJuZWxTaXplTG9jYXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLmdsUHJvZ3JhbSwgJ2tlcm5lbFNpemUnKTtcbiAgICB0aGlzLmdsLnVuaWZvcm0yaShwcm9ncmFtLmtlcm5lbFNpemVMb2NhdGlvbiwgcHJvZ3JhbS5pbnB1dFdpZHRoLCBwcm9ncmFtLmlucHV0SGVpZ2h0KTtcblxuICAgIHByb2dyYW0ucG9zaXRpb25Mb2NhdGlvbiA9IHRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbS5nbFByb2dyYW0sICdwb3NpdGlvbicpO1xuICAgIHByb2dyYW0udGV4dHVyZUxvY2F0aW9uID0gdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLmdsUHJvZ3JhbSwgJ3RleHR1cmUnKTtcblxuICAgIHByb2dyYW0uZnJhbWVCdWZmZXIgPSB0aGlzLmdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgdGhpcy5fcHJlcGFyZVByb2dyYW1PdXRwdXQocHJvZ3JhbSk7XG5cbiAgICByZXR1cm4gcHJvZ3JhbTtcbiAgfVxuXG4gIF9wcmVwYXJlUHJvZ3JhbUlucHV0cyhwcm9ncmFtLCBpbnB1dHMpIHtcbiAgICBpZiAocHJvZ3JhbS5pbnB1dFRleHR1cmVzKVxuICAgICAgcHJvZ3JhbS5pbnB1dFRleHR1cmVzLmZvckVhY2godCA9PiB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodCkpO1xuXG4gICAgcHJvZ3JhbS5pbnB1dFRleHR1cmVzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgZGF0YV0gb2YgaW5wdXRzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGRhdGEuZ3BncHVTaXplID09PSB1bmRlZmluZWQgfHwgZGF0YS5ncGdwdVN0cmlkZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dQR1BVIGlucHV0cyBtdXN0IGJlIGNyZWF0ZWQgYnkgdGhlIGBhbGxvY2AgZnVuY3Rpb24uJyk7XG5cbiAgICAgIGNvbnN0IHNpemUgPSBNYXRoLnNxcnQoZGF0YS5sZW5ndGggLyBkYXRhLmdwZ3B1U3RyaWRlKTtcbiAgICAgIGlmIChzaXplIDw9IDAgfHwgc2l6ZSAlIDEgIT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHUEdQVSBpbnB1dCBzaXplIGlzIGV4cGVjdGVkIHRvIGJlIGEgcGVyZmVjdCBzcXVhcmUuJyk7XG5cbiAgICAgIGlmIChwcm9ncmFtLmlucHV0V2lkdGggPT09IHVuZGVmaW5lZCB8fCBwcm9ncmFtLmlucHV0SGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvZ3JhbS5pbnB1dFdpZHRoID0gc2l6ZTtcbiAgICAgICAgcHJvZ3JhbS5pbnB1dEhlaWdodCA9IHNpemU7XG4gICAgICAgIHByb2dyYW0uaW5wdXREYXRhU2l6ZSA9IGRhdGEuZ3BncHVTaXplO1xuICAgICAgfSBlbHNlIGlmIChzaXplICE9IHByb2dyYW0uaW5wdXRXaWR0aCB8fCBzaXplICE9IHByb2dyYW0uaW5wdXRIZWlnaHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbGwgR1BHUFUgaW5wdXRzIG11c3QgYmUgb2YgdGhlIHNhbWUgc2l6ZS4gUmVjZWl2ZWQgJHtkYXRhLmdwZ3B1U2l6ZX0gKGludGVybmFsICR7c2l6ZSAqIHNpemV9KSBidXQgZXhwZWN0ZWQgJHtwcm9ncmFtLmlucHV0RGF0YVNpemV9IChpbnRlcm5hbCAke3Byb2dyYW0uaW5wdXRXaWR0aCAqIHByb2dyYW0uaW5wdXRIZWlnaHR9KS5gKTtcbiAgICAgIH1cblxuICAgICAgcHJvZ3JhbS5pbnB1dFRleHR1cmVzLnB1c2godGhpcy5fY3JlYXRlVGV4dHVyZShkYXRhLCBzaXplLCBzaXplLCBkYXRhLmdwZ3B1U3RyaWRlKSk7XG4gICAgfVxuICB9XG5cbiAgX3ByZXBhcmVQcm9ncmFtT3V0cHV0KHByb2dyYW0pIHtcbiAgICB0aGlzLmdsLmJpbmRGcmFtZWJ1ZmZlcih0aGlzLmdsLkZSQU1FQlVGRkVSLCBwcm9ncmFtLmZyYW1lQnVmZmVyKTtcblxuICAgIGNvbnN0IG91dHB1dFRleHR1cmUgPSB0aGlzLl9jcmVhdGVUZXh0dXJlKG51bGwsIHByb2dyYW0uaW5wdXRXaWR0aCwgcHJvZ3JhbS5pbnB1dEhlaWdodCwgNCwgcHJvZ3JhbS5vdXRwdXQpO1xuXG4gICAgaWYgKHByb2dyYW0ub3V0cHV0ICYmIHByb2dyYW0ub3V0cHV0LnRleHR1cmVUeXBlICE9PSAnM0QnICYmIHByb2dyYW0ub3V0cHV0LnRleHR1cmVUeXBlICE9PSAnMkRBcnJheScpIHtcbiAgICAgIHRoaXMuZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQodGhpcy5nbC5GUkFNRUJVRkZFUiwgdGhpcy5nbC5DT0xPUl9BVFRBQ0hNRU5UMCwgdGhpcy5nbC5URVhUVVJFXzJELCBvdXRwdXRUZXh0dXJlLCAwKTtcbiAgICAgIGNvbnN0IGZyYW1lQnVmZmVyU3RhdHVzID0gKHRoaXMuZ2wuY2hlY2tGcmFtZWJ1ZmZlclN0YXR1cyh0aGlzLmdsLkZSQU1FQlVGRkVSKSA9PSB0aGlzLmdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKTtcbiAgICAgIGlmICghZnJhbWVCdWZmZXJTdGF0dXMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYXR0YWNoaW5nIGZsb2F0IHRleHR1cmUgdG8gZnJhbWVidWZmZXIuIFlvdXIgZGV2aWNlIGlzIHByb2JhYmx5IGluY29tcGF0aWJsZS4nKTtcbiAgICB9XG5cbiAgICBpZiAocHJvZ3JhbS5vdXRwdXRUZXh0dXJlICE9PSB1bmRlZmluZWQpXG4gICAgICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUocHJvZ3JhbS5vdXRwdXRUZXh0dXJlKTtcbiAgICBwcm9ncmFtLm91dHB1dFRleHR1cmUgPSBvdXRwdXRUZXh0dXJlO1xuXG4gICAgaWYgKHByb2dyYW0ub3V0cHV0ICYmIHByb2dyYW0ub3V0cHV0Lm5hbWUpXG4gICAgICB0aGlzLm91dHB1dFRleHR1cmVzW3Byb2dyYW0ub3V0cHV0Lm5hbWVdID0gb3V0cHV0VGV4dHVyZTtcbiAgfVxuXG4gIF9zZXRVbmlmb3JtKHR5cGUsIGxvY2F0aW9uLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnaW50JzogdGhpcy5nbC51bmlmb3JtMWkobG9jYXRpb24sIHZhbHVlKTsgYnJlYWs7XG4gICAgICBjYXNlICdmbG9hdCc6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdGhpcy5nbC51bmlmb3JtMWZ2KGxvY2F0aW9uLCB2YWx1ZSkgOiB0aGlzLmdsLnVuaWZvcm0xZihsb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcbiAgICAgIGNhc2UgJ3ZlYzInOiB0aGlzLmdsLnVuaWZvcm0yZnYobG9jYXRpb24sIHZhbHVlKTsgYnJlYWs7XG4gICAgICBjYXNlICd2ZWMzJzogdGhpcy5nbC51bmlmb3JtM2Z2KGxvY2F0aW9uLCB2YWx1ZSk7IGJyZWFrO1xuICAgICAgY2FzZSAndmVjNCc6IHRoaXMuZ2wudW5pZm9ybTRmdihsb2NhdGlvbiwgdmFsdWUpOyBicmVhaztcbiAgICAgIGNhc2UgJ21hdDMnOiB0aGlzLmdsLnVuaWZvcm1NYXRyaXgzZnYobG9jYXRpb24sIHZhbHVlKTsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gdW5pZm9ybSB0eXBlICR7dHlwZX0uYCk7XG4gICAgfVxuICB9XG5cbiAgX25ld0J1ZmZlcihkYXRhLCBrbGFzcywgdGFyZ2V0KSB7XG4gICAgY29uc3QgYnVmID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcblxuICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcigodGFyZ2V0IHx8IHRoaXMuZ2wuQVJSQVlfQlVGRkVSKSwgYnVmKTtcbiAgICB0aGlzLmdsLmJ1ZmZlckRhdGEoKHRhcmdldCB8fCB0aGlzLmdsLkFSUkFZX0JVRkZFUiksIG5ldyAoa2xhc3MgfHwgRmxvYXQzMkFycmF5KShkYXRhKSwgdGhpcy5nbC5TVEFUSUNfRFJBVyk7XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgX2NyZWF0ZVRleHR1cmUoZGF0YSwgd2lkdGgsIGhlaWdodCwgY2hhbm5lbHMsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHRleHR1cmUgPSB0aGlzLmdsLmNyZWF0ZVRleHR1cmUoKTtcblxuICAgIGxldCBpbnRlcm5hbEZvcm1hdCwgZm9ybWF0O1xuXG4gICAgc3dpdGNoIChjaGFubmVscykge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBpbnRlcm5hbEZvcm1hdCA9IHRoaXMuZ2wuUjMyRjtcbiAgICAgICAgZm9ybWF0ID0gdGhpcy5nbC5SRUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBpbnRlcm5hbEZvcm1hdCA9IHRoaXMuZ2wuUkczMkY7XG4gICAgICAgIGZvcm1hdCA9IHRoaXMuZ2wuUkc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBpbnRlcm5hbEZvcm1hdCA9IHRoaXMuZ2wuUkdCMzJGO1xuICAgICAgICBmb3JtYXQgPSB0aGlzLmdsLlJHQjtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIGludGVybmFsRm9ybWF0ID0gdGhpcy5nbC5SR0JBMzJGO1xuICAgICAgICBmb3JtYXQgPSB0aGlzLmdsLlJHQkE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3coXCJUZXh0dXJlIGNoYW5uZWxzIG11c3QgYmV0d2VlbiAxIGFuZCA0LlwiKTtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBvcHRpb25zLnRleHR1cmVUeXBlID09ICczRCcgPyB0aGlzLmdsLlRFWFRVUkVfM0QgOiBvcHRpb25zLnRleHR1cmVUeXBlID09ICcyREFycmF5JyA/IHRoaXMuZ2wuVEVYVFVSRV8yRF9BUlJBWSA6IHRoaXMuZ2wuVEVYVFVSRV8yRDtcblxuICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGFyZ2V0LCB0ZXh0dXJlKTtcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLmdsLkNMQU1QX1RPX0VER0UpO1xuICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0YXJnZXQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfUiwgdGhpcy5nbC5DTEFNUF9UT19FREdFKTtcbiAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGFyZ2V0LCB0aGlzLmdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgb3B0aW9ucy5maWx0ZXIgPT0gJ2xpbmVhcicgPyB0aGlzLmdsLkxJTkVBUiA6IHRoaXMuZ2wuTkVBUkVTVCk7XG4gICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRhcmdldCwgdGhpcy5nbC5URVhUVVJFX01BR19GSUxURVIsIG9wdGlvbnMuZmlsdGVyID09ICdsaW5lYXInID8gdGhpcy5nbC5MSU5FQVIgOiB0aGlzLmdsLk5FQVJFU1QpO1xuXG4gICAgaWYgKG9wdGlvbnMudGV4dHVyZVR5cGUgPT0gJzNEJyB8fCBvcHRpb25zLnRleHR1cmVUeXBlID09ICcyREFycmF5Jykge1xuICAgICAgdGhpcy5nbC50ZXhJbWFnZTNEKHRhcmdldCwgMCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMuZGVwdGgsIDAsIGZvcm1hdCwgdGhpcy5nbC5GTE9BVCwgZGF0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2wudGV4SW1hZ2UyRCh0YXJnZXQsIDAsIGludGVybmFsRm9ybWF0LCB3aWR0aCwgaGVpZ2h0LCAwLCBmb3JtYXQsIHRoaXMuZ2wuRkxPQVQsIGRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGFyZ2V0LCBudWxsKTtcblxuICAgIHJldHVybiB0ZXh0dXJlO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/GPGPU.js\n");

/***/ }),

/***/ "./js/autonomy/DynamicObstacle.js":
/*!****************************************!*\
  !*** ./js/autonomy/DynamicObstacle.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DynamicObstacle; });\n// Half width and half height\nconst VEHICLE_SIZE = { w: 2.5, h: 1 };\nconst CYCLIST_SIZE = { w: 1.2, h: 0.6 };\nconst PEDESTRIAN_SIZE = { w: 0.6, h: 0.6 };\n\nclass DynamicObstacle {\n  static hydrate(obj) {\n    Object.setPrototypeOf(obj, DynamicObstacle.prototype);\n    Object.setPrototypeOf(obj.startPos, THREE.Vector2.prototype);\n    Object.setPrototypeOf(obj.velocity, THREE.Vector2.prototype);\n  }\n\n  constructor(type, startPos, velocity, parallel) {\n    this.type = type;\n    this.startPos = startPos;\n    this.velocity = velocity;\n    this.parallel = parallel;\n\n    switch (type) {\n        case 'cyclist':\n          this.size = Object.assign({}, CYCLIST_SIZE);\n          break;\n\n        case 'pedestrian':\n          this.size = Object.assign({}, PEDESTRIAN_SIZE);\n          break;\n\n        default:\n          this.size = Object.assign({}, VEHICLE_SIZE);\n    }\n\n    if (!parallel)\n      [this.size.w, this.size.h] = [this.size.h, this.size.w];\n  }\n\n  positionAtTime(time) {\n    return this.velocity.clone().multiplyScalar(time).add(this.startPos);\n  }\n\n  positionsInTimeRange(startTime, endTime, numFrames) {\n    const dt = (endTime - startTime) / numFrames;\n    const positions = [];\n    let time = startTime;\n\n    for (let i = 0; i <= numFrames; i++) {\n      positions.push(this.positionAtTime(time));\n      time += dt;\n    }\n\n    return positions;\n  }\n\n  verticesInTimeRange(startTime, endTime, config) {\n    const positions = this.positionsInTimeRange(startTime, endTime, config.numDynamicSubframes);\n    const vertices = [];\n\n    // Hazard dilation (drawn behind, z = 0.75)\n    const hazardHalfWidth = this.size.w + config.dynamicHazardDilationS + config.collisionDilationS;\n    const hazardHalfHeight = this.size.h + config.dynamicHazardDilationL + config.collisionDilationL;\n\n    positions.forEach(p => {\n      const v1 = [-hazardHalfWidth + p.x, hazardHalfHeight + p.y];\n      const v2 = [hazardHalfWidth + p.x, hazardHalfHeight + p.y];\n      const v3 = [hazardHalfWidth + p.x, -hazardHalfHeight + p.y];\n      const v4 = [-hazardHalfWidth + p.x, -hazardHalfHeight + p.y];\n\n      vertices.push(\n        v1[0], v1[1], 0.75,\n        v2[0], v2[1], 0.75,\n        v3[0], v3[1], 0.75,\n        v3[0], v3[1], 0.75,\n        v4[0], v4[1], 0.75,\n        v1[0], v1[1], 0.75\n      );\n    });\n    \n    // Collision dilation (drawn in front, z = 0.25)\n    const collisionHalfWidth = this.size.w + config.collisionDilationS;\n    const collisionHalfHeight = this.size.h + config.collisionDilationL;\n\n    positions.forEach(p => {\n      const v1 = [-collisionHalfWidth + p.x, collisionHalfHeight + p.y];\n      const v2 = [collisionHalfWidth + p.x, collisionHalfHeight + p.y];\n      const v3 = [collisionHalfWidth + p.x, -collisionHalfHeight + p.y];\n      const v4 = [-collisionHalfWidth + p.x, -collisionHalfHeight + p.y];\n\n      vertices.push(\n        v1[0], v1[1], 0.25,\n        v2[0], v2[1], 0.25,\n        v3[0], v3[1], 0.25,\n        v3[0], v3[1], 0.25,\n        v4[0], v4[1], 0.25,\n        v1[0], v1[1], 0.25\n      );\n    });\n\n    return vertices;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9EeW5hbWljT2JzdGFjbGUuanM/MmU3MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFBQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEIseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vanMvYXV0b25vbXkvRHluYW1pY09ic3RhY2xlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSGFsZiB3aWR0aCBhbmQgaGFsZiBoZWlnaHRcbmNvbnN0IFZFSElDTEVfU0laRSA9IHsgdzogMi41LCBoOiAxIH07XG5jb25zdCBDWUNMSVNUX1NJWkUgPSB7IHc6IDEuMiwgaDogMC42IH07XG5jb25zdCBQRURFU1RSSUFOX1NJWkUgPSB7IHc6IDAuNiwgaDogMC42IH07XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIER5bmFtaWNPYnN0YWNsZSB7XG4gIHN0YXRpYyBoeWRyYXRlKG9iaikge1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihvYmosIER5bmFtaWNPYnN0YWNsZS5wcm90b3R5cGUpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihvYmouc3RhcnRQb3MsIFRIUkVFLlZlY3RvcjIucHJvdG90eXBlKTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yob2JqLnZlbG9jaXR5LCBUSFJFRS5WZWN0b3IyLnByb3RvdHlwZSk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcih0eXBlLCBzdGFydFBvcywgdmVsb2NpdHksIHBhcmFsbGVsKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnN0YXJ0UG9zID0gc3RhcnRQb3M7XG4gICAgdGhpcy52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgIHRoaXMucGFyYWxsZWwgPSBwYXJhbGxlbDtcblxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdjeWNsaXN0JzpcbiAgICAgICAgICB0aGlzLnNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBDWUNMSVNUX1NJWkUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3BlZGVzdHJpYW4nOlxuICAgICAgICAgIHRoaXMuc2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIFBFREVTVFJJQU5fU0laRSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aGlzLnNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBWRUhJQ0xFX1NJWkUpO1xuICAgIH1cblxuICAgIGlmICghcGFyYWxsZWwpXG4gICAgICBbdGhpcy5zaXplLncsIHRoaXMuc2l6ZS5oXSA9IFt0aGlzLnNpemUuaCwgdGhpcy5zaXplLnddO1xuICB9XG5cbiAgcG9zaXRpb25BdFRpbWUodGltZSkge1xuICAgIHJldHVybiB0aGlzLnZlbG9jaXR5LmNsb25lKCkubXVsdGlwbHlTY2FsYXIodGltZSkuYWRkKHRoaXMuc3RhcnRQb3MpO1xuICB9XG5cbiAgcG9zaXRpb25zSW5UaW1lUmFuZ2Uoc3RhcnRUaW1lLCBlbmRUaW1lLCBudW1GcmFtZXMpIHtcbiAgICBjb25zdCBkdCA9IChlbmRUaW1lIC0gc3RhcnRUaW1lKSAvIG51bUZyYW1lcztcbiAgICBjb25zdCBwb3NpdGlvbnMgPSBbXTtcbiAgICBsZXQgdGltZSA9IHN0YXJ0VGltZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG51bUZyYW1lczsgaSsrKSB7XG4gICAgICBwb3NpdGlvbnMucHVzaCh0aGlzLnBvc2l0aW9uQXRUaW1lKHRpbWUpKTtcbiAgICAgIHRpbWUgKz0gZHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9ucztcbiAgfVxuXG4gIHZlcnRpY2VzSW5UaW1lUmFuZ2Uoc3RhcnRUaW1lLCBlbmRUaW1lLCBjb25maWcpIHtcbiAgICBjb25zdCBwb3NpdGlvbnMgPSB0aGlzLnBvc2l0aW9uc0luVGltZVJhbmdlKHN0YXJ0VGltZSwgZW5kVGltZSwgY29uZmlnLm51bUR5bmFtaWNTdWJmcmFtZXMpO1xuICAgIGNvbnN0IHZlcnRpY2VzID0gW107XG5cbiAgICAvLyBIYXphcmQgZGlsYXRpb24gKGRyYXduIGJlaGluZCwgeiA9IDAuNzUpXG4gICAgY29uc3QgaGF6YXJkSGFsZldpZHRoID0gdGhpcy5zaXplLncgKyBjb25maWcuZHluYW1pY0hhemFyZERpbGF0aW9uUyArIGNvbmZpZy5jb2xsaXNpb25EaWxhdGlvblM7XG4gICAgY29uc3QgaGF6YXJkSGFsZkhlaWdodCA9IHRoaXMuc2l6ZS5oICsgY29uZmlnLmR5bmFtaWNIYXphcmREaWxhdGlvbkwgKyBjb25maWcuY29sbGlzaW9uRGlsYXRpb25MO1xuXG4gICAgcG9zaXRpb25zLmZvckVhY2gocCA9PiB7XG4gICAgICBjb25zdCB2MSA9IFstaGF6YXJkSGFsZldpZHRoICsgcC54LCBoYXphcmRIYWxmSGVpZ2h0ICsgcC55XTtcbiAgICAgIGNvbnN0IHYyID0gW2hhemFyZEhhbGZXaWR0aCArIHAueCwgaGF6YXJkSGFsZkhlaWdodCArIHAueV07XG4gICAgICBjb25zdCB2MyA9IFtoYXphcmRIYWxmV2lkdGggKyBwLngsIC1oYXphcmRIYWxmSGVpZ2h0ICsgcC55XTtcbiAgICAgIGNvbnN0IHY0ID0gWy1oYXphcmRIYWxmV2lkdGggKyBwLngsIC1oYXphcmRIYWxmSGVpZ2h0ICsgcC55XTtcblxuICAgICAgdmVydGljZXMucHVzaChcbiAgICAgICAgdjFbMF0sIHYxWzFdLCAwLjc1LFxuICAgICAgICB2MlswXSwgdjJbMV0sIDAuNzUsXG4gICAgICAgIHYzWzBdLCB2M1sxXSwgMC43NSxcbiAgICAgICAgdjNbMF0sIHYzWzFdLCAwLjc1LFxuICAgICAgICB2NFswXSwgdjRbMV0sIDAuNzUsXG4gICAgICAgIHYxWzBdLCB2MVsxXSwgMC43NVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBDb2xsaXNpb24gZGlsYXRpb24gKGRyYXduIGluIGZyb250LCB6ID0gMC4yNSlcbiAgICBjb25zdCBjb2xsaXNpb25IYWxmV2lkdGggPSB0aGlzLnNpemUudyArIGNvbmZpZy5jb2xsaXNpb25EaWxhdGlvblM7XG4gICAgY29uc3QgY29sbGlzaW9uSGFsZkhlaWdodCA9IHRoaXMuc2l6ZS5oICsgY29uZmlnLmNvbGxpc2lvbkRpbGF0aW9uTDtcblxuICAgIHBvc2l0aW9ucy5mb3JFYWNoKHAgPT4ge1xuICAgICAgY29uc3QgdjEgPSBbLWNvbGxpc2lvbkhhbGZXaWR0aCArIHAueCwgY29sbGlzaW9uSGFsZkhlaWdodCArIHAueV07XG4gICAgICBjb25zdCB2MiA9IFtjb2xsaXNpb25IYWxmV2lkdGggKyBwLngsIGNvbGxpc2lvbkhhbGZIZWlnaHQgKyBwLnldO1xuICAgICAgY29uc3QgdjMgPSBbY29sbGlzaW9uSGFsZldpZHRoICsgcC54LCAtY29sbGlzaW9uSGFsZkhlaWdodCArIHAueV07XG4gICAgICBjb25zdCB2NCA9IFstY29sbGlzaW9uSGFsZldpZHRoICsgcC54LCAtY29sbGlzaW9uSGFsZkhlaWdodCArIHAueV07XG5cbiAgICAgIHZlcnRpY2VzLnB1c2goXG4gICAgICAgIHYxWzBdLCB2MVsxXSwgMC4yNSxcbiAgICAgICAgdjJbMF0sIHYyWzFdLCAwLjI1LFxuICAgICAgICB2M1swXSwgdjNbMV0sIDAuMjUsXG4gICAgICAgIHYzWzBdLCB2M1sxXSwgMC4yNSxcbiAgICAgICAgdjRbMF0sIHY0WzFdLCAwLjI1LFxuICAgICAgICB2MVswXSwgdjFbMV0sIDAuMjVcbiAgICAgICk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdmVydGljZXM7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./js/autonomy/DynamicObstacle.js\n");

/***/ }),

/***/ "./js/autonomy/LanePath.js":
/*!*********************************!*\
  !*** ./js/autonomy/LanePath.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return LanePath; });\nconst halfLaneWidth = 3.7;\n\nconst centerlineGeometry = new THREE.Geometry();\nconst leftBoundaryGeometry = new THREE.Geometry();\nconst rightBoundaryGeometry = new THREE.Geometry();\n\nclass LanePath {\n  static hydrate(obj) {\n    Object.setPrototypeOf(obj, LanePath.prototype);\n  }\n\n  constructor() {\n console.log('snir');\n    this.anchors = [];\n    this.centerlines = [];\n    this.sampleLengths = [];\n    this.arcLengths = [];\n    this.leftBoundaries = [];\n    this.rightBoundaries = [];\n  }\n\n  get centerline() {\n    return [].concat(...this.centerlines);\n  }\n\n  get leftBoundary() {\n    return [].concat(...this.leftBoundaries);\n  }\n\n  get rightBoundary() {\n    return [].concat(...this.rightBoundaries);\n  }\n\n  get arcLength() {\n    return this.arcLengths.reduce((sum, l) => sum + l, 0);\n  }\n\n  sampleStations(startStation, num, interval) {\n    const samples = [];\n    let anchorIndex = 0;\n    let sampleIndex = 0;\n    let totalLength = 0;\n    let nextStation = startStation;\n\n    while (totalLength + this.arcLengths[anchorIndex] < nextStation) {\n      totalLength += this.arcLengths[anchorIndex];\n\n      if (++anchorIndex >= this.arcLengths.length)\n        return samples;\n    }\n\n    for (let i = 0; i < num; i++) {\n      let length = this.sampleLengths[anchorIndex][sampleIndex];\n      while (totalLength + length < nextStation) {\n        totalLength += length;\n\n        if (++sampleIndex >= this.sampleLengths[anchorIndex].length) {\n          sampleIndex = 0;\n\n          if (++anchorIndex >= this.sampleLengths.length)\n            return samples;\n        }\n\n        length = this.sampleLengths[anchorIndex][sampleIndex];\n      }\n\n      const [p0, p1, p2, p3] = this.anchorsForSplineIndex(anchorIndex);\n      const weight = (sampleIndex + (nextStation - totalLength) / length) / this.sampleLengths[anchorIndex].length;\n      const pos = catmullRomVec(weight, p0, p1, p2, p3);\n      const tangent = tangentAt(weight, p0, p1, p2, p3);\n      const rot = Math.atan2(tangent.y, tangent.x);\n      const curv = curvatureAt(weight, p0, p1, p2, p3);\n\n      samples.push({ pos, rot, curv });\n      nextStation += interval;\n    }\n\n    return samples;\n  }\n\n  stationLatitudeFromPosition(position, aroundAnchorIndex = null) {\n    const [anchorIndex, sampleIndex, sampleStation, prevSampleStation] = this._findClosestSample(position, aroundAnchorIndex);\n\n    if (anchorIndex === undefined) return [0, 0, 0];\n\n    let prevPoint;\n    let nextPoint;\n    let prevStation;\n    let nextStation;\n\n    if (anchorIndex == 0 && sampleIndex == 0) {\n      prevPoint = this.centerlines[anchorIndex][sampleIndex];\n      nextPoint = this.centerlines[anchorIndex][sampleIndex + 1];\n      prevStation = 0;\n      nextStation = this.sampleLengths[anchorIndex][sampleIndex];\n    } else if (anchorIndex == this.centerlines.length - 1 && sampleIndex == this.centerlines[anchorIndex].length - 1) {\n      prevPoint = this.centerlines[anchorIndex][sampleIndex - 1];\n      nextPoint = this.centerlines[anchorIndex][sampleIndex];\n      prevStation = prevSampleStation;\n      nextStation = sampleStation;\n    } else {\n      prevPoint = sampleIndex == 0 ? this.centerlines[anchorIndex - 1][this.centerlines[anchorIndex - 1].length - 1] : this.centerlines[anchorIndex][sampleIndex - 1];\n      nextPoint = sampleIndex == this.centerlines[anchorIndex].length - 1 ? this.centerlines[anchorIndex + 1][0] : this.centerlines[anchorIndex][sampleIndex + 1];\n\n      const possibleNext = this.centerlines[anchorIndex][sampleIndex];\n      const possibleProgress = position.clone().sub(prevPoint).dot(possibleNext.clone().sub(prevPoint)) / prevPoint.distanceToSquared(possibleNext);\n\n      if (possibleProgress < 1) {\n        nextPoint = possibleNext;\n        prevStation = prevSampleStation;\n        nextStation = sampleStation;\n      } else {\n        prevPoint = possibleNext;\n        prevStation = sampleStation;\n        nextStation = sampleStation + this.sampleLengths[anchorIndex][sampleIndex];\n      }\n    }\n\n    const progress = Math.clamp(position.clone().sub(prevPoint).dot(nextPoint.clone().sub(prevPoint)) / prevPoint.distanceToSquared(nextPoint), 0, 1);\n    const projectedPosition = nextPoint.clone().sub(prevPoint).multiplyScalar(progress).add(prevPoint);\n\n    const station = prevStation + (nextStation - prevStation) * progress;\n    const latitude = Math.sign((nextPoint.x - prevPoint.x) * (position.y - prevPoint.y) - (nextPoint.y - prevPoint.y) * (position.x - prevPoint.x)) * position.distanceTo(projectedPosition);\n\n    return [station, latitude, anchorIndex];\n  }\n\n  _findClosestSample(position, aroundAnchorIndex = null) {\n    let closest = Number.POSITIVE_INFINITY;\n    let bestAnchorIndex;\n    let bestSampleIndex;\n    let bestStation;\n    let bestPrevStation;\n\n    let currStation = 0;\n    let prevStation = 0;\n\n    let startAnchorIndex = 0;\n    let endAnchorIndex = this.centerlines.length - 1;\n\n    if (aroundAnchorIndex !== null) {\n      startAnchorIndex = Math.max(0, aroundAnchorIndex - 2);\n      endAnchorIndex = Math.min(this.centerlines.length - 1, aroundAnchorIndex + 2);\n    }\n\n    if (startAnchorIndex > 0) {\n      for (let anchorIndex = 0; anchorIndex < startAnchorIndex; anchorIndex++) {\n        currStation += this.arcLengths[anchorIndex];\n      }\n\n      prevStation = currStation - this.sampleLengths[startAnchorIndex - 1][this.sampleLengths[startAnchorIndex - 1].length - 1];\n    }\n\n    for (let anchorIndex = startAnchorIndex; anchorIndex <= endAnchorIndex; anchorIndex++) {\n      const centerline = this.centerlines[anchorIndex];\n      for (let sampleIndex = 0; sampleIndex < centerline.length; sampleIndex++) {\n        const distSq = position.distanceToSquared(centerline[sampleIndex]);\n        if (distSq < closest) {\n          closest = distSq;\n          bestAnchorIndex = anchorIndex;\n          bestSampleIndex = sampleIndex;\n          bestStation = currStation;\n          bestPrevStation = prevStation;\n        }\n\n        prevStation = currStation;\n        currStation += this.sampleLengths[anchorIndex][sampleIndex];\n      }\n    }\n\n    return [bestAnchorIndex, bestSampleIndex, bestStation, bestPrevStation];\n  }\n\n  addAnchor(position, resample = true) {\n    const index = this.anchors.push(position) - 1;\n\n    if (resample) {\n      for (let i = index - 2; i < index; i++)\n        this.resample(i);\n    }\n  }\n\n  updateAnchor(index, position) {\n    this.anchors[index] = position;\n\n    for (let i = index - 2; i <= index + 1; i++)\n      this.resample(i);\n  }\n\n  removeAnchor(index) {\n    if (index < 0 || index >= this.anchors.length) return;\n\n    this.anchors.splice(index, 1);\n\n    const segmentIndex = index < this.anchors.length ? index : index - 1;\n    this.centerlines.splice(segmentIndex, 1);\n    this.sampleLengths.splice(segmentIndex, 1);\n    this.leftBoundaries.splice(segmentIndex, 1);\n    this.rightBoundaries.splice(segmentIndex, 1);\n    this.arcLengths.splice(segmentIndex, 1);\n\n    for (let i = segmentIndex - 2; i <= segmentIndex; i++)\n      this.resample(i);\n  }\n\n  resample(index) {\n    if (index < 0 || index > this.anchors.length - 2) return;\n\n    const [p0, p1, p2, p3] = this.anchorsForSplineIndex(index);\n    const points = [];\n    const lengths = [];\n    const leftBoundary = [];\n    const rightBoundary = [];\n    let prevPoint = null;\n\n    const pointsPerSegment = Math.max(10, Math.ceil(p1.distanceTo(p2) / 1));\n    const numPoints = index == this.anchors.length - 2 ? pointsPerSegment + 1 : pointsPerSegment;\n\n    for (let i = 0; i < numPoints; i++) {\n      const t = i / pointsPerSegment;\n      const point = catmullRomVec(t, p0, p1, p2, p3);\n      points.push(point);\n\n      if (prevPoint != null)\n        lengths.push(prevPoint.distanceTo(point));\n      prevPoint = point;\n\n      const tangent = tangentAt(t, p0, p1, p2, p3);\n      const normal = new THREE.Vector2(-tangent.y, tangent.x);\n\n      leftBoundary.push(normal.clone().multiplyScalar(-halfLaneWidth).add(point));\n      rightBoundary.push(normal.clone().multiplyScalar(halfLaneWidth).add(point));\n    }\n\n    lengths.push(prevPoint.distanceTo(p2));\n\n    this.centerlines[index] = points;\n    this.sampleLengths[index] = lengths;\n    this.leftBoundaries[index] = leftBoundary;\n    this.rightBoundaries[index] = rightBoundary;\n    this.arcLengths[index] = lengths.reduce((sum, l) => sum + l, 0);\n  }\n\n  resampleAll() {\n    for (let i = 0; i < this.anchors.length; i++)\n      this.resample(i);\n  }\n\n  anchorsForSplineIndex(index) {\n    let p;\n    if (index == 0)\n      p = [this.anchors[0]].concat(this.anchors.slice(0, 3));\n    else\n      p = this.anchors.slice(index - 1, index + 3);\n\n    if (p[3] === undefined)\n      p[3] = p[2];\n\n    return p;\n  }\n}\n\nfunction catmullRom(t, p0, p1, p2, p3) {\n  const v0 = (p2 - p0) * 0.5;\n  const v1 = (p3 - p1) * 0.5;\n  const t2 = t * t;\n  const t3 = t * t2;\n  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n\nfunction catmullRomVec(t, p0, p1, p2, p3) {\n  return new THREE.Vector2(catmullRom(t, p0.x, p1.x, p2.x, p3.x), catmullRom(t, p0.y, p1.y, p2.y, p3.y));\n}\n\nfunction tangentAt(t, p0, p1, p2, p3) {\n  const delta = 0.0001;\n  let t1 = t - delta;\n  let t2 = t + delta;\n\n  if (t1 < 0) t1 = 0;\n  if (t2 > 1) t2 = 1;\n\n  const prev = catmullRomVec(t1, p0, p1, p2, p3);\n  const next = catmullRomVec(t2, p0, p1, p2, p3);\n\n  return next.sub(prev).normalize();\n}\n\nfunction curvatureAt(t2, p0, p1, p2, p3) {\n  const delta = 0.0001;\n\n  // If we're estimating curvature at one of the endpoints of the spline,\n  // slightly shift it inwards to avoid infinite curvature.\n  if (t2 == 0) t2 = delta;\n  if (t2 == 1) t2 = 1 - delta;\n\n  let t1 = t2 - delta;\n  let t3 = t2 + delta;\n\n  if (t1 < 0) t1 = 0;\n  if (t3 > 1) t3 = 1;\n\n  const pt1 = catmullRomVec(t1, p0, p1, p2, p3);\n  const pt2 = catmullRomVec(t2, p0, p1, p2, p3);\n  const pt3 = catmullRomVec(t3, p0, p1, p2, p3);\n\n  return (Math.atan2(pt3.y - pt2.y, pt3.x - pt2.x) - Math.atan2(pt2.y - pt1.y, pt2.x - pt1.x)) / pt2.distanceTo(pt1);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9MYW5lUGF0aC5qcz8wZmE0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNENBQTRDLCtCQUErQjtBQUMzRTtBQUNBLCtCQUErQixpQ0FBaUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsV0FBVztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwyQkFBMkIsZ0JBQWdCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLG1CQUFtQjtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIuL2pzL2F1dG9ub215L0xhbmVQYXRoLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaGFsZkxhbmVXaWR0aCA9IDMuNztcblxuY29uc3QgY2VudGVybGluZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5jb25zdCBsZWZ0Qm91bmRhcnlHZW9tZXRyeSA9IG5ldyBUSFJFRS5HZW9tZXRyeSgpO1xuY29uc3QgcmlnaHRCb3VuZGFyeUdlb21ldHJ5ID0gbmV3IFRIUkVFLkdlb21ldHJ5KCk7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhbmVQYXRoIHtcbiAgc3RhdGljIGh5ZHJhdGUob2JqKSB7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG9iaiwgTGFuZVBhdGgucHJvdG90eXBlKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuYW5jaG9ycyA9IFtdO1xuICAgIHRoaXMuY2VudGVybGluZXMgPSBbXTtcbiAgICB0aGlzLnNhbXBsZUxlbmd0aHMgPSBbXTtcbiAgICB0aGlzLmFyY0xlbmd0aHMgPSBbXTtcbiAgICB0aGlzLmxlZnRCb3VuZGFyaWVzID0gW107XG4gICAgdGhpcy5yaWdodEJvdW5kYXJpZXMgPSBbXTtcbiAgfVxuXG4gIGdldCBjZW50ZXJsaW5lKCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoLi4udGhpcy5jZW50ZXJsaW5lcyk7XG4gIH1cblxuICBnZXQgbGVmdEJvdW5kYXJ5KCkge1xuICAgIHJldHVybiBbXS5jb25jYXQoLi4udGhpcy5sZWZ0Qm91bmRhcmllcyk7XG4gIH1cblxuICBnZXQgcmlnaHRCb3VuZGFyeSgpIHtcbiAgICByZXR1cm4gW10uY29uY2F0KC4uLnRoaXMucmlnaHRCb3VuZGFyaWVzKTtcbiAgfVxuXG4gIGdldCBhcmNMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJjTGVuZ3Rocy5yZWR1Y2UoKHN1bSwgbCkgPT4gc3VtICsgbCwgMCk7XG4gIH1cblxuICBzYW1wbGVTdGF0aW9ucyhzdGFydFN0YXRpb24sIG51bSwgaW50ZXJ2YWwpIHtcbiAgICBjb25zdCBzYW1wbGVzID0gW107XG4gICAgbGV0IGFuY2hvckluZGV4ID0gMDtcbiAgICBsZXQgc2FtcGxlSW5kZXggPSAwO1xuICAgIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gICAgbGV0IG5leHRTdGF0aW9uID0gc3RhcnRTdGF0aW9uO1xuXG4gICAgd2hpbGUgKHRvdGFsTGVuZ3RoICsgdGhpcy5hcmNMZW5ndGhzW2FuY2hvckluZGV4XSA8IG5leHRTdGF0aW9uKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSB0aGlzLmFyY0xlbmd0aHNbYW5jaG9ySW5kZXhdO1xuXG4gICAgICBpZiAoKythbmNob3JJbmRleCA+PSB0aGlzLmFyY0xlbmd0aHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gc2FtcGxlcztcbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgICBsZXQgbGVuZ3RoID0gdGhpcy5zYW1wbGVMZW5ndGhzW2FuY2hvckluZGV4XVtzYW1wbGVJbmRleF07XG4gICAgICB3aGlsZSAodG90YWxMZW5ndGggKyBsZW5ndGggPCBuZXh0U3RhdGlvbikge1xuICAgICAgICB0b3RhbExlbmd0aCArPSBsZW5ndGg7XG5cbiAgICAgICAgaWYgKCsrc2FtcGxlSW5kZXggPj0gdGhpcy5zYW1wbGVMZW5ndGhzW2FuY2hvckluZGV4XS5sZW5ndGgpIHtcbiAgICAgICAgICBzYW1wbGVJbmRleCA9IDA7XG5cbiAgICAgICAgICBpZiAoKythbmNob3JJbmRleCA+PSB0aGlzLnNhbXBsZUxlbmd0aHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHNhbXBsZXM7XG4gICAgICAgIH1cblxuICAgICAgICBsZW5ndGggPSB0aGlzLnNhbXBsZUxlbmd0aHNbYW5jaG9ySW5kZXhdW3NhbXBsZUluZGV4XTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgW3AwLCBwMSwgcDIsIHAzXSA9IHRoaXMuYW5jaG9yc0ZvclNwbGluZUluZGV4KGFuY2hvckluZGV4KTtcbiAgICAgIGNvbnN0IHdlaWdodCA9IChzYW1wbGVJbmRleCArIChuZXh0U3RhdGlvbiAtIHRvdGFsTGVuZ3RoKSAvIGxlbmd0aCkgLyB0aGlzLnNhbXBsZUxlbmd0aHNbYW5jaG9ySW5kZXhdLmxlbmd0aDtcbiAgICAgIGNvbnN0IHBvcyA9IGNhdG11bGxSb21WZWMod2VpZ2h0LCBwMCwgcDEsIHAyLCBwMyk7XG4gICAgICBjb25zdCB0YW5nZW50ID0gdGFuZ2VudEF0KHdlaWdodCwgcDAsIHAxLCBwMiwgcDMpO1xuICAgICAgY29uc3Qgcm90ID0gTWF0aC5hdGFuMih0YW5nZW50LnksIHRhbmdlbnQueCk7XG4gICAgICBjb25zdCBjdXJ2ID0gY3VydmF0dXJlQXQod2VpZ2h0LCBwMCwgcDEsIHAyLCBwMyk7XG5cbiAgICAgIHNhbXBsZXMucHVzaCh7IHBvcywgcm90LCBjdXJ2IH0pO1xuICAgICAgbmV4dFN0YXRpb24gKz0gaW50ZXJ2YWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNhbXBsZXM7XG4gIH1cblxuICBzdGF0aW9uTGF0aXR1ZGVGcm9tUG9zaXRpb24ocG9zaXRpb24sIGFyb3VuZEFuY2hvckluZGV4ID0gbnVsbCkge1xuICAgIGNvbnN0IFthbmNob3JJbmRleCwgc2FtcGxlSW5kZXgsIHNhbXBsZVN0YXRpb24sIHByZXZTYW1wbGVTdGF0aW9uXSA9IHRoaXMuX2ZpbmRDbG9zZXN0U2FtcGxlKHBvc2l0aW9uLCBhcm91bmRBbmNob3JJbmRleCk7XG5cbiAgICBpZiAoYW5jaG9ySW5kZXggPT09IHVuZGVmaW5lZCkgcmV0dXJuIFswLCAwLCAwXTtcblxuICAgIGxldCBwcmV2UG9pbnQ7XG4gICAgbGV0IG5leHRQb2ludDtcbiAgICBsZXQgcHJldlN0YXRpb247XG4gICAgbGV0IG5leHRTdGF0aW9uO1xuXG4gICAgaWYgKGFuY2hvckluZGV4ID09IDAgJiYgc2FtcGxlSW5kZXggPT0gMCkge1xuICAgICAgcHJldlBvaW50ID0gdGhpcy5jZW50ZXJsaW5lc1thbmNob3JJbmRleF1bc2FtcGxlSW5kZXhdO1xuICAgICAgbmV4dFBvaW50ID0gdGhpcy5jZW50ZXJsaW5lc1thbmNob3JJbmRleF1bc2FtcGxlSW5kZXggKyAxXTtcbiAgICAgIHByZXZTdGF0aW9uID0gMDtcbiAgICAgIG5leHRTdGF0aW9uID0gdGhpcy5zYW1wbGVMZW5ndGhzW2FuY2hvckluZGV4XVtzYW1wbGVJbmRleF07XG4gICAgfSBlbHNlIGlmIChhbmNob3JJbmRleCA9PSB0aGlzLmNlbnRlcmxpbmVzLmxlbmd0aCAtIDEgJiYgc2FtcGxlSW5kZXggPT0gdGhpcy5jZW50ZXJsaW5lc1thbmNob3JJbmRleF0ubGVuZ3RoIC0gMSkge1xuICAgICAgcHJldlBvaW50ID0gdGhpcy5jZW50ZXJsaW5lc1thbmNob3JJbmRleF1bc2FtcGxlSW5kZXggLSAxXTtcbiAgICAgIG5leHRQb2ludCA9IHRoaXMuY2VudGVybGluZXNbYW5jaG9ySW5kZXhdW3NhbXBsZUluZGV4XTtcbiAgICAgIHByZXZTdGF0aW9uID0gcHJldlNhbXBsZVN0YXRpb247XG4gICAgICBuZXh0U3RhdGlvbiA9IHNhbXBsZVN0YXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZQb2ludCA9IHNhbXBsZUluZGV4ID09IDAgPyB0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4IC0gMV1bdGhpcy5jZW50ZXJsaW5lc1thbmNob3JJbmRleCAtIDFdLmxlbmd0aCAtIDFdIDogdGhpcy5jZW50ZXJsaW5lc1thbmNob3JJbmRleF1bc2FtcGxlSW5kZXggLSAxXTtcbiAgICAgIG5leHRQb2ludCA9IHNhbXBsZUluZGV4ID09IHRoaXMuY2VudGVybGluZXNbYW5jaG9ySW5kZXhdLmxlbmd0aCAtIDEgPyB0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4ICsgMV1bMF0gOiB0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4XVtzYW1wbGVJbmRleCArIDFdO1xuXG4gICAgICBjb25zdCBwb3NzaWJsZU5leHQgPSB0aGlzLmNlbnRlcmxpbmVzW2FuY2hvckluZGV4XVtzYW1wbGVJbmRleF07XG4gICAgICBjb25zdCBwb3NzaWJsZVByb2dyZXNzID0gcG9zaXRpb24uY2xvbmUoKS5zdWIocHJldlBvaW50KS5kb3QocG9zc2libGVOZXh0LmNsb25lKCkuc3ViKHByZXZQb2ludCkpIC8gcHJldlBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKHBvc3NpYmxlTmV4dCk7XG5cbiAgICAgIGlmIChwb3NzaWJsZVByb2dyZXNzIDwgMSkge1xuICAgICAgICBuZXh0UG9pbnQgPSBwb3NzaWJsZU5leHQ7XG4gICAgICAgIHByZXZTdGF0aW9uID0gcHJldlNhbXBsZVN0YXRpb247XG4gICAgICAgIG5leHRTdGF0aW9uID0gc2FtcGxlU3RhdGlvbjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZQb2ludCA9IHBvc3NpYmxlTmV4dDtcbiAgICAgICAgcHJldlN0YXRpb24gPSBzYW1wbGVTdGF0aW9uO1xuICAgICAgICBuZXh0U3RhdGlvbiA9IHNhbXBsZVN0YXRpb24gKyB0aGlzLnNhbXBsZUxlbmd0aHNbYW5jaG9ySW5kZXhdW3NhbXBsZUluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGguY2xhbXAocG9zaXRpb24uY2xvbmUoKS5zdWIocHJldlBvaW50KS5kb3QobmV4dFBvaW50LmNsb25lKCkuc3ViKHByZXZQb2ludCkpIC8gcHJldlBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKG5leHRQb2ludCksIDAsIDEpO1xuICAgIGNvbnN0IHByb2plY3RlZFBvc2l0aW9uID0gbmV4dFBvaW50LmNsb25lKCkuc3ViKHByZXZQb2ludCkubXVsdGlwbHlTY2FsYXIocHJvZ3Jlc3MpLmFkZChwcmV2UG9pbnQpO1xuXG4gICAgY29uc3Qgc3RhdGlvbiA9IHByZXZTdGF0aW9uICsgKG5leHRTdGF0aW9uIC0gcHJldlN0YXRpb24pICogcHJvZ3Jlc3M7XG4gICAgY29uc3QgbGF0aXR1ZGUgPSBNYXRoLnNpZ24oKG5leHRQb2ludC54IC0gcHJldlBvaW50LngpICogKHBvc2l0aW9uLnkgLSBwcmV2UG9pbnQueSkgLSAobmV4dFBvaW50LnkgLSBwcmV2UG9pbnQueSkgKiAocG9zaXRpb24ueCAtIHByZXZQb2ludC54KSkgKiBwb3NpdGlvbi5kaXN0YW5jZVRvKHByb2plY3RlZFBvc2l0aW9uKTtcblxuICAgIHJldHVybiBbc3RhdGlvbiwgbGF0aXR1ZGUsIGFuY2hvckluZGV4XTtcbiAgfVxuXG4gIF9maW5kQ2xvc2VzdFNhbXBsZShwb3NpdGlvbiwgYXJvdW5kQW5jaG9ySW5kZXggPSBudWxsKSB7XG4gICAgbGV0IGNsb3Nlc3QgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgbGV0IGJlc3RBbmNob3JJbmRleDtcbiAgICBsZXQgYmVzdFNhbXBsZUluZGV4O1xuICAgIGxldCBiZXN0U3RhdGlvbjtcbiAgICBsZXQgYmVzdFByZXZTdGF0aW9uO1xuXG4gICAgbGV0IGN1cnJTdGF0aW9uID0gMDtcbiAgICBsZXQgcHJldlN0YXRpb24gPSAwO1xuXG4gICAgbGV0IHN0YXJ0QW5jaG9ySW5kZXggPSAwO1xuICAgIGxldCBlbmRBbmNob3JJbmRleCA9IHRoaXMuY2VudGVybGluZXMubGVuZ3RoIC0gMTtcblxuICAgIGlmIChhcm91bmRBbmNob3JJbmRleCAhPT0gbnVsbCkge1xuICAgICAgc3RhcnRBbmNob3JJbmRleCA9IE1hdGgubWF4KDAsIGFyb3VuZEFuY2hvckluZGV4IC0gMik7XG4gICAgICBlbmRBbmNob3JJbmRleCA9IE1hdGgubWluKHRoaXMuY2VudGVybGluZXMubGVuZ3RoIC0gMSwgYXJvdW5kQW5jaG9ySW5kZXggKyAyKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhcnRBbmNob3JJbmRleCA+IDApIHtcbiAgICAgIGZvciAobGV0IGFuY2hvckluZGV4ID0gMDsgYW5jaG9ySW5kZXggPCBzdGFydEFuY2hvckluZGV4OyBhbmNob3JJbmRleCsrKSB7XG4gICAgICAgIGN1cnJTdGF0aW9uICs9IHRoaXMuYXJjTGVuZ3Roc1thbmNob3JJbmRleF07XG4gICAgICB9XG5cbiAgICAgIHByZXZTdGF0aW9uID0gY3VyclN0YXRpb24gLSB0aGlzLnNhbXBsZUxlbmd0aHNbc3RhcnRBbmNob3JJbmRleCAtIDFdW3RoaXMuc2FtcGxlTGVuZ3Roc1tzdGFydEFuY2hvckluZGV4IC0gMV0ubGVuZ3RoIC0gMV07XG4gICAgfVxuXG4gICAgZm9yIChsZXQgYW5jaG9ySW5kZXggPSBzdGFydEFuY2hvckluZGV4OyBhbmNob3JJbmRleCA8PSBlbmRBbmNob3JJbmRleDsgYW5jaG9ySW5kZXgrKykge1xuICAgICAgY29uc3QgY2VudGVybGluZSA9IHRoaXMuY2VudGVybGluZXNbYW5jaG9ySW5kZXhdO1xuICAgICAgZm9yIChsZXQgc2FtcGxlSW5kZXggPSAwOyBzYW1wbGVJbmRleCA8IGNlbnRlcmxpbmUubGVuZ3RoOyBzYW1wbGVJbmRleCsrKSB7XG4gICAgICAgIGNvbnN0IGRpc3RTcSA9IHBvc2l0aW9uLmRpc3RhbmNlVG9TcXVhcmVkKGNlbnRlcmxpbmVbc2FtcGxlSW5kZXhdKTtcbiAgICAgICAgaWYgKGRpc3RTcSA8IGNsb3Nlc3QpIHtcbiAgICAgICAgICBjbG9zZXN0ID0gZGlzdFNxO1xuICAgICAgICAgIGJlc3RBbmNob3JJbmRleCA9IGFuY2hvckluZGV4O1xuICAgICAgICAgIGJlc3RTYW1wbGVJbmRleCA9IHNhbXBsZUluZGV4O1xuICAgICAgICAgIGJlc3RTdGF0aW9uID0gY3VyclN0YXRpb247XG4gICAgICAgICAgYmVzdFByZXZTdGF0aW9uID0gcHJldlN0YXRpb247XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2U3RhdGlvbiA9IGN1cnJTdGF0aW9uO1xuICAgICAgICBjdXJyU3RhdGlvbiArPSB0aGlzLnNhbXBsZUxlbmd0aHNbYW5jaG9ySW5kZXhdW3NhbXBsZUluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gW2Jlc3RBbmNob3JJbmRleCwgYmVzdFNhbXBsZUluZGV4LCBiZXN0U3RhdGlvbiwgYmVzdFByZXZTdGF0aW9uXTtcbiAgfVxuXG4gIGFkZEFuY2hvcihwb3NpdGlvbiwgcmVzYW1wbGUgPSB0cnVlKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmFuY2hvcnMucHVzaChwb3NpdGlvbikgLSAxO1xuXG4gICAgaWYgKHJlc2FtcGxlKSB7XG4gICAgICBmb3IgKGxldCBpID0gaW5kZXggLSAyOyBpIDwgaW5kZXg7IGkrKylcbiAgICAgICAgdGhpcy5yZXNhbXBsZShpKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVBbmNob3IoaW5kZXgsIHBvc2l0aW9uKSB7XG4gICAgdGhpcy5hbmNob3JzW2luZGV4XSA9IHBvc2l0aW9uO1xuXG4gICAgZm9yIChsZXQgaSA9IGluZGV4IC0gMjsgaSA8PSBpbmRleCArIDE7IGkrKylcbiAgICAgIHRoaXMucmVzYW1wbGUoaSk7XG4gIH1cblxuICByZW1vdmVBbmNob3IoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuYW5jaG9ycy5sZW5ndGgpIHJldHVybjtcblxuICAgIHRoaXMuYW5jaG9ycy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgY29uc3Qgc2VnbWVudEluZGV4ID0gaW5kZXggPCB0aGlzLmFuY2hvcnMubGVuZ3RoID8gaW5kZXggOiBpbmRleCAtIDE7XG4gICAgdGhpcy5jZW50ZXJsaW5lcy5zcGxpY2Uoc2VnbWVudEluZGV4LCAxKTtcbiAgICB0aGlzLnNhbXBsZUxlbmd0aHMuc3BsaWNlKHNlZ21lbnRJbmRleCwgMSk7XG4gICAgdGhpcy5sZWZ0Qm91bmRhcmllcy5zcGxpY2Uoc2VnbWVudEluZGV4LCAxKTtcbiAgICB0aGlzLnJpZ2h0Qm91bmRhcmllcy5zcGxpY2Uoc2VnbWVudEluZGV4LCAxKTtcbiAgICB0aGlzLmFyY0xlbmd0aHMuc3BsaWNlKHNlZ21lbnRJbmRleCwgMSk7XG5cbiAgICBmb3IgKGxldCBpID0gc2VnbWVudEluZGV4IC0gMjsgaSA8PSBzZWdtZW50SW5kZXg7IGkrKylcbiAgICAgIHRoaXMucmVzYW1wbGUoaSk7XG4gIH1cblxuICByZXNhbXBsZShpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aGlzLmFuY2hvcnMubGVuZ3RoIC0gMikgcmV0dXJuO1xuXG4gICAgY29uc3QgW3AwLCBwMSwgcDIsIHAzXSA9IHRoaXMuYW5jaG9yc0ZvclNwbGluZUluZGV4KGluZGV4KTtcbiAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICBjb25zdCBsZW5ndGhzID0gW107XG4gICAgY29uc3QgbGVmdEJvdW5kYXJ5ID0gW107XG4gICAgY29uc3QgcmlnaHRCb3VuZGFyeSA9IFtdO1xuICAgIGxldCBwcmV2UG9pbnQgPSBudWxsO1xuXG4gICAgY29uc3QgcG9pbnRzUGVyU2VnbWVudCA9IE1hdGgubWF4KDEwLCBNYXRoLmNlaWwocDEuZGlzdGFuY2VUbyhwMikgLyAxKSk7XG4gICAgY29uc3QgbnVtUG9pbnRzID0gaW5kZXggPT0gdGhpcy5hbmNob3JzLmxlbmd0aCAtIDIgPyBwb2ludHNQZXJTZWdtZW50ICsgMSA6IHBvaW50c1BlclNlZ21lbnQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBvaW50czsgaSsrKSB7XG4gICAgICBjb25zdCB0ID0gaSAvIHBvaW50c1BlclNlZ21lbnQ7XG4gICAgICBjb25zdCBwb2ludCA9IGNhdG11bGxSb21WZWModCwgcDAsIHAxLCBwMiwgcDMpO1xuICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuXG4gICAgICBpZiAocHJldlBvaW50ICE9IG51bGwpXG4gICAgICAgIGxlbmd0aHMucHVzaChwcmV2UG9pbnQuZGlzdGFuY2VUbyhwb2ludCkpO1xuICAgICAgcHJldlBvaW50ID0gcG9pbnQ7XG5cbiAgICAgIGNvbnN0IHRhbmdlbnQgPSB0YW5nZW50QXQodCwgcDAsIHAxLCBwMiwgcDMpO1xuICAgICAgY29uc3Qgbm9ybWFsID0gbmV3IFRIUkVFLlZlY3RvcjIoLXRhbmdlbnQueSwgdGFuZ2VudC54KTtcblxuICAgICAgbGVmdEJvdW5kYXJ5LnB1c2gobm9ybWFsLmNsb25lKCkubXVsdGlwbHlTY2FsYXIoLWhhbGZMYW5lV2lkdGgpLmFkZChwb2ludCkpO1xuICAgICAgcmlnaHRCb3VuZGFyeS5wdXNoKG5vcm1hbC5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKGhhbGZMYW5lV2lkdGgpLmFkZChwb2ludCkpO1xuICAgIH1cblxuICAgIGxlbmd0aHMucHVzaChwcmV2UG9pbnQuZGlzdGFuY2VUbyhwMikpO1xuXG4gICAgdGhpcy5jZW50ZXJsaW5lc1tpbmRleF0gPSBwb2ludHM7XG4gICAgdGhpcy5zYW1wbGVMZW5ndGhzW2luZGV4XSA9IGxlbmd0aHM7XG4gICAgdGhpcy5sZWZ0Qm91bmRhcmllc1tpbmRleF0gPSBsZWZ0Qm91bmRhcnk7XG4gICAgdGhpcy5yaWdodEJvdW5kYXJpZXNbaW5kZXhdID0gcmlnaHRCb3VuZGFyeTtcbiAgICB0aGlzLmFyY0xlbmd0aHNbaW5kZXhdID0gbGVuZ3Rocy5yZWR1Y2UoKHN1bSwgbCkgPT4gc3VtICsgbCwgMCk7XG4gIH1cblxuICByZXNhbXBsZUFsbCgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYW5jaG9ycy5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMucmVzYW1wbGUoaSk7XG4gIH1cblxuICBhbmNob3JzRm9yU3BsaW5lSW5kZXgoaW5kZXgpIHtcbiAgICBsZXQgcDtcbiAgICBpZiAoaW5kZXggPT0gMClcbiAgICAgIHAgPSBbdGhpcy5hbmNob3JzWzBdXS5jb25jYXQodGhpcy5hbmNob3JzLnNsaWNlKDAsIDMpKTtcbiAgICBlbHNlXG4gICAgICBwID0gdGhpcy5hbmNob3JzLnNsaWNlKGluZGV4IC0gMSwgaW5kZXggKyAzKTtcblxuICAgIGlmIChwWzNdID09PSB1bmRlZmluZWQpXG4gICAgICBwWzNdID0gcFsyXTtcblxuICAgIHJldHVybiBwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhdG11bGxSb20odCwgcDAsIHAxLCBwMiwgcDMpIHtcbiAgY29uc3QgdjAgPSAocDIgLSBwMCkgKiAwLjU7XG4gIGNvbnN0IHYxID0gKHAzIC0gcDEpICogMC41O1xuICBjb25zdCB0MiA9IHQgKiB0O1xuICBjb25zdCB0MyA9IHQgKiB0MjtcbiAgcmV0dXJuICgyICogcDEgLSAyICogcDIgKyB2MCArIHYxKSAqIHQzICsgKC0zICogcDEgKyAzICogcDIgLSAyICogdjAgLSB2MSkgKiB0MiArIHYwICogdCArIHAxO1xufVxuXG5mdW5jdGlvbiBjYXRtdWxsUm9tVmVjKHQsIHAwLCBwMSwgcDIsIHAzKSB7XG4gIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMihjYXRtdWxsUm9tKHQsIHAwLngsIHAxLngsIHAyLngsIHAzLngpLCBjYXRtdWxsUm9tKHQsIHAwLnksIHAxLnksIHAyLnksIHAzLnkpKTtcbn1cblxuZnVuY3Rpb24gdGFuZ2VudEF0KHQsIHAwLCBwMSwgcDIsIHAzKSB7XG4gIGNvbnN0IGRlbHRhID0gMC4wMDAxO1xuICBsZXQgdDEgPSB0IC0gZGVsdGE7XG4gIGxldCB0MiA9IHQgKyBkZWx0YTtcblxuICBpZiAodDEgPCAwKSB0MSA9IDA7XG4gIGlmICh0MiA+IDEpIHQyID0gMTtcblxuICBjb25zdCBwcmV2ID0gY2F0bXVsbFJvbVZlYyh0MSwgcDAsIHAxLCBwMiwgcDMpO1xuICBjb25zdCBuZXh0ID0gY2F0bXVsbFJvbVZlYyh0MiwgcDAsIHAxLCBwMiwgcDMpO1xuXG4gIHJldHVybiBuZXh0LnN1YihwcmV2KS5ub3JtYWxpemUoKTtcbn1cblxuZnVuY3Rpb24gY3VydmF0dXJlQXQodDIsIHAwLCBwMSwgcDIsIHAzKSB7XG4gIGNvbnN0IGRlbHRhID0gMC4wMDAxO1xuXG4gIC8vIElmIHdlJ3JlIGVzdGltYXRpbmcgY3VydmF0dXJlIGF0IG9uZSBvZiB0aGUgZW5kcG9pbnRzIG9mIHRoZSBzcGxpbmUsXG4gIC8vIHNsaWdodGx5IHNoaWZ0IGl0IGlud2FyZHMgdG8gYXZvaWQgaW5maW5pdGUgY3VydmF0dXJlLlxuICBpZiAodDIgPT0gMCkgdDIgPSBkZWx0YTtcbiAgaWYgKHQyID09IDEpIHQyID0gMSAtIGRlbHRhO1xuXG4gIGxldCB0MSA9IHQyIC0gZGVsdGE7XG4gIGxldCB0MyA9IHQyICsgZGVsdGE7XG5cbiAgaWYgKHQxIDwgMCkgdDEgPSAwO1xuICBpZiAodDMgPiAxKSB0MyA9IDE7XG5cbiAgY29uc3QgcHQxID0gY2F0bXVsbFJvbVZlYyh0MSwgcDAsIHAxLCBwMiwgcDMpO1xuICBjb25zdCBwdDIgPSBjYXRtdWxsUm9tVmVjKHQyLCBwMCwgcDEsIHAyLCBwMyk7XG4gIGNvbnN0IHB0MyA9IGNhdG11bGxSb21WZWModDMsIHAwLCBwMSwgcDIsIHAzKTtcblxuICByZXR1cm4gKE1hdGguYXRhbjIocHQzLnkgLSBwdDIueSwgcHQzLnggLSBwdDIueCkgLSBNYXRoLmF0YW4yKHB0Mi55IC0gcHQxLnksIHB0Mi54IC0gcHQxLngpKSAvIHB0Mi5kaXN0YW5jZVRvKHB0MSk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/autonomy/LanePath.js\n");

/***/ }),

/***/ "./js/autonomy/StaticObstacle.js":
/*!***************************************!*\
  !*** ./js/autonomy/StaticObstacle.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return StaticObstacle; });\nclass StaticObstacle {\n  static hydrate(obj) {\n    Object.setPrototypeOf(obj, StaticObstacle.prototype);\n    Object.setPrototypeOf(obj.pos, THREE.Vector2.prototype);\n  }\n\n  static fromJSON(json) {\n    return new StaticObstacle(new THREE.Vector2(json.p[0], json.p[1]), json.r, json.w, json.h);\n  }\n\n  constructor(pos, rot, width, height) {\n    this.pos = pos;\n    this.rot = rot;\n    this.width = width;\n    this.height = height;\n\n    this.updateVertices();\n  }\n\n  toJSON() {\n    const trunc = n => +n.toFixed(5);\n\n    return {\n      p: [trunc(this.pos.x), trunc(this.pos.y)],\n      r: trunc(this.rot),\n      w: trunc(this.width),\n      h: trunc(this.height)\n    };\n  }\n\n  updateVertices() {\n    this.vertices = [];\n\n    const cosRot = Math.cos(this.rot);\n    const sinRot = Math.sin(this.rot);\n    const halfWidth = this.width / 2;\n    const halfHeight = this.height / 2;\n\n    const hWcR = halfWidth * cosRot;\n    const hWsR = halfWidth * sinRot;\n    const hHcR = halfHeight * cosRot;\n    const hHsR = halfHeight * sinRot;\n\n    const v1 = [-hWcR - hHsR + this.pos.x, -hWsR + hHcR + this.pos.y];\n    const v2 = [-hWcR + hHsR + this.pos.x, -hWsR - hHcR + this.pos.y];\n    const v3 = [hWcR + hHsR + this.pos.x, hWsR - hHcR + this.pos.y];\n    const v4 = [hWcR - hHsR + this.pos.x, hWsR + hHcR + this.pos.y];\n\n    this.vertices = [\n      v1[0], v1[1],\n      v2[0], v2[1],\n      v3[0], v3[1],\n      v3[0], v3[1],\n      v4[0], v4[1],\n      v1[0], v1[1]\n    ];\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9TdGF0aWNPYnN0YWNsZS5qcz84OTA2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL2pzL2F1dG9ub215L1N0YXRpY09ic3RhY2xlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3RhdGljT2JzdGFjbGUge1xuICBzdGF0aWMgaHlkcmF0ZShvYmopIHtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2Yob2JqLCBTdGF0aWNPYnN0YWNsZS5wcm90b3R5cGUpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihvYmoucG9zLCBUSFJFRS5WZWN0b3IyLnByb3RvdHlwZSk7XG4gIH1cblxuICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xuICAgIHJldHVybiBuZXcgU3RhdGljT2JzdGFjbGUobmV3IFRIUkVFLlZlY3RvcjIoanNvbi5wWzBdLCBqc29uLnBbMV0pLCBqc29uLnIsIGpzb24udywganNvbi5oKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKHBvcywgcm90LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgdGhpcy5yb3QgPSByb3Q7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgdGhpcy51cGRhdGVWZXJ0aWNlcygpO1xuICB9XG5cbiAgdG9KU09OKCkge1xuICAgIGNvbnN0IHRydW5jID0gbiA9PiArbi50b0ZpeGVkKDUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHA6IFt0cnVuYyh0aGlzLnBvcy54KSwgdHJ1bmModGhpcy5wb3MueSldLFxuICAgICAgcjogdHJ1bmModGhpcy5yb3QpLFxuICAgICAgdzogdHJ1bmModGhpcy53aWR0aCksXG4gICAgICBoOiB0cnVuYyh0aGlzLmhlaWdodClcbiAgICB9O1xuICB9XG5cbiAgdXBkYXRlVmVydGljZXMoKSB7XG4gICAgdGhpcy52ZXJ0aWNlcyA9IFtdO1xuXG4gICAgY29uc3QgY29zUm90ID0gTWF0aC5jb3ModGhpcy5yb3QpO1xuICAgIGNvbnN0IHNpblJvdCA9IE1hdGguc2luKHRoaXMucm90KTtcbiAgICBjb25zdCBoYWxmV2lkdGggPSB0aGlzLndpZHRoIC8gMjtcbiAgICBjb25zdCBoYWxmSGVpZ2h0ID0gdGhpcy5oZWlnaHQgLyAyO1xuXG4gICAgY29uc3QgaFdjUiA9IGhhbGZXaWR0aCAqIGNvc1JvdDtcbiAgICBjb25zdCBoV3NSID0gaGFsZldpZHRoICogc2luUm90O1xuICAgIGNvbnN0IGhIY1IgPSBoYWxmSGVpZ2h0ICogY29zUm90O1xuICAgIGNvbnN0IGhIc1IgPSBoYWxmSGVpZ2h0ICogc2luUm90O1xuXG4gICAgY29uc3QgdjEgPSBbLWhXY1IgLSBoSHNSICsgdGhpcy5wb3MueCwgLWhXc1IgKyBoSGNSICsgdGhpcy5wb3MueV07XG4gICAgY29uc3QgdjIgPSBbLWhXY1IgKyBoSHNSICsgdGhpcy5wb3MueCwgLWhXc1IgLSBoSGNSICsgdGhpcy5wb3MueV07XG4gICAgY29uc3QgdjMgPSBbaFdjUiArIGhIc1IgKyB0aGlzLnBvcy54LCBoV3NSIC0gaEhjUiArIHRoaXMucG9zLnldO1xuICAgIGNvbnN0IHY0ID0gW2hXY1IgLSBoSHNSICsgdGhpcy5wb3MueCwgaFdzUiArIGhIY1IgKyB0aGlzLnBvcy55XTtcblxuICAgIHRoaXMudmVydGljZXMgPSBbXG4gICAgICB2MVswXSwgdjFbMV0sXG4gICAgICB2MlswXSwgdjJbMV0sXG4gICAgICB2M1swXSwgdjNbMV0sXG4gICAgICB2M1swXSwgdjNbMV0sXG4gICAgICB2NFswXSwgdjRbMV0sXG4gICAgICB2MVswXSwgdjFbMV1cbiAgICBdO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/autonomy/StaticObstacle.js\n");

/***/ }),

/***/ "./js/autonomy/path-planning/CubicPath.js":
/*!************************************************!*\
  !*** ./js/autonomy/path-planning/CubicPath.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return CubicPath; });\nconst SIMPSONS_INTERVALS = 8;\nconst NEWTON_ITERATIONS = 16;\nconst RELAXATION_ITERATIONS = 32;\nconst CONVERGENCE_ERROR = 0.01;\n\nconst jacobian = new THREE.Matrix3();\nconst invJacobian = new THREE.Matrix3();\n\n// Alternate reference implementation: https://github.com/ApolloAuto/apollo/blob/master/modules/planning/math/spiral_curve/cubic_spiral_curve.cc\nclass CubicPath {\n  constructor(start, end, params = null) {\n    this.start = Object.assign({}, start);\n    this.end = Object.assign({}, end);\n\n    if (start.pos) {\n      this.start.x = start.pos.x;\n      this.start.y = start.pos.y\n    }\n\n    if (end.pos) {\n      this.end.x = end.pos.x;\n      this.end.y = end.pos.y\n    }\n\n    const diffX = this.end.x - this.start.x;\n    const diffY = this.end.y - this.start.y;\n    const sinRot = Math.sin(this.start.rot);\n    const cosRot = Math.cos(this.start.rot);\n\n    this.goal = {\n      x: cosRot * diffX + sinRot * diffY,\n      y: -sinRot * diffX + cosRot * diffY,\n      rot: Math.wrapAngle(this.end.rot - this.start.rot),\n      curv: this.end.curv\n    };\n\n    if (params)\n      this.params = Object.assign({}, params, { p0: this.start.curv, p3: this.end.curv });\n    else\n      this.guessInitialParams();\n\n    this.converged = false;\n  }\n\n  guessInitialParams() {\n    const originalGoal = this.goal;\n    const dStartCurv = this.start.curv / RELAXATION_ITERATIONS;\n    const dGoalY = originalGoal.y / RELAXATION_ITERATIONS;\n    const dGoalRot = originalGoal.rot / RELAXATION_ITERATIONS;\n    const dGoalCurv = originalGoal.curv / RELAXATION_ITERATIONS;\n\n    this.goal = {\n      x: originalGoal.x,\n      y: 0,\n      rot: 0,\n      curv: 0\n    };\n\n    this.params = {\n      p0: 0,\n      p1: 0,\n      p2: 0,\n      p3: 0,\n      sG: originalGoal.x\n    };\n\n    for (let i = 0; i < RELAXATION_ITERATIONS; i++) {\n      this.params.p0 += dStartCurv;\n      this.params.p3 += dGoalCurv;\n      this.goal.y += dGoalY;\n      this.goal.rot += dGoalRot;\n      this.goal.curv += dGoalCurv;\n\n      this.iterate();\n    }\n\n    this.goal = originalGoal;\n  }\n\n  optimize() {\n    for (let i = 0; i < NEWTON_ITERATIONS; i++) {\n      if (this.iterate()) {\n        this.converged = true;\n        return true;\n      }\n    }\n\n    this.converged = false;\n    return false;\n  }\n\n  iterate() {\n    const { p0, p1, p2, p3, sG } = this.params;\n\n    const ds = sG / SIMPSONS_INTERVALS;\n    const sG_2 = sG * sG;\n    const sG_3 = sG_2 * sG;\n\n    let dX_p1 = 0;\n    let dX_p2 = 0;\n    let dX_sG = 0;\n    let dY_p1 = 0;\n    let dY_p2 = 0;\n    let dY_sG = 0;\n    let guessX = 0;\n    let guessY = 0;\n\n    let theta, cosTheta, sinTheta, dT_p1, dT_p2, dT_sG;\n\n    for (let i = 0, s = 0; i <= SIMPSONS_INTERVALS; i++, s += ds) {\n      const coeff = i == 0 || i == SIMPSONS_INTERVALS ? 1 : i % 2 == 0 ? 2 : 4;\n\n      const a = p0;\n      const b = (-5.5 * p0 + 9 * p1 - 4.5 * p2 + p3) / sG;\n      const c = (9 * p0 - 22.5 * p1 + 18 * p2 - 4.5 * p3) / sG_2;\n      const d = (-4.5 * (p0 - 3 * p1 + 3 * p2 - p3)) / sG_3;\n\n      theta = (((d * s / 4 + c / 3) * s + b / 2) * s + a) * s;\n      cosTheta = Math.cos(theta);\n      sinTheta = Math.sin(theta);\n\n      const s_sG = s / sG;\n      dT_p1 = ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s;\n      dT_p2 = ((-3.375 * s_sG + 6) * s_sG - 2.25) * s_sG * s;\n      dT_sG = ((3.375 * (p0 - 3 * p1 + 3 * p2 - p3) * s_sG - 3 * (2 * p0 - 5 * p1 + 4 * p2 - p3)) * s_sG + 0.25 * (11 * p0 - 18 * p1 + 9 * p2 - 2 * p3)) * s_sG * s_sG;\n\n      dX_p1 -= coeff * sinTheta * dT_p1;\n      dX_p2 -= coeff * sinTheta * dT_p2;\n      dX_sG -= coeff * sinTheta * dT_sG;\n\n      dY_p1 += coeff * cosTheta * dT_p1;\n      dY_p2 += coeff * cosTheta * dT_p2;\n      dY_sG += coeff * cosTheta * dT_sG;\n\n      guessX += coeff * cosTheta;\n      guessY += coeff * sinTheta;\n    }\n\n    // After the Simpson's integration loop, `theta`, `cosTheta`, `sinTheta`,\n    // `dT_p1`, `dT_p2`, and `dT_sG` hold the appropriate values for `sG`.\n\n    const hOver3 = sG / SIMPSONS_INTERVALS / 3;\n\n    const deltaX = this.goal.x - guessX * hOver3;\n    const deltaY = this.goal.y - guessY * hOver3;\n    const deltaRot = Math.wrapAngle(this.goal.rot - theta);\n\n    if (Math.abs(deltaX) + Math.abs(deltaY) + Math.abs(deltaRot) < CONVERGENCE_ERROR)\n      return true;\n\n    jacobian.set(\n      dX_p1 * hOver3, dX_p2 * hOver3, cosTheta + dX_sG * hOver3,\n      dY_p1 * hOver3, dY_p2 * hOver3, sinTheta + dY_sG * hOver3,\n      dT_p1, dT_p2, dT_sG\n    );\n\n    const [m11, m21, m31, m12, m22, m32, m13, m23, m33] = invJacobian.getInverse(jacobian).elements;\n\n    this.params.p1 += m11 * deltaX + m12 * deltaY + m13 * deltaRot;\n    this.params.p2 += m21 * deltaX + m22 * deltaY + m23 * deltaRot;\n    this.params.sG += m31 * deltaX + m32 * deltaY + m33 * deltaRot;\n\n    return false;\n  }\n\n  buildPath(num) {\n    const { p0, p1, p2, p3, sG } = this.params;\n\n    const sG_2 = sG * sG;\n    const sG_3 = sG_2 * sG;\n\n    const a = p0;\n    const b = (-5.5 * p0 + 9 * p1 - 4.5 * p2 + p3) / sG;\n    const c = (9 * p0 - 22.5 * p1 + 18 * p2 - 4.5 * p3) / sG_2;\n    const d = (-4.5 * (p0 - 3 * p1 + 3 * p2 - p3)) / sG_3;\n\n    const path = [{ pos: new THREE.Vector2(this.start.x, this.start.y), rot: this.start.rot, curv: this.start.curv }];\n    const ds = sG / (num - 1);\n    let s = ds;\n    let dx = 0;\n    let dy = 0;\n    let prevCosRot = Math.cos(path[0].rot);\n    let prevSinRot = Math.sin(path[0].rot);\n\n    for (let i = 1; i < num - 1; i++) {\n      const rot = (((d * s / 4 + c / 3) * s + b / 2) * s + a) * s + this.start.rot;\n      const curv = ((d * s + c) * s + b) * s + a;\n      const cosRot = Math.cos(rot);\n      const sinRot = Math.sin(rot);\n\n      dx = dx * (i - 1) / i + (cosRot + prevCosRot) / (2 * i);\n      dy = dy * (i - 1) / i + (sinRot + prevSinRot) / (2 * i);\n\n      path.push({ pos: new THREE.Vector2(s * dx + this.start.x, s * dy + this.start.y), rot: rot, curv: curv });\n\n      s += ds;\n      prevCosRot = cosRot;\n      prevSinRot = sinRot;\n    }\n\n    path.push({ pos: new THREE.Vector2(this.end.x, this.end.y), rot: this.end.rot, curv: this.end.curv });\n\n    return path;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL0N1YmljUGF0aC5qcz85NDBjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLFdBQVcseUNBQXlDO0FBQ3hGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxxQkFBcUI7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDBCQUEwQix5QkFBeUI7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcscUJBQXFCOztBQUVoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixpR0FBaUc7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixhQUFhO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLDZGQUE2Rjs7QUFFOUc7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSx5RkFBeUY7O0FBRXhHO0FBQ0E7QUFDQSIsImZpbGUiOiIuL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvQ3ViaWNQYXRoLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU0lNUFNPTlNfSU5URVJWQUxTID0gODtcbmNvbnN0IE5FV1RPTl9JVEVSQVRJT05TID0gMTY7XG5jb25zdCBSRUxBWEFUSU9OX0lURVJBVElPTlMgPSAzMjtcbmNvbnN0IENPTlZFUkdFTkNFX0VSUk9SID0gMC4wMTtcblxuY29uc3QgamFjb2JpYW4gPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuY29uc3QgaW52SmFjb2JpYW4gPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuXG4vLyBBbHRlcm5hdGUgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uOiBodHRwczovL2dpdGh1Yi5jb20vQXBvbGxvQXV0by9hcG9sbG8vYmxvYi9tYXN0ZXIvbW9kdWxlcy9wbGFubmluZy9tYXRoL3NwaXJhbF9jdXJ2ZS9jdWJpY19zcGlyYWxfY3VydmUuY2NcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1YmljUGF0aCB7XG4gIGNvbnN0cnVjdG9yKHN0YXJ0LCBlbmQsIHBhcmFtcyA9IG51bGwpIHtcbiAgICB0aGlzLnN0YXJ0ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhcnQpO1xuICAgIHRoaXMuZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgZW5kKTtcblxuICAgIGlmIChzdGFydC5wb3MpIHtcbiAgICAgIHRoaXMuc3RhcnQueCA9IHN0YXJ0LnBvcy54O1xuICAgICAgdGhpcy5zdGFydC55ID0gc3RhcnQucG9zLnlcbiAgICB9XG5cbiAgICBpZiAoZW5kLnBvcykge1xuICAgICAgdGhpcy5lbmQueCA9IGVuZC5wb3MueDtcbiAgICAgIHRoaXMuZW5kLnkgPSBlbmQucG9zLnlcbiAgICB9XG5cbiAgICBjb25zdCBkaWZmWCA9IHRoaXMuZW5kLnggLSB0aGlzLnN0YXJ0Lng7XG4gICAgY29uc3QgZGlmZlkgPSB0aGlzLmVuZC55IC0gdGhpcy5zdGFydC55O1xuICAgIGNvbnN0IHNpblJvdCA9IE1hdGguc2luKHRoaXMuc3RhcnQucm90KTtcbiAgICBjb25zdCBjb3NSb3QgPSBNYXRoLmNvcyh0aGlzLnN0YXJ0LnJvdCk7XG5cbiAgICB0aGlzLmdvYWwgPSB7XG4gICAgICB4OiBjb3NSb3QgKiBkaWZmWCArIHNpblJvdCAqIGRpZmZZLFxuICAgICAgeTogLXNpblJvdCAqIGRpZmZYICsgY29zUm90ICogZGlmZlksXG4gICAgICByb3Q6IE1hdGgud3JhcEFuZ2xlKHRoaXMuZW5kLnJvdCAtIHRoaXMuc3RhcnQucm90KSxcbiAgICAgIGN1cnY6IHRoaXMuZW5kLmN1cnZcbiAgICB9O1xuXG4gICAgaWYgKHBhcmFtcylcbiAgICAgIHRoaXMucGFyYW1zID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zLCB7IHAwOiB0aGlzLnN0YXJ0LmN1cnYsIHAzOiB0aGlzLmVuZC5jdXJ2IH0pO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuZ3Vlc3NJbml0aWFsUGFyYW1zKCk7XG5cbiAgICB0aGlzLmNvbnZlcmdlZCA9IGZhbHNlO1xuICB9XG5cbiAgZ3Vlc3NJbml0aWFsUGFyYW1zKCkge1xuICAgIGNvbnN0IG9yaWdpbmFsR29hbCA9IHRoaXMuZ29hbDtcbiAgICBjb25zdCBkU3RhcnRDdXJ2ID0gdGhpcy5zdGFydC5jdXJ2IC8gUkVMQVhBVElPTl9JVEVSQVRJT05TO1xuICAgIGNvbnN0IGRHb2FsWSA9IG9yaWdpbmFsR29hbC55IC8gUkVMQVhBVElPTl9JVEVSQVRJT05TO1xuICAgIGNvbnN0IGRHb2FsUm90ID0gb3JpZ2luYWxHb2FsLnJvdCAvIFJFTEFYQVRJT05fSVRFUkFUSU9OUztcbiAgICBjb25zdCBkR29hbEN1cnYgPSBvcmlnaW5hbEdvYWwuY3VydiAvIFJFTEFYQVRJT05fSVRFUkFUSU9OUztcblxuICAgIHRoaXMuZ29hbCA9IHtcbiAgICAgIHg6IG9yaWdpbmFsR29hbC54LFxuICAgICAgeTogMCxcbiAgICAgIHJvdDogMCxcbiAgICAgIGN1cnY6IDBcbiAgICB9O1xuXG4gICAgdGhpcy5wYXJhbXMgPSB7XG4gICAgICBwMDogMCxcbiAgICAgIHAxOiAwLFxuICAgICAgcDI6IDAsXG4gICAgICBwMzogMCxcbiAgICAgIHNHOiBvcmlnaW5hbEdvYWwueFxuICAgIH07XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IFJFTEFYQVRJT05fSVRFUkFUSU9OUzsgaSsrKSB7XG4gICAgICB0aGlzLnBhcmFtcy5wMCArPSBkU3RhcnRDdXJ2O1xuICAgICAgdGhpcy5wYXJhbXMucDMgKz0gZEdvYWxDdXJ2O1xuICAgICAgdGhpcy5nb2FsLnkgKz0gZEdvYWxZO1xuICAgICAgdGhpcy5nb2FsLnJvdCArPSBkR29hbFJvdDtcbiAgICAgIHRoaXMuZ29hbC5jdXJ2ICs9IGRHb2FsQ3VydjtcblxuICAgICAgdGhpcy5pdGVyYXRlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5nb2FsID0gb3JpZ2luYWxHb2FsO1xuICB9XG5cbiAgb3B0aW1pemUoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBORVdUT05fSVRFUkFUSU9OUzsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5pdGVyYXRlKCkpIHtcbiAgICAgICAgdGhpcy5jb252ZXJnZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNvbnZlcmdlZCA9IGZhbHNlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGl0ZXJhdGUoKSB7XG4gICAgY29uc3QgeyBwMCwgcDEsIHAyLCBwMywgc0cgfSA9IHRoaXMucGFyYW1zO1xuXG4gICAgY29uc3QgZHMgPSBzRyAvIFNJTVBTT05TX0lOVEVSVkFMUztcbiAgICBjb25zdCBzR18yID0gc0cgKiBzRztcbiAgICBjb25zdCBzR18zID0gc0dfMiAqIHNHO1xuXG4gICAgbGV0IGRYX3AxID0gMDtcbiAgICBsZXQgZFhfcDIgPSAwO1xuICAgIGxldCBkWF9zRyA9IDA7XG4gICAgbGV0IGRZX3AxID0gMDtcbiAgICBsZXQgZFlfcDIgPSAwO1xuICAgIGxldCBkWV9zRyA9IDA7XG4gICAgbGV0IGd1ZXNzWCA9IDA7XG4gICAgbGV0IGd1ZXNzWSA9IDA7XG5cbiAgICBsZXQgdGhldGEsIGNvc1RoZXRhLCBzaW5UaGV0YSwgZFRfcDEsIGRUX3AyLCBkVF9zRztcblxuICAgIGZvciAobGV0IGkgPSAwLCBzID0gMDsgaSA8PSBTSU1QU09OU19JTlRFUlZBTFM7IGkrKywgcyArPSBkcykge1xuICAgICAgY29uc3QgY29lZmYgPSBpID09IDAgfHwgaSA9PSBTSU1QU09OU19JTlRFUlZBTFMgPyAxIDogaSAlIDIgPT0gMCA/IDIgOiA0O1xuXG4gICAgICBjb25zdCBhID0gcDA7XG4gICAgICBjb25zdCBiID0gKC01LjUgKiBwMCArIDkgKiBwMSAtIDQuNSAqIHAyICsgcDMpIC8gc0c7XG4gICAgICBjb25zdCBjID0gKDkgKiBwMCAtIDIyLjUgKiBwMSArIDE4ICogcDIgLSA0LjUgKiBwMykgLyBzR18yO1xuICAgICAgY29uc3QgZCA9ICgtNC41ICogKHAwIC0gMyAqIHAxICsgMyAqIHAyIC0gcDMpKSAvIHNHXzM7XG5cbiAgICAgIHRoZXRhID0gKCgoZCAqIHMgLyA0ICsgYyAvIDMpICogcyArIGIgLyAyKSAqIHMgKyBhKSAqIHM7XG4gICAgICBjb3NUaGV0YSA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgIHNpblRoZXRhID0gTWF0aC5zaW4odGhldGEpO1xuXG4gICAgICBjb25zdCBzX3NHID0gcyAvIHNHO1xuICAgICAgZFRfcDEgPSAoKDMuMzc1ICogc19zRyAtIDcuNSkgKiBzX3NHICsgNC41KSAqIHNfc0cgKiBzO1xuICAgICAgZFRfcDIgPSAoKC0zLjM3NSAqIHNfc0cgKyA2KSAqIHNfc0cgLSAyLjI1KSAqIHNfc0cgKiBzO1xuICAgICAgZFRfc0cgPSAoKDMuMzc1ICogKHAwIC0gMyAqIHAxICsgMyAqIHAyIC0gcDMpICogc19zRyAtIDMgKiAoMiAqIHAwIC0gNSAqIHAxICsgNCAqIHAyIC0gcDMpKSAqIHNfc0cgKyAwLjI1ICogKDExICogcDAgLSAxOCAqIHAxICsgOSAqIHAyIC0gMiAqIHAzKSkgKiBzX3NHICogc19zRztcblxuICAgICAgZFhfcDEgLT0gY29lZmYgKiBzaW5UaGV0YSAqIGRUX3AxO1xuICAgICAgZFhfcDIgLT0gY29lZmYgKiBzaW5UaGV0YSAqIGRUX3AyO1xuICAgICAgZFhfc0cgLT0gY29lZmYgKiBzaW5UaGV0YSAqIGRUX3NHO1xuXG4gICAgICBkWV9wMSArPSBjb2VmZiAqIGNvc1RoZXRhICogZFRfcDE7XG4gICAgICBkWV9wMiArPSBjb2VmZiAqIGNvc1RoZXRhICogZFRfcDI7XG4gICAgICBkWV9zRyArPSBjb2VmZiAqIGNvc1RoZXRhICogZFRfc0c7XG5cbiAgICAgIGd1ZXNzWCArPSBjb2VmZiAqIGNvc1RoZXRhO1xuICAgICAgZ3Vlc3NZICs9IGNvZWZmICogc2luVGhldGE7XG4gICAgfVxuXG4gICAgLy8gQWZ0ZXIgdGhlIFNpbXBzb24ncyBpbnRlZ3JhdGlvbiBsb29wLCBgdGhldGFgLCBgY29zVGhldGFgLCBgc2luVGhldGFgLFxuICAgIC8vIGBkVF9wMWAsIGBkVF9wMmAsIGFuZCBgZFRfc0dgIGhvbGQgdGhlIGFwcHJvcHJpYXRlIHZhbHVlcyBmb3IgYHNHYC5cblxuICAgIGNvbnN0IGhPdmVyMyA9IHNHIC8gU0lNUFNPTlNfSU5URVJWQUxTIC8gMztcblxuICAgIGNvbnN0IGRlbHRhWCA9IHRoaXMuZ29hbC54IC0gZ3Vlc3NYICogaE92ZXIzO1xuICAgIGNvbnN0IGRlbHRhWSA9IHRoaXMuZ29hbC55IC0gZ3Vlc3NZICogaE92ZXIzO1xuICAgIGNvbnN0IGRlbHRhUm90ID0gTWF0aC53cmFwQW5nbGUodGhpcy5nb2FsLnJvdCAtIHRoZXRhKTtcblxuICAgIGlmIChNYXRoLmFicyhkZWx0YVgpICsgTWF0aC5hYnMoZGVsdGFZKSArIE1hdGguYWJzKGRlbHRhUm90KSA8IENPTlZFUkdFTkNFX0VSUk9SKVxuICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICBqYWNvYmlhbi5zZXQoXG4gICAgICBkWF9wMSAqIGhPdmVyMywgZFhfcDIgKiBoT3ZlcjMsIGNvc1RoZXRhICsgZFhfc0cgKiBoT3ZlcjMsXG4gICAgICBkWV9wMSAqIGhPdmVyMywgZFlfcDIgKiBoT3ZlcjMsIHNpblRoZXRhICsgZFlfc0cgKiBoT3ZlcjMsXG4gICAgICBkVF9wMSwgZFRfcDIsIGRUX3NHXG4gICAgKTtcblxuICAgIGNvbnN0IFttMTEsIG0yMSwgbTMxLCBtMTIsIG0yMiwgbTMyLCBtMTMsIG0yMywgbTMzXSA9IGludkphY29iaWFuLmdldEludmVyc2UoamFjb2JpYW4pLmVsZW1lbnRzO1xuXG4gICAgdGhpcy5wYXJhbXMucDEgKz0gbTExICogZGVsdGFYICsgbTEyICogZGVsdGFZICsgbTEzICogZGVsdGFSb3Q7XG4gICAgdGhpcy5wYXJhbXMucDIgKz0gbTIxICogZGVsdGFYICsgbTIyICogZGVsdGFZICsgbTIzICogZGVsdGFSb3Q7XG4gICAgdGhpcy5wYXJhbXMuc0cgKz0gbTMxICogZGVsdGFYICsgbTMyICogZGVsdGFZICsgbTMzICogZGVsdGFSb3Q7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBidWlsZFBhdGgobnVtKSB7XG4gICAgY29uc3QgeyBwMCwgcDEsIHAyLCBwMywgc0cgfSA9IHRoaXMucGFyYW1zO1xuXG4gICAgY29uc3Qgc0dfMiA9IHNHICogc0c7XG4gICAgY29uc3Qgc0dfMyA9IHNHXzIgKiBzRztcblxuICAgIGNvbnN0IGEgPSBwMDtcbiAgICBjb25zdCBiID0gKC01LjUgKiBwMCArIDkgKiBwMSAtIDQuNSAqIHAyICsgcDMpIC8gc0c7XG4gICAgY29uc3QgYyA9ICg5ICogcDAgLSAyMi41ICogcDEgKyAxOCAqIHAyIC0gNC41ICogcDMpIC8gc0dfMjtcbiAgICBjb25zdCBkID0gKC00LjUgKiAocDAgLSAzICogcDEgKyAzICogcDIgLSBwMykpIC8gc0dfMztcblxuICAgIGNvbnN0IHBhdGggPSBbeyBwb3M6IG5ldyBUSFJFRS5WZWN0b3IyKHRoaXMuc3RhcnQueCwgdGhpcy5zdGFydC55KSwgcm90OiB0aGlzLnN0YXJ0LnJvdCwgY3VydjogdGhpcy5zdGFydC5jdXJ2IH1dO1xuICAgIGNvbnN0IGRzID0gc0cgLyAobnVtIC0gMSk7XG4gICAgbGV0IHMgPSBkcztcbiAgICBsZXQgZHggPSAwO1xuICAgIGxldCBkeSA9IDA7XG4gICAgbGV0IHByZXZDb3NSb3QgPSBNYXRoLmNvcyhwYXRoWzBdLnJvdCk7XG4gICAgbGV0IHByZXZTaW5Sb3QgPSBNYXRoLnNpbihwYXRoWzBdLnJvdCk7XG5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG51bSAtIDE7IGkrKykge1xuICAgICAgY29uc3Qgcm90ID0gKCgoZCAqIHMgLyA0ICsgYyAvIDMpICogcyArIGIgLyAyKSAqIHMgKyBhKSAqIHMgKyB0aGlzLnN0YXJ0LnJvdDtcbiAgICAgIGNvbnN0IGN1cnYgPSAoKGQgKiBzICsgYykgKiBzICsgYikgKiBzICsgYTtcbiAgICAgIGNvbnN0IGNvc1JvdCA9IE1hdGguY29zKHJvdCk7XG4gICAgICBjb25zdCBzaW5Sb3QgPSBNYXRoLnNpbihyb3QpO1xuXG4gICAgICBkeCA9IGR4ICogKGkgLSAxKSAvIGkgKyAoY29zUm90ICsgcHJldkNvc1JvdCkgLyAoMiAqIGkpO1xuICAgICAgZHkgPSBkeSAqIChpIC0gMSkgLyBpICsgKHNpblJvdCArIHByZXZTaW5Sb3QpIC8gKDIgKiBpKTtcblxuICAgICAgcGF0aC5wdXNoKHsgcG9zOiBuZXcgVEhSRUUuVmVjdG9yMihzICogZHggKyB0aGlzLnN0YXJ0LngsIHMgKiBkeSArIHRoaXMuc3RhcnQueSksIHJvdDogcm90LCBjdXJ2OiBjdXJ2IH0pO1xuXG4gICAgICBzICs9IGRzO1xuICAgICAgcHJldkNvc1JvdCA9IGNvc1JvdDtcbiAgICAgIHByZXZTaW5Sb3QgPSBzaW5Sb3Q7XG4gICAgfVxuXG4gICAgcGF0aC5wdXNoKHsgcG9zOiBuZXcgVEhSRUUuVmVjdG9yMih0aGlzLmVuZC54LCB0aGlzLmVuZC55KSwgcm90OiB0aGlzLmVuZC5yb3QsIGN1cnY6IHRoaXMuZW5kLmN1cnYgfSk7XG5cbiAgICByZXR1cm4gcGF0aDtcbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/autonomy/path-planning/CubicPath.js\n");

/***/ }),

/***/ "./js/autonomy/path-planning/PathPlanner.js":
/*!**************************************************!*\
  !*** ./js/autonomy/path-planning/PathPlanner.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PathPlanner; });\n/* harmony import */ var _GPGPU_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../GPGPU.js */ \"./js/GPGPU.js\");\n/* harmony import */ var _physics_Car_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../physics/Car.js */ \"./js/physics/Car.js\");\n/* harmony import */ var _CubicPath_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CubicPath.js */ \"./js/autonomy/path-planning/CubicPath.js\");\n/* harmony import */ var _QuinticPath_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./QuinticPath.js */ \"./js/autonomy/path-planning/QuinticPath.js\");\n/* harmony import */ var _gpgpu_programs_xyObstacleGrid_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gpgpu-programs/xyObstacleGrid.js */ \"./js/autonomy/path-planning/gpgpu-programs/xyObstacleGrid.js\");\n/* harmony import */ var _gpgpu_programs_slObstacleGrid_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./gpgpu-programs/slObstacleGrid.js */ \"./js/autonomy/path-planning/gpgpu-programs/slObstacleGrid.js\");\n/* harmony import */ var _gpgpu_programs_slObstacleGridDilation_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./gpgpu-programs/slObstacleGridDilation.js */ \"./js/autonomy/path-planning/gpgpu-programs/slObstacleGridDilation.js\");\n/* harmony import */ var _gpgpu_programs_slDynamicObstacleGrid_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./gpgpu-programs/slDynamicObstacleGrid.js */ \"./js/autonomy/path-planning/gpgpu-programs/slDynamicObstacleGrid.js\");\n/* harmony import */ var _gpgpu_programs_xyslMap_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./gpgpu-programs/xyslMap.js */ \"./js/autonomy/path-planning/gpgpu-programs/xyslMap.js\");\n/* harmony import */ var _gpgpu_programs_optimizeCubicPaths_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./gpgpu-programs/optimizeCubicPaths.js */ \"./js/autonomy/path-planning/gpgpu-programs/optimizeCubicPaths.js\");\n/* harmony import */ var _gpgpu_programs_optimizeQuinticPaths_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./gpgpu-programs/optimizeQuinticPaths.js */ \"./js/autonomy/path-planning/gpgpu-programs/optimizeQuinticPaths.js\");\n/* harmony import */ var _gpgpu_programs_pathFromVehicleCosts_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./gpgpu-programs/pathFromVehicleCosts.js */ \"./js/autonomy/path-planning/gpgpu-programs/pathFromVehicleCosts.js\");\n/* harmony import */ var _gpgpu_programs_graphSearch_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./gpgpu-programs/graphSearch.js */ \"./js/autonomy/path-planning/gpgpu-programs/graphSearch.js\");\n/* harmony import */ var _gpgpu_programs_xyObstacleCostGrid_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./gpgpu-programs/xyObstacleCostGrid.js */ \"./js/autonomy/path-planning/gpgpu-programs/xyObstacleCostGrid.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst NUM_ACCELERATION_PROFILES = 8;\nconst NUM_VELOCITY_RANGES = 4;\nconst NUM_TIME_RANGES = 2;\n\n/* Obstacle cost map:\n *\n * 1. Rasterize triangles from polygonal obstacles into XY-space occupancy grid\n * 2. Convert occupancy grid to SL-space\n *    * Width is spatial horizon of the state lattice\n *    * Height is lane width\n *    * Resolution should be higher than XY-grid\n *    * Get XY position from centerline texture\n *    * Lookup XY in XY occupancy grid (nearest)\n * 3. Dilate SL-space grid using two passes (along station, then along latitude)\n *    * collision area: half car size + 0.3m\n *    * high cost area: 1 meter\n * 4. Convert back to XY-space using XYSL map\n */\n\nclass PathPlanner {\n  constructor() {\n    this.previousStartStation = null;\n    this.previousFirstLatticePoint = -1;\n    this.previousSecondLatticePoint = -1;\n    this.previousFirstAcceleration = -1;\n    this.previousSecondLatticePoint = -1;\n\n    let start = performance.now();\n    const programs = [\n      _gpgpu_programs_xyObstacleGrid_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].setUp(),\n      _gpgpu_programs_slObstacleGrid_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].setUp(),\n      ..._gpgpu_programs_slObstacleGridDilation_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].setUp(),\n      _gpgpu_programs_slDynamicObstacleGrid_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].setUp(),\n      _gpgpu_programs_xyslMap_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].setUp(),\n      ..._gpgpu_programs_optimizeCubicPaths_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"].setUp(),\n      _gpgpu_programs_optimizeQuinticPaths_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].setUp(),\n      ..._gpgpu_programs_pathFromVehicleCosts_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"].setUp(),\n      _gpgpu_programs_graphSearch_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"].setUp(),\n    ].map(p => Object.assign({}, p, { width: 1, height: 1 }));\n\n    this.gpgpu = new _GPGPU_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](programs);\n  }\n\n  reset() {\n    this.previousStartStation = null;\n    this.previousFirstLatticePoint = -1;\n    this.previousSecondLatticePoint = -1;\n    this.previousFirstAcceleration = -1;\n    this.previousSecondLatticePoint = -1;\n  }\n\n  plan(vehiclePose, vehicleStation, lanePath, startTime, staticObstacles, dynamicObstacles) {\n    const latticeStationInterval = this._latticeStationInterval();\n\n    const centerlineRaw = lanePath.sampleStations(vehicleStation, Math.ceil((this.config.spatialHorizon + latticeStationInterval) / this.config.centerlineStationInterval) + 1, this.config.centerlineStationInterval);\n\n    // Transform all centerline points into vehicle frame\n    const vehicleXform = vehicleTransform(vehiclePose);\n    const centerline = centerlineRaw.map(c => { return { pos: c.pos.clone().applyMatrix3(vehicleXform), rot: c.rot - vehiclePose.rot, curv: c.curv } });\n\n    const centerlineData = new Float32Array(centerline.length * 3);\n    const maxPoint = new THREE.Vector2(0, 0);\n    const minPoint = new THREE.Vector2(0, 0);\n\n    for (let i = 0; i < centerline.length; i++) {\n      const sample = centerline[i];\n      const pos = sample.pos;\n      centerlineData[i * 3 + 0] = pos.x;\n      centerlineData[i * 3 + 1] = pos.y;\n      centerlineData[i * 3 + 2] = sample.rot;\n\n      maxPoint.max(pos);\n      minPoint.min(pos);\n    }\n\n    const diff = maxPoint.clone().sub(minPoint);\n    const xyCenterPoint = minPoint.clone().add(maxPoint).divideScalar(2);\n\n    // Sizes of the xy grids (in pixels, not meters)\n    const xyWidth = Math.ceil((diff.x + this.config.gridMargin * 2) / this.config.xyGridCellSize);\n    const xyHeight = Math.ceil((diff.y + this.config.gridMargin * 2) / this.config.xyGridCellSize);\n\n    const stationWidth = this.config.spatialHorizon + latticeStationInterval * 2;\n    const slCenterPoint = new THREE.Vector2(this.config.spatialHorizon / 2, 0);\n\n    // Sizes of the sl grids (in pixels, not meters)\n    const slWidth = Math.ceil(stationWidth / this.config.slGridCellSize);\n    const slHeight = Math.ceil((this.config.roadWidth + this.config.gridMargin * 2) / this.config.slGridCellSize);\n\n    let startStation;\n\n    if (this.previousStartStation === null || vehicleStation + latticeStationInterval / 2 > this.previousStartStation) {\n      startStation = (this.previousStartStation === null ? vehicleStation : this.previousStartStation) + latticeStationInterval;\n      this.previousStartStation = startStation;\n      this.previousFirstLatticePoint -= this.config.lattice.numLatitudes;\n      this.previousSecondLatticePoint -= this.config.lattice.numLatitudes;\n    } else {\n      startStation = this.previousStartStation;\n    }\n\n    const lattice = this._buildLattice(lanePath, startStation, vehiclePose.rot, vehicleXform);\n\n    const temporalHorizon = this.config.spatialHorizon / this.config.speedLimit;\n    const dynamicFrameTime = temporalHorizon / this.config.numDynamicFrames;\n\n    for (const [i, p] of [\n      _gpgpu_programs_xyObstacleGrid_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].update(this.config, xyWidth, xyHeight, xyCenterPoint, vehicleXform, staticObstacles),\n      _gpgpu_programs_slObstacleGrid_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].update(this.config, slWidth, slHeight, slCenterPoint, xyCenterPoint),\n      ..._gpgpu_programs_slObstacleGridDilation_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"].update(this.config, slWidth, slHeight),\n      _gpgpu_programs_slDynamicObstacleGrid_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"].update(this.config, slWidth, slHeight, slCenterPoint, vehicleStation, startTime, dynamicFrameTime, dynamicObstacles),\n      _gpgpu_programs_xyslMap_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"].update(this.config, xyWidth, xyHeight, xyCenterPoint),\n      ..._gpgpu_programs_optimizeCubicPaths_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"].update(this.config, vehiclePose),\n      _gpgpu_programs_optimizeQuinticPaths_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"].update(this.config, vehiclePose),\n      ..._gpgpu_programs_pathFromVehicleCosts_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"].update(this.config, vehiclePose, xyCenterPoint, slCenterPoint, this.previousFirstLatticePoint, this.previousSecondLatticePoint, dynamicFrameTime),\n      _gpgpu_programs_graphSearch_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"].update(this.config, vehiclePose, xyCenterPoint, slCenterPoint, this.previousFirstLatticePoint, this.previousSecondLatticePoint, dynamicFrameTime)\n    ].entries()) {\n      this.gpgpu.updateProgram(i, p);\n    }\n\n    this.gpgpu.updateSharedTextures({\n      centerline: {\n        width: centerline.length,\n        height: 1,\n        channels: 3,\n        filter: 'linear',\n        data: centerlineData\n      },\n      costTable: {\n        width: NUM_ACCELERATION_PROFILES * NUM_VELOCITY_RANGES * NUM_TIME_RANGES,\n        height: this.config.lattice.numLatitudes,\n        depth: this.config.lattice.numStations,\n        channels: 4,\n        textureType: '2DArray'\n      },\n      lattice: {\n        width: this.config.lattice.numLatitudes,\n        height: this.config.lattice.numStations,\n        channels: 4,\n        data: lattice\n      }\n    });\n\n    this.gpgpu._graphSearchCostTable = null;\n    this.gpgpu._dynamicObstacleGrid = null;\n\n    let start = performance.now();\n    const outputs = this.gpgpu.run();\n    const costTable = this.gpgpu._graphSearchCostTable;\n    const cubicPathParams = outputs[6];\n    const cubicPathFromVehicleParams = outputs[7];\n    const quinticPathFromVehicleParams = outputs[8];\n\n    let bestEntry = [Number.POSITIVE_INFINITY];\n    let bestEntryIndex;\n    const numEntries = costTable.length / 4;\n\n    for (let i = 0; i < numEntries; i++) {\n      const entryUnpacked = this._unpackCostTableIndex(i);\n      const entry = [\n        costTable[i * 4],\n        costTable[i * 4 + 1],\n        costTable[i * 4 + 2],\n        costTable[i * 4 + 3]\n      ];\n\n      if (entry[0] < 0) continue;\n\n      entry[0] += this._terminalCost(entryUnpacked, entry);\n\n      if (entry[0] < bestEntry[0]) {\n        bestEntryIndex = i;\n        bestEntry = entry;\n      }\n    }\n\n    const inverseVehicleXform = (new THREE.Matrix3()).getInverse(vehicleXform);\n    let bestTrajectory = null;\n    let fromVehicleSegment = null;\n    let fromVehicleParams = null;\n    let firstLatticePoint = -1;\n    let firstAcceleration = -1;\n    let secondLatticePoint = -1;\n    let secondAcceleration = -1;\n\n    if (isFinite(bestEntry[0])) {\n      [bestTrajectory, fromVehicleSegment, fromVehicleParams, firstLatticePoint, firstAcceleration, secondLatticePoint, secondAcceleration] = this._reconstructTrajectory(\n        bestEntryIndex,\n        costTable,\n        cubicPathParams,\n        cubicPathFromVehicleParams,\n        quinticPathFromVehicleParams,\n        vehiclePose,\n        lattice\n      );\n\n      fromVehicleSegment.forEach(p => {\n        p.pos = p.pos.applyMatrix3(inverseVehicleXform);\n        p.rot += vehiclePose.rot;\n      });\n\n      bestTrajectory.forEach(p => {\n        p.pos = p.pos.applyMatrix3(inverseVehicleXform);\n        p.rot += vehiclePose.rot;\n      });\n    }\n\n    this.previousFirstLatticePoint = firstLatticePoint;\n    this.previousFirstAcceleration = firstAcceleration;\n    this.previousSecondLatticePoint = secondLatticePoint;\n    this.previousSecondAcceleration = secondAcceleration;\n\n    return {\n      path: bestTrajectory,\n      fromVehicleSegment: fromVehicleSegment,\n      fromVehicleParams: fromVehicleParams,\n      latticeStartStation: this.previousStartStation,\n      dynamicObstacleGrid: { data: this.gpgpu._dynamicObstacleGrid, width: slWidth, height: slHeight }\n    };\n  }\n\n  _buildLattice(lanePath, startStation, vehicleRot, vehicleXform) {\n    const centerline = lanePath.sampleStations(startStation, this.config.lattice.numStations, this._latticeStationInterval());\n    const offset = Math.floor(this.config.lattice.numLatitudes / 2);\n    const lattice = new Float32Array(this.config.lattice.numStations * this.config.lattice.numLatitudes * 4);\n    let index = 0;\n\n    for (let s = 0; s < centerline.length; s++) {\n      const sample = centerline[s];\n\n      for (let l = 0; l < this.config.lattice.numLatitudes; l++) {\n        const latitude = (l - offset) / offset * this.config.roadWidth / 2;\n        const rot = sample.rot - vehicleRot;\n        const pos = THREE.Vector2.fromAngle(rot + Math.PI / 2).multiplyScalar(latitude).add(sample.pos.clone().applyMatrix3(vehicleXform));\n        const curv = sample.curv == 0 ? 0 : 1 / (1 / sample.curv - latitude);\n\n        lattice[index++] = pos.x;\n        lattice[index++] = pos.y;\n        lattice[index++] = rot;\n        lattice[index++] = curv;\n      }\n    }\n\n    return lattice;\n  }\n\n  _latticeStationInterval() {\n    return this.config.spatialHorizon / this.config.lattice.numStations;\n  }\n\n  _terminalCost([stationIndex, latitudeIndex, timeIndex, velocityIndex, accelerationIndex], [cost, finalVelocity, finalTime, incomingIndex]) {\n    // Only consider vertices that reach the end of the spatial or temporal horizon\n    if (stationIndex != this.config.lattice.numStations - 1 && finalVelocity > 0.05)\n      return Number.POSITIVE_INFINITY;\n\n    const station = (this.config.spatialHorizon / this.config.lattice.numStations) * (stationIndex + 1);\n\n    return station * -this.config.stationReachDiscount + finalTime * this.config.extraTimePenalty;\n  }\n\n  _unpackCostTableIndex(index) {\n    if (index < 0) return [-1, index + 2, null, null, null];\n\n    const numPerTime = NUM_ACCELERATION_PROFILES * NUM_VELOCITY_RANGES;\n    const numPerLatitude = numPerTime * NUM_TIME_RANGES;\n    const numPerStation = this.config.lattice.numLatitudes * numPerLatitude;\n\n    const stationIndex = Math.floor(index / numPerStation);\n    index -= stationIndex * numPerStation;\n\n    const latitudeIndex = Math.floor(index / numPerLatitude);\n    index -= latitudeIndex * numPerLatitude;\n\n    const timeIndex = Math.floor(index / numPerTime);\n    index -= timeIndex * numPerTime;\n\n    const velocityIndex = Math.floor(index / NUM_ACCELERATION_PROFILES);\n    const accelerationIndex = index % NUM_ACCELERATION_PROFILES;\n\n    return [stationIndex, latitudeIndex, timeIndex, velocityIndex, accelerationIndex];\n  }\n\n  _reconstructTrajectory(index, costTable, cubicPathParams, cubicPathFromVehicleParams, quinticPathFromVehicleParams, vehiclePose, lattice) {\n    let unpacked = this._unpackCostTableIndex(index);\n    unpacked.push(costTable[index * 4 + 1]);\n    const nodes = [unpacked];\n\n    let count = 0;\n    while (unpacked[0] >= 0 && count++ < 100) {\n      index = costTable[index * 4 + 3];\n      unpacked = this._unpackCostTableIndex(index);\n\n      const finalVelocity = unpacked[0] >= 0 ? costTable[index * 4 + 1] : vehiclePose.velocity;\n      unpacked.push(finalVelocity);\n\n      nodes.unshift(unpacked);\n    }\n    if (count >= 100) throw new Error('Infinite loop encountered while reconstructing trajectory.');\n\n    const points = [];\n    let fromVehicleSegment = [];\n    let fromVehicleParams = null;\n\n    for (let i = 0; i < nodes.length - 1; i++) {\n      const [prevStation, prevLatitude, _pt, _pv, _pa, prevVelocity] = nodes[i];\n      const [station, latitude, _t, _v, _a, velocity] = nodes[i + 1];\n\n      let length;\n      let pathBuilder;\n\n      if (prevStation < 0) {\n        const start = {\n          pos: new THREE.Vector2(0, 0),\n          rot: 0,\n          curv: vehiclePose.curv\n        };\n\n        const endIndex = (station * this.config.lattice.numLatitudes + latitude) * 4;\n        const end = {\n          pos: new THREE.Vector2(lattice[endIndex], lattice[endIndex + 1]),\n          rot: lattice[endIndex + 2],\n          curv: lattice[endIndex + 3]\n        };\n\n        if (prevLatitude == 0) { // Cubic path from vehicle to lattice node\n          length = cubicPathFromVehicleParams[endIndex + 2];\n\n          const params = {\n            p1: cubicPathFromVehicleParams[endIndex],\n            p2: cubicPathFromVehicleParams[endIndex + 1],\n            sG: length\n          };\n\n          pathBuilder = new _CubicPath_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](start, end, params);\n\n          fromVehicleParams = { type: 'cubic', params: params };\n        } else { // Quintic path from vehicle to lattice node\n          length = quinticPathFromVehicleParams[endIndex + 2];\n\n          const params = {\n            p3: quinticPathFromVehicleParams[endIndex],\n            p4: quinticPathFromVehicleParams[endIndex + 1],\n            sG: length\n          };\n\n          pathBuilder = new _QuinticPath_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](start, end, params);\n\n          fromVehicleParams = { type: 'quintic', params: params };\n        }\n      } else {\n        const startIndex = (prevStation * this.config.lattice.numLatitudes + prevLatitude) * 4;\n        const endIndex = (station * this.config.lattice.numLatitudes + latitude) * 4;\n\n        const start = {\n          pos: new THREE.Vector2(lattice[startIndex], lattice[startIndex + 1]),\n          rot: lattice[startIndex + 2],\n          curv: lattice[startIndex + 3]\n        };\n\n        const end = {\n          pos: new THREE.Vector2(lattice[endIndex], lattice[endIndex + 1]),\n          rot: lattice[endIndex + 2],\n          curv: lattice[endIndex + 3]\n        };\n\n        const slIndex = station * this.config.lattice.numLatitudes + latitude;\n        const connectivityIndex = (prevStation - station + this.config.lattice.stationConnectivity) * this.config.lattice.latitudeConnectivity + prevLatitude - latitude + Math.floor(this.config.lattice.latitudeConnectivity / 2);\n        const cubicPathIndex = (connectivityIndex * this.config.lattice.numStations * this.config.lattice.numLatitudes + slIndex) * 4;\n\n        length = cubicPathParams[cubicPathIndex + 2];\n\n        pathBuilder = new _CubicPath_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](start, end, {\n          p1: cubicPathParams[cubicPathIndex],\n          p2: cubicPathParams[cubicPathIndex + 1],\n          sG: length\n        });\n      }\n\n      const path = pathBuilder.buildPath(Math.ceil(length / 0.25));\n\n      const prevVelocitySq = prevVelocity * prevVelocity;\n      const accel = (velocity * velocity - prevVelocitySq) / 2 / length;\n      const ds = length / (path.length - 1);\n      let s = 0;\n\n      for (let p = 0; p < path.length; p++) {\n        path[p].velocity = Math.sqrt(2 * accel * s + prevVelocitySq);\n        path[p].acceleration = accel;\n        s += ds;\n      }\n\n      if (prevStation < 0) {\n        fromVehicleSegment = path;\n      } else {\n        if (i > 0) path.shift();\n        points.push(...path);\n      }\n    }\n\n    let firstLatticePoint = null\n    let firstAcceleration = null;\n    let secondLatticePoint = null;\n    let secondAcceleration = null;\n\n    if (nodes.length >= 2) {\n      firstLatticePoint = nodes[1][0] * this.config.lattice.numLatitudes + nodes[1][1];\n      firstAcceleration = nodes[1][4];\n    }\n\n    if (nodes.length >= 3) {\n      secondLatticePoint = nodes[2][0] * this.config.lattice.numLatitudes + nodes[2][1];\n      secondAcceleration = nodes[2][4];\n    }\n\n    return [points, fromVehicleSegment, fromVehicleParams, firstLatticePoint, firstAcceleration, secondLatticePoint, secondAcceleration];\n  }\n}\n\nfunction vehicleTransform({ pos, rot }) {\n  const translate = new THREE.Matrix3();\n  translate.set(\n    1, 0, -pos.x,\n    0, 1, -pos.y,\n    0, 0, 1\n  );\n\n  const cosRot = Math.cos(rot);\n  const sinRot = Math.sin(rot);\n\n  const rotate = new THREE.Matrix3();\n  rotate.set(\n    cosRot, sinRot, 0,\n    -sinRot, cosRot, 0,\n    0, 0, 1\n  );\n\n  return rotate.multiply(translate);\n}\n\nfunction obstacleTransform(vehicleXform, xyCenterPoint, width, height) {\n  const translate = new THREE.Matrix3();\n  translate.set(\n    1, 0, -xyCenterPoint.x,\n    0, 1, -xyCenterPoint.y,\n    0, 0, 1\n  );\n\n  const scale = new THREE.Matrix3();\n  scale.set(\n    2 / width, 0, 0,\n    0, 2 / height, 0,\n    0, 0, 1\n  );\n\n  return scale.multiply(translate).multiply(vehicleXform);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL1BhdGhQbGFubmVyLmpzP2QzMjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNLHNCQUFzQjs7QUFFM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsU0FBUyw0RkFBNEYsRUFBRTs7QUFFdEo7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix1QkFBdUI7QUFDMUM7O0FBRUEscUJBQXFCLHNDQUFzQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0JBQStCO0FBQy9CLFNBQVMsT0FBTztBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGlCQUFpQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsV0FBVztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiIuL2pzL2F1dG9ub215L3BhdGgtcGxhbm5pbmcvUGF0aFBsYW5uZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgR1BHUFUgZnJvbSBcIi4uLy4uL0dQR1BVLmpzXCI7XG5pbXBvcnQgQ2FyIGZyb20gXCIuLi8uLi9waHlzaWNzL0Nhci5qc1wiO1xuaW1wb3J0IEN1YmljUGF0aCBmcm9tIFwiLi9DdWJpY1BhdGguanNcIjtcbmltcG9ydCBRdWludGljUGF0aCBmcm9tIFwiLi9RdWludGljUGF0aC5qc1wiO1xuaW1wb3J0IHh5T2JzdGFjbGVHcmlkIGZyb20gXCIuL2dwZ3B1LXByb2dyYW1zL3h5T2JzdGFjbGVHcmlkLmpzXCI7XG5pbXBvcnQgc2xPYnN0YWNsZUdyaWQgZnJvbSBcIi4vZ3BncHUtcHJvZ3JhbXMvc2xPYnN0YWNsZUdyaWQuanNcIjtcbmltcG9ydCBzbE9ic3RhY2xlR3JpZERpbGF0aW9uIGZyb20gXCIuL2dwZ3B1LXByb2dyYW1zL3NsT2JzdGFjbGVHcmlkRGlsYXRpb24uanNcIjtcbmltcG9ydCBzbER5bmFtaWNPYnN0YWNsZUdyaWQgZnJvbSBcIi4vZ3BncHUtcHJvZ3JhbXMvc2xEeW5hbWljT2JzdGFjbGVHcmlkLmpzXCI7XG5pbXBvcnQgeHlzbE1hcCBmcm9tIFwiLi9ncGdwdS1wcm9ncmFtcy94eXNsTWFwLmpzXCI7XG5pbXBvcnQgb3B0aW1pemVDdWJpY1BhdGhzIGZyb20gXCIuL2dwZ3B1LXByb2dyYW1zL29wdGltaXplQ3ViaWNQYXRocy5qc1wiO1xuaW1wb3J0IG9wdGltaXplUXVpbnRpY1BhdGhzIGZyb20gXCIuL2dwZ3B1LXByb2dyYW1zL29wdGltaXplUXVpbnRpY1BhdGhzLmpzXCI7XG5pbXBvcnQgcGF0aEZyb21WZWhpY2xlQ29zdHMgZnJvbSBcIi4vZ3BncHUtcHJvZ3JhbXMvcGF0aEZyb21WZWhpY2xlQ29zdHMuanNcIjtcbmltcG9ydCBncmFwaFNlYXJjaCBmcm9tIFwiLi9ncGdwdS1wcm9ncmFtcy9ncmFwaFNlYXJjaC5qc1wiO1xuaW1wb3J0IHh5T2JzdGFjbGVDb3N0R3JpZCBmcm9tIFwiLi9ncGdwdS1wcm9ncmFtcy94eU9ic3RhY2xlQ29zdEdyaWQuanNcIjtcblxuY29uc3QgTlVNX0FDQ0VMRVJBVElPTl9QUk9GSUxFUyA9IDg7XG5jb25zdCBOVU1fVkVMT0NJVFlfUkFOR0VTID0gNDtcbmNvbnN0IE5VTV9USU1FX1JBTkdFUyA9IDI7XG5cbi8qIE9ic3RhY2xlIGNvc3QgbWFwOlxuICpcbiAqIDEuIFJhc3Rlcml6ZSB0cmlhbmdsZXMgZnJvbSBwb2x5Z29uYWwgb2JzdGFjbGVzIGludG8gWFktc3BhY2Ugb2NjdXBhbmN5IGdyaWRcbiAqIDIuIENvbnZlcnQgb2NjdXBhbmN5IGdyaWQgdG8gU0wtc3BhY2VcbiAqICAgICogV2lkdGggaXMgc3BhdGlhbCBob3Jpem9uIG9mIHRoZSBzdGF0ZSBsYXR0aWNlXG4gKiAgICAqIEhlaWdodCBpcyBsYW5lIHdpZHRoXG4gKiAgICAqIFJlc29sdXRpb24gc2hvdWxkIGJlIGhpZ2hlciB0aGFuIFhZLWdyaWRcbiAqICAgICogR2V0IFhZIHBvc2l0aW9uIGZyb20gY2VudGVybGluZSB0ZXh0dXJlXG4gKiAgICAqIExvb2t1cCBYWSBpbiBYWSBvY2N1cGFuY3kgZ3JpZCAobmVhcmVzdClcbiAqIDMuIERpbGF0ZSBTTC1zcGFjZSBncmlkIHVzaW5nIHR3byBwYXNzZXMgKGFsb25nIHN0YXRpb24sIHRoZW4gYWxvbmcgbGF0aXR1ZGUpXG4gKiAgICAqIGNvbGxpc2lvbiBhcmVhOiBoYWxmIGNhciBzaXplICsgMC4zbVxuICogICAgKiBoaWdoIGNvc3QgYXJlYTogMSBtZXRlclxuICogNC4gQ29udmVydCBiYWNrIHRvIFhZLXNwYWNlIHVzaW5nIFhZU0wgbWFwXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGF0aFBsYW5uZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnByZXZpb3VzU3RhcnRTdGF0aW9uID0gbnVsbDtcbiAgICB0aGlzLnByZXZpb3VzRmlyc3RMYXR0aWNlUG9pbnQgPSAtMTtcbiAgICB0aGlzLnByZXZpb3VzU2Vjb25kTGF0dGljZVBvaW50ID0gLTE7XG4gICAgdGhpcy5wcmV2aW91c0ZpcnN0QWNjZWxlcmF0aW9uID0gLTE7XG4gICAgdGhpcy5wcmV2aW91c1NlY29uZExhdHRpY2VQb2ludCA9IC0xO1xuXG4gICAgbGV0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3QgcHJvZ3JhbXMgPSBbXG4gICAgICB4eU9ic3RhY2xlR3JpZC5zZXRVcCgpLFxuICAgICAgc2xPYnN0YWNsZUdyaWQuc2V0VXAoKSxcbiAgICAgIC4uLnNsT2JzdGFjbGVHcmlkRGlsYXRpb24uc2V0VXAoKSxcbiAgICAgIHNsRHluYW1pY09ic3RhY2xlR3JpZC5zZXRVcCgpLFxuICAgICAgeHlzbE1hcC5zZXRVcCgpLFxuICAgICAgLi4ub3B0aW1pemVDdWJpY1BhdGhzLnNldFVwKCksXG4gICAgICBvcHRpbWl6ZVF1aW50aWNQYXRocy5zZXRVcCgpLFxuICAgICAgLi4ucGF0aEZyb21WZWhpY2xlQ29zdHMuc2V0VXAoKSxcbiAgICAgIGdyYXBoU2VhcmNoLnNldFVwKCksXG4gICAgXS5tYXAocCA9PiBPYmplY3QuYXNzaWduKHt9LCBwLCB7IHdpZHRoOiAxLCBoZWlnaHQ6IDEgfSkpO1xuXG4gICAgdGhpcy5ncGdwdSA9IG5ldyBHUEdQVShwcm9ncmFtcyk7XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLnByZXZpb3VzU3RhcnRTdGF0aW9uID0gbnVsbDtcbiAgICB0aGlzLnByZXZpb3VzRmlyc3RMYXR0aWNlUG9pbnQgPSAtMTtcbiAgICB0aGlzLnByZXZpb3VzU2Vjb25kTGF0dGljZVBvaW50ID0gLTE7XG4gICAgdGhpcy5wcmV2aW91c0ZpcnN0QWNjZWxlcmF0aW9uID0gLTE7XG4gICAgdGhpcy5wcmV2aW91c1NlY29uZExhdHRpY2VQb2ludCA9IC0xO1xuICB9XG5cbiAgcGxhbih2ZWhpY2xlUG9zZSwgdmVoaWNsZVN0YXRpb24sIGxhbmVQYXRoLCBzdGFydFRpbWUsIHN0YXRpY09ic3RhY2xlcywgZHluYW1pY09ic3RhY2xlcykge1xuICAgIGNvbnN0IGxhdHRpY2VTdGF0aW9uSW50ZXJ2YWwgPSB0aGlzLl9sYXR0aWNlU3RhdGlvbkludGVydmFsKCk7XG5cbiAgICBjb25zdCBjZW50ZXJsaW5lUmF3ID0gbGFuZVBhdGguc2FtcGxlU3RhdGlvbnModmVoaWNsZVN0YXRpb24sIE1hdGguY2VpbCgodGhpcy5jb25maWcuc3BhdGlhbEhvcml6b24gKyBsYXR0aWNlU3RhdGlvbkludGVydmFsKSAvIHRoaXMuY29uZmlnLmNlbnRlcmxpbmVTdGF0aW9uSW50ZXJ2YWwpICsgMSwgdGhpcy5jb25maWcuY2VudGVybGluZVN0YXRpb25JbnRlcnZhbCk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gYWxsIGNlbnRlcmxpbmUgcG9pbnRzIGludG8gdmVoaWNsZSBmcmFtZVxuICAgIGNvbnN0IHZlaGljbGVYZm9ybSA9IHZlaGljbGVUcmFuc2Zvcm0odmVoaWNsZVBvc2UpO1xuICAgIGNvbnN0IGNlbnRlcmxpbmUgPSBjZW50ZXJsaW5lUmF3Lm1hcChjID0+IHsgcmV0dXJuIHsgcG9zOiBjLnBvcy5jbG9uZSgpLmFwcGx5TWF0cml4Myh2ZWhpY2xlWGZvcm0pLCByb3Q6IGMucm90IC0gdmVoaWNsZVBvc2Uucm90LCBjdXJ2OiBjLmN1cnYgfSB9KTtcblxuICAgIGNvbnN0IGNlbnRlcmxpbmVEYXRhID0gbmV3IEZsb2F0MzJBcnJheShjZW50ZXJsaW5lLmxlbmd0aCAqIDMpO1xuICAgIGNvbnN0IG1heFBvaW50ID0gbmV3IFRIUkVFLlZlY3RvcjIoMCwgMCk7XG4gICAgY29uc3QgbWluUG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMigwLCAwKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2VudGVybGluZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2FtcGxlID0gY2VudGVybGluZVtpXTtcbiAgICAgIGNvbnN0IHBvcyA9IHNhbXBsZS5wb3M7XG4gICAgICBjZW50ZXJsaW5lRGF0YVtpICogMyArIDBdID0gcG9zLng7XG4gICAgICBjZW50ZXJsaW5lRGF0YVtpICogMyArIDFdID0gcG9zLnk7XG4gICAgICBjZW50ZXJsaW5lRGF0YVtpICogMyArIDJdID0gc2FtcGxlLnJvdDtcblxuICAgICAgbWF4UG9pbnQubWF4KHBvcyk7XG4gICAgICBtaW5Qb2ludC5taW4ocG9zKTtcbiAgICB9XG5cbiAgICBjb25zdCBkaWZmID0gbWF4UG9pbnQuY2xvbmUoKS5zdWIobWluUG9pbnQpO1xuICAgIGNvbnN0IHh5Q2VudGVyUG9pbnQgPSBtaW5Qb2ludC5jbG9uZSgpLmFkZChtYXhQb2ludCkuZGl2aWRlU2NhbGFyKDIpO1xuXG4gICAgLy8gU2l6ZXMgb2YgdGhlIHh5IGdyaWRzIChpbiBwaXhlbHMsIG5vdCBtZXRlcnMpXG4gICAgY29uc3QgeHlXaWR0aCA9IE1hdGguY2VpbCgoZGlmZi54ICsgdGhpcy5jb25maWcuZ3JpZE1hcmdpbiAqIDIpIC8gdGhpcy5jb25maWcueHlHcmlkQ2VsbFNpemUpO1xuICAgIGNvbnN0IHh5SGVpZ2h0ID0gTWF0aC5jZWlsKChkaWZmLnkgKyB0aGlzLmNvbmZpZy5ncmlkTWFyZ2luICogMikgLyB0aGlzLmNvbmZpZy54eUdyaWRDZWxsU2l6ZSk7XG5cbiAgICBjb25zdCBzdGF0aW9uV2lkdGggPSB0aGlzLmNvbmZpZy5zcGF0aWFsSG9yaXpvbiArIGxhdHRpY2VTdGF0aW9uSW50ZXJ2YWwgKiAyO1xuICAgIGNvbnN0IHNsQ2VudGVyUG9pbnQgPSBuZXcgVEhSRUUuVmVjdG9yMih0aGlzLmNvbmZpZy5zcGF0aWFsSG9yaXpvbiAvIDIsIDApO1xuXG4gICAgLy8gU2l6ZXMgb2YgdGhlIHNsIGdyaWRzIChpbiBwaXhlbHMsIG5vdCBtZXRlcnMpXG4gICAgY29uc3Qgc2xXaWR0aCA9IE1hdGguY2VpbChzdGF0aW9uV2lkdGggLyB0aGlzLmNvbmZpZy5zbEdyaWRDZWxsU2l6ZSk7XG4gICAgY29uc3Qgc2xIZWlnaHQgPSBNYXRoLmNlaWwoKHRoaXMuY29uZmlnLnJvYWRXaWR0aCArIHRoaXMuY29uZmlnLmdyaWRNYXJnaW4gKiAyKSAvIHRoaXMuY29uZmlnLnNsR3JpZENlbGxTaXplKTtcblxuICAgIGxldCBzdGFydFN0YXRpb247XG5cbiAgICBpZiAodGhpcy5wcmV2aW91c1N0YXJ0U3RhdGlvbiA9PT0gbnVsbCB8fCB2ZWhpY2xlU3RhdGlvbiArIGxhdHRpY2VTdGF0aW9uSW50ZXJ2YWwgLyAyID4gdGhpcy5wcmV2aW91c1N0YXJ0U3RhdGlvbikge1xuICAgICAgc3RhcnRTdGF0aW9uID0gKHRoaXMucHJldmlvdXNTdGFydFN0YXRpb24gPT09IG51bGwgPyB2ZWhpY2xlU3RhdGlvbiA6IHRoaXMucHJldmlvdXNTdGFydFN0YXRpb24pICsgbGF0dGljZVN0YXRpb25JbnRlcnZhbDtcbiAgICAgIHRoaXMucHJldmlvdXNTdGFydFN0YXRpb24gPSBzdGFydFN0YXRpb247XG4gICAgICB0aGlzLnByZXZpb3VzRmlyc3RMYXR0aWNlUG9pbnQgLT0gdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXM7XG4gICAgICB0aGlzLnByZXZpb3VzU2Vjb25kTGF0dGljZVBvaW50IC09IHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFN0YXRpb24gPSB0aGlzLnByZXZpb3VzU3RhcnRTdGF0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGxhdHRpY2UgPSB0aGlzLl9idWlsZExhdHRpY2UobGFuZVBhdGgsIHN0YXJ0U3RhdGlvbiwgdmVoaWNsZVBvc2Uucm90LCB2ZWhpY2xlWGZvcm0pO1xuXG4gICAgY29uc3QgdGVtcG9yYWxIb3Jpem9uID0gdGhpcy5jb25maWcuc3BhdGlhbEhvcml6b24gLyB0aGlzLmNvbmZpZy5zcGVlZExpbWl0O1xuICAgIGNvbnN0IGR5bmFtaWNGcmFtZVRpbWUgPSB0ZW1wb3JhbEhvcml6b24gLyB0aGlzLmNvbmZpZy5udW1EeW5hbWljRnJhbWVzO1xuXG4gICAgZm9yIChjb25zdCBbaSwgcF0gb2YgW1xuICAgICAgeHlPYnN0YWNsZUdyaWQudXBkYXRlKHRoaXMuY29uZmlnLCB4eVdpZHRoLCB4eUhlaWdodCwgeHlDZW50ZXJQb2ludCwgdmVoaWNsZVhmb3JtLCBzdGF0aWNPYnN0YWNsZXMpLFxuICAgICAgc2xPYnN0YWNsZUdyaWQudXBkYXRlKHRoaXMuY29uZmlnLCBzbFdpZHRoLCBzbEhlaWdodCwgc2xDZW50ZXJQb2ludCwgeHlDZW50ZXJQb2ludCksXG4gICAgICAuLi5zbE9ic3RhY2xlR3JpZERpbGF0aW9uLnVwZGF0ZSh0aGlzLmNvbmZpZywgc2xXaWR0aCwgc2xIZWlnaHQpLFxuICAgICAgc2xEeW5hbWljT2JzdGFjbGVHcmlkLnVwZGF0ZSh0aGlzLmNvbmZpZywgc2xXaWR0aCwgc2xIZWlnaHQsIHNsQ2VudGVyUG9pbnQsIHZlaGljbGVTdGF0aW9uLCBzdGFydFRpbWUsIGR5bmFtaWNGcmFtZVRpbWUsIGR5bmFtaWNPYnN0YWNsZXMpLFxuICAgICAgeHlzbE1hcC51cGRhdGUodGhpcy5jb25maWcsIHh5V2lkdGgsIHh5SGVpZ2h0LCB4eUNlbnRlclBvaW50KSxcbiAgICAgIC4uLm9wdGltaXplQ3ViaWNQYXRocy51cGRhdGUodGhpcy5jb25maWcsIHZlaGljbGVQb3NlKSxcbiAgICAgIG9wdGltaXplUXVpbnRpY1BhdGhzLnVwZGF0ZSh0aGlzLmNvbmZpZywgdmVoaWNsZVBvc2UpLFxuICAgICAgLi4ucGF0aEZyb21WZWhpY2xlQ29zdHMudXBkYXRlKHRoaXMuY29uZmlnLCB2ZWhpY2xlUG9zZSwgeHlDZW50ZXJQb2ludCwgc2xDZW50ZXJQb2ludCwgdGhpcy5wcmV2aW91c0ZpcnN0TGF0dGljZVBvaW50LCB0aGlzLnByZXZpb3VzU2Vjb25kTGF0dGljZVBvaW50LCBkeW5hbWljRnJhbWVUaW1lKSxcbiAgICAgIGdyYXBoU2VhcmNoLnVwZGF0ZSh0aGlzLmNvbmZpZywgdmVoaWNsZVBvc2UsIHh5Q2VudGVyUG9pbnQsIHNsQ2VudGVyUG9pbnQsIHRoaXMucHJldmlvdXNGaXJzdExhdHRpY2VQb2ludCwgdGhpcy5wcmV2aW91c1NlY29uZExhdHRpY2VQb2ludCwgZHluYW1pY0ZyYW1lVGltZSlcbiAgICBdLmVudHJpZXMoKSkge1xuICAgICAgdGhpcy5ncGdwdS51cGRhdGVQcm9ncmFtKGksIHApO1xuICAgIH1cblxuICAgIHRoaXMuZ3BncHUudXBkYXRlU2hhcmVkVGV4dHVyZXMoe1xuICAgICAgY2VudGVybGluZToge1xuICAgICAgICB3aWR0aDogY2VudGVybGluZS5sZW5ndGgsXG4gICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgY2hhbm5lbHM6IDMsXG4gICAgICAgIGZpbHRlcjogJ2xpbmVhcicsXG4gICAgICAgIGRhdGE6IGNlbnRlcmxpbmVEYXRhXG4gICAgICB9LFxuICAgICAgY29zdFRhYmxlOiB7XG4gICAgICAgIHdpZHRoOiBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTICogTlVNX1ZFTE9DSVRZX1JBTkdFUyAqIE5VTV9USU1FX1JBTkdFUyxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyxcbiAgICAgICAgZGVwdGg6IHRoaXMuY29uZmlnLmxhdHRpY2UubnVtU3RhdGlvbnMsXG4gICAgICAgIGNoYW5uZWxzOiA0LFxuICAgICAgICB0ZXh0dXJlVHlwZTogJzJEQXJyYXknXG4gICAgICB9LFxuICAgICAgbGF0dGljZToge1xuICAgICAgICB3aWR0aDogdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMsXG4gICAgICAgIGhlaWdodDogdGhpcy5jb25maWcubGF0dGljZS5udW1TdGF0aW9ucyxcbiAgICAgICAgY2hhbm5lbHM6IDQsXG4gICAgICAgIGRhdGE6IGxhdHRpY2VcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuZ3BncHUuX2dyYXBoU2VhcmNoQ29zdFRhYmxlID0gbnVsbDtcbiAgICB0aGlzLmdwZ3B1Ll9keW5hbWljT2JzdGFjbGVHcmlkID0gbnVsbDtcblxuICAgIGxldCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IG91dHB1dHMgPSB0aGlzLmdwZ3B1LnJ1bigpO1xuICAgIGNvbnN0IGNvc3RUYWJsZSA9IHRoaXMuZ3BncHUuX2dyYXBoU2VhcmNoQ29zdFRhYmxlO1xuICAgIGNvbnN0IGN1YmljUGF0aFBhcmFtcyA9IG91dHB1dHNbNl07XG4gICAgY29uc3QgY3ViaWNQYXRoRnJvbVZlaGljbGVQYXJhbXMgPSBvdXRwdXRzWzddO1xuICAgIGNvbnN0IHF1aW50aWNQYXRoRnJvbVZlaGljbGVQYXJhbXMgPSBvdXRwdXRzWzhdO1xuXG4gICAgbGV0IGJlc3RFbnRyeSA9IFtOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFldO1xuICAgIGxldCBiZXN0RW50cnlJbmRleDtcbiAgICBjb25zdCBudW1FbnRyaWVzID0gY29zdFRhYmxlLmxlbmd0aCAvIDQ7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUVudHJpZXM7IGkrKykge1xuICAgICAgY29uc3QgZW50cnlVbnBhY2tlZCA9IHRoaXMuX3VucGFja0Nvc3RUYWJsZUluZGV4KGkpO1xuICAgICAgY29uc3QgZW50cnkgPSBbXG4gICAgICAgIGNvc3RUYWJsZVtpICogNF0sXG4gICAgICAgIGNvc3RUYWJsZVtpICogNCArIDFdLFxuICAgICAgICBjb3N0VGFibGVbaSAqIDQgKyAyXSxcbiAgICAgICAgY29zdFRhYmxlW2kgKiA0ICsgM11cbiAgICAgIF07XG5cbiAgICAgIGlmIChlbnRyeVswXSA8IDApIGNvbnRpbnVlO1xuXG4gICAgICBlbnRyeVswXSArPSB0aGlzLl90ZXJtaW5hbENvc3QoZW50cnlVbnBhY2tlZCwgZW50cnkpO1xuXG4gICAgICBpZiAoZW50cnlbMF0gPCBiZXN0RW50cnlbMF0pIHtcbiAgICAgICAgYmVzdEVudHJ5SW5kZXggPSBpO1xuICAgICAgICBiZXN0RW50cnkgPSBlbnRyeTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpbnZlcnNlVmVoaWNsZVhmb3JtID0gKG5ldyBUSFJFRS5NYXRyaXgzKCkpLmdldEludmVyc2UodmVoaWNsZVhmb3JtKTtcbiAgICBsZXQgYmVzdFRyYWplY3RvcnkgPSBudWxsO1xuICAgIGxldCBmcm9tVmVoaWNsZVNlZ21lbnQgPSBudWxsO1xuICAgIGxldCBmcm9tVmVoaWNsZVBhcmFtcyA9IG51bGw7XG4gICAgbGV0IGZpcnN0TGF0dGljZVBvaW50ID0gLTE7XG4gICAgbGV0IGZpcnN0QWNjZWxlcmF0aW9uID0gLTE7XG4gICAgbGV0IHNlY29uZExhdHRpY2VQb2ludCA9IC0xO1xuICAgIGxldCBzZWNvbmRBY2NlbGVyYXRpb24gPSAtMTtcblxuICAgIGlmIChpc0Zpbml0ZShiZXN0RW50cnlbMF0pKSB7XG4gICAgICBbYmVzdFRyYWplY3RvcnksIGZyb21WZWhpY2xlU2VnbWVudCwgZnJvbVZlaGljbGVQYXJhbXMsIGZpcnN0TGF0dGljZVBvaW50LCBmaXJzdEFjY2VsZXJhdGlvbiwgc2Vjb25kTGF0dGljZVBvaW50LCBzZWNvbmRBY2NlbGVyYXRpb25dID0gdGhpcy5fcmVjb25zdHJ1Y3RUcmFqZWN0b3J5KFxuICAgICAgICBiZXN0RW50cnlJbmRleCxcbiAgICAgICAgY29zdFRhYmxlLFxuICAgICAgICBjdWJpY1BhdGhQYXJhbXMsXG4gICAgICAgIGN1YmljUGF0aEZyb21WZWhpY2xlUGFyYW1zLFxuICAgICAgICBxdWludGljUGF0aEZyb21WZWhpY2xlUGFyYW1zLFxuICAgICAgICB2ZWhpY2xlUG9zZSxcbiAgICAgICAgbGF0dGljZVxuICAgICAgKTtcblxuICAgICAgZnJvbVZlaGljbGVTZWdtZW50LmZvckVhY2gocCA9PiB7XG4gICAgICAgIHAucG9zID0gcC5wb3MuYXBwbHlNYXRyaXgzKGludmVyc2VWZWhpY2xlWGZvcm0pO1xuICAgICAgICBwLnJvdCArPSB2ZWhpY2xlUG9zZS5yb3Q7XG4gICAgICB9KTtcblxuICAgICAgYmVzdFRyYWplY3RvcnkuZm9yRWFjaChwID0+IHtcbiAgICAgICAgcC5wb3MgPSBwLnBvcy5hcHBseU1hdHJpeDMoaW52ZXJzZVZlaGljbGVYZm9ybSk7XG4gICAgICAgIHAucm90ICs9IHZlaGljbGVQb3NlLnJvdDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXMucHJldmlvdXNGaXJzdExhdHRpY2VQb2ludCA9IGZpcnN0TGF0dGljZVBvaW50O1xuICAgIHRoaXMucHJldmlvdXNGaXJzdEFjY2VsZXJhdGlvbiA9IGZpcnN0QWNjZWxlcmF0aW9uO1xuICAgIHRoaXMucHJldmlvdXNTZWNvbmRMYXR0aWNlUG9pbnQgPSBzZWNvbmRMYXR0aWNlUG9pbnQ7XG4gICAgdGhpcy5wcmV2aW91c1NlY29uZEFjY2VsZXJhdGlvbiA9IHNlY29uZEFjY2VsZXJhdGlvbjtcblxuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiBiZXN0VHJhamVjdG9yeSxcbiAgICAgIGZyb21WZWhpY2xlU2VnbWVudDogZnJvbVZlaGljbGVTZWdtZW50LFxuICAgICAgZnJvbVZlaGljbGVQYXJhbXM6IGZyb21WZWhpY2xlUGFyYW1zLFxuICAgICAgbGF0dGljZVN0YXJ0U3RhdGlvbjogdGhpcy5wcmV2aW91c1N0YXJ0U3RhdGlvbixcbiAgICAgIGR5bmFtaWNPYnN0YWNsZUdyaWQ6IHsgZGF0YTogdGhpcy5ncGdwdS5fZHluYW1pY09ic3RhY2xlR3JpZCwgd2lkdGg6IHNsV2lkdGgsIGhlaWdodDogc2xIZWlnaHQgfVxuICAgIH07XG4gIH1cblxuICBfYnVpbGRMYXR0aWNlKGxhbmVQYXRoLCBzdGFydFN0YXRpb24sIHZlaGljbGVSb3QsIHZlaGljbGVYZm9ybSkge1xuICAgIGNvbnN0IGNlbnRlcmxpbmUgPSBsYW5lUGF0aC5zYW1wbGVTdGF0aW9ucyhzdGFydFN0YXRpb24sIHRoaXMuY29uZmlnLmxhdHRpY2UubnVtU3RhdGlvbnMsIHRoaXMuX2xhdHRpY2VTdGF0aW9uSW50ZXJ2YWwoKSk7XG4gICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5mbG9vcih0aGlzLmNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyAvIDIpO1xuICAgIGNvbnN0IGxhdHRpY2UgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuY29uZmlnLmxhdHRpY2UubnVtU3RhdGlvbnMgKiB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyAqIDQpO1xuICAgIGxldCBpbmRleCA9IDA7XG5cbiAgICBmb3IgKGxldCBzID0gMDsgcyA8IGNlbnRlcmxpbmUubGVuZ3RoOyBzKyspIHtcbiAgICAgIGNvbnN0IHNhbXBsZSA9IGNlbnRlcmxpbmVbc107XG5cbiAgICAgIGZvciAobGV0IGwgPSAwOyBsIDwgdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXM7IGwrKykge1xuICAgICAgICBjb25zdCBsYXRpdHVkZSA9IChsIC0gb2Zmc2V0KSAvIG9mZnNldCAqIHRoaXMuY29uZmlnLnJvYWRXaWR0aCAvIDI7XG4gICAgICAgIGNvbnN0IHJvdCA9IHNhbXBsZS5yb3QgLSB2ZWhpY2xlUm90O1xuICAgICAgICBjb25zdCBwb3MgPSBUSFJFRS5WZWN0b3IyLmZyb21BbmdsZShyb3QgKyBNYXRoLlBJIC8gMikubXVsdGlwbHlTY2FsYXIobGF0aXR1ZGUpLmFkZChzYW1wbGUucG9zLmNsb25lKCkuYXBwbHlNYXRyaXgzKHZlaGljbGVYZm9ybSkpO1xuICAgICAgICBjb25zdCBjdXJ2ID0gc2FtcGxlLmN1cnYgPT0gMCA/IDAgOiAxIC8gKDEgLyBzYW1wbGUuY3VydiAtIGxhdGl0dWRlKTtcblxuICAgICAgICBsYXR0aWNlW2luZGV4KytdID0gcG9zLng7XG4gICAgICAgIGxhdHRpY2VbaW5kZXgrK10gPSBwb3MueTtcbiAgICAgICAgbGF0dGljZVtpbmRleCsrXSA9IHJvdDtcbiAgICAgICAgbGF0dGljZVtpbmRleCsrXSA9IGN1cnY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhdHRpY2U7XG4gIH1cblxuICBfbGF0dGljZVN0YXRpb25JbnRlcnZhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuc3BhdGlhbEhvcml6b24gLyB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bVN0YXRpb25zO1xuICB9XG5cbiAgX3Rlcm1pbmFsQ29zdChbc3RhdGlvbkluZGV4LCBsYXRpdHVkZUluZGV4LCB0aW1lSW5kZXgsIHZlbG9jaXR5SW5kZXgsIGFjY2VsZXJhdGlvbkluZGV4XSwgW2Nvc3QsIGZpbmFsVmVsb2NpdHksIGZpbmFsVGltZSwgaW5jb21pbmdJbmRleF0pIHtcbiAgICAvLyBPbmx5IGNvbnNpZGVyIHZlcnRpY2VzIHRoYXQgcmVhY2ggdGhlIGVuZCBvZiB0aGUgc3BhdGlhbCBvciB0ZW1wb3JhbCBob3Jpem9uXG4gICAgaWYgKHN0YXRpb25JbmRleCAhPSB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bVN0YXRpb25zIC0gMSAmJiBmaW5hbFZlbG9jaXR5ID4gMC4wNSlcbiAgICAgIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cbiAgICBjb25zdCBzdGF0aW9uID0gKHRoaXMuY29uZmlnLnNwYXRpYWxIb3Jpem9uIC8gdGhpcy5jb25maWcubGF0dGljZS5udW1TdGF0aW9ucykgKiAoc3RhdGlvbkluZGV4ICsgMSk7XG5cbiAgICByZXR1cm4gc3RhdGlvbiAqIC10aGlzLmNvbmZpZy5zdGF0aW9uUmVhY2hEaXNjb3VudCArIGZpbmFsVGltZSAqIHRoaXMuY29uZmlnLmV4dHJhVGltZVBlbmFsdHk7XG4gIH1cblxuICBfdW5wYWNrQ29zdFRhYmxlSW5kZXgoaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPCAwKSByZXR1cm4gWy0xLCBpbmRleCArIDIsIG51bGwsIG51bGwsIG51bGxdO1xuXG4gICAgY29uc3QgbnVtUGVyVGltZSA9IE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMgKiBOVU1fVkVMT0NJVFlfUkFOR0VTO1xuICAgIGNvbnN0IG51bVBlckxhdGl0dWRlID0gbnVtUGVyVGltZSAqIE5VTV9USU1FX1JBTkdFUztcbiAgICBjb25zdCBudW1QZXJTdGF0aW9uID0gdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMgKiBudW1QZXJMYXRpdHVkZTtcblxuICAgIGNvbnN0IHN0YXRpb25JbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyBudW1QZXJTdGF0aW9uKTtcbiAgICBpbmRleCAtPSBzdGF0aW9uSW5kZXggKiBudW1QZXJTdGF0aW9uO1xuXG4gICAgY29uc3QgbGF0aXR1ZGVJbmRleCA9IE1hdGguZmxvb3IoaW5kZXggLyBudW1QZXJMYXRpdHVkZSk7XG4gICAgaW5kZXggLT0gbGF0aXR1ZGVJbmRleCAqIG51bVBlckxhdGl0dWRlO1xuXG4gICAgY29uc3QgdGltZUluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIG51bVBlclRpbWUpO1xuICAgIGluZGV4IC09IHRpbWVJbmRleCAqIG51bVBlclRpbWU7XG5cbiAgICBjb25zdCB2ZWxvY2l0eUluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMpO1xuICAgIGNvbnN0IGFjY2VsZXJhdGlvbkluZGV4ID0gaW5kZXggJSBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTO1xuXG4gICAgcmV0dXJuIFtzdGF0aW9uSW5kZXgsIGxhdGl0dWRlSW5kZXgsIHRpbWVJbmRleCwgdmVsb2NpdHlJbmRleCwgYWNjZWxlcmF0aW9uSW5kZXhdO1xuICB9XG5cbiAgX3JlY29uc3RydWN0VHJhamVjdG9yeShpbmRleCwgY29zdFRhYmxlLCBjdWJpY1BhdGhQYXJhbXMsIGN1YmljUGF0aEZyb21WZWhpY2xlUGFyYW1zLCBxdWludGljUGF0aEZyb21WZWhpY2xlUGFyYW1zLCB2ZWhpY2xlUG9zZSwgbGF0dGljZSkge1xuICAgIGxldCB1bnBhY2tlZCA9IHRoaXMuX3VucGFja0Nvc3RUYWJsZUluZGV4KGluZGV4KTtcbiAgICB1bnBhY2tlZC5wdXNoKGNvc3RUYWJsZVtpbmRleCAqIDQgKyAxXSk7XG4gICAgY29uc3Qgbm9kZXMgPSBbdW5wYWNrZWRdO1xuXG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICB3aGlsZSAodW5wYWNrZWRbMF0gPj0gMCAmJiBjb3VudCsrIDwgMTAwKSB7XG4gICAgICBpbmRleCA9IGNvc3RUYWJsZVtpbmRleCAqIDQgKyAzXTtcbiAgICAgIHVucGFja2VkID0gdGhpcy5fdW5wYWNrQ29zdFRhYmxlSW5kZXgoaW5kZXgpO1xuXG4gICAgICBjb25zdCBmaW5hbFZlbG9jaXR5ID0gdW5wYWNrZWRbMF0gPj0gMCA/IGNvc3RUYWJsZVtpbmRleCAqIDQgKyAxXSA6IHZlaGljbGVQb3NlLnZlbG9jaXR5O1xuICAgICAgdW5wYWNrZWQucHVzaChmaW5hbFZlbG9jaXR5KTtcblxuICAgICAgbm9kZXMudW5zaGlmdCh1bnBhY2tlZCk7XG4gICAgfVxuICAgIGlmIChjb3VudCA+PSAxMDApIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgbG9vcCBlbmNvdW50ZXJlZCB3aGlsZSByZWNvbnN0cnVjdGluZyB0cmFqZWN0b3J5LicpO1xuXG4gICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgbGV0IGZyb21WZWhpY2xlU2VnbWVudCA9IFtdO1xuICAgIGxldCBmcm9tVmVoaWNsZVBhcmFtcyA9IG51bGw7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgY29uc3QgW3ByZXZTdGF0aW9uLCBwcmV2TGF0aXR1ZGUsIF9wdCwgX3B2LCBfcGEsIHByZXZWZWxvY2l0eV0gPSBub2Rlc1tpXTtcbiAgICAgIGNvbnN0IFtzdGF0aW9uLCBsYXRpdHVkZSwgX3QsIF92LCBfYSwgdmVsb2NpdHldID0gbm9kZXNbaSArIDFdO1xuXG4gICAgICBsZXQgbGVuZ3RoO1xuICAgICAgbGV0IHBhdGhCdWlsZGVyO1xuXG4gICAgICBpZiAocHJldlN0YXRpb24gPCAwKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0ge1xuICAgICAgICAgIHBvczogbmV3IFRIUkVFLlZlY3RvcjIoMCwgMCksXG4gICAgICAgICAgcm90OiAwLFxuICAgICAgICAgIGN1cnY6IHZlaGljbGVQb3NlLmN1cnZcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBlbmRJbmRleCA9IChzdGF0aW9uICogdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMgKyBsYXRpdHVkZSkgKiA0O1xuICAgICAgICBjb25zdCBlbmQgPSB7XG4gICAgICAgICAgcG9zOiBuZXcgVEhSRUUuVmVjdG9yMihsYXR0aWNlW2VuZEluZGV4XSwgbGF0dGljZVtlbmRJbmRleCArIDFdKSxcbiAgICAgICAgICByb3Q6IGxhdHRpY2VbZW5kSW5kZXggKyAyXSxcbiAgICAgICAgICBjdXJ2OiBsYXR0aWNlW2VuZEluZGV4ICsgM11cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAocHJldkxhdGl0dWRlID09IDApIHsgLy8gQ3ViaWMgcGF0aCBmcm9tIHZlaGljbGUgdG8gbGF0dGljZSBub2RlXG4gICAgICAgICAgbGVuZ3RoID0gY3ViaWNQYXRoRnJvbVZlaGljbGVQYXJhbXNbZW5kSW5kZXggKyAyXTtcblxuICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHAxOiBjdWJpY1BhdGhGcm9tVmVoaWNsZVBhcmFtc1tlbmRJbmRleF0sXG4gICAgICAgICAgICBwMjogY3ViaWNQYXRoRnJvbVZlaGljbGVQYXJhbXNbZW5kSW5kZXggKyAxXSxcbiAgICAgICAgICAgIHNHOiBsZW5ndGhcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgcGF0aEJ1aWxkZXIgPSBuZXcgQ3ViaWNQYXRoKHN0YXJ0LCBlbmQsIHBhcmFtcyk7XG5cbiAgICAgICAgICBmcm9tVmVoaWNsZVBhcmFtcyA9IHsgdHlwZTogJ2N1YmljJywgcGFyYW1zOiBwYXJhbXMgfTtcbiAgICAgICAgfSBlbHNlIHsgLy8gUXVpbnRpYyBwYXRoIGZyb20gdmVoaWNsZSB0byBsYXR0aWNlIG5vZGVcbiAgICAgICAgICBsZW5ndGggPSBxdWludGljUGF0aEZyb21WZWhpY2xlUGFyYW1zW2VuZEluZGV4ICsgMl07XG5cbiAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBwMzogcXVpbnRpY1BhdGhGcm9tVmVoaWNsZVBhcmFtc1tlbmRJbmRleF0sXG4gICAgICAgICAgICBwNDogcXVpbnRpY1BhdGhGcm9tVmVoaWNsZVBhcmFtc1tlbmRJbmRleCArIDFdLFxuICAgICAgICAgICAgc0c6IGxlbmd0aFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBwYXRoQnVpbGRlciA9IG5ldyBRdWludGljUGF0aChzdGFydCwgZW5kLCBwYXJhbXMpO1xuXG4gICAgICAgICAgZnJvbVZlaGljbGVQYXJhbXMgPSB7IHR5cGU6ICdxdWludGljJywgcGFyYW1zOiBwYXJhbXMgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RhcnRJbmRleCA9IChwcmV2U3RhdGlvbiAqIHRoaXMuY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzICsgcHJldkxhdGl0dWRlKSAqIDQ7XG4gICAgICAgIGNvbnN0IGVuZEluZGV4ID0gKHN0YXRpb24gKiB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyArIGxhdGl0dWRlKSAqIDQ7XG5cbiAgICAgICAgY29uc3Qgc3RhcnQgPSB7XG4gICAgICAgICAgcG9zOiBuZXcgVEhSRUUuVmVjdG9yMihsYXR0aWNlW3N0YXJ0SW5kZXhdLCBsYXR0aWNlW3N0YXJ0SW5kZXggKyAxXSksXG4gICAgICAgICAgcm90OiBsYXR0aWNlW3N0YXJ0SW5kZXggKyAyXSxcbiAgICAgICAgICBjdXJ2OiBsYXR0aWNlW3N0YXJ0SW5kZXggKyAzXVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGVuZCA9IHtcbiAgICAgICAgICBwb3M6IG5ldyBUSFJFRS5WZWN0b3IyKGxhdHRpY2VbZW5kSW5kZXhdLCBsYXR0aWNlW2VuZEluZGV4ICsgMV0pLFxuICAgICAgICAgIHJvdDogbGF0dGljZVtlbmRJbmRleCArIDJdLFxuICAgICAgICAgIGN1cnY6IGxhdHRpY2VbZW5kSW5kZXggKyAzXVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHNsSW5kZXggPSBzdGF0aW9uICogdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMgKyBsYXRpdHVkZTtcbiAgICAgICAgY29uc3QgY29ubmVjdGl2aXR5SW5kZXggPSAocHJldlN0YXRpb24gLSBzdGF0aW9uICsgdGhpcy5jb25maWcubGF0dGljZS5zdGF0aW9uQ29ubmVjdGl2aXR5KSAqIHRoaXMuY29uZmlnLmxhdHRpY2UubGF0aXR1ZGVDb25uZWN0aXZpdHkgKyBwcmV2TGF0aXR1ZGUgLSBsYXRpdHVkZSArIE1hdGguZmxvb3IodGhpcy5jb25maWcubGF0dGljZS5sYXRpdHVkZUNvbm5lY3Rpdml0eSAvIDIpO1xuICAgICAgICBjb25zdCBjdWJpY1BhdGhJbmRleCA9IChjb25uZWN0aXZpdHlJbmRleCAqIHRoaXMuY29uZmlnLmxhdHRpY2UubnVtU3RhdGlvbnMgKiB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyArIHNsSW5kZXgpICogNDtcblxuICAgICAgICBsZW5ndGggPSBjdWJpY1BhdGhQYXJhbXNbY3ViaWNQYXRoSW5kZXggKyAyXTtcblxuICAgICAgICBwYXRoQnVpbGRlciA9IG5ldyBDdWJpY1BhdGgoc3RhcnQsIGVuZCwge1xuICAgICAgICAgIHAxOiBjdWJpY1BhdGhQYXJhbXNbY3ViaWNQYXRoSW5kZXhdLFxuICAgICAgICAgIHAyOiBjdWJpY1BhdGhQYXJhbXNbY3ViaWNQYXRoSW5kZXggKyAxXSxcbiAgICAgICAgICBzRzogbGVuZ3RoXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBwYXRoID0gcGF0aEJ1aWxkZXIuYnVpbGRQYXRoKE1hdGguY2VpbChsZW5ndGggLyAwLjI1KSk7XG5cbiAgICAgIGNvbnN0IHByZXZWZWxvY2l0eVNxID0gcHJldlZlbG9jaXR5ICogcHJldlZlbG9jaXR5O1xuICAgICAgY29uc3QgYWNjZWwgPSAodmVsb2NpdHkgKiB2ZWxvY2l0eSAtIHByZXZWZWxvY2l0eVNxKSAvIDIgLyBsZW5ndGg7XG4gICAgICBjb25zdCBkcyA9IGxlbmd0aCAvIChwYXRoLmxlbmd0aCAtIDEpO1xuICAgICAgbGV0IHMgPSAwO1xuXG4gICAgICBmb3IgKGxldCBwID0gMDsgcCA8IHBhdGgubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgcGF0aFtwXS52ZWxvY2l0eSA9IE1hdGguc3FydCgyICogYWNjZWwgKiBzICsgcHJldlZlbG9jaXR5U3EpO1xuICAgICAgICBwYXRoW3BdLmFjY2VsZXJhdGlvbiA9IGFjY2VsO1xuICAgICAgICBzICs9IGRzO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldlN0YXRpb24gPCAwKSB7XG4gICAgICAgIGZyb21WZWhpY2xlU2VnbWVudCA9IHBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaSA+IDApIHBhdGguc2hpZnQoKTtcbiAgICAgICAgcG9pbnRzLnB1c2goLi4ucGF0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IGZpcnN0TGF0dGljZVBvaW50ID0gbnVsbFxuICAgIGxldCBmaXJzdEFjY2VsZXJhdGlvbiA9IG51bGw7XG4gICAgbGV0IHNlY29uZExhdHRpY2VQb2ludCA9IG51bGw7XG4gICAgbGV0IHNlY29uZEFjY2VsZXJhdGlvbiA9IG51bGw7XG5cbiAgICBpZiAobm9kZXMubGVuZ3RoID49IDIpIHtcbiAgICAgIGZpcnN0TGF0dGljZVBvaW50ID0gbm9kZXNbMV1bMF0gKiB0aGlzLmNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyArIG5vZGVzWzFdWzFdO1xuICAgICAgZmlyc3RBY2NlbGVyYXRpb24gPSBub2Rlc1sxXVs0XTtcbiAgICB9XG5cbiAgICBpZiAobm9kZXMubGVuZ3RoID49IDMpIHtcbiAgICAgIHNlY29uZExhdHRpY2VQb2ludCA9IG5vZGVzWzJdWzBdICogdGhpcy5jb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMgKyBub2Rlc1syXVsxXTtcbiAgICAgIHNlY29uZEFjY2VsZXJhdGlvbiA9IG5vZGVzWzJdWzRdO1xuICAgIH1cblxuICAgIHJldHVybiBbcG9pbnRzLCBmcm9tVmVoaWNsZVNlZ21lbnQsIGZyb21WZWhpY2xlUGFyYW1zLCBmaXJzdExhdHRpY2VQb2ludCwgZmlyc3RBY2NlbGVyYXRpb24sIHNlY29uZExhdHRpY2VQb2ludCwgc2Vjb25kQWNjZWxlcmF0aW9uXTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2ZWhpY2xlVHJhbnNmb3JtKHsgcG9zLCByb3QgfSkge1xuICBjb25zdCB0cmFuc2xhdGUgPSBuZXcgVEhSRUUuTWF0cml4MygpO1xuICB0cmFuc2xhdGUuc2V0KFxuICAgIDEsIDAsIC1wb3MueCxcbiAgICAwLCAxLCAtcG9zLnksXG4gICAgMCwgMCwgMVxuICApO1xuXG4gIGNvbnN0IGNvc1JvdCA9IE1hdGguY29zKHJvdCk7XG4gIGNvbnN0IHNpblJvdCA9IE1hdGguc2luKHJvdCk7XG5cbiAgY29uc3Qgcm90YXRlID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcbiAgcm90YXRlLnNldChcbiAgICBjb3NSb3QsIHNpblJvdCwgMCxcbiAgICAtc2luUm90LCBjb3NSb3QsIDAsXG4gICAgMCwgMCwgMVxuICApO1xuXG4gIHJldHVybiByb3RhdGUubXVsdGlwbHkodHJhbnNsYXRlKTtcbn1cblxuZnVuY3Rpb24gb2JzdGFjbGVUcmFuc2Zvcm0odmVoaWNsZVhmb3JtLCB4eUNlbnRlclBvaW50LCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGNvbnN0IHRyYW5zbGF0ZSA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG4gIHRyYW5zbGF0ZS5zZXQoXG4gICAgMSwgMCwgLXh5Q2VudGVyUG9pbnQueCxcbiAgICAwLCAxLCAteHlDZW50ZXJQb2ludC55LFxuICAgIDAsIDAsIDFcbiAgKTtcblxuICBjb25zdCBzY2FsZSA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG4gIHNjYWxlLnNldChcbiAgICAyIC8gd2lkdGgsIDAsIDAsXG4gICAgMCwgMiAvIGhlaWdodCwgMCxcbiAgICAwLCAwLCAxXG4gICk7XG5cbiAgcmV0dXJuIHNjYWxlLm11bHRpcGx5KHRyYW5zbGF0ZSkubXVsdGlwbHkodmVoaWNsZVhmb3JtKTtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./js/autonomy/path-planning/PathPlanner.js\n");

/***/ }),

/***/ "./js/autonomy/path-planning/QuinticPath.js":
/*!**************************************************!*\
  !*** ./js/autonomy/path-planning/QuinticPath.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return QuinticPath; });\nclass QuinticPath {\n  constructor(start, end, params) {\n    this.start = Object.assign({}, start);\n    this.end = Object.assign({}, end);\n\n    if (start.pos) {\n      this.start.x = start.pos.x;\n      this.start.y = start.pos.y\n    }\n\n    if (end.pos) {\n      this.end.x = end.pos.x;\n      this.end.y = end.pos.y\n    }\n\n    const diffX = this.end.x - this.start.x;\n    const diffY = this.end.y - this.start.y;\n    const sinRot = Math.sin(this.start.rot);\n    const cosRot = Math.cos(this.start.rot);\n\n    this.goal = {\n      x: cosRot * diffX + sinRot * diffY,\n      y: -sinRot * diffX + cosRot * diffY,\n      rot: Math.wrapAngle(this.end.rot - this.start.rot),\n      curv: this.end.curv\n    };\n\n    this.params = Object.assign({}, params, { p0: this.start.curv, p1: this.start.dCurv || 0, p2: this.start.ddCurv || 0, p5: this.end.curv });\n  }\n\n  buildPath(num) {\n    const { p0, p1, p2, p3, p4, p5, sG } = this.params;\n\n    const sG_2 = sG * sG;\n    const sG_3 = sG_2 * sG;\n\n    const a = p0;\n    const b = p1;\n    const c = p2 / 2.0;\n    const d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\n    const e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\n    const f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\n\n    const path = [{ pos: new THREE.Vector2(this.start.x, this.start.y), rot: this.start.rot, curv: this.start.curv }];\n    const ds = sG / (num - 1);\n    let s = ds;\n    let dx = 0;\n    let dy = 0;\n    let prevCosRot = Math.cos(path[0].rot);\n    let prevSinRot = Math.sin(path[0].rot);\n\n    for (let i = 1; i < num - 1; i++) {\n      const rot = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s + this.start.rot;\n      const curv = ((((f * s + e) * s + d) * s + c) * s + b) * s + a;\n      const cosRot = Math.cos(rot);\n      const sinRot = Math.sin(rot);\n\n      dx = dx * (i - 1) / i + (cosRot + prevCosRot) / (2 * i);\n      dy = dy * (i - 1) / i + (sinRot + prevSinRot) / (2 * i);\n\n      path.push({ pos: new THREE.Vector2(s * dx + this.start.x, s * dy + this.start.y), rot: rot, curv: curv });\n\n      s += ds;\n      prevCosRot = cosRot;\n      prevSinRot = sinRot;\n    }\n\n    path.push({ pos: new THREE.Vector2(this.end.x, this.end.y), rot: this.end.rot, curv: this.end.curv });\n\n    return path;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL1F1aW50aWNQYXRoLmpzPzhjNjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLCtCQUErQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxXQUFXLGdHQUFnRztBQUM3STs7QUFFQTtBQUNBLFdBQVcsNkJBQTZCOztBQUV4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsaUdBQWlHO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsYUFBYTtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQiw2RkFBNkY7O0FBRTlHO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUseUZBQXlGOztBQUV4RztBQUNBO0FBQ0EiLCJmaWxlIjoiLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL1F1aW50aWNQYXRoLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVpbnRpY1BhdGgge1xuICBjb25zdHJ1Y3RvcihzdGFydCwgZW5kLCBwYXJhbXMpIHtcbiAgICB0aGlzLnN0YXJ0ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhcnQpO1xuICAgIHRoaXMuZW5kID0gT2JqZWN0LmFzc2lnbih7fSwgZW5kKTtcblxuICAgIGlmIChzdGFydC5wb3MpIHtcbiAgICAgIHRoaXMuc3RhcnQueCA9IHN0YXJ0LnBvcy54O1xuICAgICAgdGhpcy5zdGFydC55ID0gc3RhcnQucG9zLnlcbiAgICB9XG5cbiAgICBpZiAoZW5kLnBvcykge1xuICAgICAgdGhpcy5lbmQueCA9IGVuZC5wb3MueDtcbiAgICAgIHRoaXMuZW5kLnkgPSBlbmQucG9zLnlcbiAgICB9XG5cbiAgICBjb25zdCBkaWZmWCA9IHRoaXMuZW5kLnggLSB0aGlzLnN0YXJ0Lng7XG4gICAgY29uc3QgZGlmZlkgPSB0aGlzLmVuZC55IC0gdGhpcy5zdGFydC55O1xuICAgIGNvbnN0IHNpblJvdCA9IE1hdGguc2luKHRoaXMuc3RhcnQucm90KTtcbiAgICBjb25zdCBjb3NSb3QgPSBNYXRoLmNvcyh0aGlzLnN0YXJ0LnJvdCk7XG5cbiAgICB0aGlzLmdvYWwgPSB7XG4gICAgICB4OiBjb3NSb3QgKiBkaWZmWCArIHNpblJvdCAqIGRpZmZZLFxuICAgICAgeTogLXNpblJvdCAqIGRpZmZYICsgY29zUm90ICogZGlmZlksXG4gICAgICByb3Q6IE1hdGgud3JhcEFuZ2xlKHRoaXMuZW5kLnJvdCAtIHRoaXMuc3RhcnQucm90KSxcbiAgICAgIGN1cnY6IHRoaXMuZW5kLmN1cnZcbiAgICB9O1xuXG4gICAgdGhpcy5wYXJhbXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMsIHsgcDA6IHRoaXMuc3RhcnQuY3VydiwgcDE6IHRoaXMuc3RhcnQuZEN1cnYgfHwgMCwgcDI6IHRoaXMuc3RhcnQuZGRDdXJ2IHx8IDAsIHA1OiB0aGlzLmVuZC5jdXJ2IH0pO1xuICB9XG5cbiAgYnVpbGRQYXRoKG51bSkge1xuICAgIGNvbnN0IHsgcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSwgc0cgfSA9IHRoaXMucGFyYW1zO1xuXG4gICAgY29uc3Qgc0dfMiA9IHNHICogc0c7XG4gICAgY29uc3Qgc0dfMyA9IHNHXzIgKiBzRztcblxuICAgIGNvbnN0IGEgPSBwMDtcbiAgICBjb25zdCBiID0gcDE7XG4gICAgY29uc3QgYyA9IHAyIC8gMi4wO1xuICAgIGNvbnN0IGQgPSAoLTcxLjg3NSAqIHAwICsgODEuMCAqIHAzIC0gMTAuMTI1ICogcDQgKyBwNSAtIDIxLjI1ICogcDEgKiBzRyAtIDIuNzUgKiBwMiAqIHNHXzIpIC8gc0dfMztcbiAgICBjb25zdCBlID0gKDE2Ni41ICogcDAgLSAyMDIuNSAqIHAzICsgNDAuNSAqIHA0IC0gNC41ICogcDUgKyA0NS4wICogcDEgKiBzRyArIDQuNSAqIHAyICogc0dfMikgLyAoc0dfMiAqIHNHXzIpO1xuICAgIGNvbnN0IGYgPSAoLTk1LjYyNSAqIHAwICsgMTIxLjUgKiBwMyAtIDMwLjM3NSAqIHA0ICsgNC41ICogcDUgLSAyNC43NSAqIHAxICogc0cgLSAyLjI1ICogcDIgKiBzR18yKSAvIChzR18yICogc0dfMyk7XG5cbiAgICBjb25zdCBwYXRoID0gW3sgcG9zOiBuZXcgVEhSRUUuVmVjdG9yMih0aGlzLnN0YXJ0LngsIHRoaXMuc3RhcnQueSksIHJvdDogdGhpcy5zdGFydC5yb3QsIGN1cnY6IHRoaXMuc3RhcnQuY3VydiB9XTtcbiAgICBjb25zdCBkcyA9IHNHIC8gKG51bSAtIDEpO1xuICAgIGxldCBzID0gZHM7XG4gICAgbGV0IGR4ID0gMDtcbiAgICBsZXQgZHkgPSAwO1xuICAgIGxldCBwcmV2Q29zUm90ID0gTWF0aC5jb3MocGF0aFswXS5yb3QpO1xuICAgIGxldCBwcmV2U2luUm90ID0gTWF0aC5zaW4ocGF0aFswXS5yb3QpO1xuXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBudW0gLSAxOyBpKyspIHtcbiAgICAgIGNvbnN0IHJvdCA9ICgoKCgoZiAqIHMgLyA2LjAgKyBlIC8gNS4wKSAqIHMgKyBkIC8gNC4wKSAqIHMgKyBjIC8gMy4wKSAqIHMgKyBiIC8gMi4wKSAqIHMgKyBhKSAqIHMgKyB0aGlzLnN0YXJ0LnJvdDtcbiAgICAgIGNvbnN0IGN1cnYgPSAoKCgoZiAqIHMgKyBlKSAqIHMgKyBkKSAqIHMgKyBjKSAqIHMgKyBiKSAqIHMgKyBhO1xuICAgICAgY29uc3QgY29zUm90ID0gTWF0aC5jb3Mocm90KTtcbiAgICAgIGNvbnN0IHNpblJvdCA9IE1hdGguc2luKHJvdCk7XG5cbiAgICAgIGR4ID0gZHggKiAoaSAtIDEpIC8gaSArIChjb3NSb3QgKyBwcmV2Q29zUm90KSAvICgyICogaSk7XG4gICAgICBkeSA9IGR5ICogKGkgLSAxKSAvIGkgKyAoc2luUm90ICsgcHJldlNpblJvdCkgLyAoMiAqIGkpO1xuXG4gICAgICBwYXRoLnB1c2goeyBwb3M6IG5ldyBUSFJFRS5WZWN0b3IyKHMgKiBkeCArIHRoaXMuc3RhcnQueCwgcyAqIGR5ICsgdGhpcy5zdGFydC55KSwgcm90OiByb3QsIGN1cnY6IGN1cnYgfSk7XG5cbiAgICAgIHMgKz0gZHM7XG4gICAgICBwcmV2Q29zUm90ID0gY29zUm90O1xuICAgICAgcHJldlNpblJvdCA9IHNpblJvdDtcbiAgICB9XG5cbiAgICBwYXRoLnB1c2goeyBwb3M6IG5ldyBUSFJFRS5WZWN0b3IyKHRoaXMuZW5kLngsIHRoaXMuZW5kLnkpLCByb3Q6IHRoaXMuZW5kLnJvdCwgY3VydjogdGhpcy5lbmQuY3VydiB9KTtcblxuICAgIHJldHVybiBwYXRoO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/autonomy/path-planning/QuinticPath.js\n");

/***/ }),

/***/ "./js/autonomy/path-planning/gpgpu-programs/graphSearch.js":
/*!*****************************************************************!*\
  !*** ./js/autonomy/path-planning/gpgpu-programs/graphSearch.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graphSearchShared.js */ \"./js/autonomy/path-planning/gpgpu-programs/graphSearchShared.js\");\n/* State Lattice Cost Map\n * \n * 5-dimensional node: station, latitude, acceleration profile, velocity, time\n *\n * A draw call per station s\n *   * Input to kernel: latitude l, acceleration profile a, velocity range v, time range t\n *   * Find all SL vertices that can connect to this node\n *   * For each of those vertices, check if any terminate in this specific velocity and time range\n *     * Based on initial velocity, initial time, and acceleration\n *     * Each connected SL vertex should have a * v * t nodes that could possibly terminate at this node\n *   * For all valid edges, find the one with the lowest cost\n *\n * Input:\n *   * 2D texture array cost map\n *     * Height: num of latitudes (~20)\n *     * Width: num of acceleration profiles * num of time ranges * num of velocity ranges (8 * 2 * 4 = ~64)\n *       * A flattened 3D array:\n *         d1: acceleration\n *         d2: velocity\n *         d3: time\n *     * Layer: num of stations (~10)\n *   \n * Output:\n *   * 2D texture slice of the next station in the input 2D texture array cost map\n *\n * Cost Map Elements:\n *   * Traversal cost so far\n *   * Ending velocity\n *   * Ending time\n *   * Index of parent node\n *\n * Since one cubic path can be shared between multiple trajectories, they need to be pre-optimized.\n *\n * Quintic Paths:\n *   Stations 0 through (numStations - 1) correspond to the stations on the lattice; however,\n *   a new station (station -1) will be used to signifiy the single vehicle pose node. Either\n *   a cubic path or quintic path can be used to connect this single node to the lattice\n *   (depending on vehicle velocity). At station -1, latitude 0 will correspond to a cubic path,\n *   and latitude 1 will correspond to a quintic path. All other latitudes will be skipped.\n */\n\n\n\nconst SOLVE_STATION_KERNEL =\n  _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"SHARED_SHADER\"] +\n  _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"SAMPLE_CUBIC_PATH_FN\"] +\n  _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"SAMPLE_QUINTIC_PATH_FN\"] +\n\n`\n\nvec4 kernel() {\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  int latitude = indexes.y;\n\n  int numPerTime = numAccelerations * numVelocities;\n  int timeIndex = indexes.x / numPerTime;\n  indexes.x -= timeIndex * numPerTime;\n  int velocityIndex = indexes.x / numAccelerations;\n  int accelerationIndex = int(mod(float(indexes.x), float(numAccelerations)));\n\n  int minLatitude = max(latitude - latitudeConnectivity / 2, 0);\n  int maxLatitude = min(latitude + latitudeConnectivity / 2, numLatitudes - 1);\n\n  int slIndex = station * numLatitudes + latitude;\n\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\n\n  float minVelocity = velocityRanges[velocityIndex];\n  float maxVelocity = velocityRanges[velocityIndex + 1];\n\n  float minTime = timeRanges[timeIndex];\n  float maxTime = timeRanges[timeIndex + 1];\n\n  vec4 bestTrajectory = vec4(-1); // -1 means infinite cost\n  float bestTerminalCost = 1.0 / 0.0;\n\n  float hysteresisAdjustment = (slIndex == firstLatticePoint || slIndex == secondLatticePoint) ?  0.0 : hysteresisDiscount;\n\n  for (int prevStation = max(station - stationConnectivity, 0); prevStation < station; prevStation++) {\n    int stationConnectivityIndex = prevStation - station + stationConnectivity;\n\n    for (int prevLatitude = minLatitude; prevLatitude <= maxLatitude; prevLatitude++) {\n      int latitudeConnectivityIndex = prevLatitude - latitude + latitudeConnectivity / 2;\n      int connectivityIndex = stationConnectivityIndex * latitudeConnectivity + latitudeConnectivityIndex;\n\n      vec4 pathStart = texelFetch(lattice, ivec2(prevLatitude, prevStation), 0);\n      vec4 cubicPathParams = texelFetch(cubicPaths, ivec2(slIndex, connectivityIndex), 0);\n\n      // If the path didn't converge\n      if (cubicPathParams.w == 0.0) continue;\n\n      int numSamples = sampleCubicPath(pathStart, pathEnd, cubicPathParams);\n      float pathLength = cubicPathParams.z;\n\n      if (numSamples < 2) continue;\n\n      float averageStaticCost = calculateAverageStaticCost(numSamples);\n      if (averageStaticCost < 0.0) continue;\n\n      averageStaticCost += hysteresisAdjustment;\n\n      if (averageStaticCost * pathLength >= bestTerminalCost) continue;\n\n      for (int prevVelocity = 0; prevVelocity < numVelocities; prevVelocity++) {\n        for (int prevTime = 0; prevTime < numTimes; prevTime++) {\n          for (int prevAccel = 0; prevAccel < numAccelerations; prevAccel++) {\n            int avtIndex = prevTime * numPerTime + prevVelocity * numAccelerations + prevAccel;\n\n            // Cost table entry:\n            //   x: cost so far\n            //   y: end velocity\n            //   z: end time\n            //   w: parent index\n            vec4 costTableEntry = texelFetch(costTable, ivec3(avtIndex, prevLatitude, prevStation), 0);\n\n            // If cost entry is infinity\n            if (costTableEntry.x < 0.0 || averageStaticCost * pathLength + costTableEntry.x >= bestTerminalCost) continue;\n\n            vec3 avt = calculateAVT(accelerationIndex, costTableEntry.y, costTableEntry.z, pathLength);\n            float acceleration = avt.x;\n            float finalVelocity = avt.y;\n            float finalTime = avt.z;\n\n            if (averageStaticCost * pathLength + costTableEntry.x + extraTimePenalty * finalTime >= bestTerminalCost) continue;\n\n            // If the calculated final velocity does not match this fragment's velocity range, then skip this trajectory\n            if (finalVelocity < minVelocity || finalVelocity >= maxVelocity) continue;\n\n            // If the calculated final time does not match this fragment's time range, then skip this trajectory\n            if (finalTime < minTime || finalTime >= maxTime) continue;\n\n            float abandonThreshold = (bestTerminalCost - extraTimePenalty * finalTime - costTableEntry.x) / pathLength - averageStaticCost;\n            float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, costTableEntry.z, costTableEntry.y, acceleration, abandonThreshold);\n            if (averageDynamicCost < 0.0) continue;\n\n            if (accelerationIndex != prevAccel)\n              averageDynamicCost += accelerationChangePenalty;\n\n            // The cost of a trajectory is the average sample cost scaled by the path length\n            float totalCost = (averageStaticCost + averageDynamicCost) * pathLength + costTableEntry.x;\n\n            float terminalCost = totalCost + extraTimePenalty * finalTime;\n            if (terminalCost >= bestTerminalCost) continue;\n            bestTerminalCost = terminalCost;\n\n            int incomingIndex = avtIndex + numPerTime * numTimes * (prevLatitude + numLatitudes * prevStation);\n            bestTrajectory = vec4(totalCost, finalVelocity, finalTime, incomingIndex);\n          }\n        }\n      }\n    }\n  }\n\n  if (station < stationConnectivity) {\n    ivec2 slaIndex = ivec2(latitude, station * numAccelerations + accelerationIndex);\n\n    vec4 costTableEntry = texelFetch(cubicPathFromVehicleCosts, slaIndex, 0);\n    float terminalCost;\n\n    if (costTableEntry.x >= 0.0) {\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\n\n      if (terminalCost < bestTerminalCost) {\n        bestTerminalCost = terminalCost;\n        bestTrajectory = costTableEntry;\n      }\n    }\n\n    costTableEntry = texelFetch(quinticPathFromVehicleCosts, slaIndex, 0);\n\n    if (costTableEntry.x >= 0.0) {\n      terminalCost = costTableEntry.x + extraTimePenalty * costTableEntry.z;\n\n      if (terminalCost < bestTerminalCost) {\n        bestTerminalCost = terminalCost;\n        bestTrajectory = costTableEntry;\n      }\n    }\n  }\n\n  return bestTrajectory;\n}\n\n`;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  setUp() {\n    return {\n      kernel: SOLVE_STATION_KERNEL,\n      output: { name: 'graphSearch' },\n      uniforms: Object.assign({}, _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"SHARED_UNIFORMS\"], {\n        lattice: { type: 'sharedTexture' },\n        costTable: { type: 'sharedTexture', textureType: '2DArray' },\n        cubicPaths: { type: 'outputTexture' },\n        cubicPathFromVehicleCosts: { type: 'outputTexture' },\n        quinticPathFromVehicleCosts: { type: 'outputTexture' },\n        firstLatticePoint: { type: 'int' },\n        secondLatticePoint: { type: 'int' },\n        velocityVehicle: { type: 'float' },\n        curvVehicle: { type: 'float' },\n        dCurvVehicle: { type: 'float' },\n        ddCurvVehicle: { type: 'float' },\n        extraTimePenalty: { type: 'float' },\n        hysteresisDiscount: { type: 'float' },\n        accelerationChangePenalty: { type: 'float' },\n        numStations: { type: 'int' },\n        numLatitudes: { type: 'int' },\n        numAccelerations: { type: 'int' },\n        numVelocities: { type: 'int' },\n        numTimes: { type: 'int' },\n        stationConnectivity: { type: 'int' },\n        latitudeConnectivity: { type: 'int' },\n        velocityRanges: { type: 'float', length: _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"NUM_VELOCITY_RANGES\"] + 1 },\n        timeRanges: { type: 'float', length: _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"NUM_TIME_RANGES\"] + 1 },\n        station: { type: 'int' } // Updated in `drawProxy`\n      }),\n      drawProxy: (gpgpu, program, draw) => {\n        const width = _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"NUM_ACCELERATION_PROFILES\"] * _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"NUM_VELOCITY_RANGES\"] * _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"NUM_TIME_RANGES\"];\n        const height = program.meta.lattice.numLatitudes;\n        const costTable = new Float32Array(width * height * program.meta.lattice.numStations * 4);\n\n        for (let s = 0; s < program.meta.lattice.numStations; s++) {\n          gpgpu.updateProgramUniforms(program, { station: s });\n          draw();\n\n          gpgpu.gl.readPixels(0, 0, width, height, gpgpu.gl.RGBA, gpgpu.gl.FLOAT, costTable, s * width * height * 4);\n\n          gpgpu.gl.bindTexture(gpgpu.gl.TEXTURE_2D_ARRAY, gpgpu.sharedTextures.costTable);\n          gpgpu.gl.copyTexSubImage3D(gpgpu.gl.TEXTURE_2D_ARRAY, 0, 0, 0, s, 0, 0, width, height);\n        }\n\n        gpgpu._graphSearchCostTable = costTable;\n      }\n    };\n  },\n\n  update(config, pose, xyCenterPoint, slCenterPoint, firstLatticePoint, secondLatticePoint, dynamicFrameTime) {\n    return {\n      width: _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"NUM_ACCELERATION_PROFILES\"] * _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"NUM_VELOCITY_RANGES\"] * _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"NUM_TIME_RANGES\"],\n      height: config.lattice.numLatitudes,\n      meta: {\n        lattice: config.lattice\n      },\n      uniforms: Object.assign({}, Object(_graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"buildUniformValues\"])(config, xyCenterPoint, slCenterPoint, dynamicFrameTime), {\n        firstLatticePoint: firstLatticePoint,\n        secondLatticePoint: secondLatticePoint,\n        velocityVehicle: pose.velocity,\n        curvVehicle: pose.curv,\n        dCurvVehicle: pose.dCurv,\n        ddCurvVehicle: pose.ddCurv,\n        extraTimePenalty: config.extraTimePenalty,\n        hysteresisDiscount: config.hysteresisDiscount,\n        accelerationChangePenalty: config.accelerationChangePenalty,\n        numStations: config.lattice.numStations,\n        numLatitudes: config.lattice.numLatitudes,\n        numAccelerations: _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"NUM_ACCELERATION_PROFILES\"],\n        numVelocities: _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"NUM_VELOCITY_RANGES\"],\n        numTimes: _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"NUM_TIME_RANGES\"],\n        stationConnectivity: config.lattice.stationConnectivity,\n        latitudeConnectivity: config.lattice.latitudeConnectivity,\n        velocityRanges: [0, config.speedLimit / 3, config.speedLimit * 2 / 3, config.speedLimit, 1000000],\n        timeRanges: [0, 10, 1000000]\n      })\n    };\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL2dyYXBoU2VhcmNoLmpzPzRjODgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNEs7O0FBRTVLO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7O0FBRUE7O0FBRUEsK0RBQStELHVCQUF1QjtBQUN0Rjs7QUFFQSx3Q0FBd0MsNkJBQTZCO0FBQ3JFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnQ0FBZ0MsOEJBQThCO0FBQzlELDhCQUE4QixxQkFBcUI7QUFDbkQsaUNBQWlDLDhCQUE4QjtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckMsZ0NBQWdDO0FBQ2hDLGtCQUFrQix3QkFBd0I7QUFDMUMsb0JBQW9CLGdEQUFnRDtBQUNwRSxxQkFBcUIsd0JBQXdCO0FBQzdDLG9DQUFvQyx3QkFBd0I7QUFDNUQsc0NBQXNDLHdCQUF3QjtBQUM5RCw0QkFBNEIsY0FBYztBQUMxQyw2QkFBNkIsY0FBYztBQUMzQywwQkFBMEIsZ0JBQWdCO0FBQzFDLHNCQUFzQixnQkFBZ0I7QUFDdEMsdUJBQXVCLGdCQUFnQjtBQUN2Qyx3QkFBd0IsZ0JBQWdCO0FBQ3hDLDJCQUEyQixnQkFBZ0I7QUFDM0MsNkJBQTZCLGdCQUFnQjtBQUM3QyxvQ0FBb0MsZ0JBQWdCO0FBQ3BELHNCQUFzQixjQUFjO0FBQ3BDLHVCQUF1QixjQUFjO0FBQ3JDLDJCQUEyQixjQUFjO0FBQ3pDLHdCQUF3QixjQUFjO0FBQ3RDLG1CQUFtQixjQUFjO0FBQ2pDLDhCQUE4QixjQUFjO0FBQzVDLCtCQUErQixjQUFjO0FBQzdDLHlCQUF5Qix1R0FBaUQ7QUFDMUUscUJBQXFCLG1HQUE2QztBQUNsRSxrQkFBa0IsY0FBYztBQUNoQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLHNDQUFzQztBQUM3RCxnREFBZ0QsYUFBYTtBQUM3RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL2dyYXBoU2VhcmNoLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogU3RhdGUgTGF0dGljZSBDb3N0IE1hcFxuICogXG4gKiA1LWRpbWVuc2lvbmFsIG5vZGU6IHN0YXRpb24sIGxhdGl0dWRlLCBhY2NlbGVyYXRpb24gcHJvZmlsZSwgdmVsb2NpdHksIHRpbWVcbiAqXG4gKiBBIGRyYXcgY2FsbCBwZXIgc3RhdGlvbiBzXG4gKiAgICogSW5wdXQgdG8ga2VybmVsOiBsYXRpdHVkZSBsLCBhY2NlbGVyYXRpb24gcHJvZmlsZSBhLCB2ZWxvY2l0eSByYW5nZSB2LCB0aW1lIHJhbmdlIHRcbiAqICAgKiBGaW5kIGFsbCBTTCB2ZXJ0aWNlcyB0aGF0IGNhbiBjb25uZWN0IHRvIHRoaXMgbm9kZVxuICogICAqIEZvciBlYWNoIG9mIHRob3NlIHZlcnRpY2VzLCBjaGVjayBpZiBhbnkgdGVybWluYXRlIGluIHRoaXMgc3BlY2lmaWMgdmVsb2NpdHkgYW5kIHRpbWUgcmFuZ2VcbiAqICAgICAqIEJhc2VkIG9uIGluaXRpYWwgdmVsb2NpdHksIGluaXRpYWwgdGltZSwgYW5kIGFjY2VsZXJhdGlvblxuICogICAgICogRWFjaCBjb25uZWN0ZWQgU0wgdmVydGV4IHNob3VsZCBoYXZlIGEgKiB2ICogdCBub2RlcyB0aGF0IGNvdWxkIHBvc3NpYmx5IHRlcm1pbmF0ZSBhdCB0aGlzIG5vZGVcbiAqICAgKiBGb3IgYWxsIHZhbGlkIGVkZ2VzLCBmaW5kIHRoZSBvbmUgd2l0aCB0aGUgbG93ZXN0IGNvc3RcbiAqXG4gKiBJbnB1dDpcbiAqICAgKiAyRCB0ZXh0dXJlIGFycmF5IGNvc3QgbWFwXG4gKiAgICAgKiBIZWlnaHQ6IG51bSBvZiBsYXRpdHVkZXMgKH4yMClcbiAqICAgICAqIFdpZHRoOiBudW0gb2YgYWNjZWxlcmF0aW9uIHByb2ZpbGVzICogbnVtIG9mIHRpbWUgcmFuZ2VzICogbnVtIG9mIHZlbG9jaXR5IHJhbmdlcyAoOCAqIDIgKiA0ID0gfjY0KVxuICogICAgICAgKiBBIGZsYXR0ZW5lZCAzRCBhcnJheTpcbiAqICAgICAgICAgZDE6IGFjY2VsZXJhdGlvblxuICogICAgICAgICBkMjogdmVsb2NpdHlcbiAqICAgICAgICAgZDM6IHRpbWVcbiAqICAgICAqIExheWVyOiBudW0gb2Ygc3RhdGlvbnMgKH4xMClcbiAqICAgXG4gKiBPdXRwdXQ6XG4gKiAgICogMkQgdGV4dHVyZSBzbGljZSBvZiB0aGUgbmV4dCBzdGF0aW9uIGluIHRoZSBpbnB1dCAyRCB0ZXh0dXJlIGFycmF5IGNvc3QgbWFwXG4gKlxuICogQ29zdCBNYXAgRWxlbWVudHM6XG4gKiAgICogVHJhdmVyc2FsIGNvc3Qgc28gZmFyXG4gKiAgICogRW5kaW5nIHZlbG9jaXR5XG4gKiAgICogRW5kaW5nIHRpbWVcbiAqICAgKiBJbmRleCBvZiBwYXJlbnQgbm9kZVxuICpcbiAqIFNpbmNlIG9uZSBjdWJpYyBwYXRoIGNhbiBiZSBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSB0cmFqZWN0b3JpZXMsIHRoZXkgbmVlZCB0byBiZSBwcmUtb3B0aW1pemVkLlxuICpcbiAqIFF1aW50aWMgUGF0aHM6XG4gKiAgIFN0YXRpb25zIDAgdGhyb3VnaCAobnVtU3RhdGlvbnMgLSAxKSBjb3JyZXNwb25kIHRvIHRoZSBzdGF0aW9ucyBvbiB0aGUgbGF0dGljZTsgaG93ZXZlcixcbiAqICAgYSBuZXcgc3RhdGlvbiAoc3RhdGlvbiAtMSkgd2lsbCBiZSB1c2VkIHRvIHNpZ25pZml5IHRoZSBzaW5nbGUgdmVoaWNsZSBwb3NlIG5vZGUuIEVpdGhlclxuICogICBhIGN1YmljIHBhdGggb3IgcXVpbnRpYyBwYXRoIGNhbiBiZSB1c2VkIHRvIGNvbm5lY3QgdGhpcyBzaW5nbGUgbm9kZSB0byB0aGUgbGF0dGljZVxuICogICAoZGVwZW5kaW5nIG9uIHZlaGljbGUgdmVsb2NpdHkpLiBBdCBzdGF0aW9uIC0xLCBsYXRpdHVkZSAwIHdpbGwgY29ycmVzcG9uZCB0byBhIGN1YmljIHBhdGgsXG4gKiAgIGFuZCBsYXRpdHVkZSAxIHdpbGwgY29ycmVzcG9uZCB0byBhIHF1aW50aWMgcGF0aC4gQWxsIG90aGVyIGxhdGl0dWRlcyB3aWxsIGJlIHNraXBwZWQuXG4gKi9cblxuaW1wb3J0IHsgU0hBUkVEX1NIQURFUiwgU0FNUExFX0NVQklDX1BBVEhfRk4sIFNBTVBMRV9RVUlOVElDX1BBVEhfRk4sIE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMsIE5VTV9WRUxPQ0lUWV9SQU5HRVMsIE5VTV9USU1FX1JBTkdFUywgU0hBUkVEX1VOSUZPUk1TLCBidWlsZFVuaWZvcm1WYWx1ZXMgfSBmcm9tIFwiLi9ncmFwaFNlYXJjaFNoYXJlZC5qc1wiO1xuXG5jb25zdCBTT0xWRV9TVEFUSU9OX0tFUk5FTCA9XG4gIFNIQVJFRF9TSEFERVIgK1xuICBTQU1QTEVfQ1VCSUNfUEFUSF9GTiArXG4gIFNBTVBMRV9RVUlOVElDX1BBVEhfRk4gK1xuXG5gXG5cbnZlYzQga2VybmVsKCkge1xuICBpdmVjMiBpbmRleGVzID0gaXZlYzIoa2VybmVsUG9zaXRpb24gKiB2ZWMyKGtlcm5lbFNpemUpKTtcblxuICBpbnQgbGF0aXR1ZGUgPSBpbmRleGVzLnk7XG5cbiAgaW50IG51bVBlclRpbWUgPSBudW1BY2NlbGVyYXRpb25zICogbnVtVmVsb2NpdGllcztcbiAgaW50IHRpbWVJbmRleCA9IGluZGV4ZXMueCAvIG51bVBlclRpbWU7XG4gIGluZGV4ZXMueCAtPSB0aW1lSW5kZXggKiBudW1QZXJUaW1lO1xuICBpbnQgdmVsb2NpdHlJbmRleCA9IGluZGV4ZXMueCAvIG51bUFjY2VsZXJhdGlvbnM7XG4gIGludCBhY2NlbGVyYXRpb25JbmRleCA9IGludChtb2QoZmxvYXQoaW5kZXhlcy54KSwgZmxvYXQobnVtQWNjZWxlcmF0aW9ucykpKTtcblxuICBpbnQgbWluTGF0aXR1ZGUgPSBtYXgobGF0aXR1ZGUgLSBsYXRpdHVkZUNvbm5lY3Rpdml0eSAvIDIsIDApO1xuICBpbnQgbWF4TGF0aXR1ZGUgPSBtaW4obGF0aXR1ZGUgKyBsYXRpdHVkZUNvbm5lY3Rpdml0eSAvIDIsIG51bUxhdGl0dWRlcyAtIDEpO1xuXG4gIGludCBzbEluZGV4ID0gc3RhdGlvbiAqIG51bUxhdGl0dWRlcyArIGxhdGl0dWRlO1xuXG4gIHZlYzQgcGF0aEVuZCA9IHRleGVsRmV0Y2gobGF0dGljZSwgaXZlYzIobGF0aXR1ZGUsIHN0YXRpb24pLCAwKTtcblxuICBmbG9hdCBtaW5WZWxvY2l0eSA9IHZlbG9jaXR5UmFuZ2VzW3ZlbG9jaXR5SW5kZXhdO1xuICBmbG9hdCBtYXhWZWxvY2l0eSA9IHZlbG9jaXR5UmFuZ2VzW3ZlbG9jaXR5SW5kZXggKyAxXTtcblxuICBmbG9hdCBtaW5UaW1lID0gdGltZVJhbmdlc1t0aW1lSW5kZXhdO1xuICBmbG9hdCBtYXhUaW1lID0gdGltZVJhbmdlc1t0aW1lSW5kZXggKyAxXTtcblxuICB2ZWM0IGJlc3RUcmFqZWN0b3J5ID0gdmVjNCgtMSk7IC8vIC0xIG1lYW5zIGluZmluaXRlIGNvc3RcbiAgZmxvYXQgYmVzdFRlcm1pbmFsQ29zdCA9IDEuMCAvIDAuMDtcblxuICBmbG9hdCBoeXN0ZXJlc2lzQWRqdXN0bWVudCA9IChzbEluZGV4ID09IGZpcnN0TGF0dGljZVBvaW50IHx8IHNsSW5kZXggPT0gc2Vjb25kTGF0dGljZVBvaW50KSA/ICAwLjAgOiBoeXN0ZXJlc2lzRGlzY291bnQ7XG5cbiAgZm9yIChpbnQgcHJldlN0YXRpb24gPSBtYXgoc3RhdGlvbiAtIHN0YXRpb25Db25uZWN0aXZpdHksIDApOyBwcmV2U3RhdGlvbiA8IHN0YXRpb247IHByZXZTdGF0aW9uKyspIHtcbiAgICBpbnQgc3RhdGlvbkNvbm5lY3Rpdml0eUluZGV4ID0gcHJldlN0YXRpb24gLSBzdGF0aW9uICsgc3RhdGlvbkNvbm5lY3Rpdml0eTtcblxuICAgIGZvciAoaW50IHByZXZMYXRpdHVkZSA9IG1pbkxhdGl0dWRlOyBwcmV2TGF0aXR1ZGUgPD0gbWF4TGF0aXR1ZGU7IHByZXZMYXRpdHVkZSsrKSB7XG4gICAgICBpbnQgbGF0aXR1ZGVDb25uZWN0aXZpdHlJbmRleCA9IHByZXZMYXRpdHVkZSAtIGxhdGl0dWRlICsgbGF0aXR1ZGVDb25uZWN0aXZpdHkgLyAyO1xuICAgICAgaW50IGNvbm5lY3Rpdml0eUluZGV4ID0gc3RhdGlvbkNvbm5lY3Rpdml0eUluZGV4ICogbGF0aXR1ZGVDb25uZWN0aXZpdHkgKyBsYXRpdHVkZUNvbm5lY3Rpdml0eUluZGV4O1xuXG4gICAgICB2ZWM0IHBhdGhTdGFydCA9IHRleGVsRmV0Y2gobGF0dGljZSwgaXZlYzIocHJldkxhdGl0dWRlLCBwcmV2U3RhdGlvbiksIDApO1xuICAgICAgdmVjNCBjdWJpY1BhdGhQYXJhbXMgPSB0ZXhlbEZldGNoKGN1YmljUGF0aHMsIGl2ZWMyKHNsSW5kZXgsIGNvbm5lY3Rpdml0eUluZGV4KSwgMCk7XG5cbiAgICAgIC8vIElmIHRoZSBwYXRoIGRpZG4ndCBjb252ZXJnZVxuICAgICAgaWYgKGN1YmljUGF0aFBhcmFtcy53ID09IDAuMCkgY29udGludWU7XG5cbiAgICAgIGludCBudW1TYW1wbGVzID0gc2FtcGxlQ3ViaWNQYXRoKHBhdGhTdGFydCwgcGF0aEVuZCwgY3ViaWNQYXRoUGFyYW1zKTtcbiAgICAgIGZsb2F0IHBhdGhMZW5ndGggPSBjdWJpY1BhdGhQYXJhbXMuejtcblxuICAgICAgaWYgKG51bVNhbXBsZXMgPCAyKSBjb250aW51ZTtcblxuICAgICAgZmxvYXQgYXZlcmFnZVN0YXRpY0Nvc3QgPSBjYWxjdWxhdGVBdmVyYWdlU3RhdGljQ29zdChudW1TYW1wbGVzKTtcbiAgICAgIGlmIChhdmVyYWdlU3RhdGljQ29zdCA8IDAuMCkgY29udGludWU7XG5cbiAgICAgIGF2ZXJhZ2VTdGF0aWNDb3N0ICs9IGh5c3RlcmVzaXNBZGp1c3RtZW50O1xuXG4gICAgICBpZiAoYXZlcmFnZVN0YXRpY0Nvc3QgKiBwYXRoTGVuZ3RoID49IGJlc3RUZXJtaW5hbENvc3QpIGNvbnRpbnVlO1xuXG4gICAgICBmb3IgKGludCBwcmV2VmVsb2NpdHkgPSAwOyBwcmV2VmVsb2NpdHkgPCBudW1WZWxvY2l0aWVzOyBwcmV2VmVsb2NpdHkrKykge1xuICAgICAgICBmb3IgKGludCBwcmV2VGltZSA9IDA7IHByZXZUaW1lIDwgbnVtVGltZXM7IHByZXZUaW1lKyspIHtcbiAgICAgICAgICBmb3IgKGludCBwcmV2QWNjZWwgPSAwOyBwcmV2QWNjZWwgPCBudW1BY2NlbGVyYXRpb25zOyBwcmV2QWNjZWwrKykge1xuICAgICAgICAgICAgaW50IGF2dEluZGV4ID0gcHJldlRpbWUgKiBudW1QZXJUaW1lICsgcHJldlZlbG9jaXR5ICogbnVtQWNjZWxlcmF0aW9ucyArIHByZXZBY2NlbDtcblxuICAgICAgICAgICAgLy8gQ29zdCB0YWJsZSBlbnRyeTpcbiAgICAgICAgICAgIC8vICAgeDogY29zdCBzbyBmYXJcbiAgICAgICAgICAgIC8vICAgeTogZW5kIHZlbG9jaXR5XG4gICAgICAgICAgICAvLyAgIHo6IGVuZCB0aW1lXG4gICAgICAgICAgICAvLyAgIHc6IHBhcmVudCBpbmRleFxuICAgICAgICAgICAgdmVjNCBjb3N0VGFibGVFbnRyeSA9IHRleGVsRmV0Y2goY29zdFRhYmxlLCBpdmVjMyhhdnRJbmRleCwgcHJldkxhdGl0dWRlLCBwcmV2U3RhdGlvbiksIDApO1xuXG4gICAgICAgICAgICAvLyBJZiBjb3N0IGVudHJ5IGlzIGluZmluaXR5XG4gICAgICAgICAgICBpZiAoY29zdFRhYmxlRW50cnkueCA8IDAuMCB8fCBhdmVyYWdlU3RhdGljQ29zdCAqIHBhdGhMZW5ndGggKyBjb3N0VGFibGVFbnRyeS54ID49IGJlc3RUZXJtaW5hbENvc3QpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICB2ZWMzIGF2dCA9IGNhbGN1bGF0ZUFWVChhY2NlbGVyYXRpb25JbmRleCwgY29zdFRhYmxlRW50cnkueSwgY29zdFRhYmxlRW50cnkueiwgcGF0aExlbmd0aCk7XG4gICAgICAgICAgICBmbG9hdCBhY2NlbGVyYXRpb24gPSBhdnQueDtcbiAgICAgICAgICAgIGZsb2F0IGZpbmFsVmVsb2NpdHkgPSBhdnQueTtcbiAgICAgICAgICAgIGZsb2F0IGZpbmFsVGltZSA9IGF2dC56O1xuXG4gICAgICAgICAgICBpZiAoYXZlcmFnZVN0YXRpY0Nvc3QgKiBwYXRoTGVuZ3RoICsgY29zdFRhYmxlRW50cnkueCArIGV4dHJhVGltZVBlbmFsdHkgKiBmaW5hbFRpbWUgPj0gYmVzdFRlcm1pbmFsQ29zdCkgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBjYWxjdWxhdGVkIGZpbmFsIHZlbG9jaXR5IGRvZXMgbm90IG1hdGNoIHRoaXMgZnJhZ21lbnQncyB2ZWxvY2l0eSByYW5nZSwgdGhlbiBza2lwIHRoaXMgdHJhamVjdG9yeVxuICAgICAgICAgICAgaWYgKGZpbmFsVmVsb2NpdHkgPCBtaW5WZWxvY2l0eSB8fCBmaW5hbFZlbG9jaXR5ID49IG1heFZlbG9jaXR5KSBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlIGNhbGN1bGF0ZWQgZmluYWwgdGltZSBkb2VzIG5vdCBtYXRjaCB0aGlzIGZyYWdtZW50J3MgdGltZSByYW5nZSwgdGhlbiBza2lwIHRoaXMgdHJhamVjdG9yeVxuICAgICAgICAgICAgaWYgKGZpbmFsVGltZSA8IG1pblRpbWUgfHwgZmluYWxUaW1lID49IG1heFRpbWUpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBmbG9hdCBhYmFuZG9uVGhyZXNob2xkID0gKGJlc3RUZXJtaW5hbENvc3QgLSBleHRyYVRpbWVQZW5hbHR5ICogZmluYWxUaW1lIC0gY29zdFRhYmxlRW50cnkueCkgLyBwYXRoTGVuZ3RoIC0gYXZlcmFnZVN0YXRpY0Nvc3Q7XG4gICAgICAgICAgICBmbG9hdCBhdmVyYWdlRHluYW1pY0Nvc3QgPSBjYWxjdWxhdGVBdmVyYWdlRHluYW1pY0Nvc3QobnVtU2FtcGxlcywgcGF0aExlbmd0aCwgY29zdFRhYmxlRW50cnkueiwgY29zdFRhYmxlRW50cnkueSwgYWNjZWxlcmF0aW9uLCBhYmFuZG9uVGhyZXNob2xkKTtcbiAgICAgICAgICAgIGlmIChhdmVyYWdlRHluYW1pY0Nvc3QgPCAwLjApIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBpZiAoYWNjZWxlcmF0aW9uSW5kZXggIT0gcHJldkFjY2VsKVxuICAgICAgICAgICAgICBhdmVyYWdlRHluYW1pY0Nvc3QgKz0gYWNjZWxlcmF0aW9uQ2hhbmdlUGVuYWx0eTtcblxuICAgICAgICAgICAgLy8gVGhlIGNvc3Qgb2YgYSB0cmFqZWN0b3J5IGlzIHRoZSBhdmVyYWdlIHNhbXBsZSBjb3N0IHNjYWxlZCBieSB0aGUgcGF0aCBsZW5ndGhcbiAgICAgICAgICAgIGZsb2F0IHRvdGFsQ29zdCA9IChhdmVyYWdlU3RhdGljQ29zdCArIGF2ZXJhZ2VEeW5hbWljQ29zdCkgKiBwYXRoTGVuZ3RoICsgY29zdFRhYmxlRW50cnkueDtcblxuICAgICAgICAgICAgZmxvYXQgdGVybWluYWxDb3N0ID0gdG90YWxDb3N0ICsgZXh0cmFUaW1lUGVuYWx0eSAqIGZpbmFsVGltZTtcbiAgICAgICAgICAgIGlmICh0ZXJtaW5hbENvc3QgPj0gYmVzdFRlcm1pbmFsQ29zdCkgY29udGludWU7XG4gICAgICAgICAgICBiZXN0VGVybWluYWxDb3N0ID0gdGVybWluYWxDb3N0O1xuXG4gICAgICAgICAgICBpbnQgaW5jb21pbmdJbmRleCA9IGF2dEluZGV4ICsgbnVtUGVyVGltZSAqIG51bVRpbWVzICogKHByZXZMYXRpdHVkZSArIG51bUxhdGl0dWRlcyAqIHByZXZTdGF0aW9uKTtcbiAgICAgICAgICAgIGJlc3RUcmFqZWN0b3J5ID0gdmVjNCh0b3RhbENvc3QsIGZpbmFsVmVsb2NpdHksIGZpbmFsVGltZSwgaW5jb21pbmdJbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRpb24gPCBzdGF0aW9uQ29ubmVjdGl2aXR5KSB7XG4gICAgaXZlYzIgc2xhSW5kZXggPSBpdmVjMihsYXRpdHVkZSwgc3RhdGlvbiAqIG51bUFjY2VsZXJhdGlvbnMgKyBhY2NlbGVyYXRpb25JbmRleCk7XG5cbiAgICB2ZWM0IGNvc3RUYWJsZUVudHJ5ID0gdGV4ZWxGZXRjaChjdWJpY1BhdGhGcm9tVmVoaWNsZUNvc3RzLCBzbGFJbmRleCwgMCk7XG4gICAgZmxvYXQgdGVybWluYWxDb3N0O1xuXG4gICAgaWYgKGNvc3RUYWJsZUVudHJ5LnggPj0gMC4wKSB7XG4gICAgICB0ZXJtaW5hbENvc3QgPSBjb3N0VGFibGVFbnRyeS54ICsgZXh0cmFUaW1lUGVuYWx0eSAqIGNvc3RUYWJsZUVudHJ5Lno7XG5cbiAgICAgIGlmICh0ZXJtaW5hbENvc3QgPCBiZXN0VGVybWluYWxDb3N0KSB7XG4gICAgICAgIGJlc3RUZXJtaW5hbENvc3QgPSB0ZXJtaW5hbENvc3Q7XG4gICAgICAgIGJlc3RUcmFqZWN0b3J5ID0gY29zdFRhYmxlRW50cnk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29zdFRhYmxlRW50cnkgPSB0ZXhlbEZldGNoKHF1aW50aWNQYXRoRnJvbVZlaGljbGVDb3N0cywgc2xhSW5kZXgsIDApO1xuXG4gICAgaWYgKGNvc3RUYWJsZUVudHJ5LnggPj0gMC4wKSB7XG4gICAgICB0ZXJtaW5hbENvc3QgPSBjb3N0VGFibGVFbnRyeS54ICsgZXh0cmFUaW1lUGVuYWx0eSAqIGNvc3RUYWJsZUVudHJ5Lno7XG5cbiAgICAgIGlmICh0ZXJtaW5hbENvc3QgPCBiZXN0VGVybWluYWxDb3N0KSB7XG4gICAgICAgIGJlc3RUZXJtaW5hbENvc3QgPSB0ZXJtaW5hbENvc3Q7XG4gICAgICAgIGJlc3RUcmFqZWN0b3J5ID0gY29zdFRhYmxlRW50cnk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJlc3RUcmFqZWN0b3J5O1xufVxuXG5gO1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNldFVwKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXJuZWw6IFNPTFZFX1NUQVRJT05fS0VSTkVMLFxuICAgICAgb3V0cHV0OiB7IG5hbWU6ICdncmFwaFNlYXJjaCcgfSxcbiAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCBTSEFSRURfVU5JRk9STVMsIHtcbiAgICAgICAgbGF0dGljZTogeyB0eXBlOiAnc2hhcmVkVGV4dHVyZScgfSxcbiAgICAgICAgY29zdFRhYmxlOiB7IHR5cGU6ICdzaGFyZWRUZXh0dXJlJywgdGV4dHVyZVR5cGU6ICcyREFycmF5JyB9LFxuICAgICAgICBjdWJpY1BhdGhzOiB7IHR5cGU6ICdvdXRwdXRUZXh0dXJlJyB9LFxuICAgICAgICBjdWJpY1BhdGhGcm9tVmVoaWNsZUNvc3RzOiB7IHR5cGU6ICdvdXRwdXRUZXh0dXJlJyB9LFxuICAgICAgICBxdWludGljUGF0aEZyb21WZWhpY2xlQ29zdHM6IHsgdHlwZTogJ291dHB1dFRleHR1cmUnIH0sXG4gICAgICAgIGZpcnN0TGF0dGljZVBvaW50OiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgIHNlY29uZExhdHRpY2VQb2ludDogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICB2ZWxvY2l0eVZlaGljbGU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICBjdXJ2VmVoaWNsZTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gICAgICAgIGRDdXJ2VmVoaWNsZTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gICAgICAgIGRkQ3VydlZlaGljbGU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICBleHRyYVRpbWVQZW5hbHR5OiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgaHlzdGVyZXNpc0Rpc2NvdW50OiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgYWNjZWxlcmF0aW9uQ2hhbmdlUGVuYWx0eTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gICAgICAgIG51bVN0YXRpb25zOiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgIG51bUxhdGl0dWRlczogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICBudW1BY2NlbGVyYXRpb25zOiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgIG51bVZlbG9jaXRpZXM6IHsgdHlwZTogJ2ludCcgfSxcbiAgICAgICAgbnVtVGltZXM6IHsgdHlwZTogJ2ludCcgfSxcbiAgICAgICAgc3RhdGlvbkNvbm5lY3Rpdml0eTogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICBsYXRpdHVkZUNvbm5lY3Rpdml0eTogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICB2ZWxvY2l0eVJhbmdlczogeyB0eXBlOiAnZmxvYXQnLCBsZW5ndGg6IE5VTV9WRUxPQ0lUWV9SQU5HRVMgKyAxIH0sXG4gICAgICAgIHRpbWVSYW5nZXM6IHsgdHlwZTogJ2Zsb2F0JywgbGVuZ3RoOiBOVU1fVElNRV9SQU5HRVMgKyAxIH0sXG4gICAgICAgIHN0YXRpb246IHsgdHlwZTogJ2ludCcgfSAvLyBVcGRhdGVkIGluIGBkcmF3UHJveHlgXG4gICAgICB9KSxcbiAgICAgIGRyYXdQcm94eTogKGdwZ3B1LCBwcm9ncmFtLCBkcmF3KSA9PiB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gTlVNX0FDQ0VMRVJBVElPTl9QUk9GSUxFUyAqIE5VTV9WRUxPQ0lUWV9SQU5HRVMgKiBOVU1fVElNRV9SQU5HRVM7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHByb2dyYW0ubWV0YS5sYXR0aWNlLm51bUxhdGl0dWRlcztcbiAgICAgICAgY29uc3QgY29zdFRhYmxlID0gbmV3IEZsb2F0MzJBcnJheSh3aWR0aCAqIGhlaWdodCAqIHByb2dyYW0ubWV0YS5sYXR0aWNlLm51bVN0YXRpb25zICogNCk7XG5cbiAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBwcm9ncmFtLm1ldGEubGF0dGljZS5udW1TdGF0aW9uczsgcysrKSB7XG4gICAgICAgICAgZ3BncHUudXBkYXRlUHJvZ3JhbVVuaWZvcm1zKHByb2dyYW0sIHsgc3RhdGlvbjogcyB9KTtcbiAgICAgICAgICBkcmF3KCk7XG5cbiAgICAgICAgICBncGdwdS5nbC5yZWFkUGl4ZWxzKDAsIDAsIHdpZHRoLCBoZWlnaHQsIGdwZ3B1LmdsLlJHQkEsIGdwZ3B1LmdsLkZMT0FULCBjb3N0VGFibGUsIHMgKiB3aWR0aCAqIGhlaWdodCAqIDQpO1xuXG4gICAgICAgICAgZ3BncHUuZ2wuYmluZFRleHR1cmUoZ3BncHUuZ2wuVEVYVFVSRV8yRF9BUlJBWSwgZ3BncHUuc2hhcmVkVGV4dHVyZXMuY29zdFRhYmxlKTtcbiAgICAgICAgICBncGdwdS5nbC5jb3B5VGV4U3ViSW1hZ2UzRChncGdwdS5nbC5URVhUVVJFXzJEX0FSUkFZLCAwLCAwLCAwLCBzLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdwZ3B1Ll9ncmFwaFNlYXJjaENvc3RUYWJsZSA9IGNvc3RUYWJsZTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZShjb25maWcsIHBvc2UsIHh5Q2VudGVyUG9pbnQsIHNsQ2VudGVyUG9pbnQsIGZpcnN0TGF0dGljZVBvaW50LCBzZWNvbmRMYXR0aWNlUG9pbnQsIGR5bmFtaWNGcmFtZVRpbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMgKiBOVU1fVkVMT0NJVFlfUkFOR0VTICogTlVNX1RJTUVfUkFOR0VTLFxuICAgICAgaGVpZ2h0OiBjb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMsXG4gICAgICBtZXRhOiB7XG4gICAgICAgIGxhdHRpY2U6IGNvbmZpZy5sYXR0aWNlXG4gICAgICB9LFxuICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkVW5pZm9ybVZhbHVlcyhjb25maWcsIHh5Q2VudGVyUG9pbnQsIHNsQ2VudGVyUG9pbnQsIGR5bmFtaWNGcmFtZVRpbWUpLCB7XG4gICAgICAgIGZpcnN0TGF0dGljZVBvaW50OiBmaXJzdExhdHRpY2VQb2ludCxcbiAgICAgICAgc2Vjb25kTGF0dGljZVBvaW50OiBzZWNvbmRMYXR0aWNlUG9pbnQsXG4gICAgICAgIHZlbG9jaXR5VmVoaWNsZTogcG9zZS52ZWxvY2l0eSxcbiAgICAgICAgY3VydlZlaGljbGU6IHBvc2UuY3VydixcbiAgICAgICAgZEN1cnZWZWhpY2xlOiBwb3NlLmRDdXJ2LFxuICAgICAgICBkZEN1cnZWZWhpY2xlOiBwb3NlLmRkQ3VydixcbiAgICAgICAgZXh0cmFUaW1lUGVuYWx0eTogY29uZmlnLmV4dHJhVGltZVBlbmFsdHksXG4gICAgICAgIGh5c3RlcmVzaXNEaXNjb3VudDogY29uZmlnLmh5c3RlcmVzaXNEaXNjb3VudCxcbiAgICAgICAgYWNjZWxlcmF0aW9uQ2hhbmdlUGVuYWx0eTogY29uZmlnLmFjY2VsZXJhdGlvbkNoYW5nZVBlbmFsdHksXG4gICAgICAgIG51bVN0YXRpb25zOiBjb25maWcubGF0dGljZS5udW1TdGF0aW9ucyxcbiAgICAgICAgbnVtTGF0aXR1ZGVzOiBjb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMsXG4gICAgICAgIG51bUFjY2VsZXJhdGlvbnM6IE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMsXG4gICAgICAgIG51bVZlbG9jaXRpZXM6IE5VTV9WRUxPQ0lUWV9SQU5HRVMsXG4gICAgICAgIG51bVRpbWVzOiBOVU1fVElNRV9SQU5HRVMsXG4gICAgICAgIHN0YXRpb25Db25uZWN0aXZpdHk6IGNvbmZpZy5sYXR0aWNlLnN0YXRpb25Db25uZWN0aXZpdHksXG4gICAgICAgIGxhdGl0dWRlQ29ubmVjdGl2aXR5OiBjb25maWcubGF0dGljZS5sYXRpdHVkZUNvbm5lY3Rpdml0eSxcbiAgICAgICAgdmVsb2NpdHlSYW5nZXM6IFswLCBjb25maWcuc3BlZWRMaW1pdCAvIDMsIGNvbmZpZy5zcGVlZExpbWl0ICogMiAvIDMsIGNvbmZpZy5zcGVlZExpbWl0LCAxMDAwMDAwXSxcbiAgICAgICAgdGltZVJhbmdlczogWzAsIDEwLCAxMDAwMDAwXVxuICAgICAgfSlcbiAgICB9O1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/autonomy/path-planning/gpgpu-programs/graphSearch.js\n");

/***/ }),

/***/ "./js/autonomy/path-planning/gpgpu-programs/graphSearchShared.js":
/*!***********************************************************************!*\
  !*** ./js/autonomy/path-planning/gpgpu-programs/graphSearchShared.js ***!
  \***********************************************************************/
/*! exports provided: SHARED_SHADER, SAMPLE_CUBIC_PATH_FN, SAMPLE_QUINTIC_PATH_FN, NUM_ACCELERATION_PROFILES, NUM_VELOCITY_RANGES, NUM_TIME_RANGES, SHARED_UNIFORMS, buildUniformValues */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHARED_SHADER\", function() { return SHARED_SHADER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SAMPLE_CUBIC_PATH_FN\", function() { return SAMPLE_CUBIC_PATH_FN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SAMPLE_QUINTIC_PATH_FN\", function() { return SAMPLE_QUINTIC_PATH_FN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NUM_ACCELERATION_PROFILES\", function() { return NUM_ACCELERATION_PROFILES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NUM_VELOCITY_RANGES\", function() { return NUM_VELOCITY_RANGES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NUM_TIME_RANGES\", function() { return NUM_TIME_RANGES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHARED_UNIFORMS\", function() { return SHARED_UNIFORMS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"buildUniformValues\", function() { return buildUniformValues; });\nconst SHARED_SHADER = `\n\nconst float smallV = 0.01;\nvec4 pathSamples[128];\nfloat pathSampleCurvRates[128];\n\nfloat calculateAcceleration(int index, float initialVelocitySq, float distance) {\n  if (index <= 4) {\n    // [aMaxHard, aMinHard, aMaxSoft, aMinSoft, 0]\n    return accelerationProfiles[index];\n  } else {\n    float finalVelocity = finalVelocityProfiles[index - 5];\n    if (distance < 0.001) return 0.0;\n    return clamp((finalVelocity * finalVelocity - initialVelocitySq) / (2.0 * distance), accelerationProfiles[1], accelerationProfiles[0]);\n  }\n}\n\nvec2 xy2sl(vec4 xytk) {\n  vec2 xy = xytk.xy + rearAxleToCenter * vec2(cos(xytk.z), sin(xytk.z));\n  vec2 xyTexCoords = (xy - xyCenterPoint) / vec2(textureSize(xyslMap, 0)) / vec2(xyGridCellSize) + 0.5;\n  return texture(xyslMap, xyTexCoords).xy;\n}\n\nfloat sampleStaticCost(vec4 xytk) {\n  vec2 sl = xy2sl(xytk);\n  vec2 slTexCoords = (sl - slCenterPoint) / vec2(textureSize(slObstacleGrid, 0)) / vec2(slGridCellSize) + 0.5;\n  float obstacleCost = texture(slObstacleGrid, slTexCoords).r;\n\n  if (obstacleCost >= 0.75) return -1.0; // Infinite cost\n\n  obstacleCost = step(0.25, obstacleCost) * obstacleHazardCost;\n\n  float absLatitude = abs(sl.y);\n  if (absLatitude >= laneShoulderLatitude) return -1.0;\n\n  float laneCost = abs(absLatitude - laneCenterLatitude) * laneCostSlope + step(0.0, -sl.y * sign(lanePreference)) * lanePreferenceDiscount;\n\n  return obstacleCost + laneCost;\n}\n\nfloat sampleDynamicCost(vec4 xytk, float time, float velocity, float acceleration) {\n  vec2 sl = xy2sl(xytk);\n  vec2 slTexCoords = (sl - slCenterPoint) / vec2(textureSize(slDynamicObstacleGrid, 0).xy) / vec2(slGridCellSize) + 0.5;\n  float dynamicFrame = floor(time / dynamicFrameTime);\n\n  float obstacleCost = texture(slDynamicObstacleGrid, vec3(slTexCoords, dynamicFrame)).r;\n\n  if (obstacleCost > 0.75) return -1.0; // Infinite cost\n\n  return step(0.25, obstacleCost) * obstacleHazardCost;\n}\n\nfloat calculateAverageStaticCost(int numSamples) {\n  float averageStaticCost = 0.0;\n\n  for (int i = 0; i < numSamples; i++) {\n    float cost = sampleStaticCost(pathSamples[i]);\n\n    if (cost < 0.0) return cost;\n\n    averageStaticCost += cost;\n  }\n\n  averageStaticCost /= float(numSamples);\n\n  return averageStaticCost;\n}\n\nfloat calculateAverageDynamicCost(int numSamples, float pathLength, float initialTime, float initialVelocity, float acceleration, float abandonThreshold) {\n  float s = 0.0;\n  float ds = pathLength / float(numSamples - 1);\n  float averageDynamicCost = 0.0;\n  float maxVelocity = 0.0;\n  float maxLateralAcceleration = 0.0;\n  float numSamples_f = float(numSamples);\n\n  for (int i = 0; i < numSamples; i++) {\n    vec4 pathSample = pathSamples[i]; // vec4(x-pos, y-pos, theta (rotation), kappa (curvature))\n\n    float velocitySq = 2.0 * acceleration * s + initialVelocity * initialVelocity;\n    float velocity = max(smallV, sqrt(max(0.0, velocitySq)));\n    maxVelocity = max(maxVelocity, velocity);\n    maxLateralAcceleration = max(maxLateralAcceleration, abs(pathSample.w * velocity * velocity));\n\n    float time = 2.0 * s / (initialVelocity + velocity) + initialTime;\n\n    float dCurv = pathSampleCurvRates[i] * velocity;\n    if (dCurv > dCurvatureMax) return -1.0;\n\n    float cost = sampleDynamicCost(pathSample, time, velocity, acceleration);\n    if (cost < 0.0) return cost;\n\n    averageDynamicCost += cost;\n    if (averageDynamicCost / numSamples_f >= abandonThreshold) return -1.0;\n\n    s += ds;\n  }\n\n  averageDynamicCost /= numSamples_f;\n\n  // Apply speeding penality if any velocity along the trajectory is over the speed limit\n  averageDynamicCost += step(speedLimit, maxVelocity) * speedLimitPenalty;\n\n  // Apply hard acceleration/deceleration penalties if the acceleration/deceleration exceeds the soft limits\n  averageDynamicCost += step(accelerationProfiles[2] + 0.0001, acceleration) * hardAccelerationPenalty;\n  averageDynamicCost += (1.0 - step(accelerationProfiles[3], acceleration)) * hardDecelerationPenalty;\n\n  // Penalize lateral acceleration\n  averageDynamicCost += step(softLateralAccelerationLimit, maxLateralAcceleration) * softLateralAccelerationPenalty;\n  averageDynamicCost += linearLateralAccelerationPenalty * maxLateralAcceleration;\n\n  return averageDynamicCost;\n}\n\nvec3 calculateAVT(int accelerationIndex, float initialVelocity, float initialTime, float pathLength) {\n  float initialVelocitySq = initialVelocity * initialVelocity;\n  float acceleration = calculateAcceleration(accelerationIndex, initialVelocitySq, pathLength);\n\n  float finalVelocitySq = 2.0 * acceleration * pathLength + initialVelocitySq;\n  float finalVelocity = max(smallV, sqrt(max(0.0, finalVelocitySq)));\n\n  float finalTime = initialTime;\n\n  if (acceleration == 0.0) {\n    finalTime += pathLength / finalVelocity;\n  } else if (finalVelocitySq <= 0.0) { // Calculate final time if the vehicle stops before the end of the trajectory\n    float distanceLeft = pathLength - (smallV * smallV - initialVelocitySq) / (2.0 * acceleration);\n    finalTime += (finalVelocity - initialVelocity) / acceleration + distanceLeft / smallV;\n  } else {\n    finalTime += 2.0 * pathLength / (finalVelocity + initialVelocity);\n  }\n\n  return vec3(acceleration, finalVelocity, finalTime);\n}\n\n`;\n\nconst SAMPLE_CUBIC_PATH_FN = `\n\nint sampleCubicPath(vec4 start, vec4 end, vec4 cubicPathParams) {\n  float p0 = start.w;\n  float p1 = cubicPathParams.x;\n  float p2 = cubicPathParams.y;\n  float p3 = end.w;\n  float sG = cubicPathParams.z;\n\n  if (sG <= 0.0) return 0;\n\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\n\n  float sG_2 = sG * sG;\n  float sG_3 = sG_2 * sG;\n\n  float a = p0;\n  float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\n  float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\n  float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\n\n  pathSamples[0] = start;\n\n  float ds = sG / float(numSamples - 1);\n  float s = ds;\n  vec2 dxy = vec2(0);\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\n\n  for (int i = 1; i < numSamples; i++) {\n    float rot = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\n    float curv = ((d * s + c) * s + b) * s + a;\n\n    vec2 cosSin = vec2(cos(rot), sin(rot));\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\n\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\n    pathSampleCurvRates[i] = b + s * (2.0 * c + 3.0 * d * s);\n\n    s += ds;\n    prevCosSin = cosSin;\n  }\n\n  return numSamples;\n}\n\n`;\n\nconst SAMPLE_QUINTIC_PATH_FN = `\n\nint sampleQuinticPath(vec4 start, vec4 end, vec4 quinticPathParams) {\n  float p0 = start.w;\n  float p1 = dCurvVehicle;\n  float p2 = ddCurvVehicle;\n  float p3 = quinticPathParams.x;\n  float p4 = quinticPathParams.y;\n  float p5 = end.w;\n  float sG = quinticPathParams.z;\n\n  if (sG <= 0.0) return 0;\n\n  int numSamples = int(ceil(sG / pathSamplingStep)) + 1;\n\n  float sG_2 = sG * sG;\n  float sG_3 = sG_2 * sG;\n\n  float a = p0;\n  float b = p1;\n  float c = p2 / 2.0;\n  float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\n  float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\n  float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\n\n  pathSamples[0] = start;\n\n  float ds = sG / float(numSamples - 1);\n  float s = ds;\n  vec2 dxy = vec2(0);\n  vec2 prevCosSin = vec2(cos(start.z), sin(start.z));\n\n  for (int i = 1; i < numSamples; i++) {\n    float rot = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s + start.z;\n    float curv = ((((f * s + e) * s + d) * s + c) * s + b) * s + a;\n\n    vec2 cosSin = vec2(cos(rot), sin(rot));\n    dxy = dxy * vec2(float(i - 1) / float(i)) + (cosSin + prevCosSin) / vec2(2 * i);\n\n    pathSamples[i] = vec4(dxy * vec2(s) + start.xy, rot, curv);\n    pathSampleCurvRates[i] = b + s * (2.0 * c + s * (3.0 * d + s * (4.0 * e + 5.0 * f * s)));\n\n    s += ds;\n    prevCosSin = cosSin;\n  }\n\n  return numSamples;\n}\n\n`;\n\nconst NUM_ACCELERATION_PROFILES = 8;\nconst NUM_VELOCITY_RANGES = 4;\nconst NUM_TIME_RANGES = 2;\n\nconst SHARED_UNIFORMS = {\n  xyslMap: { type: 'outputTexture' },\n  slObstacleGrid: { type: 'outputTexture', name: 'slObstacleGridDilated' },\n  slDynamicObstacleGrid: { type: 'outputTexture', name: 'slDynamicObstacleGrid', textureType: '2DArray' },\n  accelerationProfiles: { type: 'float', length: 5 },\n  finalVelocityProfiles: { type: 'float', length: 3 },\n  xyCenterPoint: { type: 'vec2' },\n  xyGridCellSize: { type: 'float' },\n  slCenterPoint: { type: 'vec2' },\n  slGridCellSize: { type: 'float'},\n  laneCenterLatitude: { type: 'float'},\n  laneShoulderLatitude: { type: 'float'},\n  laneCostSlope: { type: 'float'},\n  lanePreference: { type: 'float' },\n  lanePreferenceDiscount: { type: 'float' },\n  obstacleHazardCost: { type: 'float' },\n  speedLimit: { type: 'float' },\n  speedLimitPenalty: { type: 'float' },\n  hardAccelerationPenalty: { type: 'float' },\n  hardDecelerationPenalty: { type: 'float' },\n  softLateralAccelerationLimit: { type: 'float' },\n  softLateralAccelerationPenalty: { type: 'float' },\n  linearLateralAccelerationPenalty: { type: 'float' },\n  dCurvatureMax: { type: 'float' },\n  pathSamplingStep: { type: 'float' },\n  rearAxleToCenter: { type: 'float' },\n  dynamicFrameTime: { type: 'float' }\n};\n\nfunction buildUniformValues(config, xyCenterPoint, slCenterPoint, dynamicFrameTime) {\n  return {\n    accelerationProfiles: [3.5, -6.5, 2.0, -3.0, 0],\n    finalVelocityProfiles: [0.999 * config.speedLimit, 1.0, 0.01],\n    xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\n    xyGridCellSize: config.xyGridCellSize,\n    slCenterPoint: [slCenterPoint.x, slCenterPoint.y],\n    slGridCellSize: config.slGridCellSize,\n    laneCenterLatitude: config.laneCenterLatitude,\n    laneShoulderLatitude: config.laneShoulderLatitude,\n    laneCostSlope: config.laneCostSlope,\n    lanePreference: config.lanePreference,\n    lanePreferenceDiscount: config.lanePreferenceDiscount,\n    obstacleHazardCost: config.obstacleHazardCost,\n    speedLimit: config.speedLimit,\n    speedLimitPenalty: config.speedLimitPenalty,\n    hardAccelerationPenalty: config.hardAccelerationPenalty,\n    hardDecelerationPenalty: config.hardDecelerationPenalty,\n    softLateralAccelerationLimit: config.softLateralAccelerationLimit,\n    softLateralAccelerationPenalty: config.softLateralAccelerationPenalty,\n    linearLateralAccelerationPenalty: config.linearLateralAccelerationPenalty,\n    dCurvatureMax: config.dCurvatureMax,\n    pathSamplingStep: config.pathSamplingStep,\n    rearAxleToCenter: config.rearAxleToCenter,\n    dynamicFrameTime: dynamicFrameTime\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL2dyYXBoU2VhcmNoU2hhcmVkLmpzPzIwNTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDOztBQUV4Qzs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUNBQXVDOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLGdCQUFnQjtBQUNqQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGdCQUFnQjtBQUNqQyxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUcsbUNBQW1DO0FBQ3RDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDLG1CQUFtQix1REFBdUQ7QUFDMUUsMEJBQTBCLCtFQUErRTtBQUN6Ryx5QkFBeUIsMkJBQTJCO0FBQ3BELDBCQUEwQiwyQkFBMkI7QUFDckQsa0JBQWtCLGVBQWU7QUFDakMsbUJBQW1CLGdCQUFnQjtBQUNuQyxrQkFBa0IsZUFBZTtBQUNqQyxtQkFBbUIsZUFBZTtBQUNsQyx1QkFBdUIsZUFBZTtBQUN0Qyx5QkFBeUIsZUFBZTtBQUN4QyxrQkFBa0IsZUFBZTtBQUNqQyxtQkFBbUIsZ0JBQWdCO0FBQ25DLDJCQUEyQixnQkFBZ0I7QUFDM0MsdUJBQXVCLGdCQUFnQjtBQUN2QyxlQUFlLGdCQUFnQjtBQUMvQixzQkFBc0IsZ0JBQWdCO0FBQ3RDLDRCQUE0QixnQkFBZ0I7QUFDNUMsNEJBQTRCLGdCQUFnQjtBQUM1QyxpQ0FBaUMsZ0JBQWdCO0FBQ2pELG1DQUFtQyxnQkFBZ0I7QUFDbkQscUNBQXFDLGdCQUFnQjtBQUNyRCxrQkFBa0IsZ0JBQWdCO0FBQ2xDLHFCQUFxQixnQkFBZ0I7QUFDckMscUJBQXFCLGdCQUFnQjtBQUNyQyxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQWFBIiwiZmlsZSI6Ii4vanMvYXV0b25vbXkvcGF0aC1wbGFubmluZy9ncGdwdS1wcm9ncmFtcy9ncmFwaFNlYXJjaFNoYXJlZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFNIQVJFRF9TSEFERVIgPSBgXG5cbmNvbnN0IGZsb2F0IHNtYWxsViA9IDAuMDE7XG52ZWM0IHBhdGhTYW1wbGVzWzEyOF07XG5mbG9hdCBwYXRoU2FtcGxlQ3VydlJhdGVzWzEyOF07XG5cbmZsb2F0IGNhbGN1bGF0ZUFjY2VsZXJhdGlvbihpbnQgaW5kZXgsIGZsb2F0IGluaXRpYWxWZWxvY2l0eVNxLCBmbG9hdCBkaXN0YW5jZSkge1xuICBpZiAoaW5kZXggPD0gNCkge1xuICAgIC8vIFthTWF4SGFyZCwgYU1pbkhhcmQsIGFNYXhTb2Z0LCBhTWluU29mdCwgMF1cbiAgICByZXR1cm4gYWNjZWxlcmF0aW9uUHJvZmlsZXNbaW5kZXhdO1xuICB9IGVsc2Uge1xuICAgIGZsb2F0IGZpbmFsVmVsb2NpdHkgPSBmaW5hbFZlbG9jaXR5UHJvZmlsZXNbaW5kZXggLSA1XTtcbiAgICBpZiAoZGlzdGFuY2UgPCAwLjAwMSkgcmV0dXJuIDAuMDtcbiAgICByZXR1cm4gY2xhbXAoKGZpbmFsVmVsb2NpdHkgKiBmaW5hbFZlbG9jaXR5IC0gaW5pdGlhbFZlbG9jaXR5U3EpIC8gKDIuMCAqIGRpc3RhbmNlKSwgYWNjZWxlcmF0aW9uUHJvZmlsZXNbMV0sIGFjY2VsZXJhdGlvblByb2ZpbGVzWzBdKTtcbiAgfVxufVxuXG52ZWMyIHh5MnNsKHZlYzQgeHl0aykge1xuICB2ZWMyIHh5ID0geHl0ay54eSArIHJlYXJBeGxlVG9DZW50ZXIgKiB2ZWMyKGNvcyh4eXRrLnopLCBzaW4oeHl0ay56KSk7XG4gIHZlYzIgeHlUZXhDb29yZHMgPSAoeHkgLSB4eUNlbnRlclBvaW50KSAvIHZlYzIodGV4dHVyZVNpemUoeHlzbE1hcCwgMCkpIC8gdmVjMih4eUdyaWRDZWxsU2l6ZSkgKyAwLjU7XG4gIHJldHVybiB0ZXh0dXJlKHh5c2xNYXAsIHh5VGV4Q29vcmRzKS54eTtcbn1cblxuZmxvYXQgc2FtcGxlU3RhdGljQ29zdCh2ZWM0IHh5dGspIHtcbiAgdmVjMiBzbCA9IHh5MnNsKHh5dGspO1xuICB2ZWMyIHNsVGV4Q29vcmRzID0gKHNsIC0gc2xDZW50ZXJQb2ludCkgLyB2ZWMyKHRleHR1cmVTaXplKHNsT2JzdGFjbGVHcmlkLCAwKSkgLyB2ZWMyKHNsR3JpZENlbGxTaXplKSArIDAuNTtcbiAgZmxvYXQgb2JzdGFjbGVDb3N0ID0gdGV4dHVyZShzbE9ic3RhY2xlR3JpZCwgc2xUZXhDb29yZHMpLnI7XG5cbiAgaWYgKG9ic3RhY2xlQ29zdCA+PSAwLjc1KSByZXR1cm4gLTEuMDsgLy8gSW5maW5pdGUgY29zdFxuXG4gIG9ic3RhY2xlQ29zdCA9IHN0ZXAoMC4yNSwgb2JzdGFjbGVDb3N0KSAqIG9ic3RhY2xlSGF6YXJkQ29zdDtcblxuICBmbG9hdCBhYnNMYXRpdHVkZSA9IGFicyhzbC55KTtcbiAgaWYgKGFic0xhdGl0dWRlID49IGxhbmVTaG91bGRlckxhdGl0dWRlKSByZXR1cm4gLTEuMDtcblxuICBmbG9hdCBsYW5lQ29zdCA9IGFicyhhYnNMYXRpdHVkZSAtIGxhbmVDZW50ZXJMYXRpdHVkZSkgKiBsYW5lQ29zdFNsb3BlICsgc3RlcCgwLjAsIC1zbC55ICogc2lnbihsYW5lUHJlZmVyZW5jZSkpICogbGFuZVByZWZlcmVuY2VEaXNjb3VudDtcblxuICByZXR1cm4gb2JzdGFjbGVDb3N0ICsgbGFuZUNvc3Q7XG59XG5cbmZsb2F0IHNhbXBsZUR5bmFtaWNDb3N0KHZlYzQgeHl0aywgZmxvYXQgdGltZSwgZmxvYXQgdmVsb2NpdHksIGZsb2F0IGFjY2VsZXJhdGlvbikge1xuICB2ZWMyIHNsID0geHkyc2woeHl0ayk7XG4gIHZlYzIgc2xUZXhDb29yZHMgPSAoc2wgLSBzbENlbnRlclBvaW50KSAvIHZlYzIodGV4dHVyZVNpemUoc2xEeW5hbWljT2JzdGFjbGVHcmlkLCAwKS54eSkgLyB2ZWMyKHNsR3JpZENlbGxTaXplKSArIDAuNTtcbiAgZmxvYXQgZHluYW1pY0ZyYW1lID0gZmxvb3IodGltZSAvIGR5bmFtaWNGcmFtZVRpbWUpO1xuXG4gIGZsb2F0IG9ic3RhY2xlQ29zdCA9IHRleHR1cmUoc2xEeW5hbWljT2JzdGFjbGVHcmlkLCB2ZWMzKHNsVGV4Q29vcmRzLCBkeW5hbWljRnJhbWUpKS5yO1xuXG4gIGlmIChvYnN0YWNsZUNvc3QgPiAwLjc1KSByZXR1cm4gLTEuMDsgLy8gSW5maW5pdGUgY29zdFxuXG4gIHJldHVybiBzdGVwKDAuMjUsIG9ic3RhY2xlQ29zdCkgKiBvYnN0YWNsZUhhemFyZENvc3Q7XG59XG5cbmZsb2F0IGNhbGN1bGF0ZUF2ZXJhZ2VTdGF0aWNDb3N0KGludCBudW1TYW1wbGVzKSB7XG4gIGZsb2F0IGF2ZXJhZ2VTdGF0aWNDb3N0ID0gMC4wO1xuXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgbnVtU2FtcGxlczsgaSsrKSB7XG4gICAgZmxvYXQgY29zdCA9IHNhbXBsZVN0YXRpY0Nvc3QocGF0aFNhbXBsZXNbaV0pO1xuXG4gICAgaWYgKGNvc3QgPCAwLjApIHJldHVybiBjb3N0O1xuXG4gICAgYXZlcmFnZVN0YXRpY0Nvc3QgKz0gY29zdDtcbiAgfVxuXG4gIGF2ZXJhZ2VTdGF0aWNDb3N0IC89IGZsb2F0KG51bVNhbXBsZXMpO1xuXG4gIHJldHVybiBhdmVyYWdlU3RhdGljQ29zdDtcbn1cblxuZmxvYXQgY2FsY3VsYXRlQXZlcmFnZUR5bmFtaWNDb3N0KGludCBudW1TYW1wbGVzLCBmbG9hdCBwYXRoTGVuZ3RoLCBmbG9hdCBpbml0aWFsVGltZSwgZmxvYXQgaW5pdGlhbFZlbG9jaXR5LCBmbG9hdCBhY2NlbGVyYXRpb24sIGZsb2F0IGFiYW5kb25UaHJlc2hvbGQpIHtcbiAgZmxvYXQgcyA9IDAuMDtcbiAgZmxvYXQgZHMgPSBwYXRoTGVuZ3RoIC8gZmxvYXQobnVtU2FtcGxlcyAtIDEpO1xuICBmbG9hdCBhdmVyYWdlRHluYW1pY0Nvc3QgPSAwLjA7XG4gIGZsb2F0IG1heFZlbG9jaXR5ID0gMC4wO1xuICBmbG9hdCBtYXhMYXRlcmFsQWNjZWxlcmF0aW9uID0gMC4wO1xuICBmbG9hdCBudW1TYW1wbGVzX2YgPSBmbG9hdChudW1TYW1wbGVzKTtcblxuICBmb3IgKGludCBpID0gMDsgaSA8IG51bVNhbXBsZXM7IGkrKykge1xuICAgIHZlYzQgcGF0aFNhbXBsZSA9IHBhdGhTYW1wbGVzW2ldOyAvLyB2ZWM0KHgtcG9zLCB5LXBvcywgdGhldGEgKHJvdGF0aW9uKSwga2FwcGEgKGN1cnZhdHVyZSkpXG5cbiAgICBmbG9hdCB2ZWxvY2l0eVNxID0gMi4wICogYWNjZWxlcmF0aW9uICogcyArIGluaXRpYWxWZWxvY2l0eSAqIGluaXRpYWxWZWxvY2l0eTtcbiAgICBmbG9hdCB2ZWxvY2l0eSA9IG1heChzbWFsbFYsIHNxcnQobWF4KDAuMCwgdmVsb2NpdHlTcSkpKTtcbiAgICBtYXhWZWxvY2l0eSA9IG1heChtYXhWZWxvY2l0eSwgdmVsb2NpdHkpO1xuICAgIG1heExhdGVyYWxBY2NlbGVyYXRpb24gPSBtYXgobWF4TGF0ZXJhbEFjY2VsZXJhdGlvbiwgYWJzKHBhdGhTYW1wbGUudyAqIHZlbG9jaXR5ICogdmVsb2NpdHkpKTtcblxuICAgIGZsb2F0IHRpbWUgPSAyLjAgKiBzIC8gKGluaXRpYWxWZWxvY2l0eSArIHZlbG9jaXR5KSArIGluaXRpYWxUaW1lO1xuXG4gICAgZmxvYXQgZEN1cnYgPSBwYXRoU2FtcGxlQ3VydlJhdGVzW2ldICogdmVsb2NpdHk7XG4gICAgaWYgKGRDdXJ2ID4gZEN1cnZhdHVyZU1heCkgcmV0dXJuIC0xLjA7XG5cbiAgICBmbG9hdCBjb3N0ID0gc2FtcGxlRHluYW1pY0Nvc3QocGF0aFNhbXBsZSwgdGltZSwgdmVsb2NpdHksIGFjY2VsZXJhdGlvbik7XG4gICAgaWYgKGNvc3QgPCAwLjApIHJldHVybiBjb3N0O1xuXG4gICAgYXZlcmFnZUR5bmFtaWNDb3N0ICs9IGNvc3Q7XG4gICAgaWYgKGF2ZXJhZ2VEeW5hbWljQ29zdCAvIG51bVNhbXBsZXNfZiA+PSBhYmFuZG9uVGhyZXNob2xkKSByZXR1cm4gLTEuMDtcblxuICAgIHMgKz0gZHM7XG4gIH1cblxuICBhdmVyYWdlRHluYW1pY0Nvc3QgLz0gbnVtU2FtcGxlc19mO1xuXG4gIC8vIEFwcGx5IHNwZWVkaW5nIHBlbmFsaXR5IGlmIGFueSB2ZWxvY2l0eSBhbG9uZyB0aGUgdHJhamVjdG9yeSBpcyBvdmVyIHRoZSBzcGVlZCBsaW1pdFxuICBhdmVyYWdlRHluYW1pY0Nvc3QgKz0gc3RlcChzcGVlZExpbWl0LCBtYXhWZWxvY2l0eSkgKiBzcGVlZExpbWl0UGVuYWx0eTtcblxuICAvLyBBcHBseSBoYXJkIGFjY2VsZXJhdGlvbi9kZWNlbGVyYXRpb24gcGVuYWx0aWVzIGlmIHRoZSBhY2NlbGVyYXRpb24vZGVjZWxlcmF0aW9uIGV4Y2VlZHMgdGhlIHNvZnQgbGltaXRzXG4gIGF2ZXJhZ2VEeW5hbWljQ29zdCArPSBzdGVwKGFjY2VsZXJhdGlvblByb2ZpbGVzWzJdICsgMC4wMDAxLCBhY2NlbGVyYXRpb24pICogaGFyZEFjY2VsZXJhdGlvblBlbmFsdHk7XG4gIGF2ZXJhZ2VEeW5hbWljQ29zdCArPSAoMS4wIC0gc3RlcChhY2NlbGVyYXRpb25Qcm9maWxlc1szXSwgYWNjZWxlcmF0aW9uKSkgKiBoYXJkRGVjZWxlcmF0aW9uUGVuYWx0eTtcblxuICAvLyBQZW5hbGl6ZSBsYXRlcmFsIGFjY2VsZXJhdGlvblxuICBhdmVyYWdlRHluYW1pY0Nvc3QgKz0gc3RlcChzb2Z0TGF0ZXJhbEFjY2VsZXJhdGlvbkxpbWl0LCBtYXhMYXRlcmFsQWNjZWxlcmF0aW9uKSAqIHNvZnRMYXRlcmFsQWNjZWxlcmF0aW9uUGVuYWx0eTtcbiAgYXZlcmFnZUR5bmFtaWNDb3N0ICs9IGxpbmVhckxhdGVyYWxBY2NlbGVyYXRpb25QZW5hbHR5ICogbWF4TGF0ZXJhbEFjY2VsZXJhdGlvbjtcblxuICByZXR1cm4gYXZlcmFnZUR5bmFtaWNDb3N0O1xufVxuXG52ZWMzIGNhbGN1bGF0ZUFWVChpbnQgYWNjZWxlcmF0aW9uSW5kZXgsIGZsb2F0IGluaXRpYWxWZWxvY2l0eSwgZmxvYXQgaW5pdGlhbFRpbWUsIGZsb2F0IHBhdGhMZW5ndGgpIHtcbiAgZmxvYXQgaW5pdGlhbFZlbG9jaXR5U3EgPSBpbml0aWFsVmVsb2NpdHkgKiBpbml0aWFsVmVsb2NpdHk7XG4gIGZsb2F0IGFjY2VsZXJhdGlvbiA9IGNhbGN1bGF0ZUFjY2VsZXJhdGlvbihhY2NlbGVyYXRpb25JbmRleCwgaW5pdGlhbFZlbG9jaXR5U3EsIHBhdGhMZW5ndGgpO1xuXG4gIGZsb2F0IGZpbmFsVmVsb2NpdHlTcSA9IDIuMCAqIGFjY2VsZXJhdGlvbiAqIHBhdGhMZW5ndGggKyBpbml0aWFsVmVsb2NpdHlTcTtcbiAgZmxvYXQgZmluYWxWZWxvY2l0eSA9IG1heChzbWFsbFYsIHNxcnQobWF4KDAuMCwgZmluYWxWZWxvY2l0eVNxKSkpO1xuXG4gIGZsb2F0IGZpbmFsVGltZSA9IGluaXRpYWxUaW1lO1xuXG4gIGlmIChhY2NlbGVyYXRpb24gPT0gMC4wKSB7XG4gICAgZmluYWxUaW1lICs9IHBhdGhMZW5ndGggLyBmaW5hbFZlbG9jaXR5O1xuICB9IGVsc2UgaWYgKGZpbmFsVmVsb2NpdHlTcSA8PSAwLjApIHsgLy8gQ2FsY3VsYXRlIGZpbmFsIHRpbWUgaWYgdGhlIHZlaGljbGUgc3RvcHMgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIHRyYWplY3RvcnlcbiAgICBmbG9hdCBkaXN0YW5jZUxlZnQgPSBwYXRoTGVuZ3RoIC0gKHNtYWxsViAqIHNtYWxsViAtIGluaXRpYWxWZWxvY2l0eVNxKSAvICgyLjAgKiBhY2NlbGVyYXRpb24pO1xuICAgIGZpbmFsVGltZSArPSAoZmluYWxWZWxvY2l0eSAtIGluaXRpYWxWZWxvY2l0eSkgLyBhY2NlbGVyYXRpb24gKyBkaXN0YW5jZUxlZnQgLyBzbWFsbFY7XG4gIH0gZWxzZSB7XG4gICAgZmluYWxUaW1lICs9IDIuMCAqIHBhdGhMZW5ndGggLyAoZmluYWxWZWxvY2l0eSArIGluaXRpYWxWZWxvY2l0eSk7XG4gIH1cblxuICByZXR1cm4gdmVjMyhhY2NlbGVyYXRpb24sIGZpbmFsVmVsb2NpdHksIGZpbmFsVGltZSk7XG59XG5cbmA7XG5cbmNvbnN0IFNBTVBMRV9DVUJJQ19QQVRIX0ZOID0gYFxuXG5pbnQgc2FtcGxlQ3ViaWNQYXRoKHZlYzQgc3RhcnQsIHZlYzQgZW5kLCB2ZWM0IGN1YmljUGF0aFBhcmFtcykge1xuICBmbG9hdCBwMCA9IHN0YXJ0Lnc7XG4gIGZsb2F0IHAxID0gY3ViaWNQYXRoUGFyYW1zLng7XG4gIGZsb2F0IHAyID0gY3ViaWNQYXRoUGFyYW1zLnk7XG4gIGZsb2F0IHAzID0gZW5kLnc7XG4gIGZsb2F0IHNHID0gY3ViaWNQYXRoUGFyYW1zLno7XG5cbiAgaWYgKHNHIDw9IDAuMCkgcmV0dXJuIDA7XG5cbiAgaW50IG51bVNhbXBsZXMgPSBpbnQoY2VpbChzRyAvIHBhdGhTYW1wbGluZ1N0ZXApKSArIDE7XG5cbiAgZmxvYXQgc0dfMiA9IHNHICogc0c7XG4gIGZsb2F0IHNHXzMgPSBzR18yICogc0c7XG5cbiAgZmxvYXQgYSA9IHAwO1xuICBmbG9hdCBiID0gKC01LjUgKiBwMCArIDkuMCAqIHAxIC0gNC41ICogcDIgKyBwMykgLyBzRztcbiAgZmxvYXQgYyA9ICg5LjAgKiBwMCAtIDIyLjUgKiBwMSArIDE4LjAgKiBwMiAtIDQuNSAqIHAzKSAvIHNHXzI7XG4gIGZsb2F0IGQgPSAoLTQuNSAqIChwMCAtIDMuMCAqIHAxICsgMy4wICogcDIgLSBwMykpIC8gc0dfMztcblxuICBwYXRoU2FtcGxlc1swXSA9IHN0YXJ0O1xuXG4gIGZsb2F0IGRzID0gc0cgLyBmbG9hdChudW1TYW1wbGVzIC0gMSk7XG4gIGZsb2F0IHMgPSBkcztcbiAgdmVjMiBkeHkgPSB2ZWMyKDApO1xuICB2ZWMyIHByZXZDb3NTaW4gPSB2ZWMyKGNvcyhzdGFydC56KSwgc2luKHN0YXJ0LnopKTtcblxuICBmb3IgKGludCBpID0gMTsgaSA8IG51bVNhbXBsZXM7IGkrKykge1xuICAgIGZsb2F0IHJvdCA9ICgoKGQgKiBzIC8gNC4wICsgYyAvIDMuMCkgKiBzICsgYiAvIDIuMCkgKiBzICsgYSkgKiBzICsgc3RhcnQuejtcbiAgICBmbG9hdCBjdXJ2ID0gKChkICogcyArIGMpICogcyArIGIpICogcyArIGE7XG5cbiAgICB2ZWMyIGNvc1NpbiA9IHZlYzIoY29zKHJvdCksIHNpbihyb3QpKTtcbiAgICBkeHkgPSBkeHkgKiB2ZWMyKGZsb2F0KGkgLSAxKSAvIGZsb2F0KGkpKSArIChjb3NTaW4gKyBwcmV2Q29zU2luKSAvIHZlYzIoMiAqIGkpO1xuXG4gICAgcGF0aFNhbXBsZXNbaV0gPSB2ZWM0KGR4eSAqIHZlYzIocykgKyBzdGFydC54eSwgcm90LCBjdXJ2KTtcbiAgICBwYXRoU2FtcGxlQ3VydlJhdGVzW2ldID0gYiArIHMgKiAoMi4wICogYyArIDMuMCAqIGQgKiBzKTtcblxuICAgIHMgKz0gZHM7XG4gICAgcHJldkNvc1NpbiA9IGNvc1NpbjtcbiAgfVxuXG4gIHJldHVybiBudW1TYW1wbGVzO1xufVxuXG5gO1xuXG5jb25zdCBTQU1QTEVfUVVJTlRJQ19QQVRIX0ZOID0gYFxuXG5pbnQgc2FtcGxlUXVpbnRpY1BhdGgodmVjNCBzdGFydCwgdmVjNCBlbmQsIHZlYzQgcXVpbnRpY1BhdGhQYXJhbXMpIHtcbiAgZmxvYXQgcDAgPSBzdGFydC53O1xuICBmbG9hdCBwMSA9IGRDdXJ2VmVoaWNsZTtcbiAgZmxvYXQgcDIgPSBkZEN1cnZWZWhpY2xlO1xuICBmbG9hdCBwMyA9IHF1aW50aWNQYXRoUGFyYW1zLng7XG4gIGZsb2F0IHA0ID0gcXVpbnRpY1BhdGhQYXJhbXMueTtcbiAgZmxvYXQgcDUgPSBlbmQudztcbiAgZmxvYXQgc0cgPSBxdWludGljUGF0aFBhcmFtcy56O1xuXG4gIGlmIChzRyA8PSAwLjApIHJldHVybiAwO1xuXG4gIGludCBudW1TYW1wbGVzID0gaW50KGNlaWwoc0cgLyBwYXRoU2FtcGxpbmdTdGVwKSkgKyAxO1xuXG4gIGZsb2F0IHNHXzIgPSBzRyAqIHNHO1xuICBmbG9hdCBzR18zID0gc0dfMiAqIHNHO1xuXG4gIGZsb2F0IGEgPSBwMDtcbiAgZmxvYXQgYiA9IHAxO1xuICBmbG9hdCBjID0gcDIgLyAyLjA7XG4gIGZsb2F0IGQgPSAoLTcxLjg3NSAqIHAwICsgODEuMCAqIHAzIC0gMTAuMTI1ICogcDQgKyBwNSAtIDIxLjI1ICogcDEgKiBzRyAtIDIuNzUgKiBwMiAqIHNHXzIpIC8gc0dfMztcbiAgZmxvYXQgZSA9ICgxNjYuNSAqIHAwIC0gMjAyLjUgKiBwMyArIDQwLjUgKiBwNCAtIDQuNSAqIHA1ICsgNDUuMCAqIHAxICogc0cgKyA0LjUgKiBwMiAqIHNHXzIpIC8gKHNHXzIgKiBzR18yKTtcbiAgZmxvYXQgZiA9ICgtOTUuNjI1ICogcDAgKyAxMjEuNSAqIHAzIC0gMzAuMzc1ICogcDQgKyA0LjUgKiBwNSAtIDI0Ljc1ICogcDEgKiBzRyAtIDIuMjUgKiBwMiAqIHNHXzIpIC8gKHNHXzIgKiBzR18zKTtcblxuICBwYXRoU2FtcGxlc1swXSA9IHN0YXJ0O1xuXG4gIGZsb2F0IGRzID0gc0cgLyBmbG9hdChudW1TYW1wbGVzIC0gMSk7XG4gIGZsb2F0IHMgPSBkcztcbiAgdmVjMiBkeHkgPSB2ZWMyKDApO1xuICB2ZWMyIHByZXZDb3NTaW4gPSB2ZWMyKGNvcyhzdGFydC56KSwgc2luKHN0YXJ0LnopKTtcblxuICBmb3IgKGludCBpID0gMTsgaSA8IG51bVNhbXBsZXM7IGkrKykge1xuICAgIGZsb2F0IHJvdCA9ICgoKCgoZiAqIHMgLyA2LjAgKyBlIC8gNS4wKSAqIHMgKyBkIC8gNC4wKSAqIHMgKyBjIC8gMy4wKSAqIHMgKyBiIC8gMi4wKSAqIHMgKyBhKSAqIHMgKyBzdGFydC56O1xuICAgIGZsb2F0IGN1cnYgPSAoKCgoZiAqIHMgKyBlKSAqIHMgKyBkKSAqIHMgKyBjKSAqIHMgKyBiKSAqIHMgKyBhO1xuXG4gICAgdmVjMiBjb3NTaW4gPSB2ZWMyKGNvcyhyb3QpLCBzaW4ocm90KSk7XG4gICAgZHh5ID0gZHh5ICogdmVjMihmbG9hdChpIC0gMSkgLyBmbG9hdChpKSkgKyAoY29zU2luICsgcHJldkNvc1NpbikgLyB2ZWMyKDIgKiBpKTtcblxuICAgIHBhdGhTYW1wbGVzW2ldID0gdmVjNChkeHkgKiB2ZWMyKHMpICsgc3RhcnQueHksIHJvdCwgY3Vydik7XG4gICAgcGF0aFNhbXBsZUN1cnZSYXRlc1tpXSA9IGIgKyBzICogKDIuMCAqIGMgKyBzICogKDMuMCAqIGQgKyBzICogKDQuMCAqIGUgKyA1LjAgKiBmICogcykpKTtcblxuICAgIHMgKz0gZHM7XG4gICAgcHJldkNvc1NpbiA9IGNvc1NpbjtcbiAgfVxuXG4gIHJldHVybiBudW1TYW1wbGVzO1xufVxuXG5gO1xuXG5jb25zdCBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTID0gODtcbmNvbnN0IE5VTV9WRUxPQ0lUWV9SQU5HRVMgPSA0O1xuY29uc3QgTlVNX1RJTUVfUkFOR0VTID0gMjtcblxuY29uc3QgU0hBUkVEX1VOSUZPUk1TID0ge1xuICB4eXNsTWFwOiB7IHR5cGU6ICdvdXRwdXRUZXh0dXJlJyB9LFxuICBzbE9ic3RhY2xlR3JpZDogeyB0eXBlOiAnb3V0cHV0VGV4dHVyZScsIG5hbWU6ICdzbE9ic3RhY2xlR3JpZERpbGF0ZWQnIH0sXG4gIHNsRHluYW1pY09ic3RhY2xlR3JpZDogeyB0eXBlOiAnb3V0cHV0VGV4dHVyZScsIG5hbWU6ICdzbER5bmFtaWNPYnN0YWNsZUdyaWQnLCB0ZXh0dXJlVHlwZTogJzJEQXJyYXknIH0sXG4gIGFjY2VsZXJhdGlvblByb2ZpbGVzOiB7IHR5cGU6ICdmbG9hdCcsIGxlbmd0aDogNSB9LFxuICBmaW5hbFZlbG9jaXR5UHJvZmlsZXM6IHsgdHlwZTogJ2Zsb2F0JywgbGVuZ3RoOiAzIH0sXG4gIHh5Q2VudGVyUG9pbnQ6IHsgdHlwZTogJ3ZlYzInIH0sXG4gIHh5R3JpZENlbGxTaXplOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgc2xDZW50ZXJQb2ludDogeyB0eXBlOiAndmVjMicgfSxcbiAgc2xHcmlkQ2VsbFNpemU6IHsgdHlwZTogJ2Zsb2F0J30sXG4gIGxhbmVDZW50ZXJMYXRpdHVkZTogeyB0eXBlOiAnZmxvYXQnfSxcbiAgbGFuZVNob3VsZGVyTGF0aXR1ZGU6IHsgdHlwZTogJ2Zsb2F0J30sXG4gIGxhbmVDb3N0U2xvcGU6IHsgdHlwZTogJ2Zsb2F0J30sXG4gIGxhbmVQcmVmZXJlbmNlOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgbGFuZVByZWZlcmVuY2VEaXNjb3VudDogeyB0eXBlOiAnZmxvYXQnIH0sXG4gIG9ic3RhY2xlSGF6YXJkQ29zdDogeyB0eXBlOiAnZmxvYXQnIH0sXG4gIHNwZWVkTGltaXQ6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICBzcGVlZExpbWl0UGVuYWx0eTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gIGhhcmRBY2NlbGVyYXRpb25QZW5hbHR5OiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgaGFyZERlY2VsZXJhdGlvblBlbmFsdHk6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICBzb2Z0TGF0ZXJhbEFjY2VsZXJhdGlvbkxpbWl0OiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgc29mdExhdGVyYWxBY2NlbGVyYXRpb25QZW5hbHR5OiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgbGluZWFyTGF0ZXJhbEFjY2VsZXJhdGlvblBlbmFsdHk6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICBkQ3VydmF0dXJlTWF4OiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgcGF0aFNhbXBsaW5nU3RlcDogeyB0eXBlOiAnZmxvYXQnIH0sXG4gIHJlYXJBeGxlVG9DZW50ZXI6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICBkeW5hbWljRnJhbWVUaW1lOiB7IHR5cGU6ICdmbG9hdCcgfVxufTtcblxuZnVuY3Rpb24gYnVpbGRVbmlmb3JtVmFsdWVzKGNvbmZpZywgeHlDZW50ZXJQb2ludCwgc2xDZW50ZXJQb2ludCwgZHluYW1pY0ZyYW1lVGltZSkge1xuICByZXR1cm4ge1xuICAgIGFjY2VsZXJhdGlvblByb2ZpbGVzOiBbMy41LCAtNi41LCAyLjAsIC0zLjAsIDBdLFxuICAgIGZpbmFsVmVsb2NpdHlQcm9maWxlczogWzAuOTk5ICogY29uZmlnLnNwZWVkTGltaXQsIDEuMCwgMC4wMV0sXG4gICAgeHlDZW50ZXJQb2ludDogW3h5Q2VudGVyUG9pbnQueCwgeHlDZW50ZXJQb2ludC55XSxcbiAgICB4eUdyaWRDZWxsU2l6ZTogY29uZmlnLnh5R3JpZENlbGxTaXplLFxuICAgIHNsQ2VudGVyUG9pbnQ6IFtzbENlbnRlclBvaW50LngsIHNsQ2VudGVyUG9pbnQueV0sXG4gICAgc2xHcmlkQ2VsbFNpemU6IGNvbmZpZy5zbEdyaWRDZWxsU2l6ZSxcbiAgICBsYW5lQ2VudGVyTGF0aXR1ZGU6IGNvbmZpZy5sYW5lQ2VudGVyTGF0aXR1ZGUsXG4gICAgbGFuZVNob3VsZGVyTGF0aXR1ZGU6IGNvbmZpZy5sYW5lU2hvdWxkZXJMYXRpdHVkZSxcbiAgICBsYW5lQ29zdFNsb3BlOiBjb25maWcubGFuZUNvc3RTbG9wZSxcbiAgICBsYW5lUHJlZmVyZW5jZTogY29uZmlnLmxhbmVQcmVmZXJlbmNlLFxuICAgIGxhbmVQcmVmZXJlbmNlRGlzY291bnQ6IGNvbmZpZy5sYW5lUHJlZmVyZW5jZURpc2NvdW50LFxuICAgIG9ic3RhY2xlSGF6YXJkQ29zdDogY29uZmlnLm9ic3RhY2xlSGF6YXJkQ29zdCxcbiAgICBzcGVlZExpbWl0OiBjb25maWcuc3BlZWRMaW1pdCxcbiAgICBzcGVlZExpbWl0UGVuYWx0eTogY29uZmlnLnNwZWVkTGltaXRQZW5hbHR5LFxuICAgIGhhcmRBY2NlbGVyYXRpb25QZW5hbHR5OiBjb25maWcuaGFyZEFjY2VsZXJhdGlvblBlbmFsdHksXG4gICAgaGFyZERlY2VsZXJhdGlvblBlbmFsdHk6IGNvbmZpZy5oYXJkRGVjZWxlcmF0aW9uUGVuYWx0eSxcbiAgICBzb2Z0TGF0ZXJhbEFjY2VsZXJhdGlvbkxpbWl0OiBjb25maWcuc29mdExhdGVyYWxBY2NlbGVyYXRpb25MaW1pdCxcbiAgICBzb2Z0TGF0ZXJhbEFjY2VsZXJhdGlvblBlbmFsdHk6IGNvbmZpZy5zb2Z0TGF0ZXJhbEFjY2VsZXJhdGlvblBlbmFsdHksXG4gICAgbGluZWFyTGF0ZXJhbEFjY2VsZXJhdGlvblBlbmFsdHk6IGNvbmZpZy5saW5lYXJMYXRlcmFsQWNjZWxlcmF0aW9uUGVuYWx0eSxcbiAgICBkQ3VydmF0dXJlTWF4OiBjb25maWcuZEN1cnZhdHVyZU1heCxcbiAgICBwYXRoU2FtcGxpbmdTdGVwOiBjb25maWcucGF0aFNhbXBsaW5nU3RlcCxcbiAgICByZWFyQXhsZVRvQ2VudGVyOiBjb25maWcucmVhckF4bGVUb0NlbnRlcixcbiAgICBkeW5hbWljRnJhbWVUaW1lOiBkeW5hbWljRnJhbWVUaW1lXG4gIH07XG59XG5cbmV4cG9ydCB7XG4gIFNIQVJFRF9TSEFERVIsXG4gIFNBTVBMRV9DVUJJQ19QQVRIX0ZOLFxuICBTQU1QTEVfUVVJTlRJQ19QQVRIX0ZOLFxuXG4gIE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMsXG4gIE5VTV9WRUxPQ0lUWV9SQU5HRVMsXG4gIE5VTV9USU1FX1JBTkdFUyxcblxuICBTSEFSRURfVU5JRk9STVMsXG4gIGJ1aWxkVW5pZm9ybVZhbHVlc1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/autonomy/path-planning/gpgpu-programs/graphSearchShared.js\n");

/***/ }),

/***/ "./js/autonomy/path-planning/gpgpu-programs/optimizeCubicPaths.js":
/*!************************************************************************!*\
  !*** ./js/autonomy/path-planning/gpgpu-programs/optimizeCubicPaths.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// Config:\n// num stations\n// num latitudes\n// station connectivity\n// latitude connectivity\n//\n// Shared:\n// lattice\n\nconst OPTIMIZE_CUBIC_SHARED = `\n\nconst int NEWTON_ITERATIONS = 16;\nconst int RELAXATION_ITERATIONS = 16;\nconst float CONVERGENCE_ERROR = 0.01;\n\n// These two consts must stay in sync.\nconst int SIMPSONS_INTERVALS = 8;\n//const float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TWO_PI = PI + PI;\n\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\n\nfloat wrapAngle(float angle) {\n  angle = mod(angle, TWO_PI);\n  if (angle <= -PI) return angle + TWO_PI;\n  else if (angle > PI) return angle - TWO_PI;\n  return angle;\n}\n\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float sG) {\n  float ds = sG / SIMPSONS_INTERVALS_F;\n  float sG_2 = sG * sG;\n  float sG_3 = sG_2 * sG;\n\n  vec3 dX_p = vec3(0.0);\n  vec3 dY_p = vec3(0.0);\n  vec2 guess = vec2(0.0);\n  float s = 0.0;\n\n  float theta, cosTheta, sinTheta;\n  vec3 dT_p;\n\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\n    float coeff = SIMPSONS_COEFFS[i];\n\n    float a = p0;\n    float b = (-5.5 * p0 + 9.0 * p1 - 4.5 * p2 + p3) / sG;\n    float c = (9.0 * p0 - 22.5 * p1 + 18.0 * p2 - 4.5 * p3) / sG_2;\n    float d = (-4.5 * (p0 - 3.0 * p1 + 3.0 * p2 - p3)) / sG_3;\n\n    theta = (((d * s / 4.0 + c / 3.0) * s + b / 2.0) * s + a) * s;\n    cosTheta = cos(theta);\n    sinTheta = sin(theta);\n\n    float s_sG = s / sG;\n\n    dT_p = vec3(\n      // p1\n      ((3.375 * s_sG - 7.5) * s_sG + 4.5) * s_sG * s,\n\n      // p2\n      ((-3.375 * s_sG + 6.0) * s_sG - 2.25) * s_sG * s,\n\n      // sG\n      ((3.375 * (p0 - 3.0 * p1 + 3.0 * p2 - p3) * s_sG - 3.0 * (2.0 * p0 - 5.0 * p1 + 4.0 * p2 - p3)) * s_sG + 0.25 * (11.0 * p0 - 18.0 * p1 + 9.0 * p2 - 2.0 * p3)) * s_sG * s_sG\n    );\n\n    dX_p -= coeff * sinTheta * dT_p;\n    dY_p += coeff * cosTheta * dT_p;\n\n    guess += coeff * vec2(cosTheta, sinTheta);\n\n    s += ds;\n  }\n\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\n\n  vec3 delta;\n  delta.xy = goal.xy - guess * hOver3;\n  delta.z = wrapAngle(goal.z - theta);\n\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\n    return vec4(p1, p2, sG, 1.0);\n\n  dX_p.xyz *= hOver3;\n  dY_p.xyz *= hOver3;\n  dX_p.z += cosTheta;\n  dY_p.z += sinTheta;\n\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\n\n  vec3 deltaP = invJacobian * delta;\n  vec4 params = vec4(p1, p2, sG, 0.0);\n  params.xyz += deltaP;\n\n  return params;\n}\n\n/* Input:\n *   start: (vec4)\n *     x: x position,\n *     y: y position,\n *     z: theta rotation,\n *     w: k curvature\n *   end: (vec4)\n *     x: x position,\n *     y: y position,\n *     z: theta rotation,\n *     w: k curvature\n *\n * Output: (vec4)\n *   x: p1,\n *   y: p2,\n *   z: sG,\n *   w: 1 if converged, 0 if not\n */\n\nvec4 optimize(vec4 start, vec4 end) {\n  // Translate and rotate start and end so that start is at the origin\n  float sinRot = sin(start.z);\n  float cosRot = cos(start.z);\n\n  vec4 diff = end - start;\n  vec4 goal;\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\n  goal.z = wrapAngle(diff.z);\n  goal.w = end.w;\n\n  vec4 originalGoal = goal;\n  vec4 dGoal;\n  dGoal.x = 0.0;\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\n  float dK0 = start.w / RELAXATION_ITERATIONS_F;\n\n  // Relax the goal to (x, 0, 0, 0)\n  goal.yzw = vec3(0, 0, 0);\n\n  // Relax the params to (0, 0, 0, 0, goal.x)\n  float p0 = 0.0;\n  float p1 = 0.0;\n  float p2 = 0.0;\n  float p3 = 0.0;\n  float sG = goal.x;\n\n  if (sG < 0.1) return vec4(0.0);\n\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\n    p0 += dK0;\n    p3 += dGoal.w;\n    goal += dGoal;\n    \n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\n    p1 = result.x;\n    p2 = result.y;\n    sG = result.z;\n  }\n\n  goal = originalGoal;\n\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\n    vec4 result = iterate(goal, p0, p1, p2, p3, sG);\n    if (result.w == 1.0) {\n      result.w = step(0.0, result.z);\n      return result;\n    }\n\n    p1 = result.x;\n    p2 = result.y;\n    sG = result.z;\n  }\n\n  return vec4(p1, p2, sG, 0.0);\n}\n\n`;\n\nconst OPTIMIZE_CUBIC_KERNEL = OPTIMIZE_CUBIC_SHARED + `\n\n// width: station * latitude index\n// height: station_conn * lattice_conn\n//\n// lattice:\n// width: latitudes\n// height: stations\n\nvec4 kernel() {\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  int endStation = indexes.x / numLatitudes;\n  int endLatitude = int(mod(float(indexes.x), float(numLatitudes)));\n\n  int startStation = endStation - stationConnectivity + indexes.y / latitudeConnectivity;\n  int startLatitude = endLatitude - latitudeConnectivity / 2 + int(mod(float(indexes.y), float(latitudeConnectivity)));\n\n  if (startStation < 0 || startStation >= numStations || startLatitude < 0 || startLatitude >= numLatitudes)\n    return vec4(0.0);\n\n  vec4 start = texelFetch(lattice, ivec2(startLatitude, startStation), 0);\n  vec4 end = texelFetch(lattice, ivec2(endLatitude, endStation), 0);\n\n  return optimize(start, end);\n}\n\n`;\n\nconst OPTIMIZE_CUBIC_FROM_VEHICLE_KERNEL = OPTIMIZE_CUBIC_SHARED + `\n\nvec4 kernel() {\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  vec4 start = vec4(0, 0, 0, curvVehicle);\n  vec4 end = texelFetch(lattice, indexes, 0);\n\n  return optimize(start, end);\n}\n\n`;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  setUp() {\n    return [\n      { // Cubic paths between lattice nodes\n        kernel: OPTIMIZE_CUBIC_KERNEL,\n        output: { name: 'cubicPaths', read: true },\n        uniforms: {\n          lattice: { type: 'sharedTexture' },\n          numStations: { type: 'int' },\n          numLatitudes: { type: 'int' },\n          stationConnectivity: { type: 'int' },\n          latitudeConnectivity: { type: 'int' }\n        }\n      },\n      { // Cubic paths from vehicle to lattice nodes\n        kernel: OPTIMIZE_CUBIC_FROM_VEHICLE_KERNEL,\n        output: { name: 'cubicPathsFromVehicle', read: true },\n        uniforms: {\n          lattice: { type: 'sharedTexture' },\n          curvVehicle: { type: 'float' }\n        }\n      }\n    ]\n  },\n\n  update(config, pose) {\n    return [\n      { // Cubic paths between lattice nodes\n        width: config.lattice.numStations * config.lattice.numLatitudes,\n        height: config.lattice.stationConnectivity * config.lattice.latitudeConnectivity,\n        uniforms: {\n          numStations: config.lattice.numStations,\n          numLatitudes: config.lattice.numLatitudes,\n          stationConnectivity: config.lattice.stationConnectivity,\n          latitudeConnectivity: config.lattice.latitudeConnectivity,\n        }\n      },\n      { // Cubic paths from vehicle to lattice nodes\n        width: config.lattice.numLatitudes,\n        height: config.lattice.stationConnectivity,\n        uniforms: {\n          curvVehicle: pose.curv\n        }\n      }\n    ];\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL29wdGltaXplQ3ViaWNQYXRocy5qcz8xNTNkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQix5QkFBeUI7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxpQkFBaUIsaUNBQWlDO0FBQ2xEO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1Qyx3QkFBd0IsY0FBYztBQUN0Qyx5QkFBeUIsY0FBYztBQUN2QyxnQ0FBZ0MsY0FBYztBQUM5QyxpQ0FBaUM7QUFDakM7QUFDQSxPQUFPO0FBQ1AsT0FBTztBQUNQO0FBQ0EsaUJBQWlCLDRDQUE0QztBQUM3RDtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUMsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL29wdGltaXplQ3ViaWNQYXRocy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvbmZpZzpcbi8vIG51bSBzdGF0aW9uc1xuLy8gbnVtIGxhdGl0dWRlc1xuLy8gc3RhdGlvbiBjb25uZWN0aXZpdHlcbi8vIGxhdGl0dWRlIGNvbm5lY3Rpdml0eVxuLy9cbi8vIFNoYXJlZDpcbi8vIGxhdHRpY2VcblxuY29uc3QgT1BUSU1JWkVfQ1VCSUNfU0hBUkVEID0gYFxuXG5jb25zdCBpbnQgTkVXVE9OX0lURVJBVElPTlMgPSAxNjtcbmNvbnN0IGludCBSRUxBWEFUSU9OX0lURVJBVElPTlMgPSAxNjtcbmNvbnN0IGZsb2F0IENPTlZFUkdFTkNFX0VSUk9SID0gMC4wMTtcblxuLy8gVGhlc2UgdHdvIGNvbnN0cyBtdXN0IHN0YXkgaW4gc3luYy5cbmNvbnN0IGludCBTSU1QU09OU19JTlRFUlZBTFMgPSA4O1xuLy9jb25zdCBmbG9hdCBTSU1QU09OU19DT0VGRlNbU0lNUFNPTlNfSU5URVJWQUxTICsgMV0gPSBmbG9hdFtdKDEuMCwgNC4wLCAyLjAsIDQuMCwgMi4wLCA0LjAsIDIuMCwgNC4wLCAyLjAsIDQuMCwgMi4wLCA0LjAsIDIuMCwgNC4wLCAyLjAsIDQuMCwgMS4wKTtcbmNvbnN0IGZsb2F0IFNJTVBTT05TX0NPRUZGU1tTSU1QU09OU19JTlRFUlZBTFMgKyAxXSA9IGZsb2F0W10oMS4wLCA0LjAsIDIuMCwgNC4wLCAyLjAsIDQuMCwgMi4wLCA0LjAsIDEuMCk7XG5cbmNvbnN0IGZsb2F0IFBJID0gMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1O1xuY29uc3QgZmxvYXQgVFdPX1BJID0gUEkgKyBQSTtcblxuY29uc3QgZmxvYXQgUkVMQVhBVElPTl9JVEVSQVRJT05TX0YgPSBmbG9hdChSRUxBWEFUSU9OX0lURVJBVElPTlMpO1xuY29uc3QgZmxvYXQgU0lNUFNPTlNfSU5URVJWQUxTX0YgPSBmbG9hdChTSU1QU09OU19JTlRFUlZBTFMpO1xuXG5mbG9hdCB3cmFwQW5nbGUoZmxvYXQgYW5nbGUpIHtcbiAgYW5nbGUgPSBtb2QoYW5nbGUsIFRXT19QSSk7XG4gIGlmIChhbmdsZSA8PSAtUEkpIHJldHVybiBhbmdsZSArIFRXT19QSTtcbiAgZWxzZSBpZiAoYW5nbGUgPiBQSSkgcmV0dXJuIGFuZ2xlIC0gVFdPX1BJO1xuICByZXR1cm4gYW5nbGU7XG59XG5cbnZlYzQgaXRlcmF0ZSh2ZWM0IGdvYWwsIGZsb2F0IHAwLCBmbG9hdCBwMSwgZmxvYXQgcDIsIGZsb2F0IHAzLCBmbG9hdCBzRykge1xuICBmbG9hdCBkcyA9IHNHIC8gU0lNUFNPTlNfSU5URVJWQUxTX0Y7XG4gIGZsb2F0IHNHXzIgPSBzRyAqIHNHO1xuICBmbG9hdCBzR18zID0gc0dfMiAqIHNHO1xuXG4gIHZlYzMgZFhfcCA9IHZlYzMoMC4wKTtcbiAgdmVjMyBkWV9wID0gdmVjMygwLjApO1xuICB2ZWMyIGd1ZXNzID0gdmVjMigwLjApO1xuICBmbG9hdCBzID0gMC4wO1xuXG4gIGZsb2F0IHRoZXRhLCBjb3NUaGV0YSwgc2luVGhldGE7XG4gIHZlYzMgZFRfcDtcblxuICBmb3IgKGludCBpID0gMDsgaSA8PSBTSU1QU09OU19JTlRFUlZBTFM7IGkrKykge1xuICAgIGZsb2F0IGNvZWZmID0gU0lNUFNPTlNfQ09FRkZTW2ldO1xuXG4gICAgZmxvYXQgYSA9IHAwO1xuICAgIGZsb2F0IGIgPSAoLTUuNSAqIHAwICsgOS4wICogcDEgLSA0LjUgKiBwMiArIHAzKSAvIHNHO1xuICAgIGZsb2F0IGMgPSAoOS4wICogcDAgLSAyMi41ICogcDEgKyAxOC4wICogcDIgLSA0LjUgKiBwMykgLyBzR18yO1xuICAgIGZsb2F0IGQgPSAoLTQuNSAqIChwMCAtIDMuMCAqIHAxICsgMy4wICogcDIgLSBwMykpIC8gc0dfMztcblxuICAgIHRoZXRhID0gKCgoZCAqIHMgLyA0LjAgKyBjIC8gMy4wKSAqIHMgKyBiIC8gMi4wKSAqIHMgKyBhKSAqIHM7XG4gICAgY29zVGhldGEgPSBjb3ModGhldGEpO1xuICAgIHNpblRoZXRhID0gc2luKHRoZXRhKTtcblxuICAgIGZsb2F0IHNfc0cgPSBzIC8gc0c7XG5cbiAgICBkVF9wID0gdmVjMyhcbiAgICAgIC8vIHAxXG4gICAgICAoKDMuMzc1ICogc19zRyAtIDcuNSkgKiBzX3NHICsgNC41KSAqIHNfc0cgKiBzLFxuXG4gICAgICAvLyBwMlxuICAgICAgKCgtMy4zNzUgKiBzX3NHICsgNi4wKSAqIHNfc0cgLSAyLjI1KSAqIHNfc0cgKiBzLFxuXG4gICAgICAvLyBzR1xuICAgICAgKCgzLjM3NSAqIChwMCAtIDMuMCAqIHAxICsgMy4wICogcDIgLSBwMykgKiBzX3NHIC0gMy4wICogKDIuMCAqIHAwIC0gNS4wICogcDEgKyA0LjAgKiBwMiAtIHAzKSkgKiBzX3NHICsgMC4yNSAqICgxMS4wICogcDAgLSAxOC4wICogcDEgKyA5LjAgKiBwMiAtIDIuMCAqIHAzKSkgKiBzX3NHICogc19zR1xuICAgICk7XG5cbiAgICBkWF9wIC09IGNvZWZmICogc2luVGhldGEgKiBkVF9wO1xuICAgIGRZX3AgKz0gY29lZmYgKiBjb3NUaGV0YSAqIGRUX3A7XG5cbiAgICBndWVzcyArPSBjb2VmZiAqIHZlYzIoY29zVGhldGEsIHNpblRoZXRhKTtcblxuICAgIHMgKz0gZHM7XG4gIH1cblxuICBmbG9hdCBoT3ZlcjMgPSBzRyAvIFNJTVBTT05TX0lOVEVSVkFMU19GIC8gMy4wO1xuXG4gIHZlYzMgZGVsdGE7XG4gIGRlbHRhLnh5ID0gZ29hbC54eSAtIGd1ZXNzICogaE92ZXIzO1xuICBkZWx0YS56ID0gd3JhcEFuZ2xlKGdvYWwueiAtIHRoZXRhKTtcblxuICBpZiAoYWJzKGRlbHRhLngpICsgYWJzKGRlbHRhLnkpICsgYWJzKGRlbHRhLnopIDwgQ09OVkVSR0VOQ0VfRVJST1IpXG4gICAgcmV0dXJuIHZlYzQocDEsIHAyLCBzRywgMS4wKTtcblxuICBkWF9wLnh5eiAqPSBoT3ZlcjM7XG4gIGRZX3AueHl6ICo9IGhPdmVyMztcbiAgZFhfcC56ICs9IGNvc1RoZXRhO1xuICBkWV9wLnogKz0gc2luVGhldGE7XG5cbiAgbWF0MyBpbnZKYWNvYmlhbiA9IGludmVyc2UodHJhbnNwb3NlKG1hdDMoZFhfcCwgZFlfcCwgZFRfcCkpKTtcblxuICB2ZWMzIGRlbHRhUCA9IGludkphY29iaWFuICogZGVsdGE7XG4gIHZlYzQgcGFyYW1zID0gdmVjNChwMSwgcDIsIHNHLCAwLjApO1xuICBwYXJhbXMueHl6ICs9IGRlbHRhUDtcblxuICByZXR1cm4gcGFyYW1zO1xufVxuXG4vKiBJbnB1dDpcbiAqICAgc3RhcnQ6ICh2ZWM0KVxuICogICAgIHg6IHggcG9zaXRpb24sXG4gKiAgICAgeTogeSBwb3NpdGlvbixcbiAqICAgICB6OiB0aGV0YSByb3RhdGlvbixcbiAqICAgICB3OiBrIGN1cnZhdHVyZVxuICogICBlbmQ6ICh2ZWM0KVxuICogICAgIHg6IHggcG9zaXRpb24sXG4gKiAgICAgeTogeSBwb3NpdGlvbixcbiAqICAgICB6OiB0aGV0YSByb3RhdGlvbixcbiAqICAgICB3OiBrIGN1cnZhdHVyZVxuICpcbiAqIE91dHB1dDogKHZlYzQpXG4gKiAgIHg6IHAxLFxuICogICB5OiBwMixcbiAqICAgejogc0csXG4gKiAgIHc6IDEgaWYgY29udmVyZ2VkLCAwIGlmIG5vdFxuICovXG5cbnZlYzQgb3B0aW1pemUodmVjNCBzdGFydCwgdmVjNCBlbmQpIHtcbiAgLy8gVHJhbnNsYXRlIGFuZCByb3RhdGUgc3RhcnQgYW5kIGVuZCBzbyB0aGF0IHN0YXJ0IGlzIGF0IHRoZSBvcmlnaW5cbiAgZmxvYXQgc2luUm90ID0gc2luKHN0YXJ0LnopO1xuICBmbG9hdCBjb3NSb3QgPSBjb3Moc3RhcnQueik7XG5cbiAgdmVjNCBkaWZmID0gZW5kIC0gc3RhcnQ7XG4gIHZlYzQgZ29hbDtcbiAgZ29hbC54eSA9IG1hdDIoY29zUm90LCAtc2luUm90LCBzaW5Sb3QsIGNvc1JvdCkgKiBkaWZmLnh5O1xuICBnb2FsLnogPSB3cmFwQW5nbGUoZGlmZi56KTtcbiAgZ29hbC53ID0gZW5kLnc7XG5cbiAgdmVjNCBvcmlnaW5hbEdvYWwgPSBnb2FsO1xuICB2ZWM0IGRHb2FsO1xuICBkR29hbC54ID0gMC4wO1xuICBkR29hbC55encgPSBnb2FsLnl6dyAvIFJFTEFYQVRJT05fSVRFUkFUSU9OU19GO1xuICBmbG9hdCBkSzAgPSBzdGFydC53IC8gUkVMQVhBVElPTl9JVEVSQVRJT05TX0Y7XG5cbiAgLy8gUmVsYXggdGhlIGdvYWwgdG8gKHgsIDAsIDAsIDApXG4gIGdvYWwueXp3ID0gdmVjMygwLCAwLCAwKTtcblxuICAvLyBSZWxheCB0aGUgcGFyYW1zIHRvICgwLCAwLCAwLCAwLCBnb2FsLngpXG4gIGZsb2F0IHAwID0gMC4wO1xuICBmbG9hdCBwMSA9IDAuMDtcbiAgZmxvYXQgcDIgPSAwLjA7XG4gIGZsb2F0IHAzID0gMC4wO1xuICBmbG9hdCBzRyA9IGdvYWwueDtcblxuICBpZiAoc0cgPCAwLjEpIHJldHVybiB2ZWM0KDAuMCk7XG5cbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBSRUxBWEFUSU9OX0lURVJBVElPTlM7IGkrKykge1xuICAgIHAwICs9IGRLMDtcbiAgICBwMyArPSBkR29hbC53O1xuICAgIGdvYWwgKz0gZEdvYWw7XG4gICAgXG4gICAgdmVjNCByZXN1bHQgPSBpdGVyYXRlKGdvYWwsIHAwLCBwMSwgcDIsIHAzLCBzRyk7XG4gICAgcDEgPSByZXN1bHQueDtcbiAgICBwMiA9IHJlc3VsdC55O1xuICAgIHNHID0gcmVzdWx0Lno7XG4gIH1cblxuICBnb2FsID0gb3JpZ2luYWxHb2FsO1xuXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgTkVXVE9OX0lURVJBVElPTlM7IGkrKykge1xuICAgIHZlYzQgcmVzdWx0ID0gaXRlcmF0ZShnb2FsLCBwMCwgcDEsIHAyLCBwMywgc0cpO1xuICAgIGlmIChyZXN1bHQudyA9PSAxLjApIHtcbiAgICAgIHJlc3VsdC53ID0gc3RlcCgwLjAsIHJlc3VsdC56KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcDEgPSByZXN1bHQueDtcbiAgICBwMiA9IHJlc3VsdC55O1xuICAgIHNHID0gcmVzdWx0Lno7XG4gIH1cblxuICByZXR1cm4gdmVjNChwMSwgcDIsIHNHLCAwLjApO1xufVxuXG5gO1xuXG5jb25zdCBPUFRJTUlaRV9DVUJJQ19LRVJORUwgPSBPUFRJTUlaRV9DVUJJQ19TSEFSRUQgKyBgXG5cbi8vIHdpZHRoOiBzdGF0aW9uICogbGF0aXR1ZGUgaW5kZXhcbi8vIGhlaWdodDogc3RhdGlvbl9jb25uICogbGF0dGljZV9jb25uXG4vL1xuLy8gbGF0dGljZTpcbi8vIHdpZHRoOiBsYXRpdHVkZXNcbi8vIGhlaWdodDogc3RhdGlvbnNcblxudmVjNCBrZXJuZWwoKSB7XG4gIGl2ZWMyIGluZGV4ZXMgPSBpdmVjMihrZXJuZWxQb3NpdGlvbiAqIHZlYzIoa2VybmVsU2l6ZSkpO1xuXG4gIGludCBlbmRTdGF0aW9uID0gaW5kZXhlcy54IC8gbnVtTGF0aXR1ZGVzO1xuICBpbnQgZW5kTGF0aXR1ZGUgPSBpbnQobW9kKGZsb2F0KGluZGV4ZXMueCksIGZsb2F0KG51bUxhdGl0dWRlcykpKTtcblxuICBpbnQgc3RhcnRTdGF0aW9uID0gZW5kU3RhdGlvbiAtIHN0YXRpb25Db25uZWN0aXZpdHkgKyBpbmRleGVzLnkgLyBsYXRpdHVkZUNvbm5lY3Rpdml0eTtcbiAgaW50IHN0YXJ0TGF0aXR1ZGUgPSBlbmRMYXRpdHVkZSAtIGxhdGl0dWRlQ29ubmVjdGl2aXR5IC8gMiArIGludChtb2QoZmxvYXQoaW5kZXhlcy55KSwgZmxvYXQobGF0aXR1ZGVDb25uZWN0aXZpdHkpKSk7XG5cbiAgaWYgKHN0YXJ0U3RhdGlvbiA8IDAgfHwgc3RhcnRTdGF0aW9uID49IG51bVN0YXRpb25zIHx8IHN0YXJ0TGF0aXR1ZGUgPCAwIHx8IHN0YXJ0TGF0aXR1ZGUgPj0gbnVtTGF0aXR1ZGVzKVxuICAgIHJldHVybiB2ZWM0KDAuMCk7XG5cbiAgdmVjNCBzdGFydCA9IHRleGVsRmV0Y2gobGF0dGljZSwgaXZlYzIoc3RhcnRMYXRpdHVkZSwgc3RhcnRTdGF0aW9uKSwgMCk7XG4gIHZlYzQgZW5kID0gdGV4ZWxGZXRjaChsYXR0aWNlLCBpdmVjMihlbmRMYXRpdHVkZSwgZW5kU3RhdGlvbiksIDApO1xuXG4gIHJldHVybiBvcHRpbWl6ZShzdGFydCwgZW5kKTtcbn1cblxuYDtcblxuY29uc3QgT1BUSU1JWkVfQ1VCSUNfRlJPTV9WRUhJQ0xFX0tFUk5FTCA9IE9QVElNSVpFX0NVQklDX1NIQVJFRCArIGBcblxudmVjNCBrZXJuZWwoKSB7XG4gIGl2ZWMyIGluZGV4ZXMgPSBpdmVjMihrZXJuZWxQb3NpdGlvbiAqIHZlYzIoa2VybmVsU2l6ZSkpO1xuXG4gIHZlYzQgc3RhcnQgPSB2ZWM0KDAsIDAsIDAsIGN1cnZWZWhpY2xlKTtcbiAgdmVjNCBlbmQgPSB0ZXhlbEZldGNoKGxhdHRpY2UsIGluZGV4ZXMsIDApO1xuXG4gIHJldHVybiBvcHRpbWl6ZShzdGFydCwgZW5kKTtcbn1cblxuYDtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBzZXRVcCgpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyAvLyBDdWJpYyBwYXRocyBiZXR3ZWVuIGxhdHRpY2Ugbm9kZXNcbiAgICAgICAga2VybmVsOiBPUFRJTUlaRV9DVUJJQ19LRVJORUwsXG4gICAgICAgIG91dHB1dDogeyBuYW1lOiAnY3ViaWNQYXRocycsIHJlYWQ6IHRydWUgfSxcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICBsYXR0aWNlOiB7IHR5cGU6ICdzaGFyZWRUZXh0dXJlJyB9LFxuICAgICAgICAgIG51bVN0YXRpb25zOiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgICAgbnVtTGF0aXR1ZGVzOiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgICAgc3RhdGlvbkNvbm5lY3Rpdml0eTogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICAgIGxhdGl0dWRlQ29ubmVjdGl2aXR5OiB7IHR5cGU6ICdpbnQnIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHsgLy8gQ3ViaWMgcGF0aHMgZnJvbSB2ZWhpY2xlIHRvIGxhdHRpY2Ugbm9kZXNcbiAgICAgICAga2VybmVsOiBPUFRJTUlaRV9DVUJJQ19GUk9NX1ZFSElDTEVfS0VSTkVMLFxuICAgICAgICBvdXRwdXQ6IHsgbmFtZTogJ2N1YmljUGF0aHNGcm9tVmVoaWNsZScsIHJlYWQ6IHRydWUgfSxcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICBsYXR0aWNlOiB7IHR5cGU6ICdzaGFyZWRUZXh0dXJlJyB9LFxuICAgICAgICAgIGN1cnZWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgXVxuICB9LFxuXG4gIHVwZGF0ZShjb25maWcsIHBvc2UpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyAvLyBDdWJpYyBwYXRocyBiZXR3ZWVuIGxhdHRpY2Ugbm9kZXNcbiAgICAgICAgd2lkdGg6IGNvbmZpZy5sYXR0aWNlLm51bVN0YXRpb25zICogY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzLFxuICAgICAgICBoZWlnaHQ6IGNvbmZpZy5sYXR0aWNlLnN0YXRpb25Db25uZWN0aXZpdHkgKiBjb25maWcubGF0dGljZS5sYXRpdHVkZUNvbm5lY3Rpdml0eSxcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICBudW1TdGF0aW9uczogY29uZmlnLmxhdHRpY2UubnVtU3RhdGlvbnMsXG4gICAgICAgICAgbnVtTGF0aXR1ZGVzOiBjb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMsXG4gICAgICAgICAgc3RhdGlvbkNvbm5lY3Rpdml0eTogY29uZmlnLmxhdHRpY2Uuc3RhdGlvbkNvbm5lY3Rpdml0eSxcbiAgICAgICAgICBsYXRpdHVkZUNvbm5lY3Rpdml0eTogY29uZmlnLmxhdHRpY2UubGF0aXR1ZGVDb25uZWN0aXZpdHksXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IC8vIEN1YmljIHBhdGhzIGZyb20gdmVoaWNsZSB0byBsYXR0aWNlIG5vZGVzXG4gICAgICAgIHdpZHRoOiBjb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMsXG4gICAgICAgIGhlaWdodDogY29uZmlnLmxhdHRpY2Uuc3RhdGlvbkNvbm5lY3Rpdml0eSxcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICBjdXJ2VmVoaWNsZTogcG9zZS5jdXJ2XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/autonomy/path-planning/gpgpu-programs/optimizeCubicPaths.js\n");

/***/ }),

/***/ "./js/autonomy/path-planning/gpgpu-programs/optimizeQuinticPaths.js":
/*!**************************************************************************!*\
  !*** ./js/autonomy/path-planning/gpgpu-programs/optimizeQuinticPaths.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst OPTIMIZE_KERNEL = `\n\nconst int NEWTON_ITERATIONS = 32;\nconst int RELAXATION_ITERATIONS = 32;\nconst float CONVERGENCE_ERROR = 0.01;\n\n// These two consts must stay in sync.\nconst int SIMPSONS_INTERVALS = 8;\nconst float SIMPSONS_COEFFS[SIMPSONS_INTERVALS + 1] = float[](1.0, 4.0, 2.0, 4.0, 2.0, 4.0, 2.0, 4.0, 1.0);\n\nconst float PI = 3.1415926535897932384626433832795;\nconst float TWO_PI = PI + PI;\n\nconst float RELAXATION_ITERATIONS_F = float(RELAXATION_ITERATIONS);\nconst float SIMPSONS_INTERVALS_F = float(SIMPSONS_INTERVALS);\n\nfloat wrapAngle(float angle) {\n  angle = mod(angle, TWO_PI);\n  if (angle <= -PI) return angle + TWO_PI;\n  else if (angle > PI) return angle - TWO_PI;\n  return angle;\n}\n\nvec4 iterate(vec4 goal, float p0, float p1, float p2, float p3, float p4, float p5, float sG) {\n  float ds = sG / SIMPSONS_INTERVALS_F;\n  float sG_2 = sG * sG;\n  float sG_3 = sG_2 * sG;\n\n  vec3 dX_p = vec3(0.0);\n  vec3 dY_p = vec3(0.0);\n  vec2 guess = vec2(0.0);\n  float s = 0.0;\n\n  float theta, cosTheta, sinTheta;\n  vec3 dT_p;\n\n  for (int i = 0; i <= SIMPSONS_INTERVALS; i++) {\n    float coeff = SIMPSONS_COEFFS[i];\n\n    float a = p0;\n    float b = p1;\n    float c = p2 / 2.0;\n    float d = (-71.875 * p0 + 81.0 * p3 - 10.125 * p4 + p5 - 21.25 * p1 * sG - 2.75 * p2 * sG_2) / sG_3;\n    float e = (166.5 * p0 - 202.5 * p3 + 40.5 * p4 - 4.5 * p5 + 45.0 * p1 * sG + 4.5 * p2 * sG_2) / (sG_2 * sG_2);\n    float f = (-95.625 * p0 + 121.5 * p3 - 30.375 * p4 + 4.5 * p5 - 24.75 * p1 * sG - 2.25 * p2 * sG_2) / (sG_2 * sG_3);\n\n    theta = (((((f * s / 6.0 + e / 5.0) * s + d / 4.0) * s + c / 3.0) * s + b / 2.0) * s + a) * s;\n    cosTheta = cos(theta);\n    sinTheta = sin(theta);\n\n    float s_2 = s * s;\n    float s_sG = s / sG;\n    float s_sG_2 = s_sG * s_sG;\n    float s_sG_3 = s_sG_2 * s_sG;\n    float s_sG_4 = s_sG_3 * s_sG;\n    float s_sG_5 = s_sG_4 * s_sG;\n\n    dT_p = vec3(\n      // p3\n      ((20.25 * s_sG - 40.5) * s_sG + 20.25) * s_sG_3 * s,\n\n      // p4\n      ((-5.0625 * s_sG + 8.1) * s_sG - 2.53125) * s_sG_3 * s,\n\n      // sG\n      (53.90625 * p0 - 60.75 * p3 + 7.59375 * p4 - 0.75 * p5) * s_sG_4 + 10.625 * p1 * s * s_sG_3 + 0.6875 * p2 * s_2 * s_sG_2 + (-133.2 * p0 + 162.0 * p3 - 32.4 * p4 + 3.6 * p5) * s_sG_5 + (-27.0) * p1 * s * s_sG_4 - 1.8 * p2 * s_2 * s_sG_3 + (79.6875 * p0 - 101.25 * p3 + 25.3125 * p4 - 3.75 * p5) * s_sG_5 * s_sG + 16.5 * p1 * s * s_sG_5 + 1.125 * p2 * s_2 * s_sG_4\n    );\n\n    dX_p -= coeff * sinTheta * dT_p;\n    dY_p += coeff * cosTheta * dT_p;\n\n    guess += coeff * vec2(cosTheta, sinTheta);\n\n    s += ds;\n  }\n\n  float hOver3 = sG / SIMPSONS_INTERVALS_F / 3.0;\n\n  vec3 delta;\n  delta.xy = goal.xy - guess * hOver3;\n  delta.z = wrapAngle(goal.z - theta);\n\n  if (abs(delta.x) + abs(delta.y) + abs(delta.z) < CONVERGENCE_ERROR)\n    return vec4(p3, p4, sG, 1.0);\n\n  dX_p.xyz *= hOver3;\n  dY_p.xyz *= hOver3;\n  dX_p.z += cosTheta;\n  dY_p.z += sinTheta;\n\n  mat3 invJacobian = inverse(transpose(mat3(dX_p, dY_p, dT_p)));\n\n  vec3 deltaP = invJacobian * delta;\n  vec4 params = vec4(p3, p4, sG, 0.0);\n  params.xyz += deltaP;\n\n  return params;\n}\n\nvec4 optimize(vec4 start, vec4 end) {\n  // Translate and rotate start and end so that start is at the origin\n  float sinRot = sin(start.z);\n  float cosRot = cos(start.z);\n\n  vec4 diff = end - start;\n  vec4 goal;\n  goal.xy = mat2(cosRot, -sinRot, sinRot, cosRot) * diff.xy;\n  goal.z = wrapAngle(diff.z);\n  goal.w = end.w;\n\n  vec4 originalGoal = goal;\n  vec4 dGoal;\n  dGoal.x = 0.0;\n  dGoal.yzw = goal.yzw / RELAXATION_ITERATIONS_F;\n  float d_K0 = start.w / RELAXATION_ITERATIONS_F;\n  float d_dK0 = dCurvVehicle / RELAXATION_ITERATIONS_F;\n  float d_ddK0 = ddCurvVehicle / RELAXATION_ITERATIONS_F;\n\n  // Relax the goal to (x, 0, 0, 0)\n  goal.yzw = vec3(0, 0, 0);\n\n  // Relax the params to (0, 0, 0, 0, goal.x)\n  float p0 = 0.0;\n  float p1 = 0.0;\n  float p2 = 0.0;\n  float p3 = 0.0;\n  float p4 = 0.0;\n  float p5 = 0.0;\n  float sG = goal.x;\n\n  if (sG < 0.1) return vec4(0.0);\n\n  for (int i = 0; i < RELAXATION_ITERATIONS; i++) {\n    p0 += d_K0;\n    p1 += d_dK0;\n    p2 += d_ddK0;\n    p5 += dGoal.w;\n    goal += dGoal;\n    \n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\n    p3 = result.x;\n    p4 = result.y;\n    sG = result.z;\n  }\n\n  goal = originalGoal;\n\n  for (int i = 0; i < NEWTON_ITERATIONS; i++) {\n    vec4 result = iterate(goal, p0, p1, p2, p3, p4, p5, sG);\n    if (result.w == 1.0) {\n      result.w = step(0.0, result.z);\n      return result;\n    }\n\n    p3 = result.x;\n    p4 = result.y;\n    sG = result.z;\n  }\n\n  return vec4(p3, p4, sG, 0.0);\n}\n\nvec4 kernel() {\n  ivec2 latticeIndexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  vec4 start = vec4(0, 0, 0, curvVehicle);\n  vec4 end = texelFetch(lattice, latticeIndexes, 0);\n\n  return optimize(start, end);\n}\n\n`;\n\n// Quintic spiral path optimizer\n//   * Start of paths is the vehicle pose\n//     * x-pos, y-pos, and rotation aren't needed, since the lattice origin is the vehicle pose\n//     * So assume position and rotation are 0\n//   * Ends of paths are all latitudes within the first (stationConnectivity) stations\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  setUp() {\n    return {\n      kernel: OPTIMIZE_KERNEL,\n      output: { name: 'quinticPathsFromVehicle', read: true },\n      uniforms: {\n        lattice: { type: 'sharedTexture' },\n        curvVehicle: { type: 'float' },\n        dCurvVehicle: { type: 'float' },\n        ddCurvVehicle: { type: 'float' }\n      }\n    };\n  },\n\n  update(config, pose) {\n    return {\n      width: config.lattice.numLatitudes,\n      height: config.lattice.stationConnectivity,\n      uniforms: {\n        curvVehicle: pose.curv,\n        dCurvVehicle: pose.dCurv,\n        ddCurvVehicle: pose.ddCurv\n      }\n    };\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL29wdGltaXplUXVpbnRpY1BhdGhzLmpzP2MwNWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIseUJBQXlCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBOEM7QUFDN0Q7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDLHNCQUFzQixnQkFBZ0I7QUFDdEMsdUJBQXVCLGdCQUFnQjtBQUN2Qyx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vanMvYXV0b25vbXkvcGF0aC1wbGFubmluZy9ncGdwdS1wcm9ncmFtcy9vcHRpbWl6ZVF1aW50aWNQYXRocy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE9QVElNSVpFX0tFUk5FTCA9IGBcblxuY29uc3QgaW50IE5FV1RPTl9JVEVSQVRJT05TID0gMzI7XG5jb25zdCBpbnQgUkVMQVhBVElPTl9JVEVSQVRJT05TID0gMzI7XG5jb25zdCBmbG9hdCBDT05WRVJHRU5DRV9FUlJPUiA9IDAuMDE7XG5cbi8vIFRoZXNlIHR3byBjb25zdHMgbXVzdCBzdGF5IGluIHN5bmMuXG5jb25zdCBpbnQgU0lNUFNPTlNfSU5URVJWQUxTID0gODtcbmNvbnN0IGZsb2F0IFNJTVBTT05TX0NPRUZGU1tTSU1QU09OU19JTlRFUlZBTFMgKyAxXSA9IGZsb2F0W10oMS4wLCA0LjAsIDIuMCwgNC4wLCAyLjAsIDQuMCwgMi4wLCA0LjAsIDEuMCk7XG5cbmNvbnN0IGZsb2F0IFBJID0gMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1O1xuY29uc3QgZmxvYXQgVFdPX1BJID0gUEkgKyBQSTtcblxuY29uc3QgZmxvYXQgUkVMQVhBVElPTl9JVEVSQVRJT05TX0YgPSBmbG9hdChSRUxBWEFUSU9OX0lURVJBVElPTlMpO1xuY29uc3QgZmxvYXQgU0lNUFNPTlNfSU5URVJWQUxTX0YgPSBmbG9hdChTSU1QU09OU19JTlRFUlZBTFMpO1xuXG5mbG9hdCB3cmFwQW5nbGUoZmxvYXQgYW5nbGUpIHtcbiAgYW5nbGUgPSBtb2QoYW5nbGUsIFRXT19QSSk7XG4gIGlmIChhbmdsZSA8PSAtUEkpIHJldHVybiBhbmdsZSArIFRXT19QSTtcbiAgZWxzZSBpZiAoYW5nbGUgPiBQSSkgcmV0dXJuIGFuZ2xlIC0gVFdPX1BJO1xuICByZXR1cm4gYW5nbGU7XG59XG5cbnZlYzQgaXRlcmF0ZSh2ZWM0IGdvYWwsIGZsb2F0IHAwLCBmbG9hdCBwMSwgZmxvYXQgcDIsIGZsb2F0IHAzLCBmbG9hdCBwNCwgZmxvYXQgcDUsIGZsb2F0IHNHKSB7XG4gIGZsb2F0IGRzID0gc0cgLyBTSU1QU09OU19JTlRFUlZBTFNfRjtcbiAgZmxvYXQgc0dfMiA9IHNHICogc0c7XG4gIGZsb2F0IHNHXzMgPSBzR18yICogc0c7XG5cbiAgdmVjMyBkWF9wID0gdmVjMygwLjApO1xuICB2ZWMzIGRZX3AgPSB2ZWMzKDAuMCk7XG4gIHZlYzIgZ3Vlc3MgPSB2ZWMyKDAuMCk7XG4gIGZsb2F0IHMgPSAwLjA7XG5cbiAgZmxvYXQgdGhldGEsIGNvc1RoZXRhLCBzaW5UaGV0YTtcbiAgdmVjMyBkVF9wO1xuXG4gIGZvciAoaW50IGkgPSAwOyBpIDw9IFNJTVBTT05TX0lOVEVSVkFMUzsgaSsrKSB7XG4gICAgZmxvYXQgY29lZmYgPSBTSU1QU09OU19DT0VGRlNbaV07XG5cbiAgICBmbG9hdCBhID0gcDA7XG4gICAgZmxvYXQgYiA9IHAxO1xuICAgIGZsb2F0IGMgPSBwMiAvIDIuMDtcbiAgICBmbG9hdCBkID0gKC03MS44NzUgKiBwMCArIDgxLjAgKiBwMyAtIDEwLjEyNSAqIHA0ICsgcDUgLSAyMS4yNSAqIHAxICogc0cgLSAyLjc1ICogcDIgKiBzR18yKSAvIHNHXzM7XG4gICAgZmxvYXQgZSA9ICgxNjYuNSAqIHAwIC0gMjAyLjUgKiBwMyArIDQwLjUgKiBwNCAtIDQuNSAqIHA1ICsgNDUuMCAqIHAxICogc0cgKyA0LjUgKiBwMiAqIHNHXzIpIC8gKHNHXzIgKiBzR18yKTtcbiAgICBmbG9hdCBmID0gKC05NS42MjUgKiBwMCArIDEyMS41ICogcDMgLSAzMC4zNzUgKiBwNCArIDQuNSAqIHA1IC0gMjQuNzUgKiBwMSAqIHNHIC0gMi4yNSAqIHAyICogc0dfMikgLyAoc0dfMiAqIHNHXzMpO1xuXG4gICAgdGhldGEgPSAoKCgoKGYgKiBzIC8gNi4wICsgZSAvIDUuMCkgKiBzICsgZCAvIDQuMCkgKiBzICsgYyAvIDMuMCkgKiBzICsgYiAvIDIuMCkgKiBzICsgYSkgKiBzO1xuICAgIGNvc1RoZXRhID0gY29zKHRoZXRhKTtcbiAgICBzaW5UaGV0YSA9IHNpbih0aGV0YSk7XG5cbiAgICBmbG9hdCBzXzIgPSBzICogcztcbiAgICBmbG9hdCBzX3NHID0gcyAvIHNHO1xuICAgIGZsb2F0IHNfc0dfMiA9IHNfc0cgKiBzX3NHO1xuICAgIGZsb2F0IHNfc0dfMyA9IHNfc0dfMiAqIHNfc0c7XG4gICAgZmxvYXQgc19zR180ID0gc19zR18zICogc19zRztcbiAgICBmbG9hdCBzX3NHXzUgPSBzX3NHXzQgKiBzX3NHO1xuXG4gICAgZFRfcCA9IHZlYzMoXG4gICAgICAvLyBwM1xuICAgICAgKCgyMC4yNSAqIHNfc0cgLSA0MC41KSAqIHNfc0cgKyAyMC4yNSkgKiBzX3NHXzMgKiBzLFxuXG4gICAgICAvLyBwNFxuICAgICAgKCgtNS4wNjI1ICogc19zRyArIDguMSkgKiBzX3NHIC0gMi41MzEyNSkgKiBzX3NHXzMgKiBzLFxuXG4gICAgICAvLyBzR1xuICAgICAgKDUzLjkwNjI1ICogcDAgLSA2MC43NSAqIHAzICsgNy41OTM3NSAqIHA0IC0gMC43NSAqIHA1KSAqIHNfc0dfNCArIDEwLjYyNSAqIHAxICogcyAqIHNfc0dfMyArIDAuNjg3NSAqIHAyICogc18yICogc19zR18yICsgKC0xMzMuMiAqIHAwICsgMTYyLjAgKiBwMyAtIDMyLjQgKiBwNCArIDMuNiAqIHA1KSAqIHNfc0dfNSArICgtMjcuMCkgKiBwMSAqIHMgKiBzX3NHXzQgLSAxLjggKiBwMiAqIHNfMiAqIHNfc0dfMyArICg3OS42ODc1ICogcDAgLSAxMDEuMjUgKiBwMyArIDI1LjMxMjUgKiBwNCAtIDMuNzUgKiBwNSkgKiBzX3NHXzUgKiBzX3NHICsgMTYuNSAqIHAxICogcyAqIHNfc0dfNSArIDEuMTI1ICogcDIgKiBzXzIgKiBzX3NHXzRcbiAgICApO1xuXG4gICAgZFhfcCAtPSBjb2VmZiAqIHNpblRoZXRhICogZFRfcDtcbiAgICBkWV9wICs9IGNvZWZmICogY29zVGhldGEgKiBkVF9wO1xuXG4gICAgZ3Vlc3MgKz0gY29lZmYgKiB2ZWMyKGNvc1RoZXRhLCBzaW5UaGV0YSk7XG5cbiAgICBzICs9IGRzO1xuICB9XG5cbiAgZmxvYXQgaE92ZXIzID0gc0cgLyBTSU1QU09OU19JTlRFUlZBTFNfRiAvIDMuMDtcblxuICB2ZWMzIGRlbHRhO1xuICBkZWx0YS54eSA9IGdvYWwueHkgLSBndWVzcyAqIGhPdmVyMztcbiAgZGVsdGEueiA9IHdyYXBBbmdsZShnb2FsLnogLSB0aGV0YSk7XG5cbiAgaWYgKGFicyhkZWx0YS54KSArIGFicyhkZWx0YS55KSArIGFicyhkZWx0YS56KSA8IENPTlZFUkdFTkNFX0VSUk9SKVxuICAgIHJldHVybiB2ZWM0KHAzLCBwNCwgc0csIDEuMCk7XG5cbiAgZFhfcC54eXogKj0gaE92ZXIzO1xuICBkWV9wLnh5eiAqPSBoT3ZlcjM7XG4gIGRYX3AueiArPSBjb3NUaGV0YTtcbiAgZFlfcC56ICs9IHNpblRoZXRhO1xuXG4gIG1hdDMgaW52SmFjb2JpYW4gPSBpbnZlcnNlKHRyYW5zcG9zZShtYXQzKGRYX3AsIGRZX3AsIGRUX3ApKSk7XG5cbiAgdmVjMyBkZWx0YVAgPSBpbnZKYWNvYmlhbiAqIGRlbHRhO1xuICB2ZWM0IHBhcmFtcyA9IHZlYzQocDMsIHA0LCBzRywgMC4wKTtcbiAgcGFyYW1zLnh5eiArPSBkZWx0YVA7XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxudmVjNCBvcHRpbWl6ZSh2ZWM0IHN0YXJ0LCB2ZWM0IGVuZCkge1xuICAvLyBUcmFuc2xhdGUgYW5kIHJvdGF0ZSBzdGFydCBhbmQgZW5kIHNvIHRoYXQgc3RhcnQgaXMgYXQgdGhlIG9yaWdpblxuICBmbG9hdCBzaW5Sb3QgPSBzaW4oc3RhcnQueik7XG4gIGZsb2F0IGNvc1JvdCA9IGNvcyhzdGFydC56KTtcblxuICB2ZWM0IGRpZmYgPSBlbmQgLSBzdGFydDtcbiAgdmVjNCBnb2FsO1xuICBnb2FsLnh5ID0gbWF0Mihjb3NSb3QsIC1zaW5Sb3QsIHNpblJvdCwgY29zUm90KSAqIGRpZmYueHk7XG4gIGdvYWwueiA9IHdyYXBBbmdsZShkaWZmLnopO1xuICBnb2FsLncgPSBlbmQudztcblxuICB2ZWM0IG9yaWdpbmFsR29hbCA9IGdvYWw7XG4gIHZlYzQgZEdvYWw7XG4gIGRHb2FsLnggPSAwLjA7XG4gIGRHb2FsLnl6dyA9IGdvYWwueXp3IC8gUkVMQVhBVElPTl9JVEVSQVRJT05TX0Y7XG4gIGZsb2F0IGRfSzAgPSBzdGFydC53IC8gUkVMQVhBVElPTl9JVEVSQVRJT05TX0Y7XG4gIGZsb2F0IGRfZEswID0gZEN1cnZWZWhpY2xlIC8gUkVMQVhBVElPTl9JVEVSQVRJT05TX0Y7XG4gIGZsb2F0IGRfZGRLMCA9IGRkQ3VydlZlaGljbGUgLyBSRUxBWEFUSU9OX0lURVJBVElPTlNfRjtcblxuICAvLyBSZWxheCB0aGUgZ29hbCB0byAoeCwgMCwgMCwgMClcbiAgZ29hbC55encgPSB2ZWMzKDAsIDAsIDApO1xuXG4gIC8vIFJlbGF4IHRoZSBwYXJhbXMgdG8gKDAsIDAsIDAsIDAsIGdvYWwueClcbiAgZmxvYXQgcDAgPSAwLjA7XG4gIGZsb2F0IHAxID0gMC4wO1xuICBmbG9hdCBwMiA9IDAuMDtcbiAgZmxvYXQgcDMgPSAwLjA7XG4gIGZsb2F0IHA0ID0gMC4wO1xuICBmbG9hdCBwNSA9IDAuMDtcbiAgZmxvYXQgc0cgPSBnb2FsLng7XG5cbiAgaWYgKHNHIDwgMC4xKSByZXR1cm4gdmVjNCgwLjApO1xuXG4gIGZvciAoaW50IGkgPSAwOyBpIDwgUkVMQVhBVElPTl9JVEVSQVRJT05TOyBpKyspIHtcbiAgICBwMCArPSBkX0swO1xuICAgIHAxICs9IGRfZEswO1xuICAgIHAyICs9IGRfZGRLMDtcbiAgICBwNSArPSBkR29hbC53O1xuICAgIGdvYWwgKz0gZEdvYWw7XG4gICAgXG4gICAgdmVjNCByZXN1bHQgPSBpdGVyYXRlKGdvYWwsIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHNHKTtcbiAgICBwMyA9IHJlc3VsdC54O1xuICAgIHA0ID0gcmVzdWx0Lnk7XG4gICAgc0cgPSByZXN1bHQuejtcbiAgfVxuXG4gIGdvYWwgPSBvcmlnaW5hbEdvYWw7XG5cbiAgZm9yIChpbnQgaSA9IDA7IGkgPCBORVdUT05fSVRFUkFUSU9OUzsgaSsrKSB7XG4gICAgdmVjNCByZXN1bHQgPSBpdGVyYXRlKGdvYWwsIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUsIHNHKTtcbiAgICBpZiAocmVzdWx0LncgPT0gMS4wKSB7XG4gICAgICByZXN1bHQudyA9IHN0ZXAoMC4wLCByZXN1bHQueik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHAzID0gcmVzdWx0Lng7XG4gICAgcDQgPSByZXN1bHQueTtcbiAgICBzRyA9IHJlc3VsdC56O1xuICB9XG5cbiAgcmV0dXJuIHZlYzQocDMsIHA0LCBzRywgMC4wKTtcbn1cblxudmVjNCBrZXJuZWwoKSB7XG4gIGl2ZWMyIGxhdHRpY2VJbmRleGVzID0gaXZlYzIoa2VybmVsUG9zaXRpb24gKiB2ZWMyKGtlcm5lbFNpemUpKTtcblxuICB2ZWM0IHN0YXJ0ID0gdmVjNCgwLCAwLCAwLCBjdXJ2VmVoaWNsZSk7XG4gIHZlYzQgZW5kID0gdGV4ZWxGZXRjaChsYXR0aWNlLCBsYXR0aWNlSW5kZXhlcywgMCk7XG5cbiAgcmV0dXJuIG9wdGltaXplKHN0YXJ0LCBlbmQpO1xufVxuXG5gO1xuXG4vLyBRdWludGljIHNwaXJhbCBwYXRoIG9wdGltaXplclxuLy8gICAqIFN0YXJ0IG9mIHBhdGhzIGlzIHRoZSB2ZWhpY2xlIHBvc2Vcbi8vICAgICAqIHgtcG9zLCB5LXBvcywgYW5kIHJvdGF0aW9uIGFyZW4ndCBuZWVkZWQsIHNpbmNlIHRoZSBsYXR0aWNlIG9yaWdpbiBpcyB0aGUgdmVoaWNsZSBwb3NlXG4vLyAgICAgKiBTbyBhc3N1bWUgcG9zaXRpb24gYW5kIHJvdGF0aW9uIGFyZSAwXG4vLyAgICogRW5kcyBvZiBwYXRocyBhcmUgYWxsIGxhdGl0dWRlcyB3aXRoaW4gdGhlIGZpcnN0IChzdGF0aW9uQ29ubmVjdGl2aXR5KSBzdGF0aW9uc1xuZXhwb3J0IGRlZmF1bHQge1xuICBzZXRVcCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2VybmVsOiBPUFRJTUlaRV9LRVJORUwsXG4gICAgICBvdXRwdXQ6IHsgbmFtZTogJ3F1aW50aWNQYXRoc0Zyb21WZWhpY2xlJywgcmVhZDogdHJ1ZSB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgbGF0dGljZTogeyB0eXBlOiAnc2hhcmVkVGV4dHVyZScgfSxcbiAgICAgICAgY3VydlZlaGljbGU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICBkQ3VydlZlaGljbGU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICBkZEN1cnZWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfVxuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlKGNvbmZpZywgcG9zZSkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogY29uZmlnLmxhdHRpY2UubnVtTGF0aXR1ZGVzLFxuICAgICAgaGVpZ2h0OiBjb25maWcubGF0dGljZS5zdGF0aW9uQ29ubmVjdGl2aXR5LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgY3VydlZlaGljbGU6IHBvc2UuY3VydixcbiAgICAgICAgZEN1cnZWZWhpY2xlOiBwb3NlLmRDdXJ2LFxuICAgICAgICBkZEN1cnZWZWhpY2xlOiBwb3NlLmRkQ3VydlxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./js/autonomy/path-planning/gpgpu-programs/optimizeQuinticPaths.js\n");

/***/ }),

/***/ "./js/autonomy/path-planning/gpgpu-programs/pathFromVehicleCosts.js":
/*!**************************************************************************!*\
  !*** ./js/autonomy/path-planning/gpgpu-programs/pathFromVehicleCosts.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graphSearchShared.js */ \"./js/autonomy/path-planning/gpgpu-programs/graphSearchShared.js\");\n\n\nfunction fromVehiclePathCostsKernel(pathType) {\n  return _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"SHARED_SHADER\"] + (pathType == 'cubic' ? _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"SAMPLE_CUBIC_PATH_FN\"] : _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"SAMPLE_QUINTIC_PATH_FN\"]) +\n\n`\n\n/* Calculate cost of a {cubic|quintic} path from vehicle to (stationConnectivity * numLatitudes * numAccelerations) nodes\n *   width: numLatitudes\n *   height: station * numAccelerations\n */\nvec4 kernel() {\n  ivec2 indexes = ivec2(kernelPosition * vec2(kernelSize));\n\n  int latitude = indexes.x;\n  int station = indexes.y / numAccelerations;\n  int accelerationIndex = int(mod(float(indexes.y), float(numAccelerations)));\n\n  vec4 pathStart = vec4(0, 0, 0, curvVehicle);\n  vec4 pathEnd = texelFetch(lattice, ivec2(latitude, station), 0);\n\n  vec4 pathParams = texelFetch(pathsFromVehicle, ivec2(latitude, station), 0);\n\n  // If the path didn't converge\n  if (pathParams.w == 0.0) return vec4(-1);\n\n  int numSamples = ${pathType == 'cubic' ? 'sampleCubicPath' : 'sampleQuinticPath'}(pathStart, pathEnd, pathParams);\n  float pathLength = pathParams.z;\n\n  if (numSamples < 2) return vec4(-1);\n\n  float averageStaticCost = calculateAverageStaticCost(numSamples);\n  if (averageStaticCost < 0.0) return vec4(-1);\n\n  int slIndex = station * kernelSize.x + latitude;\n  float hysteresisAdjustment = (slIndex == firstLatticePoint || slIndex == secondLatticePoint) ?  0.0 : hysteresisDiscount;\n  averageStaticCost += hysteresisAdjustment;\n\n  vec3 avt = calculateAVT(accelerationIndex, velocityVehicle, 0.0, pathLength);\n  float acceleration = avt.x;\n  float finalVelocity = avt.y;\n  float finalTime = avt.z;\n\n  float averageDynamicCost = calculateAverageDynamicCost(numSamples, pathLength, 0.0, velocityVehicle, acceleration, 1.0 / 0.0);\n  if (averageDynamicCost < 0.0) return vec4(-1);\n\n  averageDynamicCost += accelerationChangePenalty;\n\n  // The cost of a trajectory is the average sample cost scaled by the path length\n  float totalCost = (averageStaticCost + averageDynamicCost + ${pathType == 'cubic' ? '(cubicPathPenalty * velocityVehicle * velocityVehicle)' : '0.0'}) * pathLength;\n  ${pathType != 'cubic' ? 'totalCost = -1.0;' : ''}\n\n  return vec4(totalCost, finalVelocity, finalTime, ${pathType == 'cubic' ? '-2' : '-1'});\n}\n\n`;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  setUp() {\n    return [\n      {\n        kernel: fromVehiclePathCostsKernel('cubic'),\n        output: { name: 'cubicPathFromVehicleCosts' },\n        uniforms: Object.assign({}, _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"SHARED_UNIFORMS\"], {\n          lattice: { type: 'sharedTexture' },\n          pathsFromVehicle: { type: 'outputTexture', name: 'cubicPathsFromVehicle' },\n          firstLatticePoint: { type: 'int' },\n          secondLatticePoint: { type: 'int' },\n          velocityVehicle: { type: 'float' },\n          curvVehicle: { type: 'float' },\n          numAccelerations: { type: 'int' },\n          cubicPathPenalty: { type: 'float' },\n          hysteresisDiscount: { type: 'float' },\n          accelerationChangePenalty: { type: 'float' }\n        })\n      },\n      {\n        kernel: fromVehiclePathCostsKernel('quintic'),\n        output: { name: 'quinticPathFromVehicleCosts' },\n        uniforms: Object.assign({}, _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"SHARED_UNIFORMS\"], {\n          lattice: { type: 'sharedTexture' },\n          pathsFromVehicle: { type: 'outputTexture', name: 'quinticPathsFromVehicle' },\n          firstLatticePoint: { type: 'int' },\n          secondLatticePoint: { type: 'int' },\n          velocityVehicle: { type: 'float' },\n          curvVehicle: { type: 'float' },\n          dCurvVehicle: { type: 'float' },\n          ddCurvVehicle: { type: 'float' },\n          numAccelerations: { type: 'int' },\n          hysteresisDiscount: { type: 'float' },\n          accelerationChangePenalty: { type: 'float' }\n        })\n      }\n    ];\n  },\n\n  update(config, pose, xyCenterPoint, slCenterPoint, firstLatticePoint, secondLatticePoint, dynamicFrameTime) {\n    return [\n      {\n        width: config.lattice.numLatitudes,\n        height: config.lattice.stationConnectivity * _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"NUM_ACCELERATION_PROFILES\"],\n        uniforms: Object.assign({}, Object(_graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"buildUniformValues\"])(config, xyCenterPoint, slCenterPoint, dynamicFrameTime), {\n          firstLatticePoint: firstLatticePoint,\n          secondLatticePoint: secondLatticePoint,\n          velocityVehicle: pose.velocity,\n          curvVehicle: pose.curv,\n          numAccelerations: _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"NUM_ACCELERATION_PROFILES\"],\n          cubicPathPenalty: config.cubicPathPenalty,\n          hysteresisDiscount: config.hysteresisDiscount,\n          accelerationChangePenalty: config.accelerationChangePenalty\n        })\n      },\n      {\n        width: config.lattice.numLatitudes,\n        height: config.lattice.stationConnectivity * _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"NUM_ACCELERATION_PROFILES\"],\n        uniforms: Object.assign({}, Object(_graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"buildUniformValues\"])(config, xyCenterPoint, slCenterPoint, dynamicFrameTime), {\n          firstLatticePoint: firstLatticePoint,\n          secondLatticePoint: secondLatticePoint,\n          velocityVehicle: pose.velocity,\n          curvVehicle: pose.curv,\n          dCurvVehicle: pose.dCurv,\n          ddCurvVehicle: pose.ddCurv,\n          numAccelerations: _graphSearchShared_js__WEBPACK_IMPORTED_MODULE_0__[\"NUM_ACCELERATION_PROFILES\"],\n          hysteresisDiscount: config.hysteresisDiscount,\n          accelerationChangePenalty: config.accelerationChangePenalty\n        })\n      }\n    ];\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL3BhdGhGcm9tVmVoaWNsZUNvc3RzLmpzP2U1MGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBc0k7O0FBRXRJO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQiw4REFBOEQ7QUFDbkY7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdFQUFnRSx1RkFBdUY7QUFDdkosSUFBSSx3Q0FBd0M7O0FBRTVDLHFEQUFxRCxrQ0FBa0M7QUFDdkY7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9DQUFvQztBQUNyRCxrQ0FBa0M7QUFDbEMsb0JBQW9CLHdCQUF3QjtBQUM1Qyw2QkFBNkIsdURBQXVEO0FBQ3BGLDhCQUE4QixjQUFjO0FBQzVDLCtCQUErQixjQUFjO0FBQzdDLDRCQUE0QixnQkFBZ0I7QUFDNUMsd0JBQXdCLGdCQUFnQjtBQUN4Qyw2QkFBNkIsY0FBYztBQUMzQyw2QkFBNkIsZ0JBQWdCO0FBQzdDLCtCQUErQixnQkFBZ0I7QUFDL0Msc0NBQXNDO0FBQ3RDLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLGlCQUFpQixzQ0FBc0M7QUFDdkQsa0NBQWtDO0FBQ2xDLG9CQUFvQix3QkFBd0I7QUFDNUMsNkJBQTZCLHlEQUF5RDtBQUN0Riw4QkFBOEIsY0FBYztBQUM1QywrQkFBK0IsY0FBYztBQUM3Qyw0QkFBNEIsZ0JBQWdCO0FBQzVDLHdCQUF3QixnQkFBZ0I7QUFDeEMseUJBQXlCLGdCQUFnQjtBQUN6QywwQkFBMEIsZ0JBQWdCO0FBQzFDLDZCQUE2QixjQUFjO0FBQzNDLCtCQUErQixnQkFBZ0I7QUFDL0Msc0NBQXNDO0FBQ3RDLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL3BhdGhGcm9tVmVoaWNsZUNvc3RzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0hBUkVEX1NIQURFUiwgU0FNUExFX0NVQklDX1BBVEhfRk4sIFNBTVBMRV9RVUlOVElDX1BBVEhfRk4sIE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMsIFNIQVJFRF9VTklGT1JNUywgYnVpbGRVbmlmb3JtVmFsdWVzIH0gZnJvbSBcIi4vZ3JhcGhTZWFyY2hTaGFyZWQuanNcIjtcblxuZnVuY3Rpb24gZnJvbVZlaGljbGVQYXRoQ29zdHNLZXJuZWwocGF0aFR5cGUpIHtcbiAgcmV0dXJuIFNIQVJFRF9TSEFERVIgKyAocGF0aFR5cGUgPT0gJ2N1YmljJyA/IFNBTVBMRV9DVUJJQ19QQVRIX0ZOIDogU0FNUExFX1FVSU5USUNfUEFUSF9GTikgK1xuXG5gXG5cbi8qIENhbGN1bGF0ZSBjb3N0IG9mIGEge2N1YmljfHF1aW50aWN9IHBhdGggZnJvbSB2ZWhpY2xlIHRvIChzdGF0aW9uQ29ubmVjdGl2aXR5ICogbnVtTGF0aXR1ZGVzICogbnVtQWNjZWxlcmF0aW9ucykgbm9kZXNcbiAqICAgd2lkdGg6IG51bUxhdGl0dWRlc1xuICogICBoZWlnaHQ6IHN0YXRpb24gKiBudW1BY2NlbGVyYXRpb25zXG4gKi9cbnZlYzQga2VybmVsKCkge1xuICBpdmVjMiBpbmRleGVzID0gaXZlYzIoa2VybmVsUG9zaXRpb24gKiB2ZWMyKGtlcm5lbFNpemUpKTtcblxuICBpbnQgbGF0aXR1ZGUgPSBpbmRleGVzLng7XG4gIGludCBzdGF0aW9uID0gaW5kZXhlcy55IC8gbnVtQWNjZWxlcmF0aW9ucztcbiAgaW50IGFjY2VsZXJhdGlvbkluZGV4ID0gaW50KG1vZChmbG9hdChpbmRleGVzLnkpLCBmbG9hdChudW1BY2NlbGVyYXRpb25zKSkpO1xuXG4gIHZlYzQgcGF0aFN0YXJ0ID0gdmVjNCgwLCAwLCAwLCBjdXJ2VmVoaWNsZSk7XG4gIHZlYzQgcGF0aEVuZCA9IHRleGVsRmV0Y2gobGF0dGljZSwgaXZlYzIobGF0aXR1ZGUsIHN0YXRpb24pLCAwKTtcblxuICB2ZWM0IHBhdGhQYXJhbXMgPSB0ZXhlbEZldGNoKHBhdGhzRnJvbVZlaGljbGUsIGl2ZWMyKGxhdGl0dWRlLCBzdGF0aW9uKSwgMCk7XG5cbiAgLy8gSWYgdGhlIHBhdGggZGlkbid0IGNvbnZlcmdlXG4gIGlmIChwYXRoUGFyYW1zLncgPT0gMC4wKSByZXR1cm4gdmVjNCgtMSk7XG5cbiAgaW50IG51bVNhbXBsZXMgPSAke3BhdGhUeXBlID09ICdjdWJpYycgPyAnc2FtcGxlQ3ViaWNQYXRoJyA6ICdzYW1wbGVRdWludGljUGF0aCd9KHBhdGhTdGFydCwgcGF0aEVuZCwgcGF0aFBhcmFtcyk7XG4gIGZsb2F0IHBhdGhMZW5ndGggPSBwYXRoUGFyYW1zLno7XG5cbiAgaWYgKG51bVNhbXBsZXMgPCAyKSByZXR1cm4gdmVjNCgtMSk7XG5cbiAgZmxvYXQgYXZlcmFnZVN0YXRpY0Nvc3QgPSBjYWxjdWxhdGVBdmVyYWdlU3RhdGljQ29zdChudW1TYW1wbGVzKTtcbiAgaWYgKGF2ZXJhZ2VTdGF0aWNDb3N0IDwgMC4wKSByZXR1cm4gdmVjNCgtMSk7XG5cbiAgaW50IHNsSW5kZXggPSBzdGF0aW9uICoga2VybmVsU2l6ZS54ICsgbGF0aXR1ZGU7XG4gIGZsb2F0IGh5c3RlcmVzaXNBZGp1c3RtZW50ID0gKHNsSW5kZXggPT0gZmlyc3RMYXR0aWNlUG9pbnQgfHwgc2xJbmRleCA9PSBzZWNvbmRMYXR0aWNlUG9pbnQpID8gIDAuMCA6IGh5c3RlcmVzaXNEaXNjb3VudDtcbiAgYXZlcmFnZVN0YXRpY0Nvc3QgKz0gaHlzdGVyZXNpc0FkanVzdG1lbnQ7XG5cbiAgdmVjMyBhdnQgPSBjYWxjdWxhdGVBVlQoYWNjZWxlcmF0aW9uSW5kZXgsIHZlbG9jaXR5VmVoaWNsZSwgMC4wLCBwYXRoTGVuZ3RoKTtcbiAgZmxvYXQgYWNjZWxlcmF0aW9uID0gYXZ0Lng7XG4gIGZsb2F0IGZpbmFsVmVsb2NpdHkgPSBhdnQueTtcbiAgZmxvYXQgZmluYWxUaW1lID0gYXZ0Lno7XG5cbiAgZmxvYXQgYXZlcmFnZUR5bmFtaWNDb3N0ID0gY2FsY3VsYXRlQXZlcmFnZUR5bmFtaWNDb3N0KG51bVNhbXBsZXMsIHBhdGhMZW5ndGgsIDAuMCwgdmVsb2NpdHlWZWhpY2xlLCBhY2NlbGVyYXRpb24sIDEuMCAvIDAuMCk7XG4gIGlmIChhdmVyYWdlRHluYW1pY0Nvc3QgPCAwLjApIHJldHVybiB2ZWM0KC0xKTtcblxuICBhdmVyYWdlRHluYW1pY0Nvc3QgKz0gYWNjZWxlcmF0aW9uQ2hhbmdlUGVuYWx0eTtcblxuICAvLyBUaGUgY29zdCBvZiBhIHRyYWplY3RvcnkgaXMgdGhlIGF2ZXJhZ2Ugc2FtcGxlIGNvc3Qgc2NhbGVkIGJ5IHRoZSBwYXRoIGxlbmd0aFxuICBmbG9hdCB0b3RhbENvc3QgPSAoYXZlcmFnZVN0YXRpY0Nvc3QgKyBhdmVyYWdlRHluYW1pY0Nvc3QgKyAke3BhdGhUeXBlID09ICdjdWJpYycgPyAnKGN1YmljUGF0aFBlbmFsdHkgKiB2ZWxvY2l0eVZlaGljbGUgKiB2ZWxvY2l0eVZlaGljbGUpJyA6ICcwLjAnfSkgKiBwYXRoTGVuZ3RoO1xuICAke3BhdGhUeXBlICE9ICdjdWJpYycgPyAndG90YWxDb3N0ID0gLTEuMDsnIDogJyd9XG5cbiAgcmV0dXJuIHZlYzQodG90YWxDb3N0LCBmaW5hbFZlbG9jaXR5LCBmaW5hbFRpbWUsICR7cGF0aFR5cGUgPT0gJ2N1YmljJyA/ICctMicgOiAnLTEnfSk7XG59XG5cbmA7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2V0VXAoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHtcbiAgICAgICAga2VybmVsOiBmcm9tVmVoaWNsZVBhdGhDb3N0c0tlcm5lbCgnY3ViaWMnKSxcbiAgICAgICAgb3V0cHV0OiB7IG5hbWU6ICdjdWJpY1BhdGhGcm9tVmVoaWNsZUNvc3RzJyB9LFxuICAgICAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbih7fSwgU0hBUkVEX1VOSUZPUk1TLCB7XG4gICAgICAgICAgbGF0dGljZTogeyB0eXBlOiAnc2hhcmVkVGV4dHVyZScgfSxcbiAgICAgICAgICBwYXRoc0Zyb21WZWhpY2xlOiB7IHR5cGU6ICdvdXRwdXRUZXh0dXJlJywgbmFtZTogJ2N1YmljUGF0aHNGcm9tVmVoaWNsZScgfSxcbiAgICAgICAgICBmaXJzdExhdHRpY2VQb2ludDogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICAgIHNlY29uZExhdHRpY2VQb2ludDogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICAgIHZlbG9jaXR5VmVoaWNsZTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gICAgICAgICAgY3VydlZlaGljbGU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICAgIG51bUFjY2VsZXJhdGlvbnM6IHsgdHlwZTogJ2ludCcgfSxcbiAgICAgICAgICBjdWJpY1BhdGhQZW5hbHR5OiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgICBoeXN0ZXJlc2lzRGlzY291bnQ6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICAgIGFjY2VsZXJhdGlvbkNoYW5nZVBlbmFsdHk6IHsgdHlwZTogJ2Zsb2F0JyB9XG4gICAgICAgIH0pXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBrZXJuZWw6IGZyb21WZWhpY2xlUGF0aENvc3RzS2VybmVsKCdxdWludGljJyksXG4gICAgICAgIG91dHB1dDogeyBuYW1lOiAncXVpbnRpY1BhdGhGcm9tVmVoaWNsZUNvc3RzJyB9LFxuICAgICAgICB1bmlmb3JtczogT2JqZWN0LmFzc2lnbih7fSwgU0hBUkVEX1VOSUZPUk1TLCB7XG4gICAgICAgICAgbGF0dGljZTogeyB0eXBlOiAnc2hhcmVkVGV4dHVyZScgfSxcbiAgICAgICAgICBwYXRoc0Zyb21WZWhpY2xlOiB7IHR5cGU6ICdvdXRwdXRUZXh0dXJlJywgbmFtZTogJ3F1aW50aWNQYXRoc0Zyb21WZWhpY2xlJyB9LFxuICAgICAgICAgIGZpcnN0TGF0dGljZVBvaW50OiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgICAgc2Vjb25kTGF0dGljZVBvaW50OiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgICAgdmVsb2NpdHlWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgICBjdXJ2VmVoaWNsZTogeyB0eXBlOiAnZmxvYXQnIH0sXG4gICAgICAgICAgZEN1cnZWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgICBkZEN1cnZWZWhpY2xlOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgICBudW1BY2NlbGVyYXRpb25zOiB7IHR5cGU6ICdpbnQnIH0sXG4gICAgICAgICAgaHlzdGVyZXNpc0Rpc2NvdW50OiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgICBhY2NlbGVyYXRpb25DaGFuZ2VQZW5hbHR5OiB7IHR5cGU6ICdmbG9hdCcgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIF07XG4gIH0sXG5cbiAgdXBkYXRlKGNvbmZpZywgcG9zZSwgeHlDZW50ZXJQb2ludCwgc2xDZW50ZXJQb2ludCwgZmlyc3RMYXR0aWNlUG9pbnQsIHNlY29uZExhdHRpY2VQb2ludCwgZHluYW1pY0ZyYW1lVGltZSkge1xuICAgIHJldHVybiBbXG4gICAgICB7XG4gICAgICAgIHdpZHRoOiBjb25maWcubGF0dGljZS5udW1MYXRpdHVkZXMsXG4gICAgICAgIGhlaWdodDogY29uZmlnLmxhdHRpY2Uuc3RhdGlvbkNvbm5lY3Rpdml0eSAqIE5VTV9BQ0NFTEVSQVRJT05fUFJPRklMRVMsXG4gICAgICAgIHVuaWZvcm1zOiBPYmplY3QuYXNzaWduKHt9LCBidWlsZFVuaWZvcm1WYWx1ZXMoY29uZmlnLCB4eUNlbnRlclBvaW50LCBzbENlbnRlclBvaW50LCBkeW5hbWljRnJhbWVUaW1lKSwge1xuICAgICAgICAgIGZpcnN0TGF0dGljZVBvaW50OiBmaXJzdExhdHRpY2VQb2ludCxcbiAgICAgICAgICBzZWNvbmRMYXR0aWNlUG9pbnQ6IHNlY29uZExhdHRpY2VQb2ludCxcbiAgICAgICAgICB2ZWxvY2l0eVZlaGljbGU6IHBvc2UudmVsb2NpdHksXG4gICAgICAgICAgY3VydlZlaGljbGU6IHBvc2UuY3VydixcbiAgICAgICAgICBudW1BY2NlbGVyYXRpb25zOiBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTLFxuICAgICAgICAgIGN1YmljUGF0aFBlbmFsdHk6IGNvbmZpZy5jdWJpY1BhdGhQZW5hbHR5LFxuICAgICAgICAgIGh5c3RlcmVzaXNEaXNjb3VudDogY29uZmlnLmh5c3RlcmVzaXNEaXNjb3VudCxcbiAgICAgICAgICBhY2NlbGVyYXRpb25DaGFuZ2VQZW5hbHR5OiBjb25maWcuYWNjZWxlcmF0aW9uQ2hhbmdlUGVuYWx0eVxuICAgICAgICB9KVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgd2lkdGg6IGNvbmZpZy5sYXR0aWNlLm51bUxhdGl0dWRlcyxcbiAgICAgICAgaGVpZ2h0OiBjb25maWcubGF0dGljZS5zdGF0aW9uQ29ubmVjdGl2aXR5ICogTlVNX0FDQ0VMRVJBVElPTl9QUk9GSUxFUyxcbiAgICAgICAgdW5pZm9ybXM6IE9iamVjdC5hc3NpZ24oe30sIGJ1aWxkVW5pZm9ybVZhbHVlcyhjb25maWcsIHh5Q2VudGVyUG9pbnQsIHNsQ2VudGVyUG9pbnQsIGR5bmFtaWNGcmFtZVRpbWUpLCB7XG4gICAgICAgICAgZmlyc3RMYXR0aWNlUG9pbnQ6IGZpcnN0TGF0dGljZVBvaW50LFxuICAgICAgICAgIHNlY29uZExhdHRpY2VQb2ludDogc2Vjb25kTGF0dGljZVBvaW50LFxuICAgICAgICAgIHZlbG9jaXR5VmVoaWNsZTogcG9zZS52ZWxvY2l0eSxcbiAgICAgICAgICBjdXJ2VmVoaWNsZTogcG9zZS5jdXJ2LFxuICAgICAgICAgIGRDdXJ2VmVoaWNsZTogcG9zZS5kQ3VydixcbiAgICAgICAgICBkZEN1cnZWZWhpY2xlOiBwb3NlLmRkQ3VydixcbiAgICAgICAgICBudW1BY2NlbGVyYXRpb25zOiBOVU1fQUNDRUxFUkFUSU9OX1BST0ZJTEVTLFxuICAgICAgICAgIGh5c3RlcmVzaXNEaXNjb3VudDogY29uZmlnLmh5c3RlcmVzaXNEaXNjb3VudCxcbiAgICAgICAgICBhY2NlbGVyYXRpb25DaGFuZ2VQZW5hbHR5OiBjb25maWcuYWNjZWxlcmF0aW9uQ2hhbmdlUGVuYWx0eVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIF07XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./js/autonomy/path-planning/gpgpu-programs/pathFromVehicleCosts.js\n");

/***/ }),

/***/ "./js/autonomy/path-planning/gpgpu-programs/slDynamicObstacleGrid.js":
/*!***************************************************************************!*\
  !*** ./js/autonomy/path-planning/gpgpu-programs/slDynamicObstacleGrid.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst DYNAMIC_OBSTACLE_VERTEX_SHADER = `#version 300 es\nuniform mat3 xform;\nin vec3 position;\nout float color;\n\nvoid main(void) {\n  gl_Position = vec4((xform * vec3(position.xy, 1)).xy, position.z, 1);\n\n  // The z coordinate is 0.25 for collision zone and 0.75 for hazard zone,\n  // so that the collision zone is drawn on top.\n  // Convert this to 1.0 for collision zone, 0.5 for hazard zone\n  color = (1.0 - step(0.5, position.z)) * 0.5 + 0.5;\n}\n`;\n\nconst DYNAMIC_OBSTACLE_KERNEL = `\n  in float color;\n\n  vec4 kernel() {\n    return vec4(color, 0, 0, 1);\n  }\n`;\n\nlet obstacleVertices;\nlet obstacleXform;\nconst numDynamicFrames = 20;\n\n// Draw dynamic obstacle triangles to SL-space obstacle grid\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  setUp() {\n    return {\n      kernel: DYNAMIC_OBSTACLE_KERNEL,\n      vertexShader: DYNAMIC_OBSTACLE_VERTEX_SHADER,\n      output: { name: 'slDynamicObstacleGrid', textureType: '2DArray', depth: numDynamicFrames },\n      draw: (gpgpu, program) => {\n        const gl = gpgpu.gl;\n\n        gl.enable(gl.DEPTH_TEST);\n\n        const renderbuffer = gl.createRenderbuffer();\n        gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, program.inputWidth, program.inputHeight);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\n\n        for (let frame = 0; frame < numDynamicFrames; frame++) {\n          gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, program.outputTexture, 0, frame);\n          const frameBufferStatus = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE);\n          if (!frameBufferStatus)\n            throw new Error('Error attaching float texture to framebuffer. Your device is probably incompatible.');\n\n          gl.clearColor(0, 0, 0, 0);\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n          if (obstacleVertices[frame].length > 0) {\n            const buf = gl.createBuffer();\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, buf);\n            gl.bufferData(gl.ARRAY_BUFFER, obstacleVertices[frame], gl.STATIC_DRAW);\n            gl.enableVertexAttribArray(program.positionLocation);\n            gl.vertexAttribPointer(program.positionLocation, 3, gl.FLOAT, false, 0, 0);\n\n            const xformLocation = gl.getUniformLocation(program.glProgram, 'xform');\n            gl.uniformMatrix3fv(xformLocation, false, obstacleXform.elements);\n\n            gl.drawArrays(gl.TRIANGLES, 0, obstacleVertices[frame].length / 3);\n\n            if (frame == 0) {\n              const obstacleGrid = new Float32Array(program.inputWidth * program.inputHeight * 4);\n              gl.readPixels(0, 0, program.inputWidth, program.inputHeight, gl.RGBA, gl.FLOAT, obstacleGrid);\n              gpgpu._dynamicObstacleGrid = obstacleGrid;\n            }\n\n            gl.deleteBuffer(buf);\n          }\n        }\n\n        gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n        gl.deleteRenderbuffer(renderbuffer);\n        gl.disable(gl.DEPTH_TEST);\n      }\n    };\n  },\n\n  update(config, slWidth, slHeight, slCenterPoint, vehicleStation, startTime, dynamicFrameTime, dynamicObstacles) {\n    obstacleVertices = [];\n\n    let time = startTime;\n    for (let frame = 0; frame < numDynamicFrames; frame++) {\n      const vertices = Array.prototype.concat.apply([], dynamicObstacles.map(o => o.verticesInTimeRange(time, time + dynamicFrameTime, config)));\n      obstacleVertices.push(new Float32Array(vertices));\n      time += dynamicFrameTime;\n    }\n\n    const translate = new THREE.Matrix3();\n    translate.set(\n      1, 0, -slCenterPoint.x - vehicleStation,\n      0, 1, -slCenterPoint.y,\n      0, 0, 1\n    );\n\n    const scale = new THREE.Matrix3();\n    scale.set(\n      2 / (slWidth * config.slGridCellSize), 0, 0,\n      0, 2 / (slHeight * config.slGridCellSize), 0,\n      0, 0, 1\n    );\n\n    obstacleXform = scale.multiply(translate);\n\n    return {\n      width: slWidth,\n      height: slHeight\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL3NsRHluYW1pY09ic3RhY2xlR3JpZC5qcz82YzBlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpRkFBaUY7QUFDaEc7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vanMvYXV0b25vbXkvcGF0aC1wbGFubmluZy9ncGdwdS1wcm9ncmFtcy9zbER5bmFtaWNPYnN0YWNsZUdyaWQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBEWU5BTUlDX09CU1RBQ0xFX1ZFUlRFWF9TSEFERVIgPSBgI3ZlcnNpb24gMzAwIGVzXG51bmlmb3JtIG1hdDMgeGZvcm07XG5pbiB2ZWMzIHBvc2l0aW9uO1xub3V0IGZsb2F0IGNvbG9yO1xuXG52b2lkIG1haW4odm9pZCkge1xuICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHhmb3JtICogdmVjMyhwb3NpdGlvbi54eSwgMSkpLnh5LCBwb3NpdGlvbi56LCAxKTtcblxuICAvLyBUaGUgeiBjb29yZGluYXRlIGlzIDAuMjUgZm9yIGNvbGxpc2lvbiB6b25lIGFuZCAwLjc1IGZvciBoYXphcmQgem9uZSxcbiAgLy8gc28gdGhhdCB0aGUgY29sbGlzaW9uIHpvbmUgaXMgZHJhd24gb24gdG9wLlxuICAvLyBDb252ZXJ0IHRoaXMgdG8gMS4wIGZvciBjb2xsaXNpb24gem9uZSwgMC41IGZvciBoYXphcmQgem9uZVxuICBjb2xvciA9ICgxLjAgLSBzdGVwKDAuNSwgcG9zaXRpb24ueikpICogMC41ICsgMC41O1xufVxuYDtcblxuY29uc3QgRFlOQU1JQ19PQlNUQUNMRV9LRVJORUwgPSBgXG4gIGluIGZsb2F0IGNvbG9yO1xuXG4gIHZlYzQga2VybmVsKCkge1xuICAgIHJldHVybiB2ZWM0KGNvbG9yLCAwLCAwLCAxKTtcbiAgfVxuYDtcblxubGV0IG9ic3RhY2xlVmVydGljZXM7XG5sZXQgb2JzdGFjbGVYZm9ybTtcbmNvbnN0IG51bUR5bmFtaWNGcmFtZXMgPSAyMDtcblxuLy8gRHJhdyBkeW5hbWljIG9ic3RhY2xlIHRyaWFuZ2xlcyB0byBTTC1zcGFjZSBvYnN0YWNsZSBncmlkXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNldFVwKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXJuZWw6IERZTkFNSUNfT0JTVEFDTEVfS0VSTkVMLFxuICAgICAgdmVydGV4U2hhZGVyOiBEWU5BTUlDX09CU1RBQ0xFX1ZFUlRFWF9TSEFERVIsXG4gICAgICBvdXRwdXQ6IHsgbmFtZTogJ3NsRHluYW1pY09ic3RhY2xlR3JpZCcsIHRleHR1cmVUeXBlOiAnMkRBcnJheScsIGRlcHRoOiBudW1EeW5hbWljRnJhbWVzIH0sXG4gICAgICBkcmF3OiAoZ3BncHUsIHByb2dyYW0pID0+IHtcbiAgICAgICAgY29uc3QgZ2wgPSBncGdwdS5nbDtcblxuICAgICAgICBnbC5lbmFibGUoZ2wuREVQVEhfVEVTVCk7XG5cbiAgICAgICAgY29uc3QgcmVuZGVyYnVmZmVyID0gZ2wuY3JlYXRlUmVuZGVyYnVmZmVyKCk7XG4gICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIpO1xuICAgICAgICBnbC5yZW5kZXJidWZmZXJTdG9yYWdlKGdsLlJFTkRFUkJVRkZFUiwgZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHByb2dyYW0uaW5wdXRXaWR0aCwgcHJvZ3JhbS5pbnB1dEhlaWdodCk7XG4gICAgICAgIGdsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBnbC5ERVBUSF9BVFRBQ0hNRU5ULCBnbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlcik7XG5cbiAgICAgICAgZm9yIChsZXQgZnJhbWUgPSAwOyBmcmFtZSA8IG51bUR5bmFtaWNGcmFtZXM7IGZyYW1lKyspIHtcbiAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmVMYXllcihnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIHByb2dyYW0ub3V0cHV0VGV4dHVyZSwgMCwgZnJhbWUpO1xuICAgICAgICAgIGNvbnN0IGZyYW1lQnVmZmVyU3RhdHVzID0gKGdsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoZ2wuRlJBTUVCVUZGRVIpID09IGdsLkZSQU1FQlVGRkVSX0NPTVBMRVRFKTtcbiAgICAgICAgICBpZiAoIWZyYW1lQnVmZmVyU3RhdHVzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhdHRhY2hpbmcgZmxvYXQgdGV4dHVyZSB0byBmcmFtZWJ1ZmZlci4gWW91ciBkZXZpY2UgaXMgcHJvYmFibHkgaW5jb21wYXRpYmxlLicpO1xuXG4gICAgICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUIHwgZ2wuREVQVEhfQlVGRkVSX0JJVCk7XG5cbiAgICAgICAgICBpZiAob2JzdGFjbGVWZXJ0aWNlc1tmcmFtZV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYnVmID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG5cbiAgICAgICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWYpO1xuICAgICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG9ic3RhY2xlVmVydGljZXNbZnJhbWVdLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwcm9ncmFtLnBvc2l0aW9uTG9jYXRpb24pO1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwcm9ncmFtLnBvc2l0aW9uTG9jYXRpb24sIDMsIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHhmb3JtTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbS5nbFByb2dyYW0sICd4Zm9ybScpO1xuICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih4Zm9ybUxvY2F0aW9uLCBmYWxzZSwgb2JzdGFjbGVYZm9ybS5lbGVtZW50cyk7XG5cbiAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCBvYnN0YWNsZVZlcnRpY2VzW2ZyYW1lXS5sZW5ndGggLyAzKTtcblxuICAgICAgICAgICAgaWYgKGZyYW1lID09IDApIHtcbiAgICAgICAgICAgICAgY29uc3Qgb2JzdGFjbGVHcmlkID0gbmV3IEZsb2F0MzJBcnJheShwcm9ncmFtLmlucHV0V2lkdGggKiBwcm9ncmFtLmlucHV0SGVpZ2h0ICogNCk7XG4gICAgICAgICAgICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgcHJvZ3JhbS5pbnB1dFdpZHRoLCBwcm9ncmFtLmlucHV0SGVpZ2h0LCBnbC5SR0JBLCBnbC5GTE9BVCwgb2JzdGFjbGVHcmlkKTtcbiAgICAgICAgICAgICAgZ3BncHUuX2R5bmFtaWNPYnN0YWNsZUdyaWQgPSBvYnN0YWNsZUdyaWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdsLmRlbGV0ZUJ1ZmZlcihidWYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdsLmJpbmRSZW5kZXJidWZmZXIoZ2wuUkVOREVSQlVGRkVSLCBudWxsKTtcbiAgICAgICAgZ2wuZGVsZXRlUmVuZGVyYnVmZmVyKHJlbmRlcmJ1ZmZlcik7XG4gICAgICAgIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGUoY29uZmlnLCBzbFdpZHRoLCBzbEhlaWdodCwgc2xDZW50ZXJQb2ludCwgdmVoaWNsZVN0YXRpb24sIHN0YXJ0VGltZSwgZHluYW1pY0ZyYW1lVGltZSwgZHluYW1pY09ic3RhY2xlcykge1xuICAgIG9ic3RhY2xlVmVydGljZXMgPSBbXTtcblxuICAgIGxldCB0aW1lID0gc3RhcnRUaW1lO1xuICAgIGZvciAobGV0IGZyYW1lID0gMDsgZnJhbWUgPCBudW1EeW5hbWljRnJhbWVzOyBmcmFtZSsrKSB7XG4gICAgICBjb25zdCB2ZXJ0aWNlcyA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGR5bmFtaWNPYnN0YWNsZXMubWFwKG8gPT4gby52ZXJ0aWNlc0luVGltZVJhbmdlKHRpbWUsIHRpbWUgKyBkeW5hbWljRnJhbWVUaW1lLCBjb25maWcpKSk7XG4gICAgICBvYnN0YWNsZVZlcnRpY2VzLnB1c2gobmV3IEZsb2F0MzJBcnJheSh2ZXJ0aWNlcykpO1xuICAgICAgdGltZSArPSBkeW5hbWljRnJhbWVUaW1lO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG4gICAgdHJhbnNsYXRlLnNldChcbiAgICAgIDEsIDAsIC1zbENlbnRlclBvaW50LnggLSB2ZWhpY2xlU3RhdGlvbixcbiAgICAgIDAsIDEsIC1zbENlbnRlclBvaW50LnksXG4gICAgICAwLCAwLCAxXG4gICAgKTtcblxuICAgIGNvbnN0IHNjYWxlID0gbmV3IFRIUkVFLk1hdHJpeDMoKTtcbiAgICBzY2FsZS5zZXQoXG4gICAgICAyIC8gKHNsV2lkdGggKiBjb25maWcuc2xHcmlkQ2VsbFNpemUpLCAwLCAwLFxuICAgICAgMCwgMiAvIChzbEhlaWdodCAqIGNvbmZpZy5zbEdyaWRDZWxsU2l6ZSksIDAsXG4gICAgICAwLCAwLCAxXG4gICAgKTtcblxuICAgIG9ic3RhY2xlWGZvcm0gPSBzY2FsZS5tdWx0aXBseSh0cmFuc2xhdGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBzbFdpZHRoLFxuICAgICAgaGVpZ2h0OiBzbEhlaWdodFxuICAgIH1cbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/autonomy/path-planning/gpgpu-programs/slDynamicObstacleGrid.js\n");

/***/ }),

/***/ "./js/autonomy/path-planning/gpgpu-programs/slObstacleGrid.js":
/*!********************************************************************!*\
  !*** ./js/autonomy/path-planning/gpgpu-programs/slObstacleGrid.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst SL_OBSTACLE_KERNEL = `\n\nvec4 kernel() {\n  float centerlineWidth = float(textureSize(centerline, 0).x);\n\n  vec2 sl = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(slGridCellSize) + slCenterPoint;\n  float centerlineCoord = sl.x / centerlineStationInterval / centerlineWidth * (centerlineWidth - 1.0) / centerlineWidth + (0.5 / centerlineWidth);\n  if (centerlineCoord < 0.0 || centerlineCoord > 1.0) return vec4(0);\n\n  vec3 centerlineSample = texture(centerline, vec2(centerlineCoord, 0)).xyz;\n  float perpindicular = centerlineSample.z + radians(90.0);\n  vec2 xy = centerlineSample.xy + sl.yy * vec2(cos(perpindicular), sin(perpindicular));\n\n  vec2 xyTexCoords = (xy - xyCenterPoint) / vec2(textureSize(xyObstacleGrid, 0)) / vec2(xyGridCellSize) + 0.5;\n  return texture(xyObstacleGrid, xyTexCoords);\n}\n\n`;\n\n// Convert XY-space obstacle grid to SL-space obstacle grid\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  setUp() {\n    return {\n      kernel: SL_OBSTACLE_KERNEL,\n      output: { name: 'slObstacleGrid' },\n      uniforms: {\n        xyObstacleGrid: { type: 'outputTexture' },\n        slGridCellSize: { type: 'float' },\n        xyGridCellSize: { type: 'float' },\n        slCenterPoint: { type: 'vec2' },\n        xyCenterPoint: { type: 'vec2' },\n        centerlineStationInterval: { type: 'float' },\n        centerline: { type: 'sharedTexture' }\n      }\n    }\n  },\n\n  update(config, slWidth, slHeight, slCenterPoint, xyCenterPoint) {\n    return {\n      width: slWidth,\n      height: slHeight,\n      uniforms: {\n        slGridCellSize: config.slGridCellSize,\n        xyGridCellSize: config.xyGridCellSize,\n        slCenterPoint: [slCenterPoint.x, slCenterPoint.y],\n        xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\n        centerlineStationInterval: config.centerlineStationInterval\n      }\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL3NsT2JzdGFjbGVHcmlkLmpzP2U1NGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QjtBQUN4QztBQUNBLHlCQUF5Qix3QkFBd0I7QUFDakQseUJBQXlCLGdCQUFnQjtBQUN6Qyx5QkFBeUIsZ0JBQWdCO0FBQ3pDLHdCQUF3QixlQUFlO0FBQ3ZDLHdCQUF3QixlQUFlO0FBQ3ZDLG9DQUFvQyxnQkFBZ0I7QUFDcEQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL3NsT2JzdGFjbGVHcmlkLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU0xfT0JTVEFDTEVfS0VSTkVMID0gYFxuXG52ZWM0IGtlcm5lbCgpIHtcbiAgZmxvYXQgY2VudGVybGluZVdpZHRoID0gZmxvYXQodGV4dHVyZVNpemUoY2VudGVybGluZSwgMCkueCk7XG5cbiAgdmVjMiBzbCA9IChrZXJuZWxQb3NpdGlvbiAtIDAuNSkgKiB2ZWMyKGtlcm5lbFNpemUpICogdmVjMihzbEdyaWRDZWxsU2l6ZSkgKyBzbENlbnRlclBvaW50O1xuICBmbG9hdCBjZW50ZXJsaW5lQ29vcmQgPSBzbC54IC8gY2VudGVybGluZVN0YXRpb25JbnRlcnZhbCAvIGNlbnRlcmxpbmVXaWR0aCAqIChjZW50ZXJsaW5lV2lkdGggLSAxLjApIC8gY2VudGVybGluZVdpZHRoICsgKDAuNSAvIGNlbnRlcmxpbmVXaWR0aCk7XG4gIGlmIChjZW50ZXJsaW5lQ29vcmQgPCAwLjAgfHwgY2VudGVybGluZUNvb3JkID4gMS4wKSByZXR1cm4gdmVjNCgwKTtcblxuICB2ZWMzIGNlbnRlcmxpbmVTYW1wbGUgPSB0ZXh0dXJlKGNlbnRlcmxpbmUsIHZlYzIoY2VudGVybGluZUNvb3JkLCAwKSkueHl6O1xuICBmbG9hdCBwZXJwaW5kaWN1bGFyID0gY2VudGVybGluZVNhbXBsZS56ICsgcmFkaWFucyg5MC4wKTtcbiAgdmVjMiB4eSA9IGNlbnRlcmxpbmVTYW1wbGUueHkgKyBzbC55eSAqIHZlYzIoY29zKHBlcnBpbmRpY3VsYXIpLCBzaW4ocGVycGluZGljdWxhcikpO1xuXG4gIHZlYzIgeHlUZXhDb29yZHMgPSAoeHkgLSB4eUNlbnRlclBvaW50KSAvIHZlYzIodGV4dHVyZVNpemUoeHlPYnN0YWNsZUdyaWQsIDApKSAvIHZlYzIoeHlHcmlkQ2VsbFNpemUpICsgMC41O1xuICByZXR1cm4gdGV4dHVyZSh4eU9ic3RhY2xlR3JpZCwgeHlUZXhDb29yZHMpO1xufVxuXG5gO1xuXG4vLyBDb252ZXJ0IFhZLXNwYWNlIG9ic3RhY2xlIGdyaWQgdG8gU0wtc3BhY2Ugb2JzdGFjbGUgZ3JpZFxuZXhwb3J0IGRlZmF1bHQge1xuICBzZXRVcCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2VybmVsOiBTTF9PQlNUQUNMRV9LRVJORUwsXG4gICAgICBvdXRwdXQ6IHsgbmFtZTogJ3NsT2JzdGFjbGVHcmlkJyB9LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgeHlPYnN0YWNsZUdyaWQ6IHsgdHlwZTogJ291dHB1dFRleHR1cmUnIH0sXG4gICAgICAgIHNsR3JpZENlbGxTaXplOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgeHlHcmlkQ2VsbFNpemU6IHsgdHlwZTogJ2Zsb2F0JyB9LFxuICAgICAgICBzbENlbnRlclBvaW50OiB7IHR5cGU6ICd2ZWMyJyB9LFxuICAgICAgICB4eUNlbnRlclBvaW50OiB7IHR5cGU6ICd2ZWMyJyB9LFxuICAgICAgICBjZW50ZXJsaW5lU3RhdGlvbkludGVydmFsOiB7IHR5cGU6ICdmbG9hdCcgfSxcbiAgICAgICAgY2VudGVybGluZTogeyB0eXBlOiAnc2hhcmVkVGV4dHVyZScgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICB1cGRhdGUoY29uZmlnLCBzbFdpZHRoLCBzbEhlaWdodCwgc2xDZW50ZXJQb2ludCwgeHlDZW50ZXJQb2ludCkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogc2xXaWR0aCxcbiAgICAgIGhlaWdodDogc2xIZWlnaHQsXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBzbEdyaWRDZWxsU2l6ZTogY29uZmlnLnNsR3JpZENlbGxTaXplLFxuICAgICAgICB4eUdyaWRDZWxsU2l6ZTogY29uZmlnLnh5R3JpZENlbGxTaXplLFxuICAgICAgICBzbENlbnRlclBvaW50OiBbc2xDZW50ZXJQb2ludC54LCBzbENlbnRlclBvaW50LnldLFxuICAgICAgICB4eUNlbnRlclBvaW50OiBbeHlDZW50ZXJQb2ludC54LCB4eUNlbnRlclBvaW50LnldLFxuICAgICAgICBjZW50ZXJsaW5lU3RhdGlvbkludGVydmFsOiBjb25maWcuY2VudGVybGluZVN0YXRpb25JbnRlcnZhbFxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/autonomy/path-planning/gpgpu-programs/slObstacleGrid.js\n");

/***/ }),

/***/ "./js/autonomy/path-planning/gpgpu-programs/slObstacleGridDilation.js":
/*!****************************************************************************!*\
  !*** ./js/autonomy/path-planning/gpgpu-programs/slObstacleGridDilation.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst SL_OBSTACLE_DILATION_KERNEL = `\n\n// TODO: test performance of returning early if non-zero pixel found\nvec4 kernel() {\n  float val = 0.0;\n\n  for (int d = 0; d <= collisionDilation; d++) {\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r);\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r);\n  }\n\n  for (int d = collisionDilation + 1; d <= collisionDilation + hazardDilation; d++) {\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(d)).r * 0.5);\n    val = max(val, texture(slObstacleGrid, kernelPosition + delta * vec2(-d)).r * 0.5);\n  }\n\n  val = max(val, step(0.1, val) * 0.5);\n\n  return vec4(val, 0, 0, 1);\n}\n\n`;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  setUp() {\n    return [\n      { // SL-space obstacle grid S dilation\n        kernel: SL_OBSTACLE_DILATION_KERNEL,\n        output: { name: 'slObstacleGridStationDilated' },\n        uniforms: {\n          slObstacleGrid: { type: 'outputTexture' },\n          delta: { type: 'vec2' },\n          collisionDilation: { type: 'int' },\n          hazardDilation: { type: 'int' }\n        }\n      },\n      { // SL-space obstacle grid L dilation\n        kernel: SL_OBSTACLE_DILATION_KERNEL,\n        output: { name: 'slObstacleGridDilated' },\n        uniforms: {\n          slObstacleGrid: { type: 'outputTexture', name: 'slObstacleGridStationDilated' },\n          delta: { type: 'vec2' },\n          collisionDilation: { type: 'int' },\n          hazardDilation: { type: 'int' }\n        }\n      }\n    ];\n  },\n\n  update(config, slWidth, slHeight) {\n    return [\n      { // SL-space obstacle grid S dilation\n        width: slWidth,\n        height: slHeight,\n        uniforms: {\n          delta: [1 / slWidth, 0],\n          collisionDilation: Math.ceil(config.collisionDilationS / config.slGridCellSize),\n          hazardDilation: Math.ceil(config.hazardDilationS / config.slGridCellSize)\n        }\n      },\n      { // SL-space obstacle grid L dilation\n        width: slWidth,\n        height: slHeight,\n        uniforms: {\n          delta: [0, 1 / slHeight],\n          collisionDilation: Math.ceil(config.collisionDilationL / config.slGridCellSize),\n          hazardDilation: Math.ceil(config.hazardDilationL / config.slGridCellSize)\n        }\n      }\n    ];\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL3NsT2JzdGFjbGVHcmlkRGlsYXRpb24uanM/MTc0OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMseUNBQXlDO0FBQzlFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLGlCQUFpQix1Q0FBdUM7QUFDeEQ7QUFDQSwyQkFBMkIsd0JBQXdCO0FBQ25ELGtCQUFrQixlQUFlO0FBQ2pDLDhCQUE4QixjQUFjO0FBQzVDLDJCQUEyQjtBQUMzQjtBQUNBLE9BQU87QUFDUCxPQUFPO0FBQ1A7QUFDQSxpQkFBaUIsZ0NBQWdDO0FBQ2pEO0FBQ0EsMkJBQTJCLDhEQUE4RDtBQUN6RixrQkFBa0IsZUFBZTtBQUNqQyw4QkFBOEIsY0FBYztBQUM1QywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vanMvYXV0b25vbXkvcGF0aC1wbGFubmluZy9ncGdwdS1wcm9ncmFtcy9zbE9ic3RhY2xlR3JpZERpbGF0aW9uLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgU0xfT0JTVEFDTEVfRElMQVRJT05fS0VSTkVMID0gYFxuXG4vLyBUT0RPOiB0ZXN0IHBlcmZvcm1hbmNlIG9mIHJldHVybmluZyBlYXJseSBpZiBub24temVybyBwaXhlbCBmb3VuZFxudmVjNCBrZXJuZWwoKSB7XG4gIGZsb2F0IHZhbCA9IDAuMDtcblxuICBmb3IgKGludCBkID0gMDsgZCA8PSBjb2xsaXNpb25EaWxhdGlvbjsgZCsrKSB7XG4gICAgdmFsID0gbWF4KHZhbCwgdGV4dHVyZShzbE9ic3RhY2xlR3JpZCwga2VybmVsUG9zaXRpb24gKyBkZWx0YSAqIHZlYzIoZCkpLnIpO1xuICAgIHZhbCA9IG1heCh2YWwsIHRleHR1cmUoc2xPYnN0YWNsZUdyaWQsIGtlcm5lbFBvc2l0aW9uICsgZGVsdGEgKiB2ZWMyKC1kKSkucik7XG4gIH1cblxuICBmb3IgKGludCBkID0gY29sbGlzaW9uRGlsYXRpb24gKyAxOyBkIDw9IGNvbGxpc2lvbkRpbGF0aW9uICsgaGF6YXJkRGlsYXRpb247IGQrKykge1xuICAgIHZhbCA9IG1heCh2YWwsIHRleHR1cmUoc2xPYnN0YWNsZUdyaWQsIGtlcm5lbFBvc2l0aW9uICsgZGVsdGEgKiB2ZWMyKGQpKS5yICogMC41KTtcbiAgICB2YWwgPSBtYXgodmFsLCB0ZXh0dXJlKHNsT2JzdGFjbGVHcmlkLCBrZXJuZWxQb3NpdGlvbiArIGRlbHRhICogdmVjMigtZCkpLnIgKiAwLjUpO1xuICB9XG5cbiAgdmFsID0gbWF4KHZhbCwgc3RlcCgwLjEsIHZhbCkgKiAwLjUpO1xuXG4gIHJldHVybiB2ZWM0KHZhbCwgMCwgMCwgMSk7XG59XG5cbmA7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2V0VXAoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIHsgLy8gU0wtc3BhY2Ugb2JzdGFjbGUgZ3JpZCBTIGRpbGF0aW9uXG4gICAgICAgIGtlcm5lbDogU0xfT0JTVEFDTEVfRElMQVRJT05fS0VSTkVMLFxuICAgICAgICBvdXRwdXQ6IHsgbmFtZTogJ3NsT2JzdGFjbGVHcmlkU3RhdGlvbkRpbGF0ZWQnIH0sXG4gICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgc2xPYnN0YWNsZUdyaWQ6IHsgdHlwZTogJ291dHB1dFRleHR1cmUnIH0sXG4gICAgICAgICAgZGVsdGE6IHsgdHlwZTogJ3ZlYzInIH0sXG4gICAgICAgICAgY29sbGlzaW9uRGlsYXRpb246IHsgdHlwZTogJ2ludCcgfSxcbiAgICAgICAgICBoYXphcmREaWxhdGlvbjogeyB0eXBlOiAnaW50JyB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IC8vIFNMLXNwYWNlIG9ic3RhY2xlIGdyaWQgTCBkaWxhdGlvblxuICAgICAgICBrZXJuZWw6IFNMX09CU1RBQ0xFX0RJTEFUSU9OX0tFUk5FTCxcbiAgICAgICAgb3V0cHV0OiB7IG5hbWU6ICdzbE9ic3RhY2xlR3JpZERpbGF0ZWQnIH0sXG4gICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgc2xPYnN0YWNsZUdyaWQ6IHsgdHlwZTogJ291dHB1dFRleHR1cmUnLCBuYW1lOiAnc2xPYnN0YWNsZUdyaWRTdGF0aW9uRGlsYXRlZCcgfSxcbiAgICAgICAgICBkZWx0YTogeyB0eXBlOiAndmVjMicgfSxcbiAgICAgICAgICBjb2xsaXNpb25EaWxhdGlvbjogeyB0eXBlOiAnaW50JyB9LFxuICAgICAgICAgIGhhemFyZERpbGF0aW9uOiB7IHR5cGU6ICdpbnQnIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIF07XG4gIH0sXG5cbiAgdXBkYXRlKGNvbmZpZywgc2xXaWR0aCwgc2xIZWlnaHQpIHtcbiAgICByZXR1cm4gW1xuICAgICAgeyAvLyBTTC1zcGFjZSBvYnN0YWNsZSBncmlkIFMgZGlsYXRpb25cbiAgICAgICAgd2lkdGg6IHNsV2lkdGgsXG4gICAgICAgIGhlaWdodDogc2xIZWlnaHQsXG4gICAgICAgIHVuaWZvcm1zOiB7XG4gICAgICAgICAgZGVsdGE6IFsxIC8gc2xXaWR0aCwgMF0sXG4gICAgICAgICAgY29sbGlzaW9uRGlsYXRpb246IE1hdGguY2VpbChjb25maWcuY29sbGlzaW9uRGlsYXRpb25TIC8gY29uZmlnLnNsR3JpZENlbGxTaXplKSxcbiAgICAgICAgICBoYXphcmREaWxhdGlvbjogTWF0aC5jZWlsKGNvbmZpZy5oYXphcmREaWxhdGlvblMgLyBjb25maWcuc2xHcmlkQ2VsbFNpemUpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB7IC8vIFNMLXNwYWNlIG9ic3RhY2xlIGdyaWQgTCBkaWxhdGlvblxuICAgICAgICB3aWR0aDogc2xXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBzbEhlaWdodCxcbiAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICBkZWx0YTogWzAsIDEgLyBzbEhlaWdodF0sXG4gICAgICAgICAgY29sbGlzaW9uRGlsYXRpb246IE1hdGguY2VpbChjb25maWcuY29sbGlzaW9uRGlsYXRpb25MIC8gY29uZmlnLnNsR3JpZENlbGxTaXplKSxcbiAgICAgICAgICBoYXphcmREaWxhdGlvbjogTWF0aC5jZWlsKGNvbmZpZy5oYXphcmREaWxhdGlvbkwgLyBjb25maWcuc2xHcmlkQ2VsbFNpemUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICBdO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/autonomy/path-planning/gpgpu-programs/slObstacleGridDilation.js\n");

/***/ }),

/***/ "./js/autonomy/path-planning/gpgpu-programs/xyObstacleCostGrid.js":
/*!************************************************************************!*\
  !*** ./js/autonomy/path-planning/gpgpu-programs/xyObstacleCostGrid.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst XY_OBSTACLE_COST_KERNEL = `\n\nvec4 kernel() {\n  vec2 xy = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(xyGridCellSize) + xyCenterPoint;\n\n  vec2 xyTexCoords = (xy - xyCenterPoint) / vec2(textureSize(xyslMap, 0)) / vec2(xyGridCellSize) + 0.5;\n  vec2 sl = texture(xyslMap, xyTexCoords).xy;\n\n  vec2 slTexCoords = (sl - slCenterPoint) / vec2(textureSize(slObstacleGrid, 0)) / vec2(slGridCellSize) + 0.5;\n  return texture(slObstacleGrid, slTexCoords);\n}\n\n`;\n\n// Build XY obstacle costs using XYSL map\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  setUp() {\n    return {\n      kernel: XY_OBSTACLE_COST_KERNEL,\n      output: { name: 'xyObstacleCostGrid', read: true },\n      uniforms: {\n        xyslMap: { type: 'outputTexture' },\n        slObstacleGrid: { type: 'outputTexture', name: 'slObstacleGridDilated' },\n        xyCenterPoint: { type: 'vec2' },\n        xyGridCellSize: { type: 'float'},\n        slCenterPoint: { type: 'vec2' },\n        slGridCellSize: { type: 'float'}\n      }\n    };\n  },\n\n  update(config, xyWidth, xyHeight, xyCenterPoint, slCenterPoint) {\n    return {\n      width: xyWidth,\n      height: xyHeight,\n      uniforms: {\n        xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\n        xyGridCellSize: config.xyGridCellSize,\n        slCenterPoint: [slCenterPoint.x, slCenterPoint.y],\n        slGridCellSize: config.slGridCellSize\n      }\n    };\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL3h5T2JzdGFjbGVDb3N0R3JpZC5qcz9jOTc0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5Q0FBeUM7QUFDeEQ7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDLHlCQUF5Qix1REFBdUQ7QUFDaEYsd0JBQXdCLGVBQWU7QUFDdkMseUJBQXlCLGVBQWU7QUFDeEMsd0JBQXdCLGVBQWU7QUFDdkMseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vanMvYXV0b25vbXkvcGF0aC1wbGFubmluZy9ncGdwdS1wcm9ncmFtcy94eU9ic3RhY2xlQ29zdEdyaWQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBYWV9PQlNUQUNMRV9DT1NUX0tFUk5FTCA9IGBcblxudmVjNCBrZXJuZWwoKSB7XG4gIHZlYzIgeHkgPSAoa2VybmVsUG9zaXRpb24gLSAwLjUpICogdmVjMihrZXJuZWxTaXplKSAqIHZlYzIoeHlHcmlkQ2VsbFNpemUpICsgeHlDZW50ZXJQb2ludDtcblxuICB2ZWMyIHh5VGV4Q29vcmRzID0gKHh5IC0geHlDZW50ZXJQb2ludCkgLyB2ZWMyKHRleHR1cmVTaXplKHh5c2xNYXAsIDApKSAvIHZlYzIoeHlHcmlkQ2VsbFNpemUpICsgMC41O1xuICB2ZWMyIHNsID0gdGV4dHVyZSh4eXNsTWFwLCB4eVRleENvb3JkcykueHk7XG5cbiAgdmVjMiBzbFRleENvb3JkcyA9IChzbCAtIHNsQ2VudGVyUG9pbnQpIC8gdmVjMih0ZXh0dXJlU2l6ZShzbE9ic3RhY2xlR3JpZCwgMCkpIC8gdmVjMihzbEdyaWRDZWxsU2l6ZSkgKyAwLjU7XG4gIHJldHVybiB0ZXh0dXJlKHNsT2JzdGFjbGVHcmlkLCBzbFRleENvb3Jkcyk7XG59XG5cbmA7XG5cbi8vIEJ1aWxkIFhZIG9ic3RhY2xlIGNvc3RzIHVzaW5nIFhZU0wgbWFwXG5leHBvcnQgZGVmYXVsdCB7XG4gIHNldFVwKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXJuZWw6IFhZX09CU1RBQ0xFX0NPU1RfS0VSTkVMLFxuICAgICAgb3V0cHV0OiB7IG5hbWU6ICd4eU9ic3RhY2xlQ29zdEdyaWQnLCByZWFkOiB0cnVlIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICB4eXNsTWFwOiB7IHR5cGU6ICdvdXRwdXRUZXh0dXJlJyB9LFxuICAgICAgICBzbE9ic3RhY2xlR3JpZDogeyB0eXBlOiAnb3V0cHV0VGV4dHVyZScsIG5hbWU6ICdzbE9ic3RhY2xlR3JpZERpbGF0ZWQnIH0sXG4gICAgICAgIHh5Q2VudGVyUG9pbnQ6IHsgdHlwZTogJ3ZlYzInIH0sXG4gICAgICAgIHh5R3JpZENlbGxTaXplOiB7IHR5cGU6ICdmbG9hdCd9LFxuICAgICAgICBzbENlbnRlclBvaW50OiB7IHR5cGU6ICd2ZWMyJyB9LFxuICAgICAgICBzbEdyaWRDZWxsU2l6ZTogeyB0eXBlOiAnZmxvYXQnfVxuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlKGNvbmZpZywgeHlXaWR0aCwgeHlIZWlnaHQsIHh5Q2VudGVyUG9pbnQsIHNsQ2VudGVyUG9pbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHh5V2lkdGgsXG4gICAgICBoZWlnaHQ6IHh5SGVpZ2h0LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgeHlDZW50ZXJQb2ludDogW3h5Q2VudGVyUG9pbnQueCwgeHlDZW50ZXJQb2ludC55XSxcbiAgICAgICAgeHlHcmlkQ2VsbFNpemU6IGNvbmZpZy54eUdyaWRDZWxsU2l6ZSxcbiAgICAgICAgc2xDZW50ZXJQb2ludDogW3NsQ2VudGVyUG9pbnQueCwgc2xDZW50ZXJQb2ludC55XSxcbiAgICAgICAgc2xHcmlkQ2VsbFNpemU6IGNvbmZpZy5zbEdyaWRDZWxsU2l6ZVxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./js/autonomy/path-planning/gpgpu-programs/xyObstacleCostGrid.js\n");

/***/ }),

/***/ "./js/autonomy/path-planning/gpgpu-programs/xyObstacleGrid.js":
/*!********************************************************************!*\
  !*** ./js/autonomy/path-planning/gpgpu-programs/xyObstacleGrid.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst OBSTACLE_VERTEX_SHADER = `#version 300 es\nuniform mat3 xform;\nin vec2 position;\n\nvoid main(void) {\n  gl_Position = vec4((xform * vec3(position, 1)).xy, 0, 1);\n}\n`;\n\nconst OBSTACLE_KERNEL = `\n  vec4 kernel() {\n    return vec4(1, 0, 0, 1);\n  }\n`;\n\nlet obstacleVertices;\nlet obstacleXform;\n\n// Draw obstacle triangles to XY-space obstacle grid\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  setUp() {\n    return {\n      kernel: OBSTACLE_KERNEL,\n      vertexShader: OBSTACLE_VERTEX_SHADER,\n      output: { name: 'xyObstacleGrid' },\n      draw: (gpgpu, program) => {\n        const gl = gpgpu.gl;\n\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n\n        if (obstacleVertices.length > 0) {\n          const buf = gl.createBuffer();\n\n          gl.bindBuffer(gl.ARRAY_BUFFER, buf);\n          gl.bufferData(gl.ARRAY_BUFFER, obstacleVertices, gl.STATIC_DRAW);\n          gl.enableVertexAttribArray(program.positionLocation);\n          gl.vertexAttribPointer(program.positionLocation, 2, gl.FLOAT, false, 0, 0);\n\n          const xformLocation = gl.getUniformLocation(program.glProgram, 'xform');\n          gl.uniformMatrix3fv(xformLocation, false, obstacleXform.elements);\n\n          gl.drawArrays(gl.TRIANGLES, 0, obstacleVertices.length / 2);\n\n          gl.deleteBuffer(buf);\n        }\n      }\n    };\n  },\n\n  update(config, xyWidth, xyHeight, xyCenterPoint, vehicleXform, obstacles) {\n    obstacleVertices = new Float32Array(Array.prototype.concat.apply([], obstacles.map(o => o.vertices)));\n\n    const translate = new THREE.Matrix3();\n    translate.set(\n      1, 0, -xyCenterPoint.x,\n      0, 1, -xyCenterPoint.y,\n      0, 0, 1\n    );\n\n    const scale = new THREE.Matrix3();\n    scale.set(\n      2 / (xyWidth * config.xyGridCellSize), 0, 0,\n      0, 2 / (xyHeight * config.xyGridCellSize), 0,\n      0, 0, 1\n    );\n\n    obstacleXform = scale.multiply(translate).multiply(vehicleXform);\n\n    return {\n      width: xyWidth,\n      height: xyHeight\n    }\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL3h5T2JzdGFjbGVHcmlkLmpzP2Q3OGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUJBQXlCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL3h5T2JzdGFjbGVHcmlkLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgT0JTVEFDTEVfVkVSVEVYX1NIQURFUiA9IGAjdmVyc2lvbiAzMDAgZXNcbnVuaWZvcm0gbWF0MyB4Zm9ybTtcbmluIHZlYzIgcG9zaXRpb247XG5cbnZvaWQgbWFpbih2b2lkKSB7XG4gIGdsX1Bvc2l0aW9uID0gdmVjNCgoeGZvcm0gKiB2ZWMzKHBvc2l0aW9uLCAxKSkueHksIDAsIDEpO1xufVxuYDtcblxuY29uc3QgT0JTVEFDTEVfS0VSTkVMID0gYFxuICB2ZWM0IGtlcm5lbCgpIHtcbiAgICByZXR1cm4gdmVjNCgxLCAwLCAwLCAxKTtcbiAgfVxuYDtcblxubGV0IG9ic3RhY2xlVmVydGljZXM7XG5sZXQgb2JzdGFjbGVYZm9ybTtcblxuLy8gRHJhdyBvYnN0YWNsZSB0cmlhbmdsZXMgdG8gWFktc3BhY2Ugb2JzdGFjbGUgZ3JpZFxuZXhwb3J0IGRlZmF1bHQge1xuICBzZXRVcCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2VybmVsOiBPQlNUQUNMRV9LRVJORUwsXG4gICAgICB2ZXJ0ZXhTaGFkZXI6IE9CU1RBQ0xFX1ZFUlRFWF9TSEFERVIsXG4gICAgICBvdXRwdXQ6IHsgbmFtZTogJ3h5T2JzdGFjbGVHcmlkJyB9LFxuICAgICAgZHJhdzogKGdwZ3B1LCBwcm9ncmFtKSA9PiB7XG4gICAgICAgIGNvbnN0IGdsID0gZ3BncHUuZ2w7XG5cbiAgICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG5cbiAgICAgICAgaWYgKG9ic3RhY2xlVmVydGljZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGJ1ZiA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuXG4gICAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1Zik7XG4gICAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG9ic3RhY2xlVmVydGljZXMsIGdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwcm9ncmFtLnBvc2l0aW9uTG9jYXRpb24pO1xuICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIocHJvZ3JhbS5wb3NpdGlvbkxvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuXG4gICAgICAgICAgY29uc3QgeGZvcm1Mb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLmdsUHJvZ3JhbSwgJ3hmb3JtJyk7XG4gICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih4Zm9ybUxvY2F0aW9uLCBmYWxzZSwgb2JzdGFjbGVYZm9ybS5lbGVtZW50cyk7XG5cbiAgICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlRSSUFOR0xFUywgMCwgb2JzdGFjbGVWZXJ0aWNlcy5sZW5ndGggLyAyKTtcblxuICAgICAgICAgIGdsLmRlbGV0ZUJ1ZmZlcihidWYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGUoY29uZmlnLCB4eVdpZHRoLCB4eUhlaWdodCwgeHlDZW50ZXJQb2ludCwgdmVoaWNsZVhmb3JtLCBvYnN0YWNsZXMpIHtcbiAgICBvYnN0YWNsZVZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheShBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBvYnN0YWNsZXMubWFwKG8gPT4gby52ZXJ0aWNlcykpKTtcblxuICAgIGNvbnN0IHRyYW5zbGF0ZSA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG4gICAgdHJhbnNsYXRlLnNldChcbiAgICAgIDEsIDAsIC14eUNlbnRlclBvaW50LngsXG4gICAgICAwLCAxLCAteHlDZW50ZXJQb2ludC55LFxuICAgICAgMCwgMCwgMVxuICAgICk7XG5cbiAgICBjb25zdCBzY2FsZSA9IG5ldyBUSFJFRS5NYXRyaXgzKCk7XG4gICAgc2NhbGUuc2V0KFxuICAgICAgMiAvICh4eVdpZHRoICogY29uZmlnLnh5R3JpZENlbGxTaXplKSwgMCwgMCxcbiAgICAgIDAsIDIgLyAoeHlIZWlnaHQgKiBjb25maWcueHlHcmlkQ2VsbFNpemUpLCAwLFxuICAgICAgMCwgMCwgMVxuICAgICk7XG5cbiAgICBvYnN0YWNsZVhmb3JtID0gc2NhbGUubXVsdGlwbHkodHJhbnNsYXRlKS5tdWx0aXBseSh2ZWhpY2xlWGZvcm0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB4eVdpZHRoLFxuICAgICAgaGVpZ2h0OiB4eUhlaWdodFxuICAgIH1cbiAgfVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/autonomy/path-planning/gpgpu-programs/xyObstacleGrid.js\n");

/***/ }),

/***/ "./js/autonomy/path-planning/gpgpu-programs/xyslMap.js":
/*!*************************************************************!*\
  !*** ./js/autonomy/path-planning/gpgpu-programs/xyslMap.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nconst XYSL_MAP_KERNEL = `\n\nvec4 kernel() {\n  vec2 xy = (kernelPosition - 0.5) * vec2(kernelSize) * vec2(xyGridCellSize) + xyCenterPoint;\n\n  int numSamples = textureSize(centerline, 0).x;\n  int closest = 0;\n  float closestDist = distance(xy, texelFetch(centerline, ivec2(0, 0), 0).xy);\n  for (int i = 1; i < numSamples; i++) {\n    float dist = distance(xy, texelFetch(centerline, ivec2(i, 0), 0).xy);\n    if (dist < closestDist) {\n      closestDist = dist;\n      closest = i;\n    }\n  }\n\n  vec2 closestPos = texelFetch(centerline, ivec2(closest, 0), 0).xy;\n  vec2 prev, next;\n  int prevIndex, nextIndex;\n\n  if (closest == 0) {\n    prevIndex = 0;\n    nextIndex = 1;\n    prev = closestPos;\n    next = texelFetch(centerline, ivec2(1, 0), 0).xy;\n  } else if (closest == numSamples - 1) {\n    prevIndex = closest - 1;\n    nextIndex = closest;\n    prev = texelFetch(centerline, ivec2(prevIndex, 0), 0).xy;\n    next = closestPos;\n  } else {\n    vec2 before = texelFetch(centerline, ivec2(closest - 1, 0), 0).xy;\n    vec2 after = texelFetch(centerline, ivec2(closest + 1, 0), 0).xy;\n\n    if (distance(before, xy) < distance(after, xy)) {\n      prevIndex = closest - 1;\n      nextIndex = closest;\n      prev = before;\n      next = closestPos;\n    } else {\n      prevIndex = closest;\n      nextIndex = closest + 1;\n      prev = closestPos;\n      next = after;\n    }\n  }\n\n  float dist = distance(prev, next);\n  float progress = clamp(dot(xy - prev, next - prev) / dist / dist, 0.0, 1.0);\n  vec2 projectedPos = (next - prev) * vec2(progress) + prev;\n\n  return vec4(\n    (float(prevIndex) + progress) * centerlineStationInterval,\n    sign(determinant(mat2(next - prev, xy - prev))) * distance(xy, projectedPos),\n    0,\n    0\n  );\n}\n\n`;\n\n// Build XY-SL map\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  setUp() {\n    return {\n      kernel: XYSL_MAP_KERNEL,\n      output: { name: 'xyslMap', filter: 'linear' },\n      uniforms: {\n        centerline: { type: 'sharedTexture' },\n        xyCenterPoint: { type: 'vec2' },\n        xyGridCellSize: { type: 'float'},\n        centerlineStationInterval: { type: 'float'}\n      }\n    };\n  },\n\n  update(config, xyWidth, xyHeight, xyCenterPoint) {\n    return {\n      width: xyWidth,\n      height: xyHeight,\n      uniforms: {\n        xyCenterPoint: [xyCenterPoint.x, xyCenterPoint.y],\n        xyGridCellSize: config.xyGridCellSize,\n        centerlineStationInterval: config.centerlineStationInterval\n      }\n    };\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL2dwZ3B1LXByb2dyYW1zL3h5c2xNYXAuanM/NWJhOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3Qyx3QkFBd0IsZUFBZTtBQUN2Qyx5QkFBeUIsZUFBZTtBQUN4QyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vanMvYXV0b25vbXkvcGF0aC1wbGFubmluZy9ncGdwdS1wcm9ncmFtcy94eXNsTWFwLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgWFlTTF9NQVBfS0VSTkVMID0gYFxuXG52ZWM0IGtlcm5lbCgpIHtcbiAgdmVjMiB4eSA9IChrZXJuZWxQb3NpdGlvbiAtIDAuNSkgKiB2ZWMyKGtlcm5lbFNpemUpICogdmVjMih4eUdyaWRDZWxsU2l6ZSkgKyB4eUNlbnRlclBvaW50O1xuXG4gIGludCBudW1TYW1wbGVzID0gdGV4dHVyZVNpemUoY2VudGVybGluZSwgMCkueDtcbiAgaW50IGNsb3Nlc3QgPSAwO1xuICBmbG9hdCBjbG9zZXN0RGlzdCA9IGRpc3RhbmNlKHh5LCB0ZXhlbEZldGNoKGNlbnRlcmxpbmUsIGl2ZWMyKDAsIDApLCAwKS54eSk7XG4gIGZvciAoaW50IGkgPSAxOyBpIDwgbnVtU2FtcGxlczsgaSsrKSB7XG4gICAgZmxvYXQgZGlzdCA9IGRpc3RhbmNlKHh5LCB0ZXhlbEZldGNoKGNlbnRlcmxpbmUsIGl2ZWMyKGksIDApLCAwKS54eSk7XG4gICAgaWYgKGRpc3QgPCBjbG9zZXN0RGlzdCkge1xuICAgICAgY2xvc2VzdERpc3QgPSBkaXN0O1xuICAgICAgY2xvc2VzdCA9IGk7XG4gICAgfVxuICB9XG5cbiAgdmVjMiBjbG9zZXN0UG9zID0gdGV4ZWxGZXRjaChjZW50ZXJsaW5lLCBpdmVjMihjbG9zZXN0LCAwKSwgMCkueHk7XG4gIHZlYzIgcHJldiwgbmV4dDtcbiAgaW50IHByZXZJbmRleCwgbmV4dEluZGV4O1xuXG4gIGlmIChjbG9zZXN0ID09IDApIHtcbiAgICBwcmV2SW5kZXggPSAwO1xuICAgIG5leHRJbmRleCA9IDE7XG4gICAgcHJldiA9IGNsb3Nlc3RQb3M7XG4gICAgbmV4dCA9IHRleGVsRmV0Y2goY2VudGVybGluZSwgaXZlYzIoMSwgMCksIDApLnh5O1xuICB9IGVsc2UgaWYgKGNsb3Nlc3QgPT0gbnVtU2FtcGxlcyAtIDEpIHtcbiAgICBwcmV2SW5kZXggPSBjbG9zZXN0IC0gMTtcbiAgICBuZXh0SW5kZXggPSBjbG9zZXN0O1xuICAgIHByZXYgPSB0ZXhlbEZldGNoKGNlbnRlcmxpbmUsIGl2ZWMyKHByZXZJbmRleCwgMCksIDApLnh5O1xuICAgIG5leHQgPSBjbG9zZXN0UG9zO1xuICB9IGVsc2Uge1xuICAgIHZlYzIgYmVmb3JlID0gdGV4ZWxGZXRjaChjZW50ZXJsaW5lLCBpdmVjMihjbG9zZXN0IC0gMSwgMCksIDApLnh5O1xuICAgIHZlYzIgYWZ0ZXIgPSB0ZXhlbEZldGNoKGNlbnRlcmxpbmUsIGl2ZWMyKGNsb3Nlc3QgKyAxLCAwKSwgMCkueHk7XG5cbiAgICBpZiAoZGlzdGFuY2UoYmVmb3JlLCB4eSkgPCBkaXN0YW5jZShhZnRlciwgeHkpKSB7XG4gICAgICBwcmV2SW5kZXggPSBjbG9zZXN0IC0gMTtcbiAgICAgIG5leHRJbmRleCA9IGNsb3Nlc3Q7XG4gICAgICBwcmV2ID0gYmVmb3JlO1xuICAgICAgbmV4dCA9IGNsb3Nlc3RQb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZJbmRleCA9IGNsb3Nlc3Q7XG4gICAgICBuZXh0SW5kZXggPSBjbG9zZXN0ICsgMTtcbiAgICAgIHByZXYgPSBjbG9zZXN0UG9zO1xuICAgICAgbmV4dCA9IGFmdGVyO1xuICAgIH1cbiAgfVxuXG4gIGZsb2F0IGRpc3QgPSBkaXN0YW5jZShwcmV2LCBuZXh0KTtcbiAgZmxvYXQgcHJvZ3Jlc3MgPSBjbGFtcChkb3QoeHkgLSBwcmV2LCBuZXh0IC0gcHJldikgLyBkaXN0IC8gZGlzdCwgMC4wLCAxLjApO1xuICB2ZWMyIHByb2plY3RlZFBvcyA9IChuZXh0IC0gcHJldikgKiB2ZWMyKHByb2dyZXNzKSArIHByZXY7XG5cbiAgcmV0dXJuIHZlYzQoXG4gICAgKGZsb2F0KHByZXZJbmRleCkgKyBwcm9ncmVzcykgKiBjZW50ZXJsaW5lU3RhdGlvbkludGVydmFsLFxuICAgIHNpZ24oZGV0ZXJtaW5hbnQobWF0MihuZXh0IC0gcHJldiwgeHkgLSBwcmV2KSkpICogZGlzdGFuY2UoeHksIHByb2plY3RlZFBvcyksXG4gICAgMCxcbiAgICAwXG4gICk7XG59XG5cbmA7XG5cbi8vIEJ1aWxkIFhZLVNMIG1hcFxuZXhwb3J0IGRlZmF1bHQge1xuICBzZXRVcCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2VybmVsOiBYWVNMX01BUF9LRVJORUwsXG4gICAgICBvdXRwdXQ6IHsgbmFtZTogJ3h5c2xNYXAnLCBmaWx0ZXI6ICdsaW5lYXInIH0sXG4gICAgICB1bmlmb3Jtczoge1xuICAgICAgICBjZW50ZXJsaW5lOiB7IHR5cGU6ICdzaGFyZWRUZXh0dXJlJyB9LFxuICAgICAgICB4eUNlbnRlclBvaW50OiB7IHR5cGU6ICd2ZWMyJyB9LFxuICAgICAgICB4eUdyaWRDZWxsU2l6ZTogeyB0eXBlOiAnZmxvYXQnfSxcbiAgICAgICAgY2VudGVybGluZVN0YXRpb25JbnRlcnZhbDogeyB0eXBlOiAnZmxvYXQnfVxuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlKGNvbmZpZywgeHlXaWR0aCwgeHlIZWlnaHQsIHh5Q2VudGVyUG9pbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHh5V2lkdGgsXG4gICAgICBoZWlnaHQ6IHh5SGVpZ2h0LFxuICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgeHlDZW50ZXJQb2ludDogW3h5Q2VudGVyUG9pbnQueCwgeHlDZW50ZXJQb2ludC55XSxcbiAgICAgICAgeHlHcmlkQ2VsbFNpemU6IGNvbmZpZy54eUdyaWRDZWxsU2l6ZSxcbiAgICAgICAgY2VudGVybGluZVN0YXRpb25JbnRlcnZhbDogY29uZmlnLmNlbnRlcmxpbmVTdGF0aW9uSW50ZXJ2YWxcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/autonomy/path-planning/gpgpu-programs/xyslMap.js\n");

/***/ }),

/***/ "./js/physics/Car.js":
/*!***************************!*\
  !*** ./js/physics/Car.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Car; });\nclass Car {\n  constructor(x = 0, y = 0, rotation = 0) {\n console.log('snir')\n   this.setPose(x, y, rotation);\n  }\n\n  static getFrontAxlePosition(pos, rot) {\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(Car.WHEEL_BASE).add(pos);\n  }\n\n  static getFakeAxlePosition(pos, rot) {\n    return Car.frontToRearAxlePosition(pos, rot);\n  }\n\n  static centerToRearAxlePosition(pos, rot) {\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(Car.REAR_AXLE_POS).add(pos);\n  }\n\n  static frontToRearAxlePosition(pos, rot) {\n    return THREE.Vector2.fromAngle(rot).multiplyScalar(-Car.WHEEL_BASE).add(pos);\n  }\n\n  get pose() {\n    return { pos: this.rearAxlePosition.clone(), rot: this.rotation, velocity: this.velocity, curv: this.curvature, dCurv: this.dCurv, ddCurv: this.ddCurv };\n  }\n\n  get curvature() {\n    return Math.tan(this.wheelAngle) / Car.WHEEL_BASE;\n  }\n\n  get rearAxlePosition() {\n    const { x, y } = this.position;\n    const rot = this.rotation;\n    return new THREE.Vector2(x + Math.cos(rot) * Car.REAR_AXLE_POS, y + Math.sin(rot) * Car.REAR_AXLE_POS);\n  }\n\n  get frontAxlePosition() {\n    const { x, y } = this.position;\n    const rot = this.rotation;\n    return new THREE.Vector2(x + Math.cos(rot) * Car.FRONT_AXLE_POS, y + Math.sin(rot) * Car.FRONT_AXLE_POS);\n  }\n\n  setPose(x, y, rotation) {\n    // Translate so that x and y become the center of the vehicle (instead of the center of the rear axle)\n    x -= Car.REAR_AXLE_POS * Math.cos(rotation);\n    y -= Car.REAR_AXLE_POS * Math.sin(rotation);\n\n    this.position = new THREE.Vector2(x, y);\n    this.rotation = Math.wrapAngle(rotation);\n    this.velocity = 0;\n    this.acceleration = 0;\n    this.wheelAngle = 0;\n    this.wheelAngularVelocity = 0;\n    this.dCurv = 0; // derivative with respect to arc length\n    this.ddCurv = 0; // derivative with respect to arc length\n  }\n\n  step(dt) {\n    const curvPrev = this.curvature;\n    const dCurvPrev = this.dCurv;\n\n    const drag = (0.5 * Car.DRAG_COEFF * Car.FRONTAL_AREA * Car.DENSITY_OF_AIR * Math.abs(this.velocity) + Car.ROLL_RESIST) * -this.velocity;\n    this.velocity += (this.acceleration + drag / Car.MASS) * dt;\n\n    const velocitySq = this.velocity * this.velocity;\n    const maxWheelAngle = Math.clamp(Math.atan(Car.MAX_LATERAL_ACCEL * Car.WHEEL_BASE / velocitySq), 0.07, Car.MAX_WHEEL_ANGLE);\n    this.wheelAngle = Math.clamp(Math.wrapAngle(this.wheelAngle + this.wheelAngularVelocity * dt), -maxWheelAngle, maxWheelAngle);\n\n    const angularVelocity = this.velocity * this.curvature;\n    this.rotation = Math.wrapAngle(this.rotation + angularVelocity * dt);\n\n    const dist = this.velocity * dt;\n    this.position = THREE.Vector2.fromAngle(this.rotation).multiplyScalar(dist).add(this.position);\n\n    this.dCurv = dist > 0.1 ? (this.curvature - curvPrev) / dist : 0;\n    this.ddCurv = dist > 0.1 ? (this.dCurv - dCurvPrev) / dist : 0;\n  }\n\n  update(controls, dt) {\n    const gas = Math.clamp(controls.gas, -1, +1);\n    const brake = Math.clamp(controls.brake, 0, 1);\n    const steer = Math.clamp(controls.steer, -1, +1);\n\n    if (brake > 0) {\n      this.acceleration = -Math.sign(this.velocity) * Car.MAX_BRAKE_DECEL * brake;\n      const newVelocity = this.velocity + this.acceleration * dt;\n\n      // If applying the braking deceleration at the next step would cause the velocity\n      // to change directions, then just set the car as stopped.\n      if (Math.sign(newVelocity) != Math.sign(this.velocity)) {\n        this.velocity = 0;\n        this.acceleration = 0;\n      }\n    } else {\n      this.acceleration = Car.MAX_GAS_ACCEL * gas;\n    }\n\n    if (steer != 0) {\n      this.wheelAngularVelocity = steer * Car.MAX_STEER_SPEED;\n    } else {\n      this.wheelAngularVelocity = Math.clamp(-this.wheelAngle / Car.MAX_WHEEL_ANGLE * this.velocity * this.velocity * dt, -Car.MAX_STEER_SPEED, Car.MAX_STEER_SPEED);\n    }\n    \n  }\n\n}\n\nCar.HALF_CAR_LENGTH = 2.5; // meters\nCar.HALF_CAR_WIDTH = 1; // meters\nCar.HALF_WHEEL_LENGTH = 0.38; // meters\nCar.HALF_WHEEL_WIDTH = 0.12; // meters\nCar.MAX_WHEEL_ANGLE = 32 / 180 * Math.PI; // radians\nCar.MASS = 1600; // kg\nCar.DRAG_COEFF = 0.7;\nCar.DENSITY_OF_AIR = 1.8580608; // (kg/m^3)\nCar.FRONTAL_AREA = 1.85; // m^2\nCar.ROLL_RESIST = 0;\nCar.MAX_STEER_SPEED = 0.8;//1.2; // Radians per second\nCar.MAX_GAS_ACCEL = 3.5; // m / s^2\nCar.MAX_BRAKE_DECEL = 6.5; // m / s^2\nCar.WHEEL_LATERAL_POS = 0.843; // meters\nCar.FRONT_AXLE_POS = 1.6; // meters\nCar.REAR_AXLE_POS = -1.43; // meters\nCar.WHEEL_BASE = Car.FRONT_AXLE_POS - Car.REAR_AXLE_POS; // meters\nCar.MAX_LATERAL_ACCEL = 9.81; // m / s^2\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9waHlzaWNzL0Nhci5qcz8yYzBlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSwwQkFBMEI7QUFDMUIsdUJBQXVCO0FBQ3ZCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUIseUNBQXlDO0FBQ3pDLGdCQUFnQjtBQUNoQjtBQUNBLCtCQUErQjtBQUMvQix3QkFBd0I7QUFDeEI7QUFDQSwwQkFBMEIsTUFBTTtBQUNoQyx3QkFBd0I7QUFDeEIsMEJBQTBCO0FBQzFCLDhCQUE4QjtBQUM5Qix5QkFBeUI7QUFDekIsMEJBQTBCO0FBQzFCLHdEQUF3RDtBQUN4RCw2QkFBNkIiLCJmaWxlIjoiLi9qcy9waHlzaWNzL0Nhci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGNsYXNzIENhciB7XG4gIGNvbnN0cnVjdG9yKHggPSAwLCB5ID0gMCwgcm90YXRpb24gPSAwKSB7XG4gICAgdGhpcy5zZXRQb3NlKHgsIHksIHJvdGF0aW9uKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRGcm9udEF4bGVQb3NpdGlvbihwb3MsIHJvdCkge1xuICAgIHJldHVybiBUSFJFRS5WZWN0b3IyLmZyb21BbmdsZShyb3QpLm11bHRpcGx5U2NhbGFyKENhci5XSEVFTF9CQVNFKS5hZGQocG9zKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXRGYWtlQXhsZVBvc2l0aW9uKHBvcywgcm90KSB7XG4gICAgcmV0dXJuIENhci5mcm9udFRvUmVhckF4bGVQb3NpdGlvbihwb3MsIHJvdCk7XG4gIH1cblxuICBzdGF0aWMgY2VudGVyVG9SZWFyQXhsZVBvc2l0aW9uKHBvcywgcm90KSB7XG4gICAgcmV0dXJuIFRIUkVFLlZlY3RvcjIuZnJvbUFuZ2xlKHJvdCkubXVsdGlwbHlTY2FsYXIoQ2FyLlJFQVJfQVhMRV9QT1MpLmFkZChwb3MpO1xuICB9XG5cbiAgc3RhdGljIGZyb250VG9SZWFyQXhsZVBvc2l0aW9uKHBvcywgcm90KSB7XG4gICAgcmV0dXJuIFRIUkVFLlZlY3RvcjIuZnJvbUFuZ2xlKHJvdCkubXVsdGlwbHlTY2FsYXIoLUNhci5XSEVFTF9CQVNFKS5hZGQocG9zKTtcbiAgfVxuXG4gIGdldCBwb3NlKCkge1xuICAgIHJldHVybiB7IHBvczogdGhpcy5yZWFyQXhsZVBvc2l0aW9uLmNsb25lKCksIHJvdDogdGhpcy5yb3RhdGlvbiwgdmVsb2NpdHk6IHRoaXMudmVsb2NpdHksIGN1cnY6IHRoaXMuY3VydmF0dXJlLCBkQ3VydjogdGhpcy5kQ3VydiwgZGRDdXJ2OiB0aGlzLmRkQ3VydiB9O1xuICB9XG5cbiAgZ2V0IGN1cnZhdHVyZSgpIHtcbiAgICByZXR1cm4gTWF0aC50YW4odGhpcy53aGVlbEFuZ2xlKSAvIENhci5XSEVFTF9CQVNFO1xuICB9XG5cbiAgZ2V0IHJlYXJBeGxlUG9zaXRpb24oKSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnBvc2l0aW9uO1xuICAgIGNvbnN0IHJvdCA9IHRoaXMucm90YXRpb247XG4gICAgcmV0dXJuIG5ldyBUSFJFRS5WZWN0b3IyKHggKyBNYXRoLmNvcyhyb3QpICogQ2FyLlJFQVJfQVhMRV9QT1MsIHkgKyBNYXRoLnNpbihyb3QpICogQ2FyLlJFQVJfQVhMRV9QT1MpO1xuICB9XG5cbiAgZ2V0IGZyb250QXhsZVBvc2l0aW9uKCkge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy5wb3NpdGlvbjtcbiAgICBjb25zdCByb3QgPSB0aGlzLnJvdGF0aW9uO1xuICAgIHJldHVybiBuZXcgVEhSRUUuVmVjdG9yMih4ICsgTWF0aC5jb3Mocm90KSAqIENhci5GUk9OVF9BWExFX1BPUywgeSArIE1hdGguc2luKHJvdCkgKiBDYXIuRlJPTlRfQVhMRV9QT1MpO1xuICB9XG5cbiAgc2V0UG9zZSh4LCB5LCByb3RhdGlvbikge1xuICAgIC8vIFRyYW5zbGF0ZSBzbyB0aGF0IHggYW5kIHkgYmVjb21lIHRoZSBjZW50ZXIgb2YgdGhlIHZlaGljbGUgKGluc3RlYWQgb2YgdGhlIGNlbnRlciBvZiB0aGUgcmVhciBheGxlKVxuICAgIHggLT0gQ2FyLlJFQVJfQVhMRV9QT1MgKiBNYXRoLmNvcyhyb3RhdGlvbik7XG4gICAgeSAtPSBDYXIuUkVBUl9BWExFX1BPUyAqIE1hdGguc2luKHJvdGF0aW9uKTtcblxuICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMih4LCB5KTtcbiAgICB0aGlzLnJvdGF0aW9uID0gTWF0aC53cmFwQW5nbGUocm90YXRpb24pO1xuICAgIHRoaXMudmVsb2NpdHkgPSAwO1xuICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gMDtcbiAgICB0aGlzLndoZWVsQW5nbGUgPSAwO1xuICAgIHRoaXMud2hlZWxBbmd1bGFyVmVsb2NpdHkgPSAwO1xuICAgIHRoaXMuZEN1cnYgPSAwOyAvLyBkZXJpdmF0aXZlIHdpdGggcmVzcGVjdCB0byBhcmMgbGVuZ3RoXG4gICAgdGhpcy5kZEN1cnYgPSAwOyAvLyBkZXJpdmF0aXZlIHdpdGggcmVzcGVjdCB0byBhcmMgbGVuZ3RoXG4gIH1cblxuICBzdGVwKGR0KSB7XG4gICAgY29uc3QgY3VydlByZXYgPSB0aGlzLmN1cnZhdHVyZTtcbiAgICBjb25zdCBkQ3VydlByZXYgPSB0aGlzLmRDdXJ2O1xuXG4gICAgY29uc3QgZHJhZyA9ICgwLjUgKiBDYXIuRFJBR19DT0VGRiAqIENhci5GUk9OVEFMX0FSRUEgKiBDYXIuREVOU0lUWV9PRl9BSVIgKiBNYXRoLmFicyh0aGlzLnZlbG9jaXR5KSArIENhci5ST0xMX1JFU0lTVCkgKiAtdGhpcy52ZWxvY2l0eTtcbiAgICB0aGlzLnZlbG9jaXR5ICs9ICh0aGlzLmFjY2VsZXJhdGlvbiArIGRyYWcgLyBDYXIuTUFTUykgKiBkdDtcblxuICAgIGNvbnN0IHZlbG9jaXR5U3EgPSB0aGlzLnZlbG9jaXR5ICogdGhpcy52ZWxvY2l0eTtcbiAgICBjb25zdCBtYXhXaGVlbEFuZ2xlID0gTWF0aC5jbGFtcChNYXRoLmF0YW4oQ2FyLk1BWF9MQVRFUkFMX0FDQ0VMICogQ2FyLldIRUVMX0JBU0UgLyB2ZWxvY2l0eVNxKSwgMC4wNywgQ2FyLk1BWF9XSEVFTF9BTkdMRSk7XG4gICAgdGhpcy53aGVlbEFuZ2xlID0gTWF0aC5jbGFtcChNYXRoLndyYXBBbmdsZSh0aGlzLndoZWVsQW5nbGUgKyB0aGlzLndoZWVsQW5ndWxhclZlbG9jaXR5ICogZHQpLCAtbWF4V2hlZWxBbmdsZSwgbWF4V2hlZWxBbmdsZSk7XG5cbiAgICBjb25zdCBhbmd1bGFyVmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5ICogdGhpcy5jdXJ2YXR1cmU7XG4gICAgdGhpcy5yb3RhdGlvbiA9IE1hdGgud3JhcEFuZ2xlKHRoaXMucm90YXRpb24gKyBhbmd1bGFyVmVsb2NpdHkgKiBkdCk7XG5cbiAgICBjb25zdCBkaXN0ID0gdGhpcy52ZWxvY2l0eSAqIGR0O1xuICAgIHRoaXMucG9zaXRpb24gPSBUSFJFRS5WZWN0b3IyLmZyb21BbmdsZSh0aGlzLnJvdGF0aW9uKS5tdWx0aXBseVNjYWxhcihkaXN0KS5hZGQodGhpcy5wb3NpdGlvbik7XG5cbiAgICB0aGlzLmRDdXJ2ID0gZGlzdCA+IDAuMSA/ICh0aGlzLmN1cnZhdHVyZSAtIGN1cnZQcmV2KSAvIGRpc3QgOiAwO1xuICAgIHRoaXMuZGRDdXJ2ID0gZGlzdCA+IDAuMSA/ICh0aGlzLmRDdXJ2IC0gZEN1cnZQcmV2KSAvIGRpc3QgOiAwO1xuICB9XG5cbiAgdXBkYXRlKGNvbnRyb2xzLCBkdCkge1xuICAgIGNvbnN0IGdhcyA9IE1hdGguY2xhbXAoY29udHJvbHMuZ2FzLCAtMSwgKzEpO1xuICAgIGNvbnN0IGJyYWtlID0gTWF0aC5jbGFtcChjb250cm9scy5icmFrZSwgMCwgMSk7XG4gICAgY29uc3Qgc3RlZXIgPSBNYXRoLmNsYW1wKGNvbnRyb2xzLnN0ZWVyLCAtMSwgKzEpO1xuXG4gICAgaWYgKGJyYWtlID4gMCkge1xuICAgICAgdGhpcy5hY2NlbGVyYXRpb24gPSAtTWF0aC5zaWduKHRoaXMudmVsb2NpdHkpICogQ2FyLk1BWF9CUkFLRV9ERUNFTCAqIGJyYWtlO1xuICAgICAgY29uc3QgbmV3VmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5ICsgdGhpcy5hY2NlbGVyYXRpb24gKiBkdDtcblxuICAgICAgLy8gSWYgYXBwbHlpbmcgdGhlIGJyYWtpbmcgZGVjZWxlcmF0aW9uIGF0IHRoZSBuZXh0IHN0ZXAgd291bGQgY2F1c2UgdGhlIHZlbG9jaXR5XG4gICAgICAvLyB0byBjaGFuZ2UgZGlyZWN0aW9ucywgdGhlbiBqdXN0IHNldCB0aGUgY2FyIGFzIHN0b3BwZWQuXG4gICAgICBpZiAoTWF0aC5zaWduKG5ld1ZlbG9jaXR5KSAhPSBNYXRoLnNpZ24odGhpcy52ZWxvY2l0eSkpIHtcbiAgICAgICAgdGhpcy52ZWxvY2l0eSA9IDA7XG4gICAgICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hY2NlbGVyYXRpb24gPSBDYXIuTUFYX0dBU19BQ0NFTCAqIGdhcztcbiAgICB9XG5cbiAgICBpZiAoc3RlZXIgIT0gMCkge1xuICAgICAgdGhpcy53aGVlbEFuZ3VsYXJWZWxvY2l0eSA9IHN0ZWVyICogQ2FyLk1BWF9TVEVFUl9TUEVFRDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53aGVlbEFuZ3VsYXJWZWxvY2l0eSA9IE1hdGguY2xhbXAoLXRoaXMud2hlZWxBbmdsZSAvIENhci5NQVhfV0hFRUxfQU5HTEUgKiB0aGlzLnZlbG9jaXR5ICogdGhpcy52ZWxvY2l0eSAqIGR0LCAtQ2FyLk1BWF9TVEVFUl9TUEVFRCwgQ2FyLk1BWF9TVEVFUl9TUEVFRCk7XG4gICAgfVxuICAgIFxuICB9XG5cbn1cblxuQ2FyLkhBTEZfQ0FSX0xFTkdUSCA9IDIuNTsgLy8gbWV0ZXJzXG5DYXIuSEFMRl9DQVJfV0lEVEggPSAxOyAvLyBtZXRlcnNcbkNhci5IQUxGX1dIRUVMX0xFTkdUSCA9IDAuMzg7IC8vIG1ldGVyc1xuQ2FyLkhBTEZfV0hFRUxfV0lEVEggPSAwLjEyOyAvLyBtZXRlcnNcbkNhci5NQVhfV0hFRUxfQU5HTEUgPSAzMiAvIDE4MCAqIE1hdGguUEk7IC8vIHJhZGlhbnNcbkNhci5NQVNTID0gMTYwMDsgLy8ga2dcbkNhci5EUkFHX0NPRUZGID0gMC43O1xuQ2FyLkRFTlNJVFlfT0ZfQUlSID0gMS44NTgwNjA4OyAvLyAoa2cvbV4zKVxuQ2FyLkZST05UQUxfQVJFQSA9IDEuODU7IC8vIG1eMlxuQ2FyLlJPTExfUkVTSVNUID0gMDtcbkNhci5NQVhfU1RFRVJfU1BFRUQgPSAwLjg7Ly8xLjI7IC8vIFJhZGlhbnMgcGVyIHNlY29uZFxuQ2FyLk1BWF9HQVNfQUNDRUwgPSAzLjU7IC8vIG0gLyBzXjJcbkNhci5NQVhfQlJBS0VfREVDRUwgPSA2LjU7IC8vIG0gLyBzXjJcbkNhci5XSEVFTF9MQVRFUkFMX1BPUyA9IDAuODQzOyAvLyBtZXRlcnNcbkNhci5GUk9OVF9BWExFX1BPUyA9IDEuNjsgLy8gbWV0ZXJzXG5DYXIuUkVBUl9BWExFX1BPUyA9IC0xLjQzOyAvLyBtZXRlcnNcbkNhci5XSEVFTF9CQVNFID0gQ2FyLkZST05UX0FYTEVfUE9TIC0gQ2FyLlJFQVJfQVhMRV9QT1M7IC8vIG1ldGVyc1xuQ2FyLk1BWF9MQVRFUkFMX0FDQ0VMID0gOS44MTsgLy8gbSAvIHNeMlxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/physics/Car.js\n");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./js/Utils.js":
/*!***********************************************!*\
  !*** ./node_modules/raw-loader!./js/Utils.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"Math.clamp = (number, min, max) => Math.max(min, Math.min(number, max));\\n\\nMath.wrapAngle = (angle) => {\\n  angle = angle % (Math.PI * 2);\\n  if (angle <= -Math.PI) return angle + Math.PI * 2;\\n  else if (angle > Math.PI) return angle - Math.PI * 2;\\n  else return angle;\\n}\\n\\nTHREE.Vector2.fromAngle = (angle) => new THREE.Vector2(Math.cos(angle), Math.sin(angle));\\n\\nTHREE.Curve.prototype.getCurvatureAt = function(u) {\\n  let t2 = this.getUtoTmapping(u);\\n\\n  const delta = 0.0001;\\n  let t1 = t2 - delta;\\n  let t3 = t2 + delta;\\n\\n  if (t1 < 0) {\\n    t1 = 0;\\n    t2 = delta;\\n    t3 = 2 * delta;\\n  }\\n\\n  if (t3 > 1) {\\n    t3 = 1;\\n    t2 = 1 - delta;\\n    t1 = 1 - 2 * delta;\\n  }\\n\\n  const p1 = this.getPoint(t1);\\n  const p2 = this.getPoint(t2);\\n  const p3 = this.getPoint(t3);\\n\\n  return (Math.atan2(p3.y - p2.y, p3.x - p2.x) - Math.atan2(p2.y - p1.y, p2.x - p1.x)) / p2.distanceTo(p1);\\n};\\n\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9VdGlscy5qcz83NTllIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDBGQUEwRixpQ0FBaUMsa0NBQWtDLHNEQUFzRCx5REFBeUQsc0JBQXNCLEdBQUcsNkZBQTZGLHdEQUF3RCxvQ0FBb0MsMkJBQTJCLHdCQUF3Qix3QkFBd0IsbUJBQW1CLGFBQWEsaUJBQWlCLHFCQUFxQixLQUFLLG1CQUFtQixhQUFhLHFCQUFxQix5QkFBeUIsS0FBSyxtQ0FBbUMsaUNBQWlDLGlDQUFpQywrR0FBK0csSUFBSSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS4vanMvVXRpbHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiTWF0aC5jbGFtcCA9IChudW1iZXIsIG1pbiwgbWF4KSA9PiBNYXRoLm1heChtaW4sIE1hdGgubWluKG51bWJlciwgbWF4KSk7XFxuXFxuTWF0aC53cmFwQW5nbGUgPSAoYW5nbGUpID0+IHtcXG4gIGFuZ2xlID0gYW5nbGUgJSAoTWF0aC5QSSAqIDIpO1xcbiAgaWYgKGFuZ2xlIDw9IC1NYXRoLlBJKSByZXR1cm4gYW5nbGUgKyBNYXRoLlBJICogMjtcXG4gIGVsc2UgaWYgKGFuZ2xlID4gTWF0aC5QSSkgcmV0dXJuIGFuZ2xlIC0gTWF0aC5QSSAqIDI7XFxuICBlbHNlIHJldHVybiBhbmdsZTtcXG59XFxuXFxuVEhSRUUuVmVjdG9yMi5mcm9tQW5nbGUgPSAoYW5nbGUpID0+IG5ldyBUSFJFRS5WZWN0b3IyKE1hdGguY29zKGFuZ2xlKSwgTWF0aC5zaW4oYW5nbGUpKTtcXG5cXG5USFJFRS5DdXJ2ZS5wcm90b3R5cGUuZ2V0Q3VydmF0dXJlQXQgPSBmdW5jdGlvbih1KSB7XFxuICBsZXQgdDIgPSB0aGlzLmdldFV0b1RtYXBwaW5nKHUpO1xcblxcbiAgY29uc3QgZGVsdGEgPSAwLjAwMDE7XFxuICBsZXQgdDEgPSB0MiAtIGRlbHRhO1xcbiAgbGV0IHQzID0gdDIgKyBkZWx0YTtcXG5cXG4gIGlmICh0MSA8IDApIHtcXG4gICAgdDEgPSAwO1xcbiAgICB0MiA9IGRlbHRhO1xcbiAgICB0MyA9IDIgKiBkZWx0YTtcXG4gIH1cXG5cXG4gIGlmICh0MyA+IDEpIHtcXG4gICAgdDMgPSAxO1xcbiAgICB0MiA9IDEgLSBkZWx0YTtcXG4gICAgdDEgPSAxIC0gMiAqIGRlbHRhO1xcbiAgfVxcblxcbiAgY29uc3QgcDEgPSB0aGlzLmdldFBvaW50KHQxKTtcXG4gIGNvbnN0IHAyID0gdGhpcy5nZXRQb2ludCh0Mik7XFxuICBjb25zdCBwMyA9IHRoaXMuZ2V0UG9pbnQodDMpO1xcblxcbiAgcmV0dXJuIChNYXRoLmF0YW4yKHAzLnkgLSBwMi55LCBwMy54IC0gcDIueCkgLSBNYXRoLmF0YW4yKHAyLnkgLSBwMS55LCBwMi54IC0gcDEueCkpIC8gcDIuZGlzdGFuY2VUbyhwMSk7XFxufTtcXG5cIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/raw-loader/index.js!./js/Utils.js\n");

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./vendor/three.js":
/*!***************************************************!*\
  !*** ./node_modules/raw-loader!./vendor/three.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"(function (global, factory) {\\n\\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\\n\\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\\n\\t(factory((global.THREE = {})));\\n}(this, (function (exports) { 'use strict';\\n\\n\\t// Polyfills\\n\\n\\tif ( Number.EPSILON === undefined ) {\\n\\n\\t\\tNumber.EPSILON = Math.pow( 2, - 52 );\\n\\n\\t}\\n\\n\\tif ( Number.isInteger === undefined ) {\\n\\n\\t\\t// Missing in IE\\n\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger\\n\\n\\t\\tNumber.isInteger = function ( value ) {\\n\\n\\t\\t\\treturn typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t//\\n\\n\\tif ( Math.sign === undefined ) {\\n\\n\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\\n\\n\\t\\tMath.sign = function ( x ) {\\n\\n\\t\\t\\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\tif ( 'name' in Function.prototype === false ) {\\n\\n\\t\\t// Missing in IE\\n\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\\n\\n\\t\\tObject.defineProperty( Function.prototype, 'name', {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.toString().match( /^\\\\s*function\\\\s*([^\\\\(\\\\s]*)/ )[ 1 ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t} );\\n\\n\\t}\\n\\n\\tif ( Object.assign === undefined ) {\\n\\n\\t\\t// Missing in IE\\n\\t\\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\\n\\n\\t\\t( function () {\\n\\n\\t\\t\\tObject.assign = function ( target ) {\\n\\n\\t\\t\\t\\tif ( target === undefined || target === null ) {\\n\\n\\t\\t\\t\\t\\tthrow new TypeError( 'Cannot convert undefined or null to object' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar output = Object( target );\\n\\n\\t\\t\\t\\tfor ( var index = 1; index < arguments.length; index ++ ) {\\n\\n\\t\\t\\t\\t\\tvar source = arguments[ index ];\\n\\n\\t\\t\\t\\t\\tif ( source !== undefined && source !== null ) {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var nextKey in source ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\toutput[ nextKey ] = source[ nextKey ];\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn output;\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )();\\n\\n\\t}\\n\\n\\t/**\\n\\t * https://github.com/mrdoob/eventdispatcher.js/\\n\\t */\\n\\n\\tfunction EventDispatcher() {}\\n\\n\\tObject.assign( EventDispatcher.prototype, {\\n\\n\\t\\taddEventListener: function ( type, listener ) {\\n\\n\\t\\t\\tif ( this._listeners === undefined ) this._listeners = {};\\n\\n\\t\\t\\tvar listeners = this._listeners;\\n\\n\\t\\t\\tif ( listeners[ type ] === undefined ) {\\n\\n\\t\\t\\t\\tlisteners[ type ] = [];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\\n\\n\\t\\t\\t\\tlisteners[ type ].push( listener );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\thasEventListener: function ( type, listener ) {\\n\\n\\t\\t\\tif ( this._listeners === undefined ) return false;\\n\\n\\t\\t\\tvar listeners = this._listeners;\\n\\n\\t\\t\\treturn listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;\\n\\n\\t\\t},\\n\\n\\t\\tremoveEventListener: function ( type, listener ) {\\n\\n\\t\\t\\tif ( this._listeners === undefined ) return;\\n\\n\\t\\t\\tvar listeners = this._listeners;\\n\\t\\t\\tvar listenerArray = listeners[ type ];\\n\\n\\t\\t\\tif ( listenerArray !== undefined ) {\\n\\n\\t\\t\\t\\tvar index = listenerArray.indexOf( listener );\\n\\n\\t\\t\\t\\tif ( index !== - 1 ) {\\n\\n\\t\\t\\t\\t\\tlistenerArray.splice( index, 1 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tdispatchEvent: function ( event ) {\\n\\n\\t\\t\\tif ( this._listeners === undefined ) return;\\n\\n\\t\\t\\tvar listeners = this._listeners;\\n\\t\\t\\tvar listenerArray = listeners[ event.type ];\\n\\n\\t\\t\\tif ( listenerArray !== undefined ) {\\n\\n\\t\\t\\t\\tevent.target = this;\\n\\n\\t\\t\\t\\tvar array = listenerArray.slice( 0 );\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tarray[ i ].call( this, event );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tvar REVISION = '89';\\n\\tvar MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };\\n\\tvar CullFaceNone = 0;\\n\\tvar CullFaceBack = 1;\\n\\tvar CullFaceFront = 2;\\n\\tvar CullFaceFrontBack = 3;\\n\\tvar FrontFaceDirectionCW = 0;\\n\\tvar FrontFaceDirectionCCW = 1;\\n\\tvar BasicShadowMap = 0;\\n\\tvar PCFShadowMap = 1;\\n\\tvar PCFSoftShadowMap = 2;\\n\\tvar FrontSide = 0;\\n\\tvar BackSide = 1;\\n\\tvar DoubleSide = 2;\\n\\tvar FlatShading = 1;\\n\\tvar SmoothShading = 2;\\n\\tvar NoColors = 0;\\n\\tvar FaceColors = 1;\\n\\tvar VertexColors = 2;\\n\\tvar NoBlending = 0;\\n\\tvar NormalBlending = 1;\\n\\tvar AdditiveBlending = 2;\\n\\tvar SubtractiveBlending = 3;\\n\\tvar MultiplyBlending = 4;\\n\\tvar CustomBlending = 5;\\n\\tvar AddEquation = 100;\\n\\tvar SubtractEquation = 101;\\n\\tvar ReverseSubtractEquation = 102;\\n\\tvar MinEquation = 103;\\n\\tvar MaxEquation = 104;\\n\\tvar ZeroFactor = 200;\\n\\tvar OneFactor = 201;\\n\\tvar SrcColorFactor = 202;\\n\\tvar OneMinusSrcColorFactor = 203;\\n\\tvar SrcAlphaFactor = 204;\\n\\tvar OneMinusSrcAlphaFactor = 205;\\n\\tvar DstAlphaFactor = 206;\\n\\tvar OneMinusDstAlphaFactor = 207;\\n\\tvar DstColorFactor = 208;\\n\\tvar OneMinusDstColorFactor = 209;\\n\\tvar SrcAlphaSaturateFactor = 210;\\n\\tvar NeverDepth = 0;\\n\\tvar AlwaysDepth = 1;\\n\\tvar LessDepth = 2;\\n\\tvar LessEqualDepth = 3;\\n\\tvar EqualDepth = 4;\\n\\tvar GreaterEqualDepth = 5;\\n\\tvar GreaterDepth = 6;\\n\\tvar NotEqualDepth = 7;\\n\\tvar MultiplyOperation = 0;\\n\\tvar MixOperation = 1;\\n\\tvar AddOperation = 2;\\n\\tvar NoToneMapping = 0;\\n\\tvar LinearToneMapping = 1;\\n\\tvar ReinhardToneMapping = 2;\\n\\tvar Uncharted2ToneMapping = 3;\\n\\tvar CineonToneMapping = 4;\\n\\tvar UVMapping = 300;\\n\\tvar CubeReflectionMapping = 301;\\n\\tvar CubeRefractionMapping = 302;\\n\\tvar EquirectangularReflectionMapping = 303;\\n\\tvar EquirectangularRefractionMapping = 304;\\n\\tvar SphericalReflectionMapping = 305;\\n\\tvar CubeUVReflectionMapping = 306;\\n\\tvar CubeUVRefractionMapping = 307;\\n\\tvar RepeatWrapping = 1000;\\n\\tvar ClampToEdgeWrapping = 1001;\\n\\tvar MirroredRepeatWrapping = 1002;\\n\\tvar NearestFilter = 1003;\\n\\tvar NearestMipMapNearestFilter = 1004;\\n\\tvar NearestMipMapLinearFilter = 1005;\\n\\tvar LinearFilter = 1006;\\n\\tvar LinearMipMapNearestFilter = 1007;\\n\\tvar LinearMipMapLinearFilter = 1008;\\n\\tvar UnsignedByteType = 1009;\\n\\tvar ByteType = 1010;\\n\\tvar ShortType = 1011;\\n\\tvar UnsignedShortType = 1012;\\n\\tvar IntType = 1013;\\n\\tvar UnsignedIntType = 1014;\\n\\tvar FloatType = 1015;\\n\\tvar HalfFloatType = 1016;\\n\\tvar UnsignedShort4444Type = 1017;\\n\\tvar UnsignedShort5551Type = 1018;\\n\\tvar UnsignedShort565Type = 1019;\\n\\tvar UnsignedInt248Type = 1020;\\n\\tvar AlphaFormat = 1021;\\n\\tvar RGBFormat = 1022;\\n\\tvar RGBAFormat = 1023;\\n\\tvar LuminanceFormat = 1024;\\n\\tvar LuminanceAlphaFormat = 1025;\\n\\tvar RGBEFormat = RGBAFormat;\\n\\tvar DepthFormat = 1026;\\n\\tvar DepthStencilFormat = 1027;\\n\\tvar RGB_S3TC_DXT1_Format = 2001;\\n\\tvar RGBA_S3TC_DXT1_Format = 2002;\\n\\tvar RGBA_S3TC_DXT3_Format = 2003;\\n\\tvar RGBA_S3TC_DXT5_Format = 2004;\\n\\tvar RGB_PVRTC_4BPPV1_Format = 2100;\\n\\tvar RGB_PVRTC_2BPPV1_Format = 2101;\\n\\tvar RGBA_PVRTC_4BPPV1_Format = 2102;\\n\\tvar RGBA_PVRTC_2BPPV1_Format = 2103;\\n\\tvar RGB_ETC1_Format = 2151;\\n\\tvar LoopOnce = 2200;\\n\\tvar LoopRepeat = 2201;\\n\\tvar LoopPingPong = 2202;\\n\\tvar InterpolateDiscrete = 2300;\\n\\tvar InterpolateLinear = 2301;\\n\\tvar InterpolateSmooth = 2302;\\n\\tvar ZeroCurvatureEnding = 2400;\\n\\tvar ZeroSlopeEnding = 2401;\\n\\tvar WrapAroundEnding = 2402;\\n\\tvar TrianglesDrawMode = 0;\\n\\tvar TriangleStripDrawMode = 1;\\n\\tvar TriangleFanDrawMode = 2;\\n\\tvar LinearEncoding = 3000;\\n\\tvar sRGBEncoding = 3001;\\n\\tvar GammaEncoding = 3007;\\n\\tvar RGBEEncoding = 3002;\\n\\tvar LogLuvEncoding = 3003;\\n\\tvar RGBM7Encoding = 3004;\\n\\tvar RGBM16Encoding = 3005;\\n\\tvar RGBDEncoding = 3006;\\n\\tvar BasicDepthPacking = 3200;\\n\\tvar RGBADepthPacking = 3201;\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar _Math = {\\n\\n\\t\\tDEG2RAD: Math.PI / 180,\\n\\t\\tRAD2DEG: 180 / Math.PI,\\n\\n\\t\\tgenerateUUID: ( function () {\\n\\n\\t\\t\\t// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136\\n\\n\\t\\t\\tvar lut = [];\\n\\n\\t\\t\\tfor ( var i = 0; i < 256; i ++ ) {\\n\\n\\t\\t\\t\\tlut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 ).toUpperCase();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn function () {\\n\\n\\t\\t\\t\\tvar d0 = Math.random() * 0xffffffff | 0;\\n\\t\\t\\t\\tvar d1 = Math.random() * 0xffffffff | 0;\\n\\t\\t\\t\\tvar d2 = Math.random() * 0xffffffff | 0;\\n\\t\\t\\t\\tvar d3 = Math.random() * 0xffffffff | 0;\\n\\t\\t\\t\\treturn lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +\\n\\t\\t\\t\\t\\tlut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +\\n\\t\\t\\t\\t\\tlut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +\\n\\t\\t\\t\\t\\tlut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )(),\\n\\n\\t\\tclamp: function ( value, min, max ) {\\n\\n\\t\\t\\treturn Math.max( min, Math.min( max, value ) );\\n\\n\\t\\t},\\n\\n\\t\\t// compute euclidian modulo of m % n\\n\\t\\t// https://en.wikipedia.org/wiki/Modulo_operation\\n\\n\\t\\teuclideanModulo: function ( n, m ) {\\n\\n\\t\\t\\treturn ( ( n % m ) + m ) % m;\\n\\n\\t\\t},\\n\\n\\t\\t// Linear mapping from range <a1, a2> to range <b1, b2>\\n\\n\\t\\tmapLinear: function ( x, a1, a2, b1, b2 ) {\\n\\n\\t\\t\\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\\n\\n\\t\\t},\\n\\n\\t\\t// https://en.wikipedia.org/wiki/Linear_interpolation\\n\\n\\t\\tlerp: function ( x, y, t ) {\\n\\n\\t\\t\\treturn ( 1 - t ) * x + t * y;\\n\\n\\t\\t},\\n\\n\\t\\t// http://en.wikipedia.org/wiki/Smoothstep\\n\\n\\t\\tsmoothstep: function ( x, min, max ) {\\n\\n\\t\\t\\tif ( x <= min ) return 0;\\n\\t\\t\\tif ( x >= max ) return 1;\\n\\n\\t\\t\\tx = ( x - min ) / ( max - min );\\n\\n\\t\\t\\treturn x * x * ( 3 - 2 * x );\\n\\n\\t\\t},\\n\\n\\t\\tsmootherstep: function ( x, min, max ) {\\n\\n\\t\\t\\tif ( x <= min ) return 0;\\n\\t\\t\\tif ( x >= max ) return 1;\\n\\n\\t\\t\\tx = ( x - min ) / ( max - min );\\n\\n\\t\\t\\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\\n\\n\\t\\t},\\n\\n\\t\\t// Random integer from <low, high> interval\\n\\n\\t\\trandInt: function ( low, high ) {\\n\\n\\t\\t\\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\\n\\n\\t\\t},\\n\\n\\t\\t// Random float from <low, high> interval\\n\\n\\t\\trandFloat: function ( low, high ) {\\n\\n\\t\\t\\treturn low + Math.random() * ( high - low );\\n\\n\\t\\t},\\n\\n\\t\\t// Random float from <-range/2, range/2> interval\\n\\n\\t\\trandFloatSpread: function ( range ) {\\n\\n\\t\\t\\treturn range * ( 0.5 - Math.random() );\\n\\n\\t\\t},\\n\\n\\t\\tdegToRad: function ( degrees ) {\\n\\n\\t\\t\\treturn degrees * _Math.DEG2RAD;\\n\\n\\t\\t},\\n\\n\\t\\tradToDeg: function ( radians ) {\\n\\n\\t\\t\\treturn radians * _Math.RAD2DEG;\\n\\n\\t\\t},\\n\\n\\t\\tisPowerOfTwo: function ( value ) {\\n\\n\\t\\t\\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\\n\\n\\t\\t},\\n\\n\\t\\tceilPowerOfTwo: function ( value ) {\\n\\n\\t\\t\\treturn Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );\\n\\n\\t\\t},\\n\\n\\t\\tfloorPowerOfTwo: function ( value ) {\\n\\n\\t\\t\\treturn Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author philogb / http://blog.thejit.org/\\n\\t * @author egraether / http://egraether.com/\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t */\\n\\n\\tfunction Vector2( x, y ) {\\n\\n\\t\\tthis.x = x || 0;\\n\\t\\tthis.y = y || 0;\\n\\n\\t}\\n\\n\\tObject.defineProperties( Vector2.prototype, {\\n\\n\\t\\t\\\"width\\\": {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.x;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis.x = value;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t\\\"height\\\": {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.y;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis.y = value;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Vector2.prototype, {\\n\\n\\t\\tisVector2: true,\\n\\n\\t\\tset: function ( x, y ) {\\n\\n\\t\\t\\tthis.x = x;\\n\\t\\t\\tthis.y = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.x = scalar;\\n\\t\\t\\tthis.y = scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetX: function ( x ) {\\n\\n\\t\\t\\tthis.x = x;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetY: function ( y ) {\\n\\n\\t\\t\\tthis.y = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetComponent: function ( index, value ) {\\n\\n\\t\\t\\tswitch ( index ) {\\n\\n\\t\\t\\t\\tcase 0: this.x = value; break;\\n\\t\\t\\t\\tcase 1: this.y = value; break;\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetComponent: function ( index ) {\\n\\n\\t\\t\\tswitch ( index ) {\\n\\n\\t\\t\\t\\tcase 0: return this.x;\\n\\t\\t\\t\\tcase 1: return this.y;\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.x, this.y );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( v ) {\\n\\n\\t\\t\\tthis.x = v.x;\\n\\t\\t\\tthis.y = v.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tadd: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.addVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x += v.x;\\n\\t\\t\\tthis.y += v.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScalar: function ( s ) {\\n\\n\\t\\t\\tthis.x += s;\\n\\t\\t\\tthis.y += s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x + b.x;\\n\\t\\t\\tthis.y = a.y + b.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScaledVector: function ( v, s ) {\\n\\n\\t\\t\\tthis.x += v.x * s;\\n\\t\\t\\tthis.y += v.y * s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsub: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.subVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x -= v.x;\\n\\t\\t\\tthis.y -= v.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsubScalar: function ( s ) {\\n\\n\\t\\t\\tthis.x -= s;\\n\\t\\t\\tthis.y -= s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsubVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x - b.x;\\n\\t\\t\\tthis.y = a.y - b.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiply: function ( v ) {\\n\\n\\t\\t\\tthis.x *= v.x;\\n\\t\\t\\tthis.y *= v.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.x *= scalar;\\n\\t\\t\\tthis.y *= scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdivide: function ( v ) {\\n\\n\\t\\t\\tthis.x /= v.x;\\n\\t\\t\\tthis.y /= v.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdivideScalar: function ( scalar ) {\\n\\n\\t\\t\\treturn this.multiplyScalar( 1 / scalar );\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix3: function ( m ) {\\n\\n\\t\\t\\tvar x = this.x, y = this.y;\\n\\t\\t\\tvar e = m.elements;\\n\\n\\t\\t\\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];\\n\\t\\t\\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmin: function ( v ) {\\n\\n\\t\\t\\tthis.x = Math.min( this.x, v.x );\\n\\t\\t\\tthis.y = Math.min( this.y, v.y );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmax: function ( v ) {\\n\\n\\t\\t\\tthis.x = Math.max( this.x, v.x );\\n\\t\\t\\tthis.y = Math.max( this.y, v.y );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclamp: function ( min, max ) {\\n\\n\\t\\t\\t// assumes min < max, componentwise\\n\\n\\t\\t\\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\\n\\t\\t\\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclampScalar: function () {\\n\\n\\t\\t\\tvar min = new Vector2();\\n\\t\\t\\tvar max = new Vector2();\\n\\n\\t\\t\\treturn function clampScalar( minVal, maxVal ) {\\n\\n\\t\\t\\t\\tmin.set( minVal, minVal );\\n\\t\\t\\t\\tmax.set( maxVal, maxVal );\\n\\n\\t\\t\\t\\treturn this.clamp( min, max );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclampLength: function ( min, max ) {\\n\\n\\t\\t\\tvar length = this.length();\\n\\n\\t\\t\\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\\n\\n\\t\\t},\\n\\n\\t\\tfloor: function () {\\n\\n\\t\\t\\tthis.x = Math.floor( this.x );\\n\\t\\t\\tthis.y = Math.floor( this.y );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tceil: function () {\\n\\n\\t\\t\\tthis.x = Math.ceil( this.x );\\n\\t\\t\\tthis.y = Math.ceil( this.y );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tround: function () {\\n\\n\\t\\t\\tthis.x = Math.round( this.x );\\n\\t\\t\\tthis.y = Math.round( this.y );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\troundToZero: function () {\\n\\n\\t\\t\\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\\n\\t\\t\\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tnegate: function () {\\n\\n\\t\\t\\tthis.x = - this.x;\\n\\t\\t\\tthis.y = - this.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdot: function ( v ) {\\n\\n\\t\\t\\treturn this.x * v.x + this.y * v.y;\\n\\n\\t\\t},\\n\\n\\t\\tlengthSq: function () {\\n\\n\\t\\t\\treturn this.x * this.x + this.y * this.y;\\n\\n\\t\\t},\\n\\n\\t\\tlength: function () {\\n\\n\\t\\t\\treturn Math.sqrt( this.x * this.x + this.y * this.y );\\n\\n\\t\\t},\\n\\n\\t\\tmanhattanLength: function () {\\n\\n\\t\\t\\treturn Math.abs( this.x ) + Math.abs( this.y );\\n\\n\\t\\t},\\n\\n\\t\\tnormalize: function () {\\n\\n\\t\\t\\treturn this.divideScalar( this.length() || 1 );\\n\\n\\t\\t},\\n\\n\\t\\tangle: function () {\\n\\n\\t\\t\\t// computes the angle in radians with respect to the positive x-axis\\n\\n\\t\\t\\tvar angle = Math.atan2( this.y, this.x );\\n\\n\\t\\t\\tif ( angle < 0 ) angle += 2 * Math.PI;\\n\\n\\t\\t\\treturn angle;\\n\\n\\t\\t},\\n\\n\\t\\tdistanceTo: function ( v ) {\\n\\n\\t\\t\\treturn Math.sqrt( this.distanceToSquared( v ) );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToSquared: function ( v ) {\\n\\n\\t\\t\\tvar dx = this.x - v.x, dy = this.y - v.y;\\n\\t\\t\\treturn dx * dx + dy * dy;\\n\\n\\t\\t},\\n\\n\\t\\tmanhattanDistanceTo: function ( v ) {\\n\\n\\t\\t\\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );\\n\\n\\t\\t},\\n\\n\\t\\tsetLength: function ( length ) {\\n\\n\\t\\t\\treturn this.normalize().multiplyScalar( length );\\n\\n\\t\\t},\\n\\n\\t\\tlerp: function ( v, alpha ) {\\n\\n\\t\\t\\tthis.x += ( v.x - this.x ) * alpha;\\n\\t\\t\\tthis.y += ( v.y - this.y ) * alpha;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tlerpVectors: function ( v1, v2, alpha ) {\\n\\n\\t\\t\\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( v ) {\\n\\n\\t\\t\\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis.x = array[ offset ];\\n\\t\\t\\tthis.y = array[ offset + 1 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tarray[ offset ] = this.x;\\n\\t\\t\\tarray[ offset + 1 ] = this.y;\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\tfromBufferAttribute: function ( attribute, index, offset ) {\\n\\n\\t\\t\\tif ( offset !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x = attribute.getX( index );\\n\\t\\t\\tthis.y = attribute.getY( index );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\trotateAround: function ( center, angle ) {\\n\\n\\t\\t\\tvar c = Math.cos( angle ), s = Math.sin( angle );\\n\\n\\t\\t\\tvar x = this.x - center.x;\\n\\t\\t\\tvar y = this.y - center.y;\\n\\n\\t\\t\\tthis.x = x * c - y * s + center.x;\\n\\t\\t\\tthis.y = x * s + y * c + center.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author supereggbert / http://www.paulbrunt.co.uk/\\n\\t * @author philogb / http://blog.thejit.org/\\n\\t * @author jordi_ros / http://plattsoft.com\\n\\t * @author D1plo1d / http://github.com/D1plo1d\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author timknip / http://www.floorplanner.com/\\n\\t * @author bhouston / http://clara.io\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction Matrix4() {\\n\\n\\t\\tthis.elements = [\\n\\n\\t\\t\\t1, 0, 0, 0,\\n\\t\\t\\t0, 1, 0, 0,\\n\\t\\t\\t0, 0, 1, 0,\\n\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t];\\n\\n\\t\\tif ( arguments.length > 0 ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tObject.assign( Matrix4.prototype, {\\n\\n\\t\\tisMatrix4: true,\\n\\n\\t\\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\\n\\t\\t\\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\\n\\t\\t\\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\\n\\t\\t\\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tidentity: function () {\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\t1, 0, 0, 0,\\n\\t\\t\\t\\t0, 1, 0, 0,\\n\\t\\t\\t\\t0, 0, 1, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new Matrix4().fromArray( this.elements );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( m ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar me = m.elements;\\n\\n\\t\\t\\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];\\n\\t\\t\\tte[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];\\n\\t\\t\\tte[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];\\n\\t\\t\\tte[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyPosition: function ( m ) {\\n\\n\\t\\t\\tvar te = this.elements, me = m.elements;\\n\\n\\t\\t\\tte[ 12 ] = me[ 12 ];\\n\\t\\t\\tte[ 13 ] = me[ 13 ];\\n\\t\\t\\tte[ 14 ] = me[ 14 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\textractBasis: function ( xAxis, yAxis, zAxis ) {\\n\\n\\t\\t\\txAxis.setFromMatrixColumn( this, 0 );\\n\\t\\t\\tyAxis.setFromMatrixColumn( this, 1 );\\n\\t\\t\\tzAxis.setFromMatrixColumn( this, 2 );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\\n\\n\\t\\t\\tthis.set(\\n\\t\\t\\t\\txAxis.x, yAxis.x, zAxis.x, 0,\\n\\t\\t\\t\\txAxis.y, yAxis.y, zAxis.y, 0,\\n\\t\\t\\t\\txAxis.z, yAxis.z, zAxis.z, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\textractRotation: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function extractRotation( m ) {\\n\\n\\t\\t\\t\\tvar te = this.elements;\\n\\t\\t\\t\\tvar me = m.elements;\\n\\n\\t\\t\\t\\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\\n\\t\\t\\t\\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\\n\\t\\t\\t\\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\\n\\n\\t\\t\\t\\tte[ 0 ] = me[ 0 ] * scaleX;\\n\\t\\t\\t\\tte[ 1 ] = me[ 1 ] * scaleX;\\n\\t\\t\\t\\tte[ 2 ] = me[ 2 ] * scaleX;\\n\\n\\t\\t\\t\\tte[ 4 ] = me[ 4 ] * scaleY;\\n\\t\\t\\t\\tte[ 5 ] = me[ 5 ] * scaleY;\\n\\t\\t\\t\\tte[ 6 ] = me[ 6 ] * scaleY;\\n\\n\\t\\t\\t\\tte[ 8 ] = me[ 8 ] * scaleZ;\\n\\t\\t\\t\\tte[ 9 ] = me[ 9 ] * scaleZ;\\n\\t\\t\\t\\tte[ 10 ] = me[ 10 ] * scaleZ;\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tmakeRotationFromEuler: function ( euler ) {\\n\\n\\t\\t\\tif ( ! ( euler && euler.isEuler ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar x = euler.x, y = euler.y, z = euler.z;\\n\\t\\t\\tvar a = Math.cos( x ), b = Math.sin( x );\\n\\t\\t\\tvar c = Math.cos( y ), d = Math.sin( y );\\n\\t\\t\\tvar e = Math.cos( z ), f = Math.sin( z );\\n\\n\\t\\t\\tif ( euler.order === 'XYZ' ) {\\n\\n\\t\\t\\t\\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\\n\\n\\t\\t\\t\\tte[ 0 ] = c * e;\\n\\t\\t\\t\\tte[ 4 ] = - c * f;\\n\\t\\t\\t\\tte[ 8 ] = d;\\n\\n\\t\\t\\t\\tte[ 1 ] = af + be * d;\\n\\t\\t\\t\\tte[ 5 ] = ae - bf * d;\\n\\t\\t\\t\\tte[ 9 ] = - b * c;\\n\\n\\t\\t\\t\\tte[ 2 ] = bf - ae * d;\\n\\t\\t\\t\\tte[ 6 ] = be + af * d;\\n\\t\\t\\t\\tte[ 10 ] = a * c;\\n\\n\\t\\t\\t} else if ( euler.order === 'YXZ' ) {\\n\\n\\t\\t\\t\\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\\n\\n\\t\\t\\t\\tte[ 0 ] = ce + df * b;\\n\\t\\t\\t\\tte[ 4 ] = de * b - cf;\\n\\t\\t\\t\\tte[ 8 ] = a * d;\\n\\n\\t\\t\\t\\tte[ 1 ] = a * f;\\n\\t\\t\\t\\tte[ 5 ] = a * e;\\n\\t\\t\\t\\tte[ 9 ] = - b;\\n\\n\\t\\t\\t\\tte[ 2 ] = cf * b - de;\\n\\t\\t\\t\\tte[ 6 ] = df + ce * b;\\n\\t\\t\\t\\tte[ 10 ] = a * c;\\n\\n\\t\\t\\t} else if ( euler.order === 'ZXY' ) {\\n\\n\\t\\t\\t\\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\\n\\n\\t\\t\\t\\tte[ 0 ] = ce - df * b;\\n\\t\\t\\t\\tte[ 4 ] = - a * f;\\n\\t\\t\\t\\tte[ 8 ] = de + cf * b;\\n\\n\\t\\t\\t\\tte[ 1 ] = cf + de * b;\\n\\t\\t\\t\\tte[ 5 ] = a * e;\\n\\t\\t\\t\\tte[ 9 ] = df - ce * b;\\n\\n\\t\\t\\t\\tte[ 2 ] = - a * d;\\n\\t\\t\\t\\tte[ 6 ] = b;\\n\\t\\t\\t\\tte[ 10 ] = a * c;\\n\\n\\t\\t\\t} else if ( euler.order === 'ZYX' ) {\\n\\n\\t\\t\\t\\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\\n\\n\\t\\t\\t\\tte[ 0 ] = c * e;\\n\\t\\t\\t\\tte[ 4 ] = be * d - af;\\n\\t\\t\\t\\tte[ 8 ] = ae * d + bf;\\n\\n\\t\\t\\t\\tte[ 1 ] = c * f;\\n\\t\\t\\t\\tte[ 5 ] = bf * d + ae;\\n\\t\\t\\t\\tte[ 9 ] = af * d - be;\\n\\n\\t\\t\\t\\tte[ 2 ] = - d;\\n\\t\\t\\t\\tte[ 6 ] = b * c;\\n\\t\\t\\t\\tte[ 10 ] = a * c;\\n\\n\\t\\t\\t} else if ( euler.order === 'YZX' ) {\\n\\n\\t\\t\\t\\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\\n\\n\\t\\t\\t\\tte[ 0 ] = c * e;\\n\\t\\t\\t\\tte[ 4 ] = bd - ac * f;\\n\\t\\t\\t\\tte[ 8 ] = bc * f + ad;\\n\\n\\t\\t\\t\\tte[ 1 ] = f;\\n\\t\\t\\t\\tte[ 5 ] = a * e;\\n\\t\\t\\t\\tte[ 9 ] = - b * e;\\n\\n\\t\\t\\t\\tte[ 2 ] = - d * e;\\n\\t\\t\\t\\tte[ 6 ] = ad * f + bc;\\n\\t\\t\\t\\tte[ 10 ] = ac - bd * f;\\n\\n\\t\\t\\t} else if ( euler.order === 'XZY' ) {\\n\\n\\t\\t\\t\\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\\n\\n\\t\\t\\t\\tte[ 0 ] = c * e;\\n\\t\\t\\t\\tte[ 4 ] = - f;\\n\\t\\t\\t\\tte[ 8 ] = d * e;\\n\\n\\t\\t\\t\\tte[ 1 ] = ac * f + bd;\\n\\t\\t\\t\\tte[ 5 ] = a * e;\\n\\t\\t\\t\\tte[ 9 ] = ad * f - bc;\\n\\n\\t\\t\\t\\tte[ 2 ] = bc * f - ad;\\n\\t\\t\\t\\tte[ 6 ] = b * e;\\n\\t\\t\\t\\tte[ 10 ] = bd * f + ac;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// last column\\n\\t\\t\\tte[ 3 ] = 0;\\n\\t\\t\\tte[ 7 ] = 0;\\n\\t\\t\\tte[ 11 ] = 0;\\n\\n\\t\\t\\t// bottom row\\n\\t\\t\\tte[ 12 ] = 0;\\n\\t\\t\\tte[ 13 ] = 0;\\n\\t\\t\\tte[ 14 ] = 0;\\n\\t\\t\\tte[ 15 ] = 1;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeRotationFromQuaternion: function ( q ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar x = q._x, y = q._y, z = q._z, w = q._w;\\n\\t\\t\\tvar x2 = x + x, y2 = y + y, z2 = z + z;\\n\\t\\t\\tvar xx = x * x2, xy = x * y2, xz = x * z2;\\n\\t\\t\\tvar yy = y * y2, yz = y * z2, zz = z * z2;\\n\\t\\t\\tvar wx = w * x2, wy = w * y2, wz = w * z2;\\n\\n\\t\\t\\tte[ 0 ] = 1 - ( yy + zz );\\n\\t\\t\\tte[ 4 ] = xy - wz;\\n\\t\\t\\tte[ 8 ] = xz + wy;\\n\\n\\t\\t\\tte[ 1 ] = xy + wz;\\n\\t\\t\\tte[ 5 ] = 1 - ( xx + zz );\\n\\t\\t\\tte[ 9 ] = yz - wx;\\n\\n\\t\\t\\tte[ 2 ] = xz - wy;\\n\\t\\t\\tte[ 6 ] = yz + wx;\\n\\t\\t\\tte[ 10 ] = 1 - ( xx + yy );\\n\\n\\t\\t\\t// last column\\n\\t\\t\\tte[ 3 ] = 0;\\n\\t\\t\\tte[ 7 ] = 0;\\n\\t\\t\\tte[ 11 ] = 0;\\n\\n\\t\\t\\t// bottom row\\n\\t\\t\\tte[ 12 ] = 0;\\n\\t\\t\\tte[ 13 ] = 0;\\n\\t\\t\\tte[ 14 ] = 0;\\n\\t\\t\\tte[ 15 ] = 1;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tlookAt: function () {\\n\\n\\t\\t\\tvar x = new Vector3();\\n\\t\\t\\tvar y = new Vector3();\\n\\t\\t\\tvar z = new Vector3();\\n\\n\\t\\t\\treturn function lookAt( eye, target, up ) {\\n\\n\\t\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\t\\tz.subVectors( eye, target );\\n\\n\\t\\t\\t\\tif ( z.lengthSq() === 0 ) {\\n\\n\\t\\t\\t\\t\\t// eye and target are in the same position\\n\\n\\t\\t\\t\\t\\tz.z = 1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tz.normalize();\\n\\t\\t\\t\\tx.crossVectors( up, z );\\n\\n\\t\\t\\t\\tif ( x.lengthSq() === 0 ) {\\n\\n\\t\\t\\t\\t\\t// up and z are parallel\\n\\n\\t\\t\\t\\t\\tif ( Math.abs( up.z ) === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\tz.x += 0.0001;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tz.z += 0.0001;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tz.normalize();\\n\\t\\t\\t\\t\\tx.crossVectors( up, z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tx.normalize();\\n\\t\\t\\t\\ty.crossVectors( z, x );\\n\\n\\t\\t\\t\\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\\n\\t\\t\\t\\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\\n\\t\\t\\t\\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tmultiply: function ( m, n ) {\\n\\n\\t\\t\\tif ( n !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.multiplyMatrices( m, n );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this.multiplyMatrices( this, m );\\n\\n\\t\\t},\\n\\n\\t\\tpremultiply: function ( m ) {\\n\\n\\t\\t\\treturn this.multiplyMatrices( m, this );\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyMatrices: function ( a, b ) {\\n\\n\\t\\t\\tvar ae = a.elements;\\n\\t\\t\\tvar be = b.elements;\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\\n\\t\\t\\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\\n\\t\\t\\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\\n\\t\\t\\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\\n\\n\\t\\t\\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\\n\\t\\t\\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\\n\\t\\t\\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\\n\\t\\t\\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\\n\\n\\t\\t\\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\\n\\t\\t\\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\\n\\t\\t\\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\\n\\t\\t\\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\\n\\n\\t\\t\\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\\n\\t\\t\\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\\n\\t\\t\\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\\n\\t\\t\\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\\n\\n\\t\\t\\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\\n\\t\\t\\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\\n\\t\\t\\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\\n\\t\\t\\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\\n\\n\\t\\t\\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\\n\\t\\t\\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\\n\\t\\t\\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\\n\\t\\t\\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyScalar: function ( s ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\\n\\t\\t\\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\\n\\t\\t\\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\\n\\t\\t\\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyToBufferAttribute: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function applyToBufferAttribute( attribute ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tv1.x = attribute.getX( i );\\n\\t\\t\\t\\t\\tv1.y = attribute.getY( i );\\n\\t\\t\\t\\t\\tv1.z = attribute.getZ( i );\\n\\n\\t\\t\\t\\t\\tv1.applyMatrix4( this );\\n\\n\\t\\t\\t\\t\\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn attribute;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tdeterminant: function () {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\\n\\t\\t\\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\\n\\t\\t\\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\\n\\t\\t\\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\\n\\n\\t\\t\\t//TODO: make this more efficient\\n\\t\\t\\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\\n\\n\\t\\t\\treturn (\\n\\t\\t\\t\\tn41 * (\\n\\t\\t\\t\\t\\t+ n14 * n23 * n32\\n\\t\\t\\t\\t\\t - n13 * n24 * n32\\n\\t\\t\\t\\t\\t - n14 * n22 * n33\\n\\t\\t\\t\\t\\t + n12 * n24 * n33\\n\\t\\t\\t\\t\\t + n13 * n22 * n34\\n\\t\\t\\t\\t\\t - n12 * n23 * n34\\n\\t\\t\\t\\t) +\\n\\t\\t\\t\\tn42 * (\\n\\t\\t\\t\\t\\t+ n11 * n23 * n34\\n\\t\\t\\t\\t\\t - n11 * n24 * n33\\n\\t\\t\\t\\t\\t + n14 * n21 * n33\\n\\t\\t\\t\\t\\t - n13 * n21 * n34\\n\\t\\t\\t\\t\\t + n13 * n24 * n31\\n\\t\\t\\t\\t\\t - n14 * n23 * n31\\n\\t\\t\\t\\t) +\\n\\t\\t\\t\\tn43 * (\\n\\t\\t\\t\\t\\t+ n11 * n24 * n32\\n\\t\\t\\t\\t\\t - n11 * n22 * n34\\n\\t\\t\\t\\t\\t - n14 * n21 * n32\\n\\t\\t\\t\\t\\t + n12 * n21 * n34\\n\\t\\t\\t\\t\\t + n14 * n22 * n31\\n\\t\\t\\t\\t\\t - n12 * n24 * n31\\n\\t\\t\\t\\t) +\\n\\t\\t\\t\\tn44 * (\\n\\t\\t\\t\\t\\t- n13 * n22 * n31\\n\\t\\t\\t\\t\\t - n11 * n23 * n32\\n\\t\\t\\t\\t\\t + n11 * n22 * n33\\n\\t\\t\\t\\t\\t + n13 * n21 * n32\\n\\t\\t\\t\\t\\t - n12 * n21 * n33\\n\\t\\t\\t\\t\\t + n12 * n23 * n31\\n\\t\\t\\t\\t)\\n\\n\\t\\t\\t);\\n\\n\\t\\t},\\n\\n\\t\\ttranspose: function () {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar tmp;\\n\\n\\t\\t\\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\\n\\t\\t\\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\\n\\t\\t\\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\\n\\n\\t\\t\\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\\n\\t\\t\\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\\n\\t\\t\\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetPosition: function ( v ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 12 ] = v.x;\\n\\t\\t\\tte[ 13 ] = v.y;\\n\\t\\t\\tte[ 14 ] = v.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetInverse: function ( m, throwOnDegenerate ) {\\n\\n\\t\\t\\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\\n\\t\\t\\tvar te = this.elements,\\n\\t\\t\\t\\tme = m.elements,\\n\\n\\t\\t\\t\\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\\n\\t\\t\\t\\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\\n\\t\\t\\t\\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\\n\\t\\t\\t\\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\\n\\n\\t\\t\\t\\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\\n\\t\\t\\t\\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\\n\\t\\t\\t\\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\\n\\t\\t\\t\\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\\n\\n\\t\\t\\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\\n\\n\\t\\t\\tif ( det === 0 ) {\\n\\n\\t\\t\\t\\tvar msg = \\\"THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0\\\";\\n\\n\\t\\t\\t\\tif ( throwOnDegenerate === true ) {\\n\\n\\t\\t\\t\\t\\tthrow new Error( msg );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tconsole.warn( msg );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn this.identity();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar detInv = 1 / det;\\n\\n\\t\\t\\tte[ 0 ] = t11 * detInv;\\n\\t\\t\\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\\n\\t\\t\\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\\n\\t\\t\\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\\n\\n\\t\\t\\tte[ 4 ] = t12 * detInv;\\n\\t\\t\\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\\n\\t\\t\\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\\n\\t\\t\\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\\n\\n\\t\\t\\tte[ 8 ] = t13 * detInv;\\n\\t\\t\\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\\n\\t\\t\\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\\n\\t\\t\\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\\n\\n\\t\\t\\tte[ 12 ] = t14 * detInv;\\n\\t\\t\\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\\n\\t\\t\\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\\n\\t\\t\\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tscale: function ( v ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar x = v.x, y = v.y, z = v.z;\\n\\n\\t\\t\\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\\n\\t\\t\\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\\n\\t\\t\\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\\n\\t\\t\\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetMaxScaleOnAxis: function () {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\\n\\t\\t\\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\\n\\t\\t\\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\\n\\n\\t\\t\\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\\n\\n\\t\\t},\\n\\n\\t\\tmakeTranslation: function ( x, y, z ) {\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\t1, 0, 0, x,\\n\\t\\t\\t\\t0, 1, 0, y,\\n\\t\\t\\t\\t0, 0, 1, z,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeRotationX: function ( theta ) {\\n\\n\\t\\t\\tvar c = Math.cos( theta ), s = Math.sin( theta );\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\t1, 0, 0, 0,\\n\\t\\t\\t\\t0, c, - s, 0,\\n\\t\\t\\t\\t0, s, c, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeRotationY: function ( theta ) {\\n\\n\\t\\t\\tvar c = Math.cos( theta ), s = Math.sin( theta );\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\t c, 0, s, 0,\\n\\t\\t\\t\\t 0, 1, 0, 0,\\n\\t\\t\\t\\t- s, 0, c, 0,\\n\\t\\t\\t\\t 0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeRotationZ: function ( theta ) {\\n\\n\\t\\t\\tvar c = Math.cos( theta ), s = Math.sin( theta );\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\tc, - s, 0, 0,\\n\\t\\t\\t\\ts, c, 0, 0,\\n\\t\\t\\t\\t0, 0, 1, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeRotationAxis: function ( axis, angle ) {\\n\\n\\t\\t\\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\\n\\n\\t\\t\\tvar c = Math.cos( angle );\\n\\t\\t\\tvar s = Math.sin( angle );\\n\\t\\t\\tvar t = 1 - c;\\n\\t\\t\\tvar x = axis.x, y = axis.y, z = axis.z;\\n\\t\\t\\tvar tx = t * x, ty = t * y;\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\\n\\t\\t\\t\\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\\n\\t\\t\\t\\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\t return this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeScale: function ( x, y, z ) {\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\tx, 0, 0, 0,\\n\\t\\t\\t\\t0, y, 0, 0,\\n\\t\\t\\t\\t0, 0, z, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeShear: function ( x, y, z ) {\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\t1, y, z, 0,\\n\\t\\t\\t\\tx, 1, z, 0,\\n\\t\\t\\t\\tx, y, 1, 0,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcompose: function ( position, quaternion, scale ) {\\n\\n\\t\\t\\tthis.makeRotationFromQuaternion( quaternion );\\n\\t\\t\\tthis.scale( scale );\\n\\t\\t\\tthis.setPosition( position );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdecompose: function () {\\n\\n\\t\\t\\tvar vector = new Vector3();\\n\\t\\t\\tvar matrix = new Matrix4();\\n\\n\\t\\t\\treturn function decompose( position, quaternion, scale ) {\\n\\n\\t\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\t\\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\\n\\t\\t\\t\\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\\n\\t\\t\\t\\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\\n\\n\\t\\t\\t\\t// if determine is negative, we need to invert one scale\\n\\t\\t\\t\\tvar det = this.determinant();\\n\\t\\t\\t\\tif ( det < 0 ) sx = - sx;\\n\\n\\t\\t\\t\\tposition.x = te[ 12 ];\\n\\t\\t\\t\\tposition.y = te[ 13 ];\\n\\t\\t\\t\\tposition.z = te[ 14 ];\\n\\n\\t\\t\\t\\t// scale the rotation part\\n\\t\\t\\t\\tmatrix.copy( this );\\n\\n\\t\\t\\t\\tvar invSX = 1 / sx;\\n\\t\\t\\t\\tvar invSY = 1 / sy;\\n\\t\\t\\t\\tvar invSZ = 1 / sz;\\n\\n\\t\\t\\t\\tmatrix.elements[ 0 ] *= invSX;\\n\\t\\t\\t\\tmatrix.elements[ 1 ] *= invSX;\\n\\t\\t\\t\\tmatrix.elements[ 2 ] *= invSX;\\n\\n\\t\\t\\t\\tmatrix.elements[ 4 ] *= invSY;\\n\\t\\t\\t\\tmatrix.elements[ 5 ] *= invSY;\\n\\t\\t\\t\\tmatrix.elements[ 6 ] *= invSY;\\n\\n\\t\\t\\t\\tmatrix.elements[ 8 ] *= invSZ;\\n\\t\\t\\t\\tmatrix.elements[ 9 ] *= invSZ;\\n\\t\\t\\t\\tmatrix.elements[ 10 ] *= invSZ;\\n\\n\\t\\t\\t\\tquaternion.setFromRotationMatrix( matrix );\\n\\n\\t\\t\\t\\tscale.x = sx;\\n\\t\\t\\t\\tscale.y = sy;\\n\\t\\t\\t\\tscale.z = sz;\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tmakePerspective: function ( left, right, top, bottom, near, far ) {\\n\\n\\t\\t\\tif ( far === undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar x = 2 * near / ( right - left );\\n\\t\\t\\tvar y = 2 * near / ( top - bottom );\\n\\n\\t\\t\\tvar a = ( right + left ) / ( right - left );\\n\\t\\t\\tvar b = ( top + bottom ) / ( top - bottom );\\n\\t\\t\\tvar c = - ( far + near ) / ( far - near );\\n\\t\\t\\tvar d = - 2 * far * near / ( far - near );\\n\\n\\t\\t\\tte[ 0 ] = x;\\tte[ 4 ] = 0;\\tte[ 8 ] = a;\\tte[ 12 ] = 0;\\n\\t\\t\\tte[ 1 ] = 0;\\tte[ 5 ] = y;\\tte[ 9 ] = b;\\tte[ 13 ] = 0;\\n\\t\\t\\tte[ 2 ] = 0;\\tte[ 6 ] = 0;\\tte[ 10 ] = c;\\tte[ 14 ] = d;\\n\\t\\t\\tte[ 3 ] = 0;\\tte[ 7 ] = 0;\\tte[ 11 ] = - 1;\\tte[ 15 ] = 0;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar w = 1.0 / ( right - left );\\n\\t\\t\\tvar h = 1.0 / ( top - bottom );\\n\\t\\t\\tvar p = 1.0 / ( far - near );\\n\\n\\t\\t\\tvar x = ( right + left ) * w;\\n\\t\\t\\tvar y = ( top + bottom ) * h;\\n\\t\\t\\tvar z = ( far + near ) * p;\\n\\n\\t\\t\\tte[ 0 ] = 2 * w;\\tte[ 4 ] = 0;\\tte[ 8 ] = 0;\\tte[ 12 ] = - x;\\n\\t\\t\\tte[ 1 ] = 0;\\tte[ 5 ] = 2 * h;\\tte[ 9 ] = 0;\\tte[ 13 ] = - y;\\n\\t\\t\\tte[ 2 ] = 0;\\tte[ 6 ] = 0;\\tte[ 10 ] = - 2 * p;\\tte[ 14 ] = - z;\\n\\t\\t\\tte[ 3 ] = 0;\\tte[ 7 ] = 0;\\tte[ 11 ] = 0;\\tte[ 15 ] = 1;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( matrix ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar me = matrix.elements;\\n\\n\\t\\t\\tfor ( var i = 0; i < 16; i ++ ) {\\n\\n\\t\\t\\t\\tif ( te[ i ] !== me[ i ] ) return false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0; i < 16; i ++ ) {\\n\\n\\t\\t\\t\\tthis.elements[ i ] = array[ i + offset ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tarray[ offset ] = te[ 0 ];\\n\\t\\t\\tarray[ offset + 1 ] = te[ 1 ];\\n\\t\\t\\tarray[ offset + 2 ] = te[ 2 ];\\n\\t\\t\\tarray[ offset + 3 ] = te[ 3 ];\\n\\n\\t\\t\\tarray[ offset + 4 ] = te[ 4 ];\\n\\t\\t\\tarray[ offset + 5 ] = te[ 5 ];\\n\\t\\t\\tarray[ offset + 6 ] = te[ 6 ];\\n\\t\\t\\tarray[ offset + 7 ] = te[ 7 ];\\n\\n\\t\\t\\tarray[ offset + 8 ] = te[ 8 ];\\n\\t\\t\\tarray[ offset + 9 ] = te[ 9 ];\\n\\t\\t\\tarray[ offset + 10 ] = te[ 10 ];\\n\\t\\t\\tarray[ offset + 11 ] = te[ 11 ];\\n\\n\\t\\t\\tarray[ offset + 12 ] = te[ 12 ];\\n\\t\\t\\tarray[ offset + 13 ] = te[ 13 ];\\n\\t\\t\\tarray[ offset + 14 ] = te[ 14 ];\\n\\t\\t\\tarray[ offset + 15 ] = te[ 15 ];\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Quaternion( x, y, z, w ) {\\n\\n\\t\\tthis._x = x || 0;\\n\\t\\tthis._y = y || 0;\\n\\t\\tthis._z = z || 0;\\n\\t\\tthis._w = ( w !== undefined ) ? w : 1;\\n\\n\\t}\\n\\n\\tObject.assign( Quaternion, {\\n\\n\\t\\tslerp: function ( qa, qb, qm, t ) {\\n\\n\\t\\t\\treturn qm.copy( qa ).slerp( qb, t );\\n\\n\\t\\t},\\n\\n\\t\\tslerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\\n\\n\\t\\t\\t// fuzz-free, array-based Quaternion SLERP operation\\n\\n\\t\\t\\tvar x0 = src0[ srcOffset0 + 0 ],\\n\\t\\t\\t\\ty0 = src0[ srcOffset0 + 1 ],\\n\\t\\t\\t\\tz0 = src0[ srcOffset0 + 2 ],\\n\\t\\t\\t\\tw0 = src0[ srcOffset0 + 3 ],\\n\\n\\t\\t\\t\\tx1 = src1[ srcOffset1 + 0 ],\\n\\t\\t\\t\\ty1 = src1[ srcOffset1 + 1 ],\\n\\t\\t\\t\\tz1 = src1[ srcOffset1 + 2 ],\\n\\t\\t\\t\\tw1 = src1[ srcOffset1 + 3 ];\\n\\n\\t\\t\\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\\n\\n\\t\\t\\t\\tvar s = 1 - t,\\n\\n\\t\\t\\t\\t\\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\\n\\n\\t\\t\\t\\t\\tdir = ( cos >= 0 ? 1 : - 1 ),\\n\\t\\t\\t\\t\\tsqrSin = 1 - cos * cos;\\n\\n\\t\\t\\t\\t// Skip the Slerp for tiny steps to avoid numeric problems:\\n\\t\\t\\t\\tif ( sqrSin > Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\tvar sin = Math.sqrt( sqrSin ),\\n\\t\\t\\t\\t\\t\\tlen = Math.atan2( sin, cos * dir );\\n\\n\\t\\t\\t\\t\\ts = Math.sin( s * len ) / sin;\\n\\t\\t\\t\\t\\tt = Math.sin( t * len ) / sin;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar tDir = t * dir;\\n\\n\\t\\t\\t\\tx0 = x0 * s + x1 * tDir;\\n\\t\\t\\t\\ty0 = y0 * s + y1 * tDir;\\n\\t\\t\\t\\tz0 = z0 * s + z1 * tDir;\\n\\t\\t\\t\\tw0 = w0 * s + w1 * tDir;\\n\\n\\t\\t\\t\\t// Normalize in case we just did a lerp:\\n\\t\\t\\t\\tif ( s === 1 - t ) {\\n\\n\\t\\t\\t\\t\\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\\n\\n\\t\\t\\t\\t\\tx0 *= f;\\n\\t\\t\\t\\t\\ty0 *= f;\\n\\t\\t\\t\\t\\tz0 *= f;\\n\\t\\t\\t\\t\\tw0 *= f;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tdst[ dstOffset ] = x0;\\n\\t\\t\\tdst[ dstOffset + 1 ] = y0;\\n\\t\\t\\tdst[ dstOffset + 2 ] = z0;\\n\\t\\t\\tdst[ dstOffset + 3 ] = w0;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( Quaternion.prototype, {\\n\\n\\t\\tx: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._x;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._x = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ty: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._y;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._y = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tz: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._z;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._z = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tw: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._w;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._w = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Quaternion.prototype, {\\n\\n\\t\\tset: function ( x, y, z, w ) {\\n\\n\\t\\t\\tthis._x = x;\\n\\t\\t\\tthis._y = y;\\n\\t\\t\\tthis._z = z;\\n\\t\\t\\tthis._w = w;\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this._x, this._y, this._z, this._w );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( quaternion ) {\\n\\n\\t\\t\\tthis._x = quaternion.x;\\n\\t\\t\\tthis._y = quaternion.y;\\n\\t\\t\\tthis._z = quaternion.z;\\n\\t\\t\\tthis._w = quaternion.w;\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromEuler: function ( euler, update ) {\\n\\n\\t\\t\\tif ( ! ( euler && euler.isEuler ) ) {\\n\\n\\t\\t\\t\\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar x = euler._x, y = euler._y, z = euler._z, order = euler.order;\\n\\n\\t\\t\\t// http://www.mathworks.com/matlabcentral/fileexchange/\\n\\t\\t\\t// \\t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\\n\\t\\t\\t//\\tcontent/SpinCalc.m\\n\\n\\t\\t\\tvar cos = Math.cos;\\n\\t\\t\\tvar sin = Math.sin;\\n\\n\\t\\t\\tvar c1 = cos( x / 2 );\\n\\t\\t\\tvar c2 = cos( y / 2 );\\n\\t\\t\\tvar c3 = cos( z / 2 );\\n\\n\\t\\t\\tvar s1 = sin( x / 2 );\\n\\t\\t\\tvar s2 = sin( y / 2 );\\n\\t\\t\\tvar s3 = sin( z / 2 );\\n\\n\\t\\t\\tif ( order === 'XYZ' ) {\\n\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\\n\\n\\t\\t\\t} else if ( order === 'YXZ' ) {\\n\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\\n\\n\\t\\t\\t} else if ( order === 'ZXY' ) {\\n\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\\n\\n\\t\\t\\t} else if ( order === 'ZYX' ) {\\n\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\\n\\n\\t\\t\\t} else if ( order === 'YZX' ) {\\n\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\\n\\n\\t\\t\\t} else if ( order === 'XZY' ) {\\n\\n\\t\\t\\t\\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\\n\\t\\t\\t\\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\\n\\t\\t\\t\\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\\n\\t\\t\\t\\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( update !== false ) this.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromAxisAngle: function ( axis, angle ) {\\n\\n\\t\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\\n\\n\\t\\t\\t// assumes axis is normalized\\n\\n\\t\\t\\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\\n\\n\\t\\t\\tthis._x = axis.x * s;\\n\\t\\t\\tthis._y = axis.y * s;\\n\\t\\t\\tthis._z = axis.z * s;\\n\\t\\t\\tthis._w = Math.cos( halfAngle );\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromRotationMatrix: function ( m ) {\\n\\n\\t\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\\n\\n\\t\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\n\\n\\t\\t\\tvar te = m.elements,\\n\\n\\t\\t\\t\\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\\n\\t\\t\\t\\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\\n\\t\\t\\t\\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\\n\\n\\t\\t\\t\\ttrace = m11 + m22 + m33,\\n\\t\\t\\t\\ts;\\n\\n\\t\\t\\tif ( trace > 0 ) {\\n\\n\\t\\t\\t\\ts = 0.5 / Math.sqrt( trace + 1.0 );\\n\\n\\t\\t\\t\\tthis._w = 0.25 / s;\\n\\t\\t\\t\\tthis._x = ( m32 - m23 ) * s;\\n\\t\\t\\t\\tthis._y = ( m13 - m31 ) * s;\\n\\t\\t\\t\\tthis._z = ( m21 - m12 ) * s;\\n\\n\\t\\t\\t} else if ( m11 > m22 && m11 > m33 ) {\\n\\n\\t\\t\\t\\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\\n\\n\\t\\t\\t\\tthis._w = ( m32 - m23 ) / s;\\n\\t\\t\\t\\tthis._x = 0.25 * s;\\n\\t\\t\\t\\tthis._y = ( m12 + m21 ) / s;\\n\\t\\t\\t\\tthis._z = ( m13 + m31 ) / s;\\n\\n\\t\\t\\t} else if ( m22 > m33 ) {\\n\\n\\t\\t\\t\\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\\n\\n\\t\\t\\t\\tthis._w = ( m13 - m31 ) / s;\\n\\t\\t\\t\\tthis._x = ( m12 + m21 ) / s;\\n\\t\\t\\t\\tthis._y = 0.25 * s;\\n\\t\\t\\t\\tthis._z = ( m23 + m32 ) / s;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\\n\\n\\t\\t\\t\\tthis._w = ( m21 - m12 ) / s;\\n\\t\\t\\t\\tthis._x = ( m13 + m31 ) / s;\\n\\t\\t\\t\\tthis._y = ( m23 + m32 ) / s;\\n\\t\\t\\t\\tthis._z = 0.25 * s;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromUnitVectors: function () {\\n\\n\\t\\t\\t// assumes direction vectors vFrom and vTo are normalized\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\t\\t\\tvar r;\\n\\n\\t\\t\\tvar EPS = 0.000001;\\n\\n\\t\\t\\treturn function setFromUnitVectors( vFrom, vTo ) {\\n\\n\\t\\t\\t\\tif ( v1 === undefined ) v1 = new Vector3();\\n\\n\\t\\t\\t\\tr = vFrom.dot( vTo ) + 1;\\n\\n\\t\\t\\t\\tif ( r < EPS ) {\\n\\n\\t\\t\\t\\t\\tr = 0;\\n\\n\\t\\t\\t\\t\\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\\n\\n\\t\\t\\t\\t\\t\\tv1.set( - vFrom.y, vFrom.x, 0 );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tv1.set( 0, - vFrom.z, vFrom.y );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tv1.crossVectors( vFrom, vTo );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis._x = v1.x;\\n\\t\\t\\t\\tthis._y = v1.y;\\n\\t\\t\\t\\tthis._z = v1.z;\\n\\t\\t\\t\\tthis._w = r;\\n\\n\\t\\t\\t\\treturn this.normalize();\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tinverse: function () {\\n\\n\\t\\t\\treturn this.conjugate().normalize();\\n\\n\\t\\t},\\n\\n\\t\\tconjugate: function () {\\n\\n\\t\\t\\tthis._x *= - 1;\\n\\t\\t\\tthis._y *= - 1;\\n\\t\\t\\tthis._z *= - 1;\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdot: function ( v ) {\\n\\n\\t\\t\\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\\n\\n\\t\\t},\\n\\n\\t\\tlengthSq: function () {\\n\\n\\t\\t\\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\\n\\n\\t\\t},\\n\\n\\t\\tlength: function () {\\n\\n\\t\\t\\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\\n\\n\\t\\t},\\n\\n\\t\\tnormalize: function () {\\n\\n\\t\\t\\tvar l = this.length();\\n\\n\\t\\t\\tif ( l === 0 ) {\\n\\n\\t\\t\\t\\tthis._x = 0;\\n\\t\\t\\t\\tthis._y = 0;\\n\\t\\t\\t\\tthis._z = 0;\\n\\t\\t\\t\\tthis._w = 1;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tl = 1 / l;\\n\\n\\t\\t\\t\\tthis._x = this._x * l;\\n\\t\\t\\t\\tthis._y = this._y * l;\\n\\t\\t\\t\\tthis._z = this._z * l;\\n\\t\\t\\t\\tthis._w = this._w * l;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiply: function ( q, p ) {\\n\\n\\t\\t\\tif ( p !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.multiplyQuaternions( q, p );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this.multiplyQuaternions( this, q );\\n\\n\\t\\t},\\n\\n\\t\\tpremultiply: function ( q ) {\\n\\n\\t\\t\\treturn this.multiplyQuaternions( q, this );\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyQuaternions: function ( a, b ) {\\n\\n\\t\\t\\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\\n\\n\\t\\t\\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\\n\\t\\t\\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\\n\\n\\t\\t\\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\\n\\t\\t\\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\\n\\t\\t\\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\\n\\t\\t\\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tslerp: function ( qb, t ) {\\n\\n\\t\\t\\tif ( t === 0 ) return this;\\n\\t\\t\\tif ( t === 1 ) return this.copy( qb );\\n\\n\\t\\t\\tvar x = this._x, y = this._y, z = this._z, w = this._w;\\n\\n\\t\\t\\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\\n\\n\\t\\t\\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\\n\\n\\t\\t\\tif ( cosHalfTheta < 0 ) {\\n\\n\\t\\t\\t\\tthis._w = - qb._w;\\n\\t\\t\\t\\tthis._x = - qb._x;\\n\\t\\t\\t\\tthis._y = - qb._y;\\n\\t\\t\\t\\tthis._z = - qb._z;\\n\\n\\t\\t\\t\\tcosHalfTheta = - cosHalfTheta;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.copy( qb );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( cosHalfTheta >= 1.0 ) {\\n\\n\\t\\t\\t\\tthis._w = w;\\n\\t\\t\\t\\tthis._x = x;\\n\\t\\t\\t\\tthis._y = y;\\n\\t\\t\\t\\tthis._z = z;\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\\n\\n\\t\\t\\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\\n\\n\\t\\t\\t\\tthis._w = 0.5 * ( w + this._w );\\n\\t\\t\\t\\tthis._x = 0.5 * ( x + this._x );\\n\\t\\t\\t\\tthis._y = 0.5 * ( y + this._y );\\n\\t\\t\\t\\tthis._z = 0.5 * ( z + this._z );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\\n\\t\\t\\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\\n\\t\\t\\t\\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\\n\\n\\t\\t\\tthis._w = ( w * ratioA + this._w * ratioB );\\n\\t\\t\\tthis._x = ( x * ratioA + this._x * ratioB );\\n\\t\\t\\tthis._y = ( y * ratioA + this._y * ratioB );\\n\\t\\t\\tthis._z = ( z * ratioA + this._z * ratioB );\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( quaternion ) {\\n\\n\\t\\t\\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis._x = array[ offset ];\\n\\t\\t\\tthis._y = array[ offset + 1 ];\\n\\t\\t\\tthis._z = array[ offset + 2 ];\\n\\t\\t\\tthis._w = array[ offset + 3 ];\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tarray[ offset ] = this._x;\\n\\t\\t\\tarray[ offset + 1 ] = this._y;\\n\\t\\t\\tarray[ offset + 2 ] = this._z;\\n\\t\\t\\tarray[ offset + 3 ] = this._w;\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\tonChange: function ( callback ) {\\n\\n\\t\\t\\tthis.onChangeCallback = callback;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tonChangeCallback: function () {}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author kile / http://kile.stravaganza.org/\\n\\t * @author philogb / http://blog.thejit.org/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author egraether / http://egraether.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction Vector3( x, y, z ) {\\n\\n\\t\\tthis.x = x || 0;\\n\\t\\tthis.y = y || 0;\\n\\t\\tthis.z = z || 0;\\n\\n\\t}\\n\\n\\tObject.assign( Vector3.prototype, {\\n\\n\\t\\tisVector3: true,\\n\\n\\t\\tset: function ( x, y, z ) {\\n\\n\\t\\t\\tthis.x = x;\\n\\t\\t\\tthis.y = y;\\n\\t\\t\\tthis.z = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.x = scalar;\\n\\t\\t\\tthis.y = scalar;\\n\\t\\t\\tthis.z = scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetX: function ( x ) {\\n\\n\\t\\t\\tthis.x = x;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetY: function ( y ) {\\n\\n\\t\\t\\tthis.y = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetZ: function ( z ) {\\n\\n\\t\\t\\tthis.z = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetComponent: function ( index, value ) {\\n\\n\\t\\t\\tswitch ( index ) {\\n\\n\\t\\t\\t\\tcase 0: this.x = value; break;\\n\\t\\t\\t\\tcase 1: this.y = value; break;\\n\\t\\t\\t\\tcase 2: this.z = value; break;\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetComponent: function ( index ) {\\n\\n\\t\\t\\tswitch ( index ) {\\n\\n\\t\\t\\t\\tcase 0: return this.x;\\n\\t\\t\\t\\tcase 1: return this.y;\\n\\t\\t\\t\\tcase 2: return this.z;\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.x, this.y, this.z );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( v ) {\\n\\n\\t\\t\\tthis.x = v.x;\\n\\t\\t\\tthis.y = v.y;\\n\\t\\t\\tthis.z = v.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tadd: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.addVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x += v.x;\\n\\t\\t\\tthis.y += v.y;\\n\\t\\t\\tthis.z += v.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScalar: function ( s ) {\\n\\n\\t\\t\\tthis.x += s;\\n\\t\\t\\tthis.y += s;\\n\\t\\t\\tthis.z += s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x + b.x;\\n\\t\\t\\tthis.y = a.y + b.y;\\n\\t\\t\\tthis.z = a.z + b.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScaledVector: function ( v, s ) {\\n\\n\\t\\t\\tthis.x += v.x * s;\\n\\t\\t\\tthis.y += v.y * s;\\n\\t\\t\\tthis.z += v.z * s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsub: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.subVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x -= v.x;\\n\\t\\t\\tthis.y -= v.y;\\n\\t\\t\\tthis.z -= v.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsubScalar: function ( s ) {\\n\\n\\t\\t\\tthis.x -= s;\\n\\t\\t\\tthis.y -= s;\\n\\t\\t\\tthis.z -= s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsubVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x - b.x;\\n\\t\\t\\tthis.y = a.y - b.y;\\n\\t\\t\\tthis.z = a.z - b.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiply: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.multiplyVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x *= v.x;\\n\\t\\t\\tthis.y *= v.y;\\n\\t\\t\\tthis.z *= v.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.x *= scalar;\\n\\t\\t\\tthis.y *= scalar;\\n\\t\\t\\tthis.z *= scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x * b.x;\\n\\t\\t\\tthis.y = a.y * b.y;\\n\\t\\t\\tthis.z = a.z * b.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyEuler: function () {\\n\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\n\\t\\t\\treturn function applyEuler( euler ) {\\n\\n\\t\\t\\t\\tif ( ! ( euler && euler.isEuler ) ) {\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tapplyAxisAngle: function () {\\n\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\n\\t\\t\\treturn function applyAxisAngle( axis, angle ) {\\n\\n\\t\\t\\t\\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tapplyMatrix3: function ( m ) {\\n\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z;\\n\\t\\t\\tvar e = m.elements;\\n\\n\\t\\t\\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\\n\\t\\t\\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\\n\\t\\t\\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix4: function ( m ) {\\n\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z;\\n\\t\\t\\tvar e = m.elements;\\n\\n\\t\\t\\tvar w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\\n\\n\\t\\t\\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\\n\\t\\t\\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\\n\\t\\t\\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyQuaternion: function ( q ) {\\n\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z;\\n\\t\\t\\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\\n\\n\\t\\t\\t// calculate quat * vector\\n\\n\\t\\t\\tvar ix = qw * x + qy * z - qz * y;\\n\\t\\t\\tvar iy = qw * y + qz * x - qx * z;\\n\\t\\t\\tvar iz = qw * z + qx * y - qy * x;\\n\\t\\t\\tvar iw = - qx * x - qy * y - qz * z;\\n\\n\\t\\t\\t// calculate result * inverse quat\\n\\n\\t\\t\\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\\n\\t\\t\\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\\n\\t\\t\\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tproject: function () {\\n\\n\\t\\t\\tvar matrix = new Matrix4();\\n\\n\\t\\t\\treturn function project( camera ) {\\n\\n\\t\\t\\t\\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\\n\\t\\t\\t\\treturn this.applyMatrix4( matrix );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tunproject: function () {\\n\\n\\t\\t\\tvar matrix = new Matrix4();\\n\\n\\t\\t\\treturn function unproject( camera ) {\\n\\n\\t\\t\\t\\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\\n\\t\\t\\t\\treturn this.applyMatrix4( matrix );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttransformDirection: function ( m ) {\\n\\n\\t\\t\\t// input: THREE.Matrix4 affine matrix\\n\\t\\t\\t// vector interpreted as a direction\\n\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z;\\n\\t\\t\\tvar e = m.elements;\\n\\n\\t\\t\\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;\\n\\t\\t\\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;\\n\\t\\t\\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\\n\\n\\t\\t\\treturn this.normalize();\\n\\n\\t\\t},\\n\\n\\t\\tdivide: function ( v ) {\\n\\n\\t\\t\\tthis.x /= v.x;\\n\\t\\t\\tthis.y /= v.y;\\n\\t\\t\\tthis.z /= v.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdivideScalar: function ( scalar ) {\\n\\n\\t\\t\\treturn this.multiplyScalar( 1 / scalar );\\n\\n\\t\\t},\\n\\n\\t\\tmin: function ( v ) {\\n\\n\\t\\t\\tthis.x = Math.min( this.x, v.x );\\n\\t\\t\\tthis.y = Math.min( this.y, v.y );\\n\\t\\t\\tthis.z = Math.min( this.z, v.z );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmax: function ( v ) {\\n\\n\\t\\t\\tthis.x = Math.max( this.x, v.x );\\n\\t\\t\\tthis.y = Math.max( this.y, v.y );\\n\\t\\t\\tthis.z = Math.max( this.z, v.z );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclamp: function ( min, max ) {\\n\\n\\t\\t\\t// assumes min < max, componentwise\\n\\n\\t\\t\\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\\n\\t\\t\\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\\n\\t\\t\\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclampScalar: function () {\\n\\n\\t\\t\\tvar min = new Vector3();\\n\\t\\t\\tvar max = new Vector3();\\n\\n\\t\\t\\treturn function clampScalar( minVal, maxVal ) {\\n\\n\\t\\t\\t\\tmin.set( minVal, minVal, minVal );\\n\\t\\t\\t\\tmax.set( maxVal, maxVal, maxVal );\\n\\n\\t\\t\\t\\treturn this.clamp( min, max );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclampLength: function ( min, max ) {\\n\\n\\t\\t\\tvar length = this.length();\\n\\n\\t\\t\\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\\n\\n\\t\\t},\\n\\n\\t\\tfloor: function () {\\n\\n\\t\\t\\tthis.x = Math.floor( this.x );\\n\\t\\t\\tthis.y = Math.floor( this.y );\\n\\t\\t\\tthis.z = Math.floor( this.z );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tceil: function () {\\n\\n\\t\\t\\tthis.x = Math.ceil( this.x );\\n\\t\\t\\tthis.y = Math.ceil( this.y );\\n\\t\\t\\tthis.z = Math.ceil( this.z );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tround: function () {\\n\\n\\t\\t\\tthis.x = Math.round( this.x );\\n\\t\\t\\tthis.y = Math.round( this.y );\\n\\t\\t\\tthis.z = Math.round( this.z );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\troundToZero: function () {\\n\\n\\t\\t\\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\\n\\t\\t\\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\\n\\t\\t\\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tnegate: function () {\\n\\n\\t\\t\\tthis.x = - this.x;\\n\\t\\t\\tthis.y = - this.y;\\n\\t\\t\\tthis.z = - this.z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdot: function ( v ) {\\n\\n\\t\\t\\treturn this.x * v.x + this.y * v.y + this.z * v.z;\\n\\n\\t\\t},\\n\\n\\t\\t// TODO lengthSquared?\\n\\n\\t\\tlengthSq: function () {\\n\\n\\t\\t\\treturn this.x * this.x + this.y * this.y + this.z * this.z;\\n\\n\\t\\t},\\n\\n\\t\\tlength: function () {\\n\\n\\t\\t\\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\\n\\n\\t\\t},\\n\\n\\t\\tmanhattanLength: function () {\\n\\n\\t\\t\\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\\n\\n\\t\\t},\\n\\n\\t\\tnormalize: function () {\\n\\n\\t\\t\\treturn this.divideScalar( this.length() || 1 );\\n\\n\\t\\t},\\n\\n\\t\\tsetLength: function ( length ) {\\n\\n\\t\\t\\treturn this.normalize().multiplyScalar( length );\\n\\n\\t\\t},\\n\\n\\t\\tlerp: function ( v, alpha ) {\\n\\n\\t\\t\\tthis.x += ( v.x - this.x ) * alpha;\\n\\t\\t\\tthis.y += ( v.y - this.y ) * alpha;\\n\\t\\t\\tthis.z += ( v.z - this.z ) * alpha;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tlerpVectors: function ( v1, v2, alpha ) {\\n\\n\\t\\t\\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\\n\\n\\t\\t},\\n\\n\\t\\tcross: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.crossVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this.crossVectors( this, v );\\n\\n\\t\\t},\\n\\n\\t\\tcrossVectors: function ( a, b ) {\\n\\n\\t\\t\\tvar ax = a.x, ay = a.y, az = a.z;\\n\\t\\t\\tvar bx = b.x, by = b.y, bz = b.z;\\n\\n\\t\\t\\tthis.x = ay * bz - az * by;\\n\\t\\t\\tthis.y = az * bx - ax * bz;\\n\\t\\t\\tthis.z = ax * by - ay * bx;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tprojectOnVector: function ( vector ) {\\n\\n\\t\\t\\tvar scalar = vector.dot( this ) / vector.lengthSq();\\n\\n\\t\\t\\treturn this.copy( vector ).multiplyScalar( scalar );\\n\\n\\t\\t},\\n\\n\\t\\tprojectOnPlane: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function projectOnPlane( planeNormal ) {\\n\\n\\t\\t\\t\\tv1.copy( this ).projectOnVector( planeNormal );\\n\\n\\t\\t\\t\\treturn this.sub( v1 );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\treflect: function () {\\n\\n\\t\\t\\t// reflect incident vector off plane orthogonal to normal\\n\\t\\t\\t// normal is assumed to have unit length\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function reflect( normal ) {\\n\\n\\t\\t\\t\\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tangleTo: function ( v ) {\\n\\n\\t\\t\\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\\n\\n\\t\\t\\t// clamp, to handle numerical problems\\n\\n\\t\\t\\treturn Math.acos( _Math.clamp( theta, - 1, 1 ) );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceTo: function ( v ) {\\n\\n\\t\\t\\treturn Math.sqrt( this.distanceToSquared( v ) );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToSquared: function ( v ) {\\n\\n\\t\\t\\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\\n\\n\\t\\t\\treturn dx * dx + dy * dy + dz * dz;\\n\\n\\t\\t},\\n\\n\\t\\tmanhattanDistanceTo: function ( v ) {\\n\\n\\t\\t\\treturn Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );\\n\\n\\t\\t},\\n\\n\\t\\tsetFromSpherical: function ( s ) {\\n\\n\\t\\t\\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\\n\\n\\t\\t\\tthis.x = sinPhiRadius * Math.sin( s.theta );\\n\\t\\t\\tthis.y = Math.cos( s.phi ) * s.radius;\\n\\t\\t\\tthis.z = sinPhiRadius * Math.cos( s.theta );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromCylindrical: function ( c ) {\\n\\n\\t\\t\\tthis.x = c.radius * Math.sin( c.theta );\\n\\t\\t\\tthis.y = c.y;\\n\\t\\t\\tthis.z = c.radius * Math.cos( c.theta );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromMatrixPosition: function ( m ) {\\n\\n\\t\\t\\tvar e = m.elements;\\n\\n\\t\\t\\tthis.x = e[ 12 ];\\n\\t\\t\\tthis.y = e[ 13 ];\\n\\t\\t\\tthis.z = e[ 14 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromMatrixScale: function ( m ) {\\n\\n\\t\\t\\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\\n\\t\\t\\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\\n\\t\\t\\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\\n\\n\\t\\t\\tthis.x = sx;\\n\\t\\t\\tthis.y = sy;\\n\\t\\t\\tthis.z = sz;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromMatrixColumn: function ( m, index ) {\\n\\n\\t\\t\\treturn this.fromArray( m.elements, index * 4 );\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( v ) {\\n\\n\\t\\t\\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis.x = array[ offset ];\\n\\t\\t\\tthis.y = array[ offset + 1 ];\\n\\t\\t\\tthis.z = array[ offset + 2 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tarray[ offset ] = this.x;\\n\\t\\t\\tarray[ offset + 1 ] = this.y;\\n\\t\\t\\tarray[ offset + 2 ] = this.z;\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\tfromBufferAttribute: function ( attribute, index, offset ) {\\n\\n\\t\\t\\tif ( offset !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x = attribute.getX( index );\\n\\t\\t\\tthis.y = attribute.getY( index );\\n\\t\\t\\tthis.z = attribute.getZ( index );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author bhouston / http://clara.io\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction Matrix3() {\\n\\n\\t\\tthis.elements = [\\n\\n\\t\\t\\t1, 0, 0,\\n\\t\\t\\t0, 1, 0,\\n\\t\\t\\t0, 0, 1\\n\\n\\t\\t];\\n\\n\\t\\tif ( arguments.length > 0 ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tObject.assign( Matrix3.prototype, {\\n\\n\\t\\tisMatrix3: true,\\n\\n\\t\\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\\n\\t\\t\\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\\n\\t\\t\\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tidentity: function () {\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\t1, 0, 0,\\n\\t\\t\\t\\t0, 1, 0,\\n\\t\\t\\t\\t0, 0, 1\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().fromArray( this.elements );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( m ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar me = m.elements;\\n\\n\\t\\t\\tte[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];\\n\\t\\t\\tte[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];\\n\\t\\t\\tte[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromMatrix4: function ( m ) {\\n\\n\\t\\t\\tvar me = m.elements;\\n\\n\\t\\t\\tthis.set(\\n\\n\\t\\t\\t\\tme[ 0 ], me[ 4 ], me[ 8 ],\\n\\t\\t\\t\\tme[ 1 ], me[ 5 ], me[ 9 ],\\n\\t\\t\\t\\tme[ 2 ], me[ 6 ], me[ 10 ]\\n\\n\\t\\t\\t);\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyToBufferAttribute: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function applyToBufferAttribute( attribute ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tv1.x = attribute.getX( i );\\n\\t\\t\\t\\t\\tv1.y = attribute.getY( i );\\n\\t\\t\\t\\t\\tv1.z = attribute.getZ( i );\\n\\n\\t\\t\\t\\t\\tv1.applyMatrix3( this );\\n\\n\\t\\t\\t\\t\\tattribute.setXYZ( i, v1.x, v1.y, v1.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn attribute;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tmultiply: function ( m ) {\\n\\n\\t\\t\\treturn this.multiplyMatrices( this, m );\\n\\n\\t\\t},\\n\\n\\t\\tpremultiply: function ( m ) {\\n\\n\\t\\t\\treturn this.multiplyMatrices( m, this );\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyMatrices: function ( a, b ) {\\n\\n\\t\\t\\tvar ae = a.elements;\\n\\t\\t\\tvar be = b.elements;\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];\\n\\t\\t\\tvar a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];\\n\\t\\t\\tvar a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];\\n\\n\\t\\t\\tvar b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];\\n\\t\\t\\tvar b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];\\n\\t\\t\\tvar b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];\\n\\n\\t\\t\\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;\\n\\t\\t\\tte[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;\\n\\t\\t\\tte[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;\\n\\n\\t\\t\\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;\\n\\t\\t\\tte[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;\\n\\t\\t\\tte[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;\\n\\n\\t\\t\\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;\\n\\t\\t\\tte[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;\\n\\t\\t\\tte[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyScalar: function ( s ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\\n\\t\\t\\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\\n\\t\\t\\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdeterminant: function () {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\\n\\t\\t\\t\\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\\n\\t\\t\\t\\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\\n\\n\\t\\t\\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\\n\\n\\t\\t},\\n\\n\\t\\tgetInverse: function ( matrix, throwOnDegenerate ) {\\n\\n\\t\\t\\tif ( matrix && matrix.isMatrix4 ) {\\n\\n\\t\\t\\t\\tconsole.error( \\\"THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.\\\" );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar me = matrix.elements,\\n\\t\\t\\t\\tte = this.elements,\\n\\n\\t\\t\\t\\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\\n\\t\\t\\t\\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\\n\\t\\t\\t\\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\\n\\n\\t\\t\\t\\tt11 = n33 * n22 - n32 * n23,\\n\\t\\t\\t\\tt12 = n32 * n13 - n33 * n12,\\n\\t\\t\\t\\tt13 = n23 * n12 - n22 * n13,\\n\\n\\t\\t\\t\\tdet = n11 * t11 + n21 * t12 + n31 * t13;\\n\\n\\t\\t\\tif ( det === 0 ) {\\n\\n\\t\\t\\t\\tvar msg = \\\"THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0\\\";\\n\\n\\t\\t\\t\\tif ( throwOnDegenerate === true ) {\\n\\n\\t\\t\\t\\t\\tthrow new Error( msg );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tconsole.warn( msg );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn this.identity();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar detInv = 1 / det;\\n\\n\\t\\t\\tte[ 0 ] = t11 * detInv;\\n\\t\\t\\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\\n\\t\\t\\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\\n\\n\\t\\t\\tte[ 3 ] = t12 * detInv;\\n\\t\\t\\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\\n\\t\\t\\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\\n\\n\\t\\t\\tte[ 6 ] = t13 * detInv;\\n\\t\\t\\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\\n\\t\\t\\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttranspose: function () {\\n\\n\\t\\t\\tvar tmp, m = this.elements;\\n\\n\\t\\t\\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\\n\\t\\t\\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\\n\\t\\t\\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetNormalMatrix: function ( matrix4 ) {\\n\\n\\t\\t\\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\\n\\n\\t\\t},\\n\\n\\t\\ttransposeIntoArray: function ( r ) {\\n\\n\\t\\t\\tvar m = this.elements;\\n\\n\\t\\t\\tr[ 0 ] = m[ 0 ];\\n\\t\\t\\tr[ 1 ] = m[ 3 ];\\n\\t\\t\\tr[ 2 ] = m[ 6 ];\\n\\t\\t\\tr[ 3 ] = m[ 1 ];\\n\\t\\t\\tr[ 4 ] = m[ 4 ];\\n\\t\\t\\tr[ 5 ] = m[ 7 ];\\n\\t\\t\\tr[ 6 ] = m[ 2 ];\\n\\t\\t\\tr[ 7 ] = m[ 5 ];\\n\\t\\t\\tr[ 8 ] = m[ 8 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {\\n\\n\\t\\t\\tvar c = Math.cos( rotation );\\n\\t\\t\\tvar s = Math.sin( rotation );\\n\\n\\t\\t\\tthis.set(\\n\\t\\t\\t\\tsx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,\\n\\t\\t\\t\\t- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,\\n\\t\\t\\t\\t0, 0, 1\\n\\t\\t\\t);\\n\\n\\t\\t},\\n\\n\\t\\tscale: function ( sx, sy ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;\\n\\t\\t\\tte[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\trotate: function ( theta ) {\\n\\n\\t\\t\\tvar c = Math.cos( theta );\\n\\t\\t\\tvar s = Math.sin( theta );\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tvar a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];\\n\\t\\t\\tvar a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];\\n\\n\\t\\t\\tte[ 0 ] = c * a11 + s * a21;\\n\\t\\t\\tte[ 3 ] = c * a12 + s * a22;\\n\\t\\t\\tte[ 6 ] = c * a13 + s * a23;\\n\\n\\t\\t\\tte[ 1 ] = - s * a11 + c * a21;\\n\\t\\t\\tte[ 4 ] = - s * a12 + c * a22;\\n\\t\\t\\tte[ 7 ] = - s * a13 + c * a23;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttranslate: function ( tx, ty ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tte[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];\\n\\t\\t\\tte[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( matrix ) {\\n\\n\\t\\t\\tvar te = this.elements;\\n\\t\\t\\tvar me = matrix.elements;\\n\\n\\t\\t\\tfor ( var i = 0; i < 9; i ++ ) {\\n\\n\\t\\t\\t\\tif ( te[ i ] !== me[ i ] ) return false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0; i < 9; i ++ ) {\\n\\n\\t\\t\\t\\tthis.elements[ i ] = array[ i + offset ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tvar te = this.elements;\\n\\n\\t\\t\\tarray[ offset ] = te[ 0 ];\\n\\t\\t\\tarray[ offset + 1 ] = te[ 1 ];\\n\\t\\t\\tarray[ offset + 2 ] = te[ 2 ];\\n\\n\\t\\t\\tarray[ offset + 3 ] = te[ 3 ];\\n\\t\\t\\tarray[ offset + 4 ] = te[ 4 ];\\n\\t\\t\\tarray[ offset + 5 ] = te[ 5 ];\\n\\n\\t\\t\\tarray[ offset + 6 ] = te[ 6 ];\\n\\t\\t\\tarray[ offset + 7 ] = te[ 7 ];\\n\\t\\t\\tarray[ offset + 8 ] = te[ 8 ];\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author szimek / https://github.com/szimek/\\n\\t */\\n\\n\\tvar textureId = 0;\\n\\n\\tfunction Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\\n\\n\\t\\tObject.defineProperty( this, 'id', { value: textureId ++ } );\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.name = '';\\n\\n\\t\\tthis.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;\\n\\t\\tthis.mipmaps = [];\\n\\n\\t\\tthis.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;\\n\\n\\t\\tthis.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;\\n\\t\\tthis.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;\\n\\n\\t\\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\\n\\t\\tthis.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;\\n\\n\\t\\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\\n\\n\\t\\tthis.format = format !== undefined ? format : RGBAFormat;\\n\\t\\tthis.type = type !== undefined ? type : UnsignedByteType;\\n\\n\\t\\tthis.offset = new Vector2( 0, 0 );\\n\\t\\tthis.repeat = new Vector2( 1, 1 );\\n\\t\\tthis.center = new Vector2( 0, 0 );\\n\\t\\tthis.rotation = 0;\\n\\n\\t\\tthis.matrixAutoUpdate = true;\\n\\t\\tthis.matrix = new Matrix3();\\n\\n\\t\\tthis.generateMipmaps = true;\\n\\t\\tthis.premultiplyAlpha = false;\\n\\t\\tthis.flipY = true;\\n\\t\\tthis.unpackAlignment = 4;\\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\\n\\n\\t\\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\\n\\t\\t//\\n\\t\\t// Also changing the encoding after already used by a Material will not automatically make the Material\\n\\t\\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\\n\\t\\tthis.encoding = encoding !== undefined ? encoding : LinearEncoding;\\n\\n\\t\\tthis.version = 0;\\n\\t\\tthis.onUpdate = null;\\n\\n\\t}\\n\\n\\tTexture.DEFAULT_IMAGE = undefined;\\n\\tTexture.DEFAULT_MAPPING = UVMapping;\\n\\n\\tTexture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: Texture,\\n\\n\\t\\tisTexture: true,\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.name = source.name;\\n\\n\\t\\t\\tthis.image = source.image;\\n\\t\\t\\tthis.mipmaps = source.mipmaps.slice( 0 );\\n\\n\\t\\t\\tthis.mapping = source.mapping;\\n\\n\\t\\t\\tthis.wrapS = source.wrapS;\\n\\t\\t\\tthis.wrapT = source.wrapT;\\n\\n\\t\\t\\tthis.magFilter = source.magFilter;\\n\\t\\t\\tthis.minFilter = source.minFilter;\\n\\n\\t\\t\\tthis.anisotropy = source.anisotropy;\\n\\n\\t\\t\\tthis.format = source.format;\\n\\t\\t\\tthis.type = source.type;\\n\\n\\t\\t\\tthis.offset.copy( source.offset );\\n\\t\\t\\tthis.repeat.copy( source.repeat );\\n\\t\\t\\tthis.center.copy( source.center );\\n\\t\\t\\tthis.rotation = source.rotation;\\n\\n\\t\\t\\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\\n\\t\\t\\tthis.matrix.copy( source.matrix );\\n\\n\\t\\t\\tthis.generateMipmaps = source.generateMipmaps;\\n\\t\\t\\tthis.premultiplyAlpha = source.premultiplyAlpha;\\n\\t\\t\\tthis.flipY = source.flipY;\\n\\t\\t\\tthis.unpackAlignment = source.unpackAlignment;\\n\\t\\t\\tthis.encoding = source.encoding;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\\n\\n\\t\\t\\tif ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {\\n\\n\\t\\t\\t\\treturn meta.textures[ this.uuid ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction getDataURL( image ) {\\n\\n\\t\\t\\t\\tvar canvas;\\n\\n\\t\\t\\t\\tif ( image instanceof HTMLCanvasElement ) {\\n\\n\\t\\t\\t\\t\\tcanvas = image;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tcanvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\n\\t\\t\\t\\t\\tcanvas.width = image.width;\\n\\t\\t\\t\\t\\tcanvas.height = image.height;\\n\\n\\t\\t\\t\\t\\tvar context = canvas.getContext( '2d' );\\n\\n\\t\\t\\t\\t\\tif ( image instanceof ImageData ) {\\n\\n\\t\\t\\t\\t\\t\\tcontext.putImageData( image, 0, 0 );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tcontext.drawImage( image, 0, 0, image.width, image.height );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\\n\\n\\t\\t\\t\\t\\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\treturn canvas.toDataURL( 'image/png' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar output = {\\n\\t\\t\\t\\tmetadata: {\\n\\t\\t\\t\\t\\tversion: 4.5,\\n\\t\\t\\t\\t\\ttype: 'Texture',\\n\\t\\t\\t\\t\\tgenerator: 'Texture.toJSON'\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tuuid: this.uuid,\\n\\t\\t\\t\\tname: this.name,\\n\\n\\t\\t\\t\\tmapping: this.mapping,\\n\\n\\t\\t\\t\\trepeat: [ this.repeat.x, this.repeat.y ],\\n\\t\\t\\t\\toffset: [ this.offset.x, this.offset.y ],\\n\\t\\t\\t\\tcenter: [ this.center.x, this.center.y ],\\n\\t\\t\\t\\trotation: this.rotation,\\n\\n\\t\\t\\t\\twrap: [ this.wrapS, this.wrapT ],\\n\\n\\t\\t\\t\\tminFilter: this.minFilter,\\n\\t\\t\\t\\tmagFilter: this.magFilter,\\n\\t\\t\\t\\tanisotropy: this.anisotropy,\\n\\n\\t\\t\\t\\tflipY: this.flipY\\n\\t\\t\\t};\\n\\n\\t\\t\\tif ( this.image !== undefined ) {\\n\\n\\t\\t\\t\\t// TODO: Move to THREE.Image\\n\\n\\t\\t\\t\\tvar image = this.image;\\n\\n\\t\\t\\t\\tif ( image.uuid === undefined ) {\\n\\n\\t\\t\\t\\t\\timage.uuid = _Math.generateUUID(); // UGH\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {\\n\\n\\t\\t\\t\\t\\tmeta.images[ image.uuid ] = {\\n\\t\\t\\t\\t\\t\\tuuid: image.uuid,\\n\\t\\t\\t\\t\\t\\turl: getDataURL( image )\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\toutput.image = image.uuid;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ! isRootObject ) {\\n\\n\\t\\t\\t\\tmeta.textures[ this.uuid ] = output;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn output;\\n\\n\\t\\t},\\n\\n\\t\\tdispose: function () {\\n\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\n\\n\\t\\t},\\n\\n\\t\\ttransformUv: function ( uv ) {\\n\\n\\t\\t\\tif ( this.mapping !== UVMapping ) return;\\n\\n\\t\\t\\tuv.applyMatrix3( this.matrix );\\n\\n\\t\\t\\tif ( uv.x < 0 || uv.x > 1 ) {\\n\\n\\t\\t\\t\\tswitch ( this.wrapS ) {\\n\\n\\t\\t\\t\\t\\tcase RepeatWrapping:\\n\\n\\t\\t\\t\\t\\t\\tuv.x = uv.x - Math.floor( uv.x );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase ClampToEdgeWrapping:\\n\\n\\t\\t\\t\\t\\t\\tuv.x = uv.x < 0 ? 0 : 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase MirroredRepeatWrapping:\\n\\n\\t\\t\\t\\t\\t\\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tuv.x = Math.ceil( uv.x ) - uv.x;\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tuv.x = uv.x - Math.floor( uv.x );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( uv.y < 0 || uv.y > 1 ) {\\n\\n\\t\\t\\t\\tswitch ( this.wrapT ) {\\n\\n\\t\\t\\t\\t\\tcase RepeatWrapping:\\n\\n\\t\\t\\t\\t\\t\\tuv.y = uv.y - Math.floor( uv.y );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase ClampToEdgeWrapping:\\n\\n\\t\\t\\t\\t\\t\\tuv.y = uv.y < 0 ? 0 : 1;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase MirroredRepeatWrapping:\\n\\n\\t\\t\\t\\t\\t\\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tuv.y = Math.ceil( uv.y ) - uv.y;\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tuv.y = uv.y - Math.floor( uv.y );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.flipY ) {\\n\\n\\t\\t\\t\\tuv.y = 1 - uv.y;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperty( Texture.prototype, \\\"needsUpdate\\\", {\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tif ( value === true ) this.version ++;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author supereggbert / http://www.paulbrunt.co.uk/\\n\\t * @author philogb / http://blog.thejit.org/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author egraether / http://egraether.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction Vector4( x, y, z, w ) {\\n\\n\\t\\tthis.x = x || 0;\\n\\t\\tthis.y = y || 0;\\n\\t\\tthis.z = z || 0;\\n\\t\\tthis.w = ( w !== undefined ) ? w : 1;\\n\\n\\t}\\n\\n\\tObject.assign( Vector4.prototype, {\\n\\n\\t\\tisVector4: true,\\n\\n\\t\\tset: function ( x, y, z, w ) {\\n\\n\\t\\t\\tthis.x = x;\\n\\t\\t\\tthis.y = y;\\n\\t\\t\\tthis.z = z;\\n\\t\\t\\tthis.w = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.x = scalar;\\n\\t\\t\\tthis.y = scalar;\\n\\t\\t\\tthis.z = scalar;\\n\\t\\t\\tthis.w = scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetX: function ( x ) {\\n\\n\\t\\t\\tthis.x = x;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetY: function ( y ) {\\n\\n\\t\\t\\tthis.y = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetZ: function ( z ) {\\n\\n\\t\\t\\tthis.z = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetW: function ( w ) {\\n\\n\\t\\t\\tthis.w = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetComponent: function ( index, value ) {\\n\\n\\t\\t\\tswitch ( index ) {\\n\\n\\t\\t\\t\\tcase 0: this.x = value; break;\\n\\t\\t\\t\\tcase 1: this.y = value; break;\\n\\t\\t\\t\\tcase 2: this.z = value; break;\\n\\t\\t\\t\\tcase 3: this.w = value; break;\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetComponent: function ( index ) {\\n\\n\\t\\t\\tswitch ( index ) {\\n\\n\\t\\t\\t\\tcase 0: return this.x;\\n\\t\\t\\t\\tcase 1: return this.y;\\n\\t\\t\\t\\tcase 2: return this.z;\\n\\t\\t\\t\\tcase 3: return this.w;\\n\\t\\t\\t\\tdefault: throw new Error( 'index is out of range: ' + index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.x, this.y, this.z, this.w );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( v ) {\\n\\n\\t\\t\\tthis.x = v.x;\\n\\t\\t\\tthis.y = v.y;\\n\\t\\t\\tthis.z = v.z;\\n\\t\\t\\tthis.w = ( v.w !== undefined ) ? v.w : 1;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tadd: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.addVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x += v.x;\\n\\t\\t\\tthis.y += v.y;\\n\\t\\t\\tthis.z += v.z;\\n\\t\\t\\tthis.w += v.w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScalar: function ( s ) {\\n\\n\\t\\t\\tthis.x += s;\\n\\t\\t\\tthis.y += s;\\n\\t\\t\\tthis.z += s;\\n\\t\\t\\tthis.w += s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x + b.x;\\n\\t\\t\\tthis.y = a.y + b.y;\\n\\t\\t\\tthis.z = a.z + b.z;\\n\\t\\t\\tthis.w = a.w + b.w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScaledVector: function ( v, s ) {\\n\\n\\t\\t\\tthis.x += v.x * s;\\n\\t\\t\\tthis.y += v.y * s;\\n\\t\\t\\tthis.z += v.z * s;\\n\\t\\t\\tthis.w += v.w * s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsub: function ( v, w ) {\\n\\n\\t\\t\\tif ( w !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\\n\\t\\t\\t\\treturn this.subVectors( v, w );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x -= v.x;\\n\\t\\t\\tthis.y -= v.y;\\n\\t\\t\\tthis.z -= v.z;\\n\\t\\t\\tthis.w -= v.w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsubScalar: function ( s ) {\\n\\n\\t\\t\\tthis.x -= s;\\n\\t\\t\\tthis.y -= s;\\n\\t\\t\\tthis.z -= s;\\n\\t\\t\\tthis.w -= s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsubVectors: function ( a, b ) {\\n\\n\\t\\t\\tthis.x = a.x - b.x;\\n\\t\\t\\tthis.y = a.y - b.y;\\n\\t\\t\\tthis.z = a.z - b.z;\\n\\t\\t\\tthis.w = a.w - b.w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.x *= scalar;\\n\\t\\t\\tthis.y *= scalar;\\n\\t\\t\\tthis.z *= scalar;\\n\\t\\t\\tthis.w *= scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix4: function ( m ) {\\n\\n\\t\\t\\tvar x = this.x, y = this.y, z = this.z, w = this.w;\\n\\t\\t\\tvar e = m.elements;\\n\\n\\t\\t\\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\\n\\t\\t\\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\\n\\t\\t\\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\\n\\t\\t\\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdivideScalar: function ( scalar ) {\\n\\n\\t\\t\\treturn this.multiplyScalar( 1 / scalar );\\n\\n\\t\\t},\\n\\n\\t\\tsetAxisAngleFromQuaternion: function ( q ) {\\n\\n\\t\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\\n\\n\\t\\t\\t// q is assumed to be normalized\\n\\n\\t\\t\\tthis.w = 2 * Math.acos( q.w );\\n\\n\\t\\t\\tvar s = Math.sqrt( 1 - q.w * q.w );\\n\\n\\t\\t\\tif ( s < 0.0001 ) {\\n\\n\\t\\t\\t\\tthis.x = 1;\\n\\t\\t\\t\\tthis.y = 0;\\n\\t\\t\\t\\tthis.z = 0;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.x = q.x / s;\\n\\t\\t\\t\\tthis.y = q.y / s;\\n\\t\\t\\t\\tthis.z = q.z / s;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetAxisAngleFromRotationMatrix: function ( m ) {\\n\\n\\t\\t\\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\\n\\n\\t\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\n\\n\\t\\t\\tvar angle, x, y, z,\\t\\t// variables for result\\n\\t\\t\\t\\tepsilon = 0.01,\\t\\t// margin to allow for rounding errors\\n\\t\\t\\t\\tepsilon2 = 0.1,\\t\\t// margin to distinguish between 0 and 180 degrees\\n\\n\\t\\t\\t\\tte = m.elements,\\n\\n\\t\\t\\t\\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\\n\\t\\t\\t\\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\\n\\t\\t\\t\\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\\n\\n\\t\\t\\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\\n\\t\\t\\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\\n\\t\\t\\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\\n\\n\\t\\t\\t\\t// singularity found\\n\\t\\t\\t\\t// first check for identity matrix which must have +1 for all terms\\n\\t\\t\\t\\t// in leading diagonal and zero in other terms\\n\\n\\t\\t\\t\\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\\n\\t\\t\\t\\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\\n\\t\\t\\t\\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\\n\\t\\t\\t\\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\\n\\n\\t\\t\\t\\t\\t// this singularity is identity matrix so angle = 0\\n\\n\\t\\t\\t\\t\\tthis.set( 1, 0, 0, 0 );\\n\\n\\t\\t\\t\\t\\treturn this; // zero angle, arbitrary axis\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// otherwise this singularity is angle = 180\\n\\n\\t\\t\\t\\tangle = Math.PI;\\n\\n\\t\\t\\t\\tvar xx = ( m11 + 1 ) / 2;\\n\\t\\t\\t\\tvar yy = ( m22 + 1 ) / 2;\\n\\t\\t\\t\\tvar zz = ( m33 + 1 ) / 2;\\n\\t\\t\\t\\tvar xy = ( m12 + m21 ) / 4;\\n\\t\\t\\t\\tvar xz = ( m13 + m31 ) / 4;\\n\\t\\t\\t\\tvar yz = ( m23 + m32 ) / 4;\\n\\n\\t\\t\\t\\tif ( ( xx > yy ) && ( xx > zz ) ) {\\n\\n\\t\\t\\t\\t\\t// m11 is the largest diagonal term\\n\\n\\t\\t\\t\\t\\tif ( xx < epsilon ) {\\n\\n\\t\\t\\t\\t\\t\\tx = 0;\\n\\t\\t\\t\\t\\t\\ty = 0.707106781;\\n\\t\\t\\t\\t\\t\\tz = 0.707106781;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tx = Math.sqrt( xx );\\n\\t\\t\\t\\t\\t\\ty = xy / x;\\n\\t\\t\\t\\t\\t\\tz = xz / x;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( yy > zz ) {\\n\\n\\t\\t\\t\\t\\t// m22 is the largest diagonal term\\n\\n\\t\\t\\t\\t\\tif ( yy < epsilon ) {\\n\\n\\t\\t\\t\\t\\t\\tx = 0.707106781;\\n\\t\\t\\t\\t\\t\\ty = 0;\\n\\t\\t\\t\\t\\t\\tz = 0.707106781;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\ty = Math.sqrt( yy );\\n\\t\\t\\t\\t\\t\\tx = xy / y;\\n\\t\\t\\t\\t\\t\\tz = yz / y;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// m33 is the largest diagonal term so base result on this\\n\\n\\t\\t\\t\\t\\tif ( zz < epsilon ) {\\n\\n\\t\\t\\t\\t\\t\\tx = 0.707106781;\\n\\t\\t\\t\\t\\t\\ty = 0.707106781;\\n\\t\\t\\t\\t\\t\\tz = 0;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tz = Math.sqrt( zz );\\n\\t\\t\\t\\t\\t\\tx = xz / z;\\n\\t\\t\\t\\t\\t\\ty = yz / z;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.set( x, y, z, angle );\\n\\n\\t\\t\\t\\treturn this; // return 180 deg rotation\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// as we have reached here there are no singularities so we can handle normally\\n\\n\\t\\t\\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\\n\\t\\t\\t                   ( m13 - m31 ) * ( m13 - m31 ) +\\n\\t\\t\\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\\n\\n\\t\\t\\tif ( Math.abs( s ) < 0.001 ) s = 1;\\n\\n\\t\\t\\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\\n\\t\\t\\t// caught by singularity test above, but I've left it in just in case\\n\\n\\t\\t\\tthis.x = ( m32 - m23 ) / s;\\n\\t\\t\\tthis.y = ( m13 - m31 ) / s;\\n\\t\\t\\tthis.z = ( m21 - m12 ) / s;\\n\\t\\t\\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmin: function ( v ) {\\n\\n\\t\\t\\tthis.x = Math.min( this.x, v.x );\\n\\t\\t\\tthis.y = Math.min( this.y, v.y );\\n\\t\\t\\tthis.z = Math.min( this.z, v.z );\\n\\t\\t\\tthis.w = Math.min( this.w, v.w );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmax: function ( v ) {\\n\\n\\t\\t\\tthis.x = Math.max( this.x, v.x );\\n\\t\\t\\tthis.y = Math.max( this.y, v.y );\\n\\t\\t\\tthis.z = Math.max( this.z, v.z );\\n\\t\\t\\tthis.w = Math.max( this.w, v.w );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclamp: function ( min, max ) {\\n\\n\\t\\t\\t// assumes min < max, componentwise\\n\\n\\t\\t\\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\\n\\t\\t\\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\\n\\t\\t\\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\\n\\t\\t\\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclampScalar: function () {\\n\\n\\t\\t\\tvar min, max;\\n\\n\\t\\t\\treturn function clampScalar( minVal, maxVal ) {\\n\\n\\t\\t\\t\\tif ( min === undefined ) {\\n\\n\\t\\t\\t\\t\\tmin = new Vector4();\\n\\t\\t\\t\\t\\tmax = new Vector4();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tmin.set( minVal, minVal, minVal, minVal );\\n\\t\\t\\t\\tmax.set( maxVal, maxVal, maxVal, maxVal );\\n\\n\\t\\t\\t\\treturn this.clamp( min, max );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclampLength: function ( min, max ) {\\n\\n\\t\\t\\tvar length = this.length();\\n\\n\\t\\t\\treturn this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );\\n\\n\\t\\t},\\n\\n\\t\\tfloor: function () {\\n\\n\\t\\t\\tthis.x = Math.floor( this.x );\\n\\t\\t\\tthis.y = Math.floor( this.y );\\n\\t\\t\\tthis.z = Math.floor( this.z );\\n\\t\\t\\tthis.w = Math.floor( this.w );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tceil: function () {\\n\\n\\t\\t\\tthis.x = Math.ceil( this.x );\\n\\t\\t\\tthis.y = Math.ceil( this.y );\\n\\t\\t\\tthis.z = Math.ceil( this.z );\\n\\t\\t\\tthis.w = Math.ceil( this.w );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tround: function () {\\n\\n\\t\\t\\tthis.x = Math.round( this.x );\\n\\t\\t\\tthis.y = Math.round( this.y );\\n\\t\\t\\tthis.z = Math.round( this.z );\\n\\t\\t\\tthis.w = Math.round( this.w );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\troundToZero: function () {\\n\\n\\t\\t\\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\\n\\t\\t\\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\\n\\t\\t\\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\\n\\t\\t\\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tnegate: function () {\\n\\n\\t\\t\\tthis.x = - this.x;\\n\\t\\t\\tthis.y = - this.y;\\n\\t\\t\\tthis.z = - this.z;\\n\\t\\t\\tthis.w = - this.w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdot: function ( v ) {\\n\\n\\t\\t\\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\\n\\n\\t\\t},\\n\\n\\t\\tlengthSq: function () {\\n\\n\\t\\t\\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\\n\\n\\t\\t},\\n\\n\\t\\tlength: function () {\\n\\n\\t\\t\\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\\n\\n\\t\\t},\\n\\n\\t\\tmanhattanLength: function () {\\n\\n\\t\\t\\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\\n\\n\\t\\t},\\n\\n\\t\\tnormalize: function () {\\n\\n\\t\\t\\treturn this.divideScalar( this.length() || 1 );\\n\\n\\t\\t},\\n\\n\\t\\tsetLength: function ( length ) {\\n\\n\\t\\t\\treturn this.normalize().multiplyScalar( length );\\n\\n\\t\\t},\\n\\n\\t\\tlerp: function ( v, alpha ) {\\n\\n\\t\\t\\tthis.x += ( v.x - this.x ) * alpha;\\n\\t\\t\\tthis.y += ( v.y - this.y ) * alpha;\\n\\t\\t\\tthis.z += ( v.z - this.z ) * alpha;\\n\\t\\t\\tthis.w += ( v.w - this.w ) * alpha;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tlerpVectors: function ( v1, v2, alpha ) {\\n\\n\\t\\t\\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( v ) {\\n\\n\\t\\t\\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis.x = array[ offset ];\\n\\t\\t\\tthis.y = array[ offset + 1 ];\\n\\t\\t\\tthis.z = array[ offset + 2 ];\\n\\t\\t\\tthis.w = array[ offset + 3 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tarray[ offset ] = this.x;\\n\\t\\t\\tarray[ offset + 1 ] = this.y;\\n\\t\\t\\tarray[ offset + 2 ] = this.z;\\n\\t\\t\\tarray[ offset + 3 ] = this.w;\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\tfromBufferAttribute: function ( attribute, index, offset ) {\\n\\n\\t\\t\\tif ( offset !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.x = attribute.getX( index );\\n\\t\\t\\tthis.y = attribute.getY( index );\\n\\t\\t\\tthis.z = attribute.getZ( index );\\n\\t\\t\\tthis.w = attribute.getW( index );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author szimek / https://github.com/szimek/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author Marius Kintel / https://github.com/kintel\\n\\t */\\n\\n\\t/*\\n\\t In options, we can specify:\\n\\t * Texture parameters for an auto-generated target texture\\n\\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\\n\\t*/\\n\\tfunction WebGLRenderTarget( width, height, options ) {\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.width = width;\\n\\t\\tthis.height = height;\\n\\n\\t\\tthis.scissor = new Vector4( 0, 0, width, height );\\n\\t\\tthis.scissorTest = false;\\n\\n\\t\\tthis.viewport = new Vector4( 0, 0, width, height );\\n\\n\\t\\toptions = options || {};\\n\\n\\t\\tif ( options.minFilter === undefined ) options.minFilter = LinearFilter;\\n\\n\\t\\tthis.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\\n\\n\\t\\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\\n\\t\\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\\n\\t\\tthis.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;\\n\\n\\t}\\n\\n\\tWebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: WebGLRenderTarget,\\n\\n\\t\\tisWebGLRenderTarget: true,\\n\\n\\t\\tsetSize: function ( width, height ) {\\n\\n\\t\\t\\tif ( this.width !== width || this.height !== height ) {\\n\\n\\t\\t\\t\\tthis.width = width;\\n\\t\\t\\t\\tthis.height = height;\\n\\n\\t\\t\\t\\tthis.dispose();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.viewport.set( 0, 0, width, height );\\n\\t\\t\\tthis.scissor.set( 0, 0, width, height );\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.width = source.width;\\n\\t\\t\\tthis.height = source.height;\\n\\n\\t\\t\\tthis.viewport.copy( source.viewport );\\n\\n\\t\\t\\tthis.texture = source.texture.clone();\\n\\n\\t\\t\\tthis.depthBuffer = source.depthBuffer;\\n\\t\\t\\tthis.stencilBuffer = source.stencilBuffer;\\n\\t\\t\\tthis.depthTexture = source.depthTexture;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdispose: function () {\\n\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com\\n\\t */\\n\\n\\tfunction WebGLRenderTargetCube( width, height, options ) {\\n\\n\\t\\tWebGLRenderTarget.call( this, width, height, options );\\n\\n\\t\\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\\n\\t\\tthis.activeMipMapLevel = 0;\\n\\n\\t}\\n\\n\\tWebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );\\n\\tWebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;\\n\\n\\tWebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\\n\\n\\t\\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\\n\\n\\t\\tthis.image = { data: data, width: width, height: height };\\n\\n\\t\\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\\n\\t\\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\\n\\n\\t\\tthis.generateMipmaps = false;\\n\\t\\tthis.flipY = false;\\n\\t\\tthis.unpackAlignment = 1;\\n\\n\\t}\\n\\n\\tDataTexture.prototype = Object.create( Texture.prototype );\\n\\tDataTexture.prototype.constructor = DataTexture;\\n\\n\\tDataTexture.prototype.isDataTexture = true;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\\n\\n\\t\\timages = images !== undefined ? images : [];\\n\\t\\tmapping = mapping !== undefined ? mapping : CubeReflectionMapping;\\n\\n\\t\\tTexture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\\n\\n\\t\\tthis.flipY = false;\\n\\n\\t}\\n\\n\\tCubeTexture.prototype = Object.create( Texture.prototype );\\n\\tCubeTexture.prototype.constructor = CubeTexture;\\n\\n\\tCubeTexture.prototype.isCubeTexture = true;\\n\\n\\tObject.defineProperty( CubeTexture.prototype, 'images', {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\treturn this.image;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tthis.image = value;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author tschw\\n\\t *\\n\\t * Uniforms of a program.\\n\\t * Those form a tree structure with a special top-level container for the root,\\n\\t * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\\n\\t *\\n\\t *\\n\\t * Properties of inner nodes including the top-level container:\\n\\t *\\n\\t * .seq - array of nested uniforms\\n\\t * .map - nested uniforms by name\\n\\t *\\n\\t *\\n\\t * Methods of all nodes except the top-level container:\\n\\t *\\n\\t * .setValue( gl, value, [renderer] )\\n\\t *\\n\\t * \\t\\tuploads a uniform value(s)\\n\\t *  \\tthe 'renderer' parameter is needed for sampler uniforms\\n\\t *\\n\\t *\\n\\t * Static methods of the top-level container (renderer factorizations):\\n\\t *\\n\\t * .upload( gl, seq, values, renderer )\\n\\t *\\n\\t * \\t\\tsets uniforms in 'seq' to 'values[id].value'\\n\\t *\\n\\t * .seqWithValue( seq, values ) : filteredSeq\\n\\t *\\n\\t * \\t\\tfilters 'seq' entries with corresponding entry in values\\n\\t *\\n\\t *\\n\\t * Methods of the top-level container (renderer factorizations):\\n\\t *\\n\\t * .setValue( gl, name, value )\\n\\t *\\n\\t * \\t\\tsets uniform with  name 'name' to 'value'\\n\\t *\\n\\t * .set( gl, obj, prop )\\n\\t *\\n\\t * \\t\\tsets uniform from object and property with same name than uniform\\n\\t *\\n\\t * .setOptional( gl, obj, prop )\\n\\t *\\n\\t * \\t\\tlike .set for an optional property of the object\\n\\t *\\n\\t */\\n\\n\\tvar emptyTexture = new Texture();\\n\\tvar emptyCubeTexture = new CubeTexture();\\n\\n\\t// --- Base for inner nodes (including the root) ---\\n\\n\\tfunction UniformContainer() {\\n\\n\\t\\tthis.seq = [];\\n\\t\\tthis.map = {};\\n\\n\\t}\\n\\n\\t// --- Utilities ---\\n\\n\\t// Array Caches (provide typed arrays for temporary by size)\\n\\n\\tvar arrayCacheF32 = [];\\n\\tvar arrayCacheI32 = [];\\n\\n\\t// Float32Array caches used for uploading Matrix uniforms\\n\\n\\tvar mat4array = new Float32Array( 16 );\\n\\tvar mat3array = new Float32Array( 9 );\\n\\n\\t// Flattening for arrays of vectors and matrices\\n\\n\\tfunction flatten( array, nBlocks, blockSize ) {\\n\\n\\t\\tvar firstElem = array[ 0 ];\\n\\n\\t\\tif ( firstElem <= 0 || firstElem > 0 ) return array;\\n\\t\\t// unoptimized: ! isNaN( firstElem )\\n\\t\\t// see http://jacksondunstan.com/articles/983\\n\\n\\t\\tvar n = nBlocks * blockSize,\\n\\t\\t\\tr = arrayCacheF32[ n ];\\n\\n\\t\\tif ( r === undefined ) {\\n\\n\\t\\t\\tr = new Float32Array( n );\\n\\t\\t\\tarrayCacheF32[ n ] = r;\\n\\n\\t\\t}\\n\\n\\t\\tif ( nBlocks !== 0 ) {\\n\\n\\t\\t\\tfirstElem.toArray( r, 0 );\\n\\n\\t\\t\\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\\n\\n\\t\\t\\t\\toffset += blockSize;\\n\\t\\t\\t\\tarray[ i ].toArray( r, offset );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn r;\\n\\n\\t}\\n\\n\\t// Texture unit allocation\\n\\n\\tfunction allocTexUnits( renderer, n ) {\\n\\n\\t\\tvar r = arrayCacheI32[ n ];\\n\\n\\t\\tif ( r === undefined ) {\\n\\n\\t\\t\\tr = new Int32Array( n );\\n\\t\\t\\tarrayCacheI32[ n ] = r;\\n\\n\\t\\t}\\n\\n\\t\\tfor ( var i = 0; i !== n; ++ i )\\n\\t\\t\\tr[ i ] = renderer.allocTextureUnit();\\n\\n\\t\\treturn r;\\n\\n\\t}\\n\\n\\t// --- Setters ---\\n\\n\\t// Note: Defining these methods externally, because they come in a bunch\\n\\t// and this way their names minify.\\n\\n\\t// Single scalar\\n\\n\\tfunction setValue1f( gl, v ) {\\n\\n\\t\\tgl.uniform1f( this.addr, v );\\n\\n\\t}\\n\\n\\tfunction setValue1i( gl, v ) {\\n\\n\\t\\tgl.uniform1i( this.addr, v );\\n\\n\\t}\\n\\n\\t// Single float vector (from flat array or THREE.VectorN)\\n\\n\\tfunction setValue2fv( gl, v ) {\\n\\n\\t\\tif ( v.x === undefined ) {\\n\\n\\t\\t\\tgl.uniform2fv( this.addr, v );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tgl.uniform2f( this.addr, v.x, v.y );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction setValue3fv( gl, v ) {\\n\\n\\t\\tif ( v.x !== undefined ) {\\n\\n\\t\\t\\tgl.uniform3f( this.addr, v.x, v.y, v.z );\\n\\n\\t\\t} else if ( v.r !== undefined ) {\\n\\n\\t\\t\\tgl.uniform3f( this.addr, v.r, v.g, v.b );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tgl.uniform3fv( this.addr, v );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction setValue4fv( gl, v ) {\\n\\n\\t\\tif ( v.x === undefined ) {\\n\\n\\t\\t\\tgl.uniform4fv( this.addr, v );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Single matrix (from flat array or MatrixN)\\n\\n\\tfunction setValue2fm( gl, v ) {\\n\\n\\t\\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\\n\\n\\t}\\n\\n\\tfunction setValue3fm( gl, v ) {\\n\\n\\t\\tif ( v.elements === undefined ) {\\n\\n\\t\\t\\tgl.uniformMatrix3fv( this.addr, false, v );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tmat3array.set( v.elements );\\n\\t\\t\\tgl.uniformMatrix3fv( this.addr, false, mat3array );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction setValue4fm( gl, v ) {\\n\\n\\t\\tif ( v.elements === undefined ) {\\n\\n\\t\\t\\tgl.uniformMatrix4fv( this.addr, false, v );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tmat4array.set( v.elements );\\n\\t\\t\\tgl.uniformMatrix4fv( this.addr, false, mat4array );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Single texture (2D / Cube)\\n\\n\\tfunction setValueT1( gl, v, renderer ) {\\n\\n\\t\\tvar unit = renderer.allocTextureUnit();\\n\\t\\tgl.uniform1i( this.addr, unit );\\n\\t\\trenderer.setTexture2D( v || emptyTexture, unit );\\n\\n\\t}\\n\\n\\tfunction setValueT6( gl, v, renderer ) {\\n\\n\\t\\tvar unit = renderer.allocTextureUnit();\\n\\t\\tgl.uniform1i( this.addr, unit );\\n\\t\\trenderer.setTextureCube( v || emptyCubeTexture, unit );\\n\\n\\t}\\n\\n\\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\\n\\n\\tfunction setValue2iv( gl, v ) {\\n\\n\\t\\tgl.uniform2iv( this.addr, v );\\n\\n\\t}\\n\\n\\tfunction setValue3iv( gl, v ) {\\n\\n\\t\\tgl.uniform3iv( this.addr, v );\\n\\n\\t}\\n\\n\\tfunction setValue4iv( gl, v ) {\\n\\n\\t\\tgl.uniform4iv( this.addr, v );\\n\\n\\t}\\n\\n\\t// Helper to pick the right setter for the singular case\\n\\n\\tfunction getSingularSetter( type ) {\\n\\n\\t\\tswitch ( type ) {\\n\\n\\t\\t\\tcase 0x1406: return setValue1f; // FLOAT\\n\\t\\t\\tcase 0x8b50: return setValue2fv; // _VEC2\\n\\t\\t\\tcase 0x8b51: return setValue3fv; // _VEC3\\n\\t\\t\\tcase 0x8b52: return setValue4fv; // _VEC4\\n\\n\\t\\t\\tcase 0x8b5a: return setValue2fm; // _MAT2\\n\\t\\t\\tcase 0x8b5b: return setValue3fm; // _MAT3\\n\\t\\t\\tcase 0x8b5c: return setValue4fm; // _MAT4\\n\\n\\t\\t\\tcase 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES\\n\\t\\t\\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\\n\\n\\t\\t\\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\\n\\t\\t\\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\\n\\t\\t\\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\\n\\t\\t\\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Array of scalars\\n\\n\\tfunction setValue1fv( gl, v ) {\\n\\n\\t\\tgl.uniform1fv( this.addr, v );\\n\\n\\t}\\n\\tfunction setValue1iv( gl, v ) {\\n\\n\\t\\tgl.uniform1iv( this.addr, v );\\n\\n\\t}\\n\\n\\t// Array of vectors (flat or from THREE classes)\\n\\n\\tfunction setValueV2a( gl, v ) {\\n\\n\\t\\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\\n\\n\\t}\\n\\n\\tfunction setValueV3a( gl, v ) {\\n\\n\\t\\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\\n\\n\\t}\\n\\n\\tfunction setValueV4a( gl, v ) {\\n\\n\\t\\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\\n\\n\\t}\\n\\n\\t// Array of matrices (flat or from THREE clases)\\n\\n\\tfunction setValueM2a( gl, v ) {\\n\\n\\t\\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\\n\\n\\t}\\n\\n\\tfunction setValueM3a( gl, v ) {\\n\\n\\t\\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\\n\\n\\t}\\n\\n\\tfunction setValueM4a( gl, v ) {\\n\\n\\t\\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\\n\\n\\t}\\n\\n\\t// Array of textures (2D / Cube)\\n\\n\\tfunction setValueT1a( gl, v, renderer ) {\\n\\n\\t\\tvar n = v.length,\\n\\t\\t\\tunits = allocTexUnits( renderer, n );\\n\\n\\t\\tgl.uniform1iv( this.addr, units );\\n\\n\\t\\tfor ( var i = 0; i !== n; ++ i ) {\\n\\n\\t\\t\\trenderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction setValueT6a( gl, v, renderer ) {\\n\\n\\t\\tvar n = v.length,\\n\\t\\t\\tunits = allocTexUnits( renderer, n );\\n\\n\\t\\tgl.uniform1iv( this.addr, units );\\n\\n\\t\\tfor ( var i = 0; i !== n; ++ i ) {\\n\\n\\t\\t\\trenderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Helper to pick the right setter for a pure (bottom-level) array\\n\\n\\tfunction getPureArraySetter( type ) {\\n\\n\\t\\tswitch ( type ) {\\n\\n\\t\\t\\tcase 0x1406: return setValue1fv; // FLOAT\\n\\t\\t\\tcase 0x8b50: return setValueV2a; // _VEC2\\n\\t\\t\\tcase 0x8b51: return setValueV3a; // _VEC3\\n\\t\\t\\tcase 0x8b52: return setValueV4a; // _VEC4\\n\\n\\t\\t\\tcase 0x8b5a: return setValueM2a; // _MAT2\\n\\t\\t\\tcase 0x8b5b: return setValueM3a; // _MAT3\\n\\t\\t\\tcase 0x8b5c: return setValueM4a; // _MAT4\\n\\n\\t\\t\\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\\n\\t\\t\\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\\n\\n\\t\\t\\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\\n\\t\\t\\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\\n\\t\\t\\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\\n\\t\\t\\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// --- Uniform Classes ---\\n\\n\\tfunction SingleUniform( id, activeInfo, addr ) {\\n\\n\\t\\tthis.id = id;\\n\\t\\tthis.addr = addr;\\n\\t\\tthis.setValue = getSingularSetter( activeInfo.type );\\n\\n\\t\\t// this.path = activeInfo.name; // DEBUG\\n\\n\\t}\\n\\n\\tfunction PureArrayUniform( id, activeInfo, addr ) {\\n\\n\\t\\tthis.id = id;\\n\\t\\tthis.addr = addr;\\n\\t\\tthis.size = activeInfo.size;\\n\\t\\tthis.setValue = getPureArraySetter( activeInfo.type );\\n\\n\\t\\t// this.path = activeInfo.name; // DEBUG\\n\\n\\t}\\n\\n\\tfunction StructuredUniform( id ) {\\n\\n\\t\\tthis.id = id;\\n\\n\\t\\tUniformContainer.call( this ); // mix-in\\n\\n\\t}\\n\\n\\tStructuredUniform.prototype.setValue = function ( gl, value ) {\\n\\n\\t\\t// Note: Don't need an extra 'renderer' parameter, since samplers\\n\\t\\t// are not allowed in structured uniforms.\\n\\n\\t\\tvar seq = this.seq;\\n\\n\\t\\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\\n\\n\\t\\t\\tvar u = seq[ i ];\\n\\t\\t\\tu.setValue( gl, value[ u.id ] );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t// --- Top-level ---\\n\\n\\t// Parser - builds up the property tree from the path strings\\n\\n\\tvar RePathPart = /([\\\\w\\\\d_]+)(\\\\])?(\\\\[|\\\\.)?/g;\\n\\n\\t// extracts\\n\\t// \\t- the identifier (member name or array index)\\n\\t//  - followed by an optional right bracket (found when array index)\\n\\t//  - followed by an optional left bracket or dot (type of subscript)\\n\\t//\\n\\t// Note: These portions can be read in a non-overlapping fashion and\\n\\t// allow straightforward parsing of the hierarchy that WebGL encodes\\n\\t// in the uniform names.\\n\\n\\tfunction addUniform( container, uniformObject ) {\\n\\n\\t\\tcontainer.seq.push( uniformObject );\\n\\t\\tcontainer.map[ uniformObject.id ] = uniformObject;\\n\\n\\t}\\n\\n\\tfunction parseUniform( activeInfo, addr, container ) {\\n\\n\\t\\tvar path = activeInfo.name,\\n\\t\\t\\tpathLength = path.length;\\n\\n\\t\\t// reset RegExp object, because of the early exit of a previous run\\n\\t\\tRePathPart.lastIndex = 0;\\n\\n\\t\\tfor ( ; ; ) {\\n\\n\\t\\t\\tvar match = RePathPart.exec( path ),\\n\\t\\t\\t\\tmatchEnd = RePathPart.lastIndex,\\n\\n\\t\\t\\t\\tid = match[ 1 ],\\n\\t\\t\\t\\tidIsIndex = match[ 2 ] === ']',\\n\\t\\t\\t\\tsubscript = match[ 3 ];\\n\\n\\t\\t\\tif ( idIsIndex ) id = id | 0; // convert to integer\\n\\n\\t\\t\\tif ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {\\n\\n\\t\\t\\t\\t// bare name or \\\"pure\\\" bottom-level array \\\"[0]\\\" suffix\\n\\n\\t\\t\\t\\taddUniform( container, subscript === undefined ?\\n\\t\\t\\t\\t\\tnew SingleUniform( id, activeInfo, addr ) :\\n\\t\\t\\t\\t\\tnew PureArrayUniform( id, activeInfo, addr ) );\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// step into inner node / create it in case it doesn't exist\\n\\n\\t\\t\\t\\tvar map = container.map, next = map[ id ];\\n\\n\\t\\t\\t\\tif ( next === undefined ) {\\n\\n\\t\\t\\t\\t\\tnext = new StructuredUniform( id );\\n\\t\\t\\t\\t\\taddUniform( container, next );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcontainer = next;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// Root Container\\n\\n\\tfunction WebGLUniforms( gl, program, renderer ) {\\n\\n\\t\\tUniformContainer.call( this );\\n\\n\\t\\tthis.renderer = renderer;\\n\\n\\t\\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\\n\\n\\t\\tfor ( var i = 0; i < n; ++ i ) {\\n\\n\\t\\t\\tvar info = gl.getActiveUniform( program, i ),\\n\\t\\t\\t\\tpath = info.name,\\n\\t\\t\\t\\taddr = gl.getUniformLocation( program, path );\\n\\n\\t\\t\\tparseUniform( info, addr, this );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tWebGLUniforms.prototype.setValue = function ( gl, name, value ) {\\n\\n\\t\\tvar u = this.map[ name ];\\n\\n\\t\\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\\n\\n\\t};\\n\\n\\tWebGLUniforms.prototype.setOptional = function ( gl, object, name ) {\\n\\n\\t\\tvar v = object[ name ];\\n\\n\\t\\tif ( v !== undefined ) this.setValue( gl, name, v );\\n\\n\\t};\\n\\n\\n\\t// Static interface\\n\\n\\tWebGLUniforms.upload = function ( gl, seq, values, renderer ) {\\n\\n\\t\\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\\n\\n\\t\\t\\tvar u = seq[ i ],\\n\\t\\t\\t\\tv = values[ u.id ];\\n\\n\\t\\t\\tif ( v.needsUpdate !== false ) {\\n\\n\\t\\t\\t\\t// note: always updating when .needsUpdate is undefined\\n\\t\\t\\t\\tu.setValue( gl, v.value, renderer );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tWebGLUniforms.seqWithValue = function ( seq, values ) {\\n\\n\\t\\tvar r = [];\\n\\n\\t\\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\\n\\n\\t\\t\\tvar u = seq[ i ];\\n\\t\\t\\tif ( u.id in values ) r.push( u );\\n\\n\\t\\t}\\n\\n\\t\\treturn r;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\\n\\t\\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\\n\\t\\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\\n\\t\\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\\n\\t\\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\\n\\t\\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\\n\\t\\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\\n\\t\\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\\n\\t\\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\\n\\t\\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\\n\\t\\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\\n\\t\\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\\n\\t\\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\\n\\t\\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\\n\\t\\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\\n\\t\\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\\n\\t\\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\\n\\t\\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\\n\\t\\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\\n\\t\\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\\n\\t\\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\\n\\t\\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\\n\\t\\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\\n\\t\\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\\n\\n\\tfunction Color( r, g, b ) {\\n\\n\\t\\tif ( g === undefined && b === undefined ) {\\n\\n\\t\\t\\t// r is THREE.Color, hex or string\\n\\t\\t\\treturn this.set( r );\\n\\n\\t\\t}\\n\\n\\t\\treturn this.setRGB( r, g, b );\\n\\n\\t}\\n\\n\\tObject.assign( Color.prototype, {\\n\\n\\t\\tisColor: true,\\n\\n\\t\\tr: 1, g: 1, b: 1,\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tif ( value && value.isColor ) {\\n\\n\\t\\t\\t\\tthis.copy( value );\\n\\n\\t\\t\\t} else if ( typeof value === 'number' ) {\\n\\n\\t\\t\\t\\tthis.setHex( value );\\n\\n\\t\\t\\t} else if ( typeof value === 'string' ) {\\n\\n\\t\\t\\t\\tthis.setStyle( value );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.r = scalar;\\n\\t\\t\\tthis.g = scalar;\\n\\t\\t\\tthis.b = scalar;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetHex: function ( hex ) {\\n\\n\\t\\t\\thex = Math.floor( hex );\\n\\n\\t\\t\\tthis.r = ( hex >> 16 & 255 ) / 255;\\n\\t\\t\\tthis.g = ( hex >> 8 & 255 ) / 255;\\n\\t\\t\\tthis.b = ( hex & 255 ) / 255;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetRGB: function ( r, g, b ) {\\n\\n\\t\\t\\tthis.r = r;\\n\\t\\t\\tthis.g = g;\\n\\t\\t\\tthis.b = b;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetHSL: function () {\\n\\n\\t\\t\\tfunction hue2rgb( p, q, t ) {\\n\\n\\t\\t\\t\\tif ( t < 0 ) t += 1;\\n\\t\\t\\t\\tif ( t > 1 ) t -= 1;\\n\\t\\t\\t\\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\\n\\t\\t\\t\\tif ( t < 1 / 2 ) return q;\\n\\t\\t\\t\\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\\n\\t\\t\\t\\treturn p;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn function setHSL( h, s, l ) {\\n\\n\\t\\t\\t\\t// h,s,l ranges are in 0.0 - 1.0\\n\\t\\t\\t\\th = _Math.euclideanModulo( h, 1 );\\n\\t\\t\\t\\ts = _Math.clamp( s, 0, 1 );\\n\\t\\t\\t\\tl = _Math.clamp( l, 0, 1 );\\n\\n\\t\\t\\t\\tif ( s === 0 ) {\\n\\n\\t\\t\\t\\t\\tthis.r = this.g = this.b = l;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\\n\\t\\t\\t\\t\\tvar q = ( 2 * l ) - p;\\n\\n\\t\\t\\t\\t\\tthis.r = hue2rgb( q, p, h + 1 / 3 );\\n\\t\\t\\t\\t\\tthis.g = hue2rgb( q, p, h );\\n\\t\\t\\t\\t\\tthis.b = hue2rgb( q, p, h - 1 / 3 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tsetStyle: function ( style ) {\\n\\n\\t\\t\\tfunction handleAlpha( string ) {\\n\\n\\t\\t\\t\\tif ( string === undefined ) return;\\n\\n\\t\\t\\t\\tif ( parseFloat( string ) < 1 ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tvar m;\\n\\n\\t\\t\\tif ( m = /^((?:rgb|hsl)a?)\\\\(\\\\s*([^\\\\)]*)\\\\)/.exec( style ) ) {\\n\\n\\t\\t\\t\\t// rgb / hsl\\n\\n\\t\\t\\t\\tvar color;\\n\\t\\t\\t\\tvar name = m[ 1 ];\\n\\t\\t\\t\\tvar components = m[ 2 ];\\n\\n\\t\\t\\t\\tswitch ( name ) {\\n\\n\\t\\t\\t\\t\\tcase 'rgb':\\n\\t\\t\\t\\t\\tcase 'rgba':\\n\\n\\t\\t\\t\\t\\t\\tif ( color = /^(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*(,\\\\s*([0-9]*\\\\.?[0-9]+)\\\\s*)?$/.exec( components ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// rgb(255,0,0) rgba(255,0,0,0.5)\\n\\t\\t\\t\\t\\t\\t\\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\\n\\t\\t\\t\\t\\t\\t\\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\\n\\t\\t\\t\\t\\t\\t\\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\\n\\n\\t\\t\\t\\t\\t\\t\\thandleAlpha( color[ 5 ] );\\n\\n\\t\\t\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( color = /^(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*(,\\\\s*([0-9]*\\\\.?[0-9]+)\\\\s*)?$/.exec( components ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\\n\\t\\t\\t\\t\\t\\t\\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\\n\\t\\t\\t\\t\\t\\t\\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\\n\\t\\t\\t\\t\\t\\t\\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\\n\\n\\t\\t\\t\\t\\t\\t\\thandleAlpha( color[ 5 ] );\\n\\n\\t\\t\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'hsl':\\n\\t\\t\\t\\t\\tcase 'hsla':\\n\\n\\t\\t\\t\\t\\t\\tif ( color = /^([0-9]*\\\\.?[0-9]+)\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*(,\\\\s*([0-9]*\\\\.?[0-9]+)\\\\s*)?$/.exec( components ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\\n\\t\\t\\t\\t\\t\\t\\tvar h = parseFloat( color[ 1 ] ) / 360;\\n\\t\\t\\t\\t\\t\\t\\tvar s = parseInt( color[ 2 ], 10 ) / 100;\\n\\t\\t\\t\\t\\t\\t\\tvar l = parseInt( color[ 3 ], 10 ) / 100;\\n\\n\\t\\t\\t\\t\\t\\t\\thandleAlpha( color[ 5 ] );\\n\\n\\t\\t\\t\\t\\t\\t\\treturn this.setHSL( h, s, l );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( m = /^\\\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\\n\\n\\t\\t\\t\\t// hex color\\n\\n\\t\\t\\t\\tvar hex = m[ 1 ];\\n\\t\\t\\t\\tvar size = hex.length;\\n\\n\\t\\t\\t\\tif ( size === 3 ) {\\n\\n\\t\\t\\t\\t\\t// #ff0\\n\\t\\t\\t\\t\\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\\n\\t\\t\\t\\t\\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\\n\\t\\t\\t\\t\\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\\n\\n\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t} else if ( size === 6 ) {\\n\\n\\t\\t\\t\\t\\t// #ff0000\\n\\t\\t\\t\\t\\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\\n\\t\\t\\t\\t\\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\\n\\t\\t\\t\\t\\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\\n\\n\\t\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( style && style.length > 0 ) {\\n\\n\\t\\t\\t\\t// color keywords\\n\\t\\t\\t\\tvar hex = ColorKeywords[ style ];\\n\\n\\t\\t\\t\\tif ( hex !== undefined ) {\\n\\n\\t\\t\\t\\t\\t// red\\n\\t\\t\\t\\t\\tthis.setHex( hex );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// unknown color\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.Color: Unknown color ' + style );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.r, this.g, this.b );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( color ) {\\n\\n\\t\\t\\tthis.r = color.r;\\n\\t\\t\\tthis.g = color.g;\\n\\t\\t\\tthis.b = color.b;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyGammaToLinear: function ( color, gammaFactor ) {\\n\\n\\t\\t\\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\\n\\n\\t\\t\\tthis.r = Math.pow( color.r, gammaFactor );\\n\\t\\t\\tthis.g = Math.pow( color.g, gammaFactor );\\n\\t\\t\\tthis.b = Math.pow( color.b, gammaFactor );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyLinearToGamma: function ( color, gammaFactor ) {\\n\\n\\t\\t\\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\\n\\n\\t\\t\\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\\n\\n\\t\\t\\tthis.r = Math.pow( color.r, safeInverse );\\n\\t\\t\\tthis.g = Math.pow( color.g, safeInverse );\\n\\t\\t\\tthis.b = Math.pow( color.b, safeInverse );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tconvertGammaToLinear: function () {\\n\\n\\t\\t\\tvar r = this.r, g = this.g, b = this.b;\\n\\n\\t\\t\\tthis.r = r * r;\\n\\t\\t\\tthis.g = g * g;\\n\\t\\t\\tthis.b = b * b;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tconvertLinearToGamma: function () {\\n\\n\\t\\t\\tthis.r = Math.sqrt( this.r );\\n\\t\\t\\tthis.g = Math.sqrt( this.g );\\n\\t\\t\\tthis.b = Math.sqrt( this.b );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetHex: function () {\\n\\n\\t\\t\\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\\n\\n\\t\\t},\\n\\n\\t\\tgetHexString: function () {\\n\\n\\t\\t\\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\\n\\n\\t\\t},\\n\\n\\t\\tgetHSL: function ( optionalTarget ) {\\n\\n\\t\\t\\t// h,s,l ranges are in 0.0 - 1.0\\n\\n\\t\\t\\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\\n\\n\\t\\t\\tvar r = this.r, g = this.g, b = this.b;\\n\\n\\t\\t\\tvar max = Math.max( r, g, b );\\n\\t\\t\\tvar min = Math.min( r, g, b );\\n\\n\\t\\t\\tvar hue, saturation;\\n\\t\\t\\tvar lightness = ( min + max ) / 2.0;\\n\\n\\t\\t\\tif ( min === max ) {\\n\\n\\t\\t\\t\\thue = 0;\\n\\t\\t\\t\\tsaturation = 0;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar delta = max - min;\\n\\n\\t\\t\\t\\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\\n\\n\\t\\t\\t\\tswitch ( max ) {\\n\\n\\t\\t\\t\\t\\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\\n\\t\\t\\t\\t\\tcase g: hue = ( b - r ) / delta + 2; break;\\n\\t\\t\\t\\t\\tcase b: hue = ( r - g ) / delta + 4; break;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\thue /= 6;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\thsl.h = hue;\\n\\t\\t\\thsl.s = saturation;\\n\\t\\t\\thsl.l = lightness;\\n\\n\\t\\t\\treturn hsl;\\n\\n\\t\\t},\\n\\n\\t\\tgetStyle: function () {\\n\\n\\t\\t\\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\\n\\n\\t\\t},\\n\\n\\t\\toffsetHSL: function ( h, s, l ) {\\n\\n\\t\\t\\tvar hsl = this.getHSL();\\n\\n\\t\\t\\thsl.h += h; hsl.s += s; hsl.l += l;\\n\\n\\t\\t\\tthis.setHSL( hsl.h, hsl.s, hsl.l );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tadd: function ( color ) {\\n\\n\\t\\t\\tthis.r += color.r;\\n\\t\\t\\tthis.g += color.g;\\n\\t\\t\\tthis.b += color.b;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddColors: function ( color1, color2 ) {\\n\\n\\t\\t\\tthis.r = color1.r + color2.r;\\n\\t\\t\\tthis.g = color1.g + color2.g;\\n\\t\\t\\tthis.b = color1.b + color2.b;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddScalar: function ( s ) {\\n\\n\\t\\t\\tthis.r += s;\\n\\t\\t\\tthis.g += s;\\n\\t\\t\\tthis.b += s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsub: function ( color ) {\\n\\n\\t\\t\\tthis.r = Math.max( 0, this.r - color.r );\\n\\t\\t\\tthis.g = Math.max( 0, this.g - color.g );\\n\\t\\t\\tthis.b = Math.max( 0, this.b - color.b );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiply: function ( color ) {\\n\\n\\t\\t\\tthis.r *= color.r;\\n\\t\\t\\tthis.g *= color.g;\\n\\t\\t\\tthis.b *= color.b;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmultiplyScalar: function ( s ) {\\n\\n\\t\\t\\tthis.r *= s;\\n\\t\\t\\tthis.g *= s;\\n\\t\\t\\tthis.b *= s;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tlerp: function ( color, alpha ) {\\n\\n\\t\\t\\tthis.r += ( color.r - this.r ) * alpha;\\n\\t\\t\\tthis.g += ( color.g - this.g ) * alpha;\\n\\t\\t\\tthis.b += ( color.b - this.b ) * alpha;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( c ) {\\n\\n\\t\\t\\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis.r = array[ offset ];\\n\\t\\t\\tthis.g = array[ offset + 1 ];\\n\\t\\t\\tthis.b = array[ offset + 2 ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tarray[ offset ] = this.r;\\n\\t\\t\\tarray[ offset + 1 ] = this.g;\\n\\t\\t\\tarray[ offset + 2 ] = this.b;\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\treturn this.getHex();\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * Uniforms library for shared webgl shaders\\n\\t */\\n\\n\\tvar UniformsLib = {\\n\\n\\t\\tcommon: {\\n\\n\\t\\t\\tdiffuse: { value: new Color( 0xeeeeee ) },\\n\\t\\t\\topacity: { value: 1.0 },\\n\\n\\t\\t\\tmap: { value: null },\\n\\t\\t\\tuvTransform: { value: new Matrix3() },\\n\\n\\t\\t\\talphaMap: { value: null },\\n\\n\\t\\t},\\n\\n\\t\\tspecularmap: {\\n\\n\\t\\t\\tspecularMap: { value: null },\\n\\n\\t\\t},\\n\\n\\t\\tenvmap: {\\n\\n\\t\\t\\tenvMap: { value: null },\\n\\t\\t\\tflipEnvMap: { value: - 1 },\\n\\t\\t\\treflectivity: { value: 1.0 },\\n\\t\\t\\trefractionRatio: { value: 0.98 }\\n\\n\\t\\t},\\n\\n\\t\\taomap: {\\n\\n\\t\\t\\taoMap: { value: null },\\n\\t\\t\\taoMapIntensity: { value: 1 }\\n\\n\\t\\t},\\n\\n\\t\\tlightmap: {\\n\\n\\t\\t\\tlightMap: { value: null },\\n\\t\\t\\tlightMapIntensity: { value: 1 }\\n\\n\\t\\t},\\n\\n\\t\\temissivemap: {\\n\\n\\t\\t\\temissiveMap: { value: null }\\n\\n\\t\\t},\\n\\n\\t\\tbumpmap: {\\n\\n\\t\\t\\tbumpMap: { value: null },\\n\\t\\t\\tbumpScale: { value: 1 }\\n\\n\\t\\t},\\n\\n\\t\\tnormalmap: {\\n\\n\\t\\t\\tnormalMap: { value: null },\\n\\t\\t\\tnormalScale: { value: new Vector2( 1, 1 ) }\\n\\n\\t\\t},\\n\\n\\t\\tdisplacementmap: {\\n\\n\\t\\t\\tdisplacementMap: { value: null },\\n\\t\\t\\tdisplacementScale: { value: 1 },\\n\\t\\t\\tdisplacementBias: { value: 0 }\\n\\n\\t\\t},\\n\\n\\t\\troughnessmap: {\\n\\n\\t\\t\\troughnessMap: { value: null }\\n\\n\\t\\t},\\n\\n\\t\\tmetalnessmap: {\\n\\n\\t\\t\\tmetalnessMap: { value: null }\\n\\n\\t\\t},\\n\\n\\t\\tgradientmap: {\\n\\n\\t\\t\\tgradientMap: { value: null }\\n\\n\\t\\t},\\n\\n\\t\\tfog: {\\n\\n\\t\\t\\tfogDensity: { value: 0.00025 },\\n\\t\\t\\tfogNear: { value: 1 },\\n\\t\\t\\tfogFar: { value: 2000 },\\n\\t\\t\\tfogColor: { value: new Color( 0xffffff ) }\\n\\n\\t\\t},\\n\\n\\t\\tlights: {\\n\\n\\t\\t\\tambientLightColor: { value: [] },\\n\\n\\t\\t\\tdirectionalLights: { value: [], properties: {\\n\\t\\t\\t\\tdirection: {},\\n\\t\\t\\t\\tcolor: {},\\n\\n\\t\\t\\t\\tshadow: {},\\n\\t\\t\\t\\tshadowBias: {},\\n\\t\\t\\t\\tshadowRadius: {},\\n\\t\\t\\t\\tshadowMapSize: {}\\n\\t\\t\\t} },\\n\\n\\t\\t\\tdirectionalShadowMap: { value: [] },\\n\\t\\t\\tdirectionalShadowMatrix: { value: [] },\\n\\n\\t\\t\\tspotLights: { value: [], properties: {\\n\\t\\t\\t\\tcolor: {},\\n\\t\\t\\t\\tposition: {},\\n\\t\\t\\t\\tdirection: {},\\n\\t\\t\\t\\tdistance: {},\\n\\t\\t\\t\\tconeCos: {},\\n\\t\\t\\t\\tpenumbraCos: {},\\n\\t\\t\\t\\tdecay: {},\\n\\n\\t\\t\\t\\tshadow: {},\\n\\t\\t\\t\\tshadowBias: {},\\n\\t\\t\\t\\tshadowRadius: {},\\n\\t\\t\\t\\tshadowMapSize: {}\\n\\t\\t\\t} },\\n\\n\\t\\t\\tspotShadowMap: { value: [] },\\n\\t\\t\\tspotShadowMatrix: { value: [] },\\n\\n\\t\\t\\tpointLights: { value: [], properties: {\\n\\t\\t\\t\\tcolor: {},\\n\\t\\t\\t\\tposition: {},\\n\\t\\t\\t\\tdecay: {},\\n\\t\\t\\t\\tdistance: {},\\n\\n\\t\\t\\t\\tshadow: {},\\n\\t\\t\\t\\tshadowBias: {},\\n\\t\\t\\t\\tshadowRadius: {},\\n\\t\\t\\t\\tshadowMapSize: {},\\n\\t\\t\\t\\tshadowCameraNear: {},\\n\\t\\t\\t\\tshadowCameraFar: {}\\n\\t\\t\\t} },\\n\\n\\t\\t\\tpointShadowMap: { value: [] },\\n\\t\\t\\tpointShadowMatrix: { value: [] },\\n\\n\\t\\t\\themisphereLights: { value: [], properties: {\\n\\t\\t\\t\\tdirection: {},\\n\\t\\t\\t\\tskyColor: {},\\n\\t\\t\\t\\tgroundColor: {}\\n\\t\\t\\t} },\\n\\n\\t\\t\\t// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src\\n\\t\\t\\trectAreaLights: { value: [], properties: {\\n\\t\\t\\t\\tcolor: {},\\n\\t\\t\\t\\tposition: {},\\n\\t\\t\\t\\twidth: {},\\n\\t\\t\\t\\theight: {}\\n\\t\\t\\t} }\\n\\n\\t\\t},\\n\\n\\t\\tpoints: {\\n\\n\\t\\t\\tdiffuse: { value: new Color( 0xeeeeee ) },\\n\\t\\t\\topacity: { value: 1.0 },\\n\\t\\t\\tsize: { value: 1.0 },\\n\\t\\t\\tscale: { value: 1.0 },\\n\\t\\t\\tmap: { value: null },\\n\\t\\t\\tuvTransform: { value: new Matrix3() }\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * Uniform Utilities\\n\\t */\\n\\n\\tvar UniformsUtils = {\\n\\n\\t\\tmerge: function ( uniforms ) {\\n\\n\\t\\t\\tvar merged = {};\\n\\n\\t\\t\\tfor ( var u = 0; u < uniforms.length; u ++ ) {\\n\\n\\t\\t\\t\\tvar tmp = this.clone( uniforms[ u ] );\\n\\n\\t\\t\\t\\tfor ( var p in tmp ) {\\n\\n\\t\\t\\t\\t\\tmerged[ p ] = tmp[ p ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn merged;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function ( uniforms_src ) {\\n\\n\\t\\t\\tvar uniforms_dst = {};\\n\\n\\t\\t\\tfor ( var u in uniforms_src ) {\\n\\n\\t\\t\\t\\tuniforms_dst[ u ] = {};\\n\\n\\t\\t\\t\\tfor ( var p in uniforms_src[ u ] ) {\\n\\n\\t\\t\\t\\t\\tvar parameter_src = uniforms_src[ u ][ p ];\\n\\n\\t\\t\\t\\t\\tif ( parameter_src && ( parameter_src.isColor ||\\n\\t\\t\\t\\t\\t\\tparameter_src.isMatrix3 || parameter_src.isMatrix4 ||\\n\\t\\t\\t\\t\\t\\tparameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||\\n\\t\\t\\t\\t\\t\\tparameter_src.isTexture ) ) {\\n\\n\\t\\t\\t\\t\\t\\tuniforms_dst[ u ][ p ] = parameter_src.clone();\\n\\n\\t\\t\\t\\t\\t} else if ( Array.isArray( parameter_src ) ) {\\n\\n\\t\\t\\t\\t\\t\\tuniforms_dst[ u ][ p ] = parameter_src.slice();\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tuniforms_dst[ u ][ p ] = parameter_src;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn uniforms_dst;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tvar alphamap_fragment = \\\"#ifdef USE_ALPHAMAP\\\\n\\\\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\\\n#endif\\\\n\\\";\\n\\n\\tvar alphamap_pars_fragment = \\\"#ifdef USE_ALPHAMAP\\\\n\\\\tuniform sampler2D alphaMap;\\\\n#endif\\\\n\\\";\\n\\n\\tvar alphatest_fragment = \\\"#ifdef ALPHATEST\\\\n\\\\tif ( diffuseColor.a < ALPHATEST ) discard;\\\\n#endif\\\\n\\\";\\n\\n\\tvar aomap_fragment = \\\"#ifdef USE_AOMAP\\\\n\\\\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\\\n\\\\treflectedLight.indirectDiffuse *= ambientOcclusion;\\\\n\\\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\\\n\\\\t\\\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\\\n\\\\t\\\\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar aomap_pars_fragment = \\\"#ifdef USE_AOMAP\\\\n\\\\tuniform sampler2D aoMap;\\\\n\\\\tuniform float aoMapIntensity;\\\\n#endif\\\";\\n\\n\\tvar begin_vertex = \\\"\\\\nvec3 transformed = vec3( position );\\\\n\\\";\\n\\n\\tvar beginnormal_vertex = \\\"\\\\nvec3 objectNormal = vec3( normal );\\\\n\\\";\\n\\n\\tvar bsdfs = \\\"float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\\\n\\\\tif( decayExponent > 0.0 ) {\\\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\\\n\\\\t\\\\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\\\n\\\\t\\\\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\\\n\\\\t\\\\treturn distanceFalloff * maxDistanceCutoffFactor;\\\\n#else\\\\n\\\\t\\\\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\\\n#endif\\\\n\\\\t}\\\\n\\\\treturn 1.0;\\\\n}\\\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\\\n\\\\treturn RECIPROCAL_PI * diffuseColor;\\\\n}\\\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\\\n\\\\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\\\n\\\\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\\\n}\\\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\\\n\\\\tfloat a2 = pow2( alpha );\\\\n\\\\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\\\n\\\\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\\\n\\\\treturn 1.0 / ( gl * gv );\\\\n}\\\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\\\n\\\\tfloat a2 = pow2( alpha );\\\\n\\\\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\\\n\\\\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\\\n\\\\treturn 0.5 / max( gv + gl, EPSILON );\\\\n}\\\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\\\n\\\\tfloat a2 = pow2( alpha );\\\\n\\\\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\\\n\\\\treturn RECIPROCAL_PI * a2 / pow2( denom );\\\\n}\\\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\\\n\\\\tfloat alpha = pow2( roughness );\\\\n\\\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\\\n\\\\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\\\n\\\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\\\n\\\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\\\n\\\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\\\n\\\\tvec3 F = F_Schlick( specularColor, dotLH );\\\\n\\\\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\\\n\\\\tfloat D = D_GGX( alpha, dotNH );\\\\n\\\\treturn F * ( G * D );\\\\n}\\\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\\\n\\\\tconst float LUT_SIZE  = 64.0;\\\\n\\\\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\\\n\\\\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\\\\n\\\\tfloat theta = acos( dot( N, V ) );\\\\n\\\\tvec2 uv = vec2(\\\\n\\\\t\\\\tsqrt( saturate( roughness ) ),\\\\n\\\\t\\\\tsaturate( theta / ( 0.5 * PI ) ) );\\\\n\\\\tuv = uv * LUT_SCALE + LUT_BIAS;\\\\n\\\\treturn uv;\\\\n}\\\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\\\n\\\\tfloat l = length( f );\\\\n\\\\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\\\n}\\\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\\\n\\\\tfloat x = dot( v1, v2 );\\\\n\\\\tfloat y = abs( x );\\\\n\\\\tfloat a = 0.86267 + (0.49788 + 0.01436 * y ) * y;\\\\n\\\\tfloat b = 3.45068 + (4.18814 + y) * y;\\\\n\\\\tfloat v = a / b;\\\\n\\\\tfloat theta_sintheta = (x > 0.0) ? v : 0.5 * inversesqrt( 1.0 - x * x ) - v;\\\\n\\\\treturn cross( v1, v2 ) * theta_sintheta;\\\\n}\\\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\\\n\\\\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\\\n\\\\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\\\n\\\\tvec3 lightNormal = cross( v1, v2 );\\\\n\\\\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\\\n\\\\tvec3 T1, T2;\\\\n\\\\tT1 = normalize( V - N * dot( V, N ) );\\\\n\\\\tT2 = - cross( N, T1 );\\\\n\\\\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\\\n\\\\tvec3 coords[ 4 ];\\\\n\\\\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\\\n\\\\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\\\n\\\\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\\\n\\\\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\\\n\\\\tcoords[ 0 ] = normalize( coords[ 0 ] );\\\\n\\\\tcoords[ 1 ] = normalize( coords[ 1 ] );\\\\n\\\\tcoords[ 2 ] = normalize( coords[ 2 ] );\\\\n\\\\tcoords[ 3 ] = normalize( coords[ 3 ] );\\\\n\\\\tvec3 vectorFormFactor = vec3( 0.0 );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\\\n\\\\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\\\n\\\\tvec3 result = vec3( LTC_ClippedSphereFormFactor( vectorFormFactor ) );\\\\n\\\\treturn result;\\\\n}\\\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\\\n\\\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\\\n\\\\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\\\n\\\\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\\\n\\\\tvec4 r = roughness * c0 + c1;\\\\n\\\\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\\\n\\\\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\\\n\\\\treturn specularColor * AB.x + AB.y;\\\\n}\\\\nfloat G_BlinnPhong_Implicit( ) {\\\\n\\\\treturn 0.25;\\\\n}\\\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\\\n\\\\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\\\n}\\\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\\\n\\\\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\\\n\\\\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\\\n\\\\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\\\n\\\\tvec3 F = F_Schlick( specularColor, dotLH );\\\\n\\\\tfloat G = G_BlinnPhong_Implicit( );\\\\n\\\\tfloat D = D_BlinnPhong( shininess, dotNH );\\\\n\\\\treturn F * ( G * D );\\\\n}\\\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\\\n\\\\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\\\n}\\\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\\\n\\\\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\\\n}\\\\n\\\";\\n\\n\\tvar bumpmap_pars_fragment = \\\"#ifdef USE_BUMPMAP\\\\n\\\\tuniform sampler2D bumpMap;\\\\n\\\\tuniform float bumpScale;\\\\n\\\\tvec2 dHdxy_fwd() {\\\\n\\\\t\\\\tvec2 dSTdx = dFdx( vUv );\\\\n\\\\t\\\\tvec2 dSTdy = dFdy( vUv );\\\\n\\\\t\\\\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\\\n\\\\t\\\\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\\\n\\\\t\\\\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\\\n\\\\t\\\\treturn vec2( dBx, dBy );\\\\n\\\\t}\\\\n\\\\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\\\n\\\\t\\\\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\\\n\\\\t\\\\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\\\n\\\\t\\\\tvec3 vN = surf_norm;\\\\n\\\\t\\\\tvec3 R1 = cross( vSigmaY, vN );\\\\n\\\\t\\\\tvec3 R2 = cross( vN, vSigmaX );\\\\n\\\\t\\\\tfloat fDet = dot( vSigmaX, R1 );\\\\n\\\\t\\\\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\\\n\\\\t\\\\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar clipping_planes_fragment = \\\"#if NUM_CLIPPING_PLANES > 0\\\\n\\\\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\\\\n\\\\t\\\\tvec4 plane = clippingPlanes[ i ];\\\\n\\\\t\\\\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\\\n\\\\t}\\\\n\\\\t\\\\t\\\\n\\\\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\\\n\\\\t\\\\tbool clipped = true;\\\\n\\\\t\\\\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\\\\n\\\\t\\\\t\\\\tvec4 plane = clippingPlanes[ i ];\\\\n\\\\t\\\\t\\\\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\tif ( clipped ) discard;\\\\n\\\\t\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar clipping_planes_pars_fragment = \\\"#if NUM_CLIPPING_PLANES > 0\\\\n\\\\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\\\n\\\\t\\\\tvarying vec3 vViewPosition;\\\\n\\\\t#endif\\\\n\\\\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\\\n#endif\\\\n\\\";\\n\\n\\tvar clipping_planes_pars_vertex = \\\"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\\\n\\\\tvarying vec3 vViewPosition;\\\\n#endif\\\\n\\\";\\n\\n\\tvar clipping_planes_vertex = \\\"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n#endif\\\\n\\\";\\n\\n\\tvar color_fragment = \\\"#ifdef USE_COLOR\\\\n\\\\tdiffuseColor.rgb *= vColor;\\\\n#endif\\\";\\n\\n\\tvar color_pars_fragment = \\\"#ifdef USE_COLOR\\\\n\\\\tvarying vec3 vColor;\\\\n#endif\\\\n\\\";\\n\\n\\tvar color_pars_vertex = \\\"#ifdef USE_COLOR\\\\n\\\\tvarying vec3 vColor;\\\\n#endif\\\";\\n\\n\\tvar color_vertex = \\\"#ifdef USE_COLOR\\\\n\\\\tvColor.xyz = color.xyz;\\\\n#endif\\\";\\n\\n\\tvar common = \\\"#define PI 3.14159265359\\\\n#define PI2 6.28318530718\\\\n#define PI_HALF 1.5707963267949\\\\n#define RECIPROCAL_PI 0.31830988618\\\\n#define RECIPROCAL_PI2 0.15915494\\\\n#define LOG2 1.442695\\\\n#define EPSILON 1e-6\\\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\\\nfloat pow2( const in float x ) { return x*x; }\\\\nfloat pow3( const in float x ) { return x*x*x; }\\\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\\\nhighp float rand( const in vec2 uv ) {\\\\n\\\\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\\\n\\\\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\\\n\\\\treturn fract(sin(sn) * c);\\\\n}\\\\nstruct IncidentLight {\\\\n\\\\tvec3 color;\\\\n\\\\tvec3 direction;\\\\n\\\\tbool visible;\\\\n};\\\\nstruct ReflectedLight {\\\\n\\\\tvec3 directDiffuse;\\\\n\\\\tvec3 directSpecular;\\\\n\\\\tvec3 indirectDiffuse;\\\\n\\\\tvec3 indirectSpecular;\\\\n};\\\\nstruct GeometricContext {\\\\n\\\\tvec3 position;\\\\n\\\\tvec3 normal;\\\\n\\\\tvec3 viewDir;\\\\n};\\\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\\\n\\\\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\\\n}\\\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\\\n\\\\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\\\n}\\\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\\\n\\\\tfloat distance = dot( planeNormal, point - pointOnPlane );\\\\n\\\\treturn - distance * planeNormal + point;\\\\n}\\\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\\\n\\\\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\\\n}\\\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\\\n\\\\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\\\n}\\\\nmat3 transposeMat3( const in mat3 m ) {\\\\n\\\\tmat3 tmp;\\\\n\\\\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\\\n\\\\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\\\n\\\\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\\\n\\\\treturn tmp;\\\\n}\\\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\\\n\\\\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\\\n\\\\treturn dot( weights, color.rgb );\\\\n}\\\\n\\\";\\n\\n\\tvar cube_uv_reflection_fragment = \\\"#ifdef ENVMAP_TYPE_CUBE_UV\\\\n#define cubeUV_textureSize (1024.0)\\\\nint getFaceFromDirection(vec3 direction) {\\\\n\\\\tvec3 absDirection = abs(direction);\\\\n\\\\tint face = -1;\\\\n\\\\tif( absDirection.x > absDirection.z ) {\\\\n\\\\t\\\\tif(absDirection.x > absDirection.y )\\\\n\\\\t\\\\t\\\\tface = direction.x > 0.0 ? 0 : 3;\\\\n\\\\t\\\\telse\\\\n\\\\t\\\\t\\\\tface = direction.y > 0.0 ? 1 : 4;\\\\n\\\\t}\\\\n\\\\telse {\\\\n\\\\t\\\\tif(absDirection.z > absDirection.y )\\\\n\\\\t\\\\t\\\\tface = direction.z > 0.0 ? 2 : 5;\\\\n\\\\t\\\\telse\\\\n\\\\t\\\\t\\\\tface = direction.y > 0.0 ? 1 : 4;\\\\n\\\\t}\\\\n\\\\treturn face;\\\\n}\\\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\\\n\\\\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\\\n\\\\tfloat dxRoughness = dFdx(roughness);\\\\n\\\\tfloat dyRoughness = dFdy(roughness);\\\\n\\\\tvec3 dx = dFdx( vec * scale * dxRoughness );\\\\n\\\\tvec3 dy = dFdy( vec * scale * dyRoughness );\\\\n\\\\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\\\n\\\\td = clamp(d, 1.0, cubeUV_rangeClamp);\\\\n\\\\tfloat mipLevel = 0.5 * log2(d);\\\\n\\\\treturn vec2(floor(mipLevel), fract(mipLevel));\\\\n}\\\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\\\n\\\\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\\\n\\\\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\\\n\\\\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\\\n\\\\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\\\n\\\\tfloat powScale = exp2_packed.x * exp2_packed.y;\\\\n\\\\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\\\n\\\\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\\\n\\\\tbool bRes = mipLevel == 0.0;\\\\n\\\\tscale =  bRes && (scale < a) ? a : scale;\\\\n\\\\tvec3 r;\\\\n\\\\tvec2 offset;\\\\n\\\\tint face = getFaceFromDirection(direction);\\\\n\\\\tfloat rcpPowScale = 1.0 / powScale;\\\\n\\\\tif( face == 0) {\\\\n\\\\t\\\\tr = vec3(direction.x, -direction.z, direction.y);\\\\n\\\\t\\\\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\\\n\\\\t}\\\\n\\\\telse if( face == 1) {\\\\n\\\\t\\\\tr = vec3(direction.y, direction.x, direction.z);\\\\n\\\\t\\\\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\\\n\\\\t}\\\\n\\\\telse if( face == 2) {\\\\n\\\\t\\\\tr = vec3(direction.z, direction.x, direction.y);\\\\n\\\\t\\\\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\\\\n\\\\t}\\\\n\\\\telse if( face == 3) {\\\\n\\\\t\\\\tr = vec3(direction.x, direction.z, direction.y);\\\\n\\\\t\\\\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\\\n\\\\t}\\\\n\\\\telse if( face == 4) {\\\\n\\\\t\\\\tr = vec3(direction.y, direction.x, -direction.z);\\\\n\\\\t\\\\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\\\n\\\\t}\\\\n\\\\telse {\\\\n\\\\t\\\\tr = vec3(direction.z, -direction.x, direction.y);\\\\n\\\\t\\\\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\\\n\\\\t\\\\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\\\\n\\\\t}\\\\n\\\\tr = normalize(r);\\\\n\\\\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\\\n\\\\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\\\n\\\\tvec2 base = offset + vec2( texelOffset );\\\\n\\\\treturn base + s * ( scale - 2.0 * texelOffset );\\\\n}\\\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\\\n\\\\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\\\n\\\\tfloat r1 = floor(roughnessVal);\\\\n\\\\tfloat r2 = r1 + 1.0;\\\\n\\\\tfloat t = fract(roughnessVal);\\\\n\\\\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\\\n\\\\tfloat s = mipInfo.y;\\\\n\\\\tfloat level0 = mipInfo.x;\\\\n\\\\tfloat level1 = level0 + 1.0;\\\\n\\\\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\\\n\\\\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\\\n\\\\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\\\n\\\\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\\\n\\\\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\\\n\\\\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\\\n\\\\tvec4 result = mix(color10, color20, t);\\\\n\\\\treturn vec4(result.rgb, 1.0);\\\\n}\\\\n#endif\\\\n\\\";\\n\\n\\tvar defaultnormal_vertex = \\\"vec3 transformedNormal = normalMatrix * objectNormal;\\\\n#ifdef FLIP_SIDED\\\\n\\\\ttransformedNormal = - transformedNormal;\\\\n#endif\\\\n\\\";\\n\\n\\tvar displacementmap_pars_vertex = \\\"#ifdef USE_DISPLACEMENTMAP\\\\n\\\\tuniform sampler2D displacementMap;\\\\n\\\\tuniform float displacementScale;\\\\n\\\\tuniform float displacementBias;\\\\n#endif\\\\n\\\";\\n\\n\\tvar displacementmap_vertex = \\\"#ifdef USE_DISPLACEMENTMAP\\\\n\\\\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\\\n#endif\\\\n\\\";\\n\\n\\tvar emissivemap_fragment = \\\"#ifdef USE_EMISSIVEMAP\\\\n\\\\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\\\n\\\\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\\\n\\\\ttotalEmissiveRadiance *= emissiveColor.rgb;\\\\n#endif\\\\n\\\";\\n\\n\\tvar emissivemap_pars_fragment = \\\"#ifdef USE_EMISSIVEMAP\\\\n\\\\tuniform sampler2D emissiveMap;\\\\n#endif\\\\n\\\";\\n\\n\\tvar encodings_fragment = \\\"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\\\n\\\";\\n\\n\\tvar encodings_pars_fragment = \\\"\\\\nvec4 LinearToLinear( in vec4 value ) {\\\\n\\\\treturn value;\\\\n}\\\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\\\n\\\\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\\\n}\\\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\\\n\\\\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\\\n}\\\\nvec4 sRGBToLinear( in vec4 value ) {\\\\n\\\\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\\\n}\\\\nvec4 LinearTosRGB( in vec4 value ) {\\\\n\\\\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\\\n}\\\\nvec4 RGBEToLinear( in vec4 value ) {\\\\n\\\\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\\\n}\\\\nvec4 LinearToRGBE( in vec4 value ) {\\\\n\\\\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\\\n\\\\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\\\n\\\\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\\\n}\\\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\\\n\\\\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\\\\n}\\\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\\\n\\\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\\\n\\\\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\\\n\\\\tM            = ceil( M * 255.0 ) / 255.0;\\\\n\\\\treturn vec4( value.rgb / ( M * maxRange ), M );\\\\n}\\\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\\\n\\\\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\\\n}\\\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\\\n\\\\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\\\\n\\\\tfloat D      = max( maxRange / maxRGB, 1.0 );\\\\n\\\\tD            = min( floor( D ) / 255.0, 1.0 );\\\\n\\\\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\\\n}\\\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\\\nvec4 LinearToLogLuv( in vec4 value )  {\\\\n\\\\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\\\n\\\\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\\\n\\\\tvec4 vResult;\\\\n\\\\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\\\n\\\\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\\\n\\\\tvResult.w = fract(Le);\\\\n\\\\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\\\n\\\\treturn vResult;\\\\n}\\\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\\\nvec4 LogLuvToLinear( in vec4 value ) {\\\\n\\\\tfloat Le = value.z * 255.0 + value.w;\\\\n\\\\tvec3 Xp_Y_XYZp;\\\\n\\\\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\\\n\\\\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\\\n\\\\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\\\n\\\\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\\\n\\\\treturn vec4( max(vRGB, 0.0), 1.0 );\\\\n}\\\\n\\\";\\n\\n\\tvar envmap_fragment = \\\"#ifdef USE_ENVMAP\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\\\n\\\\t\\\\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\\\n\\\\t\\\\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\\\n\\\\t\\\\t#ifdef ENVMAP_MODE_REFLECTION\\\\n\\\\t\\\\t\\\\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\\\n\\\\t\\\\t#endif\\\\n\\\\t#else\\\\n\\\\t\\\\tvec3 reflectVec = vReflect;\\\\n\\\\t#endif\\\\n\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\\\n\\\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\\\n\\\\t\\\\tvec2 sampleUV;\\\\n\\\\t\\\\treflectVec = normalize( reflectVec );\\\\n\\\\t\\\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\\\n\\\\t\\\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\\\n\\\\t\\\\tvec4 envColor = texture2D( envMap, sampleUV );\\\\n\\\\t#elif defined( ENVMAP_TYPE_SPHERE )\\\\n\\\\t\\\\treflectVec = normalize( reflectVec );\\\\n\\\\t\\\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\\\\n\\\\t\\\\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\\\n\\\\t#else\\\\n\\\\t\\\\tvec4 envColor = vec4( 0.0 );\\\\n\\\\t#endif\\\\n\\\\tenvColor = envMapTexelToLinear( envColor );\\\\n\\\\t#ifdef ENVMAP_BLENDING_MULTIPLY\\\\n\\\\t\\\\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\\\n\\\\t#elif defined( ENVMAP_BLENDING_MIX )\\\\n\\\\t\\\\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\\\n\\\\t#elif defined( ENVMAP_BLENDING_ADD )\\\\n\\\\t\\\\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar envmap_pars_fragment = \\\"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\\\n\\\\tuniform float reflectivity;\\\\n\\\\tuniform float envMapIntensity;\\\\n#endif\\\\n#ifdef USE_ENVMAP\\\\n\\\\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\\\n\\\\t\\\\tvarying vec3 vWorldPosition;\\\\n\\\\t#endif\\\\n\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\tuniform samplerCube envMap;\\\\n\\\\t#else\\\\n\\\\t\\\\tuniform sampler2D envMap;\\\\n\\\\t#endif\\\\n\\\\tuniform float flipEnvMap;\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\\\n\\\\t\\\\tuniform float refractionRatio;\\\\n\\\\t#else\\\\n\\\\t\\\\tvarying vec3 vReflect;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar envmap_pars_vertex = \\\"#ifdef USE_ENVMAP\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\\\n\\\\t\\\\tvarying vec3 vWorldPosition;\\\\n\\\\t#else\\\\n\\\\t\\\\tvarying vec3 vReflect;\\\\n\\\\t\\\\tuniform float refractionRatio;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar envmap_vertex = \\\"#ifdef USE_ENVMAP\\\\n\\\\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\\\n\\\\t\\\\tvWorldPosition = worldPosition.xyz;\\\\n\\\\t#else\\\\n\\\\t\\\\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\\\n\\\\t\\\\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\\\n\\\\t\\\\t#ifdef ENVMAP_MODE_REFLECTION\\\\n\\\\t\\\\t\\\\tvReflect = reflect( cameraToVertex, worldNormal );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\\\n\\\\t\\\\t#endif\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar fog_vertex = \\\"\\\\n#ifdef USE_FOG\\\\nfogDepth = -mvPosition.z;\\\\n#endif\\\";\\n\\n\\tvar fog_pars_vertex = \\\"#ifdef USE_FOG\\\\n  varying float fogDepth;\\\\n#endif\\\\n\\\";\\n\\n\\tvar fog_fragment = \\\"#ifdef USE_FOG\\\\n\\\\t#ifdef FOG_EXP2\\\\n\\\\t\\\\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\\\n\\\\t#endif\\\\n\\\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\\\n#endif\\\\n\\\";\\n\\n\\tvar fog_pars_fragment = \\\"#ifdef USE_FOG\\\\n\\\\tuniform vec3 fogColor;\\\\n\\\\tvarying float fogDepth;\\\\n\\\\t#ifdef FOG_EXP2\\\\n\\\\t\\\\tuniform float fogDensity;\\\\n\\\\t#else\\\\n\\\\t\\\\tuniform float fogNear;\\\\n\\\\t\\\\tuniform float fogFar;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar gradientmap_pars_fragment = \\\"#ifdef TOON\\\\n\\\\tuniform sampler2D gradientMap;\\\\n\\\\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\\\n\\\\t\\\\tfloat dotNL = dot( normal, lightDirection );\\\\n\\\\t\\\\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\\\n\\\\t\\\\t#ifdef USE_GRADIENTMAP\\\\n\\\\t\\\\t\\\\treturn texture2D( gradientMap, coord ).rgb;\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar lightmap_fragment = \\\"#ifdef USE_LIGHTMAP\\\\n\\\\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\\\n#endif\\\\n\\\";\\n\\n\\tvar lightmap_pars_fragment = \\\"#ifdef USE_LIGHTMAP\\\\n\\\\tuniform sampler2D lightMap;\\\\n\\\\tuniform float lightMapIntensity;\\\\n#endif\\\";\\n\\n\\tvar lights_lambert_vertex = \\\"vec3 diffuse = vec3( 1.0 );\\\\nGeometricContext geometry;\\\\ngeometry.position = mvPosition.xyz;\\\\ngeometry.normal = normalize( transformedNormal );\\\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\\\nGeometricContext backGeometry;\\\\nbackGeometry.position = geometry.position;\\\\nbackGeometry.normal = -geometry.normal;\\\\nbackGeometry.viewDir = geometry.viewDir;\\\\nvLightFront = vec3( 0.0 );\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\tvLightBack = vec3( 0.0 );\\\\n#endif\\\\nIncidentLight directLight;\\\\nfloat dotNL;\\\\nvec3 directLightColor_Diffuse;\\\\n#if NUM_POINT_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\\\n\\\\t\\\\tdotNL = dot( geometry.normal, directLight.direction );\\\\n\\\\t\\\\tdirectLightColor_Diffuse = PI * directLight.color;\\\\n\\\\t\\\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_SPOT_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\\\n\\\\t\\\\tdotNL = dot( geometry.normal, directLight.direction );\\\\n\\\\t\\\\tdirectLightColor_Diffuse = PI * directLight.color;\\\\n\\\\t\\\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_DIR_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\\\n\\\\t\\\\tdotNL = dot( geometry.normal, directLight.direction );\\\\n\\\\t\\\\tdirectLightColor_Diffuse = PI * directLight.color;\\\\n\\\\t\\\\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_HEMI_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\\\n\\\\t\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\t\\\\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar lights_pars = \\\"uniform vec3 ambientLightColor;\\\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\\\n\\\\tvec3 irradiance = ambientLightColor;\\\\n\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\tirradiance *= PI;\\\\n\\\\t#endif\\\\n\\\\treturn irradiance;\\\\n}\\\\n#if NUM_DIR_LIGHTS > 0\\\\n\\\\tstruct DirectionalLight {\\\\n\\\\t\\\\tvec3 direction;\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t\\\\tint shadow;\\\\n\\\\t\\\\tfloat shadowBias;\\\\n\\\\t\\\\tfloat shadowRadius;\\\\n\\\\t\\\\tvec2 shadowMapSize;\\\\n\\\\t};\\\\n\\\\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\\\n\\\\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\\\n\\\\t\\\\tdirectLight.color = directionalLight.color;\\\\n\\\\t\\\\tdirectLight.direction = directionalLight.direction;\\\\n\\\\t\\\\tdirectLight.visible = true;\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_POINT_LIGHTS > 0\\\\n\\\\tstruct PointLight {\\\\n\\\\t\\\\tvec3 position;\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t\\\\tfloat distance;\\\\n\\\\t\\\\tfloat decay;\\\\n\\\\t\\\\tint shadow;\\\\n\\\\t\\\\tfloat shadowBias;\\\\n\\\\t\\\\tfloat shadowRadius;\\\\n\\\\t\\\\tvec2 shadowMapSize;\\\\n\\\\t\\\\tfloat shadowCameraNear;\\\\n\\\\t\\\\tfloat shadowCameraFar;\\\\n\\\\t};\\\\n\\\\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\\\n\\\\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\\\n\\\\t\\\\tvec3 lVector = pointLight.position - geometry.position;\\\\n\\\\t\\\\tdirectLight.direction = normalize( lVector );\\\\n\\\\t\\\\tfloat lightDistance = length( lVector );\\\\n\\\\t\\\\tdirectLight.color = pointLight.color;\\\\n\\\\t\\\\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\\\n\\\\t\\\\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_SPOT_LIGHTS > 0\\\\n\\\\tstruct SpotLight {\\\\n\\\\t\\\\tvec3 position;\\\\n\\\\t\\\\tvec3 direction;\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t\\\\tfloat distance;\\\\n\\\\t\\\\tfloat decay;\\\\n\\\\t\\\\tfloat coneCos;\\\\n\\\\t\\\\tfloat penumbraCos;\\\\n\\\\t\\\\tint shadow;\\\\n\\\\t\\\\tfloat shadowBias;\\\\n\\\\t\\\\tfloat shadowRadius;\\\\n\\\\t\\\\tvec2 shadowMapSize;\\\\n\\\\t};\\\\n\\\\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\\\n\\\\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\\\n\\\\t\\\\tvec3 lVector = spotLight.position - geometry.position;\\\\n\\\\t\\\\tdirectLight.direction = normalize( lVector );\\\\n\\\\t\\\\tfloat lightDistance = length( lVector );\\\\n\\\\t\\\\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\\\n\\\\t\\\\tif ( angleCos > spotLight.coneCos ) {\\\\n\\\\t\\\\t\\\\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\\\n\\\\t\\\\t\\\\tdirectLight.color = spotLight.color;\\\\n\\\\t\\\\t\\\\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\\\n\\\\t\\\\t\\\\tdirectLight.visible = true;\\\\n\\\\t\\\\t} else {\\\\n\\\\t\\\\t\\\\tdirectLight.color = vec3( 0.0 );\\\\n\\\\t\\\\t\\\\tdirectLight.visible = false;\\\\n\\\\t\\\\t}\\\\n\\\\t}\\\\n#endif\\\\n#if NUM_RECT_AREA_LIGHTS > 0\\\\n\\\\tstruct RectAreaLight {\\\\n\\\\t\\\\tvec3 color;\\\\n\\\\t\\\\tvec3 position;\\\\n\\\\t\\\\tvec3 halfWidth;\\\\n\\\\t\\\\tvec3 halfHeight;\\\\n\\\\t};\\\\n\\\\tuniform sampler2D ltcMat;\\\\tuniform sampler2D ltcMag;\\\\n\\\\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\\\n#endif\\\\n#if NUM_HEMI_LIGHTS > 0\\\\n\\\\tstruct HemisphereLight {\\\\n\\\\t\\\\tvec3 direction;\\\\n\\\\t\\\\tvec3 skyColor;\\\\n\\\\t\\\\tvec3 groundColor;\\\\n\\\\t};\\\\n\\\\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\\\n\\\\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\\\n\\\\t\\\\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\\\n\\\\t\\\\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\\\n\\\\t\\\\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\\\n\\\\t\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\t\\\\tirradiance *= PI;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treturn irradiance;\\\\n\\\\t}\\\\n#endif\\\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\\\n\\\\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\\\n\\\\t\\\\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\\\n\\\\t\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\t\\\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\\\n\\\\t\\\\t\\\\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\\\n\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tvec4 envMapColor = vec4( 0.0 );\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treturn PI * envMapColor.rgb * envMapIntensity;\\\\n\\\\t}\\\\n\\\\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\\\n\\\\t\\\\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\\\n\\\\t\\\\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\\\n\\\\t\\\\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\\\n\\\\t}\\\\n\\\\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\\\n\\\\t\\\\t#ifdef ENVMAP_MODE_REFLECTION\\\\n\\\\t\\\\t\\\\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\\\n\\\\t\\\\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\\\n\\\\t\\\\t#ifdef ENVMAP_TYPE_CUBE\\\\n\\\\t\\\\t\\\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\\\n\\\\t\\\\t\\\\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\\\n\\\\t\\\\t\\\\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_EQUIREC )\\\\n\\\\t\\\\t\\\\tvec2 sampleUV;\\\\n\\\\t\\\\t\\\\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\\\n\\\\t\\\\t\\\\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#elif defined( ENVMAP_TYPE_SPHERE )\\\\n\\\\t\\\\t\\\\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\\\\n\\\\t\\\\t\\\\t#ifdef TEXTURE_LOD_EXT\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\t\\\\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\\\n\\\\t\\\\t\\\\t#endif\\\\n\\\\t\\\\t\\\\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\treturn envMapColor.rgb * envMapIntensity;\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar lights_phong_fragment = \\\"BlinnPhongMaterial material;\\\\nmaterial.diffuseColor = diffuseColor.rgb;\\\\nmaterial.specularColor = specular;\\\\nmaterial.specularShininess = shininess;\\\\nmaterial.specularStrength = specularStrength;\\\\n\\\";\\n\\n\\tvar lights_phong_pars_fragment = \\\"varying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\nstruct BlinnPhongMaterial {\\\\n\\\\tvec3\\\\tdiffuseColor;\\\\n\\\\tvec3\\\\tspecularColor;\\\\n\\\\tfloat\\\\tspecularShininess;\\\\n\\\\tfloat\\\\tspecularStrength;\\\\n};\\\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\t#ifdef TOON\\\\n\\\\t\\\\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\\\n\\\\t\\\\tvec3 irradiance = dotNL * directLight.color;\\\\n\\\\t#endif\\\\n\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\tirradiance *= PI;\\\\n\\\\t#endif\\\\n\\\\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n\\\\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\\\n}\\\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n}\\\\n#define RE_Direct\\\\t\\\\t\\\\t\\\\tRE_Direct_BlinnPhong\\\\n#define RE_IndirectDiffuse\\\\t\\\\tRE_IndirectDiffuse_BlinnPhong\\\\n#define Material_LightProbeLOD( material )\\\\t(0)\\\\n\\\";\\n\\n\\tvar lights_physical_fragment = \\\"PhysicalMaterial material;\\\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\\\n#ifdef STANDARD\\\\n\\\\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\\\n#else\\\\n\\\\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\\\n\\\\tmaterial.clearCoat = saturate( clearCoat );\\\\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\\\\n#endif\\\\n\\\";\\n\\n\\tvar lights_physical_pars_fragment = \\\"struct PhysicalMaterial {\\\\n\\\\tvec3\\\\tdiffuseColor;\\\\n\\\\tfloat\\\\tspecularRoughness;\\\\n\\\\tvec3\\\\tspecularColor;\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\tfloat clearCoat;\\\\n\\\\t\\\\tfloat clearCoatRoughness;\\\\n\\\\t#endif\\\\n};\\\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\\\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\\\\n\\\\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\\\n}\\\\n#if NUM_RECT_AREA_LIGHTS > 0\\\\n\\\\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\t\\\\tvec3 normal = geometry.normal;\\\\n\\\\t\\\\tvec3 viewDir = geometry.viewDir;\\\\n\\\\t\\\\tvec3 position = geometry.position;\\\\n\\\\t\\\\tvec3 lightPos = rectAreaLight.position;\\\\n\\\\t\\\\tvec3 halfWidth = rectAreaLight.halfWidth;\\\\n\\\\t\\\\tvec3 halfHeight = rectAreaLight.halfHeight;\\\\n\\\\t\\\\tvec3 lightColor = rectAreaLight.color;\\\\n\\\\t\\\\tfloat roughness = material.specularRoughness;\\\\n\\\\t\\\\tvec3 rectCoords[ 4 ];\\\\n\\\\t\\\\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\\\\t\\\\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\\\\n\\\\t\\\\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\\\\n\\\\t\\\\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\\\\n\\\\t\\\\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\\\n\\\\t\\\\tfloat norm = texture2D( ltcMag, uv ).a;\\\\n\\\\t\\\\tvec4 t = texture2D( ltcMat, uv );\\\\n\\\\t\\\\tmat3 mInv = mat3(\\\\n\\\\t\\\\t\\\\tvec3(   1,   0, t.y ),\\\\n\\\\t\\\\t\\\\tvec3(   0, t.z,   0 ),\\\\n\\\\t\\\\t\\\\tvec3( t.w,   0, t.x )\\\\n\\\\t\\\\t);\\\\n\\\\t\\\\treflectedLight.directSpecular += lightColor * material.specularColor * norm * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\\\n\\\\t\\\\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1 ), rectCoords );\\\\n\\\\t}\\\\n#endif\\\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\\\n\\\\tvec3 irradiance = dotNL * directLight.color;\\\\n\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\tirradiance *= PI;\\\\n\\\\t#endif\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat clearCoatDHR = 0.0;\\\\n\\\\t#endif\\\\n\\\\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\\\n\\\\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\\\n\\\\t#endif\\\\n}\\\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\\\n}\\\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\\\n\\\\t\\\\tfloat dotNL = dotNV;\\\\n\\\\t\\\\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\\\\n\\\\t#else\\\\n\\\\t\\\\tfloat clearCoatDHR = 0.0;\\\\n\\\\t#endif\\\\n\\\\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\\\\n\\\\t#endif\\\\n}\\\\n#define RE_Direct\\\\t\\\\t\\\\t\\\\tRE_Direct_Physical\\\\n#define RE_Direct_RectArea\\\\t\\\\tRE_Direct_RectArea_Physical\\\\n#define RE_IndirectDiffuse\\\\t\\\\tRE_IndirectDiffuse_Physical\\\\n#define RE_IndirectSpecular\\\\t\\\\tRE_IndirectSpecular_Physical\\\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\\\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\\\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\\\n\\\\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\\\n}\\\\n\\\";\\n\\n\\tvar lights_template = \\\"\\\\nGeometricContext geometry;\\\\ngeometry.position = - vViewPosition;\\\\ngeometry.normal = normal;\\\\ngeometry.viewDir = normalize( vViewPosition );\\\\nIncidentLight directLight;\\\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\\\n\\\\tPointLight pointLight;\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tpointLight = pointLights[ i ];\\\\n\\\\t\\\\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\\\n\\\\t\\\\t#ifdef USE_SHADOWMAP\\\\n\\\\t\\\\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tRE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n#endif\\\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\\\n\\\\tSpotLight spotLight;\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tspotLight = spotLights[ i ];\\\\n\\\\t\\\\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\\\n\\\\t\\\\t#ifdef USE_SHADOWMAP\\\\n\\\\t\\\\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tRE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n#endif\\\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\\\n\\\\tDirectionalLight directionalLight;\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tdirectionalLight = directionalLights[ i ];\\\\n\\\\t\\\\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\\\n\\\\t\\\\t#ifdef USE_SHADOWMAP\\\\n\\\\t\\\\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tRE_Direct( directLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n#endif\\\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\\\n\\\\tRectAreaLight rectAreaLight;\\\\n\\\\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\\\n\\\\t\\\\trectAreaLight = rectAreaLights[ i ];\\\\n\\\\t\\\\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\\\n\\\\t}\\\\n#endif\\\\n#if defined( RE_IndirectDiffuse )\\\\n\\\\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\\\n\\\\t#ifdef USE_LIGHTMAP\\\\n\\\\t\\\\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\\\n\\\\t\\\\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\\\n\\\\t\\\\t\\\\tlightMapIrradiance *= PI;\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\tirradiance += lightMapIrradiance;\\\\n\\\\t#endif\\\\n\\\\t#if ( NUM_HEMI_LIGHTS > 0 )\\\\n\\\\t\\\\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\\\n\\\\t\\\\t\\\\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\\\n\\\\t\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\\\n\\\\t\\\\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\\\n\\\\t#endif\\\\n\\\\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\\\n#endif\\\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\\\n\\\\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\\\n\\\\t#ifndef STANDARD\\\\n\\\\t\\\\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\\\\n\\\\t#else\\\\n\\\\t\\\\tvec3 clearCoatRadiance = vec3( 0.0 );\\\\n\\\\t#endif\\\\n\\\\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\\\\n#endif\\\\n\\\";\\n\\n\\tvar logdepthbuf_fragment = \\\"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\\\n\\\\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\\\\n#endif\\\";\\n\\n\\tvar logdepthbuf_pars_fragment = \\\"#ifdef USE_LOGDEPTHBUF\\\\n\\\\tuniform float logDepthBufFC;\\\\n\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\t\\\\tvarying float vFragDepth;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar logdepthbuf_pars_vertex = \\\"#ifdef USE_LOGDEPTHBUF\\\\n\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\t\\\\tvarying float vFragDepth;\\\\n\\\\t#endif\\\\n\\\\tuniform float logDepthBufFC;\\\\n#endif\\\";\\n\\n\\tvar logdepthbuf_vertex = \\\"#ifdef USE_LOGDEPTHBUF\\\\n\\\\t#ifdef USE_LOGDEPTHBUF_EXT\\\\n\\\\t\\\\tvFragDepth = 1.0 + gl_Position.w;\\\\n\\\\t#else\\\\n\\\\t\\\\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\\\n\\\\t\\\\tgl_Position.z *= gl_Position.w;\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar map_fragment = \\\"#ifdef USE_MAP\\\\n\\\\tvec4 texelColor = texture2D( map, vUv );\\\\n\\\\ttexelColor = mapTexelToLinear( texelColor );\\\\n\\\\tdiffuseColor *= texelColor;\\\\n#endif\\\\n\\\";\\n\\n\\tvar map_pars_fragment = \\\"#ifdef USE_MAP\\\\n\\\\tuniform sampler2D map;\\\\n#endif\\\\n\\\";\\n\\n\\tvar map_particle_fragment = \\\"#ifdef USE_MAP\\\\n\\\\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\\\n\\\\tvec4 mapTexel = texture2D( map, uv );\\\\n\\\\tdiffuseColor *= mapTexelToLinear( mapTexel );\\\\n#endif\\\\n\\\";\\n\\n\\tvar map_particle_pars_fragment = \\\"#ifdef USE_MAP\\\\n\\\\tuniform mat3 uvTransform;\\\\n\\\\tuniform sampler2D map;\\\\n#endif\\\\n\\\";\\n\\n\\tvar metalnessmap_fragment = \\\"float metalnessFactor = metalness;\\\\n#ifdef USE_METALNESSMAP\\\\n\\\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\\\n\\\\tmetalnessFactor *= texelMetalness.b;\\\\n#endif\\\\n\\\";\\n\\n\\tvar metalnessmap_pars_fragment = \\\"#ifdef USE_METALNESSMAP\\\\n\\\\tuniform sampler2D metalnessMap;\\\\n#endif\\\";\\n\\n\\tvar morphnormal_vertex = \\\"#ifdef USE_MORPHNORMALS\\\\n\\\\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\\\n\\\\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\\\n\\\\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\\\n\\\\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\\\n#endif\\\\n\\\";\\n\\n\\tvar morphtarget_pars_vertex = \\\"#ifdef USE_MORPHTARGETS\\\\n\\\\t#ifndef USE_MORPHNORMALS\\\\n\\\\tuniform float morphTargetInfluences[ 8 ];\\\\n\\\\t#else\\\\n\\\\tuniform float morphTargetInfluences[ 4 ];\\\\n\\\\t#endif\\\\n#endif\\\";\\n\\n\\tvar morphtarget_vertex = \\\"#ifdef USE_MORPHTARGETS\\\\n\\\\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\\\n\\\\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\\\n\\\\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\\\n\\\\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\\\n\\\\t#ifndef USE_MORPHNORMALS\\\\n\\\\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\\\n\\\\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\\\n\\\\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\\\n\\\\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar normal_fragment = \\\"#ifdef FLAT_SHADED\\\\n\\\\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\\\n\\\\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\\\n\\\\tvec3 normal = normalize( cross( fdx, fdy ) );\\\\n#else\\\\n\\\\tvec3 normal = normalize( vNormal );\\\\n\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\\\n\\\\t#endif\\\\n#endif\\\\n#ifdef USE_NORMALMAP\\\\n\\\\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\\\n#elif defined( USE_BUMPMAP )\\\\n\\\\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\\\n#endif\\\\n\\\";\\n\\n\\tvar normalmap_pars_fragment = \\\"#ifdef USE_NORMALMAP\\\\n\\\\tuniform sampler2D normalMap;\\\\n\\\\tuniform vec2 normalScale;\\\\n\\\\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\\\n\\\\t\\\\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\\\n\\\\t\\\\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\\\n\\\\t\\\\tvec2 st0 = dFdx( vUv.st );\\\\n\\\\t\\\\tvec2 st1 = dFdy( vUv.st );\\\\n\\\\t\\\\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\\\n\\\\t\\\\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\\\n\\\\t\\\\tvec3 N = normalize( surf_norm );\\\\n\\\\t\\\\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\\\n\\\\t\\\\tmapN.xy = normalScale * mapN.xy;\\\\n\\\\t\\\\tmat3 tsn = mat3( S, T, N );\\\\n\\\\t\\\\treturn normalize( tsn * mapN );\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar packing = \\\"vec3 packNormalToRGB( const in vec3 normal ) {\\\\n\\\\treturn normalize( normal ) * 0.5 + 0.5;\\\\n}\\\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\\\n\\\\treturn 2.0 * rgb.xyz - 1.0;\\\\n}\\\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\\\nconst float ShiftRight8 = 1. / 256.;\\\\nvec4 packDepthToRGBA( const in float v ) {\\\\n\\\\tvec4 r = vec4( fract( v * PackFactors ), v );\\\\n\\\\tr.yzw -= r.xyz * ShiftRight8;\\\\treturn r * PackUpscale;\\\\n}\\\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\\\n\\\\treturn dot( v, UnpackFactors );\\\\n}\\\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\\\n\\\\treturn ( viewZ + near ) / ( near - far );\\\\n}\\\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\\\n\\\\treturn linearClipZ * ( near - far ) - near;\\\\n}\\\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\\\n\\\\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\\\n}\\\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\\\n\\\\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\\\n}\\\\n\\\";\\n\\n\\tvar premultiplied_alpha_fragment = \\\"#ifdef PREMULTIPLIED_ALPHA\\\\n\\\\tgl_FragColor.rgb *= gl_FragColor.a;\\\\n#endif\\\\n\\\";\\n\\n\\tvar project_vertex = \\\"vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\\\ngl_Position = projectionMatrix * mvPosition;\\\\n\\\";\\n\\n\\tvar dithering_fragment = \\\"#if defined( DITHERING )\\\\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\\\\n#endif\\\\n\\\";\\n\\n\\tvar dithering_pars_fragment = \\\"#if defined( DITHERING )\\\\n\\\\tvec3 dithering( vec3 color ) {\\\\n\\\\t\\\\tfloat grid_position = rand( gl_FragCoord.xy );\\\\n\\\\t\\\\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\\\n\\\\t\\\\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\\\n\\\\t\\\\treturn color + dither_shift_RGB;\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar roughnessmap_fragment = \\\"float roughnessFactor = roughness;\\\\n#ifdef USE_ROUGHNESSMAP\\\\n\\\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\\\n\\\\troughnessFactor *= texelRoughness.g;\\\\n#endif\\\\n\\\";\\n\\n\\tvar roughnessmap_pars_fragment = \\\"#ifdef USE_ROUGHNESSMAP\\\\n\\\\tuniform sampler2D roughnessMap;\\\\n#endif\\\";\\n\\n\\tvar shadowmap_pars_fragment = \\\"#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHTS > 0\\\\n\\\\t\\\\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHTS > 0\\\\n\\\\t\\\\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHTS > 0\\\\n\\\\t\\\\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\\\n\\\\t\\\\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\\\n\\\\t}\\\\n\\\\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\\\n\\\\t\\\\tconst vec2 offset = vec2( 0.0, 1.0 );\\\\n\\\\t\\\\tvec2 texelSize = vec2( 1.0 ) / size;\\\\n\\\\t\\\\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\\\n\\\\t\\\\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\\\n\\\\t\\\\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\\\n\\\\t\\\\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\\\n\\\\t\\\\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\\\n\\\\t\\\\tvec2 f = fract( uv * size + 0.5 );\\\\n\\\\t\\\\tfloat a = mix( lb, lt, f.y );\\\\n\\\\t\\\\tfloat b = mix( rb, rt, f.y );\\\\n\\\\t\\\\tfloat c = mix( a, b, f.x );\\\\n\\\\t\\\\treturn c;\\\\n\\\\t}\\\\n\\\\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\\\n\\\\t\\\\tfloat shadow = 1.0;\\\\n\\\\t\\\\tshadowCoord.xyz /= shadowCoord.w;\\\\n\\\\t\\\\tshadowCoord.z += shadowBias;\\\\n\\\\t\\\\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\\\n\\\\t\\\\tbool inFrustum = all( inFrustumVec );\\\\n\\\\t\\\\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\\\n\\\\t\\\\tbool frustumTest = all( frustumTestVec );\\\\n\\\\t\\\\tif ( frustumTest ) {\\\\n\\\\t\\\\t#if defined( SHADOWMAP_TYPE_PCF )\\\\n\\\\t\\\\t\\\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\\\n\\\\t\\\\t\\\\tfloat dx0 = - texelSize.x * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dy0 = - texelSize.y * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dx1 = + texelSize.x * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dy1 = + texelSize.y * shadowRadius;\\\\n\\\\t\\\\t\\\\tshadow = (\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\\\n\\\\t\\\\t\\\\t) * ( 1.0 / 9.0 );\\\\n\\\\t\\\\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\\\n\\\\t\\\\t\\\\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\\\n\\\\t\\\\t\\\\tfloat dx0 = - texelSize.x * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dy0 = - texelSize.y * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dx1 = + texelSize.x * shadowRadius;\\\\n\\\\t\\\\t\\\\tfloat dy1 = + texelSize.y * shadowRadius;\\\\n\\\\t\\\\t\\\\tshadow = (\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\\\n\\\\t\\\\t\\\\t) * ( 1.0 / 9.0 );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\\\n\\\\t\\\\t#endif\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\treturn shadow;\\\\n\\\\t}\\\\n\\\\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\\\n\\\\t\\\\tvec3 absV = abs( v );\\\\n\\\\t\\\\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\\\n\\\\t\\\\tabsV *= scaleToCube;\\\\n\\\\t\\\\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\\\n\\\\t\\\\tvec2 planar = v.xy;\\\\n\\\\t\\\\tfloat almostATexel = 1.5 * texelSizeY;\\\\n\\\\t\\\\tfloat almostOne = 1.0 - almostATexel;\\\\n\\\\t\\\\tif ( absV.z >= almostOne ) {\\\\n\\\\t\\\\t\\\\tif ( v.z > 0.0 )\\\\n\\\\t\\\\t\\\\t\\\\tplanar.x = 4.0 - v.x;\\\\n\\\\t\\\\t} else if ( absV.x >= almostOne ) {\\\\n\\\\t\\\\t\\\\tfloat signX = sign( v.x );\\\\n\\\\t\\\\t\\\\tplanar.x = v.z * signX + 2.0 * signX;\\\\n\\\\t\\\\t} else if ( absV.y >= almostOne ) {\\\\n\\\\t\\\\t\\\\tfloat signY = sign( v.y );\\\\n\\\\t\\\\t\\\\tplanar.x = v.x + 2.0 * signY + 2.0;\\\\n\\\\t\\\\t\\\\tplanar.y = v.z * signY - 2.0;\\\\n\\\\t\\\\t}\\\\n\\\\t\\\\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\\\n\\\\t}\\\\n\\\\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\\\n\\\\t\\\\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\\\n\\\\t\\\\tvec3 lightToPosition = shadowCoord.xyz;\\\\n\\\\t\\\\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\\\\t\\\\tdp += shadowBias;\\\\n\\\\t\\\\tvec3 bd3D = normalize( lightToPosition );\\\\n\\\\t\\\\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\\\n\\\\t\\\\t\\\\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\\\n\\\\t\\\\t\\\\treturn (\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\\\n\\\\t\\\\t\\\\t\\\\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\\\n\\\\t\\\\t\\\\t) * ( 1.0 / 9.0 );\\\\n\\\\t\\\\t#else\\\\n\\\\t\\\\t\\\\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\\\n\\\\t\\\\t#endif\\\\n\\\\t}\\\\n#endif\\\\n\\\";\\n\\n\\tvar shadowmap_pars_vertex = \\\"#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHTS > 0\\\\n\\\\t\\\\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHTS > 0\\\\n\\\\t\\\\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHTS > 0\\\\n\\\\t\\\\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\\\n\\\\t\\\\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar shadowmap_vertex = \\\"#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHTS > 0\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar shadowmask_pars_fragment = \\\"float getShadowMask() {\\\\n\\\\tfloat shadow = 1.0;\\\\n\\\\t#ifdef USE_SHADOWMAP\\\\n\\\\t#if NUM_DIR_LIGHTS > 0\\\\n\\\\tDirectionalLight directionalLight;\\\\n\\\\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tdirectionalLight = directionalLights[ i ];\\\\n\\\\t\\\\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if NUM_SPOT_LIGHTS > 0\\\\n\\\\tSpotLight spotLight;\\\\n\\\\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tspotLight = spotLights[ i ];\\\\n\\\\t\\\\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#if NUM_POINT_LIGHTS > 0\\\\n\\\\tPointLight pointLight;\\\\n\\\\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\\\n\\\\t\\\\tpointLight = pointLights[ i ];\\\\n\\\\t\\\\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\\\n\\\\t}\\\\n\\\\t#endif\\\\n\\\\t#endif\\\\n\\\\treturn shadow;\\\\n}\\\\n\\\";\\n\\n\\tvar skinbase_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\\\n\\\\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\\\n\\\\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\\\n\\\\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\\\n#endif\\\";\\n\\n\\tvar skinning_pars_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tuniform mat4 bindMatrix;\\\\n\\\\tuniform mat4 bindMatrixInverse;\\\\n\\\\t#ifdef BONE_TEXTURE\\\\n\\\\t\\\\tuniform sampler2D boneTexture;\\\\n\\\\t\\\\tuniform int boneTextureSize;\\\\n\\\\t\\\\tmat4 getBoneMatrix( const in float i ) {\\\\n\\\\t\\\\t\\\\tfloat j = i * 4.0;\\\\n\\\\t\\\\t\\\\tfloat x = mod( j, float( boneTextureSize ) );\\\\n\\\\t\\\\t\\\\tfloat y = floor( j / float( boneTextureSize ) );\\\\n\\\\t\\\\t\\\\tfloat dx = 1.0 / float( boneTextureSize );\\\\n\\\\t\\\\t\\\\tfloat dy = 1.0 / float( boneTextureSize );\\\\n\\\\t\\\\t\\\\ty = dy * ( y + 0.5 );\\\\n\\\\t\\\\t\\\\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\\\n\\\\t\\\\t\\\\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\\\n\\\\t\\\\t\\\\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\\\n\\\\t\\\\t\\\\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\\\n\\\\t\\\\t\\\\tmat4 bone = mat4( v1, v2, v3, v4 );\\\\n\\\\t\\\\t\\\\treturn bone;\\\\n\\\\t\\\\t}\\\\n\\\\t#else\\\\n\\\\t\\\\tuniform mat4 boneMatrices[ MAX_BONES ];\\\\n\\\\t\\\\tmat4 getBoneMatrix( const in float i ) {\\\\n\\\\t\\\\t\\\\tmat4 bone = boneMatrices[ int(i) ];\\\\n\\\\t\\\\t\\\\treturn bone;\\\\n\\\\t\\\\t}\\\\n\\\\t#endif\\\\n#endif\\\\n\\\";\\n\\n\\tvar skinning_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\\\n\\\\tvec4 skinned = vec4( 0.0 );\\\\n\\\\tskinned += boneMatX * skinVertex * skinWeight.x;\\\\n\\\\tskinned += boneMatY * skinVertex * skinWeight.y;\\\\n\\\\tskinned += boneMatZ * skinVertex * skinWeight.z;\\\\n\\\\tskinned += boneMatW * skinVertex * skinWeight.w;\\\\n\\\\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\\\n#endif\\\\n\\\";\\n\\n\\tvar skinnormal_vertex = \\\"#ifdef USE_SKINNING\\\\n\\\\tmat4 skinMatrix = mat4( 0.0 );\\\\n\\\\tskinMatrix += skinWeight.x * boneMatX;\\\\n\\\\tskinMatrix += skinWeight.y * boneMatY;\\\\n\\\\tskinMatrix += skinWeight.z * boneMatZ;\\\\n\\\\tskinMatrix += skinWeight.w * boneMatW;\\\\n\\\\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\\\n\\\\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\\\n#endif\\\\n\\\";\\n\\n\\tvar specularmap_fragment = \\\"float specularStrength;\\\\n#ifdef USE_SPECULARMAP\\\\n\\\\tvec4 texelSpecular = texture2D( specularMap, vUv );\\\\n\\\\tspecularStrength = texelSpecular.r;\\\\n#else\\\\n\\\\tspecularStrength = 1.0;\\\\n#endif\\\";\\n\\n\\tvar specularmap_pars_fragment = \\\"#ifdef USE_SPECULARMAP\\\\n\\\\tuniform sampler2D specularMap;\\\\n#endif\\\";\\n\\n\\tvar tonemapping_fragment = \\\"#if defined( TONE_MAPPING )\\\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\\\n#endif\\\\n\\\";\\n\\n\\tvar tonemapping_pars_fragment = \\\"#ifndef saturate\\\\n\\\\t#define saturate(a) clamp( a, 0.0, 1.0 )\\\\n#endif\\\\nuniform float toneMappingExposure;\\\\nuniform float toneMappingWhitePoint;\\\\nvec3 LinearToneMapping( vec3 color ) {\\\\n\\\\treturn toneMappingExposure * color;\\\\n}\\\\nvec3 ReinhardToneMapping( vec3 color ) {\\\\n\\\\tcolor *= toneMappingExposure;\\\\n\\\\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\\\n}\\\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\\\n\\\\tcolor *= toneMappingExposure;\\\\n\\\\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\\\n}\\\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\\\n\\\\tcolor *= toneMappingExposure;\\\\n\\\\tcolor = max( vec3( 0.0 ), color - 0.004 );\\\\n\\\\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\\\n}\\\\n\\\";\\n\\n\\tvar uv_pars_fragment = \\\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\\\n\\\\tvarying vec2 vUv;\\\\n#endif\\\";\\n\\n\\tvar uv_pars_vertex = \\\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\\\n\\\\tvarying vec2 vUv;\\\\n\\\\tuniform mat3 uvTransform;\\\\n#endif\\\\n\\\";\\n\\n\\tvar uv_vertex = \\\"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\\\n\\\\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\\\n#endif\\\";\\n\\n\\tvar uv2_pars_fragment = \\\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\\\n\\\\tvarying vec2 vUv2;\\\\n#endif\\\";\\n\\n\\tvar uv2_pars_vertex = \\\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\\\n\\\\tattribute vec2 uv2;\\\\n\\\\tvarying vec2 vUv2;\\\\n#endif\\\";\\n\\n\\tvar uv2_vertex = \\\"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\\\n\\\\tvUv2 = uv2;\\\\n#endif\\\";\\n\\n\\tvar worldpos_vertex = \\\"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\\\n\\\\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\\\n#endif\\\\n\\\";\\n\\n\\tvar cube_frag = \\\"uniform samplerCube tCube;\\\\nuniform float tFlip;\\\\nuniform float opacity;\\\\nvarying vec3 vWorldPosition;\\\\nvoid main() {\\\\n\\\\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\\\n\\\\tgl_FragColor.a *= opacity;\\\\n}\\\\n\\\";\\n\\n\\tvar cube_vert = \\\"varying vec3 vWorldPosition;\\\\n#include <common>\\\\nvoid main() {\\\\n\\\\tvWorldPosition = transformDirection( position, modelMatrix );\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\tgl_Position.z = gl_Position.w;\\\\n}\\\\n\\\";\\n\\n\\tvar depth_frag = \\\"#if DEPTH_PACKING == 3200\\\\n\\\\tuniform float opacity;\\\\n#endif\\\\n#include <common>\\\\n#include <packing>\\\\n#include <uv_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( 1.0 );\\\\n\\\\t#if DEPTH_PACKING == 3200\\\\n\\\\t\\\\tdiffuseColor.a = opacity;\\\\n\\\\t#endif\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#if DEPTH_PACKING == 3200\\\\n\\\\t\\\\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\\\n\\\\t#elif DEPTH_PACKING == 3201\\\\n\\\\t\\\\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\\\n\\\\t#endif\\\\n}\\\\n\\\";\\n\\n\\tvar depth_vert = \\\"#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#ifdef USE_DISPLACEMENTMAP\\\\n\\\\t\\\\t#include <beginnormal_vertex>\\\\n\\\\t\\\\t#include <morphnormal_vertex>\\\\n\\\\t\\\\t#include <skinnormal_vertex>\\\\n\\\\t#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar distanceRGBA_frag = \\\"#define DISTANCE\\\\nuniform vec3 referencePosition;\\\\nuniform float nearDistance;\\\\nuniform float farDistance;\\\\nvarying vec3 vWorldPosition;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <uv_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main () {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( 1.0 );\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\tfloat dist = length( vWorldPosition - referencePosition );\\\\n\\\\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\\\n\\\\tdist = saturate( dist );\\\\n\\\\tgl_FragColor = packDepthToRGBA( dist );\\\\n}\\\\n\\\";\\n\\n\\tvar distanceRGBA_vert = \\\"#define DISTANCE\\\\nvarying vec3 vWorldPosition;\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#ifdef USE_DISPLACEMENTMAP\\\\n\\\\t\\\\t#include <beginnormal_vertex>\\\\n\\\\t\\\\t#include <morphnormal_vertex>\\\\n\\\\t\\\\t#include <skinnormal_vertex>\\\\n\\\\t#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\tvWorldPosition = worldPosition.xyz;\\\\n}\\\\n\\\";\\n\\n\\tvar equirect_frag = \\\"uniform sampler2D tEquirect;\\\\nvarying vec3 vWorldPosition;\\\\n#include <common>\\\\nvoid main() {\\\\n\\\\tvec3 direction = normalize( vWorldPosition );\\\\n\\\\tvec2 sampleUV;\\\\n\\\\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\\\n\\\\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\\\n\\\\tgl_FragColor = texture2D( tEquirect, sampleUV );\\\\n}\\\\n\\\";\\n\\n\\tvar equirect_vert = \\\"varying vec3 vWorldPosition;\\\\n#include <common>\\\\nvoid main() {\\\\n\\\\tvWorldPosition = transformDirection( position, modelMatrix );\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <project_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar linedashed_frag = \\\"uniform vec3 diffuse;\\\\nuniform float opacity;\\\\nuniform float dashSize;\\\\nuniform float totalSize;\\\\nvarying float vLineDistance;\\\\n#include <common>\\\\n#include <color_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\\\n\\\\t\\\\tdiscard;\\\\n\\\\t}\\\\n\\\\tvec3 outgoingLight = vec3( 0.0 );\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\toutgoingLight = diffuseColor.rgb;\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar linedashed_vert = \\\"uniform float scale;\\\\nattribute float lineDistance;\\\\nvarying float vLineDistance;\\\\n#include <common>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <color_vertex>\\\\n\\\\tvLineDistance = scale * lineDistance;\\\\n\\\\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\\\n\\\\tgl_Position = projectionMatrix * mvPosition;\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar meshbasic_frag = \\\"uniform vec3 diffuse;\\\\nuniform float opacity;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <envmap_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <specularmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <specularmap_fragment>\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\t#ifdef USE_LIGHTMAP\\\\n\\\\t\\\\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\\\n\\\\t#else\\\\n\\\\t\\\\treflectedLight.indirectDiffuse += vec3( 1.0 );\\\\n\\\\t#endif\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\\\n\\\\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\\\n\\\\t#include <envmap_fragment>\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar meshbasic_vert = \\\"#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <envmap_pars_vertex>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#ifdef USE_ENVMAP\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n\\\\t#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <envmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar meshlambert_frag = \\\"uniform vec3 diffuse;\\\\nuniform vec3 emissive;\\\\nuniform float opacity;\\\\nvarying vec3 vLightFront;\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\tvarying vec3 vLightBack;\\\\n#endif\\\\n#include <common>\\\\n#include <packing>\\\\n#include <dithering_pars_fragment>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <emissivemap_pars_fragment>\\\\n#include <envmap_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <lights_pars>\\\\n#include <fog_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <shadowmask_pars_fragment>\\\\n#include <specularmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\tvec3 totalEmissiveRadiance = emissive;\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <specularmap_fragment>\\\\n\\\\t#include <emissivemap_fragment>\\\\n\\\\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\\\n\\\\t#include <lightmap_fragment>\\\\n\\\\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\\\n\\\\t#ifdef DOUBLE_SIDED\\\\n\\\\t\\\\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\\\n\\\\t#else\\\\n\\\\t\\\\treflectedLight.directDiffuse = vLightFront;\\\\n\\\\t#endif\\\\n\\\\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\\\n\\\\t#include <envmap_fragment>\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <dithering_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar meshlambert_vert = \\\"#define LAMBERT\\\\nvarying vec3 vLightFront;\\\\n#ifdef DOUBLE_SIDED\\\\n\\\\tvarying vec3 vLightBack;\\\\n#endif\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <envmap_pars_vertex>\\\\n#include <bsdfs>\\\\n#include <lights_pars>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <envmap_vertex>\\\\n\\\\t#include <lights_lambert_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar meshphong_frag = \\\"#define PHONG\\\\nuniform vec3 diffuse;\\\\nuniform vec3 emissive;\\\\nuniform vec3 specular;\\\\nuniform float shininess;\\\\nuniform float opacity;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <dithering_pars_fragment>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <emissivemap_pars_fragment>\\\\n#include <envmap_pars_fragment>\\\\n#include <gradientmap_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <lights_pars>\\\\n#include <lights_phong_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <bumpmap_pars_fragment>\\\\n#include <normalmap_pars_fragment>\\\\n#include <specularmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\tvec3 totalEmissiveRadiance = emissive;\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <specularmap_fragment>\\\\n\\\\t#include <normal_fragment>\\\\n\\\\t#include <emissivemap_fragment>\\\\n\\\\t#include <lights_phong_fragment>\\\\n\\\\t#include <lights_template>\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\\\n\\\\t#include <envmap_fragment>\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <dithering_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar meshphong_vert = \\\"#define PHONG\\\\nvarying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <envmap_pars_vertex>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvNormal = normalize( transformedNormal );\\\\n#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <envmap_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar meshphysical_frag = \\\"#define PHYSICAL\\\\nuniform vec3 diffuse;\\\\nuniform vec3 emissive;\\\\nuniform float roughness;\\\\nuniform float metalness;\\\\nuniform float opacity;\\\\n#ifndef STANDARD\\\\n\\\\tuniform float clearCoat;\\\\n\\\\tuniform float clearCoatRoughness;\\\\n#endif\\\\nvarying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <packing>\\\\n#include <dithering_pars_fragment>\\\\n#include <color_pars_fragment>\\\\n#include <uv_pars_fragment>\\\\n#include <uv2_pars_fragment>\\\\n#include <map_pars_fragment>\\\\n#include <alphamap_pars_fragment>\\\\n#include <aomap_pars_fragment>\\\\n#include <lightmap_pars_fragment>\\\\n#include <emissivemap_pars_fragment>\\\\n#include <envmap_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <cube_uv_reflection_fragment>\\\\n#include <lights_pars>\\\\n#include <lights_physical_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <bumpmap_pars_fragment>\\\\n#include <normalmap_pars_fragment>\\\\n#include <roughnessmap_pars_fragment>\\\\n#include <metalnessmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\\\n\\\\tvec3 totalEmissiveRadiance = emissive;\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphamap_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\t#include <roughnessmap_fragment>\\\\n\\\\t#include <metalnessmap_fragment>\\\\n\\\\t#include <normal_fragment>\\\\n\\\\t#include <emissivemap_fragment>\\\\n\\\\t#include <lights_physical_fragment>\\\\n\\\\t#include <lights_template>\\\\n\\\\t#include <aomap_fragment>\\\\n\\\\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <dithering_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar meshphysical_vert = \\\"#define PHYSICAL\\\\nvarying vec3 vViewPosition;\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <common>\\\\n#include <uv_pars_vertex>\\\\n#include <uv2_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <uv2_vertex>\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvNormal = normalize( transformedNormal );\\\\n#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar normal_frag = \\\"#define NORMAL\\\\nuniform float opacity;\\\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\\\n\\\\tvarying vec3 vViewPosition;\\\\n#endif\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <packing>\\\\n#include <uv_pars_fragment>\\\\n#include <bumpmap_pars_fragment>\\\\n#include <normalmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <normal_fragment>\\\\n\\\\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\\\n}\\\\n\\\";\\n\\n\\tvar normal_vert = \\\"#define NORMAL\\\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\\\n\\\\tvarying vec3 vViewPosition;\\\\n#endif\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvarying vec3 vNormal;\\\\n#endif\\\\n#include <uv_pars_vertex>\\\\n#include <displacementmap_pars_vertex>\\\\n#include <morphtarget_pars_vertex>\\\\n#include <skinning_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <uv_vertex>\\\\n\\\\t#include <beginnormal_vertex>\\\\n\\\\t#include <morphnormal_vertex>\\\\n\\\\t#include <skinbase_vertex>\\\\n\\\\t#include <skinnormal_vertex>\\\\n\\\\t#include <defaultnormal_vertex>\\\\n#ifndef FLAT_SHADED\\\\n\\\\tvNormal = normalize( transformedNormal );\\\\n#endif\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <morphtarget_vertex>\\\\n\\\\t#include <skinning_vertex>\\\\n\\\\t#include <displacementmap_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\\\\n\\\\tvViewPosition = - mvPosition.xyz;\\\\n#endif\\\\n}\\\\n\\\";\\n\\n\\tvar points_frag = \\\"uniform vec3 diffuse;\\\\nuniform float opacity;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <color_pars_fragment>\\\\n#include <map_particle_pars_fragment>\\\\n#include <fog_pars_fragment>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <logdepthbuf_pars_fragment>\\\\n#include <clipping_planes_pars_fragment>\\\\nvoid main() {\\\\n\\\\t#include <clipping_planes_fragment>\\\\n\\\\tvec3 outgoingLight = vec3( 0.0 );\\\\n\\\\tvec4 diffuseColor = vec4( diffuse, opacity );\\\\n\\\\t#include <logdepthbuf_fragment>\\\\n\\\\t#include <map_particle_fragment>\\\\n\\\\t#include <color_fragment>\\\\n\\\\t#include <alphatest_fragment>\\\\n\\\\toutgoingLight = diffuseColor.rgb;\\\\n\\\\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\\\n\\\\t#include <premultiplied_alpha_fragment>\\\\n\\\\t#include <tonemapping_fragment>\\\\n\\\\t#include <encodings_fragment>\\\\n\\\\t#include <fog_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar points_vert = \\\"uniform float size;\\\\nuniform float scale;\\\\n#include <common>\\\\n#include <color_pars_vertex>\\\\n#include <fog_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\n#include <logdepthbuf_pars_vertex>\\\\n#include <clipping_planes_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <color_vertex>\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#ifdef USE_SIZEATTENUATION\\\\n\\\\t\\\\tgl_PointSize = size * ( scale / - mvPosition.z );\\\\n\\\\t#else\\\\n\\\\t\\\\tgl_PointSize = size;\\\\n\\\\t#endif\\\\n\\\\t#include <logdepthbuf_vertex>\\\\n\\\\t#include <clipping_planes_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar shadow_frag = \\\"uniform vec3 color;\\\\nuniform float opacity;\\\\n#include <common>\\\\n#include <packing>\\\\n#include <fog_pars_fragment>\\\\n#include <bsdfs>\\\\n#include <lights_pars>\\\\n#include <shadowmap_pars_fragment>\\\\n#include <shadowmask_pars_fragment>\\\\nvoid main() {\\\\n\\\\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\\\n\\\\t#include <fog_fragment>\\\\n}\\\\n\\\";\\n\\n\\tvar shadow_vert = \\\"#include <fog_pars_vertex>\\\\n#include <shadowmap_pars_vertex>\\\\nvoid main() {\\\\n\\\\t#include <begin_vertex>\\\\n\\\\t#include <project_vertex>\\\\n\\\\t#include <worldpos_vertex>\\\\n\\\\t#include <shadowmap_vertex>\\\\n\\\\t#include <fog_vertex>\\\\n}\\\\n\\\";\\n\\n\\tvar ShaderChunk = {\\n\\t\\talphamap_fragment: alphamap_fragment,\\n\\t\\talphamap_pars_fragment: alphamap_pars_fragment,\\n\\t\\talphatest_fragment: alphatest_fragment,\\n\\t\\taomap_fragment: aomap_fragment,\\n\\t\\taomap_pars_fragment: aomap_pars_fragment,\\n\\t\\tbegin_vertex: begin_vertex,\\n\\t\\tbeginnormal_vertex: beginnormal_vertex,\\n\\t\\tbsdfs: bsdfs,\\n\\t\\tbumpmap_pars_fragment: bumpmap_pars_fragment,\\n\\t\\tclipping_planes_fragment: clipping_planes_fragment,\\n\\t\\tclipping_planes_pars_fragment: clipping_planes_pars_fragment,\\n\\t\\tclipping_planes_pars_vertex: clipping_planes_pars_vertex,\\n\\t\\tclipping_planes_vertex: clipping_planes_vertex,\\n\\t\\tcolor_fragment: color_fragment,\\n\\t\\tcolor_pars_fragment: color_pars_fragment,\\n\\t\\tcolor_pars_vertex: color_pars_vertex,\\n\\t\\tcolor_vertex: color_vertex,\\n\\t\\tcommon: common,\\n\\t\\tcube_uv_reflection_fragment: cube_uv_reflection_fragment,\\n\\t\\tdefaultnormal_vertex: defaultnormal_vertex,\\n\\t\\tdisplacementmap_pars_vertex: displacementmap_pars_vertex,\\n\\t\\tdisplacementmap_vertex: displacementmap_vertex,\\n\\t\\temissivemap_fragment: emissivemap_fragment,\\n\\t\\temissivemap_pars_fragment: emissivemap_pars_fragment,\\n\\t\\tencodings_fragment: encodings_fragment,\\n\\t\\tencodings_pars_fragment: encodings_pars_fragment,\\n\\t\\tenvmap_fragment: envmap_fragment,\\n\\t\\tenvmap_pars_fragment: envmap_pars_fragment,\\n\\t\\tenvmap_pars_vertex: envmap_pars_vertex,\\n\\t\\tenvmap_vertex: envmap_vertex,\\n\\t\\tfog_vertex: fog_vertex,\\n\\t\\tfog_pars_vertex: fog_pars_vertex,\\n\\t\\tfog_fragment: fog_fragment,\\n\\t\\tfog_pars_fragment: fog_pars_fragment,\\n\\t\\tgradientmap_pars_fragment: gradientmap_pars_fragment,\\n\\t\\tlightmap_fragment: lightmap_fragment,\\n\\t\\tlightmap_pars_fragment: lightmap_pars_fragment,\\n\\t\\tlights_lambert_vertex: lights_lambert_vertex,\\n\\t\\tlights_pars: lights_pars,\\n\\t\\tlights_phong_fragment: lights_phong_fragment,\\n\\t\\tlights_phong_pars_fragment: lights_phong_pars_fragment,\\n\\t\\tlights_physical_fragment: lights_physical_fragment,\\n\\t\\tlights_physical_pars_fragment: lights_physical_pars_fragment,\\n\\t\\tlights_template: lights_template,\\n\\t\\tlogdepthbuf_fragment: logdepthbuf_fragment,\\n\\t\\tlogdepthbuf_pars_fragment: logdepthbuf_pars_fragment,\\n\\t\\tlogdepthbuf_pars_vertex: logdepthbuf_pars_vertex,\\n\\t\\tlogdepthbuf_vertex: logdepthbuf_vertex,\\n\\t\\tmap_fragment: map_fragment,\\n\\t\\tmap_pars_fragment: map_pars_fragment,\\n\\t\\tmap_particle_fragment: map_particle_fragment,\\n\\t\\tmap_particle_pars_fragment: map_particle_pars_fragment,\\n\\t\\tmetalnessmap_fragment: metalnessmap_fragment,\\n\\t\\tmetalnessmap_pars_fragment: metalnessmap_pars_fragment,\\n\\t\\tmorphnormal_vertex: morphnormal_vertex,\\n\\t\\tmorphtarget_pars_vertex: morphtarget_pars_vertex,\\n\\t\\tmorphtarget_vertex: morphtarget_vertex,\\n\\t\\tnormal_fragment: normal_fragment,\\n\\t\\tnormalmap_pars_fragment: normalmap_pars_fragment,\\n\\t\\tpacking: packing,\\n\\t\\tpremultiplied_alpha_fragment: premultiplied_alpha_fragment,\\n\\t\\tproject_vertex: project_vertex,\\n\\t\\tdithering_fragment: dithering_fragment,\\n\\t\\tdithering_pars_fragment: dithering_pars_fragment,\\n\\t\\troughnessmap_fragment: roughnessmap_fragment,\\n\\t\\troughnessmap_pars_fragment: roughnessmap_pars_fragment,\\n\\t\\tshadowmap_pars_fragment: shadowmap_pars_fragment,\\n\\t\\tshadowmap_pars_vertex: shadowmap_pars_vertex,\\n\\t\\tshadowmap_vertex: shadowmap_vertex,\\n\\t\\tshadowmask_pars_fragment: shadowmask_pars_fragment,\\n\\t\\tskinbase_vertex: skinbase_vertex,\\n\\t\\tskinning_pars_vertex: skinning_pars_vertex,\\n\\t\\tskinning_vertex: skinning_vertex,\\n\\t\\tskinnormal_vertex: skinnormal_vertex,\\n\\t\\tspecularmap_fragment: specularmap_fragment,\\n\\t\\tspecularmap_pars_fragment: specularmap_pars_fragment,\\n\\t\\ttonemapping_fragment: tonemapping_fragment,\\n\\t\\ttonemapping_pars_fragment: tonemapping_pars_fragment,\\n\\t\\tuv_pars_fragment: uv_pars_fragment,\\n\\t\\tuv_pars_vertex: uv_pars_vertex,\\n\\t\\tuv_vertex: uv_vertex,\\n\\t\\tuv2_pars_fragment: uv2_pars_fragment,\\n\\t\\tuv2_pars_vertex: uv2_pars_vertex,\\n\\t\\tuv2_vertex: uv2_vertex,\\n\\t\\tworldpos_vertex: worldpos_vertex,\\n\\n\\t\\tcube_frag: cube_frag,\\n\\t\\tcube_vert: cube_vert,\\n\\t\\tdepth_frag: depth_frag,\\n\\t\\tdepth_vert: depth_vert,\\n\\t\\tdistanceRGBA_frag: distanceRGBA_frag,\\n\\t\\tdistanceRGBA_vert: distanceRGBA_vert,\\n\\t\\tequirect_frag: equirect_frag,\\n\\t\\tequirect_vert: equirect_vert,\\n\\t\\tlinedashed_frag: linedashed_frag,\\n\\t\\tlinedashed_vert: linedashed_vert,\\n\\t\\tmeshbasic_frag: meshbasic_frag,\\n\\t\\tmeshbasic_vert: meshbasic_vert,\\n\\t\\tmeshlambert_frag: meshlambert_frag,\\n\\t\\tmeshlambert_vert: meshlambert_vert,\\n\\t\\tmeshphong_frag: meshphong_frag,\\n\\t\\tmeshphong_vert: meshphong_vert,\\n\\t\\tmeshphysical_frag: meshphysical_frag,\\n\\t\\tmeshphysical_vert: meshphysical_vert,\\n\\t\\tnormal_frag: normal_frag,\\n\\t\\tnormal_vert: normal_vert,\\n\\t\\tpoints_frag: points_frag,\\n\\t\\tpoints_vert: points_vert,\\n\\t\\tshadow_frag: shadow_frag,\\n\\t\\tshadow_vert: shadow_vert\\n\\t};\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t */\\n\\n\\tvar ShaderLib = {\\n\\n\\t\\tbasic: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.specularmap,\\n\\t\\t\\t\\tUniformsLib.envmap,\\n\\t\\t\\t\\tUniformsLib.aomap,\\n\\t\\t\\t\\tUniformsLib.lightmap,\\n\\t\\t\\t\\tUniformsLib.fog\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.meshbasic_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.meshbasic_frag\\n\\n\\t\\t},\\n\\n\\t\\tlambert: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.specularmap,\\n\\t\\t\\t\\tUniformsLib.envmap,\\n\\t\\t\\t\\tUniformsLib.aomap,\\n\\t\\t\\t\\tUniformsLib.lightmap,\\n\\t\\t\\t\\tUniformsLib.emissivemap,\\n\\t\\t\\t\\tUniformsLib.fog,\\n\\t\\t\\t\\tUniformsLib.lights,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\temissive: { value: new Color( 0x000000 ) }\\n\\t\\t\\t\\t}\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.meshlambert_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.meshlambert_frag\\n\\n\\t\\t},\\n\\n\\t\\tphong: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.specularmap,\\n\\t\\t\\t\\tUniformsLib.envmap,\\n\\t\\t\\t\\tUniformsLib.aomap,\\n\\t\\t\\t\\tUniformsLib.lightmap,\\n\\t\\t\\t\\tUniformsLib.emissivemap,\\n\\t\\t\\t\\tUniformsLib.bumpmap,\\n\\t\\t\\t\\tUniformsLib.normalmap,\\n\\t\\t\\t\\tUniformsLib.displacementmap,\\n\\t\\t\\t\\tUniformsLib.gradientmap,\\n\\t\\t\\t\\tUniformsLib.fog,\\n\\t\\t\\t\\tUniformsLib.lights,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\temissive: { value: new Color( 0x000000 ) },\\n\\t\\t\\t\\t\\tspecular: { value: new Color( 0x111111 ) },\\n\\t\\t\\t\\t\\tshininess: { value: 30 }\\n\\t\\t\\t\\t}\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.meshphong_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.meshphong_frag\\n\\n\\t\\t},\\n\\n\\t\\tstandard: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.envmap,\\n\\t\\t\\t\\tUniformsLib.aomap,\\n\\t\\t\\t\\tUniformsLib.lightmap,\\n\\t\\t\\t\\tUniformsLib.emissivemap,\\n\\t\\t\\t\\tUniformsLib.bumpmap,\\n\\t\\t\\t\\tUniformsLib.normalmap,\\n\\t\\t\\t\\tUniformsLib.displacementmap,\\n\\t\\t\\t\\tUniformsLib.roughnessmap,\\n\\t\\t\\t\\tUniformsLib.metalnessmap,\\n\\t\\t\\t\\tUniformsLib.fog,\\n\\t\\t\\t\\tUniformsLib.lights,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\temissive: { value: new Color( 0x000000 ) },\\n\\t\\t\\t\\t\\troughness: { value: 0.5 },\\n\\t\\t\\t\\t\\tmetalness: { value: 0.5 },\\n\\t\\t\\t\\t\\tenvMapIntensity: { value: 1 } // temporary\\n\\t\\t\\t\\t}\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.meshphysical_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.meshphysical_frag\\n\\n\\t\\t},\\n\\n\\t\\tpoints: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.points,\\n\\t\\t\\t\\tUniformsLib.fog\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.points_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.points_frag\\n\\n\\t\\t},\\n\\n\\t\\tdashed: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.fog,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tscale: { value: 1 },\\n\\t\\t\\t\\t\\tdashSize: { value: 1 },\\n\\t\\t\\t\\t\\ttotalSize: { value: 2 }\\n\\t\\t\\t\\t}\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.linedashed_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.linedashed_frag\\n\\n\\t\\t},\\n\\n\\t\\tdepth: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.displacementmap\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.depth_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.depth_frag\\n\\n\\t\\t},\\n\\n\\t\\tnormal: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.bumpmap,\\n\\t\\t\\t\\tUniformsLib.normalmap,\\n\\t\\t\\t\\tUniformsLib.displacementmap,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\topacity: { value: 1.0 }\\n\\t\\t\\t\\t}\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.normal_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.normal_frag\\n\\n\\t\\t},\\n\\n\\t\\t/* -------------------------------------------------------------------------\\n\\t\\t//\\tCube map shader\\n\\t\\t ------------------------------------------------------------------------- */\\n\\n\\t\\tcube: {\\n\\n\\t\\t\\tuniforms: {\\n\\t\\t\\t\\ttCube: { value: null },\\n\\t\\t\\t\\ttFlip: { value: - 1 },\\n\\t\\t\\t\\topacity: { value: 1.0 }\\n\\t\\t\\t},\\n\\n\\t\\t\\tvertexShader: ShaderChunk.cube_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.cube_frag\\n\\n\\t\\t},\\n\\n\\t\\tequirect: {\\n\\n\\t\\t\\tuniforms: {\\n\\t\\t\\t\\ttEquirect: { value: null },\\n\\t\\t\\t},\\n\\n\\t\\t\\tvertexShader: ShaderChunk.equirect_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.equirect_frag\\n\\n\\t\\t},\\n\\n\\t\\tdistanceRGBA: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.common,\\n\\t\\t\\t\\tUniformsLib.displacementmap,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\treferencePosition: { value: new Vector3() },\\n\\t\\t\\t\\t\\tnearDistance: { value: 1 },\\n\\t\\t\\t\\t\\tfarDistance: { value: 1000 }\\n\\t\\t\\t\\t}\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.distanceRGBA_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.distanceRGBA_frag\\n\\n\\t\\t},\\n\\n\\t\\tshadow: {\\n\\n\\t\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\t\\tUniformsLib.lights,\\n\\t\\t\\t\\tUniformsLib.fog,\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcolor: { value: new Color( 0x00000 ) },\\n\\t\\t\\t\\t\\topacity: { value: 1.0 }\\n\\t\\t\\t\\t},\\n\\t\\t\\t] ),\\n\\n\\t\\t\\tvertexShader: ShaderChunk.shadow_vert,\\n\\t\\t\\tfragmentShader: ShaderChunk.shadow_frag\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tShaderLib.physical = {\\n\\n\\t\\tuniforms: UniformsUtils.merge( [\\n\\t\\t\\tShaderLib.standard.uniforms,\\n\\t\\t\\t{\\n\\t\\t\\t\\tclearCoat: { value: 0 },\\n\\t\\t\\t\\tclearCoatRoughness: { value: 0 }\\n\\t\\t\\t}\\n\\t\\t] ),\\n\\n\\t\\tvertexShader: ShaderChunk.meshphysical_vert,\\n\\t\\tfragmentShader: ShaderChunk.meshphysical_frag\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Box2( min, max ) {\\n\\n\\t\\tthis.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );\\n\\t\\tthis.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );\\n\\n\\t}\\n\\n\\tObject.assign( Box2.prototype, {\\n\\n\\t\\tset: function ( min, max ) {\\n\\n\\t\\t\\tthis.min.copy( min );\\n\\t\\t\\tthis.max.copy( max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromPoints: function ( points ) {\\n\\n\\t\\t\\tthis.makeEmpty();\\n\\n\\t\\t\\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.expandByPoint( points[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromCenterAndSize: function () {\\n\\n\\t\\t\\tvar v1 = new Vector2();\\n\\n\\t\\t\\treturn function setFromCenterAndSize( center, size ) {\\n\\n\\t\\t\\t\\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\\n\\t\\t\\t\\tthis.min.copy( center ).sub( halfSize );\\n\\t\\t\\t\\tthis.max.copy( center ).add( halfSize );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( box ) {\\n\\n\\t\\t\\tthis.min.copy( box.min );\\n\\t\\t\\tthis.max.copy( box.max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeEmpty: function () {\\n\\n\\t\\t\\tthis.min.x = this.min.y = + Infinity;\\n\\t\\t\\tthis.max.x = this.max.y = - Infinity;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tisEmpty: function () {\\n\\n\\t\\t\\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\\n\\n\\t\\t\\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\\n\\n\\t\\t},\\n\\n\\t\\tgetCenter: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector2();\\n\\t\\t\\treturn this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\\n\\n\\t\\t},\\n\\n\\t\\tgetSize: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector2();\\n\\t\\t\\treturn this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );\\n\\n\\t\\t},\\n\\n\\t\\texpandByPoint: function ( point ) {\\n\\n\\t\\t\\tthis.min.min( point );\\n\\t\\t\\tthis.max.max( point );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\texpandByVector: function ( vector ) {\\n\\n\\t\\t\\tthis.min.sub( vector );\\n\\t\\t\\tthis.max.add( vector );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\texpandByScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.min.addScalar( - scalar );\\n\\t\\t\\tthis.max.addScalar( scalar );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcontainsPoint: function ( point ) {\\n\\n\\t\\t\\treturn point.x < this.min.x || point.x > this.max.x ||\\n\\t\\t\\t\\tpoint.y < this.min.y || point.y > this.max.y ? false : true;\\n\\n\\t\\t},\\n\\n\\t\\tcontainsBox: function ( box ) {\\n\\n\\t\\t\\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\\n\\t\\t\\t\\tthis.min.y <= box.min.y && box.max.y <= this.max.y;\\n\\n\\t\\t},\\n\\n\\t\\tgetParameter: function ( point, optionalTarget ) {\\n\\n\\t\\t\\t// This can potentially have a divide by zero if the box\\n\\t\\t\\t// has a size dimension of 0.\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector2();\\n\\n\\t\\t\\treturn result.set(\\n\\t\\t\\t\\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\\n\\t\\t\\t\\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\\n\\t\\t\\t);\\n\\n\\t\\t},\\n\\n\\t\\tintersectsBox: function ( box ) {\\n\\n\\t\\t\\t// using 4 splitting planes to rule out intersections\\n\\n\\t\\t\\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\\n\\t\\t\\t\\tbox.max.y < this.min.y || box.min.y > this.max.y ? false : true;\\n\\n\\t\\t},\\n\\n\\t\\tclampPoint: function ( point, optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector2();\\n\\t\\t\\treturn result.copy( point ).clamp( this.min, this.max );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToPoint: function () {\\n\\n\\t\\t\\tvar v1 = new Vector2();\\n\\n\\t\\t\\treturn function distanceToPoint( point ) {\\n\\n\\t\\t\\t\\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\\n\\t\\t\\t\\treturn clampedPoint.sub( point ).length();\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersect: function ( box ) {\\n\\n\\t\\t\\tthis.min.max( box.min );\\n\\t\\t\\tthis.max.min( box.max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tunion: function ( box ) {\\n\\n\\t\\t\\tthis.min.min( box.min );\\n\\t\\t\\tthis.max.max( box.max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttranslate: function ( offset ) {\\n\\n\\t\\t\\tthis.min.add( offset );\\n\\t\\t\\tthis.max.add( offset );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( box ) {\\n\\n\\t\\t\\treturn box.min.equals( this.min ) && box.max.equals( this.max );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction WebGLFlareRenderer( renderer, gl, state, textures, capabilities ) {\\n\\n\\t\\tvar vertexBuffer, elementBuffer;\\n\\t\\tvar shader, program, attributes, uniforms;\\n\\n\\t\\tvar tempTexture, occlusionTexture;\\n\\n\\t\\tfunction init() {\\n\\n\\t\\t\\tvar vertices = new Float32Array( [\\n\\t\\t\\t\\t- 1, - 1, 0, 0,\\n\\t\\t\\t\\t  1, - 1, 1, 0,\\n\\t\\t\\t\\t  1, 1, 1, 1,\\n\\t\\t\\t\\t- 1, 1, 0, 1\\n\\t\\t\\t] );\\n\\n\\t\\t\\tvar faces = new Uint16Array( [\\n\\t\\t\\t\\t0, 1, 2,\\n\\t\\t\\t\\t0, 2, 3\\n\\t\\t\\t] );\\n\\n\\t\\t\\t// buffers\\n\\n\\t\\t\\tvertexBuffer = gl.createBuffer();\\n\\t\\t\\telementBuffer = gl.createBuffer();\\n\\n\\t\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\\n\\t\\t\\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\\n\\n\\t\\t\\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\\n\\t\\t\\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\\n\\n\\t\\t\\t// textures\\n\\n\\t\\t\\ttempTexture = gl.createTexture();\\n\\t\\t\\tocclusionTexture = gl.createTexture();\\n\\n\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\\n\\t\\t\\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\\n\\n\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\\n\\t\\t\\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\\n\\t\\t\\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\\n\\n\\t\\t\\tshader = {\\n\\n\\t\\t\\t\\tvertexShader: [\\n\\n\\t\\t\\t\\t\\t'uniform lowp int renderType;',\\n\\n\\t\\t\\t\\t\\t'uniform vec3 screenPosition;',\\n\\t\\t\\t\\t\\t'uniform vec2 scale;',\\n\\t\\t\\t\\t\\t'uniform float rotation;',\\n\\n\\t\\t\\t\\t\\t'uniform sampler2D occlusionMap;',\\n\\n\\t\\t\\t\\t\\t'attribute vec2 position;',\\n\\t\\t\\t\\t\\t'attribute vec2 uv;',\\n\\n\\t\\t\\t\\t\\t'varying vec2 vUV;',\\n\\t\\t\\t\\t\\t'varying float vVisibility;',\\n\\n\\t\\t\\t\\t\\t'void main() {',\\n\\n\\t\\t\\t\\t\\t'\\tvUV = uv;',\\n\\n\\t\\t\\t\\t\\t'\\tvec2 pos = position;',\\n\\n\\t\\t\\t\\t\\t'\\tif ( renderType == 2 ) {',\\n\\n\\t\\t\\t\\t\\t'\\t\\tvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );',\\n\\t\\t\\t\\t\\t'\\t\\tvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );',\\n\\n\\t\\t\\t\\t\\t'\\t\\tvVisibility =        visibility.r / 9.0;',\\n\\t\\t\\t\\t\\t'\\t\\tvVisibility *= 1.0 - visibility.g / 9.0;',\\n\\t\\t\\t\\t\\t'\\t\\tvVisibility *=       visibility.b / 9.0;',\\n\\t\\t\\t\\t\\t'\\t\\tvVisibility *= 1.0 - visibility.a / 9.0;',\\n\\n\\t\\t\\t\\t\\t'\\t\\tpos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;',\\n\\t\\t\\t\\t\\t'\\t\\tpos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;',\\n\\n\\t\\t\\t\\t\\t'\\t}',\\n\\n\\t\\t\\t\\t\\t'\\tgl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );',\\n\\n\\t\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t\\t].join( '\\\\n' ),\\n\\n\\t\\t\\t\\tfragmentShader: [\\n\\n\\t\\t\\t\\t\\t'uniform lowp int renderType;',\\n\\n\\t\\t\\t\\t\\t'uniform sampler2D map;',\\n\\t\\t\\t\\t\\t'uniform float opacity;',\\n\\t\\t\\t\\t\\t'uniform vec3 color;',\\n\\n\\t\\t\\t\\t\\t'varying vec2 vUV;',\\n\\t\\t\\t\\t\\t'varying float vVisibility;',\\n\\n\\t\\t\\t\\t\\t'void main() {',\\n\\n\\t\\t\\t\\t\\t// pink square\\n\\n\\t\\t\\t\\t\\t'\\tif ( renderType == 0 ) {',\\n\\n\\t\\t\\t\\t\\t'\\t\\tgl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );',\\n\\n\\t\\t\\t\\t\\t// restore\\n\\n\\t\\t\\t\\t\\t'\\t} else if ( renderType == 1 ) {',\\n\\n\\t\\t\\t\\t\\t'\\t\\tgl_FragColor = texture2D( map, vUV );',\\n\\n\\t\\t\\t\\t\\t// flare\\n\\n\\t\\t\\t\\t\\t'\\t} else {',\\n\\n\\t\\t\\t\\t\\t'\\t\\tvec4 texture = texture2D( map, vUV );',\\n\\t\\t\\t\\t\\t'\\t\\ttexture.a *= opacity * vVisibility;',\\n\\t\\t\\t\\t\\t'\\t\\tgl_FragColor = texture;',\\n\\t\\t\\t\\t\\t'\\t\\tgl_FragColor.rgb *= color;',\\n\\n\\t\\t\\t\\t\\t'\\t}',\\n\\n\\t\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t\\t].join( '\\\\n' )\\n\\n\\t\\t\\t};\\n\\n\\t\\t\\tprogram = createProgram( shader );\\n\\n\\t\\t\\tattributes = {\\n\\t\\t\\t\\tvertex: gl.getAttribLocation( program, 'position' ),\\n\\t\\t\\t\\tuv: gl.getAttribLocation( program, 'uv' )\\n\\t\\t\\t};\\n\\n\\t\\t\\tuniforms = {\\n\\t\\t\\t\\trenderType: gl.getUniformLocation( program, 'renderType' ),\\n\\t\\t\\t\\tmap: gl.getUniformLocation( program, 'map' ),\\n\\t\\t\\t\\tocclusionMap: gl.getUniformLocation( program, 'occlusionMap' ),\\n\\t\\t\\t\\topacity: gl.getUniformLocation( program, 'opacity' ),\\n\\t\\t\\t\\tcolor: gl.getUniformLocation( program, 'color' ),\\n\\t\\t\\t\\tscale: gl.getUniformLocation( program, 'scale' ),\\n\\t\\t\\t\\trotation: gl.getUniformLocation( program, 'rotation' ),\\n\\t\\t\\t\\tscreenPosition: gl.getUniformLocation( program, 'screenPosition' )\\n\\t\\t\\t};\\n\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\t * Render lens flares\\n\\t\\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\\n\\t\\t *         reads these back and calculates occlusion.\\n\\t\\t */\\n\\n\\t\\tthis.render = function ( flares, scene, camera, viewport ) {\\n\\n\\t\\t\\tif ( flares.length === 0 ) return;\\n\\n\\t\\t\\tvar tempPosition = new Vector3();\\n\\n\\t\\t\\tvar invAspect = viewport.w / viewport.z,\\n\\t\\t\\t\\thalfViewportWidth = viewport.z * 0.5,\\n\\t\\t\\t\\thalfViewportHeight = viewport.w * 0.5;\\n\\n\\t\\t\\tvar size = 16 / viewport.w,\\n\\t\\t\\t\\tscale = new Vector2( size * invAspect, size );\\n\\n\\t\\t\\tvar screenPosition = new Vector3( 1, 1, 0 ),\\n\\t\\t\\t\\tscreenPositionPixels = new Vector2( 1, 1 );\\n\\n\\t\\t\\tvar validArea = new Box2();\\n\\n\\t\\t\\tvalidArea.min.set( viewport.x, viewport.y );\\n\\t\\t\\tvalidArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );\\n\\n\\t\\t\\tif ( program === undefined ) {\\n\\n\\t\\t\\t\\tinit();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.useProgram( program );\\n\\n\\t\\t\\tstate.initAttributes();\\n\\t\\t\\tstate.enableAttribute( attributes.vertex );\\n\\t\\t\\tstate.enableAttribute( attributes.uv );\\n\\t\\t\\tstate.disableUnusedAttributes();\\n\\n\\t\\t\\t// loop through all lens flares to update their occlusion and positions\\n\\t\\t\\t// setup gl and common used attribs/uniforms\\n\\n\\t\\t\\tgl.uniform1i( uniforms.occlusionMap, 0 );\\n\\t\\t\\tgl.uniform1i( uniforms.map, 1 );\\n\\n\\t\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\\n\\t\\t\\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\\n\\t\\t\\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\\n\\n\\t\\t\\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\\n\\n\\t\\t\\tstate.disable( gl.CULL_FACE );\\n\\t\\t\\tstate.buffers.depth.setMask( false );\\n\\n\\t\\t\\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tsize = 16 / viewport.w;\\n\\t\\t\\t\\tscale.set( size * invAspect, size );\\n\\n\\t\\t\\t\\t// calc object screen position\\n\\n\\t\\t\\t\\tvar flare = flares[ i ];\\n\\n\\t\\t\\t\\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\\n\\n\\t\\t\\t\\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\\n\\t\\t\\t\\ttempPosition.applyMatrix4( camera.projectionMatrix );\\n\\n\\t\\t\\t\\t// setup arrays for gl programs\\n\\n\\t\\t\\t\\tscreenPosition.copy( tempPosition );\\n\\n\\t\\t\\t\\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\\n\\n\\t\\t\\t\\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\\n\\t\\t\\t\\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\\n\\n\\t\\t\\t\\t// screen cull\\n\\n\\t\\t\\t\\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\\n\\n\\t\\t\\t\\t\\t// save current RGB to temp texture\\n\\n\\t\\t\\t\\t\\tstate.activeTexture( gl.TEXTURE0 );\\n\\t\\t\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, null );\\n\\t\\t\\t\\t\\tstate.activeTexture( gl.TEXTURE1 );\\n\\t\\t\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\\n\\t\\t\\t\\t\\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\\n\\n\\n\\t\\t\\t\\t\\t// render pink quad\\n\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.renderType, 0 );\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\\n\\t\\t\\t\\t\\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\\n\\n\\t\\t\\t\\t\\tstate.disable( gl.BLEND );\\n\\t\\t\\t\\t\\tstate.enable( gl.DEPTH_TEST );\\n\\n\\t\\t\\t\\t\\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\\n\\n\\n\\t\\t\\t\\t\\t// copy result to occlusionMap\\n\\n\\t\\t\\t\\t\\tstate.activeTexture( gl.TEXTURE0 );\\n\\t\\t\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\\n\\t\\t\\t\\t\\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\\n\\n\\n\\t\\t\\t\\t\\t// restore graphics\\n\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.renderType, 1 );\\n\\t\\t\\t\\t\\tstate.disable( gl.DEPTH_TEST );\\n\\n\\t\\t\\t\\t\\tstate.activeTexture( gl.TEXTURE1 );\\n\\t\\t\\t\\t\\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\\n\\t\\t\\t\\t\\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\\n\\n\\n\\t\\t\\t\\t\\t// update object positions\\n\\n\\t\\t\\t\\t\\tflare.positionScreen.copy( screenPosition );\\n\\n\\t\\t\\t\\t\\tif ( flare.customUpdateCallback ) {\\n\\n\\t\\t\\t\\t\\t\\tflare.customUpdateCallback( flare );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tflare.updateLensFlares();\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// render flares\\n\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.renderType, 2 );\\n\\t\\t\\t\\t\\tstate.enable( gl.BLEND );\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar sprite = flare.lensFlares[ j ];\\n\\n\\t\\t\\t\\t\\t\\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tscreenPosition.x = sprite.x;\\n\\t\\t\\t\\t\\t\\t\\tscreenPosition.y = sprite.y;\\n\\t\\t\\t\\t\\t\\t\\tscreenPosition.z = sprite.z;\\n\\n\\t\\t\\t\\t\\t\\t\\tsize = sprite.size * sprite.scale / viewport.w;\\n\\n\\t\\t\\t\\t\\t\\t\\tscale.x = size * invAspect;\\n\\t\\t\\t\\t\\t\\t\\tscale.y = size;\\n\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform1f( uniforms.rotation, sprite.rotation );\\n\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform1f( uniforms.opacity, sprite.opacity );\\n\\t\\t\\t\\t\\t\\t\\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\\n\\n\\t\\t\\t\\t\\t\\t\\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\\n\\n\\t\\t\\t\\t\\t\\t\\ttextures.setTexture2D( sprite.texture, 1 );\\n\\n\\t\\t\\t\\t\\t\\t\\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// restore gl\\n\\n\\t\\t\\tstate.enable( gl.CULL_FACE );\\n\\t\\t\\tstate.enable( gl.DEPTH_TEST );\\n\\t\\t\\tstate.buffers.depth.setMask( true );\\n\\n\\t\\t\\tstate.reset();\\n\\n\\t\\t};\\n\\n\\t\\tfunction createProgram( shader ) {\\n\\n\\t\\t\\tvar program = gl.createProgram();\\n\\n\\t\\t\\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\\n\\t\\t\\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\\n\\n\\t\\t\\tvar prefix = 'precision ' + capabilities.precision + ' float;\\\\n';\\n\\n\\t\\t\\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\\n\\t\\t\\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\\n\\n\\t\\t\\tgl.compileShader( fragmentShader );\\n\\t\\t\\tgl.compileShader( vertexShader );\\n\\n\\t\\t\\tgl.attachShader( program, fragmentShader );\\n\\t\\t\\tgl.attachShader( program, vertexShader );\\n\\n\\t\\t\\tgl.linkProgram( program );\\n\\n\\t\\t\\treturn program;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\\n\\n\\t\\tTexture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\\n\\n\\t\\tthis.needsUpdate = true;\\n\\n\\t}\\n\\n\\tCanvasTexture.prototype = Object.create( Texture.prototype );\\n\\tCanvasTexture.prototype.constructor = CanvasTexture;\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction WebGLSpriteRenderer( renderer, gl, state, textures, capabilities ) {\\n\\n\\t\\tvar vertexBuffer, elementBuffer;\\n\\t\\tvar program, attributes, uniforms;\\n\\n\\t\\tvar texture;\\n\\n\\t\\t// decompose matrixWorld\\n\\n\\t\\tvar spritePosition = new Vector3();\\n\\t\\tvar spriteRotation = new Quaternion();\\n\\t\\tvar spriteScale = new Vector3();\\n\\n\\t\\tfunction init() {\\n\\n\\t\\t\\tvar vertices = new Float32Array( [\\n\\t\\t\\t\\t- 0.5, - 0.5, 0, 0,\\n\\t\\t\\t\\t  0.5, - 0.5, 1, 0,\\n\\t\\t\\t\\t  0.5, 0.5, 1, 1,\\n\\t\\t\\t\\t- 0.5, 0.5, 0, 1\\n\\t\\t\\t] );\\n\\n\\t\\t\\tvar faces = new Uint16Array( [\\n\\t\\t\\t\\t0, 1, 2,\\n\\t\\t\\t\\t0, 2, 3\\n\\t\\t\\t] );\\n\\n\\t\\t\\tvertexBuffer = gl.createBuffer();\\n\\t\\t\\telementBuffer = gl.createBuffer();\\n\\n\\t\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\\n\\t\\t\\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\\n\\n\\t\\t\\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\\n\\t\\t\\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\\n\\n\\t\\t\\tprogram = createProgram();\\n\\n\\t\\t\\tattributes = {\\n\\t\\t\\t\\tposition: gl.getAttribLocation( program, 'position' ),\\n\\t\\t\\t\\tuv: gl.getAttribLocation( program, 'uv' )\\n\\t\\t\\t};\\n\\n\\t\\t\\tuniforms = {\\n\\t\\t\\t\\tuvOffset: gl.getUniformLocation( program, 'uvOffset' ),\\n\\t\\t\\t\\tuvScale: gl.getUniformLocation( program, 'uvScale' ),\\n\\n\\t\\t\\t\\trotation: gl.getUniformLocation( program, 'rotation' ),\\n\\t\\t\\t\\tscale: gl.getUniformLocation( program, 'scale' ),\\n\\n\\t\\t\\t\\tcolor: gl.getUniformLocation( program, 'color' ),\\n\\t\\t\\t\\tmap: gl.getUniformLocation( program, 'map' ),\\n\\t\\t\\t\\topacity: gl.getUniformLocation( program, 'opacity' ),\\n\\n\\t\\t\\t\\tmodelViewMatrix: gl.getUniformLocation( program, 'modelViewMatrix' ),\\n\\t\\t\\t\\tprojectionMatrix: gl.getUniformLocation( program, 'projectionMatrix' ),\\n\\n\\t\\t\\t\\tfogType: gl.getUniformLocation( program, 'fogType' ),\\n\\t\\t\\t\\tfogDensity: gl.getUniformLocation( program, 'fogDensity' ),\\n\\t\\t\\t\\tfogNear: gl.getUniformLocation( program, 'fogNear' ),\\n\\t\\t\\t\\tfogFar: gl.getUniformLocation( program, 'fogFar' ),\\n\\t\\t\\t\\tfogColor: gl.getUniformLocation( program, 'fogColor' ),\\n\\t\\t\\t\\tfogDepth: gl.getUniformLocation( program, 'fogDepth' ),\\n\\n\\t\\t\\t\\talphaTest: gl.getUniformLocation( program, 'alphaTest' )\\n\\t\\t\\t};\\n\\n\\t\\t\\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\n\\t\\t\\tcanvas.width = 8;\\n\\t\\t\\tcanvas.height = 8;\\n\\n\\t\\t\\tvar context = canvas.getContext( '2d' );\\n\\t\\t\\tcontext.fillStyle = 'white';\\n\\t\\t\\tcontext.fillRect( 0, 0, 8, 8 );\\n\\n\\t\\t\\ttexture = new CanvasTexture( canvas );\\n\\n\\t\\t}\\n\\n\\t\\tthis.render = function ( sprites, scene, camera ) {\\n\\n\\t\\t\\tif ( sprites.length === 0 ) return;\\n\\n\\t\\t\\t// setup gl\\n\\n\\t\\t\\tif ( program === undefined ) {\\n\\n\\t\\t\\t\\tinit();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.useProgram( program );\\n\\n\\t\\t\\tstate.initAttributes();\\n\\t\\t\\tstate.enableAttribute( attributes.position );\\n\\t\\t\\tstate.enableAttribute( attributes.uv );\\n\\t\\t\\tstate.disableUnusedAttributes();\\n\\n\\t\\t\\tstate.disable( gl.CULL_FACE );\\n\\t\\t\\tstate.enable( gl.BLEND );\\n\\n\\t\\t\\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\\n\\t\\t\\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\\n\\t\\t\\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\\n\\n\\t\\t\\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\\n\\n\\t\\t\\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\\n\\n\\t\\t\\tstate.activeTexture( gl.TEXTURE0 );\\n\\t\\t\\tgl.uniform1i( uniforms.map, 0 );\\n\\n\\t\\t\\tvar oldFogType = 0;\\n\\t\\t\\tvar sceneFogType = 0;\\n\\t\\t\\tvar fog = scene.fog;\\n\\n\\t\\t\\tif ( fog ) {\\n\\n\\t\\t\\t\\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\\n\\n\\t\\t\\t\\tif ( fog.isFog ) {\\n\\n\\t\\t\\t\\t\\tgl.uniform1f( uniforms.fogNear, fog.near );\\n\\t\\t\\t\\t\\tgl.uniform1f( uniforms.fogFar, fog.far );\\n\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.fogType, 1 );\\n\\t\\t\\t\\t\\toldFogType = 1;\\n\\t\\t\\t\\t\\tsceneFogType = 1;\\n\\n\\t\\t\\t\\t} else if ( fog.isFogExp2 ) {\\n\\n\\t\\t\\t\\t\\tgl.uniform1f( uniforms.fogDensity, fog.density );\\n\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.fogType, 2 );\\n\\t\\t\\t\\t\\toldFogType = 2;\\n\\t\\t\\t\\t\\tsceneFogType = 2;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tgl.uniform1i( uniforms.fogType, 0 );\\n\\t\\t\\t\\toldFogType = 0;\\n\\t\\t\\t\\tsceneFogType = 0;\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\t// update positions and sort\\n\\n\\t\\t\\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar sprite = sprites[ i ];\\n\\n\\t\\t\\t\\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\\n\\t\\t\\t\\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tsprites.sort( painterSortStable );\\n\\n\\t\\t\\t// render all sprites\\n\\n\\t\\t\\tvar scale = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar sprite = sprites[ i ];\\n\\t\\t\\t\\tvar material = sprite.material;\\n\\n\\t\\t\\t\\tif ( material.visible === false ) continue;\\n\\n\\t\\t\\t\\tsprite.onBeforeRender( renderer, scene, camera, undefined, material, undefined );\\n\\n\\t\\t\\t\\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\\n\\t\\t\\t\\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\\n\\n\\t\\t\\t\\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\\n\\n\\t\\t\\t\\tscale[ 0 ] = spriteScale.x;\\n\\t\\t\\t\\tscale[ 1 ] = spriteScale.y;\\n\\n\\t\\t\\t\\tvar fogType = 0;\\n\\n\\t\\t\\t\\tif ( scene.fog && material.fog ) {\\n\\n\\t\\t\\t\\t\\tfogType = sceneFogType;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( oldFogType !== fogType ) {\\n\\n\\t\\t\\t\\t\\tgl.uniform1i( uniforms.fogType, fogType );\\n\\t\\t\\t\\t\\toldFogType = fogType;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( material.map !== null ) {\\n\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\\n\\t\\t\\t\\t\\tgl.uniform2f( uniforms.uvScale, 1, 1 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgl.uniform1f( uniforms.opacity, material.opacity );\\n\\t\\t\\t\\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\\n\\n\\t\\t\\t\\tgl.uniform1f( uniforms.rotation, material.rotation );\\n\\t\\t\\t\\tgl.uniform2fv( uniforms.scale, scale );\\n\\n\\t\\t\\t\\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\\n\\t\\t\\t\\tstate.buffers.depth.setTest( material.depthTest );\\n\\t\\t\\t\\tstate.buffers.depth.setMask( material.depthWrite );\\n\\t\\t\\t\\tstate.buffers.color.setMask( material.colorWrite );\\n\\n\\t\\t\\t\\ttextures.setTexture2D( material.map || texture, 0 );\\n\\n\\t\\t\\t\\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\\n\\n\\t\\t\\t\\tsprite.onAfterRender( renderer, scene, camera, undefined, material, undefined );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// restore gl\\n\\n\\t\\t\\tstate.enable( gl.CULL_FACE );\\n\\n\\t\\t\\tstate.reset();\\n\\n\\t\\t};\\n\\n\\t\\tfunction createProgram() {\\n\\n\\t\\t\\tvar program = gl.createProgram();\\n\\n\\t\\t\\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\\n\\t\\t\\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\\n\\n\\t\\t\\tgl.shaderSource( vertexShader, [\\n\\n\\t\\t\\t\\t'precision ' + capabilities.precision + ' float;',\\n\\n\\t\\t\\t\\t'#define SHADER_NAME ' + 'SpriteMaterial',\\n\\n\\t\\t\\t\\t'uniform mat4 modelViewMatrix;',\\n\\t\\t\\t\\t'uniform mat4 projectionMatrix;',\\n\\t\\t\\t\\t'uniform float rotation;',\\n\\t\\t\\t\\t'uniform vec2 scale;',\\n\\t\\t\\t\\t'uniform vec2 uvOffset;',\\n\\t\\t\\t\\t'uniform vec2 uvScale;',\\n\\n\\t\\t\\t\\t'attribute vec2 position;',\\n\\t\\t\\t\\t'attribute vec2 uv;',\\n\\n\\t\\t\\t\\t'varying vec2 vUV;',\\n\\t\\t\\t\\t'varying float fogDepth;',\\n\\n\\t\\t\\t\\t'void main() {',\\n\\n\\t\\t\\t\\t'\\tvUV = uvOffset + uv * uvScale;',\\n\\n\\t\\t\\t\\t'\\tvec2 alignedPosition = position * scale;',\\n\\n\\t\\t\\t\\t'\\tvec2 rotatedPosition;',\\n\\t\\t\\t\\t'\\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\\n\\t\\t\\t\\t'\\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\\n\\n\\t\\t\\t\\t'\\tvec4 mvPosition;',\\n\\n\\t\\t\\t\\t'\\tmvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\\n\\t\\t\\t\\t'\\tmvPosition.xy += rotatedPosition;',\\n\\n\\t\\t\\t\\t'\\tgl_Position = projectionMatrix * mvPosition;',\\n\\n\\t\\t\\t\\t'\\tfogDepth = - mvPosition.z;',\\n\\n\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t].join( '\\\\n' ) );\\n\\n\\t\\t\\tgl.shaderSource( fragmentShader, [\\n\\n\\t\\t\\t\\t'precision ' + capabilities.precision + ' float;',\\n\\n\\t\\t\\t\\t'#define SHADER_NAME ' + 'SpriteMaterial',\\n\\n\\t\\t\\t\\t'uniform vec3 color;',\\n\\t\\t\\t\\t'uniform sampler2D map;',\\n\\t\\t\\t\\t'uniform float opacity;',\\n\\n\\t\\t\\t\\t'uniform int fogType;',\\n\\t\\t\\t\\t'uniform vec3 fogColor;',\\n\\t\\t\\t\\t'uniform float fogDensity;',\\n\\t\\t\\t\\t'uniform float fogNear;',\\n\\t\\t\\t\\t'uniform float fogFar;',\\n\\t\\t\\t\\t'uniform float alphaTest;',\\n\\n\\t\\t\\t\\t'varying vec2 vUV;',\\n\\t\\t\\t\\t'varying float fogDepth;',\\n\\n\\t\\t\\t\\t'void main() {',\\n\\n\\t\\t\\t\\t'\\tvec4 texture = texture2D( map, vUV );',\\n\\n\\t\\t\\t\\t'\\tgl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\\n\\n\\t\\t\\t\\t'\\tif ( gl_FragColor.a < alphaTest ) discard;',\\n\\n\\t\\t\\t\\t'\\tif ( fogType > 0 ) {',\\n\\n\\t\\t\\t\\t'\\t\\tfloat fogFactor = 0.0;',\\n\\n\\t\\t\\t\\t'\\t\\tif ( fogType == 1 ) {',\\n\\n\\t\\t\\t\\t'\\t\\t\\tfogFactor = smoothstep( fogNear, fogFar, fogDepth );',\\n\\n\\t\\t\\t\\t'\\t\\t} else {',\\n\\n\\t\\t\\t\\t'\\t\\t\\tconst float LOG2 = 1.442695;',\\n\\t\\t\\t\\t'\\t\\t\\tfogFactor = exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 );',\\n\\t\\t\\t\\t'\\t\\t\\tfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\\n\\n\\t\\t\\t\\t'\\t\\t}',\\n\\n\\t\\t\\t\\t'\\t\\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );',\\n\\n\\t\\t\\t\\t'\\t}',\\n\\n\\t\\t\\t\\t'}'\\n\\n\\t\\t\\t].join( '\\\\n' ) );\\n\\n\\t\\t\\tgl.compileShader( vertexShader );\\n\\t\\t\\tgl.compileShader( fragmentShader );\\n\\n\\t\\t\\tgl.attachShader( program, vertexShader );\\n\\t\\t\\tgl.attachShader( program, fragmentShader );\\n\\n\\t\\t\\tgl.linkProgram( program );\\n\\n\\t\\t\\treturn program;\\n\\n\\t\\t}\\n\\n\\t\\tfunction painterSortStable( a, b ) {\\n\\n\\t\\t\\tif ( a.renderOrder !== b.renderOrder ) {\\n\\n\\t\\t\\t\\treturn a.renderOrder - b.renderOrder;\\n\\n\\t\\t\\t} else if ( a.z !== b.z ) {\\n\\n\\t\\t\\t\\treturn b.z - a.z;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\treturn b.id - a.id;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tvar materialId = 0;\\n\\n\\tfunction Material() {\\n\\n\\t\\tObject.defineProperty( this, 'id', { value: materialId ++ } );\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.name = '';\\n\\t\\tthis.type = 'Material';\\n\\n\\t\\tthis.fog = true;\\n\\t\\tthis.lights = true;\\n\\n\\t\\tthis.blending = NormalBlending;\\n\\t\\tthis.side = FrontSide;\\n\\t\\tthis.flatShading = false;\\n\\t\\tthis.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\\n\\n\\t\\tthis.opacity = 1;\\n\\t\\tthis.transparent = false;\\n\\n\\t\\tthis.blendSrc = SrcAlphaFactor;\\n\\t\\tthis.blendDst = OneMinusSrcAlphaFactor;\\n\\t\\tthis.blendEquation = AddEquation;\\n\\t\\tthis.blendSrcAlpha = null;\\n\\t\\tthis.blendDstAlpha = null;\\n\\t\\tthis.blendEquationAlpha = null;\\n\\n\\t\\tthis.depthFunc = LessEqualDepth;\\n\\t\\tthis.depthTest = true;\\n\\t\\tthis.depthWrite = true;\\n\\n\\t\\tthis.clippingPlanes = null;\\n\\t\\tthis.clipIntersection = false;\\n\\t\\tthis.clipShadows = false;\\n\\n\\t\\tthis.colorWrite = true;\\n\\n\\t\\tthis.precision = null; // override the renderer's default precision for this material\\n\\n\\t\\tthis.polygonOffset = false;\\n\\t\\tthis.polygonOffsetFactor = 0;\\n\\t\\tthis.polygonOffsetUnits = 0;\\n\\n\\t\\tthis.dithering = false;\\n\\n\\t\\tthis.alphaTest = 0;\\n\\t\\tthis.premultipliedAlpha = false;\\n\\n\\t\\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\\n\\n\\t\\tthis.visible = true;\\n\\n\\t\\tthis.userData = {};\\n\\n\\t\\tthis.needsUpdate = true;\\n\\n\\t}\\n\\n\\tMaterial.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: Material,\\n\\n\\t\\tisMaterial: true,\\n\\n\\t\\tonBeforeCompile: function () {},\\n\\n\\t\\tsetValues: function ( values ) {\\n\\n\\t\\t\\tif ( values === undefined ) return;\\n\\n\\t\\t\\tfor ( var key in values ) {\\n\\n\\t\\t\\t\\tvar newValue = values[ key ];\\n\\n\\t\\t\\t\\tif ( newValue === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.Material: '\\\" + key + \\\"' parameter is undefined.\\\" );\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// for backward compatability if shading is set in the constructor\\n\\t\\t\\t\\tif ( key === 'shading' ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\\n\\t\\t\\t\\t\\tthis.flatShading = ( newValue === FlatShading ) ? true : false;\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar currentValue = this[ key ];\\n\\n\\t\\t\\t\\tif ( currentValue === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.\\\" + this.type + \\\": '\\\" + key + \\\"' is not a property of this material.\\\" );\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( currentValue && currentValue.isColor ) {\\n\\n\\t\\t\\t\\t\\tcurrentValue.set( newValue );\\n\\n\\t\\t\\t\\t} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {\\n\\n\\t\\t\\t\\t\\tcurrentValue.copy( newValue );\\n\\n\\t\\t\\t\\t} else if ( key === 'overdraw' ) {\\n\\n\\t\\t\\t\\t\\t// ensure overdraw is backwards-compatible with legacy boolean type\\n\\t\\t\\t\\t\\tthis[ key ] = Number( newValue );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis[ key ] = newValue;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar isRoot = ( meta === undefined || typeof meta === 'string' );\\n\\n\\t\\t\\tif ( isRoot ) {\\n\\n\\t\\t\\t\\tmeta = {\\n\\t\\t\\t\\t\\ttextures: {},\\n\\t\\t\\t\\t\\timages: {}\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar data = {\\n\\t\\t\\t\\tmetadata: {\\n\\t\\t\\t\\t\\tversion: 4.5,\\n\\t\\t\\t\\t\\ttype: 'Material',\\n\\t\\t\\t\\t\\tgenerator: 'Material.toJSON'\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t\\t// standard Material serialization\\n\\t\\t\\tdata.uuid = this.uuid;\\n\\t\\t\\tdata.type = this.type;\\n\\n\\t\\t\\tif ( this.name !== '' ) data.name = this.name;\\n\\n\\t\\t\\tif ( this.color && this.color.isColor ) data.color = this.color.getHex();\\n\\n\\t\\t\\tif ( this.roughness !== undefined ) data.roughness = this.roughness;\\n\\t\\t\\tif ( this.metalness !== undefined ) data.metalness = this.metalness;\\n\\n\\t\\t\\tif ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();\\n\\t\\t\\tif ( this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;\\n\\n\\t\\t\\tif ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();\\n\\t\\t\\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\\n\\t\\t\\tif ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;\\n\\t\\t\\tif ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;\\n\\n\\t\\t\\tif ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;\\n\\t\\t\\tif ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\\n\\t\\t\\tif ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\\n\\t\\t\\tif ( this.bumpMap && this.bumpMap.isTexture ) {\\n\\n\\t\\t\\t\\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\\n\\t\\t\\t\\tdata.bumpScale = this.bumpScale;\\n\\n\\t\\t\\t}\\n\\t\\t\\tif ( this.normalMap && this.normalMap.isTexture ) {\\n\\n\\t\\t\\t\\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\\n\\t\\t\\t\\tdata.normalScale = this.normalScale.toArray();\\n\\n\\t\\t\\t}\\n\\t\\t\\tif ( this.displacementMap && this.displacementMap.isTexture ) {\\n\\n\\t\\t\\t\\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\\n\\t\\t\\t\\tdata.displacementScale = this.displacementScale;\\n\\t\\t\\t\\tdata.displacementBias = this.displacementBias;\\n\\n\\t\\t\\t}\\n\\t\\t\\tif ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\\n\\t\\t\\tif ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\\n\\n\\t\\t\\tif ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\\n\\t\\t\\tif ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\\n\\n\\t\\t\\tif ( this.envMap && this.envMap.isTexture ) {\\n\\n\\t\\t\\t\\tdata.envMap = this.envMap.toJSON( meta ).uuid;\\n\\t\\t\\t\\tdata.reflectivity = this.reflectivity; // Scale behind envMap\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.gradientMap && this.gradientMap.isTexture ) {\\n\\n\\t\\t\\t\\tdata.gradientMap = this.gradientMap.toJSON( meta ).uuid;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.size !== undefined ) data.size = this.size;\\n\\t\\t\\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\\n\\n\\t\\t\\tif ( this.blending !== NormalBlending ) data.blending = this.blending;\\n\\t\\t\\tif ( this.flatShading === true ) data.flatShading = this.flatShading;\\n\\t\\t\\tif ( this.side !== FrontSide ) data.side = this.side;\\n\\t\\t\\tif ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;\\n\\n\\t\\t\\tif ( this.opacity < 1 ) data.opacity = this.opacity;\\n\\t\\t\\tif ( this.transparent === true ) data.transparent = this.transparent;\\n\\n\\t\\t\\tdata.depthFunc = this.depthFunc;\\n\\t\\t\\tdata.depthTest = this.depthTest;\\n\\t\\t\\tdata.depthWrite = this.depthWrite;\\n\\n\\t\\t\\t// rotation (SpriteMaterial)\\n\\t\\t\\tif ( this.rotation !== 0 ) data.rotation = this.rotation;\\n\\n\\t\\t\\tif ( this.linewidth !== 1 ) data.linewidth = this.linewidth;\\n\\t\\t\\tif ( this.dashSize !== undefined ) data.dashSize = this.dashSize;\\n\\t\\t\\tif ( this.gapSize !== undefined ) data.gapSize = this.gapSize;\\n\\t\\t\\tif ( this.scale !== undefined ) data.scale = this.scale;\\n\\n\\t\\t\\tif ( this.dithering === true ) data.dithering = true;\\n\\n\\t\\t\\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\\n\\t\\t\\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\\n\\n\\t\\t\\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\\n\\t\\t\\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\\n\\t\\t\\tif ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;\\n\\t\\t\\tif ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;\\n\\n\\t\\t\\tif ( this.morphTargets === true ) data.morphTargets = true;\\n\\t\\t\\tif ( this.skinning === true ) data.skinning = true;\\n\\n\\t\\t\\tif ( this.visible === false ) data.visible = false;\\n\\t\\t\\tif ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;\\n\\n\\t\\t\\t// TODO: Copied from Object3D.toJSON\\n\\n\\t\\t\\tfunction extractFromCache( cache ) {\\n\\n\\t\\t\\t\\tvar values = [];\\n\\n\\t\\t\\t\\tfor ( var key in cache ) {\\n\\n\\t\\t\\t\\t\\tvar data = cache[ key ];\\n\\t\\t\\t\\t\\tdelete data.metadata;\\n\\t\\t\\t\\t\\tvalues.push( data );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn values;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( isRoot ) {\\n\\n\\t\\t\\t\\tvar textures = extractFromCache( meta.textures );\\n\\t\\t\\t\\tvar images = extractFromCache( meta.images );\\n\\n\\t\\t\\t\\tif ( textures.length > 0 ) data.textures = textures;\\n\\t\\t\\t\\tif ( images.length > 0 ) data.images = images;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.name = source.name;\\n\\n\\t\\t\\tthis.fog = source.fog;\\n\\t\\t\\tthis.lights = source.lights;\\n\\n\\t\\t\\tthis.blending = source.blending;\\n\\t\\t\\tthis.side = source.side;\\n\\t\\t\\tthis.flatShading = source.flatShading;\\n\\t\\t\\tthis.vertexColors = source.vertexColors;\\n\\n\\t\\t\\tthis.opacity = source.opacity;\\n\\t\\t\\tthis.transparent = source.transparent;\\n\\n\\t\\t\\tthis.blendSrc = source.blendSrc;\\n\\t\\t\\tthis.blendDst = source.blendDst;\\n\\t\\t\\tthis.blendEquation = source.blendEquation;\\n\\t\\t\\tthis.blendSrcAlpha = source.blendSrcAlpha;\\n\\t\\t\\tthis.blendDstAlpha = source.blendDstAlpha;\\n\\t\\t\\tthis.blendEquationAlpha = source.blendEquationAlpha;\\n\\n\\t\\t\\tthis.depthFunc = source.depthFunc;\\n\\t\\t\\tthis.depthTest = source.depthTest;\\n\\t\\t\\tthis.depthWrite = source.depthWrite;\\n\\n\\t\\t\\tthis.colorWrite = source.colorWrite;\\n\\n\\t\\t\\tthis.precision = source.precision;\\n\\n\\t\\t\\tthis.polygonOffset = source.polygonOffset;\\n\\t\\t\\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\\n\\t\\t\\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\\n\\n\\t\\t\\tthis.dithering = source.dithering;\\n\\n\\t\\t\\tthis.alphaTest = source.alphaTest;\\n\\t\\t\\tthis.premultipliedAlpha = source.premultipliedAlpha;\\n\\n\\t\\t\\tthis.overdraw = source.overdraw;\\n\\n\\t\\t\\tthis.visible = source.visible;\\n\\t\\t\\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\\n\\n\\t\\t\\tthis.clipShadows = source.clipShadows;\\n\\t\\t\\tthis.clipIntersection = source.clipIntersection;\\n\\n\\t\\t\\tvar srcPlanes = source.clippingPlanes,\\n\\t\\t\\t\\tdstPlanes = null;\\n\\n\\t\\t\\tif ( srcPlanes !== null ) {\\n\\n\\t\\t\\t\\tvar n = srcPlanes.length;\\n\\t\\t\\t\\tdstPlanes = new Array( n );\\n\\n\\t\\t\\t\\tfor ( var i = 0; i !== n; ++ i )\\n\\t\\t\\t\\t\\tdstPlanes[ i ] = srcPlanes[ i ].clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.clippingPlanes = dstPlanes;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdispose: function () {\\n\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author bhouston / https://clara.io\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t *\\n\\t * parameters = {\\n\\t *\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\n\\t *  displacementScale: <float>,\\n\\t *  displacementBias: <float>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshDepthMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'MeshDepthMaterial';\\n\\n\\t\\tthis.depthPacking = BasicDepthPacking;\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.alphaMap = null;\\n\\n\\t\\tthis.displacementMap = null;\\n\\t\\tthis.displacementScale = 1;\\n\\t\\tthis.displacementBias = 0;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\n\\t\\tthis.fog = false;\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshDepthMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshDepthMaterial.prototype.constructor = MeshDepthMaterial;\\n\\n\\tMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\\n\\n\\tMeshDepthMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.depthPacking = source.depthPacking;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.alphaMap = source.alphaMap;\\n\\n\\t\\tthis.displacementMap = source.displacementMap;\\n\\t\\tthis.displacementScale = source.displacementScale;\\n\\t\\tthis.displacementBias = source.displacementBias;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t *\\n\\t * parameters = {\\n\\t *\\n\\t *  referencePosition: <float>,\\n\\t *  nearDistance: <float>,\\n\\t *  farDistance: <float>,\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>,\\n\\t *\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\n\\t *  displacementScale: <float>,\\n\\t *  displacementBias: <float>\\n\\t *\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshDistanceMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'MeshDistanceMaterial';\\n\\n\\t\\tthis.referencePosition = new Vector3();\\n\\t\\tthis.nearDistance = 1;\\n\\t\\tthis.farDistance = 1000;\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.alphaMap = null;\\n\\n\\t\\tthis.displacementMap = null;\\n\\t\\tthis.displacementScale = 1;\\n\\t\\tthis.displacementBias = 0;\\n\\n\\t\\tthis.fog = false;\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshDistanceMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;\\n\\n\\tMeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;\\n\\n\\tMeshDistanceMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.referencePosition.copy( source.referencePosition );\\n\\t\\tthis.nearDistance = source.nearDistance;\\n\\t\\tthis.farDistance = source.farDistance;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.alphaMap = source.alphaMap;\\n\\n\\t\\tthis.displacementMap = source.displacementMap;\\n\\t\\tthis.displacementScale = source.displacementScale;\\n\\t\\tthis.displacementBias = source.displacementBias;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction Box3( min, max ) {\\n\\n\\t\\tthis.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );\\n\\t\\tthis.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );\\n\\n\\t}\\n\\n\\tObject.assign( Box3.prototype, {\\n\\n\\t\\tisBox3: true,\\n\\n\\t\\tset: function ( min, max ) {\\n\\n\\t\\t\\tthis.min.copy( min );\\n\\t\\t\\tthis.max.copy( max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromArray: function ( array ) {\\n\\n\\t\\t\\tvar minX = + Infinity;\\n\\t\\t\\tvar minY = + Infinity;\\n\\t\\t\\tvar minZ = + Infinity;\\n\\n\\t\\t\\tvar maxX = - Infinity;\\n\\t\\t\\tvar maxY = - Infinity;\\n\\t\\t\\tvar maxZ = - Infinity;\\n\\n\\t\\t\\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\\n\\n\\t\\t\\t\\tvar x = array[ i ];\\n\\t\\t\\t\\tvar y = array[ i + 1 ];\\n\\t\\t\\t\\tvar z = array[ i + 2 ];\\n\\n\\t\\t\\t\\tif ( x < minX ) minX = x;\\n\\t\\t\\t\\tif ( y < minY ) minY = y;\\n\\t\\t\\t\\tif ( z < minZ ) minZ = z;\\n\\n\\t\\t\\t\\tif ( x > maxX ) maxX = x;\\n\\t\\t\\t\\tif ( y > maxY ) maxY = y;\\n\\t\\t\\t\\tif ( z > maxZ ) maxZ = z;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.min.set( minX, minY, minZ );\\n\\t\\t\\tthis.max.set( maxX, maxY, maxZ );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromBufferAttribute: function ( attribute ) {\\n\\n\\t\\t\\tvar minX = + Infinity;\\n\\t\\t\\tvar minY = + Infinity;\\n\\t\\t\\tvar minZ = + Infinity;\\n\\n\\t\\t\\tvar maxX = - Infinity;\\n\\t\\t\\tvar maxY = - Infinity;\\n\\t\\t\\tvar maxZ = - Infinity;\\n\\n\\t\\t\\tfor ( var i = 0, l = attribute.count; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar x = attribute.getX( i );\\n\\t\\t\\t\\tvar y = attribute.getY( i );\\n\\t\\t\\t\\tvar z = attribute.getZ( i );\\n\\n\\t\\t\\t\\tif ( x < minX ) minX = x;\\n\\t\\t\\t\\tif ( y < minY ) minY = y;\\n\\t\\t\\t\\tif ( z < minZ ) minZ = z;\\n\\n\\t\\t\\t\\tif ( x > maxX ) maxX = x;\\n\\t\\t\\t\\tif ( y > maxY ) maxY = y;\\n\\t\\t\\t\\tif ( z > maxZ ) maxZ = z;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.min.set( minX, minY, minZ );\\n\\t\\t\\tthis.max.set( maxX, maxY, maxZ );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromPoints: function ( points ) {\\n\\n\\t\\t\\tthis.makeEmpty();\\n\\n\\t\\t\\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.expandByPoint( points[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromCenterAndSize: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function setFromCenterAndSize( center, size ) {\\n\\n\\t\\t\\t\\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\\n\\n\\t\\t\\t\\tthis.min.copy( center ).sub( halfSize );\\n\\t\\t\\t\\tthis.max.copy( center ).add( halfSize );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tsetFromObject: function ( object ) {\\n\\n\\t\\t\\tthis.makeEmpty();\\n\\n\\t\\t\\treturn this.expandByObject( object );\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( box ) {\\n\\n\\t\\t\\tthis.min.copy( box.min );\\n\\t\\t\\tthis.max.copy( box.max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tmakeEmpty: function () {\\n\\n\\t\\t\\tthis.min.x = this.min.y = this.min.z = + Infinity;\\n\\t\\t\\tthis.max.x = this.max.y = this.max.z = - Infinity;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tisEmpty: function () {\\n\\n\\t\\t\\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\\n\\n\\t\\t\\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\\n\\n\\t\\t},\\n\\n\\t\\tgetCenter: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\\n\\n\\t\\t},\\n\\n\\t\\tgetSize: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\treturn this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );\\n\\n\\t\\t},\\n\\n\\t\\texpandByPoint: function ( point ) {\\n\\n\\t\\t\\tthis.min.min( point );\\n\\t\\t\\tthis.max.max( point );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\texpandByVector: function ( vector ) {\\n\\n\\t\\t\\tthis.min.sub( vector );\\n\\t\\t\\tthis.max.add( vector );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\texpandByScalar: function ( scalar ) {\\n\\n\\t\\t\\tthis.min.addScalar( - scalar );\\n\\t\\t\\tthis.max.addScalar( scalar );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\texpandByObject: function () {\\n\\n\\t\\t\\t// Computes the world-axis-aligned bounding box of an object (including its children),\\n\\t\\t\\t// accounting for both the object's, and children's, world transforms\\n\\n\\t\\t\\tvar scope, i, l;\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\tfunction traverse( node ) {\\n\\n\\t\\t\\t\\tvar geometry = node.geometry;\\n\\n\\t\\t\\t\\tif ( geometry !== undefined ) {\\n\\n\\t\\t\\t\\t\\tif ( geometry.isGeometry ) {\\n\\n\\t\\t\\t\\t\\t\\tvar vertices = geometry.vertices;\\n\\n\\t\\t\\t\\t\\t\\tfor ( i = 0, l = vertices.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tv1.copy( vertices[ i ] );\\n\\t\\t\\t\\t\\t\\t\\tv1.applyMatrix4( node.matrixWorld );\\n\\n\\t\\t\\t\\t\\t\\t\\tscope.expandByPoint( v1 );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else if ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\t\\t\\tvar attribute = geometry.attributes.position;\\n\\n\\t\\t\\t\\t\\t\\tif ( attribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0, l = attribute.count; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tv1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tscope.expandByPoint( v1 );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn function expandByObject( object ) {\\n\\n\\t\\t\\t\\tscope = this;\\n\\n\\t\\t\\t\\tobject.updateMatrixWorld( true );\\n\\n\\t\\t\\t\\tobject.traverse( traverse );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tcontainsPoint: function ( point ) {\\n\\n\\t\\t\\treturn point.x < this.min.x || point.x > this.max.x ||\\n\\t\\t\\t\\tpoint.y < this.min.y || point.y > this.max.y ||\\n\\t\\t\\t\\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\\n\\n\\t\\t},\\n\\n\\t\\tcontainsBox: function ( box ) {\\n\\n\\t\\t\\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\\n\\t\\t\\t\\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\\n\\t\\t\\t\\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\\n\\n\\t\\t},\\n\\n\\t\\tgetParameter: function ( point, optionalTarget ) {\\n\\n\\t\\t\\t// This can potentially have a divide by zero if the box\\n\\t\\t\\t// has a size dimension of 0.\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\treturn result.set(\\n\\t\\t\\t\\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\\n\\t\\t\\t\\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\\n\\t\\t\\t\\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\\n\\t\\t\\t);\\n\\n\\t\\t},\\n\\n\\t\\tintersectsBox: function ( box ) {\\n\\n\\t\\t\\t// using 6 splitting planes to rule out intersections.\\n\\t\\t\\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\\n\\t\\t\\t\\tbox.max.y < this.min.y || box.min.y > this.max.y ||\\n\\t\\t\\t\\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\\n\\n\\t\\t},\\n\\n\\t\\tintersectsSphere: ( function () {\\n\\n\\t\\t\\tvar closestPoint = new Vector3();\\n\\n\\t\\t\\treturn function intersectsSphere( sphere ) {\\n\\n\\t\\t\\t\\t// Find the point on the AABB closest to the sphere center.\\n\\t\\t\\t\\tthis.clampPoint( sphere.center, closestPoint );\\n\\n\\t\\t\\t\\t// If that point is inside the sphere, the AABB and sphere intersect.\\n\\t\\t\\t\\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )(),\\n\\n\\t\\tintersectsPlane: function ( plane ) {\\n\\n\\t\\t\\t// We compute the minimum and maximum dot product values. If those values\\n\\t\\t\\t// are on the same side (back or front) of the plane, then there is no intersection.\\n\\n\\t\\t\\tvar min, max;\\n\\n\\t\\t\\tif ( plane.normal.x > 0 ) {\\n\\n\\t\\t\\t\\tmin = plane.normal.x * this.min.x;\\n\\t\\t\\t\\tmax = plane.normal.x * this.max.x;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tmin = plane.normal.x * this.max.x;\\n\\t\\t\\t\\tmax = plane.normal.x * this.min.x;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( plane.normal.y > 0 ) {\\n\\n\\t\\t\\t\\tmin += plane.normal.y * this.min.y;\\n\\t\\t\\t\\tmax += plane.normal.y * this.max.y;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tmin += plane.normal.y * this.max.y;\\n\\t\\t\\t\\tmax += plane.normal.y * this.min.y;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( plane.normal.z > 0 ) {\\n\\n\\t\\t\\t\\tmin += plane.normal.z * this.min.z;\\n\\t\\t\\t\\tmax += plane.normal.z * this.max.z;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tmin += plane.normal.z * this.max.z;\\n\\t\\t\\t\\tmax += plane.normal.z * this.min.z;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ( min <= plane.constant && max >= plane.constant );\\n\\n\\t\\t},\\n\\n\\t\\tclampPoint: function ( point, optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\treturn result.copy( point ).clamp( this.min, this.max );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToPoint: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function distanceToPoint( point ) {\\n\\n\\t\\t\\t\\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\\n\\t\\t\\t\\treturn clampedPoint.sub( point ).length();\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tgetBoundingSphere: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function getBoundingSphere( optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Sphere();\\n\\n\\t\\t\\t\\tthis.getCenter( result.center );\\n\\n\\t\\t\\t\\tresult.radius = this.getSize( v1 ).length() * 0.5;\\n\\n\\t\\t\\t\\treturn result;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersect: function ( box ) {\\n\\n\\t\\t\\tthis.min.max( box.min );\\n\\t\\t\\tthis.max.min( box.max );\\n\\n\\t\\t\\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\\n\\t\\t\\tif ( this.isEmpty() ) this.makeEmpty();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tunion: function ( box ) {\\n\\n\\t\\t\\tthis.min.min( box.min );\\n\\t\\t\\tthis.max.max( box.max );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix4: function () {\\n\\n\\t\\t\\tvar points = [\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3(),\\n\\t\\t\\t\\tnew Vector3()\\n\\t\\t\\t];\\n\\n\\t\\t\\treturn function applyMatrix4( matrix ) {\\n\\n\\t\\t\\t\\t// transform of empty box is an empty box.\\n\\t\\t\\t\\tif ( this.isEmpty() ) return this;\\n\\n\\t\\t\\t\\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\\n\\t\\t\\t\\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\\n\\t\\t\\t\\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\\n\\t\\t\\t\\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\\n\\t\\t\\t\\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\\n\\t\\t\\t\\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\\n\\t\\t\\t\\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\\n\\t\\t\\t\\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\\n\\t\\t\\t\\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\\t// 111\\n\\n\\t\\t\\t\\tthis.setFromPoints( points );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslate: function ( offset ) {\\n\\n\\t\\t\\tthis.min.add( offset );\\n\\t\\t\\tthis.max.add( offset );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( box ) {\\n\\n\\t\\t\\treturn box.min.equals( this.min ) && box.max.equals( this.max );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Sphere( center, radius ) {\\n\\n\\t\\tthis.center = ( center !== undefined ) ? center : new Vector3();\\n\\t\\tthis.radius = ( radius !== undefined ) ? radius : 0;\\n\\n\\t}\\n\\n\\tObject.assign( Sphere.prototype, {\\n\\n\\t\\tset: function ( center, radius ) {\\n\\n\\t\\t\\tthis.center.copy( center );\\n\\t\\t\\tthis.radius = radius;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromPoints: function () {\\n\\n\\t\\t\\tvar box = new Box3();\\n\\n\\t\\t\\treturn function setFromPoints( points, optionalCenter ) {\\n\\n\\t\\t\\t\\tvar center = this.center;\\n\\n\\t\\t\\t\\tif ( optionalCenter !== undefined ) {\\n\\n\\t\\t\\t\\t\\tcenter.copy( optionalCenter );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tbox.setFromPoints( points ).getCenter( center );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar maxRadiusSq = 0;\\n\\n\\t\\t\\t\\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.radius = Math.sqrt( maxRadiusSq );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( sphere ) {\\n\\n\\t\\t\\tthis.center.copy( sphere.center );\\n\\t\\t\\tthis.radius = sphere.radius;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tempty: function () {\\n\\n\\t\\t\\treturn ( this.radius <= 0 );\\n\\n\\t\\t},\\n\\n\\t\\tcontainsPoint: function ( point ) {\\n\\n\\t\\t\\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToPoint: function ( point ) {\\n\\n\\t\\t\\treturn ( point.distanceTo( this.center ) - this.radius );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsSphere: function ( sphere ) {\\n\\n\\t\\t\\tvar radiusSum = this.radius + sphere.radius;\\n\\n\\t\\t\\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsBox: function ( box ) {\\n\\n\\t\\t\\treturn box.intersectsSphere( this );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsPlane: function ( plane ) {\\n\\n\\t\\t\\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\\n\\n\\t\\t},\\n\\n\\t\\tclampPoint: function ( point, optionalTarget ) {\\n\\n\\t\\t\\tvar deltaLengthSq = this.center.distanceToSquared( point );\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\tresult.copy( point );\\n\\n\\t\\t\\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\\n\\n\\t\\t\\t\\tresult.sub( this.center ).normalize();\\n\\t\\t\\t\\tresult.multiplyScalar( this.radius ).add( this.center );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t},\\n\\n\\t\\tgetBoundingBox: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar box = optionalTarget || new Box3();\\n\\n\\t\\t\\tbox.set( this.center, this.center );\\n\\t\\t\\tbox.expandByScalar( this.radius );\\n\\n\\t\\t\\treturn box;\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix4: function ( matrix ) {\\n\\n\\t\\t\\tthis.center.applyMatrix4( matrix );\\n\\t\\t\\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttranslate: function ( offset ) {\\n\\n\\t\\t\\tthis.center.add( offset );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( sphere ) {\\n\\n\\t\\t\\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Plane( normal, constant ) {\\n\\n\\t\\t// normal is assumed to be normalized\\n\\n\\t\\tthis.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );\\n\\t\\tthis.constant = ( constant !== undefined ) ? constant : 0;\\n\\n\\t}\\n\\n\\tObject.assign( Plane.prototype, {\\n\\n\\t\\tset: function ( normal, constant ) {\\n\\n\\t\\t\\tthis.normal.copy( normal );\\n\\t\\t\\tthis.constant = constant;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetComponents: function ( x, y, z, w ) {\\n\\n\\t\\t\\tthis.normal.set( x, y, z );\\n\\t\\t\\tthis.constant = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\\n\\n\\t\\t\\tthis.normal.copy( normal );\\n\\t\\t\\tthis.constant = - point.dot( this.normal );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromCoplanarPoints: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\t\\t\\tvar v2 = new Vector3();\\n\\n\\t\\t\\treturn function setFromCoplanarPoints( a, b, c ) {\\n\\n\\t\\t\\t\\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\\n\\n\\t\\t\\t\\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\\n\\n\\t\\t\\t\\tthis.setFromNormalAndCoplanarPoint( normal, a );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( plane ) {\\n\\n\\t\\t\\tthis.normal.copy( plane.normal );\\n\\t\\t\\tthis.constant = plane.constant;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tnormalize: function () {\\n\\n\\t\\t\\t// Note: will lead to a divide by zero if the plane is invalid.\\n\\n\\t\\t\\tvar inverseNormalLength = 1.0 / this.normal.length();\\n\\t\\t\\tthis.normal.multiplyScalar( inverseNormalLength );\\n\\t\\t\\tthis.constant *= inverseNormalLength;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tnegate: function () {\\n\\n\\t\\t\\tthis.constant *= - 1;\\n\\t\\t\\tthis.normal.negate();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToPoint: function ( point ) {\\n\\n\\t\\t\\treturn this.normal.dot( point ) + this.constant;\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToSphere: function ( sphere ) {\\n\\n\\t\\t\\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\\n\\n\\t\\t},\\n\\n\\t\\tprojectPoint: function ( point, optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\treturn result.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );\\n\\n\\t\\t},\\n\\n\\t\\tintersectLine: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function intersectLine( line, optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\t\\tvar direction = line.delta( v1 );\\n\\n\\t\\t\\t\\tvar denominator = this.normal.dot( direction );\\n\\n\\t\\t\\t\\tif ( denominator === 0 ) {\\n\\n\\t\\t\\t\\t\\t// line is coplanar, return origin\\n\\t\\t\\t\\t\\tif ( this.distanceToPoint( line.start ) === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\treturn result.copy( line.start );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Unsure if this is the correct method to handle this case.\\n\\t\\t\\t\\t\\treturn undefined;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\\n\\n\\t\\t\\t\\tif ( t < 0 || t > 1 ) {\\n\\n\\t\\t\\t\\t\\treturn undefined;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersectsLine: function ( line ) {\\n\\n\\t\\t\\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\\n\\n\\t\\t\\tvar startSign = this.distanceToPoint( line.start );\\n\\t\\t\\tvar endSign = this.distanceToPoint( line.end );\\n\\n\\t\\t\\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsBox: function ( box ) {\\n\\n\\t\\t\\treturn box.intersectsPlane( this );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsSphere: function ( sphere ) {\\n\\n\\t\\t\\treturn sphere.intersectsPlane( this );\\n\\n\\t\\t},\\n\\n\\t\\tcoplanarPoint: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix4: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\t\\t\\tvar m1 = new Matrix3();\\n\\n\\t\\t\\treturn function applyMatrix4( matrix, optionalNormalMatrix ) {\\n\\n\\t\\t\\t\\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\\n\\n\\t\\t\\t\\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\\n\\n\\t\\t\\t\\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\\n\\n\\t\\t\\t\\tthis.constant = - referencePoint.dot( normal );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslate: function ( offset ) {\\n\\n\\t\\t\\tthis.constant -= offset.dot( this.normal );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( plane ) {\\n\\n\\t\\t\\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Frustum( p0, p1, p2, p3, p4, p5 ) {\\n\\n\\t\\tthis.planes = [\\n\\n\\t\\t\\t( p0 !== undefined ) ? p0 : new Plane(),\\n\\t\\t\\t( p1 !== undefined ) ? p1 : new Plane(),\\n\\t\\t\\t( p2 !== undefined ) ? p2 : new Plane(),\\n\\t\\t\\t( p3 !== undefined ) ? p3 : new Plane(),\\n\\t\\t\\t( p4 !== undefined ) ? p4 : new Plane(),\\n\\t\\t\\t( p5 !== undefined ) ? p5 : new Plane()\\n\\n\\t\\t];\\n\\n\\t}\\n\\n\\tObject.assign( Frustum.prototype, {\\n\\n\\t\\tset: function ( p0, p1, p2, p3, p4, p5 ) {\\n\\n\\t\\t\\tvar planes = this.planes;\\n\\n\\t\\t\\tplanes[ 0 ].copy( p0 );\\n\\t\\t\\tplanes[ 1 ].copy( p1 );\\n\\t\\t\\tplanes[ 2 ].copy( p2 );\\n\\t\\t\\tplanes[ 3 ].copy( p3 );\\n\\t\\t\\tplanes[ 4 ].copy( p4 );\\n\\t\\t\\tplanes[ 5 ].copy( p5 );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( frustum ) {\\n\\n\\t\\t\\tvar planes = this.planes;\\n\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\tplanes[ i ].copy( frustum.planes[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromMatrix: function ( m ) {\\n\\n\\t\\t\\tvar planes = this.planes;\\n\\t\\t\\tvar me = m.elements;\\n\\t\\t\\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\\n\\t\\t\\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\\n\\t\\t\\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\\n\\t\\t\\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\\n\\n\\t\\t\\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\\n\\t\\t\\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\\n\\t\\t\\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\\n\\t\\t\\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\\n\\t\\t\\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\\n\\t\\t\\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tintersectsObject: function () {\\n\\n\\t\\t\\tvar sphere = new Sphere();\\n\\n\\t\\t\\treturn function intersectsObject( object ) {\\n\\n\\t\\t\\t\\tvar geometry = object.geometry;\\n\\n\\t\\t\\t\\tif ( geometry.boundingSphere === null )\\n\\t\\t\\t\\t\\tgeometry.computeBoundingSphere();\\n\\n\\t\\t\\t\\tsphere.copy( geometry.boundingSphere )\\n\\t\\t\\t\\t\\t.applyMatrix4( object.matrixWorld );\\n\\n\\t\\t\\t\\treturn this.intersectsSphere( sphere );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersectsSprite: function () {\\n\\n\\t\\t\\tvar sphere = new Sphere();\\n\\n\\t\\t\\treturn function intersectsSprite( sprite ) {\\n\\n\\t\\t\\t\\tsphere.center.set( 0, 0, 0 );\\n\\t\\t\\t\\tsphere.radius = 0.7071067811865476;\\n\\t\\t\\t\\tsphere.applyMatrix4( sprite.matrixWorld );\\n\\n\\t\\t\\t\\treturn this.intersectsSphere( sphere );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersectsSphere: function ( sphere ) {\\n\\n\\t\\t\\tvar planes = this.planes;\\n\\t\\t\\tvar center = sphere.center;\\n\\t\\t\\tvar negRadius = - sphere.radius;\\n\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\tvar distance = planes[ i ].distanceToPoint( center );\\n\\n\\t\\t\\t\\tif ( distance < negRadius ) {\\n\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\n\\t\\t},\\n\\n\\t\\tintersectsBox: function () {\\n\\n\\t\\t\\tvar p1 = new Vector3(),\\n\\t\\t\\t\\tp2 = new Vector3();\\n\\n\\t\\t\\treturn function intersectsBox( box ) {\\n\\n\\t\\t\\t\\tvar planes = this.planes;\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar plane = planes[ i ];\\n\\n\\t\\t\\t\\t\\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\\n\\t\\t\\t\\t\\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\\n\\t\\t\\t\\t\\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\\n\\t\\t\\t\\t\\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\\n\\t\\t\\t\\t\\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\\n\\t\\t\\t\\t\\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\\n\\n\\t\\t\\t\\t\\tvar d1 = plane.distanceToPoint( p1 );\\n\\t\\t\\t\\t\\tvar d2 = plane.distanceToPoint( p2 );\\n\\n\\t\\t\\t\\t\\t// if both outside plane, no intersection\\n\\n\\t\\t\\t\\t\\tif ( d1 < 0 && d2 < 0 ) {\\n\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tcontainsPoint: function ( point ) {\\n\\n\\t\\t\\tvar planes = this.planes;\\n\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\\n\\n\\t\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn true;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLShadowMap( _renderer, _objects, maxTextureSize ) {\\n\\n\\t\\tvar _frustum = new Frustum(),\\n\\t\\t\\t_projScreenMatrix = new Matrix4(),\\n\\n\\t\\t\\t_shadowMapSize = new Vector2(),\\n\\t\\t\\t_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),\\n\\n\\t\\t\\t_lookTarget = new Vector3(),\\n\\t\\t\\t_lightPositionWorld = new Vector3(),\\n\\n\\t\\t\\t_MorphingFlag = 1,\\n\\t\\t\\t_SkinningFlag = 2,\\n\\n\\t\\t\\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\\n\\n\\t\\t\\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\\n\\t\\t\\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\\n\\n\\t\\t\\t_materialCache = {};\\n\\n\\t\\tvar cubeDirections = [\\n\\t\\t\\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\\n\\t\\t\\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\\n\\t\\t];\\n\\n\\t\\tvar cubeUps = [\\n\\t\\t\\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\\n\\t\\t\\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\\tnew Vector3( 0, 0, - 1 )\\n\\t\\t];\\n\\n\\t\\tvar cube2DViewPorts = [\\n\\t\\t\\tnew Vector4(), new Vector4(), new Vector4(),\\n\\t\\t\\tnew Vector4(), new Vector4(), new Vector4()\\n\\t\\t];\\n\\n\\t\\t// init\\n\\n\\t\\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\\n\\n\\t\\t\\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\\n\\t\\t\\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\\n\\n\\t\\t\\tvar depthMaterial = new MeshDepthMaterial( {\\n\\n\\t\\t\\t\\tdepthPacking: RGBADepthPacking,\\n\\n\\t\\t\\t\\tmorphTargets: useMorphing,\\n\\t\\t\\t\\tskinning: useSkinning\\n\\n\\t\\t\\t} );\\n\\n\\t\\t\\t_depthMaterials[ i ] = depthMaterial;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar distanceMaterial = new MeshDistanceMaterial( {\\n\\n\\t\\t\\t\\tmorphTargets: useMorphing,\\n\\t\\t\\t\\tskinning: useSkinning\\n\\n\\t\\t\\t} );\\n\\n\\t\\t\\t_distanceMaterials[ i ] = distanceMaterial;\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tthis.enabled = false;\\n\\n\\t\\tthis.autoUpdate = true;\\n\\t\\tthis.needsUpdate = false;\\n\\n\\t\\tthis.type = PCFShadowMap;\\n\\n\\t\\tthis.renderReverseSided = true;\\n\\t\\tthis.renderSingleSided = true;\\n\\n\\t\\tthis.render = function ( lights, scene, camera ) {\\n\\n\\t\\t\\tif ( scope.enabled === false ) return;\\n\\t\\t\\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\\n\\n\\t\\t\\tif ( lights.length === 0 ) return;\\n\\n\\t\\t\\t// TODO Clean up (needed in case of contextlost)\\n\\t\\t\\tvar _gl = _renderer.context;\\n\\t\\t\\tvar _state = _renderer.state;\\n\\n\\t\\t\\t// Set GL state for depth map.\\n\\t\\t\\t_state.disable( _gl.BLEND );\\n\\t\\t\\t_state.buffers.color.setClear( 1, 1, 1, 1 );\\n\\t\\t\\t_state.buffers.depth.setTest( true );\\n\\t\\t\\t_state.setScissorTest( false );\\n\\n\\t\\t\\t// render depth map\\n\\n\\t\\t\\tvar faceCount;\\n\\n\\t\\t\\tfor ( var i = 0, il = lights.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar light = lights[ i ];\\n\\t\\t\\t\\tvar shadow = light.shadow;\\n\\t\\t\\t\\tvar isPointLight = light && light.isPointLight;\\n\\n\\t\\t\\t\\tif ( shadow === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar shadowCamera = shadow.camera;\\n\\n\\t\\t\\t\\t_shadowMapSize.copy( shadow.mapSize );\\n\\t\\t\\t\\t_shadowMapSize.min( _maxShadowMapSize );\\n\\n\\t\\t\\t\\tif ( isPointLight ) {\\n\\n\\t\\t\\t\\t\\tvar vpWidth = _shadowMapSize.x;\\n\\t\\t\\t\\t\\tvar vpHeight = _shadowMapSize.y;\\n\\n\\t\\t\\t\\t\\t// These viewports map a cube-map onto a 2D texture with the\\n\\t\\t\\t\\t\\t// following orientation:\\n\\t\\t\\t\\t\\t//\\n\\t\\t\\t\\t\\t//  xzXZ\\n\\t\\t\\t\\t\\t//   y Y\\n\\t\\t\\t\\t\\t//\\n\\t\\t\\t\\t\\t// X - Positive x direction\\n\\t\\t\\t\\t\\t// x - Negative x direction\\n\\t\\t\\t\\t\\t// Y - Positive y direction\\n\\t\\t\\t\\t\\t// y - Negative y direction\\n\\t\\t\\t\\t\\t// Z - Positive z direction\\n\\t\\t\\t\\t\\t// z - Negative z direction\\n\\n\\t\\t\\t\\t\\t// positive X\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\\n\\t\\t\\t\\t\\t// negative X\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\\n\\t\\t\\t\\t\\t// positive Z\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\\n\\t\\t\\t\\t\\t// negative Z\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\\n\\t\\t\\t\\t\\t// positive Y\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\\n\\t\\t\\t\\t\\t// negative Y\\n\\t\\t\\t\\t\\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\\n\\n\\t\\t\\t\\t\\t_shadowMapSize.x *= 4.0;\\n\\t\\t\\t\\t\\t_shadowMapSize.y *= 2.0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( shadow.map === null ) {\\n\\n\\t\\t\\t\\t\\tvar pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };\\n\\n\\t\\t\\t\\t\\tshadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\\n\\t\\t\\t\\t\\tshadow.map.texture.name = light.name + \\\".shadowMap\\\";\\n\\n\\t\\t\\t\\t\\tshadowCamera.updateProjectionMatrix();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( shadow.isSpotLightShadow ) {\\n\\n\\t\\t\\t\\t\\tshadow.update( light );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar shadowMap = shadow.map;\\n\\t\\t\\t\\tvar shadowMatrix = shadow.matrix;\\n\\n\\t\\t\\t\\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\tshadowCamera.position.copy( _lightPositionWorld );\\n\\n\\t\\t\\t\\tif ( isPointLight ) {\\n\\n\\t\\t\\t\\t\\tfaceCount = 6;\\n\\n\\t\\t\\t\\t\\t// for point lights we set the shadow matrix to be a translation-only matrix\\n\\t\\t\\t\\t\\t// equal to inverse of the light's position\\n\\n\\t\\t\\t\\t\\tshadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tfaceCount = 1;\\n\\n\\t\\t\\t\\t\\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\\n\\t\\t\\t\\t\\tshadowCamera.lookAt( _lookTarget );\\n\\t\\t\\t\\t\\tshadowCamera.updateMatrixWorld();\\n\\n\\t\\t\\t\\t\\t// compute shadow matrix\\n\\n\\t\\t\\t\\t\\tshadowMatrix.set(\\n\\t\\t\\t\\t\\t\\t0.5, 0.0, 0.0, 0.5,\\n\\t\\t\\t\\t\\t\\t0.0, 0.5, 0.0, 0.5,\\n\\t\\t\\t\\t\\t\\t0.0, 0.0, 0.5, 0.5,\\n\\t\\t\\t\\t\\t\\t0.0, 0.0, 0.0, 1.0\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\\n\\t\\t\\t\\t\\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t_renderer.setRenderTarget( shadowMap );\\n\\t\\t\\t\\t_renderer.clear();\\n\\n\\t\\t\\t\\t// render shadow map for each cube face (if omni-directional) or\\n\\t\\t\\t\\t// run a single pass if not\\n\\n\\t\\t\\t\\tfor ( var face = 0; face < faceCount; face ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( isPointLight ) {\\n\\n\\t\\t\\t\\t\\t\\t_lookTarget.copy( shadowCamera.position );\\n\\t\\t\\t\\t\\t\\t_lookTarget.add( cubeDirections[ face ] );\\n\\t\\t\\t\\t\\t\\tshadowCamera.up.copy( cubeUps[ face ] );\\n\\t\\t\\t\\t\\t\\tshadowCamera.lookAt( _lookTarget );\\n\\t\\t\\t\\t\\t\\tshadowCamera.updateMatrixWorld();\\n\\n\\t\\t\\t\\t\\t\\tvar vpDimensions = cube2DViewPorts[ face ];\\n\\t\\t\\t\\t\\t\\t_state.viewport( vpDimensions );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// update camera matrices and frustum\\n\\n\\t\\t\\t\\t\\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\\n\\t\\t\\t\\t\\t_frustum.setFromMatrix( _projScreenMatrix );\\n\\n\\t\\t\\t\\t\\t// set object matrices & frustum culling\\n\\n\\t\\t\\t\\t\\trenderObject( scene, camera, shadowCamera, isPointLight );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscope.needsUpdate = false;\\n\\n\\t\\t};\\n\\n\\t\\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {\\n\\n\\t\\t\\tvar geometry = object.geometry;\\n\\n\\t\\t\\tvar result = null;\\n\\n\\t\\t\\tvar materialVariants = _depthMaterials;\\n\\t\\t\\tvar customMaterial = object.customDepthMaterial;\\n\\n\\t\\t\\tif ( isPointLight ) {\\n\\n\\t\\t\\t\\tmaterialVariants = _distanceMaterials;\\n\\t\\t\\t\\tcustomMaterial = object.customDistanceMaterial;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ! customMaterial ) {\\n\\n\\t\\t\\t\\tvar useMorphing = false;\\n\\n\\t\\t\\t\\tif ( material.morphTargets ) {\\n\\n\\t\\t\\t\\t\\tif ( geometry && geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\t\\t\\tuseMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\\n\\n\\t\\t\\t\\t\\t} else if ( geometry && geometry.isGeometry ) {\\n\\n\\t\\t\\t\\t\\t\\tuseMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( object.isSkinnedMesh && material.skinning === false ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar useSkinning = object.isSkinnedMesh && material.skinning;\\n\\n\\t\\t\\t\\tvar variantIndex = 0;\\n\\n\\t\\t\\t\\tif ( useMorphing ) variantIndex |= _MorphingFlag;\\n\\t\\t\\t\\tif ( useSkinning ) variantIndex |= _SkinningFlag;\\n\\n\\t\\t\\t\\tresult = materialVariants[ variantIndex ];\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tresult = customMaterial;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( _renderer.localClippingEnabled &&\\n\\t\\t\\t\\t\\tmaterial.clipShadows === true &&\\n\\t\\t\\t\\t\\tmaterial.clippingPlanes.length !== 0 ) {\\n\\n\\t\\t\\t\\t// in this case we need a unique material instance reflecting the\\n\\t\\t\\t\\t// appropriate state\\n\\n\\t\\t\\t\\tvar keyA = result.uuid, keyB = material.uuid;\\n\\n\\t\\t\\t\\tvar materialsForVariant = _materialCache[ keyA ];\\n\\n\\t\\t\\t\\tif ( materialsForVariant === undefined ) {\\n\\n\\t\\t\\t\\t\\tmaterialsForVariant = {};\\n\\t\\t\\t\\t\\t_materialCache[ keyA ] = materialsForVariant;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar cachedMaterial = materialsForVariant[ keyB ];\\n\\n\\t\\t\\t\\tif ( cachedMaterial === undefined ) {\\n\\n\\t\\t\\t\\t\\tcachedMaterial = result.clone();\\n\\t\\t\\t\\t\\tmaterialsForVariant[ keyB ] = cachedMaterial;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tresult = cachedMaterial;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult.visible = material.visible;\\n\\t\\t\\tresult.wireframe = material.wireframe;\\n\\n\\t\\t\\tvar side = material.side;\\n\\n\\t\\t\\tif ( scope.renderSingleSided && side == DoubleSide ) {\\n\\n\\t\\t\\t\\tside = FrontSide;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( scope.renderReverseSided ) {\\n\\n\\t\\t\\t\\tif ( side === FrontSide ) side = BackSide;\\n\\t\\t\\t\\telse if ( side === BackSide ) side = FrontSide;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult.side = side;\\n\\n\\t\\t\\tresult.clipShadows = material.clipShadows;\\n\\t\\t\\tresult.clippingPlanes = material.clippingPlanes;\\n\\t\\t\\tresult.clipIntersection = material.clipIntersection;\\n\\n\\t\\t\\tresult.wireframeLinewidth = material.wireframeLinewidth;\\n\\t\\t\\tresult.linewidth = material.linewidth;\\n\\n\\t\\t\\tif ( isPointLight && result.isMeshDistanceMaterial ) {\\n\\n\\t\\t\\t\\tresult.referencePosition.copy( lightPositionWorld );\\n\\t\\t\\t\\tresult.nearDistance = shadowCameraNear;\\n\\t\\t\\t\\tresult.farDistance = shadowCameraFar;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t}\\n\\n\\t\\tfunction renderObject( object, camera, shadowCamera, isPointLight ) {\\n\\n\\t\\t\\tif ( object.visible === false ) return;\\n\\n\\t\\t\\tvar visible = object.layers.test( camera.layers );\\n\\n\\t\\t\\tif ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {\\n\\n\\t\\t\\t\\tif ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {\\n\\n\\t\\t\\t\\t\\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\\n\\n\\t\\t\\t\\t\\tvar geometry = _objects.update( object );\\n\\t\\t\\t\\t\\tvar material = object.material;\\n\\n\\t\\t\\t\\t\\tif ( Array.isArray( material ) ) {\\n\\n\\t\\t\\t\\t\\t\\tvar groups = geometry.groups;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar group = groups[ k ];\\n\\t\\t\\t\\t\\t\\t\\tvar groupMaterial = material[ group.materialIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( groupMaterial && groupMaterial.visible ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );\\n\\t\\t\\t\\t\\t\\t\\t\\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else if ( material.visible ) {\\n\\n\\t\\t\\t\\t\\t\\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );\\n\\t\\t\\t\\t\\t\\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar children = object.children;\\n\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\trenderObject( children[ i ], camera, shadowCamera, isPointLight );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLAttributes( gl ) {\\n\\n\\t\\tvar buffers = {};\\n\\n\\t\\tfunction createBuffer( attribute, bufferType ) {\\n\\n\\t\\t\\tvar array = attribute.array;\\n\\t\\t\\tvar usage = attribute.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\\n\\n\\t\\t\\tvar buffer = gl.createBuffer();\\n\\n\\t\\t\\tgl.bindBuffer( bufferType, buffer );\\n\\t\\t\\tgl.bufferData( bufferType, array, usage );\\n\\n\\t\\t\\tattribute.onUploadCallback();\\n\\n\\t\\t\\tvar type = gl.FLOAT;\\n\\n\\t\\t\\tif ( array instanceof Float32Array ) {\\n\\n\\t\\t\\t\\ttype = gl.FLOAT;\\n\\n\\t\\t\\t} else if ( array instanceof Float64Array ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );\\n\\n\\t\\t\\t} else if ( array instanceof Uint16Array ) {\\n\\n\\t\\t\\t\\ttype = gl.UNSIGNED_SHORT;\\n\\n\\t\\t\\t} else if ( array instanceof Int16Array ) {\\n\\n\\t\\t\\t\\ttype = gl.SHORT;\\n\\n\\t\\t\\t} else if ( array instanceof Uint32Array ) {\\n\\n\\t\\t\\t\\ttype = gl.UNSIGNED_INT;\\n\\n\\t\\t\\t} else if ( array instanceof Int32Array ) {\\n\\n\\t\\t\\t\\ttype = gl.INT;\\n\\n\\t\\t\\t} else if ( array instanceof Int8Array ) {\\n\\n\\t\\t\\t\\ttype = gl.BYTE;\\n\\n\\t\\t\\t} else if ( array instanceof Uint8Array ) {\\n\\n\\t\\t\\t\\ttype = gl.UNSIGNED_BYTE;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tbuffer: buffer,\\n\\t\\t\\t\\ttype: type,\\n\\t\\t\\t\\tbytesPerElement: array.BYTES_PER_ELEMENT,\\n\\t\\t\\t\\tversion: attribute.version\\n\\t\\t\\t};\\n\\n\\t\\t}\\n\\n\\t\\tfunction updateBuffer( buffer, attribute, bufferType ) {\\n\\n\\t\\t\\tvar array = attribute.array;\\n\\t\\t\\tvar updateRange = attribute.updateRange;\\n\\n\\t\\t\\tgl.bindBuffer( bufferType, buffer );\\n\\n\\t\\t\\tif ( attribute.dynamic === false ) {\\n\\n\\t\\t\\t\\tgl.bufferData( bufferType, array, gl.STATIC_DRAW );\\n\\n\\t\\t\\t} else if ( updateRange.count === - 1 ) {\\n\\n\\t\\t\\t\\t// Not using update ranges\\n\\n\\t\\t\\t\\tgl.bufferSubData( bufferType, 0, array );\\n\\n\\t\\t\\t} else if ( updateRange.count === 0 ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tgl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,\\n\\t\\t\\t\\t\\tarray.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );\\n\\n\\t\\t\\t\\tupdateRange.count = - 1; // reset range\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction get( attribute ) {\\n\\n\\t\\t\\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\\n\\n\\t\\t\\treturn buffers[ attribute.uuid ];\\n\\n\\t\\t}\\n\\n\\t\\tfunction remove( attribute ) {\\n\\n\\t\\t\\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\\n\\n\\t\\t\\tvar data = buffers[ attribute.uuid ];\\n\\n\\t\\t\\tif ( data ) {\\n\\n\\t\\t\\t\\tgl.deleteBuffer( data.buffer );\\n\\n\\t\\t\\t\\tdelete buffers[ attribute.uuid ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction update( attribute, bufferType ) {\\n\\n\\t\\t\\tif ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;\\n\\n\\t\\t\\tvar data = buffers[ attribute.uuid ];\\n\\n\\t\\t\\tif ( data === undefined ) {\\n\\n\\t\\t\\t\\tbuffers[ attribute.uuid ] = createBuffer( attribute, bufferType );\\n\\n\\t\\t\\t} else if ( data.version < attribute.version ) {\\n\\n\\t\\t\\t\\tupdateBuffer( data.buffer, attribute, bufferType );\\n\\n\\t\\t\\t\\tdata.version = attribute.version;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tget: get,\\n\\t\\t\\tremove: remove,\\n\\t\\t\\tupdate: update\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Euler( x, y, z, order ) {\\n\\n\\t\\tthis._x = x || 0;\\n\\t\\tthis._y = y || 0;\\n\\t\\tthis._z = z || 0;\\n\\t\\tthis._order = order || Euler.DefaultOrder;\\n\\n\\t}\\n\\n\\tEuler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\\n\\n\\tEuler.DefaultOrder = 'XYZ';\\n\\n\\tObject.defineProperties( Euler.prototype, {\\n\\n\\t\\tx: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._x;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._x = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ty: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._y;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._y = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tz: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._z;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._z = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\torder: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this._order;\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tthis._order = value;\\n\\t\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Euler.prototype, {\\n\\n\\t\\tisEuler: true,\\n\\n\\t\\tset: function ( x, y, z, order ) {\\n\\n\\t\\t\\tthis._x = x;\\n\\t\\t\\tthis._y = y;\\n\\t\\t\\tthis._z = z;\\n\\t\\t\\tthis._order = order || this._order;\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this._x, this._y, this._z, this._order );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( euler ) {\\n\\n\\t\\t\\tthis._x = euler._x;\\n\\t\\t\\tthis._y = euler._y;\\n\\t\\t\\tthis._z = euler._z;\\n\\t\\t\\tthis._order = euler._order;\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromRotationMatrix: function ( m, order, update ) {\\n\\n\\t\\t\\tvar clamp = _Math.clamp;\\n\\n\\t\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\n\\n\\t\\t\\tvar te = m.elements;\\n\\t\\t\\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\\n\\t\\t\\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\\n\\t\\t\\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\\n\\n\\t\\t\\torder = order || this._order;\\n\\n\\t\\t\\tif ( order === 'XYZ' ) {\\n\\n\\t\\t\\t\\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\\n\\n\\t\\t\\t\\tif ( Math.abs( m13 ) < 0.99999 ) {\\n\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( - m23, m33 );\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( - m12, m11 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( m32, m22 );\\n\\t\\t\\t\\t\\tthis._z = 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( order === 'YXZ' ) {\\n\\n\\t\\t\\t\\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\\n\\n\\t\\t\\t\\tif ( Math.abs( m23 ) < 0.99999 ) {\\n\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( m13, m33 );\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( m21, m22 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( - m31, m11 );\\n\\t\\t\\t\\t\\tthis._z = 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( order === 'ZXY' ) {\\n\\n\\t\\t\\t\\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\\n\\n\\t\\t\\t\\tif ( Math.abs( m32 ) < 0.99999 ) {\\n\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( - m31, m33 );\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( - m12, m22 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis._y = 0;\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( m21, m11 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( order === 'ZYX' ) {\\n\\n\\t\\t\\t\\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\\n\\n\\t\\t\\t\\tif ( Math.abs( m31 ) < 0.99999 ) {\\n\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( m32, m33 );\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( m21, m11 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis._x = 0;\\n\\t\\t\\t\\t\\tthis._z = Math.atan2( - m12, m22 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( order === 'YZX' ) {\\n\\n\\t\\t\\t\\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\\n\\n\\t\\t\\t\\tif ( Math.abs( m21 ) < 0.99999 ) {\\n\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( - m23, m22 );\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( - m31, m11 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis._x = 0;\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( m13, m33 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( order === 'XZY' ) {\\n\\n\\t\\t\\t\\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\\n\\n\\t\\t\\t\\tif ( Math.abs( m12 ) < 0.99999 ) {\\n\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( m32, m22 );\\n\\t\\t\\t\\t\\tthis._y = Math.atan2( m13, m11 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis._x = Math.atan2( - m23, m33 );\\n\\t\\t\\t\\t\\tthis._y = 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._order = order;\\n\\n\\t\\t\\tif ( update !== false ) this.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromQuaternion: function () {\\n\\n\\t\\t\\tvar matrix = new Matrix4();\\n\\n\\t\\t\\treturn function setFromQuaternion( q, order, update ) {\\n\\n\\t\\t\\t\\tmatrix.makeRotationFromQuaternion( q );\\n\\n\\t\\t\\t\\treturn this.setFromRotationMatrix( matrix, order, update );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tsetFromVector3: function ( v, order ) {\\n\\n\\t\\t\\treturn this.set( v.x, v.y, v.z, order || this._order );\\n\\n\\t\\t},\\n\\n\\t\\treorder: function () {\\n\\n\\t\\t\\t// WARNING: this discards revolution information -bhouston\\n\\n\\t\\t\\tvar q = new Quaternion();\\n\\n\\t\\t\\treturn function reorder( newOrder ) {\\n\\n\\t\\t\\t\\tq.setFromEuler( this );\\n\\n\\t\\t\\t\\treturn this.setFromQuaternion( q, newOrder );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tequals: function ( euler ) {\\n\\n\\t\\t\\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\\n\\n\\t\\t},\\n\\n\\t\\tfromArray: function ( array ) {\\n\\n\\t\\t\\tthis._x = array[ 0 ];\\n\\t\\t\\tthis._y = array[ 1 ];\\n\\t\\t\\tthis._z = array[ 2 ];\\n\\t\\t\\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\\n\\n\\t\\t\\tthis.onChangeCallback();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoArray: function ( array, offset ) {\\n\\n\\t\\t\\tif ( array === undefined ) array = [];\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tarray[ offset ] = this._x;\\n\\t\\t\\tarray[ offset + 1 ] = this._y;\\n\\t\\t\\tarray[ offset + 2 ] = this._z;\\n\\t\\t\\tarray[ offset + 3 ] = this._order;\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\ttoVector3: function ( optionalResult ) {\\n\\n\\t\\t\\tif ( optionalResult ) {\\n\\n\\t\\t\\t\\treturn optionalResult.set( this._x, this._y, this._z );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\treturn new Vector3( this._x, this._y, this._z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tonChange: function ( callback ) {\\n\\n\\t\\t\\tthis.onChangeCallback = callback;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tonChangeCallback: function () {}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Layers() {\\n\\n\\t\\tthis.mask = 1 | 0;\\n\\n\\t}\\n\\n\\tObject.assign( Layers.prototype, {\\n\\n\\t\\tset: function ( channel ) {\\n\\n\\t\\t\\tthis.mask = 1 << channel | 0;\\n\\n\\t\\t},\\n\\n\\t\\tenable: function ( channel ) {\\n\\n\\t\\t\\tthis.mask |= 1 << channel | 0;\\n\\n\\t\\t},\\n\\n\\t\\ttoggle: function ( channel ) {\\n\\n\\t\\t\\tthis.mask ^= 1 << channel | 0;\\n\\n\\t\\t},\\n\\n\\t\\tdisable: function ( channel ) {\\n\\n\\t\\t\\tthis.mask &= ~ ( 1 << channel | 0 );\\n\\n\\t\\t},\\n\\n\\t\\ttest: function ( layers ) {\\n\\n\\t\\t\\treturn ( this.mask & layers.mask ) !== 0;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author elephantatwork / www.elephantatwork.ch\\n\\t */\\n\\n\\tvar object3DId = 0;\\n\\n\\tfunction Object3D() {\\n\\n\\t\\tObject.defineProperty( this, 'id', { value: object3DId ++ } );\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.name = '';\\n\\t\\tthis.type = 'Object3D';\\n\\n\\t\\tthis.parent = null;\\n\\t\\tthis.children = [];\\n\\n\\t\\tthis.up = Object3D.DefaultUp.clone();\\n\\n\\t\\tvar position = new Vector3();\\n\\t\\tvar rotation = new Euler();\\n\\t\\tvar quaternion = new Quaternion();\\n\\t\\tvar scale = new Vector3( 1, 1, 1 );\\n\\n\\t\\tfunction onRotationChange() {\\n\\n\\t\\t\\tquaternion.setFromEuler( rotation, false );\\n\\n\\t\\t}\\n\\n\\t\\tfunction onQuaternionChange() {\\n\\n\\t\\t\\trotation.setFromQuaternion( quaternion, undefined, false );\\n\\n\\t\\t}\\n\\n\\t\\trotation.onChange( onRotationChange );\\n\\t\\tquaternion.onChange( onQuaternionChange );\\n\\n\\t\\tObject.defineProperties( this, {\\n\\t\\t\\tposition: {\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\tvalue: position\\n\\t\\t\\t},\\n\\t\\t\\trotation: {\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\tvalue: rotation\\n\\t\\t\\t},\\n\\t\\t\\tquaternion: {\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\tvalue: quaternion\\n\\t\\t\\t},\\n\\t\\t\\tscale: {\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\tvalue: scale\\n\\t\\t\\t},\\n\\t\\t\\tmodelViewMatrix: {\\n\\t\\t\\t\\tvalue: new Matrix4()\\n\\t\\t\\t},\\n\\t\\t\\tnormalMatrix: {\\n\\t\\t\\t\\tvalue: new Matrix3()\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t\\tthis.matrix = new Matrix4();\\n\\t\\tthis.matrixWorld = new Matrix4();\\n\\n\\t\\tthis.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\\n\\t\\tthis.matrixWorldNeedsUpdate = false;\\n\\n\\t\\tthis.layers = new Layers();\\n\\t\\tthis.visible = true;\\n\\n\\t\\tthis.castShadow = false;\\n\\t\\tthis.receiveShadow = false;\\n\\n\\t\\tthis.frustumCulled = true;\\n\\t\\tthis.renderOrder = 0;\\n\\n\\t\\tthis.userData = {};\\n\\n\\t}\\n\\n\\tObject3D.DefaultUp = new Vector3( 0, 1, 0 );\\n\\tObject3D.DefaultMatrixAutoUpdate = true;\\n\\n\\tObject3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: Object3D,\\n\\n\\t\\tisObject3D: true,\\n\\n\\t\\tonBeforeRender: function () {},\\n\\t\\tonAfterRender: function () {},\\n\\n\\t\\tapplyMatrix: function ( matrix ) {\\n\\n\\t\\t\\tthis.matrix.multiplyMatrices( matrix, this.matrix );\\n\\n\\t\\t\\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\\n\\n\\t\\t},\\n\\n\\t\\tapplyQuaternion: function ( q ) {\\n\\n\\t\\t\\tthis.quaternion.premultiply( q );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetRotationFromAxisAngle: function ( axis, angle ) {\\n\\n\\t\\t\\t// assumes axis is normalized\\n\\n\\t\\t\\tthis.quaternion.setFromAxisAngle( axis, angle );\\n\\n\\t\\t},\\n\\n\\t\\tsetRotationFromEuler: function ( euler ) {\\n\\n\\t\\t\\tthis.quaternion.setFromEuler( euler, true );\\n\\n\\t\\t},\\n\\n\\t\\tsetRotationFromMatrix: function ( m ) {\\n\\n\\t\\t\\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\\n\\n\\t\\t\\tthis.quaternion.setFromRotationMatrix( m );\\n\\n\\t\\t},\\n\\n\\t\\tsetRotationFromQuaternion: function ( q ) {\\n\\n\\t\\t\\t// assumes q is normalized\\n\\n\\t\\t\\tthis.quaternion.copy( q );\\n\\n\\t\\t},\\n\\n\\t\\trotateOnAxis: function () {\\n\\n\\t\\t\\t// rotate object on axis in object space\\n\\t\\t\\t// axis is assumed to be normalized\\n\\n\\t\\t\\tvar q1 = new Quaternion();\\n\\n\\t\\t\\treturn function rotateOnAxis( axis, angle ) {\\n\\n\\t\\t\\t\\tq1.setFromAxisAngle( axis, angle );\\n\\n\\t\\t\\t\\tthis.quaternion.multiply( q1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateOnWorldAxis: function () {\\n\\n\\t\\t\\t// rotate object on axis in world space\\n\\t\\t\\t// axis is assumed to be normalized\\n\\t\\t\\t// method assumes no rotated parent\\n\\n\\t\\t\\tvar q1 = new Quaternion();\\n\\n\\t\\t\\treturn function rotateOnWorldAxis( axis, angle ) {\\n\\n\\t\\t\\t\\tq1.setFromAxisAngle( axis, angle );\\n\\n\\t\\t\\t\\tthis.quaternion.premultiply( q1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateX: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3( 1, 0, 0 );\\n\\n\\t\\t\\treturn function rotateX( angle ) {\\n\\n\\t\\t\\t\\treturn this.rotateOnAxis( v1, angle );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateY: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3( 0, 1, 0 );\\n\\n\\t\\t\\treturn function rotateY( angle ) {\\n\\n\\t\\t\\t\\treturn this.rotateOnAxis( v1, angle );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateZ: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3( 0, 0, 1 );\\n\\n\\t\\t\\treturn function rotateZ( angle ) {\\n\\n\\t\\t\\t\\treturn this.rotateOnAxis( v1, angle );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslateOnAxis: function () {\\n\\n\\t\\t\\t// translate object by distance along axis in object space\\n\\t\\t\\t// axis is assumed to be normalized\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function translateOnAxis( axis, distance ) {\\n\\n\\t\\t\\t\\tv1.copy( axis ).applyQuaternion( this.quaternion );\\n\\n\\t\\t\\t\\tthis.position.add( v1.multiplyScalar( distance ) );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslateX: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3( 1, 0, 0 );\\n\\n\\t\\t\\treturn function translateX( distance ) {\\n\\n\\t\\t\\t\\treturn this.translateOnAxis( v1, distance );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslateY: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3( 0, 1, 0 );\\n\\n\\t\\t\\treturn function translateY( distance ) {\\n\\n\\t\\t\\t\\treturn this.translateOnAxis( v1, distance );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslateZ: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3( 0, 0, 1 );\\n\\n\\t\\t\\treturn function translateZ( distance ) {\\n\\n\\t\\t\\t\\treturn this.translateOnAxis( v1, distance );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tlocalToWorld: function ( vector ) {\\n\\n\\t\\t\\treturn vector.applyMatrix4( this.matrixWorld );\\n\\n\\t\\t},\\n\\n\\t\\tworldToLocal: function () {\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function worldToLocal( vector ) {\\n\\n\\t\\t\\t\\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tlookAt: function () {\\n\\n\\t\\t\\t// This method does not support objects with rotated and/or translated parent(s)\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\t\\t\\tvar vector = new Vector3();\\n\\n\\t\\t\\treturn function lookAt( x, y, z ) {\\n\\n\\t\\t\\t\\tif ( x.isVector3 ) {\\n\\n\\t\\t\\t\\t\\tvector.copy( x );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvector.set( x, y, z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( this.isCamera ) {\\n\\n\\t\\t\\t\\t\\tm1.lookAt( this.position, vector, this.up );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tm1.lookAt( vector, this.position, this.up );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.quaternion.setFromRotationMatrix( m1 );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tadd: function ( object ) {\\n\\n\\t\\t\\tif ( arguments.length > 1 ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < arguments.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tthis.add( arguments[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( object === this ) {\\n\\n\\t\\t\\t\\tconsole.error( \\\"THREE.Object3D.add: object can't be added as a child of itself.\\\", object );\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ( object && object.isObject3D ) ) {\\n\\n\\t\\t\\t\\tif ( object.parent !== null ) {\\n\\n\\t\\t\\t\\t\\tobject.parent.remove( object );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tobject.parent = this;\\n\\t\\t\\t\\tobject.dispatchEvent( { type: 'added' } );\\n\\n\\t\\t\\t\\tthis.children.push( object );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tconsole.error( \\\"THREE.Object3D.add: object not an instance of THREE.Object3D.\\\", object );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tremove: function ( object ) {\\n\\n\\t\\t\\tif ( arguments.length > 1 ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < arguments.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tthis.remove( arguments[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar index = this.children.indexOf( object );\\n\\n\\t\\t\\tif ( index !== - 1 ) {\\n\\n\\t\\t\\t\\tobject.parent = null;\\n\\n\\t\\t\\t\\tobject.dispatchEvent( { type: 'removed' } );\\n\\n\\t\\t\\t\\tthis.children.splice( index, 1 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetObjectById: function ( id ) {\\n\\n\\t\\t\\treturn this.getObjectByProperty( 'id', id );\\n\\n\\t\\t},\\n\\n\\t\\tgetObjectByName: function ( name ) {\\n\\n\\t\\t\\treturn this.getObjectByProperty( 'name', name );\\n\\n\\t\\t},\\n\\n\\t\\tgetObjectByProperty: function ( name, value ) {\\n\\n\\t\\t\\tif ( this[ name ] === value ) return this;\\n\\n\\t\\t\\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar child = this.children[ i ];\\n\\t\\t\\t\\tvar object = child.getObjectByProperty( name, value );\\n\\n\\t\\t\\t\\tif ( object !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn object;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn undefined;\\n\\n\\t\\t},\\n\\n\\t\\tgetWorldPosition: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\tthis.updateMatrixWorld( true );\\n\\n\\t\\t\\treturn result.setFromMatrixPosition( this.matrixWorld );\\n\\n\\t\\t},\\n\\n\\t\\tgetWorldQuaternion: function () {\\n\\n\\t\\t\\tvar position = new Vector3();\\n\\t\\t\\tvar scale = new Vector3();\\n\\n\\t\\t\\treturn function getWorldQuaternion( optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Quaternion();\\n\\n\\t\\t\\t\\tthis.updateMatrixWorld( true );\\n\\n\\t\\t\\t\\tthis.matrixWorld.decompose( position, result, scale );\\n\\n\\t\\t\\t\\treturn result;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tgetWorldRotation: function () {\\n\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\n\\t\\t\\treturn function getWorldRotation( optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Euler();\\n\\n\\t\\t\\t\\tthis.getWorldQuaternion( quaternion );\\n\\n\\t\\t\\t\\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tgetWorldScale: function () {\\n\\n\\t\\t\\tvar position = new Vector3();\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\n\\t\\t\\treturn function getWorldScale( optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\t\\tthis.updateMatrixWorld( true );\\n\\n\\t\\t\\t\\tthis.matrixWorld.decompose( position, quaternion, result );\\n\\n\\t\\t\\t\\treturn result;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tgetWorldDirection: function () {\\n\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\n\\t\\t\\treturn function getWorldDirection( optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\t\\tthis.getWorldQuaternion( quaternion );\\n\\n\\t\\t\\t\\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\traycast: function () {},\\n\\n\\t\\ttraverse: function ( callback ) {\\n\\n\\t\\t\\tcallback( this );\\n\\n\\t\\t\\tvar children = this.children;\\n\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tchildren[ i ].traverse( callback );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ttraverseVisible: function ( callback ) {\\n\\n\\t\\t\\tif ( this.visible === false ) return;\\n\\n\\t\\t\\tcallback( this );\\n\\n\\t\\t\\tvar children = this.children;\\n\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tchildren[ i ].traverseVisible( callback );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ttraverseAncestors: function ( callback ) {\\n\\n\\t\\t\\tvar parent = this.parent;\\n\\n\\t\\t\\tif ( parent !== null ) {\\n\\n\\t\\t\\t\\tcallback( parent );\\n\\n\\t\\t\\t\\tparent.traverseAncestors( callback );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tupdateMatrix: function () {\\n\\n\\t\\t\\tthis.matrix.compose( this.position, this.quaternion, this.scale );\\n\\n\\t\\t\\tthis.matrixWorldNeedsUpdate = true;\\n\\n\\t\\t},\\n\\n\\t\\tupdateMatrixWorld: function ( force ) {\\n\\n\\t\\t\\tif ( this.matrixAutoUpdate ) this.updateMatrix();\\n\\n\\t\\t\\tif ( this.matrixWorldNeedsUpdate || force ) {\\n\\n\\t\\t\\t\\tif ( this.parent === null ) {\\n\\n\\t\\t\\t\\t\\tthis.matrixWorld.copy( this.matrix );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.matrixWorldNeedsUpdate = false;\\n\\n\\t\\t\\t\\tforce = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// update children\\n\\n\\t\\t\\tvar children = this.children;\\n\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tchildren[ i ].updateMatrixWorld( force );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\t// meta is a string when called from JSON.stringify\\n\\t\\t\\tvar isRootObject = ( meta === undefined || typeof meta === 'string' );\\n\\n\\t\\t\\tvar output = {};\\n\\n\\t\\t\\t// meta is a hash used to collect geometries, materials.\\n\\t\\t\\t// not providing it implies that this is the root object\\n\\t\\t\\t// being serialized.\\n\\t\\t\\tif ( isRootObject ) {\\n\\n\\t\\t\\t\\t// initialize meta obj\\n\\t\\t\\t\\tmeta = {\\n\\t\\t\\t\\t\\tgeometries: {},\\n\\t\\t\\t\\t\\tmaterials: {},\\n\\t\\t\\t\\t\\ttextures: {},\\n\\t\\t\\t\\t\\timages: {},\\n\\t\\t\\t\\t\\tshapes: {}\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\toutput.metadata = {\\n\\t\\t\\t\\t\\tversion: 4.5,\\n\\t\\t\\t\\t\\ttype: 'Object',\\n\\t\\t\\t\\t\\tgenerator: 'Object3D.toJSON'\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// standard Object3D serialization\\n\\n\\t\\t\\tvar object = {};\\n\\n\\t\\t\\tobject.uuid = this.uuid;\\n\\t\\t\\tobject.type = this.type;\\n\\n\\t\\t\\tif ( this.name !== '' ) object.name = this.name;\\n\\t\\t\\tif ( this.castShadow === true ) object.castShadow = true;\\n\\t\\t\\tif ( this.receiveShadow === true ) object.receiveShadow = true;\\n\\t\\t\\tif ( this.visible === false ) object.visible = false;\\n\\t\\t\\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\\n\\n\\t\\t\\tobject.matrix = this.matrix.toArray();\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tfunction serialize( library, element ) {\\n\\n\\t\\t\\t\\tif ( library[ element.uuid ] === undefined ) {\\n\\n\\t\\t\\t\\t\\tlibrary[ element.uuid ] = element.toJSON( meta );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn element.uuid;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.geometry !== undefined ) {\\n\\n\\t\\t\\t\\tobject.geometry = serialize( meta.geometries, this.geometry );\\n\\n\\t\\t\\t\\tvar parameters = this.geometry.parameters;\\n\\n\\t\\t\\t\\tif ( parameters !== undefined && parameters.shapes !== undefined ) {\\n\\n\\t\\t\\t\\t\\tvar shapes = parameters.shapes;\\n\\n\\t\\t\\t\\t\\tif ( Array.isArray( shapes ) ) {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar shape = shapes[ i ];\\n\\n\\t\\t\\t\\t\\t\\t\\tserialize( meta.shapes, shape );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tserialize( meta.shapes, shapes );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.material !== undefined ) {\\n\\n\\t\\t\\t\\tif ( Array.isArray( this.material ) ) {\\n\\n\\t\\t\\t\\t\\tvar uuids = [];\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = this.material.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tuuids.push( serialize( meta.materials, this.material[ i ] ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tobject.material = uuids;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tobject.material = serialize( meta.materials, this.material );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tif ( this.children.length > 0 ) {\\n\\n\\t\\t\\t\\tobject.children = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < this.children.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tobject.children.push( this.children[ i ].toJSON( meta ).object );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( isRootObject ) {\\n\\n\\t\\t\\t\\tvar geometries = extractFromCache( meta.geometries );\\n\\t\\t\\t\\tvar materials = extractFromCache( meta.materials );\\n\\t\\t\\t\\tvar textures = extractFromCache( meta.textures );\\n\\t\\t\\t\\tvar images = extractFromCache( meta.images );\\n\\t\\t\\t\\tvar shapes = extractFromCache( meta.shapes );\\n\\n\\t\\t\\t\\tif ( geometries.length > 0 ) output.geometries = geometries;\\n\\t\\t\\t\\tif ( materials.length > 0 ) output.materials = materials;\\n\\t\\t\\t\\tif ( textures.length > 0 ) output.textures = textures;\\n\\t\\t\\t\\tif ( images.length > 0 ) output.images = images;\\n\\t\\t\\t\\tif ( shapes.length > 0 ) output.shapes = shapes;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\toutput.object = object;\\n\\n\\t\\t\\treturn output;\\n\\n\\t\\t\\t// extract data from the cache hash\\n\\t\\t\\t// remove metadata on each item\\n\\t\\t\\t// and return as array\\n\\t\\t\\tfunction extractFromCache( cache ) {\\n\\n\\t\\t\\t\\tvar values = [];\\n\\t\\t\\t\\tfor ( var key in cache ) {\\n\\n\\t\\t\\t\\t\\tvar data = cache[ key ];\\n\\t\\t\\t\\t\\tdelete data.metadata;\\n\\t\\t\\t\\t\\tvalues.push( data );\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn values;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tclone: function ( recursive ) {\\n\\n\\t\\t\\treturn new this.constructor().copy( this, recursive );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source, recursive ) {\\n\\n\\t\\t\\tif ( recursive === undefined ) recursive = true;\\n\\n\\t\\t\\tthis.name = source.name;\\n\\n\\t\\t\\tthis.up.copy( source.up );\\n\\n\\t\\t\\tthis.position.copy( source.position );\\n\\t\\t\\tthis.quaternion.copy( source.quaternion );\\n\\t\\t\\tthis.scale.copy( source.scale );\\n\\n\\t\\t\\tthis.matrix.copy( source.matrix );\\n\\t\\t\\tthis.matrixWorld.copy( source.matrixWorld );\\n\\n\\t\\t\\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\\n\\t\\t\\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\\n\\n\\t\\t\\tthis.layers.mask = source.layers.mask;\\n\\t\\t\\tthis.visible = source.visible;\\n\\n\\t\\t\\tthis.castShadow = source.castShadow;\\n\\t\\t\\tthis.receiveShadow = source.receiveShadow;\\n\\n\\t\\t\\tthis.frustumCulled = source.frustumCulled;\\n\\t\\t\\tthis.renderOrder = source.renderOrder;\\n\\n\\t\\t\\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\\n\\n\\t\\t\\tif ( recursive === true ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < source.children.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar child = source.children[ i ];\\n\\t\\t\\t\\t\\tthis.add( child.clone() );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t*/\\n\\n\\tfunction Camera() {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Camera';\\n\\n\\t\\tthis.matrixWorldInverse = new Matrix4();\\n\\t\\tthis.projectionMatrix = new Matrix4();\\n\\n\\t}\\n\\n\\tCamera.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Camera,\\n\\n\\t\\tisCamera: true,\\n\\n\\t\\tcopy: function ( source, recursive ) {\\n\\n\\t\\t\\tObject3D.prototype.copy.call( this, source, recursive );\\n\\n\\t\\t\\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\\n\\t\\t\\tthis.projectionMatrix.copy( source.projectionMatrix );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetWorldDirection: function () {\\n\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\n\\t\\t\\treturn function getWorldDirection( optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\t\\tthis.getWorldQuaternion( quaternion );\\n\\n\\t\\t\\t\\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tupdateMatrixWorld: function ( force ) {\\n\\n\\t\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t\\t\\tthis.matrixWorldInverse.getInverse( this.matrixWorld );\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author arose / http://github.com/arose\\n\\t */\\n\\n\\tfunction OrthographicCamera( left, right, top, bottom, near, far ) {\\n\\n\\t\\tCamera.call( this );\\n\\n\\t\\tthis.type = 'OrthographicCamera';\\n\\n\\t\\tthis.zoom = 1;\\n\\t\\tthis.view = null;\\n\\n\\t\\tthis.left = left;\\n\\t\\tthis.right = right;\\n\\t\\tthis.top = top;\\n\\t\\tthis.bottom = bottom;\\n\\n\\t\\tthis.near = ( near !== undefined ) ? near : 0.1;\\n\\t\\tthis.far = ( far !== undefined ) ? far : 2000;\\n\\n\\t\\tthis.updateProjectionMatrix();\\n\\n\\t}\\n\\n\\tOrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\\n\\n\\t\\tconstructor: OrthographicCamera,\\n\\n\\t\\tisOrthographicCamera: true,\\n\\n\\t\\tcopy: function ( source, recursive ) {\\n\\n\\t\\t\\tCamera.prototype.copy.call( this, source, recursive );\\n\\n\\t\\t\\tthis.left = source.left;\\n\\t\\t\\tthis.right = source.right;\\n\\t\\t\\tthis.top = source.top;\\n\\t\\t\\tthis.bottom = source.bottom;\\n\\t\\t\\tthis.near = source.near;\\n\\t\\t\\tthis.far = source.far;\\n\\n\\t\\t\\tthis.zoom = source.zoom;\\n\\t\\t\\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\\n\\n\\t\\t\\tif ( this.view === null ) {\\n\\n\\t\\t\\t\\tthis.view = {\\n\\t\\t\\t\\t\\tenabled: true,\\n\\t\\t\\t\\t\\tfullWidth: 1,\\n\\t\\t\\t\\t\\tfullHeight: 1,\\n\\t\\t\\t\\t\\toffsetX: 0,\\n\\t\\t\\t\\t\\toffsetY: 0,\\n\\t\\t\\t\\t\\twidth: 1,\\n\\t\\t\\t\\t\\theight: 1\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.view.enabled = true;\\n\\t\\t\\tthis.view.fullWidth = fullWidth;\\n\\t\\t\\tthis.view.fullHeight = fullHeight;\\n\\t\\t\\tthis.view.offsetX = x;\\n\\t\\t\\tthis.view.offsetY = y;\\n\\t\\t\\tthis.view.width = width;\\n\\t\\t\\tthis.view.height = height;\\n\\n\\t\\t\\tthis.updateProjectionMatrix();\\n\\n\\t\\t},\\n\\n\\t\\tclearViewOffset: function () {\\n\\n\\t\\t\\tif ( this.view !== null ) {\\n\\n\\t\\t\\t\\tthis.view.enabled = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.updateProjectionMatrix();\\n\\n\\t\\t},\\n\\n\\t\\tupdateProjectionMatrix: function () {\\n\\n\\t\\t\\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\\n\\t\\t\\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\\n\\t\\t\\tvar cx = ( this.right + this.left ) / 2;\\n\\t\\t\\tvar cy = ( this.top + this.bottom ) / 2;\\n\\n\\t\\t\\tvar left = cx - dx;\\n\\t\\t\\tvar right = cx + dx;\\n\\t\\t\\tvar top = cy + dy;\\n\\t\\t\\tvar bottom = cy - dy;\\n\\n\\t\\t\\tif ( this.view !== null && this.view.enabled ) {\\n\\n\\t\\t\\t\\tvar zoomW = this.zoom / ( this.view.width / this.view.fullWidth );\\n\\t\\t\\t\\tvar zoomH = this.zoom / ( this.view.height / this.view.fullHeight );\\n\\t\\t\\t\\tvar scaleW = ( this.right - this.left ) / this.view.width;\\n\\t\\t\\t\\tvar scaleH = ( this.top - this.bottom ) / this.view.height;\\n\\n\\t\\t\\t\\tleft += scaleW * ( this.view.offsetX / zoomW );\\n\\t\\t\\t\\tright = left + scaleW * ( this.view.width / zoomW );\\n\\t\\t\\t\\ttop -= scaleH * ( this.view.offsetY / zoomH );\\n\\t\\t\\t\\tbottom = top - scaleH * ( this.view.height / zoomH );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\n\\n\\t\\t\\tdata.object.zoom = this.zoom;\\n\\t\\t\\tdata.object.left = this.left;\\n\\t\\t\\tdata.object.right = this.right;\\n\\t\\t\\tdata.object.top = this.top;\\n\\t\\t\\tdata.object.bottom = this.bottom;\\n\\t\\t\\tdata.object.near = this.near;\\n\\t\\t\\tdata.object.far = this.far;\\n\\n\\t\\t\\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Face3( a, b, c, normal, color, materialIndex ) {\\n\\n\\t\\tthis.a = a;\\n\\t\\tthis.b = b;\\n\\t\\tthis.c = c;\\n\\n\\t\\tthis.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();\\n\\t\\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\\n\\n\\t\\tthis.color = ( color && color.isColor ) ? color : new Color();\\n\\t\\tthis.vertexColors = Array.isArray( color ) ? color : [];\\n\\n\\t\\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\\n\\n\\t}\\n\\n\\tObject.assign( Face3.prototype, {\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.a = source.a;\\n\\t\\t\\tthis.b = source.b;\\n\\t\\t\\tthis.c = source.c;\\n\\n\\t\\t\\tthis.normal.copy( source.normal );\\n\\t\\t\\tthis.color.copy( source.color );\\n\\n\\t\\t\\tthis.materialIndex = source.materialIndex;\\n\\n\\t\\t\\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author kile / http://kile.stravaganza.org/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tvar geometryId = 0; // Geometry uses even numbers as Id\\n\\n\\tfunction Geometry() {\\n\\n\\t\\tObject.defineProperty( this, 'id', { value: geometryId += 2 } );\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.name = '';\\n\\t\\tthis.type = 'Geometry';\\n\\n\\t\\tthis.vertices = [];\\n\\t\\tthis.colors = [];\\n\\t\\tthis.faces = [];\\n\\t\\tthis.faceVertexUvs = [[]];\\n\\n\\t\\tthis.morphTargets = [];\\n\\t\\tthis.morphNormals = [];\\n\\n\\t\\tthis.skinWeights = [];\\n\\t\\tthis.skinIndices = [];\\n\\n\\t\\tthis.lineDistances = [];\\n\\n\\t\\tthis.boundingBox = null;\\n\\t\\tthis.boundingSphere = null;\\n\\n\\t\\t// update flags\\n\\n\\t\\tthis.elementsNeedUpdate = false;\\n\\t\\tthis.verticesNeedUpdate = false;\\n\\t\\tthis.uvsNeedUpdate = false;\\n\\t\\tthis.normalsNeedUpdate = false;\\n\\t\\tthis.colorsNeedUpdate = false;\\n\\t\\tthis.lineDistancesNeedUpdate = false;\\n\\t\\tthis.groupsNeedUpdate = false;\\n\\n\\t}\\n\\n\\tGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: Geometry,\\n\\n\\t\\tisGeometry: true,\\n\\n\\t\\tapplyMatrix: function ( matrix ) {\\n\\n\\t\\t\\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\\n\\n\\t\\t\\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar vertex = this.vertices[ i ];\\n\\t\\t\\t\\tvertex.applyMatrix4( matrix );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = this.faces[ i ];\\n\\t\\t\\t\\tface.normal.applyMatrix3( normalMatrix ).normalize();\\n\\n\\t\\t\\t\\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.boundingBox !== null ) {\\n\\n\\t\\t\\t\\tthis.computeBoundingBox();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tthis.computeBoundingSphere();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.verticesNeedUpdate = true;\\n\\t\\t\\tthis.normalsNeedUpdate = true;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\trotateX: function () {\\n\\n\\t\\t\\t// rotate geometry around world x-axis\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function rotateX( angle ) {\\n\\n\\t\\t\\t\\tm1.makeRotationX( angle );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateY: function () {\\n\\n\\t\\t\\t// rotate geometry around world y-axis\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function rotateY( angle ) {\\n\\n\\t\\t\\t\\tm1.makeRotationY( angle );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateZ: function () {\\n\\n\\t\\t\\t// rotate geometry around world z-axis\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function rotateZ( angle ) {\\n\\n\\t\\t\\t\\tm1.makeRotationZ( angle );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslate: function () {\\n\\n\\t\\t\\t// translate geometry\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function translate( x, y, z ) {\\n\\n\\t\\t\\t\\tm1.makeTranslation( x, y, z );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tscale: function () {\\n\\n\\t\\t\\t// scale geometry\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function scale( x, y, z ) {\\n\\n\\t\\t\\t\\tm1.makeScale( x, y, z );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tlookAt: function () {\\n\\n\\t\\t\\tvar obj = new Object3D();\\n\\n\\t\\t\\treturn function lookAt( vector ) {\\n\\n\\t\\t\\t\\tobj.lookAt( vector );\\n\\n\\t\\t\\t\\tobj.updateMatrix();\\n\\n\\t\\t\\t\\tthis.applyMatrix( obj.matrix );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tfromBufferGeometry: function ( geometry ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\\n\\t\\t\\tvar attributes = geometry.attributes;\\n\\n\\t\\t\\tvar positions = attributes.position.array;\\n\\t\\t\\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\\n\\t\\t\\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\\n\\t\\t\\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\\n\\t\\t\\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\\n\\n\\t\\t\\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\\n\\n\\t\\t\\tvar tempNormals = [];\\n\\t\\t\\tvar tempUVs = [];\\n\\t\\t\\tvar tempUVs2 = [];\\n\\n\\t\\t\\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\\n\\n\\t\\t\\t\\tscope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\\n\\n\\t\\t\\t\\tif ( normals !== undefined ) {\\n\\n\\t\\t\\t\\t\\ttempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( colors !== undefined ) {\\n\\n\\t\\t\\t\\t\\tscope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( uvs !== undefined ) {\\n\\n\\t\\t\\t\\t\\ttempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( uvs2 !== undefined ) {\\n\\n\\t\\t\\t\\t\\ttempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction addFace( a, b, c, materialIndex ) {\\n\\n\\t\\t\\t\\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\\n\\t\\t\\t\\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\\n\\n\\t\\t\\t\\tvar face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\\n\\n\\t\\t\\t\\tscope.faces.push( face );\\n\\n\\t\\t\\t\\tif ( uvs !== undefined ) {\\n\\n\\t\\t\\t\\t\\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( uvs2 !== undefined ) {\\n\\n\\t\\t\\t\\t\\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar groups = geometry.groups;\\n\\n\\t\\t\\tif ( groups.length > 0 ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < groups.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar group = groups[ i ];\\n\\n\\t\\t\\t\\t\\tvar start = group.start;\\n\\t\\t\\t\\t\\tvar count = group.count;\\n\\n\\t\\t\\t\\t\\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( indices !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\taddFace( j, j + 1, j + 2, group.materialIndex );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tif ( indices !== undefined ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < indices.length; i += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\taddFace( i, i + 1, i + 2 );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.computeFaceNormals();\\n\\n\\t\\t\\tif ( geometry.boundingBox !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingBox = geometry.boundingBox.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingSphere = geometry.boundingSphere.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcenter: function () {\\n\\n\\t\\t\\tthis.computeBoundingBox();\\n\\n\\t\\t\\tvar offset = this.boundingBox.getCenter().negate();\\n\\n\\t\\t\\tthis.translate( offset.x, offset.y, offset.z );\\n\\n\\t\\t\\treturn offset;\\n\\n\\t\\t},\\n\\n\\t\\tnormalize: function () {\\n\\n\\t\\t\\tthis.computeBoundingSphere();\\n\\n\\t\\t\\tvar center = this.boundingSphere.center;\\n\\t\\t\\tvar radius = this.boundingSphere.radius;\\n\\n\\t\\t\\tvar s = radius === 0 ? 1 : 1.0 / radius;\\n\\n\\t\\t\\tvar matrix = new Matrix4();\\n\\t\\t\\tmatrix.set(\\n\\t\\t\\t\\ts, 0, 0, - s * center.x,\\n\\t\\t\\t\\t0, s, 0, - s * center.y,\\n\\t\\t\\t\\t0, 0, s, - s * center.z,\\n\\t\\t\\t\\t0, 0, 0, 1\\n\\t\\t\\t);\\n\\n\\t\\t\\tthis.applyMatrix( matrix );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcomputeFaceNormals: function () {\\n\\n\\t\\t\\tvar cb = new Vector3(), ab = new Vector3();\\n\\n\\t\\t\\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\tvar face = this.faces[ f ];\\n\\n\\t\\t\\t\\tvar vA = this.vertices[ face.a ];\\n\\t\\t\\t\\tvar vB = this.vertices[ face.b ];\\n\\t\\t\\t\\tvar vC = this.vertices[ face.c ];\\n\\n\\t\\t\\t\\tcb.subVectors( vC, vB );\\n\\t\\t\\t\\tab.subVectors( vA, vB );\\n\\t\\t\\t\\tcb.cross( ab );\\n\\n\\t\\t\\t\\tcb.normalize();\\n\\n\\t\\t\\t\\tface.normal.copy( cb );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tcomputeVertexNormals: function ( areaWeighted ) {\\n\\n\\t\\t\\tif ( areaWeighted === undefined ) areaWeighted = true;\\n\\n\\t\\t\\tvar v, vl, f, fl, face, vertices;\\n\\n\\t\\t\\tvertices = new Array( this.vertices.length );\\n\\n\\t\\t\\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\\n\\n\\t\\t\\t\\tvertices[ v ] = new Vector3();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( areaWeighted ) {\\n\\n\\t\\t\\t\\t// vertex normals weighted by triangle areas\\n\\t\\t\\t\\t// http://www.iquilezles.org/www/articles/normals/normals.htm\\n\\n\\t\\t\\t\\tvar vA, vB, vC;\\n\\t\\t\\t\\tvar cb = new Vector3(), ab = new Vector3();\\n\\n\\t\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\t\\tvA = this.vertices[ face.a ];\\n\\t\\t\\t\\t\\tvB = this.vertices[ face.b ];\\n\\t\\t\\t\\t\\tvC = this.vertices[ face.c ];\\n\\n\\t\\t\\t\\t\\tcb.subVectors( vC, vB );\\n\\t\\t\\t\\t\\tab.subVectors( vA, vB );\\n\\t\\t\\t\\t\\tcb.cross( ab );\\n\\n\\t\\t\\t\\t\\tvertices[ face.a ].add( cb );\\n\\t\\t\\t\\t\\tvertices[ face.b ].add( cb );\\n\\t\\t\\t\\t\\tvertices[ face.c ].add( cb );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.computeFaceNormals();\\n\\n\\t\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\t\\tvertices[ face.a ].add( face.normal );\\n\\t\\t\\t\\t\\tvertices[ face.b ].add( face.normal );\\n\\t\\t\\t\\t\\tvertices[ face.c ].add( face.normal );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\\n\\n\\t\\t\\t\\tvertices[ v ].normalize();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\tvar vertexNormals = face.vertexNormals;\\n\\n\\t\\t\\t\\tif ( vertexNormals.length === 3 ) {\\n\\n\\t\\t\\t\\t\\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\\n\\t\\t\\t\\t\\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\\n\\t\\t\\t\\t\\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\\n\\t\\t\\t\\t\\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\\n\\t\\t\\t\\t\\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.faces.length > 0 ) {\\n\\n\\t\\t\\t\\tthis.normalsNeedUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tcomputeFlatVertexNormals: function () {\\n\\n\\t\\t\\tvar f, fl, face;\\n\\n\\t\\t\\tthis.computeFaceNormals();\\n\\n\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\tvar vertexNormals = face.vertexNormals;\\n\\n\\t\\t\\t\\tif ( vertexNormals.length === 3 ) {\\n\\n\\t\\t\\t\\t\\tvertexNormals[ 0 ].copy( face.normal );\\n\\t\\t\\t\\t\\tvertexNormals[ 1 ].copy( face.normal );\\n\\t\\t\\t\\t\\tvertexNormals[ 2 ].copy( face.normal );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvertexNormals[ 0 ] = face.normal.clone();\\n\\t\\t\\t\\t\\tvertexNormals[ 1 ] = face.normal.clone();\\n\\t\\t\\t\\t\\tvertexNormals[ 2 ] = face.normal.clone();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.faces.length > 0 ) {\\n\\n\\t\\t\\t\\tthis.normalsNeedUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tcomputeMorphNormals: function () {\\n\\n\\t\\t\\tvar i, il, f, fl, face;\\n\\n\\t\\t\\t// save original normals\\n\\t\\t\\t// - create temp variables on first access\\n\\t\\t\\t//   otherwise just copy (for faster repeated calls)\\n\\n\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\tif ( ! face.__originalFaceNormal ) {\\n\\n\\t\\t\\t\\t\\tface.__originalFaceNormal = face.normal.clone();\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tface.__originalFaceNormal.copy( face.normal );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\\n\\n\\t\\t\\t\\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( ! face.__originalVertexNormals[ i ] ) {\\n\\n\\t\\t\\t\\t\\t\\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// use temp geometry to compute face and vertex normals for each morph\\n\\n\\t\\t\\tvar tmpGeo = new Geometry();\\n\\t\\t\\ttmpGeo.faces = this.faces;\\n\\n\\t\\t\\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t// create on first access\\n\\n\\t\\t\\t\\tif ( ! this.morphNormals[ i ] ) {\\n\\n\\t\\t\\t\\t\\tthis.morphNormals[ i ] = {};\\n\\t\\t\\t\\t\\tthis.morphNormals[ i ].faceNormals = [];\\n\\t\\t\\t\\t\\tthis.morphNormals[ i ].vertexNormals = [];\\n\\n\\t\\t\\t\\t\\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\\n\\t\\t\\t\\t\\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\\n\\n\\t\\t\\t\\t\\tvar faceNormal, vertexNormals;\\n\\n\\t\\t\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tfaceNormal = new Vector3();\\n\\t\\t\\t\\t\\t\\tvertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };\\n\\n\\t\\t\\t\\t\\t\\tdstNormalsFace.push( faceNormal );\\n\\t\\t\\t\\t\\t\\tdstNormalsVertex.push( vertexNormals );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar morphNormals = this.morphNormals[ i ];\\n\\n\\t\\t\\t\\t// set vertices to morph target\\n\\n\\t\\t\\t\\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\\n\\n\\t\\t\\t\\t// compute morph normals\\n\\n\\t\\t\\t\\ttmpGeo.computeFaceNormals();\\n\\t\\t\\t\\ttmpGeo.computeVertexNormals();\\n\\n\\t\\t\\t\\t// store morph normals\\n\\n\\t\\t\\t\\tvar faceNormal, vertexNormals;\\n\\n\\t\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\t\\tfaceNormal = morphNormals.faceNormals[ f ];\\n\\t\\t\\t\\t\\tvertexNormals = morphNormals.vertexNormals[ f ];\\n\\n\\t\\t\\t\\t\\tfaceNormal.copy( face.normal );\\n\\n\\t\\t\\t\\t\\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\\n\\t\\t\\t\\t\\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\\n\\t\\t\\t\\t\\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// restore original normals\\n\\n\\t\\t\\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\tface = this.faces[ f ];\\n\\n\\t\\t\\t\\tface.normal = face.__originalFaceNormal;\\n\\t\\t\\t\\tface.vertexNormals = face.__originalVertexNormals;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tcomputeLineDistances: function () {\\n\\n\\t\\t\\tvar d = 0;\\n\\t\\t\\tvar vertices = this.vertices;\\n\\n\\t\\t\\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tif ( i > 0 ) {\\n\\n\\t\\t\\t\\t\\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.lineDistances[ i ] = d;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tcomputeBoundingBox: function () {\\n\\n\\t\\t\\tif ( this.boundingBox === null ) {\\n\\n\\t\\t\\t\\tthis.boundingBox = new Box3();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.boundingBox.setFromPoints( this.vertices );\\n\\n\\t\\t},\\n\\n\\t\\tcomputeBoundingSphere: function () {\\n\\n\\t\\t\\tif ( this.boundingSphere === null ) {\\n\\n\\t\\t\\t\\tthis.boundingSphere = new Sphere();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.boundingSphere.setFromPoints( this.vertices );\\n\\n\\t\\t},\\n\\n\\t\\tmerge: function ( geometry, matrix, materialIndexOffset ) {\\n\\n\\t\\t\\tif ( ! ( geometry && geometry.isGeometry ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar normalMatrix,\\n\\t\\t\\t\\tvertexOffset = this.vertices.length,\\n\\t\\t\\t\\tvertices1 = this.vertices,\\n\\t\\t\\t\\tvertices2 = geometry.vertices,\\n\\t\\t\\t\\tfaces1 = this.faces,\\n\\t\\t\\t\\tfaces2 = geometry.faces,\\n\\t\\t\\t\\tuvs1 = this.faceVertexUvs[ 0 ],\\n\\t\\t\\t\\tuvs2 = geometry.faceVertexUvs[ 0 ],\\n\\t\\t\\t\\tcolors1 = this.colors,\\n\\t\\t\\t\\tcolors2 = geometry.colors;\\n\\n\\t\\t\\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\\n\\n\\t\\t\\tif ( matrix !== undefined ) {\\n\\n\\t\\t\\t\\tnormalMatrix = new Matrix3().getNormalMatrix( matrix );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// vertices\\n\\n\\t\\t\\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar vertex = vertices2[ i ];\\n\\n\\t\\t\\t\\tvar vertexCopy = vertex.clone();\\n\\n\\t\\t\\t\\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\\n\\n\\t\\t\\t\\tvertices1.push( vertexCopy );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// colors\\n\\n\\t\\t\\tfor ( var i = 0, il = colors2.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tcolors1.push( colors2[ i ].clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// faces\\n\\n\\t\\t\\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = faces2[ i ], faceCopy, normal, color,\\n\\t\\t\\t\\t\\tfaceVertexNormals = face.vertexNormals,\\n\\t\\t\\t\\t\\tfaceVertexColors = face.vertexColors;\\n\\n\\t\\t\\t\\tfaceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\\n\\t\\t\\t\\tfaceCopy.normal.copy( face.normal );\\n\\n\\t\\t\\t\\tif ( normalMatrix !== undefined ) {\\n\\n\\t\\t\\t\\t\\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tnormal = faceVertexNormals[ j ].clone();\\n\\n\\t\\t\\t\\t\\tif ( normalMatrix !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tnormal.applyMatrix3( normalMatrix ).normalize();\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfaceCopy.vertexNormals.push( normal );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfaceCopy.color.copy( face.color );\\n\\n\\t\\t\\t\\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tcolor = faceVertexColors[ j ];\\n\\t\\t\\t\\t\\tfaceCopy.vertexColors.push( color.clone() );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\\n\\n\\t\\t\\t\\tfaces1.push( faceCopy );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// uvs\\n\\n\\t\\t\\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar uv = uvs2[ i ], uvCopy = [];\\n\\n\\t\\t\\t\\tif ( uv === undefined ) {\\n\\n\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tuvCopy.push( uv[ j ].clone() );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tuvs1.push( uvCopy );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tmergeMesh: function ( mesh ) {\\n\\n\\t\\t\\tif ( ! ( mesh && mesh.isMesh ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tmesh.matrixAutoUpdate && mesh.updateMatrix();\\n\\n\\t\\t\\tthis.merge( mesh.geometry, mesh.matrix );\\n\\n\\t\\t},\\n\\n\\t\\t/*\\n\\t\\t * Checks for duplicate vertices with hashmap.\\n\\t\\t * Duplicated vertices are removed\\n\\t\\t * and faces' vertices are updated.\\n\\t\\t */\\n\\n\\t\\tmergeVertices: function () {\\n\\n\\t\\t\\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\\n\\t\\t\\tvar unique = [], changes = [];\\n\\n\\t\\t\\tvar v, key;\\n\\t\\t\\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\\n\\t\\t\\tvar precision = Math.pow( 10, precisionPoints );\\n\\t\\t\\tvar i, il, face;\\n\\t\\t\\tvar indices, j, jl;\\n\\n\\t\\t\\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tv = this.vertices[ i ];\\n\\t\\t\\t\\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\\n\\n\\t\\t\\t\\tif ( verticesMap[ key ] === undefined ) {\\n\\n\\t\\t\\t\\t\\tverticesMap[ key ] = i;\\n\\t\\t\\t\\t\\tunique.push( this.vertices[ i ] );\\n\\t\\t\\t\\t\\tchanges[ i ] = unique.length - 1;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\\n\\t\\t\\t\\t\\tchanges[ i ] = changes[ verticesMap[ key ] ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\t// if faces are completely degenerate after merging vertices, we\\n\\t\\t\\t// have to remove them from the geometry.\\n\\t\\t\\tvar faceIndicesToRemove = [];\\n\\n\\t\\t\\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tface = this.faces[ i ];\\n\\n\\t\\t\\t\\tface.a = changes[ face.a ];\\n\\t\\t\\t\\tface.b = changes[ face.b ];\\n\\t\\t\\t\\tface.c = changes[ face.c ];\\n\\n\\t\\t\\t\\tindices = [ face.a, face.b, face.c ];\\n\\n\\t\\t\\t\\t// if any duplicate vertices are found in a Face3\\n\\t\\t\\t\\t// we have to remove the face as nothing can be saved\\n\\t\\t\\t\\tfor ( var n = 0; n < 3; n ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\\n\\n\\t\\t\\t\\t\\t\\tfaceIndicesToRemove.push( i );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\\n\\n\\t\\t\\t\\tvar idx = faceIndicesToRemove[ i ];\\n\\n\\t\\t\\t\\tthis.faces.splice( idx, 1 );\\n\\n\\t\\t\\t\\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tthis.faceVertexUvs[ j ].splice( idx, 1 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Use unique set of vertices\\n\\n\\t\\t\\tvar diff = this.vertices.length - unique.length;\\n\\t\\t\\tthis.vertices = unique;\\n\\t\\t\\treturn diff;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromPoints: function ( points ) {\\n\\n\\t\\t\\tthis.vertices = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar point = points[ i ];\\n\\t\\t\\t\\tthis.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsortFacesByMaterialIndex: function () {\\n\\n\\t\\t\\tvar faces = this.faces;\\n\\t\\t\\tvar length = faces.length;\\n\\n\\t\\t\\t// tag faces\\n\\n\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\n\\n\\t\\t\\t\\tfaces[ i ]._id = i;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// sort faces\\n\\n\\t\\t\\tfunction materialIndexSort( a, b ) {\\n\\n\\t\\t\\t\\treturn a.materialIndex - b.materialIndex;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfaces.sort( materialIndexSort );\\n\\n\\t\\t\\t// sort uvs\\n\\n\\t\\t\\tvar uvs1 = this.faceVertexUvs[ 0 ];\\n\\t\\t\\tvar uvs2 = this.faceVertexUvs[ 1 ];\\n\\n\\t\\t\\tvar newUvs1, newUvs2;\\n\\n\\t\\t\\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\\n\\t\\t\\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\\n\\n\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\n\\n\\t\\t\\t\\tvar id = faces[ i ]._id;\\n\\n\\t\\t\\t\\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\\n\\t\\t\\t\\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\\n\\t\\t\\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar data = {\\n\\t\\t\\t\\tmetadata: {\\n\\t\\t\\t\\t\\tversion: 4.5,\\n\\t\\t\\t\\t\\ttype: 'Geometry',\\n\\t\\t\\t\\t\\tgenerator: 'Geometry.toJSON'\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t\\t// standard Geometry serialization\\n\\n\\t\\t\\tdata.uuid = this.uuid;\\n\\t\\t\\tdata.type = this.type;\\n\\t\\t\\tif ( this.name !== '' ) data.name = this.name;\\n\\n\\t\\t\\tif ( this.parameters !== undefined ) {\\n\\n\\t\\t\\t\\tvar parameters = this.parameters;\\n\\n\\t\\t\\t\\tfor ( var key in parameters ) {\\n\\n\\t\\t\\t\\t\\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn data;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar vertices = [];\\n\\n\\t\\t\\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar vertex = this.vertices[ i ];\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar faces = [];\\n\\t\\t\\tvar normals = [];\\n\\t\\t\\tvar normalsHash = {};\\n\\t\\t\\tvar colors = [];\\n\\t\\t\\tvar colorsHash = {};\\n\\t\\t\\tvar uvs = [];\\n\\t\\t\\tvar uvsHash = {};\\n\\n\\t\\t\\tfor ( var i = 0; i < this.faces.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = this.faces[ i ];\\n\\n\\t\\t\\t\\tvar hasMaterial = true;\\n\\t\\t\\t\\tvar hasFaceUv = false; // deprecated\\n\\t\\t\\t\\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\\n\\t\\t\\t\\tvar hasFaceNormal = face.normal.length() > 0;\\n\\t\\t\\t\\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\\n\\t\\t\\t\\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\\n\\t\\t\\t\\tvar hasFaceVertexColor = face.vertexColors.length > 0;\\n\\n\\t\\t\\t\\tvar faceType = 0;\\n\\n\\t\\t\\t\\tfaceType = setBit( faceType, 0, 0 ); // isQuad\\n\\t\\t\\t\\tfaceType = setBit( faceType, 1, hasMaterial );\\n\\t\\t\\t\\tfaceType = setBit( faceType, 2, hasFaceUv );\\n\\t\\t\\t\\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\\n\\t\\t\\t\\tfaceType = setBit( faceType, 4, hasFaceNormal );\\n\\t\\t\\t\\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\\n\\t\\t\\t\\tfaceType = setBit( faceType, 6, hasFaceColor );\\n\\t\\t\\t\\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\\n\\n\\t\\t\\t\\tfaces.push( faceType );\\n\\t\\t\\t\\tfaces.push( face.a, face.b, face.c );\\n\\t\\t\\t\\tfaces.push( face.materialIndex );\\n\\n\\t\\t\\t\\tif ( hasFaceVertexUv ) {\\n\\n\\t\\t\\t\\t\\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\\n\\n\\t\\t\\t\\t\\tfaces.push(\\n\\t\\t\\t\\t\\t\\tgetUvIndex( faceVertexUvs[ 0 ] ),\\n\\t\\t\\t\\t\\t\\tgetUvIndex( faceVertexUvs[ 1 ] ),\\n\\t\\t\\t\\t\\t\\tgetUvIndex( faceVertexUvs[ 2 ] )\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasFaceNormal ) {\\n\\n\\t\\t\\t\\t\\tfaces.push( getNormalIndex( face.normal ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasFaceVertexNormal ) {\\n\\n\\t\\t\\t\\t\\tvar vertexNormals = face.vertexNormals;\\n\\n\\t\\t\\t\\t\\tfaces.push(\\n\\t\\t\\t\\t\\t\\tgetNormalIndex( vertexNormals[ 0 ] ),\\n\\t\\t\\t\\t\\t\\tgetNormalIndex( vertexNormals[ 1 ] ),\\n\\t\\t\\t\\t\\t\\tgetNormalIndex( vertexNormals[ 2 ] )\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasFaceColor ) {\\n\\n\\t\\t\\t\\t\\tfaces.push( getColorIndex( face.color ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasFaceVertexColor ) {\\n\\n\\t\\t\\t\\t\\tvar vertexColors = face.vertexColors;\\n\\n\\t\\t\\t\\t\\tfaces.push(\\n\\t\\t\\t\\t\\t\\tgetColorIndex( vertexColors[ 0 ] ),\\n\\t\\t\\t\\t\\t\\tgetColorIndex( vertexColors[ 1 ] ),\\n\\t\\t\\t\\t\\t\\tgetColorIndex( vertexColors[ 2 ] )\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction setBit( value, position, enabled ) {\\n\\n\\t\\t\\t\\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction getNormalIndex( normal ) {\\n\\n\\t\\t\\t\\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\\n\\n\\t\\t\\t\\tif ( normalsHash[ hash ] !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn normalsHash[ hash ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tnormalsHash[ hash ] = normals.length / 3;\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\treturn normalsHash[ hash ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction getColorIndex( color ) {\\n\\n\\t\\t\\t\\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\\n\\n\\t\\t\\t\\tif ( colorsHash[ hash ] !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn colorsHash[ hash ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcolorsHash[ hash ] = colors.length;\\n\\t\\t\\t\\tcolors.push( color.getHex() );\\n\\n\\t\\t\\t\\treturn colorsHash[ hash ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction getUvIndex( uv ) {\\n\\n\\t\\t\\t\\tvar hash = uv.x.toString() + uv.y.toString();\\n\\n\\t\\t\\t\\tif ( uvsHash[ hash ] !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn uvsHash[ hash ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tuvsHash[ hash ] = uvs.length / 2;\\n\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\n\\n\\t\\t\\t\\treturn uvsHash[ hash ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tdata.data = {};\\n\\n\\t\\t\\tdata.data.vertices = vertices;\\n\\t\\t\\tdata.data.normals = normals;\\n\\t\\t\\tif ( colors.length > 0 ) data.data.colors = colors;\\n\\t\\t\\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\\n\\t\\t\\tdata.data.faces = faces;\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\t/*\\n\\t\\t\\t // Handle primitives\\n\\n\\t\\t\\t var parameters = this.parameters;\\n\\n\\t\\t\\t if ( parameters !== undefined ) {\\n\\n\\t\\t\\t var values = [];\\n\\n\\t\\t\\t for ( var key in parameters ) {\\n\\n\\t\\t\\t values.push( parameters[ key ] );\\n\\n\\t\\t\\t }\\n\\n\\t\\t\\t var geometry = Object.create( this.constructor.prototype );\\n\\t\\t\\t this.constructor.apply( geometry, values );\\n\\t\\t\\t return geometry;\\n\\n\\t\\t\\t }\\n\\n\\t\\t\\t return new this.constructor().copy( this );\\n\\t\\t\\t */\\n\\n\\t\\t\\treturn new Geometry().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tvar i, il, j, jl, k, kl;\\n\\n\\t\\t\\t// reset\\n\\n\\t\\t\\tthis.vertices = [];\\n\\t\\t\\tthis.colors = [];\\n\\t\\t\\tthis.faces = [];\\n\\t\\t\\tthis.faceVertexUvs = [[]];\\n\\t\\t\\tthis.morphTargets = [];\\n\\t\\t\\tthis.morphNormals = [];\\n\\t\\t\\tthis.skinWeights = [];\\n\\t\\t\\tthis.skinIndices = [];\\n\\t\\t\\tthis.lineDistances = [];\\n\\t\\t\\tthis.boundingBox = null;\\n\\t\\t\\tthis.boundingSphere = null;\\n\\n\\t\\t\\t// name\\n\\n\\t\\t\\tthis.name = source.name;\\n\\n\\t\\t\\t// vertices\\n\\n\\t\\t\\tvar vertices = source.vertices;\\n\\n\\t\\t\\tfor ( i = 0, il = vertices.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.vertices.push( vertices[ i ].clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// colors\\n\\n\\t\\t\\tvar colors = source.colors;\\n\\n\\t\\t\\tfor ( i = 0, il = colors.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.colors.push( colors[ i ].clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// faces\\n\\n\\t\\t\\tvar faces = source.faces;\\n\\n\\t\\t\\tfor ( i = 0, il = faces.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.faces.push( faces[ i ].clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// face vertex uvs\\n\\n\\t\\t\\tfor ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar faceVertexUvs = source.faceVertexUvs[ i ];\\n\\n\\t\\t\\t\\tif ( this.faceVertexUvs[ i ] === undefined ) {\\n\\n\\t\\t\\t\\t\\tthis.faceVertexUvs[ i ] = [];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\\n\\n\\t\\t\\t\\t\\tfor ( k = 0, kl = uvs.length; k < kl; k ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar uv = uvs[ k ];\\n\\n\\t\\t\\t\\t\\t\\tuvsCopy.push( uv.clone() );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tthis.faceVertexUvs[ i ].push( uvsCopy );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// morph targets\\n\\n\\t\\t\\tvar morphTargets = source.morphTargets;\\n\\n\\t\\t\\tfor ( i = 0, il = morphTargets.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar morphTarget = {};\\n\\t\\t\\t\\tmorphTarget.name = morphTargets[ i ].name;\\n\\n\\t\\t\\t\\t// vertices\\n\\n\\t\\t\\t\\tif ( morphTargets[ i ].vertices !== undefined ) {\\n\\n\\t\\t\\t\\t\\tmorphTarget.vertices = [];\\n\\n\\t\\t\\t\\t\\tfor ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tmorphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// normals\\n\\n\\t\\t\\t\\tif ( morphTargets[ i ].normals !== undefined ) {\\n\\n\\t\\t\\t\\t\\tmorphTarget.normals = [];\\n\\n\\t\\t\\t\\t\\tfor ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tmorphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.morphTargets.push( morphTarget );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// morph normals\\n\\n\\t\\t\\tvar morphNormals = source.morphNormals;\\n\\n\\t\\t\\tfor ( i = 0, il = morphNormals.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar morphNormal = {};\\n\\n\\t\\t\\t\\t// vertex normals\\n\\n\\t\\t\\t\\tif ( morphNormals[ i ].vertexNormals !== undefined ) {\\n\\n\\t\\t\\t\\t\\tmorphNormal.vertexNormals = [];\\n\\n\\t\\t\\t\\t\\tfor ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];\\n\\t\\t\\t\\t\\t\\tvar destVertexNormal = {};\\n\\n\\t\\t\\t\\t\\t\\tdestVertexNormal.a = srcVertexNormal.a.clone();\\n\\t\\t\\t\\t\\t\\tdestVertexNormal.b = srcVertexNormal.b.clone();\\n\\t\\t\\t\\t\\t\\tdestVertexNormal.c = srcVertexNormal.c.clone();\\n\\n\\t\\t\\t\\t\\t\\tmorphNormal.vertexNormals.push( destVertexNormal );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// face normals\\n\\n\\t\\t\\t\\tif ( morphNormals[ i ].faceNormals !== undefined ) {\\n\\n\\t\\t\\t\\t\\tmorphNormal.faceNormals = [];\\n\\n\\t\\t\\t\\t\\tfor ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tmorphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.morphNormals.push( morphNormal );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// skin weights\\n\\n\\t\\t\\tvar skinWeights = source.skinWeights;\\n\\n\\t\\t\\tfor ( i = 0, il = skinWeights.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.skinWeights.push( skinWeights[ i ].clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// skin indices\\n\\n\\t\\t\\tvar skinIndices = source.skinIndices;\\n\\n\\t\\t\\tfor ( i = 0, il = skinIndices.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.skinIndices.push( skinIndices[ i ].clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// line distances\\n\\n\\t\\t\\tvar lineDistances = source.lineDistances;\\n\\n\\t\\t\\tfor ( i = 0, il = lineDistances.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tthis.lineDistances.push( lineDistances[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// bounding box\\n\\n\\t\\t\\tvar boundingBox = source.boundingBox;\\n\\n\\t\\t\\tif ( boundingBox !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingBox = boundingBox.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// bounding sphere\\n\\n\\t\\t\\tvar boundingSphere = source.boundingSphere;\\n\\n\\t\\t\\tif ( boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingSphere = boundingSphere.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// update flags\\n\\n\\t\\t\\tthis.elementsNeedUpdate = source.elementsNeedUpdate;\\n\\t\\t\\tthis.verticesNeedUpdate = source.verticesNeedUpdate;\\n\\t\\t\\tthis.uvsNeedUpdate = source.uvsNeedUpdate;\\n\\t\\t\\tthis.normalsNeedUpdate = source.normalsNeedUpdate;\\n\\t\\t\\tthis.colorsNeedUpdate = source.colorsNeedUpdate;\\n\\t\\t\\tthis.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;\\n\\t\\t\\tthis.groupsNeedUpdate = source.groupsNeedUpdate;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdispose: function () {\\n\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tif ( Array.isArray( array ) ) {\\n\\n\\t\\t\\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\\n\\n\\t\\t}\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\t\\tthis.name = '';\\n\\n\\t\\tthis.array = array;\\n\\t\\tthis.itemSize = itemSize;\\n\\t\\tthis.count = array !== undefined ? array.length / itemSize : 0;\\n\\t\\tthis.normalized = normalized === true;\\n\\n\\t\\tthis.dynamic = false;\\n\\t\\tthis.updateRange = { offset: 0, count: - 1 };\\n\\n\\t\\tthis.onUploadCallback = function () {};\\n\\n\\t\\tthis.version = 0;\\n\\n\\t}\\n\\n\\tObject.defineProperty( BufferAttribute.prototype, 'needsUpdate', {\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tif ( value === true ) this.version ++;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( BufferAttribute.prototype, {\\n\\n\\t\\tisBufferAttribute: true,\\n\\n\\t\\tsetArray: function ( array ) {\\n\\n\\t\\t\\tif ( Array.isArray( array ) ) {\\n\\n\\t\\t\\t\\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.count = array !== undefined ? array.length / this.itemSize : 0;\\n\\t\\t\\tthis.array = array;\\n\\n\\t\\t},\\n\\n\\t\\tsetDynamic: function ( value ) {\\n\\n\\t\\t\\tthis.dynamic = value;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.array = new source.array.constructor( source.array );\\n\\t\\t\\tthis.itemSize = source.itemSize;\\n\\t\\t\\tthis.count = source.count;\\n\\t\\t\\tthis.normalized = source.normalized;\\n\\n\\t\\t\\tthis.dynamic = source.dynamic;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyAt: function ( index1, attribute, index2 ) {\\n\\n\\t\\t\\tindex1 *= this.itemSize;\\n\\t\\t\\tindex2 *= attribute.itemSize;\\n\\n\\t\\t\\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyArray: function ( array ) {\\n\\n\\t\\t\\tthis.array.set( array );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyColorsArray: function ( colors ) {\\n\\n\\t\\t\\tvar array = this.array, offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar color = colors[ i ];\\n\\n\\t\\t\\t\\tif ( color === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\\n\\t\\t\\t\\t\\tcolor = new Color();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tarray[ offset ++ ] = color.r;\\n\\t\\t\\t\\tarray[ offset ++ ] = color.g;\\n\\t\\t\\t\\tarray[ offset ++ ] = color.b;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyIndicesArray: function ( indices ) {\\n\\n\\t\\t\\tvar array = this.array, offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar index = indices[ i ];\\n\\n\\t\\t\\t\\tarray[ offset ++ ] = index.a;\\n\\t\\t\\t\\tarray[ offset ++ ] = index.b;\\n\\t\\t\\t\\tarray[ offset ++ ] = index.c;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyVector2sArray: function ( vectors ) {\\n\\n\\t\\t\\tvar array = this.array, offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar vector = vectors[ i ];\\n\\n\\t\\t\\t\\tif ( vector === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\\n\\t\\t\\t\\t\\tvector = new Vector2();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.x;\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.y;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyVector3sArray: function ( vectors ) {\\n\\n\\t\\t\\tvar array = this.array, offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar vector = vectors[ i ];\\n\\n\\t\\t\\t\\tif ( vector === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\\n\\t\\t\\t\\t\\tvector = new Vector3();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.x;\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.y;\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.z;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyVector4sArray: function ( vectors ) {\\n\\n\\t\\t\\tvar array = this.array, offset = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar vector = vectors[ i ];\\n\\n\\t\\t\\t\\tif ( vector === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\\n\\t\\t\\t\\t\\tvector = new Vector4();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.x;\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.y;\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.z;\\n\\t\\t\\t\\tarray[ offset ++ ] = vector.w;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis.array.set( value, offset );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetX: function ( index ) {\\n\\n\\t\\t\\treturn this.array[ index * this.itemSize ];\\n\\n\\t\\t},\\n\\n\\t\\tsetX: function ( index, x ) {\\n\\n\\t\\t\\tthis.array[ index * this.itemSize ] = x;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetY: function ( index ) {\\n\\n\\t\\t\\treturn this.array[ index * this.itemSize + 1 ];\\n\\n\\t\\t},\\n\\n\\t\\tsetY: function ( index, y ) {\\n\\n\\t\\t\\tthis.array[ index * this.itemSize + 1 ] = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetZ: function ( index ) {\\n\\n\\t\\t\\treturn this.array[ index * this.itemSize + 2 ];\\n\\n\\t\\t},\\n\\n\\t\\tsetZ: function ( index, z ) {\\n\\n\\t\\t\\tthis.array[ index * this.itemSize + 2 ] = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetW: function ( index ) {\\n\\n\\t\\t\\treturn this.array[ index * this.itemSize + 3 ];\\n\\n\\t\\t},\\n\\n\\t\\tsetW: function ( index, w ) {\\n\\n\\t\\t\\tthis.array[ index * this.itemSize + 3 ] = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetXY: function ( index, x, y ) {\\n\\n\\t\\t\\tindex *= this.itemSize;\\n\\n\\t\\t\\tthis.array[ index + 0 ] = x;\\n\\t\\t\\tthis.array[ index + 1 ] = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetXYZ: function ( index, x, y, z ) {\\n\\n\\t\\t\\tindex *= this.itemSize;\\n\\n\\t\\t\\tthis.array[ index + 0 ] = x;\\n\\t\\t\\tthis.array[ index + 1 ] = y;\\n\\t\\t\\tthis.array[ index + 2 ] = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetXYZW: function ( index, x, y, z, w ) {\\n\\n\\t\\t\\tindex *= this.itemSize;\\n\\n\\t\\t\\tthis.array[ index + 0 ] = x;\\n\\t\\t\\tthis.array[ index + 1 ] = y;\\n\\t\\t\\tthis.array[ index + 2 ] = z;\\n\\t\\t\\tthis.array[ index + 3 ] = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tonUpload: function ( callback ) {\\n\\n\\t\\t\\tthis.onUploadCallback = callback;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.array, this.itemSize ).copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tfunction Int8BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tInt8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tInt8BufferAttribute.prototype.constructor = Int8BufferAttribute;\\n\\n\\n\\tfunction Uint8BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tUint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tUint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;\\n\\n\\n\\tfunction Uint8ClampedBufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tUint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tUint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;\\n\\n\\n\\tfunction Int16BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tInt16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tInt16BufferAttribute.prototype.constructor = Int16BufferAttribute;\\n\\n\\n\\tfunction Uint16BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tUint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tUint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;\\n\\n\\n\\tfunction Int32BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tInt32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tInt32BufferAttribute.prototype.constructor = Int32BufferAttribute;\\n\\n\\n\\tfunction Uint32BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tUint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tUint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;\\n\\n\\n\\tfunction Float32BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tFloat32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tFloat32BufferAttribute.prototype.constructor = Float32BufferAttribute;\\n\\n\\n\\tfunction Float64BufferAttribute( array, itemSize, normalized ) {\\n\\n\\t\\tBufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );\\n\\n\\t}\\n\\n\\tFloat64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );\\n\\tFloat64BufferAttribute.prototype.constructor = Float64BufferAttribute;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction DirectGeometry() {\\n\\n\\t\\tthis.indices = [];\\n\\t\\tthis.vertices = [];\\n\\t\\tthis.normals = [];\\n\\t\\tthis.colors = [];\\n\\t\\tthis.uvs = [];\\n\\t\\tthis.uvs2 = [];\\n\\n\\t\\tthis.groups = [];\\n\\n\\t\\tthis.morphTargets = {};\\n\\n\\t\\tthis.skinWeights = [];\\n\\t\\tthis.skinIndices = [];\\n\\n\\t\\t// this.lineDistances = [];\\n\\n\\t\\tthis.boundingBox = null;\\n\\t\\tthis.boundingSphere = null;\\n\\n\\t\\t// update flags\\n\\n\\t\\tthis.verticesNeedUpdate = false;\\n\\t\\tthis.normalsNeedUpdate = false;\\n\\t\\tthis.colorsNeedUpdate = false;\\n\\t\\tthis.uvsNeedUpdate = false;\\n\\t\\tthis.groupsNeedUpdate = false;\\n\\n\\t}\\n\\n\\tObject.assign( DirectGeometry.prototype, {\\n\\n\\t\\tcomputeGroups: function ( geometry ) {\\n\\n\\t\\t\\tvar group;\\n\\t\\t\\tvar groups = [];\\n\\t\\t\\tvar materialIndex = undefined;\\n\\n\\t\\t\\tvar faces = geometry.faces;\\n\\n\\t\\t\\tfor ( var i = 0; i < faces.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\t// materials\\n\\n\\t\\t\\t\\tif ( face.materialIndex !== materialIndex ) {\\n\\n\\t\\t\\t\\t\\tmaterialIndex = face.materialIndex;\\n\\n\\t\\t\\t\\t\\tif ( group !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tgroup.count = ( i * 3 ) - group.start;\\n\\t\\t\\t\\t\\t\\tgroups.push( group );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tgroup = {\\n\\t\\t\\t\\t\\t\\tstart: i * 3,\\n\\t\\t\\t\\t\\t\\tmaterialIndex: materialIndex\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( group !== undefined ) {\\n\\n\\t\\t\\t\\tgroup.count = ( i * 3 ) - group.start;\\n\\t\\t\\t\\tgroups.push( group );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.groups = groups;\\n\\n\\t\\t},\\n\\n\\t\\tfromGeometry: function ( geometry ) {\\n\\n\\t\\t\\tvar faces = geometry.faces;\\n\\t\\t\\tvar vertices = geometry.vertices;\\n\\t\\t\\tvar faceVertexUvs = geometry.faceVertexUvs;\\n\\n\\t\\t\\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\\n\\t\\t\\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\\n\\n\\t\\t\\t// morphs\\n\\n\\t\\t\\tvar morphTargets = geometry.morphTargets;\\n\\t\\t\\tvar morphTargetsLength = morphTargets.length;\\n\\n\\t\\t\\tvar morphTargetsPosition;\\n\\n\\t\\t\\tif ( morphTargetsLength > 0 ) {\\n\\n\\t\\t\\t\\tmorphTargetsPosition = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\\n\\n\\t\\t\\t\\t\\tmorphTargetsPosition[ i ] = [];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.morphTargets.position = morphTargetsPosition;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar morphNormals = geometry.morphNormals;\\n\\t\\t\\tvar morphNormalsLength = morphNormals.length;\\n\\n\\t\\t\\tvar morphTargetsNormal;\\n\\n\\t\\t\\tif ( morphNormalsLength > 0 ) {\\n\\n\\t\\t\\t\\tmorphTargetsNormal = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\\n\\n\\t\\t\\t\\t\\tmorphTargetsNormal[ i ] = [];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.morphTargets.normal = morphTargetsNormal;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// skins\\n\\n\\t\\t\\tvar skinIndices = geometry.skinIndices;\\n\\t\\t\\tvar skinWeights = geometry.skinWeights;\\n\\n\\t\\t\\tvar hasSkinIndices = skinIndices.length === vertices.length;\\n\\t\\t\\tvar hasSkinWeights = skinWeights.length === vertices.length;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tfor ( var i = 0; i < faces.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\\n\\n\\t\\t\\t\\tvar vertexNormals = face.vertexNormals;\\n\\n\\t\\t\\t\\tif ( vertexNormals.length === 3 ) {\\n\\n\\t\\t\\t\\t\\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvar normal = face.normal;\\n\\n\\t\\t\\t\\t\\tthis.normals.push( normal, normal, normal );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar vertexColors = face.vertexColors;\\n\\n\\t\\t\\t\\tif ( vertexColors.length === 3 ) {\\n\\n\\t\\t\\t\\t\\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvar color = face.color;\\n\\n\\t\\t\\t\\t\\tthis.colors.push( color, color, color );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasFaceVertexUv === true ) {\\n\\n\\t\\t\\t\\t\\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\\n\\n\\t\\t\\t\\t\\tif ( vertexUvs !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\\n\\n\\t\\t\\t\\t\\t\\tthis.uvs.push( new Vector2(), new Vector2(), new Vector2() );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasFaceVertexUv2 === true ) {\\n\\n\\t\\t\\t\\t\\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\\n\\n\\t\\t\\t\\t\\tif ( vertexUvs !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\\n\\n\\t\\t\\t\\t\\t\\tthis.uvs2.push( new Vector2(), new Vector2(), new Vector2() );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// morphs\\n\\n\\t\\t\\t\\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\\n\\n\\t\\t\\t\\t\\tvar morphTarget = morphTargets[ j ].vertices;\\n\\n\\t\\t\\t\\t\\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\\n\\n\\t\\t\\t\\t\\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\\n\\n\\t\\t\\t\\t\\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// skins\\n\\n\\t\\t\\t\\tif ( hasSkinIndices ) {\\n\\n\\t\\t\\t\\t\\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( hasSkinWeights ) {\\n\\n\\t\\t\\t\\t\\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.computeGroups( geometry );\\n\\n\\t\\t\\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\\n\\t\\t\\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\\n\\t\\t\\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\\n\\t\\t\\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\\n\\t\\t\\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction arrayMax( array ) {\\n\\n\\t\\tif ( array.length === 0 ) return - Infinity;\\n\\n\\t\\tvar max = array[ 0 ];\\n\\n\\t\\tfor ( var i = 1, l = array.length; i < l; ++ i ) {\\n\\n\\t\\t\\tif ( array[ i ] > max ) max = array[ i ];\\n\\n\\t\\t}\\n\\n\\t\\treturn max;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id\\n\\n\\tfunction BufferGeometry() {\\n\\n\\t\\tObject.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.name = '';\\n\\t\\tthis.type = 'BufferGeometry';\\n\\n\\t\\tthis.index = null;\\n\\t\\tthis.attributes = {};\\n\\n\\t\\tthis.morphAttributes = {};\\n\\n\\t\\tthis.groups = [];\\n\\n\\t\\tthis.boundingBox = null;\\n\\t\\tthis.boundingSphere = null;\\n\\n\\t\\tthis.drawRange = { start: 0, count: Infinity };\\n\\n\\t}\\n\\n\\tBufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: BufferGeometry,\\n\\n\\t\\tisBufferGeometry: true,\\n\\n\\t\\tgetIndex: function () {\\n\\n\\t\\t\\treturn this.index;\\n\\n\\t\\t},\\n\\n\\t\\tsetIndex: function ( index ) {\\n\\n\\t\\t\\tif ( Array.isArray( index ) ) {\\n\\n\\t\\t\\t\\tthis.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.index = index;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\taddAttribute: function ( name, attribute ) {\\n\\n\\t\\t\\tif ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\\n\\n\\t\\t\\t\\tthis.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\\n\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( name === 'index' ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\\n\\t\\t\\t\\tthis.setIndex( attribute );\\n\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.attributes[ name ] = attribute;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetAttribute: function ( name ) {\\n\\n\\t\\t\\treturn this.attributes[ name ];\\n\\n\\t\\t},\\n\\n\\t\\tremoveAttribute: function ( name ) {\\n\\n\\t\\t\\tdelete this.attributes[ name ];\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddGroup: function ( start, count, materialIndex ) {\\n\\n\\t\\t\\tthis.groups.push( {\\n\\n\\t\\t\\t\\tstart: start,\\n\\t\\t\\t\\tcount: count,\\n\\t\\t\\t\\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\\n\\n\\t\\t\\t} );\\n\\n\\t\\t},\\n\\n\\t\\tclearGroups: function () {\\n\\n\\t\\t\\tthis.groups = [];\\n\\n\\t\\t},\\n\\n\\t\\tsetDrawRange: function ( start, count ) {\\n\\n\\t\\t\\tthis.drawRange.start = start;\\n\\t\\t\\tthis.drawRange.count = count;\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix: function ( matrix ) {\\n\\n\\t\\t\\tvar position = this.attributes.position;\\n\\n\\t\\t\\tif ( position !== undefined ) {\\n\\n\\t\\t\\t\\tmatrix.applyToBufferAttribute( position );\\n\\t\\t\\t\\tposition.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar normal = this.attributes.normal;\\n\\n\\t\\t\\tif ( normal !== undefined ) {\\n\\n\\t\\t\\t\\tvar normalMatrix = new Matrix3().getNormalMatrix( matrix );\\n\\n\\t\\t\\t\\tnormalMatrix.applyToBufferAttribute( normal );\\n\\t\\t\\t\\tnormal.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.boundingBox !== null ) {\\n\\n\\t\\t\\t\\tthis.computeBoundingBox();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tthis.computeBoundingSphere();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\trotateX: function () {\\n\\n\\t\\t\\t// rotate geometry around world x-axis\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function rotateX( angle ) {\\n\\n\\t\\t\\t\\tm1.makeRotationX( angle );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateY: function () {\\n\\n\\t\\t\\t// rotate geometry around world y-axis\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function rotateY( angle ) {\\n\\n\\t\\t\\t\\tm1.makeRotationY( angle );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\trotateZ: function () {\\n\\n\\t\\t\\t// rotate geometry around world z-axis\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function rotateZ( angle ) {\\n\\n\\t\\t\\t\\tm1.makeRotationZ( angle );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttranslate: function () {\\n\\n\\t\\t\\t// translate geometry\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function translate( x, y, z ) {\\n\\n\\t\\t\\t\\tm1.makeTranslation( x, y, z );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tscale: function () {\\n\\n\\t\\t\\t// scale geometry\\n\\n\\t\\t\\tvar m1 = new Matrix4();\\n\\n\\t\\t\\treturn function scale( x, y, z ) {\\n\\n\\t\\t\\t\\tm1.makeScale( x, y, z );\\n\\n\\t\\t\\t\\tthis.applyMatrix( m1 );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tlookAt: function () {\\n\\n\\t\\t\\tvar obj = new Object3D();\\n\\n\\t\\t\\treturn function lookAt( vector ) {\\n\\n\\t\\t\\t\\tobj.lookAt( vector );\\n\\n\\t\\t\\t\\tobj.updateMatrix();\\n\\n\\t\\t\\t\\tthis.applyMatrix( obj.matrix );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tcenter: function () {\\n\\n\\t\\t\\tthis.computeBoundingBox();\\n\\n\\t\\t\\tvar offset = this.boundingBox.getCenter().negate();\\n\\n\\t\\t\\tthis.translate( offset.x, offset.y, offset.z );\\n\\n\\t\\t\\treturn offset;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromObject: function ( object ) {\\n\\n\\t\\t\\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\\n\\n\\t\\t\\tvar geometry = object.geometry;\\n\\n\\t\\t\\tif ( object.isPoints || object.isLine ) {\\n\\n\\t\\t\\t\\tvar positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );\\n\\t\\t\\t\\tvar colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );\\n\\n\\t\\t\\t\\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\\n\\t\\t\\t\\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\\n\\n\\t\\t\\t\\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\\n\\n\\t\\t\\t\\t\\tvar lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );\\n\\n\\t\\t\\t\\t\\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( geometry.boundingSphere !== null ) {\\n\\n\\t\\t\\t\\t\\tthis.boundingSphere = geometry.boundingSphere.clone();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( geometry.boundingBox !== null ) {\\n\\n\\t\\t\\t\\t\\tthis.boundingBox = geometry.boundingBox.clone();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( object.isMesh ) {\\n\\n\\t\\t\\t\\tif ( geometry && geometry.isGeometry ) {\\n\\n\\t\\t\\t\\t\\tthis.fromGeometry( geometry );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromPoints: function ( points ) {\\n\\n\\t\\t\\tvar position = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar point = points[ i ];\\n\\t\\t\\t\\tposition.push( point.x, point.y, point.z || 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tupdateFromObject: function ( object ) {\\n\\n\\t\\t\\tvar geometry = object.geometry;\\n\\n\\t\\t\\tif ( object.isMesh ) {\\n\\n\\t\\t\\t\\tvar direct = geometry.__directGeometry;\\n\\n\\t\\t\\t\\tif ( geometry.elementsNeedUpdate === true ) {\\n\\n\\t\\t\\t\\t\\tdirect = undefined;\\n\\t\\t\\t\\t\\tgeometry.elementsNeedUpdate = false;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( direct === undefined ) {\\n\\n\\t\\t\\t\\t\\treturn this.fromGeometry( geometry );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\\n\\t\\t\\t\\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\\n\\t\\t\\t\\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\\n\\t\\t\\t\\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\\n\\t\\t\\t\\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\\n\\n\\t\\t\\t\\tgeometry.verticesNeedUpdate = false;\\n\\t\\t\\t\\tgeometry.normalsNeedUpdate = false;\\n\\t\\t\\t\\tgeometry.colorsNeedUpdate = false;\\n\\t\\t\\t\\tgeometry.uvsNeedUpdate = false;\\n\\t\\t\\t\\tgeometry.groupsNeedUpdate = false;\\n\\n\\t\\t\\t\\tgeometry = direct;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar attribute;\\n\\n\\t\\t\\tif ( geometry.verticesNeedUpdate === true ) {\\n\\n\\t\\t\\t\\tattribute = this.attributes.position;\\n\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\tattribute.copyVector3sArray( geometry.vertices );\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.verticesNeedUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.normalsNeedUpdate === true ) {\\n\\n\\t\\t\\t\\tattribute = this.attributes.normal;\\n\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\tattribute.copyVector3sArray( geometry.normals );\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.normalsNeedUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.colorsNeedUpdate === true ) {\\n\\n\\t\\t\\t\\tattribute = this.attributes.color;\\n\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\tattribute.copyColorsArray( geometry.colors );\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.colorsNeedUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.uvsNeedUpdate ) {\\n\\n\\t\\t\\t\\tattribute = this.attributes.uv;\\n\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\tattribute.copyVector2sArray( geometry.uvs );\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.uvsNeedUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.lineDistancesNeedUpdate ) {\\n\\n\\t\\t\\t\\tattribute = this.attributes.lineDistance;\\n\\n\\t\\t\\t\\tif ( attribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\tattribute.copyArray( geometry.lineDistances );\\n\\t\\t\\t\\t\\tattribute.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.lineDistancesNeedUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.groupsNeedUpdate ) {\\n\\n\\t\\t\\t\\tgeometry.computeGroups( object.geometry );\\n\\t\\t\\t\\tthis.groups = geometry.groups;\\n\\n\\t\\t\\t\\tgeometry.groupsNeedUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tfromGeometry: function ( geometry ) {\\n\\n\\t\\t\\tgeometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );\\n\\n\\t\\t\\treturn this.fromDirectGeometry( geometry.__directGeometry );\\n\\n\\t\\t},\\n\\n\\t\\tfromDirectGeometry: function ( geometry ) {\\n\\n\\t\\t\\tvar positions = new Float32Array( geometry.vertices.length * 3 );\\n\\t\\t\\tthis.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\\n\\n\\t\\t\\tif ( geometry.normals.length > 0 ) {\\n\\n\\t\\t\\t\\tvar normals = new Float32Array( geometry.normals.length * 3 );\\n\\t\\t\\t\\tthis.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.colors.length > 0 ) {\\n\\n\\t\\t\\t\\tvar colors = new Float32Array( geometry.colors.length * 3 );\\n\\t\\t\\t\\tthis.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.uvs.length > 0 ) {\\n\\n\\t\\t\\t\\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\\n\\t\\t\\t\\tthis.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.uvs2.length > 0 ) {\\n\\n\\t\\t\\t\\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\\n\\t\\t\\t\\tthis.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.indices.length > 0 ) {\\n\\n\\t\\t\\t\\tvar TypeArray = arrayMax( geometry.indices ) > 65535 ? Uint32Array : Uint16Array;\\n\\t\\t\\t\\tvar indices = new TypeArray( geometry.indices.length * 3 );\\n\\t\\t\\t\\tthis.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// groups\\n\\n\\t\\t\\tthis.groups = geometry.groups;\\n\\n\\t\\t\\t// morphs\\n\\n\\t\\t\\tfor ( var name in geometry.morphTargets ) {\\n\\n\\t\\t\\t\\tvar array = [];\\n\\t\\t\\t\\tvar morphTargets = geometry.morphTargets[ name ];\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar morphTarget = morphTargets[ i ];\\n\\n\\t\\t\\t\\t\\tvar attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );\\n\\n\\t\\t\\t\\t\\tarray.push( attribute.copyVector3sArray( morphTarget ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.morphAttributes[ name ] = array;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// skinning\\n\\n\\t\\t\\tif ( geometry.skinIndices.length > 0 ) {\\n\\n\\t\\t\\t\\tvar skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );\\n\\t\\t\\t\\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.skinWeights.length > 0 ) {\\n\\n\\t\\t\\t\\tvar skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );\\n\\t\\t\\t\\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tif ( geometry.boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingSphere = geometry.boundingSphere.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry.boundingBox !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingBox = geometry.boundingBox.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcomputeBoundingBox: function () {\\n\\n\\t\\t\\tif ( this.boundingBox === null ) {\\n\\n\\t\\t\\t\\tthis.boundingBox = new Box3();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar position = this.attributes.position;\\n\\n\\t\\t\\tif ( position !== undefined ) {\\n\\n\\t\\t\\t\\tthis.boundingBox.setFromBufferAttribute( position );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.boundingBox.makeEmpty();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \\\"position\\\" attribute is likely to have NaN values.', this );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tcomputeBoundingSphere: function () {\\n\\n\\t\\t\\tvar box = new Box3();\\n\\t\\t\\tvar vector = new Vector3();\\n\\n\\t\\t\\treturn function computeBoundingSphere() {\\n\\n\\t\\t\\t\\tif ( this.boundingSphere === null ) {\\n\\n\\t\\t\\t\\t\\tthis.boundingSphere = new Sphere();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar position = this.attributes.position;\\n\\n\\t\\t\\t\\tif ( position ) {\\n\\n\\t\\t\\t\\t\\tvar center = this.boundingSphere.center;\\n\\n\\t\\t\\t\\t\\tbox.setFromBufferAttribute( position );\\n\\t\\t\\t\\t\\tbox.getCenter( center );\\n\\n\\t\\t\\t\\t\\t// hoping to find a boundingSphere with a radius smaller than the\\n\\t\\t\\t\\t\\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\\n\\n\\t\\t\\t\\t\\tvar maxRadiusSq = 0;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = position.count; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvector.x = position.getX( i );\\n\\t\\t\\t\\t\\t\\tvector.y = position.getY( i );\\n\\t\\t\\t\\t\\t\\tvector.z = position.getZ( i );\\n\\t\\t\\t\\t\\t\\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\\n\\n\\t\\t\\t\\t\\tif ( isNaN( this.boundingSphere.radius ) ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \\\"position\\\" attribute is likely to have NaN values.', this );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tcomputeFaceNormals: function () {\\n\\n\\t\\t\\t// backwards compatibility\\n\\n\\t\\t},\\n\\n\\t\\tcomputeVertexNormals: function () {\\n\\n\\t\\t\\tvar index = this.index;\\n\\t\\t\\tvar attributes = this.attributes;\\n\\t\\t\\tvar groups = this.groups;\\n\\n\\t\\t\\tif ( attributes.position ) {\\n\\n\\t\\t\\t\\tvar positions = attributes.position.array;\\n\\n\\t\\t\\t\\tif ( attributes.normal === undefined ) {\\n\\n\\t\\t\\t\\t\\tthis.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// reset existing normals to zero\\n\\n\\t\\t\\t\\t\\tvar array = attributes.normal.array;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tarray[ i ] = 0;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar normals = attributes.normal.array;\\n\\n\\t\\t\\t\\tvar vA, vB, vC;\\n\\t\\t\\t\\tvar pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\\n\\t\\t\\t\\tvar cb = new Vector3(), ab = new Vector3();\\n\\n\\t\\t\\t\\t// indexed elements\\n\\n\\t\\t\\t\\tif ( index ) {\\n\\n\\t\\t\\t\\t\\tvar indices = index.array;\\n\\n\\t\\t\\t\\t\\tif ( groups.length === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.addGroup( 0, indices.length );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\tvar group = groups[ j ];\\n\\n\\t\\t\\t\\t\\t\\tvar start = group.start;\\n\\t\\t\\t\\t\\t\\tvar count = group.count;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvA = indices[ i + 0 ] * 3;\\n\\t\\t\\t\\t\\t\\t\\tvB = indices[ i + 1 ] * 3;\\n\\t\\t\\t\\t\\t\\t\\tvC = indices[ i + 2 ] * 3;\\n\\n\\t\\t\\t\\t\\t\\t\\tpA.fromArray( positions, vA );\\n\\t\\t\\t\\t\\t\\t\\tpB.fromArray( positions, vB );\\n\\t\\t\\t\\t\\t\\t\\tpC.fromArray( positions, vC );\\n\\n\\t\\t\\t\\t\\t\\t\\tcb.subVectors( pC, pB );\\n\\t\\t\\t\\t\\t\\t\\tab.subVectors( pA, pB );\\n\\t\\t\\t\\t\\t\\t\\tcb.cross( ab );\\n\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vA ] += cb.x;\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vA + 1 ] += cb.y;\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vA + 2 ] += cb.z;\\n\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vB ] += cb.x;\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vB + 1 ] += cb.y;\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vB + 2 ] += cb.z;\\n\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vC ] += cb.x;\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vC + 1 ] += cb.y;\\n\\t\\t\\t\\t\\t\\t\\tnormals[ vC + 2 ] += cb.z;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// non-indexed elements (unconnected triangle soup)\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\\n\\n\\t\\t\\t\\t\\t\\tpA.fromArray( positions, i );\\n\\t\\t\\t\\t\\t\\tpB.fromArray( positions, i + 3 );\\n\\t\\t\\t\\t\\t\\tpC.fromArray( positions, i + 6 );\\n\\n\\t\\t\\t\\t\\t\\tcb.subVectors( pC, pB );\\n\\t\\t\\t\\t\\t\\tab.subVectors( pA, pB );\\n\\t\\t\\t\\t\\t\\tcb.cross( ab );\\n\\n\\t\\t\\t\\t\\t\\tnormals[ i ] = cb.x;\\n\\t\\t\\t\\t\\t\\tnormals[ i + 1 ] = cb.y;\\n\\t\\t\\t\\t\\t\\tnormals[ i + 2 ] = cb.z;\\n\\n\\t\\t\\t\\t\\t\\tnormals[ i + 3 ] = cb.x;\\n\\t\\t\\t\\t\\t\\tnormals[ i + 4 ] = cb.y;\\n\\t\\t\\t\\t\\t\\tnormals[ i + 5 ] = cb.z;\\n\\n\\t\\t\\t\\t\\t\\tnormals[ i + 6 ] = cb.x;\\n\\t\\t\\t\\t\\t\\tnormals[ i + 7 ] = cb.y;\\n\\t\\t\\t\\t\\t\\tnormals[ i + 8 ] = cb.z;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.normalizeNormals();\\n\\n\\t\\t\\t\\tattributes.normal.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tmerge: function ( geometry, offset ) {\\n\\n\\t\\t\\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tvar attributes = this.attributes;\\n\\n\\t\\t\\tfor ( var key in attributes ) {\\n\\n\\t\\t\\t\\tif ( geometry.attributes[ key ] === undefined ) continue;\\n\\n\\t\\t\\t\\tvar attribute1 = attributes[ key ];\\n\\t\\t\\t\\tvar attributeArray1 = attribute1.array;\\n\\n\\t\\t\\t\\tvar attribute2 = geometry.attributes[ key ];\\n\\t\\t\\t\\tvar attributeArray2 = attribute2.array;\\n\\n\\t\\t\\t\\tvar attributeSize = attribute2.itemSize;\\n\\n\\t\\t\\t\\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\\n\\n\\t\\t\\t\\t\\tattributeArray1[ j ] = attributeArray2[ i ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tnormalizeNormals: function () {\\n\\n\\t\\t\\tvar vector = new Vector3();\\n\\n\\t\\t\\treturn function normalizeNormals() {\\n\\n\\t\\t\\t\\tvar normals = this.attributes.normal;\\n\\n\\t\\t\\t\\tfor ( var i = 0, il = normals.count; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvector.x = normals.getX( i );\\n\\t\\t\\t\\t\\tvector.y = normals.getY( i );\\n\\t\\t\\t\\t\\tvector.z = normals.getZ( i );\\n\\n\\t\\t\\t\\t\\tvector.normalize();\\n\\n\\t\\t\\t\\t\\tnormals.setXYZ( i, vector.x, vector.y, vector.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttoNonIndexed: function () {\\n\\n\\t\\t\\tif ( this.index === null ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar geometry2 = new BufferGeometry();\\n\\n\\t\\t\\tvar indices = this.index.array;\\n\\t\\t\\tvar attributes = this.attributes;\\n\\n\\t\\t\\tfor ( var name in attributes ) {\\n\\n\\t\\t\\t\\tvar attribute = attributes[ name ];\\n\\n\\t\\t\\t\\tvar array = attribute.array;\\n\\t\\t\\t\\tvar itemSize = attribute.itemSize;\\n\\n\\t\\t\\t\\tvar array2 = new array.constructor( indices.length * itemSize );\\n\\n\\t\\t\\t\\tvar index = 0, index2 = 0;\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tindex = indices[ i ] * itemSize;\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0; j < itemSize; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tarray2[ index2 ++ ] = array[ index ++ ];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn geometry2;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar data = {\\n\\t\\t\\t\\tmetadata: {\\n\\t\\t\\t\\t\\tversion: 4.5,\\n\\t\\t\\t\\t\\ttype: 'BufferGeometry',\\n\\t\\t\\t\\t\\tgenerator: 'BufferGeometry.toJSON'\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t\\t// standard BufferGeometry serialization\\n\\n\\t\\t\\tdata.uuid = this.uuid;\\n\\t\\t\\tdata.type = this.type;\\n\\t\\t\\tif ( this.name !== '' ) data.name = this.name;\\n\\n\\t\\t\\tif ( this.parameters !== undefined ) {\\n\\n\\t\\t\\t\\tvar parameters = this.parameters;\\n\\n\\t\\t\\t\\tfor ( var key in parameters ) {\\n\\n\\t\\t\\t\\t\\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn data;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tdata.data = { attributes: {} };\\n\\n\\t\\t\\tvar index = this.index;\\n\\n\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\tvar array = Array.prototype.slice.call( index.array );\\n\\n\\t\\t\\t\\tdata.data.index = {\\n\\t\\t\\t\\t\\ttype: index.array.constructor.name,\\n\\t\\t\\t\\t\\tarray: array\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar attributes = this.attributes;\\n\\n\\t\\t\\tfor ( var key in attributes ) {\\n\\n\\t\\t\\t\\tvar attribute = attributes[ key ];\\n\\n\\t\\t\\t\\tvar array = Array.prototype.slice.call( attribute.array );\\n\\n\\t\\t\\t\\tdata.data.attributes[ key ] = {\\n\\t\\t\\t\\t\\titemSize: attribute.itemSize,\\n\\t\\t\\t\\t\\ttype: attribute.array.constructor.name,\\n\\t\\t\\t\\t\\tarray: array,\\n\\t\\t\\t\\t\\tnormalized: attribute.normalized\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar groups = this.groups;\\n\\n\\t\\t\\tif ( groups.length > 0 ) {\\n\\n\\t\\t\\t\\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar boundingSphere = this.boundingSphere;\\n\\n\\t\\t\\tif ( boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tdata.data.boundingSphere = {\\n\\t\\t\\t\\t\\tcenter: boundingSphere.center.toArray(),\\n\\t\\t\\t\\t\\tradius: boundingSphere.radius\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\t/*\\n\\t\\t\\t // Handle primitives\\n\\n\\t\\t\\t var parameters = this.parameters;\\n\\n\\t\\t\\t if ( parameters !== undefined ) {\\n\\n\\t\\t\\t var values = [];\\n\\n\\t\\t\\t for ( var key in parameters ) {\\n\\n\\t\\t\\t values.push( parameters[ key ] );\\n\\n\\t\\t\\t }\\n\\n\\t\\t\\t var geometry = Object.create( this.constructor.prototype );\\n\\t\\t\\t this.constructor.apply( geometry, values );\\n\\t\\t\\t return geometry;\\n\\n\\t\\t\\t }\\n\\n\\t\\t\\t return new this.constructor().copy( this );\\n\\t\\t\\t */\\n\\n\\t\\t\\treturn new BufferGeometry().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tvar name, i, l;\\n\\n\\t\\t\\t// reset\\n\\n\\t\\t\\tthis.index = null;\\n\\t\\t\\tthis.attributes = {};\\n\\t\\t\\tthis.morphAttributes = {};\\n\\t\\t\\tthis.groups = [];\\n\\t\\t\\tthis.boundingBox = null;\\n\\t\\t\\tthis.boundingSphere = null;\\n\\n\\t\\t\\t// name\\n\\n\\t\\t\\tthis.name = source.name;\\n\\n\\t\\t\\t// index\\n\\n\\t\\t\\tvar index = source.index;\\n\\n\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\tthis.setIndex( index.clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// attributes\\n\\n\\t\\t\\tvar attributes = source.attributes;\\n\\n\\t\\t\\tfor ( name in attributes ) {\\n\\n\\t\\t\\t\\tvar attribute = attributes[ name ];\\n\\t\\t\\t\\tthis.addAttribute( name, attribute.clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// morph attributes\\n\\n\\t\\t\\tvar morphAttributes = source.morphAttributes;\\n\\n\\t\\t\\tfor ( name in morphAttributes ) {\\n\\n\\t\\t\\t\\tvar array = [];\\n\\t\\t\\t\\tvar morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\\n\\n\\t\\t\\t\\tfor ( i = 0, l = morphAttribute.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tarray.push( morphAttribute[ i ].clone() );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.morphAttributes[ name ] = array;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// groups\\n\\n\\t\\t\\tvar groups = source.groups;\\n\\n\\t\\t\\tfor ( i = 0, l = groups.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar group = groups[ i ];\\n\\t\\t\\t\\tthis.addGroup( group.start, group.count, group.materialIndex );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// bounding box\\n\\n\\t\\t\\tvar boundingBox = source.boundingBox;\\n\\n\\t\\t\\tif ( boundingBox !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingBox = boundingBox.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// bounding sphere\\n\\n\\t\\t\\tvar boundingSphere = source.boundingSphere;\\n\\n\\t\\t\\tif ( boundingSphere !== null ) {\\n\\n\\t\\t\\t\\tthis.boundingSphere = boundingSphere.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// draw range\\n\\n\\t\\t\\tthis.drawRange.start = source.drawRange.start;\\n\\t\\t\\tthis.drawRange.count = source.drawRange.count;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdispose: function () {\\n\\n\\t\\t\\tthis.dispatchEvent( { type: 'dispose' } );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// BoxGeometry\\n\\n\\tfunction BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'BoxGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\twidth: width,\\n\\t\\t\\theight: height,\\n\\t\\t\\tdepth: depth,\\n\\t\\t\\twidthSegments: widthSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\tdepthSegments: depthSegments\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tBoxGeometry.prototype = Object.create( Geometry.prototype );\\n\\tBoxGeometry.prototype.constructor = BoxGeometry;\\n\\n\\t// BoxBufferGeometry\\n\\n\\tfunction BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'BoxBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\twidth: width,\\n\\t\\t\\theight: height,\\n\\t\\t\\tdepth: depth,\\n\\t\\t\\twidthSegments: widthSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\tdepthSegments: depthSegments\\n\\t\\t};\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\twidth = width || 1;\\n\\t\\theight = height || 1;\\n\\t\\tdepth = depth || 1;\\n\\n\\t\\t// segments\\n\\n\\t\\twidthSegments = Math.floor( widthSegments ) || 1;\\n\\t\\theightSegments = Math.floor( heightSegments ) || 1;\\n\\t\\tdepthSegments = Math.floor( depthSegments ) || 1;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar numberOfVertices = 0;\\n\\t\\tvar groupStart = 0;\\n\\n\\t\\t// build each side of the box geometry\\n\\n\\t\\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\\n\\t\\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\\n\\t\\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\\n\\t\\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\\n\\t\\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\\n\\t\\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t\\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\\n\\n\\t\\t\\tvar segmentWidth = width / gridX;\\n\\t\\t\\tvar segmentHeight = height / gridY;\\n\\n\\t\\t\\tvar widthHalf = width / 2;\\n\\t\\t\\tvar heightHalf = height / 2;\\n\\t\\t\\tvar depthHalf = depth / 2;\\n\\n\\t\\t\\tvar gridX1 = gridX + 1;\\n\\t\\t\\tvar gridY1 = gridY + 1;\\n\\n\\t\\t\\tvar vertexCounter = 0;\\n\\t\\t\\tvar groupCount = 0;\\n\\n\\t\\t\\tvar ix, iy;\\n\\n\\t\\t\\tvar vector = new Vector3();\\n\\n\\t\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\t\\tfor ( iy = 0; iy < gridY1; iy ++ ) {\\n\\n\\t\\t\\t\\tvar y = iy * segmentHeight - heightHalf;\\n\\n\\t\\t\\t\\tfor ( ix = 0; ix < gridX1; ix ++ ) {\\n\\n\\t\\t\\t\\t\\tvar x = ix * segmentWidth - widthHalf;\\n\\n\\t\\t\\t\\t\\t// set values to correct vector component\\n\\n\\t\\t\\t\\t\\tvector[ u ] = x * udir;\\n\\t\\t\\t\\t\\tvector[ v ] = y * vdir;\\n\\t\\t\\t\\t\\tvector[ w ] = depthHalf;\\n\\n\\t\\t\\t\\t\\t// now apply vector to vertex buffer\\n\\n\\t\\t\\t\\t\\tvertices.push( vector.x, vector.y, vector.z );\\n\\n\\t\\t\\t\\t\\t// set values to correct vector component\\n\\n\\t\\t\\t\\t\\tvector[ u ] = 0;\\n\\t\\t\\t\\t\\tvector[ v ] = 0;\\n\\t\\t\\t\\t\\tvector[ w ] = depth > 0 ? 1 : - 1;\\n\\n\\t\\t\\t\\t\\t// now apply vector to normal buffer\\n\\n\\t\\t\\t\\t\\tnormals.push( vector.x, vector.y, vector.z );\\n\\n\\t\\t\\t\\t\\t// uvs\\n\\n\\t\\t\\t\\t\\tuvs.push( ix / gridX );\\n\\t\\t\\t\\t\\tuvs.push( 1 - ( iy / gridY ) );\\n\\n\\t\\t\\t\\t\\t// counters\\n\\n\\t\\t\\t\\t\\tvertexCounter += 1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// indices\\n\\n\\t\\t\\t// 1. you need three indices to draw a single face\\n\\t\\t\\t// 2. a single segment consists of two faces\\n\\t\\t\\t// 3. so we need to generate six (2*3) indices per segment\\n\\n\\t\\t\\tfor ( iy = 0; iy < gridY; iy ++ ) {\\n\\n\\t\\t\\t\\tfor ( ix = 0; ix < gridX; ix ++ ) {\\n\\n\\t\\t\\t\\t\\tvar a = numberOfVertices + ix + gridX1 * iy;\\n\\t\\t\\t\\t\\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\\n\\t\\t\\t\\t\\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\\n\\t\\t\\t\\t\\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\\n\\n\\t\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t\\t\\t// increase counter\\n\\n\\t\\t\\t\\t\\tgroupCount += 6;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// add a group to the geometry. this will ensure multi material support\\n\\n\\t\\t\\tscope.addGroup( groupStart, groupCount, materialIndex );\\n\\n\\t\\t\\t// calculate new start value for groups\\n\\n\\t\\t\\tgroupStart += groupCount;\\n\\n\\t\\t\\t// update total number of vertices\\n\\n\\t\\t\\tnumberOfVertices += vertexCounter;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tBoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tBoxBufferGeometry.prototype.constructor = BoxBufferGeometry;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// PlaneGeometry\\n\\n\\tfunction PlaneGeometry( width, height, widthSegments, heightSegments ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'PlaneGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\twidth: width,\\n\\t\\t\\theight: height,\\n\\t\\t\\twidthSegments: widthSegments,\\n\\t\\t\\theightSegments: heightSegments\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tPlaneGeometry.prototype = Object.create( Geometry.prototype );\\n\\tPlaneGeometry.prototype.constructor = PlaneGeometry;\\n\\n\\t// PlaneBufferGeometry\\n\\n\\tfunction PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'PlaneBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\twidth: width,\\n\\t\\t\\theight: height,\\n\\t\\t\\twidthSegments: widthSegments,\\n\\t\\t\\theightSegments: heightSegments\\n\\t\\t};\\n\\n\\t\\twidth = width || 1;\\n\\t\\theight = height || 1;\\n\\n\\t\\tvar width_half = width / 2;\\n\\t\\tvar height_half = height / 2;\\n\\n\\t\\tvar gridX = Math.floor( widthSegments ) || 1;\\n\\t\\tvar gridY = Math.floor( heightSegments ) || 1;\\n\\n\\t\\tvar gridX1 = gridX + 1;\\n\\t\\tvar gridY1 = gridY + 1;\\n\\n\\t\\tvar segment_width = width / gridX;\\n\\t\\tvar segment_height = height / gridY;\\n\\n\\t\\tvar ix, iy;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\tfor ( iy = 0; iy < gridY1; iy ++ ) {\\n\\n\\t\\t\\tvar y = iy * segment_height - height_half;\\n\\n\\t\\t\\tfor ( ix = 0; ix < gridX1; ix ++ ) {\\n\\n\\t\\t\\t\\tvar x = ix * segment_width - width_half;\\n\\n\\t\\t\\t\\tvertices.push( x, - y, 0 );\\n\\n\\t\\t\\t\\tnormals.push( 0, 0, 1 );\\n\\n\\t\\t\\t\\tuvs.push( ix / gridX );\\n\\t\\t\\t\\tuvs.push( 1 - ( iy / gridY ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// indices\\n\\n\\t\\tfor ( iy = 0; iy < gridY; iy ++ ) {\\n\\n\\t\\t\\tfor ( ix = 0; ix < gridX; ix ++ ) {\\n\\n\\t\\t\\t\\tvar a = ix + gridX1 * iy;\\n\\t\\t\\t\\tvar b = ix + gridX1 * ( iy + 1 );\\n\\t\\t\\t\\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\\n\\t\\t\\t\\tvar d = ( ix + 1 ) + gridX1 * iy;\\n\\n\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t}\\n\\n\\tPlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tPlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  opacity: <float>,\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  lightMap: new THREE.Texture( <Image> ),\\n\\t *  lightMapIntensity: <float>\\n\\t *\\n\\t *  aoMap: new THREE.Texture( <Image> ),\\n\\t *  aoMapIntensity: <float>\\n\\t *\\n\\t *  specularMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\\n\\t *  combine: THREE.Multiply,\\n\\t *  reflectivity: <float>,\\n\\t *  refractionRatio: <float>,\\n\\t *\\n\\t *  depthTest: <bool>,\\n\\t *  depthWrite: <bool>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>,\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshBasicMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'MeshBasicMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff ); // emissive\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.lightMap = null;\\n\\t\\tthis.lightMapIntensity = 1.0;\\n\\n\\t\\tthis.aoMap = null;\\n\\t\\tthis.aoMapIntensity = 1.0;\\n\\n\\t\\tthis.specularMap = null;\\n\\n\\t\\tthis.alphaMap = null;\\n\\n\\t\\tthis.envMap = null;\\n\\t\\tthis.combine = MultiplyOperation;\\n\\t\\tthis.reflectivity = 1;\\n\\t\\tthis.refractionRatio = 0.98;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\t\\tthis.wireframeLinecap = 'round';\\n\\t\\tthis.wireframeLinejoin = 'round';\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshBasicMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshBasicMaterial.prototype.constructor = MeshBasicMaterial;\\n\\n\\tMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\\n\\n\\tMeshBasicMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.color.copy( source.color );\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.lightMap = source.lightMap;\\n\\t\\tthis.lightMapIntensity = source.lightMapIntensity;\\n\\n\\t\\tthis.aoMap = source.aoMap;\\n\\t\\tthis.aoMapIntensity = source.aoMapIntensity;\\n\\n\\t\\tthis.specularMap = source.specularMap;\\n\\n\\t\\tthis.alphaMap = source.alphaMap;\\n\\n\\t\\tthis.envMap = source.envMap;\\n\\t\\tthis.combine = source.combine;\\n\\t\\tthis.reflectivity = source.reflectivity;\\n\\t\\tthis.refractionRatio = source.refractionRatio;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\t\\tthis.wireframeLinecap = source.wireframeLinecap;\\n\\t\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  defines: { \\\"label\\\" : \\\"value\\\" },\\n\\t *  uniforms: { \\\"parameter1\\\": { value: 1.0 }, \\\"parameter2\\\": { value2: 2 } },\\n\\t *\\n\\t *  fragmentShader: <string>,\\n\\t *  vertexShader: <string>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>,\\n\\t *\\n\\t *  lights: <bool>,\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>,\\n\\t *  morphNormals: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction ShaderMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'ShaderMaterial';\\n\\n\\t\\tthis.defines = {};\\n\\t\\tthis.uniforms = {};\\n\\n\\t\\tthis.vertexShader = 'void main() {\\\\n\\\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\\n}';\\n\\t\\tthis.fragmentShader = 'void main() {\\\\n\\\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\\\n}';\\n\\n\\t\\tthis.linewidth = 1;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\n\\t\\tthis.fog = false; // set to use scene fog\\n\\t\\tthis.lights = false; // set to use scene lights\\n\\t\\tthis.clipping = false; // set to use user-defined clipping planes\\n\\n\\t\\tthis.skinning = false; // set to use skinning attribute streams\\n\\t\\tthis.morphTargets = false; // set to use morph targets\\n\\t\\tthis.morphNormals = false; // set to use morph normals\\n\\n\\t\\tthis.extensions = {\\n\\t\\t\\tderivatives: false, // set to use derivatives\\n\\t\\t\\tfragDepth: false, // set to use fragment depth values\\n\\t\\t\\tdrawBuffers: false, // set to use draw buffers\\n\\t\\t\\tshaderTextureLOD: false // set to use shader texture LOD\\n\\t\\t};\\n\\n\\t\\t// When rendered geometry doesn't include these attributes but the material does,\\n\\t\\t// use these default values in WebGL. This avoids errors when buffer data is missing.\\n\\t\\tthis.defaultAttributeValues = {\\n\\t\\t\\t'color': [ 1, 1, 1 ],\\n\\t\\t\\t'uv': [ 0, 0 ],\\n\\t\\t\\t'uv2': [ 0, 0 ]\\n\\t\\t};\\n\\n\\t\\tthis.index0AttributeName = undefined;\\n\\n\\t\\tif ( parameters !== undefined ) {\\n\\n\\t\\t\\tif ( parameters.attributes !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.setValues( parameters );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tShaderMaterial.prototype = Object.create( Material.prototype );\\n\\tShaderMaterial.prototype.constructor = ShaderMaterial;\\n\\n\\tShaderMaterial.prototype.isShaderMaterial = true;\\n\\n\\tShaderMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.fragmentShader = source.fragmentShader;\\n\\t\\tthis.vertexShader = source.vertexShader;\\n\\n\\t\\tthis.uniforms = UniformsUtils.clone( source.uniforms );\\n\\n\\t\\tthis.defines = source.defines;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\n\\t\\tthis.lights = source.lights;\\n\\t\\tthis.clipping = source.clipping;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\t\\tthis.morphNormals = source.morphNormals;\\n\\n\\t\\tthis.extensions = source.extensions;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tShaderMaterial.prototype.toJSON = function ( meta ) {\\n\\n\\t\\tvar data = Material.prototype.toJSON.call( this, meta );\\n\\n\\t\\tdata.uniforms = this.uniforms;\\n\\t\\tdata.vertexShader = this.vertexShader;\\n\\t\\tdata.fragmentShader = this.fragmentShader;\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Ray( origin, direction ) {\\n\\n\\t\\tthis.origin = ( origin !== undefined ) ? origin : new Vector3();\\n\\t\\tthis.direction = ( direction !== undefined ) ? direction : new Vector3();\\n\\n\\t}\\n\\n\\tObject.assign( Ray.prototype, {\\n\\n\\t\\tset: function ( origin, direction ) {\\n\\n\\t\\t\\tthis.origin.copy( origin );\\n\\t\\t\\tthis.direction.copy( direction );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( ray ) {\\n\\n\\t\\t\\tthis.origin.copy( ray.origin );\\n\\t\\t\\tthis.direction.copy( ray.direction );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tat: function ( t, optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\\n\\n\\t\\t},\\n\\n\\t\\tlookAt: function ( v ) {\\n\\n\\t\\t\\tthis.direction.copy( v ).sub( this.origin ).normalize();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\trecast: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function recast( t ) {\\n\\n\\t\\t\\t\\tthis.origin.copy( this.at( t, v1 ) );\\n\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclosestPointToPoint: function ( point, optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\tresult.subVectors( point, this.origin );\\n\\t\\t\\tvar directionDistance = result.dot( this.direction );\\n\\n\\t\\t\\tif ( directionDistance < 0 ) {\\n\\n\\t\\t\\t\\treturn result.copy( this.origin );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToPoint: function ( point ) {\\n\\n\\t\\t\\treturn Math.sqrt( this.distanceSqToPoint( point ) );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceSqToPoint: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function distanceSqToPoint( point ) {\\n\\n\\t\\t\\t\\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\\n\\n\\t\\t\\t\\t// point behind the ray\\n\\n\\t\\t\\t\\tif ( directionDistance < 0 ) {\\n\\n\\t\\t\\t\\t\\treturn this.origin.distanceToSquared( point );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\\n\\n\\t\\t\\t\\treturn v1.distanceToSquared( point );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tdistanceSqToSegment: function () {\\n\\n\\t\\t\\tvar segCenter = new Vector3();\\n\\t\\t\\tvar segDir = new Vector3();\\n\\t\\t\\tvar diff = new Vector3();\\n\\n\\t\\t\\treturn function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\\n\\n\\t\\t\\t\\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\\n\\t\\t\\t\\t// It returns the min distance between the ray and the segment\\n\\t\\t\\t\\t// defined by v0 and v1\\n\\t\\t\\t\\t// It can also set two optional targets :\\n\\t\\t\\t\\t// - The closest point on the ray\\n\\t\\t\\t\\t// - The closest point on the segment\\n\\n\\t\\t\\t\\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\\n\\t\\t\\t\\tsegDir.copy( v1 ).sub( v0 ).normalize();\\n\\t\\t\\t\\tdiff.copy( this.origin ).sub( segCenter );\\n\\n\\t\\t\\t\\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\\n\\t\\t\\t\\tvar a01 = - this.direction.dot( segDir );\\n\\t\\t\\t\\tvar b0 = diff.dot( this.direction );\\n\\t\\t\\t\\tvar b1 = - diff.dot( segDir );\\n\\t\\t\\t\\tvar c = diff.lengthSq();\\n\\t\\t\\t\\tvar det = Math.abs( 1 - a01 * a01 );\\n\\t\\t\\t\\tvar s0, s1, sqrDist, extDet;\\n\\n\\t\\t\\t\\tif ( det > 0 ) {\\n\\n\\t\\t\\t\\t\\t// The ray and segment are not parallel.\\n\\n\\t\\t\\t\\t\\ts0 = a01 * b1 - b0;\\n\\t\\t\\t\\t\\ts1 = a01 * b0 - b1;\\n\\t\\t\\t\\t\\textDet = segExtent * det;\\n\\n\\t\\t\\t\\t\\tif ( s0 >= 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( s1 >= - extDet ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( s1 <= extDet ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// region 0\\n\\t\\t\\t\\t\\t\\t\\t\\t// Minimum at interior points of ray and segment.\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar invDet = 1 / det;\\n\\t\\t\\t\\t\\t\\t\\t\\ts0 *= invDet;\\n\\t\\t\\t\\t\\t\\t\\t\\ts1 *= invDet;\\n\\t\\t\\t\\t\\t\\t\\t\\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t// region 1\\n\\n\\t\\t\\t\\t\\t\\t\\t\\ts1 = segExtent;\\n\\t\\t\\t\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\\n\\t\\t\\t\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t// region 5\\n\\n\\t\\t\\t\\t\\t\\t\\ts1 = - segExtent;\\n\\t\\t\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\\n\\t\\t\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tif ( s1 <= - extDet ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// region 4\\n\\n\\t\\t\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\\n\\t\\t\\t\\t\\t\\t\\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\\n\\t\\t\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t\\t\\t} else if ( s1 <= extDet ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// region 3\\n\\n\\t\\t\\t\\t\\t\\t\\ts0 = 0;\\n\\t\\t\\t\\t\\t\\t\\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\\n\\t\\t\\t\\t\\t\\t\\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t// region 2\\n\\n\\t\\t\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\\n\\t\\t\\t\\t\\t\\t\\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\\n\\t\\t\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// Ray and segment are parallel.\\n\\n\\t\\t\\t\\t\\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\\n\\t\\t\\t\\t\\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\\n\\t\\t\\t\\t\\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( optionalPointOnRay ) {\\n\\n\\t\\t\\t\\t\\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( optionalPointOnSegment ) {\\n\\n\\t\\t\\t\\t\\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn sqrDist;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersectSphere: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function intersectSphere( sphere, optionalTarget ) {\\n\\n\\t\\t\\t\\tv1.subVectors( sphere.center, this.origin );\\n\\t\\t\\t\\tvar tca = v1.dot( this.direction );\\n\\t\\t\\t\\tvar d2 = v1.dot( v1 ) - tca * tca;\\n\\t\\t\\t\\tvar radius2 = sphere.radius * sphere.radius;\\n\\n\\t\\t\\t\\tif ( d2 > radius2 ) return null;\\n\\n\\t\\t\\t\\tvar thc = Math.sqrt( radius2 - d2 );\\n\\n\\t\\t\\t\\t// t0 = first intersect point - entrance on front of sphere\\n\\t\\t\\t\\tvar t0 = tca - thc;\\n\\n\\t\\t\\t\\t// t1 = second intersect point - exit point on back of sphere\\n\\t\\t\\t\\tvar t1 = tca + thc;\\n\\n\\t\\t\\t\\t// test to see if both t0 and t1 are behind the ray - if so, return null\\n\\t\\t\\t\\tif ( t0 < 0 && t1 < 0 ) return null;\\n\\n\\t\\t\\t\\t// test to see if t0 is behind the ray:\\n\\t\\t\\t\\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\\n\\t\\t\\t\\t// in order to always return an intersect point that is in front of the ray.\\n\\t\\t\\t\\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\\n\\n\\t\\t\\t\\t// else t0 is in front of the ray, so return the first collision point scaled by t0\\n\\t\\t\\t\\treturn this.at( t0, optionalTarget );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tintersectsSphere: function ( sphere ) {\\n\\n\\t\\t\\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\\n\\n\\t\\t},\\n\\n\\t\\tdistanceToPlane: function ( plane ) {\\n\\n\\t\\t\\tvar denominator = plane.normal.dot( this.direction );\\n\\n\\t\\t\\tif ( denominator === 0 ) {\\n\\n\\t\\t\\t\\t// line is coplanar, return origin\\n\\t\\t\\t\\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\\n\\n\\t\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Null is preferable to undefined since undefined means.... it is undefined\\n\\n\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\\n\\n\\t\\t\\t// Return if the ray never intersects the plane\\n\\n\\t\\t\\treturn t >= 0 ? t : null;\\n\\n\\t\\t},\\n\\n\\t\\tintersectPlane: function ( plane, optionalTarget ) {\\n\\n\\t\\t\\tvar t = this.distanceToPlane( plane );\\n\\n\\t\\t\\tif ( t === null ) {\\n\\n\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this.at( t, optionalTarget );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsPlane: function ( plane ) {\\n\\n\\t\\t\\t// check if the ray lies on the plane first\\n\\n\\t\\t\\tvar distToPoint = plane.distanceToPoint( this.origin );\\n\\n\\t\\t\\tif ( distToPoint === 0 ) {\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar denominator = plane.normal.dot( this.direction );\\n\\n\\t\\t\\tif ( denominator * distToPoint < 0 ) {\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// ray origin is behind the plane (and is pointing behind it)\\n\\n\\t\\t\\treturn false;\\n\\n\\t\\t},\\n\\n\\t\\tintersectBox: function ( box, optionalTarget ) {\\n\\n\\t\\t\\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\\n\\n\\t\\t\\tvar invdirx = 1 / this.direction.x,\\n\\t\\t\\t\\tinvdiry = 1 / this.direction.y,\\n\\t\\t\\t\\tinvdirz = 1 / this.direction.z;\\n\\n\\t\\t\\tvar origin = this.origin;\\n\\n\\t\\t\\tif ( invdirx >= 0 ) {\\n\\n\\t\\t\\t\\ttmin = ( box.min.x - origin.x ) * invdirx;\\n\\t\\t\\t\\ttmax = ( box.max.x - origin.x ) * invdirx;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\ttmin = ( box.max.x - origin.x ) * invdirx;\\n\\t\\t\\t\\ttmax = ( box.min.x - origin.x ) * invdirx;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( invdiry >= 0 ) {\\n\\n\\t\\t\\t\\ttymin = ( box.min.y - origin.y ) * invdiry;\\n\\t\\t\\t\\ttymax = ( box.max.y - origin.y ) * invdiry;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\ttymin = ( box.max.y - origin.y ) * invdiry;\\n\\t\\t\\t\\ttymax = ( box.min.y - origin.y ) * invdiry;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\\n\\n\\t\\t\\t// These lines also handle the case where tmin or tmax is NaN\\n\\t\\t\\t// (result of 0 * Infinity). x !== x returns true if x is NaN\\n\\n\\t\\t\\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\\n\\n\\t\\t\\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\\n\\n\\t\\t\\tif ( invdirz >= 0 ) {\\n\\n\\t\\t\\t\\ttzmin = ( box.min.z - origin.z ) * invdirz;\\n\\t\\t\\t\\ttzmax = ( box.max.z - origin.z ) * invdirz;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\ttzmin = ( box.max.z - origin.z ) * invdirz;\\n\\t\\t\\t\\ttzmax = ( box.min.z - origin.z ) * invdirz;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\\n\\n\\t\\t\\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\\n\\n\\t\\t\\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\\n\\n\\t\\t\\t//return point closest to the ray (positive side)\\n\\n\\t\\t\\tif ( tmax < 0 ) return null;\\n\\n\\t\\t\\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\\n\\n\\t\\t},\\n\\n\\t\\tintersectsBox: ( function () {\\n\\n\\t\\t\\tvar v = new Vector3();\\n\\n\\t\\t\\treturn function intersectsBox( box ) {\\n\\n\\t\\t\\t\\treturn this.intersectBox( box, v ) !== null;\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )(),\\n\\n\\t\\tintersectTriangle: function () {\\n\\n\\t\\t\\t// Compute the offset origin, edges, and normal.\\n\\t\\t\\tvar diff = new Vector3();\\n\\t\\t\\tvar edge1 = new Vector3();\\n\\t\\t\\tvar edge2 = new Vector3();\\n\\t\\t\\tvar normal = new Vector3();\\n\\n\\t\\t\\treturn function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {\\n\\n\\t\\t\\t\\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\\n\\n\\t\\t\\t\\tedge1.subVectors( b, a );\\n\\t\\t\\t\\tedge2.subVectors( c, a );\\n\\t\\t\\t\\tnormal.crossVectors( edge1, edge2 );\\n\\n\\t\\t\\t\\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\\n\\t\\t\\t\\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\\n\\t\\t\\t\\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\\n\\t\\t\\t\\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\\n\\t\\t\\t\\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\\n\\t\\t\\t\\tvar DdN = this.direction.dot( normal );\\n\\t\\t\\t\\tvar sign;\\n\\n\\t\\t\\t\\tif ( DdN > 0 ) {\\n\\n\\t\\t\\t\\t\\tif ( backfaceCulling ) return null;\\n\\t\\t\\t\\t\\tsign = 1;\\n\\n\\t\\t\\t\\t} else if ( DdN < 0 ) {\\n\\n\\t\\t\\t\\t\\tsign = - 1;\\n\\t\\t\\t\\t\\tDdN = - DdN;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdiff.subVectors( this.origin, a );\\n\\t\\t\\t\\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\\n\\n\\t\\t\\t\\t// b1 < 0, no intersection\\n\\t\\t\\t\\tif ( DdQxE2 < 0 ) {\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\\n\\n\\t\\t\\t\\t// b2 < 0, no intersection\\n\\t\\t\\t\\tif ( DdE1xQ < 0 ) {\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// b1+b2 > 1, no intersection\\n\\t\\t\\t\\tif ( DdQxE2 + DdE1xQ > DdN ) {\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Line intersects triangle, check if ray does.\\n\\t\\t\\t\\tvar QdN = - sign * diff.dot( normal );\\n\\n\\t\\t\\t\\t// t < 0, no intersection\\n\\t\\t\\t\\tif ( QdN < 0 ) {\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Ray intersects triangle.\\n\\t\\t\\t\\treturn this.at( QdN / DdN, optionalTarget );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tapplyMatrix4: function ( matrix4 ) {\\n\\n\\t\\t\\tthis.origin.applyMatrix4( matrix4 );\\n\\t\\t\\tthis.direction.transformDirection( matrix4 );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( ray ) {\\n\\n\\t\\t\\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t */\\n\\n\\tfunction Line3( start, end ) {\\n\\n\\t\\tthis.start = ( start !== undefined ) ? start : new Vector3();\\n\\t\\tthis.end = ( end !== undefined ) ? end : new Vector3();\\n\\n\\t}\\n\\n\\tObject.assign( Line3.prototype, {\\n\\n\\t\\tset: function ( start, end ) {\\n\\n\\t\\t\\tthis.start.copy( start );\\n\\t\\t\\tthis.end.copy( end );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( line ) {\\n\\n\\t\\t\\tthis.start.copy( line.start );\\n\\t\\t\\tthis.end.copy( line.end );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetCenter: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\\n\\n\\t\\t},\\n\\n\\t\\tdelta: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\treturn result.subVectors( this.end, this.start );\\n\\n\\t\\t},\\n\\n\\t\\tdistanceSq: function () {\\n\\n\\t\\t\\treturn this.start.distanceToSquared( this.end );\\n\\n\\t\\t},\\n\\n\\t\\tdistance: function () {\\n\\n\\t\\t\\treturn this.start.distanceTo( this.end );\\n\\n\\t\\t},\\n\\n\\t\\tat: function ( t, optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\\n\\n\\t\\t},\\n\\n\\t\\tclosestPointToPointParameter: function () {\\n\\n\\t\\t\\tvar startP = new Vector3();\\n\\t\\t\\tvar startEnd = new Vector3();\\n\\n\\t\\t\\treturn function closestPointToPointParameter( point, clampToLine ) {\\n\\n\\t\\t\\t\\tstartP.subVectors( point, this.start );\\n\\t\\t\\t\\tstartEnd.subVectors( this.end, this.start );\\n\\n\\t\\t\\t\\tvar startEnd2 = startEnd.dot( startEnd );\\n\\t\\t\\t\\tvar startEnd_startP = startEnd.dot( startP );\\n\\n\\t\\t\\t\\tvar t = startEnd_startP / startEnd2;\\n\\n\\t\\t\\t\\tif ( clampToLine ) {\\n\\n\\t\\t\\t\\t\\tt = _Math.clamp( t, 0, 1 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn t;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\\n\\n\\t\\t\\tvar t = this.closestPointToPointParameter( point, clampToLine );\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\\n\\n\\t\\t},\\n\\n\\t\\tapplyMatrix4: function ( matrix ) {\\n\\n\\t\\t\\tthis.start.applyMatrix4( matrix );\\n\\t\\t\\tthis.end.applyMatrix4( matrix );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tequals: function ( line ) {\\n\\n\\t\\t\\treturn line.start.equals( this.start ) && line.end.equals( this.end );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Triangle( a, b, c ) {\\n\\n\\t\\tthis.a = ( a !== undefined ) ? a : new Vector3();\\n\\t\\tthis.b = ( b !== undefined ) ? b : new Vector3();\\n\\t\\tthis.c = ( c !== undefined ) ? c : new Vector3();\\n\\n\\t}\\n\\n\\tObject.assign( Triangle, {\\n\\n\\t\\tnormal: function () {\\n\\n\\t\\t\\tvar v0 = new Vector3();\\n\\n\\t\\t\\treturn function normal( a, b, c, optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\t\\tresult.subVectors( c, b );\\n\\t\\t\\t\\tv0.subVectors( a, b );\\n\\t\\t\\t\\tresult.cross( v0 );\\n\\n\\t\\t\\t\\tvar resultLengthSq = result.lengthSq();\\n\\t\\t\\t\\tif ( resultLengthSq > 0 ) {\\n\\n\\t\\t\\t\\t\\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn result.set( 0, 0, 0 );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\t// static/instance method to calculate barycentric coordinates\\n\\t\\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\\n\\t\\tbarycoordFromPoint: function () {\\n\\n\\t\\t\\tvar v0 = new Vector3();\\n\\t\\t\\tvar v1 = new Vector3();\\n\\t\\t\\tvar v2 = new Vector3();\\n\\n\\t\\t\\treturn function barycoordFromPoint( point, a, b, c, optionalTarget ) {\\n\\n\\t\\t\\t\\tv0.subVectors( c, a );\\n\\t\\t\\t\\tv1.subVectors( b, a );\\n\\t\\t\\t\\tv2.subVectors( point, a );\\n\\n\\t\\t\\t\\tvar dot00 = v0.dot( v0 );\\n\\t\\t\\t\\tvar dot01 = v0.dot( v1 );\\n\\t\\t\\t\\tvar dot02 = v0.dot( v2 );\\n\\t\\t\\t\\tvar dot11 = v1.dot( v1 );\\n\\t\\t\\t\\tvar dot12 = v1.dot( v2 );\\n\\n\\t\\t\\t\\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\n\\t\\t\\t\\t// collinear or singular triangle\\n\\t\\t\\t\\tif ( denom === 0 ) {\\n\\n\\t\\t\\t\\t\\t// arbitrary location outside of triangle?\\n\\t\\t\\t\\t\\t// not sure if this is the best idea, maybe should be returning undefined\\n\\t\\t\\t\\t\\treturn result.set( - 2, - 1, - 1 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar invDenom = 1 / denom;\\n\\t\\t\\t\\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\\n\\t\\t\\t\\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\\n\\n\\t\\t\\t\\t// barycentric coordinates must always sum to 1\\n\\t\\t\\t\\treturn result.set( 1 - u - v, v, u );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tcontainsPoint: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function containsPoint( point, a, b, c ) {\\n\\n\\t\\t\\t\\tvar result = Triangle.barycoordFromPoint( point, a, b, c, v1 );\\n\\n\\t\\t\\t\\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}()\\n\\n\\t} );\\n\\n\\tObject.assign( Triangle.prototype, {\\n\\n\\t\\tset: function ( a, b, c ) {\\n\\n\\t\\t\\tthis.a.copy( a );\\n\\t\\t\\tthis.b.copy( b );\\n\\t\\t\\tthis.c.copy( c );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\\n\\n\\t\\t\\tthis.a.copy( points[ i0 ] );\\n\\t\\t\\tthis.b.copy( points[ i1 ] );\\n\\t\\t\\tthis.c.copy( points[ i2 ] );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( triangle ) {\\n\\n\\t\\t\\tthis.a.copy( triangle.a );\\n\\t\\t\\tthis.b.copy( triangle.b );\\n\\t\\t\\tthis.c.copy( triangle.c );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tarea: function () {\\n\\n\\t\\t\\tvar v0 = new Vector3();\\n\\t\\t\\tvar v1 = new Vector3();\\n\\n\\t\\t\\treturn function area() {\\n\\n\\t\\t\\t\\tv0.subVectors( this.c, this.b );\\n\\t\\t\\t\\tv1.subVectors( this.a, this.b );\\n\\n\\t\\t\\t\\treturn v0.cross( v1 ).length() * 0.5;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tmidpoint: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\\n\\n\\t\\t},\\n\\n\\t\\tnormal: function ( optionalTarget ) {\\n\\n\\t\\t\\treturn Triangle.normal( this.a, this.b, this.c, optionalTarget );\\n\\n\\t\\t},\\n\\n\\t\\tplane: function ( optionalTarget ) {\\n\\n\\t\\t\\tvar result = optionalTarget || new Plane();\\n\\n\\t\\t\\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\\n\\n\\t\\t},\\n\\n\\t\\tbarycoordFromPoint: function ( point, optionalTarget ) {\\n\\n\\t\\t\\treturn Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\\n\\n\\t\\t},\\n\\n\\t\\tcontainsPoint: function ( point ) {\\n\\n\\t\\t\\treturn Triangle.containsPoint( point, this.a, this.b, this.c );\\n\\n\\t\\t},\\n\\n\\t\\tclosestPointToPoint: function () {\\n\\n\\t\\t\\tvar plane = new Plane();\\n\\t\\t\\tvar edgeList = [ new Line3(), new Line3(), new Line3() ];\\n\\t\\t\\tvar projectedPoint = new Vector3();\\n\\t\\t\\tvar closestPoint = new Vector3();\\n\\n\\t\\t\\treturn function closestPointToPoint( point, optionalTarget ) {\\n\\n\\t\\t\\t\\tvar result = optionalTarget || new Vector3();\\n\\t\\t\\t\\tvar minDistance = Infinity;\\n\\n\\t\\t\\t\\t// project the point onto the plane of the triangle\\n\\n\\t\\t\\t\\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\\n\\t\\t\\t\\tplane.projectPoint( point, projectedPoint );\\n\\n\\t\\t\\t\\t// check if the projection lies within the triangle\\n\\n\\t\\t\\t\\tif ( this.containsPoint( projectedPoint ) === true ) {\\n\\n\\t\\t\\t\\t\\t// if so, this is the closest point\\n\\n\\t\\t\\t\\t\\tresult.copy( projectedPoint );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\\n\\n\\t\\t\\t\\t\\tedgeList[ 0 ].set( this.a, this.b );\\n\\t\\t\\t\\t\\tedgeList[ 1 ].set( this.b, this.c );\\n\\t\\t\\t\\t\\tedgeList[ 2 ].set( this.c, this.a );\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < edgeList.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\\n\\n\\t\\t\\t\\t\\t\\tvar distance = projectedPoint.distanceToSquared( closestPoint );\\n\\n\\t\\t\\t\\t\\t\\tif ( distance < minDistance ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tminDistance = distance;\\n\\n\\t\\t\\t\\t\\t\\t\\tresult.copy( closestPoint );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn result;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tequals: function ( triangle ) {\\n\\n\\t\\t\\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author jonobr1 / http://jonobr1.com/\\n\\t */\\n\\n\\tfunction Mesh( geometry, material ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Mesh';\\n\\n\\t\\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\\n\\t\\tthis.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );\\n\\n\\t\\tthis.drawMode = TrianglesDrawMode;\\n\\n\\t\\tthis.updateMorphTargets();\\n\\n\\t}\\n\\n\\tMesh.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Mesh,\\n\\n\\t\\tisMesh: true,\\n\\n\\t\\tsetDrawMode: function ( value ) {\\n\\n\\t\\t\\tthis.drawMode = value;\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tObject3D.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.drawMode = source.drawMode;\\n\\n\\t\\t\\tif ( source.morphTargetInfluences !== undefined ) {\\n\\n\\t\\t\\t\\tthis.morphTargetInfluences = source.morphTargetInfluences.slice();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( source.morphTargetDictionary !== undefined ) {\\n\\n\\t\\t\\t\\tthis.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tupdateMorphTargets: function () {\\n\\n\\t\\t\\tvar geometry = this.geometry;\\n\\t\\t\\tvar m, ml, name;\\n\\n\\t\\t\\tif ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\tvar morphAttributes = geometry.morphAttributes;\\n\\t\\t\\t\\tvar keys = Object.keys( morphAttributes );\\n\\n\\t\\t\\t\\tif ( keys.length > 0 ) {\\n\\n\\t\\t\\t\\t\\tvar morphAttribute = morphAttributes[ keys[ 0 ] ];\\n\\n\\t\\t\\t\\t\\tif ( morphAttribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.morphTargetInfluences = [];\\n\\t\\t\\t\\t\\t\\tthis.morphTargetDictionary = {};\\n\\n\\t\\t\\t\\t\\t\\tfor ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tname = morphAttribute[ m ].name || String( m );\\n\\n\\t\\t\\t\\t\\t\\t\\tthis.morphTargetInfluences.push( 0 );\\n\\t\\t\\t\\t\\t\\t\\tthis.morphTargetDictionary[ name ] = m;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar morphTargets = geometry.morphTargets;\\n\\n\\t\\t\\t\\tif ( morphTargets !== undefined && morphTargets.length > 0 ) {\\n\\n\\t\\t\\t\\t\\tthis.morphTargetInfluences = [];\\n\\t\\t\\t\\t\\tthis.morphTargetDictionary = {};\\n\\n\\t\\t\\t\\t\\tfor ( m = 0, ml = morphTargets.length; m < ml; m ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tname = morphTargets[ m ].name || String( m );\\n\\n\\t\\t\\t\\t\\t\\tthis.morphTargetInfluences.push( 0 );\\n\\t\\t\\t\\t\\t\\tthis.morphTargetDictionary[ name ] = m;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\traycast: ( function () {\\n\\n\\t\\t\\tvar inverseMatrix = new Matrix4();\\n\\t\\t\\tvar ray = new Ray();\\n\\t\\t\\tvar sphere = new Sphere();\\n\\n\\t\\t\\tvar vA = new Vector3();\\n\\t\\t\\tvar vB = new Vector3();\\n\\t\\t\\tvar vC = new Vector3();\\n\\n\\t\\t\\tvar tempA = new Vector3();\\n\\t\\t\\tvar tempB = new Vector3();\\n\\t\\t\\tvar tempC = new Vector3();\\n\\n\\t\\t\\tvar uvA = new Vector2();\\n\\t\\t\\tvar uvB = new Vector2();\\n\\t\\t\\tvar uvC = new Vector2();\\n\\n\\t\\t\\tvar barycoord = new Vector3();\\n\\n\\t\\t\\tvar intersectionPoint = new Vector3();\\n\\t\\t\\tvar intersectionPointWorld = new Vector3();\\n\\n\\t\\t\\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\\n\\n\\t\\t\\t\\tTriangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\\n\\n\\t\\t\\t\\tuv1.multiplyScalar( barycoord.x );\\n\\t\\t\\t\\tuv2.multiplyScalar( barycoord.y );\\n\\t\\t\\t\\tuv3.multiplyScalar( barycoord.z );\\n\\n\\t\\t\\t\\tuv1.add( uv2 ).add( uv3 );\\n\\n\\t\\t\\t\\treturn uv1.clone();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {\\n\\n\\t\\t\\t\\tvar intersect;\\n\\n\\t\\t\\t\\tif ( material.side === BackSide ) {\\n\\n\\t\\t\\t\\t\\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( intersect === null ) return null;\\n\\n\\t\\t\\t\\tintersectionPointWorld.copy( point );\\n\\t\\t\\t\\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\\n\\n\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\\n\\n\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\\n\\n\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\tdistance: distance,\\n\\t\\t\\t\\t\\tpoint: intersectionPointWorld.clone(),\\n\\t\\t\\t\\t\\tobject: object\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {\\n\\n\\t\\t\\t\\tvA.fromBufferAttribute( position, a );\\n\\t\\t\\t\\tvB.fromBufferAttribute( position, b );\\n\\t\\t\\t\\tvC.fromBufferAttribute( position, c );\\n\\n\\t\\t\\t\\tvar intersection = checkIntersection( object, object.material, raycaster, ray, vA, vB, vC, intersectionPoint );\\n\\n\\t\\t\\t\\tif ( intersection ) {\\n\\n\\t\\t\\t\\t\\tif ( uv ) {\\n\\n\\t\\t\\t\\t\\t\\tuvA.fromBufferAttribute( uv, a );\\n\\t\\t\\t\\t\\t\\tuvB.fromBufferAttribute( uv, b );\\n\\t\\t\\t\\t\\t\\tuvC.fromBufferAttribute( uv, c );\\n\\n\\t\\t\\t\\t\\t\\tintersection.uv = uvIntersection( intersectionPoint, vA, vB, vC, uvA, uvB, uvC );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tintersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );\\n\\t\\t\\t\\t\\tintersection.faceIndex = a;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn intersection;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\n\\n\\t\\t\\t\\tvar geometry = this.geometry;\\n\\t\\t\\t\\tvar material = this.material;\\n\\t\\t\\t\\tvar matrixWorld = this.matrixWorld;\\n\\n\\t\\t\\t\\tif ( material === undefined ) return;\\n\\n\\t\\t\\t\\t// Checking boundingSphere distance to ray\\n\\n\\t\\t\\t\\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\\n\\n\\t\\t\\t\\tsphere.copy( geometry.boundingSphere );\\n\\t\\t\\t\\tsphere.applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\\n\\n\\t\\t\\t\\t//\\n\\n\\t\\t\\t\\tinverseMatrix.getInverse( matrixWorld );\\n\\t\\t\\t\\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\\n\\n\\t\\t\\t\\t// Check boundingBox before continuing\\n\\n\\t\\t\\t\\tif ( geometry.boundingBox !== null ) {\\n\\n\\t\\t\\t\\t\\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar intersection;\\n\\n\\t\\t\\t\\tif ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\t\\tvar a, b, c;\\n\\t\\t\\t\\t\\tvar index = geometry.index;\\n\\t\\t\\t\\t\\tvar position = geometry.attributes.position;\\n\\t\\t\\t\\t\\tvar uv = geometry.attributes.uv;\\n\\t\\t\\t\\t\\tvar i, l;\\n\\n\\t\\t\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\t\\t\\t// indexed buffer geometry\\n\\n\\t\\t\\t\\t\\t\\tfor ( i = 0, l = index.count; i < l; i += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\ta = index.getX( i );\\n\\t\\t\\t\\t\\t\\t\\tb = index.getX( i + 1 );\\n\\t\\t\\t\\t\\t\\t\\tc = index.getX( i + 2 );\\n\\n\\t\\t\\t\\t\\t\\t\\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( intersection ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\\n\\t\\t\\t\\t\\t\\t\\t\\tintersects.push( intersection );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else if ( position !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t// non-indexed buffer geometry\\n\\n\\t\\t\\t\\t\\t\\tfor ( i = 0, l = position.count; i < l; i += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\ta = i;\\n\\t\\t\\t\\t\\t\\t\\tb = i + 1;\\n\\t\\t\\t\\t\\t\\t\\tc = i + 2;\\n\\n\\t\\t\\t\\t\\t\\t\\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( intersection ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tintersection.index = a; // triangle number in positions buffer semantics\\n\\t\\t\\t\\t\\t\\t\\t\\tintersects.push( intersection );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( geometry.isGeometry ) {\\n\\n\\t\\t\\t\\t\\tvar fvA, fvB, fvC;\\n\\t\\t\\t\\t\\tvar isMultiMaterial = Array.isArray( material );\\n\\n\\t\\t\\t\\t\\tvar vertices = geometry.vertices;\\n\\t\\t\\t\\t\\tvar faces = geometry.faces;\\n\\t\\t\\t\\t\\tvar uvs;\\n\\n\\t\\t\\t\\t\\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\\n\\t\\t\\t\\t\\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\\n\\n\\t\\t\\t\\t\\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar face = faces[ f ];\\n\\t\\t\\t\\t\\t\\tvar faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;\\n\\n\\t\\t\\t\\t\\t\\tif ( faceMaterial === undefined ) continue;\\n\\n\\t\\t\\t\\t\\t\\tfvA = vertices[ face.a ];\\n\\t\\t\\t\\t\\t\\tfvB = vertices[ face.b ];\\n\\t\\t\\t\\t\\t\\tfvC = vertices[ face.c ];\\n\\n\\t\\t\\t\\t\\t\\tif ( faceMaterial.morphTargets === true ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar morphTargets = geometry.morphTargets;\\n\\t\\t\\t\\t\\t\\t\\tvar morphInfluences = this.morphTargetInfluences;\\n\\n\\t\\t\\t\\t\\t\\t\\tvA.set( 0, 0, 0 );\\n\\t\\t\\t\\t\\t\\t\\tvB.set( 0, 0, 0 );\\n\\t\\t\\t\\t\\t\\t\\tvC.set( 0, 0, 0 );\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar influence = morphInfluences[ t ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( influence === 0 ) continue;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar targets = morphTargets[ t ].vertices;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\\n\\t\\t\\t\\t\\t\\t\\t\\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\\n\\t\\t\\t\\t\\t\\t\\t\\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tvA.add( fvA );\\n\\t\\t\\t\\t\\t\\t\\tvB.add( fvB );\\n\\t\\t\\t\\t\\t\\t\\tvC.add( fvC );\\n\\n\\t\\t\\t\\t\\t\\t\\tfvA = vA;\\n\\t\\t\\t\\t\\t\\t\\tfvB = vB;\\n\\t\\t\\t\\t\\t\\t\\tfvC = vC;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tintersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\\n\\n\\t\\t\\t\\t\\t\\tif ( intersection ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( uvs && uvs[ f ] ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar uvs_f = uvs[ f ];\\n\\t\\t\\t\\t\\t\\t\\t\\tuvA.copy( uvs_f[ 0 ] );\\n\\t\\t\\t\\t\\t\\t\\t\\tuvB.copy( uvs_f[ 1 ] );\\n\\t\\t\\t\\t\\t\\t\\t\\tuvC.copy( uvs_f[ 2 ] );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tintersection.face = face;\\n\\t\\t\\t\\t\\t\\t\\tintersection.faceIndex = f;\\n\\t\\t\\t\\t\\t\\t\\tintersects.push( intersection );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() ),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLBackground( renderer, state, geometries, premultipliedAlpha ) {\\n\\n\\t\\tvar clearColor = new Color( 0x000000 );\\n\\t\\tvar clearAlpha = 0;\\n\\n\\t\\tvar planeCamera, planeMesh;\\n\\t\\tvar boxMesh;\\n\\n\\t\\tfunction render( renderList, scene, camera, forceClear ) {\\n\\n\\t\\t\\tvar background = scene.background;\\n\\n\\t\\t\\tif ( background === null ) {\\n\\n\\t\\t\\t\\tsetClear( clearColor, clearAlpha );\\n\\n\\t\\t\\t} else if ( background && background.isColor ) {\\n\\n\\t\\t\\t\\tsetClear( background, 1 );\\n\\t\\t\\t\\tforceClear = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( renderer.autoClear || forceClear ) {\\n\\n\\t\\t\\t\\trenderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( background && background.isCubeTexture ) {\\n\\n\\t\\t\\t\\tif ( boxMesh === undefined ) {\\n\\n\\t\\t\\t\\t\\tboxMesh = new Mesh(\\n\\t\\t\\t\\t\\t\\tnew BoxBufferGeometry( 1, 1, 1 ),\\n\\t\\t\\t\\t\\t\\tnew ShaderMaterial( {\\n\\t\\t\\t\\t\\t\\t\\tuniforms: ShaderLib.cube.uniforms,\\n\\t\\t\\t\\t\\t\\t\\tvertexShader: ShaderLib.cube.vertexShader,\\n\\t\\t\\t\\t\\t\\t\\tfragmentShader: ShaderLib.cube.fragmentShader,\\n\\t\\t\\t\\t\\t\\t\\tside: BackSide,\\n\\t\\t\\t\\t\\t\\t\\tdepthTest: true,\\n\\t\\t\\t\\t\\t\\t\\tdepthWrite: false,\\n\\t\\t\\t\\t\\t\\t\\tfog: false\\n\\t\\t\\t\\t\\t\\t} )\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\tboxMesh.geometry.removeAttribute( 'normal' );\\n\\t\\t\\t\\t\\tboxMesh.geometry.removeAttribute( 'uv' );\\n\\n\\t\\t\\t\\t\\tboxMesh.onBeforeRender = function ( renderer, scene, camera ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.matrixWorld.copyPosition( camera.matrixWorld );\\n\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\tgeometries.update( boxMesh.geometry );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tboxMesh.material.uniforms.tCube.value = background;\\n\\n\\t\\t\\t\\trenderList.push( boxMesh, boxMesh.geometry, boxMesh.material, 0, null );\\n\\n\\t\\t\\t} else if ( background && background.isTexture ) {\\n\\n\\t\\t\\t\\tif ( planeCamera === undefined ) {\\n\\n\\t\\t\\t\\t\\tplaneCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\\n\\n\\t\\t\\t\\t\\tplaneMesh = new Mesh(\\n\\t\\t\\t\\t\\t\\tnew PlaneBufferGeometry( 2, 2 ),\\n\\t\\t\\t\\t\\t\\tnew MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )\\n\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\tgeometries.update( planeMesh.geometry );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tplaneMesh.material.map = background;\\n\\n\\t\\t\\t\\t// TODO Push this to renderList\\n\\n\\t\\t\\t\\trenderer.renderBufferDirect( planeCamera, null, planeMesh.geometry, planeMesh.material, planeMesh, null );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction setClear( color, alpha ) {\\n\\n\\t\\t\\tstate.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tgetClearColor: function () {\\n\\n\\t\\t\\t\\treturn clearColor;\\n\\n\\t\\t\\t},\\n\\t\\t\\tsetClearColor: function ( color, alpha ) {\\n\\n\\t\\t\\t\\tclearColor.set( color );\\n\\t\\t\\t\\tclearAlpha = alpha !== undefined ? alpha : 1;\\n\\t\\t\\t\\tsetClear( clearColor, clearAlpha );\\n\\n\\t\\t\\t},\\n\\t\\t\\tgetClearAlpha: function () {\\n\\n\\t\\t\\t\\treturn clearAlpha;\\n\\n\\t\\t\\t},\\n\\t\\t\\tsetClearAlpha: function ( alpha ) {\\n\\n\\t\\t\\t\\tclearAlpha = alpha;\\n\\t\\t\\t\\tsetClear( clearColor, clearAlpha );\\n\\n\\t\\t\\t},\\n\\t\\t\\trender: render\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction painterSortStable( a, b ) {\\n\\n\\t\\tif ( a.renderOrder !== b.renderOrder ) {\\n\\n\\t\\t\\treturn a.renderOrder - b.renderOrder;\\n\\n\\t\\t} else if ( a.program && b.program && a.program !== b.program ) {\\n\\n\\t\\t\\treturn a.program.id - b.program.id;\\n\\n\\t\\t} else if ( a.material.id !== b.material.id ) {\\n\\n\\t\\t\\treturn a.material.id - b.material.id;\\n\\n\\t\\t} else if ( a.z !== b.z ) {\\n\\n\\t\\t\\treturn a.z - b.z;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\treturn a.id - b.id;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction reversePainterSortStable( a, b ) {\\n\\n\\t\\tif ( a.renderOrder !== b.renderOrder ) {\\n\\n\\t\\t\\treturn a.renderOrder - b.renderOrder;\\n\\n\\t\\t} if ( a.z !== b.z ) {\\n\\n\\t\\t\\treturn b.z - a.z;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\treturn a.id - b.id;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction WebGLRenderList() {\\n\\n\\t\\tvar renderItems = [];\\n\\t\\tvar renderItemsIndex = 0;\\n\\n\\t\\tvar opaque = [];\\n\\t\\tvar transparent = [];\\n\\n\\t\\tfunction init() {\\n\\n\\t\\t\\trenderItemsIndex = 0;\\n\\n\\t\\t\\topaque.length = 0;\\n\\t\\t\\ttransparent.length = 0;\\n\\n\\t\\t}\\n\\n\\t\\tfunction push( object, geometry, material, z, group ) {\\n\\n\\t\\t\\tvar renderItem = renderItems[ renderItemsIndex ];\\n\\n\\t\\t\\tif ( renderItem === undefined ) {\\n\\n\\t\\t\\t\\trenderItem = {\\n\\t\\t\\t\\t\\tid: object.id,\\n\\t\\t\\t\\t\\tobject: object,\\n\\t\\t\\t\\t\\tgeometry: geometry,\\n\\t\\t\\t\\t\\tmaterial: material,\\n\\t\\t\\t\\t\\tprogram: material.program,\\n\\t\\t\\t\\t\\trenderOrder: object.renderOrder,\\n\\t\\t\\t\\t\\tz: z,\\n\\t\\t\\t\\t\\tgroup: group\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\trenderItems[ renderItemsIndex ] = renderItem;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\trenderItem.id = object.id;\\n\\t\\t\\t\\trenderItem.object = object;\\n\\t\\t\\t\\trenderItem.geometry = geometry;\\n\\t\\t\\t\\trenderItem.material = material;\\n\\t\\t\\t\\trenderItem.program = material.program;\\n\\t\\t\\t\\trenderItem.renderOrder = object.renderOrder;\\n\\t\\t\\t\\trenderItem.z = z;\\n\\t\\t\\t\\trenderItem.group = group;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t( material.transparent === true ? transparent : opaque ).push( renderItem );\\n\\n\\t\\t\\trenderItemsIndex ++;\\n\\n\\t\\t}\\n\\n\\t\\tfunction sort() {\\n\\n\\t\\t\\tif ( opaque.length > 1 ) opaque.sort( painterSortStable );\\n\\t\\t\\tif ( transparent.length > 1 ) transparent.sort( reversePainterSortStable );\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\topaque: opaque,\\n\\t\\t\\ttransparent: transparent,\\n\\n\\t\\t\\tinit: init,\\n\\t\\t\\tpush: push,\\n\\n\\t\\t\\tsort: sort\\n\\t\\t};\\n\\n\\t}\\n\\n\\tfunction WebGLRenderLists() {\\n\\n\\t\\tvar lists = {};\\n\\n\\t\\tfunction get( scene, camera ) {\\n\\n\\t\\t\\tvar hash = scene.id + ',' + camera.id;\\n\\t\\t\\tvar list = lists[ hash ];\\n\\n\\t\\t\\tif ( list === undefined ) {\\n\\n\\t\\t\\t\\t// console.log( 'THREE.WebGLRenderLists:', hash );\\n\\n\\t\\t\\t\\tlist = new WebGLRenderList();\\n\\t\\t\\t\\tlists[ hash ] = list;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn list;\\n\\n\\t\\t}\\n\\n\\t\\tfunction dispose() {\\n\\n\\t\\t\\tlists = {};\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tget: get,\\n\\t\\t\\tdispose: dispose\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction absNumericalSort( a, b ) {\\n\\n\\t\\treturn Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );\\n\\n\\t}\\n\\n\\tfunction WebGLMorphtargets( gl ) {\\n\\n\\t\\tvar influencesList = {};\\n\\t\\tvar morphInfluences = new Float32Array( 8 );\\n\\n\\t\\tfunction update( object, geometry, material, program ) {\\n\\n\\t\\t\\tvar objectInfluences = object.morphTargetInfluences;\\n\\n\\t\\t\\tvar length = objectInfluences.length;\\n\\n\\t\\t\\tvar influences = influencesList[ geometry.id ];\\n\\n\\t\\t\\tif ( influences === undefined ) {\\n\\n\\t\\t\\t\\t// initialise list\\n\\n\\t\\t\\t\\tinfluences = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tinfluences[ i ] = [ i, 0 ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tinfluencesList[ geometry.id ] = influences;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar morphTargets = material.morphTargets && geometry.morphAttributes.position;\\n\\t\\t\\tvar morphNormals = material.morphNormals && geometry.morphAttributes.normal;\\n\\n\\t\\t\\t// Remove current morphAttributes\\n\\n\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\n\\n\\t\\t\\t\\tvar influence = influences[ i ];\\n\\n\\t\\t\\t\\tif ( influence[ 1 ] !== 0 ) {\\n\\n\\t\\t\\t\\t\\tif ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );\\n\\t\\t\\t\\t\\tif ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Collect influences\\n\\n\\t\\t\\tfor ( var i = 0; i < length; i ++ ) {\\n\\n\\t\\t\\t\\tvar influence = influences[ i ];\\n\\n\\t\\t\\t\\tinfluence[ 0 ] = i;\\n\\t\\t\\t\\tinfluence[ 1 ] = objectInfluences[ i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tinfluences.sort( absNumericalSort );\\n\\n\\t\\t\\t// Add morphAttributes\\n\\n\\t\\t\\tfor ( var i = 0; i < 8; i ++ ) {\\n\\n\\t\\t\\t\\tvar influence = influences[ i ];\\n\\n\\t\\t\\t\\tif ( influence ) {\\n\\n\\t\\t\\t\\t\\tvar index = influence[ 0 ];\\n\\t\\t\\t\\t\\tvar value = influence[ 1 ];\\n\\n\\t\\t\\t\\t\\tif ( value ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );\\n\\t\\t\\t\\t\\t\\tif ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );\\n\\n\\t\\t\\t\\t\\t\\tmorphInfluences[ i ] = value;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tmorphInfluences[ i ] = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tprogram.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tupdate: update\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {\\n\\n\\t\\tvar mode;\\n\\n\\t\\tfunction setMode( value ) {\\n\\n\\t\\t\\tmode = value;\\n\\n\\t\\t}\\n\\n\\t\\tvar type, bytesPerElement;\\n\\n\\t\\tfunction setIndex( value ) {\\n\\n\\t\\t\\ttype = value.type;\\n\\t\\t\\tbytesPerElement = value.bytesPerElement;\\n\\n\\t\\t}\\n\\n\\t\\tfunction render( start, count ) {\\n\\n\\t\\t\\tgl.drawElements( mode, count, type, start * bytesPerElement );\\n\\n\\t\\t\\tinfoRender.calls ++;\\n\\t\\t\\tinfoRender.vertices += count;\\n\\n\\t\\t\\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\\n\\t\\t\\telse if ( mode === gl.POINTS ) infoRender.points += count;\\n\\n\\t\\t}\\n\\n\\t\\tfunction renderInstances( geometry, start, count ) {\\n\\n\\t\\t\\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\\n\\n\\t\\t\\tif ( extension === null ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\textension.drawElementsInstancedANGLE( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );\\n\\n\\t\\t\\tinfoRender.calls ++;\\n\\t\\t\\tinfoRender.vertices += count * geometry.maxInstancedCount;\\n\\n\\t\\t\\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\\n\\t\\t\\telse if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tthis.setMode = setMode;\\n\\t\\tthis.setIndex = setIndex;\\n\\t\\tthis.render = render;\\n\\t\\tthis.renderInstances = renderInstances;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLBufferRenderer( gl, extensions, infoRender ) {\\n\\n\\t\\tvar mode;\\n\\n\\t\\tfunction setMode( value ) {\\n\\n\\t\\t\\tmode = value;\\n\\n\\t\\t}\\n\\n\\t\\tfunction render( start, count ) {\\n\\n\\t\\t\\tgl.drawArrays( mode, start, count );\\n\\n\\t\\t\\tinfoRender.calls ++;\\n\\t\\t\\tinfoRender.vertices += count;\\n\\n\\t\\t\\tif ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;\\n\\t\\t\\telse if ( mode === gl.POINTS ) infoRender.points += count;\\n\\n\\t\\t}\\n\\n\\t\\tfunction renderInstances( geometry, start, count ) {\\n\\n\\t\\t\\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\\n\\n\\t\\t\\tif ( extension === null ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar position = geometry.attributes.position;\\n\\n\\t\\t\\tif ( position.isInterleavedBufferAttribute ) {\\n\\n\\t\\t\\t\\tcount = position.data.count;\\n\\n\\t\\t\\t\\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\textension.drawArraysInstancedANGLE( mode, start, count, geometry.maxInstancedCount );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tinfoRender.calls ++;\\n\\t\\t\\tinfoRender.vertices += count * geometry.maxInstancedCount;\\n\\n\\t\\t\\tif ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;\\n\\t\\t\\telse if ( mode === gl.POINTS ) infoRender.points += geometry.maxInstancedCount * count;\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tthis.setMode = setMode;\\n\\t\\tthis.render = render;\\n\\t\\tthis.renderInstances = renderInstances;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLGeometries( gl, attributes, infoMemory ) {\\n\\n\\t\\tvar geometries = {};\\n\\t\\tvar wireframeAttributes = {};\\n\\n\\t\\tfunction onGeometryDispose( event ) {\\n\\n\\t\\t\\tvar geometry = event.target;\\n\\t\\t\\tvar buffergeometry = geometries[ geometry.id ];\\n\\n\\t\\t\\tif ( buffergeometry.index !== null ) {\\n\\n\\t\\t\\t\\tattributes.remove( buffergeometry.index );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var name in buffergeometry.attributes ) {\\n\\n\\t\\t\\t\\tattributes.remove( buffergeometry.attributes[ name ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\\n\\n\\t\\t\\tdelete geometries[ geometry.id ];\\n\\n\\t\\t\\t// TODO Remove duplicate code\\n\\n\\t\\t\\tvar attribute = wireframeAttributes[ geometry.id ];\\n\\n\\t\\t\\tif ( attribute ) {\\n\\n\\t\\t\\t\\tattributes.remove( attribute );\\n\\t\\t\\t\\tdelete wireframeAttributes[ geometry.id ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tattribute = wireframeAttributes[ buffergeometry.id ];\\n\\n\\t\\t\\tif ( attribute ) {\\n\\n\\t\\t\\t\\tattributes.remove( attribute );\\n\\t\\t\\t\\tdelete wireframeAttributes[ buffergeometry.id ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tinfoMemory.geometries --;\\n\\n\\t\\t}\\n\\n\\t\\tfunction get( object, geometry ) {\\n\\n\\t\\t\\tvar buffergeometry = geometries[ geometry.id ];\\n\\n\\t\\t\\tif ( buffergeometry ) return buffergeometry;\\n\\n\\t\\t\\tgeometry.addEventListener( 'dispose', onGeometryDispose );\\n\\n\\t\\t\\tif ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\tbuffergeometry = geometry;\\n\\n\\t\\t\\t} else if ( geometry.isGeometry ) {\\n\\n\\t\\t\\t\\tif ( geometry._bufferGeometry === undefined ) {\\n\\n\\t\\t\\t\\t\\tgeometry._bufferGeometry = new BufferGeometry().setFromObject( object );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbuffergeometry = geometry._bufferGeometry;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tgeometries[ geometry.id ] = buffergeometry;\\n\\n\\t\\t\\tinfoMemory.geometries ++;\\n\\n\\t\\t\\treturn buffergeometry;\\n\\n\\t\\t}\\n\\n\\t\\tfunction update( geometry ) {\\n\\n\\t\\t\\tvar index = geometry.index;\\n\\t\\t\\tvar geometryAttributes = geometry.attributes;\\n\\n\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\tattributes.update( index, gl.ELEMENT_ARRAY_BUFFER );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var name in geometryAttributes ) {\\n\\n\\t\\t\\t\\tattributes.update( geometryAttributes[ name ], gl.ARRAY_BUFFER );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// morph targets\\n\\n\\t\\t\\tvar morphAttributes = geometry.morphAttributes;\\n\\n\\t\\t\\tfor ( var name in morphAttributes ) {\\n\\n\\t\\t\\t\\tvar array = morphAttributes[ name ];\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tattributes.update( array[ i ], gl.ARRAY_BUFFER );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction getWireframeAttribute( geometry ) {\\n\\n\\t\\t\\tvar attribute = wireframeAttributes[ geometry.id ];\\n\\n\\t\\t\\tif ( attribute ) return attribute;\\n\\n\\t\\t\\tvar indices = [];\\n\\n\\t\\t\\tvar geometryIndex = geometry.index;\\n\\t\\t\\tvar geometryAttributes = geometry.attributes;\\n\\n\\t\\t\\t// console.time( 'wireframe' );\\n\\n\\t\\t\\tif ( geometryIndex !== null ) {\\n\\n\\t\\t\\t\\tvar array = geometryIndex.array;\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\\n\\n\\t\\t\\t\\t\\tvar a = array[ i + 0 ];\\n\\t\\t\\t\\t\\tvar b = array[ i + 1 ];\\n\\t\\t\\t\\t\\tvar c = array[ i + 2 ];\\n\\n\\t\\t\\t\\t\\tindices.push( a, b, b, c, c, a );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar array = geometryAttributes.position.array;\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\\n\\n\\t\\t\\t\\t\\tvar a = i + 0;\\n\\t\\t\\t\\t\\tvar b = i + 1;\\n\\t\\t\\t\\t\\tvar c = i + 2;\\n\\n\\t\\t\\t\\t\\tindices.push( a, b, b, c, c, a );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// console.timeEnd( 'wireframe' );\\n\\n\\t\\t\\tattribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );\\n\\n\\t\\t\\tattributes.update( attribute, gl.ELEMENT_ARRAY_BUFFER );\\n\\n\\t\\t\\twireframeAttributes[ geometry.id ] = attribute;\\n\\n\\t\\t\\treturn attribute;\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tget: get,\\n\\t\\t\\tupdate: update,\\n\\n\\t\\t\\tgetWireframeAttribute: getWireframeAttribute\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction UniformsCache() {\\n\\n\\t\\tvar lights = {};\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tget: function ( light ) {\\n\\n\\t\\t\\t\\tif ( lights[ light.id ] !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn lights[ light.id ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar uniforms;\\n\\n\\t\\t\\t\\tswitch ( light.type ) {\\n\\n\\t\\t\\t\\t\\tcase 'DirectionalLight':\\n\\t\\t\\t\\t\\t\\tuniforms = {\\n\\t\\t\\t\\t\\t\\t\\tdirection: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\tcolor: new Color(),\\n\\n\\t\\t\\t\\t\\t\\t\\tshadow: false,\\n\\t\\t\\t\\t\\t\\t\\tshadowBias: 0,\\n\\t\\t\\t\\t\\t\\t\\tshadowRadius: 1,\\n\\t\\t\\t\\t\\t\\t\\tshadowMapSize: new Vector2()\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'SpotLight':\\n\\t\\t\\t\\t\\t\\tuniforms = {\\n\\t\\t\\t\\t\\t\\t\\tposition: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\tdirection: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\tcolor: new Color(),\\n\\t\\t\\t\\t\\t\\t\\tdistance: 0,\\n\\t\\t\\t\\t\\t\\t\\tconeCos: 0,\\n\\t\\t\\t\\t\\t\\t\\tpenumbraCos: 0,\\n\\t\\t\\t\\t\\t\\t\\tdecay: 0,\\n\\n\\t\\t\\t\\t\\t\\t\\tshadow: false,\\n\\t\\t\\t\\t\\t\\t\\tshadowBias: 0,\\n\\t\\t\\t\\t\\t\\t\\tshadowRadius: 1,\\n\\t\\t\\t\\t\\t\\t\\tshadowMapSize: new Vector2()\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'PointLight':\\n\\t\\t\\t\\t\\t\\tuniforms = {\\n\\t\\t\\t\\t\\t\\t\\tposition: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\tcolor: new Color(),\\n\\t\\t\\t\\t\\t\\t\\tdistance: 0,\\n\\t\\t\\t\\t\\t\\t\\tdecay: 0,\\n\\n\\t\\t\\t\\t\\t\\t\\tshadow: false,\\n\\t\\t\\t\\t\\t\\t\\tshadowBias: 0,\\n\\t\\t\\t\\t\\t\\t\\tshadowRadius: 1,\\n\\t\\t\\t\\t\\t\\t\\tshadowMapSize: new Vector2(),\\n\\t\\t\\t\\t\\t\\t\\tshadowCameraNear: 1,\\n\\t\\t\\t\\t\\t\\t\\tshadowCameraFar: 1000\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'HemisphereLight':\\n\\t\\t\\t\\t\\t\\tuniforms = {\\n\\t\\t\\t\\t\\t\\t\\tdirection: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\tskyColor: new Color(),\\n\\t\\t\\t\\t\\t\\t\\tgroundColor: new Color()\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'RectAreaLight':\\n\\t\\t\\t\\t\\t\\tuniforms = {\\n\\t\\t\\t\\t\\t\\t\\tcolor: new Color(),\\n\\t\\t\\t\\t\\t\\t\\tposition: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\thalfWidth: new Vector3(),\\n\\t\\t\\t\\t\\t\\t\\thalfHeight: new Vector3()\\n\\t\\t\\t\\t\\t\\t\\t// TODO (abelnation): set RectAreaLight shadow uniforms\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlights[ light.id ] = uniforms;\\n\\n\\t\\t\\t\\treturn uniforms;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\tfunction WebGLLights() {\\n\\n\\t\\tvar cache = new UniformsCache();\\n\\n\\t\\tvar state = {\\n\\n\\t\\t\\thash: '',\\n\\n\\t\\t\\tambient: [ 0, 0, 0 ],\\n\\t\\t\\tdirectional: [],\\n\\t\\t\\tdirectionalShadowMap: [],\\n\\t\\t\\tdirectionalShadowMatrix: [],\\n\\t\\t\\tspot: [],\\n\\t\\t\\tspotShadowMap: [],\\n\\t\\t\\tspotShadowMatrix: [],\\n\\t\\t\\trectArea: [],\\n\\t\\t\\tpoint: [],\\n\\t\\t\\tpointShadowMap: [],\\n\\t\\t\\tpointShadowMatrix: [],\\n\\t\\t\\themi: []\\n\\n\\t\\t};\\n\\n\\t\\tvar vector3 = new Vector3();\\n\\t\\tvar matrix4 = new Matrix4();\\n\\t\\tvar matrix42 = new Matrix4();\\n\\n\\t\\tfunction setup( lights, shadows, camera ) {\\n\\n\\t\\t\\tvar r = 0, g = 0, b = 0;\\n\\n\\t\\t\\tvar directionalLength = 0;\\n\\t\\t\\tvar pointLength = 0;\\n\\t\\t\\tvar spotLength = 0;\\n\\t\\t\\tvar rectAreaLength = 0;\\n\\t\\t\\tvar hemiLength = 0;\\n\\n\\t\\t\\tvar viewMatrix = camera.matrixWorldInverse;\\n\\n\\t\\t\\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar light = lights[ i ];\\n\\n\\t\\t\\t\\tvar color = light.color;\\n\\t\\t\\t\\tvar intensity = light.intensity;\\n\\t\\t\\t\\tvar distance = light.distance;\\n\\n\\t\\t\\t\\tvar shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\\n\\n\\t\\t\\t\\tif ( light.isAmbientLight ) {\\n\\n\\t\\t\\t\\t\\tr += color.r * intensity;\\n\\t\\t\\t\\t\\tg += color.g * intensity;\\n\\t\\t\\t\\t\\tb += color.b * intensity;\\n\\n\\t\\t\\t\\t} else if ( light.isDirectionalLight ) {\\n\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\n\\n\\t\\t\\t\\t\\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\\n\\t\\t\\t\\t\\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tvector3.setFromMatrixPosition( light.target.matrixWorld );\\n\\t\\t\\t\\t\\tuniforms.direction.sub( vector3 );\\n\\t\\t\\t\\t\\tuniforms.direction.transformDirection( viewMatrix );\\n\\n\\t\\t\\t\\t\\tuniforms.shadow = light.castShadow;\\n\\n\\t\\t\\t\\t\\tif ( light.castShadow ) {\\n\\n\\t\\t\\t\\t\\t\\tvar shadow = light.shadow;\\n\\n\\t\\t\\t\\t\\t\\tuniforms.shadowBias = shadow.bias;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowRadius = shadow.radius;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowMapSize = shadow.mapSize;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tstate.directionalShadowMap[ directionalLength ] = shadowMap;\\n\\t\\t\\t\\t\\tstate.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\\n\\t\\t\\t\\t\\tstate.directional[ directionalLength ] = uniforms;\\n\\n\\t\\t\\t\\t\\tdirectionalLength ++;\\n\\n\\t\\t\\t\\t} else if ( light.isSpotLight ) {\\n\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\n\\n\\t\\t\\t\\t\\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tuniforms.position.applyMatrix4( viewMatrix );\\n\\n\\t\\t\\t\\t\\tuniforms.color.copy( color ).multiplyScalar( intensity );\\n\\t\\t\\t\\t\\tuniforms.distance = distance;\\n\\n\\t\\t\\t\\t\\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tvector3.setFromMatrixPosition( light.target.matrixWorld );\\n\\t\\t\\t\\t\\tuniforms.direction.sub( vector3 );\\n\\t\\t\\t\\t\\tuniforms.direction.transformDirection( viewMatrix );\\n\\n\\t\\t\\t\\t\\tuniforms.coneCos = Math.cos( light.angle );\\n\\t\\t\\t\\t\\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\\n\\t\\t\\t\\t\\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\\n\\n\\t\\t\\t\\t\\tuniforms.shadow = light.castShadow;\\n\\n\\t\\t\\t\\t\\tif ( light.castShadow ) {\\n\\n\\t\\t\\t\\t\\t\\tvar shadow = light.shadow;\\n\\n\\t\\t\\t\\t\\t\\tuniforms.shadowBias = shadow.bias;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowRadius = shadow.radius;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowMapSize = shadow.mapSize;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tstate.spotShadowMap[ spotLength ] = shadowMap;\\n\\t\\t\\t\\t\\tstate.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\\n\\t\\t\\t\\t\\tstate.spot[ spotLength ] = uniforms;\\n\\n\\t\\t\\t\\t\\tspotLength ++;\\n\\n\\t\\t\\t\\t} else if ( light.isRectAreaLight ) {\\n\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\n\\n\\t\\t\\t\\t\\t// (a) intensity controls irradiance of entire light\\n\\t\\t\\t\\t\\tuniforms.color\\n\\t\\t\\t\\t\\t\\t.copy( color )\\n\\t\\t\\t\\t\\t\\t.multiplyScalar( intensity / ( light.width * light.height ) );\\n\\n\\t\\t\\t\\t\\t// (b) intensity controls the radiance per light area\\n\\t\\t\\t\\t\\t// uniforms.color.copy( color ).multiplyScalar( intensity );\\n\\n\\t\\t\\t\\t\\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tuniforms.position.applyMatrix4( viewMatrix );\\n\\n\\t\\t\\t\\t\\t// extract local rotation of light to derive width/height half vectors\\n\\t\\t\\t\\t\\tmatrix42.identity();\\n\\t\\t\\t\\t\\tmatrix4.copy( light.matrixWorld );\\n\\t\\t\\t\\t\\tmatrix4.premultiply( viewMatrix );\\n\\t\\t\\t\\t\\tmatrix42.extractRotation( matrix4 );\\n\\n\\t\\t\\t\\t\\tuniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );\\n\\t\\t\\t\\t\\tuniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );\\n\\n\\t\\t\\t\\t\\tuniforms.halfWidth.applyMatrix4( matrix42 );\\n\\t\\t\\t\\t\\tuniforms.halfHeight.applyMatrix4( matrix42 );\\n\\n\\t\\t\\t\\t\\t// TODO (abelnation): RectAreaLight distance?\\n\\t\\t\\t\\t\\t// uniforms.distance = distance;\\n\\n\\t\\t\\t\\t\\tstate.rectArea[ rectAreaLength ] = uniforms;\\n\\n\\t\\t\\t\\t\\trectAreaLength ++;\\n\\n\\t\\t\\t\\t} else if ( light.isPointLight ) {\\n\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\n\\n\\t\\t\\t\\t\\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tuniforms.position.applyMatrix4( viewMatrix );\\n\\n\\t\\t\\t\\t\\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\\n\\t\\t\\t\\t\\tuniforms.distance = light.distance;\\n\\t\\t\\t\\t\\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\\n\\n\\t\\t\\t\\t\\tuniforms.shadow = light.castShadow;\\n\\n\\t\\t\\t\\t\\tif ( light.castShadow ) {\\n\\n\\t\\t\\t\\t\\t\\tvar shadow = light.shadow;\\n\\n\\t\\t\\t\\t\\t\\tuniforms.shadowBias = shadow.bias;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowRadius = shadow.radius;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowMapSize = shadow.mapSize;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowCameraNear = shadow.camera.near;\\n\\t\\t\\t\\t\\t\\tuniforms.shadowCameraFar = shadow.camera.far;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tstate.pointShadowMap[ pointLength ] = shadowMap;\\n\\t\\t\\t\\t\\tstate.pointShadowMatrix[ pointLength ] = light.shadow.matrix;\\n\\t\\t\\t\\t\\tstate.point[ pointLength ] = uniforms;\\n\\n\\t\\t\\t\\t\\tpointLength ++;\\n\\n\\t\\t\\t\\t} else if ( light.isHemisphereLight ) {\\n\\n\\t\\t\\t\\t\\tvar uniforms = cache.get( light );\\n\\n\\t\\t\\t\\t\\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\\n\\t\\t\\t\\t\\tuniforms.direction.transformDirection( viewMatrix );\\n\\t\\t\\t\\t\\tuniforms.direction.normalize();\\n\\n\\t\\t\\t\\t\\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\\n\\t\\t\\t\\t\\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\\n\\n\\t\\t\\t\\t\\tstate.hemi[ hemiLength ] = uniforms;\\n\\n\\t\\t\\t\\t\\themiLength ++;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.ambient[ 0 ] = r;\\n\\t\\t\\tstate.ambient[ 1 ] = g;\\n\\t\\t\\tstate.ambient[ 2 ] = b;\\n\\n\\t\\t\\tstate.directional.length = directionalLength;\\n\\t\\t\\tstate.spot.length = spotLength;\\n\\t\\t\\tstate.rectArea.length = rectAreaLength;\\n\\t\\t\\tstate.point.length = pointLength;\\n\\t\\t\\tstate.hemi.length = hemiLength;\\n\\n\\t\\t\\t// TODO (sam-g-steel) why aren't we using join\\n\\t\\t\\tstate.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + shadows.length;\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tsetup: setup,\\n\\t\\t\\tstate: state\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLObjects( geometries, infoRender ) {\\n\\n\\t\\tvar updateList = {};\\n\\n\\t\\tfunction update( object ) {\\n\\n\\t\\t\\tvar frame = infoRender.frame;\\n\\n\\t\\t\\tvar geometry = object.geometry;\\n\\t\\t\\tvar buffergeometry = geometries.get( object, geometry );\\n\\n\\t\\t\\t// Update once per frame\\n\\n\\t\\t\\tif ( updateList[ buffergeometry.id ] !== frame ) {\\n\\n\\t\\t\\t\\tif ( geometry.isGeometry ) {\\n\\n\\t\\t\\t\\t\\tbuffergeometry.updateFromObject( object );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometries.update( buffergeometry );\\n\\n\\t\\t\\t\\tupdateList[ buffergeometry.id ] = frame;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn buffergeometry;\\n\\n\\t\\t}\\n\\n\\t\\tfunction clear() {\\n\\n\\t\\t\\tupdateList = {};\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tupdate: update,\\n\\t\\t\\tclear: clear\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction addLineNumbers( string ) {\\n\\n\\t\\tvar lines = string.split( '\\\\n' );\\n\\n\\t\\tfor ( var i = 0; i < lines.length; i ++ ) {\\n\\n\\t\\t\\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\\n\\n\\t\\t}\\n\\n\\t\\treturn lines.join( '\\\\n' );\\n\\n\\t}\\n\\n\\tfunction WebGLShader( gl, type, string ) {\\n\\n\\t\\tvar shader = gl.createShader( type );\\n\\n\\t\\tgl.shaderSource( shader, string );\\n\\t\\tgl.compileShader( shader );\\n\\n\\t\\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.WebGLShader: Shader couldn\\\\'t compile.' );\\n\\n\\t\\t}\\n\\n\\t\\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\\n\\n\\t\\t}\\n\\n\\t\\t// --enable-privileged-webgl-extension\\n\\t\\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\\n\\n\\t\\treturn shader;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar programIdCount = 0;\\n\\n\\tfunction getEncodingComponents( encoding ) {\\n\\n\\t\\tswitch ( encoding ) {\\n\\n\\t\\t\\tcase LinearEncoding:\\n\\t\\t\\t\\treturn [ 'Linear', '( value )' ];\\n\\t\\t\\tcase sRGBEncoding:\\n\\t\\t\\t\\treturn [ 'sRGB', '( value )' ];\\n\\t\\t\\tcase RGBEEncoding:\\n\\t\\t\\t\\treturn [ 'RGBE', '( value )' ];\\n\\t\\t\\tcase RGBM7Encoding:\\n\\t\\t\\t\\treturn [ 'RGBM', '( value, 7.0 )' ];\\n\\t\\t\\tcase RGBM16Encoding:\\n\\t\\t\\t\\treturn [ 'RGBM', '( value, 16.0 )' ];\\n\\t\\t\\tcase RGBDEncoding:\\n\\t\\t\\t\\treturn [ 'RGBD', '( value, 256.0 )' ];\\n\\t\\t\\tcase GammaEncoding:\\n\\t\\t\\t\\treturn [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tthrow new Error( 'unsupported encoding: ' + encoding );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tfunction getTexelDecodingFunction( functionName, encoding ) {\\n\\n\\t\\tvar components = getEncodingComponents( encoding );\\n\\t\\treturn 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';\\n\\n\\t}\\n\\n\\tfunction getTexelEncodingFunction( functionName, encoding ) {\\n\\n\\t\\tvar components = getEncodingComponents( encoding );\\n\\t\\treturn 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';\\n\\n\\t}\\n\\n\\tfunction getToneMappingFunction( functionName, toneMapping ) {\\n\\n\\t\\tvar toneMappingName;\\n\\n\\t\\tswitch ( toneMapping ) {\\n\\n\\t\\t\\tcase LinearToneMapping:\\n\\t\\t\\t\\ttoneMappingName = 'Linear';\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase ReinhardToneMapping:\\n\\t\\t\\t\\ttoneMappingName = 'Reinhard';\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase Uncharted2ToneMapping:\\n\\t\\t\\t\\ttoneMappingName = 'Uncharted2';\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase CineonToneMapping:\\n\\t\\t\\t\\ttoneMappingName = 'OptimizedCineon';\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\\n\\n\\t\\t}\\n\\n\\t\\treturn 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';\\n\\n\\t}\\n\\n\\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\\n\\n\\t\\textensions = extensions || {};\\n\\n\\t\\tvar chunks = [\\n\\t\\t\\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\\n\\t\\t\\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\\n\\t\\t\\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\\n\\t\\t\\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''\\n\\t\\t];\\n\\n\\t\\treturn chunks.filter( filterEmptyLine ).join( '\\\\n' );\\n\\n\\t}\\n\\n\\tfunction generateDefines( defines ) {\\n\\n\\t\\tvar chunks = [];\\n\\n\\t\\tfor ( var name in defines ) {\\n\\n\\t\\t\\tvar value = defines[ name ];\\n\\n\\t\\t\\tif ( value === false ) continue;\\n\\n\\t\\t\\tchunks.push( '#define ' + name + ' ' + value );\\n\\n\\t\\t}\\n\\n\\t\\treturn chunks.join( '\\\\n' );\\n\\n\\t}\\n\\n\\tfunction fetchAttributeLocations( gl, program ) {\\n\\n\\t\\tvar attributes = {};\\n\\n\\t\\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\\n\\n\\t\\tfor ( var i = 0; i < n; i ++ ) {\\n\\n\\t\\t\\tvar info = gl.getActiveAttrib( program, i );\\n\\t\\t\\tvar name = info.name;\\n\\n\\t\\t\\t// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );\\n\\n\\t\\t\\tattributes[ name ] = gl.getAttribLocation( program, name );\\n\\n\\t\\t}\\n\\n\\t\\treturn attributes;\\n\\n\\t}\\n\\n\\tfunction filterEmptyLine( string ) {\\n\\n\\t\\treturn string !== '';\\n\\n\\t}\\n\\n\\tfunction replaceLightNums( string, parameters ) {\\n\\n\\t\\treturn string\\n\\t\\t\\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\\n\\t\\t\\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\\n\\t\\t\\t.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )\\n\\t\\t\\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\\n\\t\\t\\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\\n\\n\\t}\\n\\n\\tfunction parseIncludes( string ) {\\n\\n\\t\\tvar pattern = /^[ \\\\t]*#include +<([\\\\w\\\\d.]+)>/gm;\\n\\n\\t\\tfunction replace( match, include ) {\\n\\n\\t\\t\\tvar replace = ShaderChunk[ include ];\\n\\n\\t\\t\\tif ( replace === undefined ) {\\n\\n\\t\\t\\t\\tthrow new Error( 'Can not resolve #include <' + include + '>' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn parseIncludes( replace );\\n\\n\\t\\t}\\n\\n\\t\\treturn string.replace( pattern, replace );\\n\\n\\t}\\n\\n\\tfunction unrollLoops( string ) {\\n\\n\\t\\tvar pattern = /for \\\\( int i \\\\= (\\\\d+)\\\\; i < (\\\\d+)\\\\; i \\\\+\\\\+ \\\\) \\\\{([\\\\s\\\\S]+?)(?=\\\\})\\\\}/g;\\n\\n\\t\\tfunction replace( match, start, end, snippet ) {\\n\\n\\t\\t\\tvar unroll = '';\\n\\n\\t\\t\\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\\n\\n\\t\\t\\t\\tunroll += snippet.replace( /\\\\[ i \\\\]/g, '[ ' + i + ' ]' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn unroll;\\n\\n\\t\\t}\\n\\n\\t\\treturn string.replace( pattern, replace );\\n\\n\\t}\\n\\n\\tfunction WebGLProgram( renderer, extensions, code, material, shader, parameters ) {\\n\\n\\t\\tvar gl = renderer.context;\\n\\n\\t\\tvar defines = material.defines;\\n\\n\\t\\tvar vertexShader = shader.vertexShader;\\n\\t\\tvar fragmentShader = shader.fragmentShader;\\n\\n\\t\\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\\n\\n\\t\\tif ( parameters.shadowMapType === PCFShadowMap ) {\\n\\n\\t\\t\\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\\n\\n\\t\\t} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {\\n\\n\\t\\t\\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\\n\\n\\t\\t}\\n\\n\\t\\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\\n\\t\\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\\n\\t\\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\\n\\n\\t\\tif ( parameters.envMap ) {\\n\\n\\t\\t\\tswitch ( material.envMap.mapping ) {\\n\\n\\t\\t\\t\\tcase CubeReflectionMapping:\\n\\t\\t\\t\\tcase CubeRefractionMapping:\\n\\t\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase CubeUVReflectionMapping:\\n\\t\\t\\t\\tcase CubeUVRefractionMapping:\\n\\t\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase EquirectangularReflectionMapping:\\n\\t\\t\\t\\tcase EquirectangularRefractionMapping:\\n\\t\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase SphericalReflectionMapping:\\n\\t\\t\\t\\t\\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tswitch ( material.envMap.mapping ) {\\n\\n\\t\\t\\t\\tcase CubeRefractionMapping:\\n\\t\\t\\t\\tcase EquirectangularRefractionMapping:\\n\\t\\t\\t\\t\\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tswitch ( material.combine ) {\\n\\n\\t\\t\\t\\tcase MultiplyOperation:\\n\\t\\t\\t\\t\\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase MixOperation:\\n\\t\\t\\t\\t\\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase AddOperation:\\n\\t\\t\\t\\t\\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\\n\\n\\t\\t// console.log( 'building new program ' );\\n\\n\\t\\t//\\n\\n\\t\\tvar customExtensions = generateExtensions( material.extensions, parameters, extensions );\\n\\n\\t\\tvar customDefines = generateDefines( defines );\\n\\n\\t\\t//\\n\\n\\t\\tvar program = gl.createProgram();\\n\\n\\t\\tvar prefixVertex, prefixFragment;\\n\\n\\t\\tif ( material.isRawShaderMaterial ) {\\n\\n\\t\\t\\tprefixVertex = [\\n\\n\\t\\t\\t\\tcustomDefines\\n\\n\\t\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\n\\n\\t\\t\\tif ( prefixVertex.length > 0 ) {\\n\\n\\t\\t\\t\\tprefixVertex += '\\\\n';\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tprefixFragment = [\\n\\n\\t\\t\\t\\tcustomExtensions,\\n\\t\\t\\t\\tcustomDefines\\n\\n\\t\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\n\\n\\t\\t\\tif ( prefixFragment.length > 0 ) {\\n\\n\\t\\t\\t\\tprefixFragment += '\\\\n';\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tprefixVertex = [\\n\\n\\t\\t\\t\\t'precision ' + parameters.precision + ' float;',\\n\\t\\t\\t\\t'precision ' + parameters.precision + ' int;',\\n\\n\\t\\t\\t\\t'#define SHADER_NAME ' + shader.name,\\n\\n\\t\\t\\t\\tcustomDefines,\\n\\n\\t\\t\\t\\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\\n\\n\\t\\t\\t\\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\\n\\n\\t\\t\\t\\t'#define MAX_BONES ' + parameters.maxBones,\\n\\t\\t\\t\\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\\n\\t\\t\\t\\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\\n\\n\\t\\t\\t\\tparameters.map ? '#define USE_MAP' : '',\\n\\t\\t\\t\\tparameters.envMap ? '#define USE_ENVMAP' : '',\\n\\t\\t\\t\\tparameters.envMap ? '#define ' + envMapModeDefine : '',\\n\\t\\t\\t\\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\\n\\t\\t\\t\\tparameters.aoMap ? '#define USE_AOMAP' : '',\\n\\t\\t\\t\\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\\n\\t\\t\\t\\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\\n\\t\\t\\t\\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\\n\\t\\t\\t\\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\\n\\t\\t\\t\\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\\n\\t\\t\\t\\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\\n\\t\\t\\t\\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\\n\\t\\t\\t\\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\\n\\t\\t\\t\\tparameters.vertexColors ? '#define USE_COLOR' : '',\\n\\n\\t\\t\\t\\tparameters.flatShading ? '#define FLAT_SHADED' : '',\\n\\n\\t\\t\\t\\tparameters.skinning ? '#define USE_SKINNING' : '',\\n\\t\\t\\t\\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\\n\\n\\t\\t\\t\\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\\n\\t\\t\\t\\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\\n\\t\\t\\t\\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\\n\\t\\t\\t\\tparameters.flipSided ? '#define FLIP_SIDED' : '',\\n\\n\\t\\t\\t\\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\\n\\n\\t\\t\\t\\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\\n\\t\\t\\t\\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\\n\\n\\t\\t\\t\\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\\n\\n\\t\\t\\t\\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\\n\\t\\t\\t\\tparameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\\n\\n\\t\\t\\t\\t'uniform mat4 modelMatrix;',\\n\\t\\t\\t\\t'uniform mat4 modelViewMatrix;',\\n\\t\\t\\t\\t'uniform mat4 projectionMatrix;',\\n\\t\\t\\t\\t'uniform mat4 viewMatrix;',\\n\\t\\t\\t\\t'uniform mat3 normalMatrix;',\\n\\t\\t\\t\\t'uniform vec3 cameraPosition;',\\n\\n\\t\\t\\t\\t'attribute vec3 position;',\\n\\t\\t\\t\\t'attribute vec3 normal;',\\n\\t\\t\\t\\t'attribute vec2 uv;',\\n\\n\\t\\t\\t\\t'#ifdef USE_COLOR',\\n\\n\\t\\t\\t\\t'\\tattribute vec3 color;',\\n\\n\\t\\t\\t\\t'#endif',\\n\\n\\t\\t\\t\\t'#ifdef USE_MORPHTARGETS',\\n\\n\\t\\t\\t\\t'\\tattribute vec3 morphTarget0;',\\n\\t\\t\\t\\t'\\tattribute vec3 morphTarget1;',\\n\\t\\t\\t\\t'\\tattribute vec3 morphTarget2;',\\n\\t\\t\\t\\t'\\tattribute vec3 morphTarget3;',\\n\\n\\t\\t\\t\\t'\\t#ifdef USE_MORPHNORMALS',\\n\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphNormal0;',\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphNormal1;',\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphNormal2;',\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphNormal3;',\\n\\n\\t\\t\\t\\t'\\t#else',\\n\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphTarget4;',\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphTarget5;',\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphTarget6;',\\n\\t\\t\\t\\t'\\t\\tattribute vec3 morphTarget7;',\\n\\n\\t\\t\\t\\t'\\t#endif',\\n\\n\\t\\t\\t\\t'#endif',\\n\\n\\t\\t\\t\\t'#ifdef USE_SKINNING',\\n\\n\\t\\t\\t\\t'\\tattribute vec4 skinIndex;',\\n\\t\\t\\t\\t'\\tattribute vec4 skinWeight;',\\n\\n\\t\\t\\t\\t'#endif',\\n\\n\\t\\t\\t\\t'\\\\n'\\n\\n\\t\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\n\\n\\t\\t\\tprefixFragment = [\\n\\n\\t\\t\\t\\tcustomExtensions,\\n\\n\\t\\t\\t\\t'precision ' + parameters.precision + ' float;',\\n\\t\\t\\t\\t'precision ' + parameters.precision + ' int;',\\n\\n\\t\\t\\t\\t'#define SHADER_NAME ' + shader.name,\\n\\n\\t\\t\\t\\tcustomDefines,\\n\\n\\t\\t\\t\\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\\n\\n\\t\\t\\t\\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\\n\\n\\t\\t\\t\\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\\n\\t\\t\\t\\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\\n\\n\\t\\t\\t\\tparameters.map ? '#define USE_MAP' : '',\\n\\t\\t\\t\\tparameters.envMap ? '#define USE_ENVMAP' : '',\\n\\t\\t\\t\\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\\n\\t\\t\\t\\tparameters.envMap ? '#define ' + envMapModeDefine : '',\\n\\t\\t\\t\\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\\n\\t\\t\\t\\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\\n\\t\\t\\t\\tparameters.aoMap ? '#define USE_AOMAP' : '',\\n\\t\\t\\t\\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\\n\\t\\t\\t\\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\\n\\t\\t\\t\\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\\n\\t\\t\\t\\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\\n\\t\\t\\t\\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\\n\\t\\t\\t\\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\\n\\t\\t\\t\\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\\n\\t\\t\\t\\tparameters.vertexColors ? '#define USE_COLOR' : '',\\n\\n\\t\\t\\t\\tparameters.gradientMap ? '#define USE_GRADIENTMAP' : '',\\n\\n\\t\\t\\t\\tparameters.flatShading ? '#define FLAT_SHADED' : '',\\n\\n\\t\\t\\t\\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\\n\\t\\t\\t\\tparameters.flipSided ? '#define FLIP_SIDED' : '',\\n\\n\\t\\t\\t\\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\\n\\t\\t\\t\\t'#define UNION_CLIPPING_PLANES ' + ( parameters.numClippingPlanes - parameters.numClipIntersection ),\\n\\n\\t\\t\\t\\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\\n\\t\\t\\t\\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\\n\\n\\t\\t\\t\\tparameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',\\n\\n\\t\\t\\t\\tparameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',\\n\\n\\t\\t\\t\\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\\n\\t\\t\\t\\tparameters.logarithmicDepthBuffer && extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\\n\\n\\t\\t\\t\\tparameters.envMap && extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\\n\\n\\t\\t\\t\\t'uniform mat4 viewMatrix;',\\n\\t\\t\\t\\t'uniform vec3 cameraPosition;',\\n\\n\\t\\t\\t\\t( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',\\n\\t\\t\\t\\t( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below\\n\\t\\t\\t\\t( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',\\n\\n\\t\\t\\t\\tparameters.dithering ? '#define DITHERING' : '',\\n\\n\\t\\t\\t\\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\\n\\t\\t\\t\\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\\n\\t\\t\\t\\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\\n\\t\\t\\t\\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\\n\\t\\t\\t\\tparameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',\\n\\n\\t\\t\\t\\tparameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',\\n\\n\\t\\t\\t\\t'\\\\n'\\n\\n\\t\\t\\t].filter( filterEmptyLine ).join( '\\\\n' );\\n\\n\\t\\t}\\n\\n\\t\\tvertexShader = parseIncludes( vertexShader );\\n\\t\\tvertexShader = replaceLightNums( vertexShader, parameters );\\n\\n\\t\\tfragmentShader = parseIncludes( fragmentShader );\\n\\t\\tfragmentShader = replaceLightNums( fragmentShader, parameters );\\n\\n\\t\\tif ( ! material.isShaderMaterial ) {\\n\\n\\t\\t\\tvertexShader = unrollLoops( vertexShader );\\n\\t\\t\\tfragmentShader = unrollLoops( fragmentShader );\\n\\n\\t\\t}\\n\\n\\t\\tvar vertexGlsl = prefixVertex + vertexShader;\\n\\t\\tvar fragmentGlsl = prefixFragment + fragmentShader;\\n\\n\\t\\t// console.log( '*VERTEX*', vertexGlsl );\\n\\t\\t// console.log( '*FRAGMENT*', fragmentGlsl );\\n\\n\\t\\tvar glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\\n\\t\\tvar glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\\n\\n\\t\\tgl.attachShader( program, glVertexShader );\\n\\t\\tgl.attachShader( program, glFragmentShader );\\n\\n\\t\\t// Force a particular attribute to index 0.\\n\\n\\t\\tif ( material.index0AttributeName !== undefined ) {\\n\\n\\t\\t\\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\\n\\n\\t\\t} else if ( parameters.morphTargets === true ) {\\n\\n\\t\\t\\t// programs with morphTargets displace position out of attribute 0\\n\\t\\t\\tgl.bindAttribLocation( program, 0, 'position' );\\n\\n\\t\\t}\\n\\n\\t\\tgl.linkProgram( program );\\n\\n\\t\\tvar programLog = gl.getProgramInfoLog( program );\\n\\t\\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\\n\\t\\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\\n\\n\\t\\tvar runnable = true;\\n\\t\\tvar haveDiagnostics = true;\\n\\n\\t\\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\\n\\t\\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\\n\\n\\t\\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\\n\\n\\t\\t\\trunnable = false;\\n\\n\\t\\t\\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\\n\\n\\t\\t} else if ( programLog !== '' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\\n\\n\\t\\t} else if ( vertexLog === '' || fragmentLog === '' ) {\\n\\n\\t\\t\\thaveDiagnostics = false;\\n\\n\\t\\t}\\n\\n\\t\\tif ( haveDiagnostics ) {\\n\\n\\t\\t\\tthis.diagnostics = {\\n\\n\\t\\t\\t\\trunnable: runnable,\\n\\t\\t\\t\\tmaterial: material,\\n\\n\\t\\t\\t\\tprogramLog: programLog,\\n\\n\\t\\t\\t\\tvertexShader: {\\n\\n\\t\\t\\t\\t\\tlog: vertexLog,\\n\\t\\t\\t\\t\\tprefix: prefixVertex\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfragmentShader: {\\n\\n\\t\\t\\t\\t\\tlog: fragmentLog,\\n\\t\\t\\t\\t\\tprefix: prefixFragment\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}\\n\\n\\t\\t// clean up\\n\\n\\t\\tgl.deleteShader( glVertexShader );\\n\\t\\tgl.deleteShader( glFragmentShader );\\n\\n\\t\\t// set up caching for uniform locations\\n\\n\\t\\tvar cachedUniforms;\\n\\n\\t\\tthis.getUniforms = function () {\\n\\n\\t\\t\\tif ( cachedUniforms === undefined ) {\\n\\n\\t\\t\\t\\tcachedUniforms = new WebGLUniforms( gl, program, renderer );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn cachedUniforms;\\n\\n\\t\\t};\\n\\n\\t\\t// set up caching for attribute locations\\n\\n\\t\\tvar cachedAttributes;\\n\\n\\t\\tthis.getAttributes = function () {\\n\\n\\t\\t\\tif ( cachedAttributes === undefined ) {\\n\\n\\t\\t\\t\\tcachedAttributes = fetchAttributeLocations( gl, program );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn cachedAttributes;\\n\\n\\t\\t};\\n\\n\\t\\t// free resource\\n\\n\\t\\tthis.destroy = function () {\\n\\n\\t\\t\\tgl.deleteProgram( program );\\n\\t\\t\\tthis.program = undefined;\\n\\n\\t\\t};\\n\\n\\t\\t// DEPRECATED\\n\\n\\t\\tObject.defineProperties( this, {\\n\\n\\t\\t\\tuniforms: {\\n\\t\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\\n\\t\\t\\t\\t\\treturn this.getUniforms();\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\n\\t\\t\\tattributes: {\\n\\t\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\\n\\t\\t\\t\\t\\treturn this.getAttributes();\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t} );\\n\\n\\n\\t\\t//\\n\\n\\t\\tthis.id = programIdCount ++;\\n\\t\\tthis.code = code;\\n\\t\\tthis.usedTimes = 1;\\n\\t\\tthis.program = program;\\n\\t\\tthis.vertexShader = glVertexShader;\\n\\t\\tthis.fragmentShader = glFragmentShader;\\n\\n\\t\\treturn this;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLPrograms( renderer, extensions, capabilities ) {\\n\\n\\t\\tvar programs = [];\\n\\n\\t\\tvar shaderIDs = {\\n\\t\\t\\tMeshDepthMaterial: 'depth',\\n\\t\\t\\tMeshDistanceMaterial: 'distanceRGBA',\\n\\t\\t\\tMeshNormalMaterial: 'normal',\\n\\t\\t\\tMeshBasicMaterial: 'basic',\\n\\t\\t\\tMeshLambertMaterial: 'lambert',\\n\\t\\t\\tMeshPhongMaterial: 'phong',\\n\\t\\t\\tMeshToonMaterial: 'phong',\\n\\t\\t\\tMeshStandardMaterial: 'physical',\\n\\t\\t\\tMeshPhysicalMaterial: 'physical',\\n\\t\\t\\tLineBasicMaterial: 'basic',\\n\\t\\t\\tLineDashedMaterial: 'dashed',\\n\\t\\t\\tPointsMaterial: 'points',\\n\\t\\t\\tShadowMaterial: 'shadow'\\n\\t\\t};\\n\\n\\t\\tvar parameterNames = [\\n\\t\\t\\t\\\"precision\\\", \\\"supportsVertexTextures\\\", \\\"map\\\", \\\"mapEncoding\\\", \\\"envMap\\\", \\\"envMapMode\\\", \\\"envMapEncoding\\\",\\n\\t\\t\\t\\\"lightMap\\\", \\\"aoMap\\\", \\\"emissiveMap\\\", \\\"emissiveMapEncoding\\\", \\\"bumpMap\\\", \\\"normalMap\\\", \\\"displacementMap\\\", \\\"specularMap\\\",\\n\\t\\t\\t\\\"roughnessMap\\\", \\\"metalnessMap\\\", \\\"gradientMap\\\",\\n\\t\\t\\t\\\"alphaMap\\\", \\\"combine\\\", \\\"vertexColors\\\", \\\"fog\\\", \\\"useFog\\\", \\\"fogExp\\\",\\n\\t\\t\\t\\\"flatShading\\\", \\\"sizeAttenuation\\\", \\\"logarithmicDepthBuffer\\\", \\\"skinning\\\",\\n\\t\\t\\t\\\"maxBones\\\", \\\"useVertexTexture\\\", \\\"morphTargets\\\", \\\"morphNormals\\\",\\n\\t\\t\\t\\\"maxMorphTargets\\\", \\\"maxMorphNormals\\\", \\\"premultipliedAlpha\\\",\\n\\t\\t\\t\\\"numDirLights\\\", \\\"numPointLights\\\", \\\"numSpotLights\\\", \\\"numHemiLights\\\", \\\"numRectAreaLights\\\",\\n\\t\\t\\t\\\"shadowMapEnabled\\\", \\\"shadowMapType\\\", \\\"toneMapping\\\", 'physicallyCorrectLights',\\n\\t\\t\\t\\\"alphaTest\\\", \\\"doubleSided\\\", \\\"flipSided\\\", \\\"numClippingPlanes\\\", \\\"numClipIntersection\\\", \\\"depthPacking\\\", \\\"dithering\\\"\\n\\t\\t];\\n\\n\\n\\t\\tfunction allocateBones( object ) {\\n\\n\\t\\t\\tvar skeleton = object.skeleton;\\n\\t\\t\\tvar bones = skeleton.bones;\\n\\n\\t\\t\\tif ( capabilities.floatVertexTextures ) {\\n\\n\\t\\t\\t\\treturn 1024;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// default for when object is not specified\\n\\t\\t\\t\\t// ( for example when prebuilding shader to be used with multiple objects )\\n\\t\\t\\t\\t//\\n\\t\\t\\t\\t//  - leave some extra space for other uniforms\\n\\t\\t\\t\\t//  - limit here is ANGLE's 254 max uniform vectors\\n\\t\\t\\t\\t//    (up to 54 should be safe)\\n\\n\\t\\t\\t\\tvar nVertexUniforms = capabilities.maxVertexUniforms;\\n\\t\\t\\t\\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\\n\\n\\t\\t\\t\\tvar maxBones = Math.min( nVertexMatrices, bones.length );\\n\\n\\t\\t\\t\\tif ( maxBones < bones.length ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );\\n\\t\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn maxBones;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\\n\\n\\t\\t\\tvar encoding;\\n\\n\\t\\t\\tif ( ! map ) {\\n\\n\\t\\t\\t\\tencoding = LinearEncoding;\\n\\n\\t\\t\\t} else if ( map.isTexture ) {\\n\\n\\t\\t\\t\\tencoding = map.encoding;\\n\\n\\t\\t\\t} else if ( map.isWebGLRenderTarget ) {\\n\\n\\t\\t\\t\\tconsole.warn( \\\"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\\\" );\\n\\t\\t\\t\\tencoding = map.texture.encoding;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\\n\\t\\t\\tif ( encoding === LinearEncoding && gammaOverrideLinear ) {\\n\\n\\t\\t\\t\\tencoding = GammaEncoding;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn encoding;\\n\\n\\t\\t}\\n\\n\\t\\tthis.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {\\n\\n\\t\\t\\tvar shaderID = shaderIDs[ material.type ];\\n\\n\\t\\t\\t// heuristics to create shader parameters according to lights in the scene\\n\\t\\t\\t// (not to blow over maxLights budget)\\n\\n\\t\\t\\tvar maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;\\n\\t\\t\\tvar precision = capabilities.precision;\\n\\n\\t\\t\\tif ( material.precision !== null ) {\\n\\n\\t\\t\\t\\tprecision = capabilities.getMaxPrecision( material.precision );\\n\\n\\t\\t\\t\\tif ( precision !== material.precision ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar currentRenderTarget = renderer.getRenderTarget();\\n\\n\\t\\t\\tvar parameters = {\\n\\n\\t\\t\\t\\tshaderID: shaderID,\\n\\n\\t\\t\\t\\tprecision: precision,\\n\\t\\t\\t\\tsupportsVertexTextures: capabilities.vertexTextures,\\n\\t\\t\\t\\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\\n\\t\\t\\t\\tmap: !! material.map,\\n\\t\\t\\t\\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\\n\\t\\t\\t\\tenvMap: !! material.envMap,\\n\\t\\t\\t\\tenvMapMode: material.envMap && material.envMap.mapping,\\n\\t\\t\\t\\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\\n\\t\\t\\t\\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),\\n\\t\\t\\t\\tlightMap: !! material.lightMap,\\n\\t\\t\\t\\taoMap: !! material.aoMap,\\n\\t\\t\\t\\temissiveMap: !! material.emissiveMap,\\n\\t\\t\\t\\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\\n\\t\\t\\t\\tbumpMap: !! material.bumpMap,\\n\\t\\t\\t\\tnormalMap: !! material.normalMap,\\n\\t\\t\\t\\tdisplacementMap: !! material.displacementMap,\\n\\t\\t\\t\\troughnessMap: !! material.roughnessMap,\\n\\t\\t\\t\\tmetalnessMap: !! material.metalnessMap,\\n\\t\\t\\t\\tspecularMap: !! material.specularMap,\\n\\t\\t\\t\\talphaMap: !! material.alphaMap,\\n\\n\\t\\t\\t\\tgradientMap: !! material.gradientMap,\\n\\n\\t\\t\\t\\tcombine: material.combine,\\n\\n\\t\\t\\t\\tvertexColors: material.vertexColors,\\n\\n\\t\\t\\t\\tfog: !! fog,\\n\\t\\t\\t\\tuseFog: material.fog,\\n\\t\\t\\t\\tfogExp: ( fog && fog.isFogExp2 ),\\n\\n\\t\\t\\t\\tflatShading: material.flatShading,\\n\\n\\t\\t\\t\\tsizeAttenuation: material.sizeAttenuation,\\n\\t\\t\\t\\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\\n\\n\\t\\t\\t\\tskinning: material.skinning && maxBones > 0,\\n\\t\\t\\t\\tmaxBones: maxBones,\\n\\t\\t\\t\\tuseVertexTexture: capabilities.floatVertexTextures,\\n\\n\\t\\t\\t\\tmorphTargets: material.morphTargets,\\n\\t\\t\\t\\tmorphNormals: material.morphNormals,\\n\\t\\t\\t\\tmaxMorphTargets: renderer.maxMorphTargets,\\n\\t\\t\\t\\tmaxMorphNormals: renderer.maxMorphNormals,\\n\\n\\t\\t\\t\\tnumDirLights: lights.directional.length,\\n\\t\\t\\t\\tnumPointLights: lights.point.length,\\n\\t\\t\\t\\tnumSpotLights: lights.spot.length,\\n\\t\\t\\t\\tnumRectAreaLights: lights.rectArea.length,\\n\\t\\t\\t\\tnumHemiLights: lights.hemi.length,\\n\\n\\t\\t\\t\\tnumClippingPlanes: nClipPlanes,\\n\\t\\t\\t\\tnumClipIntersection: nClipIntersection,\\n\\n\\t\\t\\t\\tdithering: material.dithering,\\n\\n\\t\\t\\t\\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,\\n\\t\\t\\t\\tshadowMapType: renderer.shadowMap.type,\\n\\n\\t\\t\\t\\ttoneMapping: renderer.toneMapping,\\n\\t\\t\\t\\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\\n\\n\\t\\t\\t\\tpremultipliedAlpha: material.premultipliedAlpha,\\n\\n\\t\\t\\t\\talphaTest: material.alphaTest,\\n\\t\\t\\t\\tdoubleSided: material.side === DoubleSide,\\n\\t\\t\\t\\tflipSided: material.side === BackSide,\\n\\n\\t\\t\\t\\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\\n\\n\\t\\t\\t};\\n\\n\\t\\t\\treturn parameters;\\n\\n\\t\\t};\\n\\n\\t\\tthis.getProgramCode = function ( material, parameters ) {\\n\\n\\t\\t\\tvar array = [];\\n\\n\\t\\t\\tif ( parameters.shaderID ) {\\n\\n\\t\\t\\t\\tarray.push( parameters.shaderID );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tarray.push( material.fragmentShader );\\n\\t\\t\\t\\tarray.push( material.vertexShader );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.defines !== undefined ) {\\n\\n\\t\\t\\t\\tfor ( var name in material.defines ) {\\n\\n\\t\\t\\t\\t\\tarray.push( name );\\n\\t\\t\\t\\t\\tarray.push( material.defines[ name ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\\n\\n\\t\\t\\t\\tarray.push( parameters[ parameterNames[ i ] ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tarray.push( material.onBeforeCompile.toString() );\\n\\n\\t\\t\\tarray.push( renderer.gammaOutput );\\n\\n\\t\\t\\treturn array.join();\\n\\n\\t\\t};\\n\\n\\t\\tthis.acquireProgram = function ( material, shader, parameters, code ) {\\n\\n\\t\\t\\tvar program;\\n\\n\\t\\t\\t// Check if code has been already compiled\\n\\t\\t\\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\\n\\n\\t\\t\\t\\tvar programInfo = programs[ p ];\\n\\n\\t\\t\\t\\tif ( programInfo.code === code ) {\\n\\n\\t\\t\\t\\t\\tprogram = programInfo;\\n\\t\\t\\t\\t\\t++ program.usedTimes;\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( program === undefined ) {\\n\\n\\t\\t\\t\\tprogram = new WebGLProgram( renderer, extensions, code, material, shader, parameters );\\n\\t\\t\\t\\tprograms.push( program );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn program;\\n\\n\\t\\t};\\n\\n\\t\\tthis.releaseProgram = function ( program ) {\\n\\n\\t\\t\\tif ( -- program.usedTimes === 0 ) {\\n\\n\\t\\t\\t\\t// Remove from unordered set\\n\\t\\t\\t\\tvar i = programs.indexOf( program );\\n\\t\\t\\t\\tprograms[ i ] = programs[ programs.length - 1 ];\\n\\t\\t\\t\\tprograms.pop();\\n\\n\\t\\t\\t\\t// Free WebGL resources\\n\\t\\t\\t\\tprogram.destroy();\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\t// Exposed for resource monitoring & error feedback via renderer.info:\\n\\t\\tthis.programs = programs;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLTextures( _gl, extensions, state, properties, capabilities, utils, infoMemory ) {\\n\\n\\t\\tvar _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof window.WebGL2RenderingContext );\\n\\t\\tvar _videoTextures = {};\\n\\n\\t\\t//\\n\\n\\t\\tfunction clampToMaxSize( image, maxSize ) {\\n\\n\\t\\t\\tif ( image.width > maxSize || image.height > maxSize ) {\\n\\n\\t\\t\\t\\t// Warning: Scaling through the canvas will only work with images that use\\n\\t\\t\\t\\t// premultiplied alpha.\\n\\n\\t\\t\\t\\tvar scale = maxSize / Math.max( image.width, image.height );\\n\\n\\t\\t\\t\\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\n\\t\\t\\t\\tcanvas.width = Math.floor( image.width * scale );\\n\\t\\t\\t\\tcanvas.height = Math.floor( image.height * scale );\\n\\n\\t\\t\\t\\tvar context = canvas.getContext( '2d' );\\n\\t\\t\\t\\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\\n\\n\\t\\t\\t\\treturn canvas;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn image;\\n\\n\\t\\t}\\n\\n\\t\\tfunction isPowerOfTwo( image ) {\\n\\n\\t\\t\\treturn _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );\\n\\n\\t\\t}\\n\\n\\t\\tfunction makePowerOfTwo( image ) {\\n\\n\\t\\t\\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) {\\n\\n\\t\\t\\t\\tvar canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\n\\t\\t\\t\\tcanvas.width = _Math.floorPowerOfTwo( image.width );\\n\\t\\t\\t\\tcanvas.height = _Math.floorPowerOfTwo( image.height );\\n\\n\\t\\t\\t\\tvar context = canvas.getContext( '2d' );\\n\\t\\t\\t\\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\\n\\n\\t\\t\\t\\treturn canvas;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn image;\\n\\n\\t\\t}\\n\\n\\t\\tfunction textureNeedsPowerOfTwo( texture ) {\\n\\n\\t\\t\\treturn ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||\\n\\t\\t\\t\\t( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );\\n\\n\\t\\t}\\n\\n\\t\\tfunction textureNeedsGenerateMipmaps( texture, isPowerOfTwo ) {\\n\\n\\t\\t\\treturn texture.generateMipmaps && isPowerOfTwo &&\\n\\t\\t\\t\\ttexture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\\n\\n\\t\\t}\\n\\n\\t\\t// Fallback filters for non-power-of-2 textures\\n\\n\\t\\tfunction filterFallback( f ) {\\n\\n\\t\\t\\tif ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {\\n\\n\\t\\t\\t\\treturn _gl.NEAREST;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn _gl.LINEAR;\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction onTextureDispose( event ) {\\n\\n\\t\\t\\tvar texture = event.target;\\n\\n\\t\\t\\ttexture.removeEventListener( 'dispose', onTextureDispose );\\n\\n\\t\\t\\tdeallocateTexture( texture );\\n\\n\\t\\t\\tif ( texture.isVideoTexture ) {\\n\\n\\t\\t\\t\\tdelete _videoTextures[ texture.id ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tinfoMemory.textures --;\\n\\n\\t\\t}\\n\\n\\t\\tfunction onRenderTargetDispose( event ) {\\n\\n\\t\\t\\tvar renderTarget = event.target;\\n\\n\\t\\t\\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\\n\\n\\t\\t\\tdeallocateRenderTarget( renderTarget );\\n\\n\\t\\t\\tinfoMemory.textures --;\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction deallocateTexture( texture ) {\\n\\n\\t\\t\\tvar textureProperties = properties.get( texture );\\n\\n\\t\\t\\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\\n\\n\\t\\t\\t\\t// cube texture\\n\\n\\t\\t\\t\\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// 2D texture\\n\\n\\t\\t\\t\\tif ( textureProperties.__webglInit === undefined ) return;\\n\\n\\t\\t\\t\\t_gl.deleteTexture( textureProperties.__webglTexture );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// remove all webgl properties\\n\\t\\t\\tproperties.remove( texture );\\n\\n\\t\\t}\\n\\n\\t\\tfunction deallocateRenderTarget( renderTarget ) {\\n\\n\\t\\t\\tvar renderTargetProperties = properties.get( renderTarget );\\n\\t\\t\\tvar textureProperties = properties.get( renderTarget.texture );\\n\\n\\t\\t\\tif ( ! renderTarget ) return;\\n\\n\\t\\t\\tif ( textureProperties.__webglTexture !== undefined ) {\\n\\n\\t\\t\\t\\t_gl.deleteTexture( textureProperties.__webglTexture );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( renderTarget.depthTexture ) {\\n\\n\\t\\t\\t\\trenderTarget.depthTexture.dispose();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( renderTarget.isWebGLRenderTargetCube ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\\n\\t\\t\\t\\t\\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\\n\\t\\t\\t\\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tproperties.remove( renderTarget.texture );\\n\\t\\t\\tproperties.remove( renderTarget );\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\n\\n\\t\\tfunction setTexture2D( texture, slot ) {\\n\\n\\t\\t\\tvar textureProperties = properties.get( texture );\\n\\n\\t\\t\\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\\n\\n\\t\\t\\t\\tvar image = texture.image;\\n\\n\\t\\t\\t\\tif ( image === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\\n\\n\\t\\t\\t\\t} else if ( image.complete === false ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tuploadTexture( textureProperties, texture, slot );\\n\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\n\\t\\t\\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\\n\\n\\t\\t}\\n\\n\\t\\tfunction setTextureCube( texture, slot ) {\\n\\n\\t\\t\\tvar textureProperties = properties.get( texture );\\n\\n\\t\\t\\tif ( texture.image.length === 6 ) {\\n\\n\\t\\t\\t\\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\\n\\n\\t\\t\\t\\t\\tif ( ! textureProperties.__image__webglTextureCube ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.addEventListener( 'dispose', onTextureDispose );\\n\\n\\t\\t\\t\\t\\t\\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\\n\\n\\t\\t\\t\\t\\t\\tinfoMemory.textures ++;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\n\\t\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\\n\\n\\t\\t\\t\\t\\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\\n\\n\\t\\t\\t\\t\\tvar isCompressed = ( texture && texture.isCompressedTexture );\\n\\t\\t\\t\\t\\tvar isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );\\n\\n\\t\\t\\t\\t\\tvar cubeImage = [];\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( ! isCompressed && ! isDataTexture ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar image = cubeImage[ 0 ],\\n\\t\\t\\t\\t\\t\\tisPowerOfTwoImage = isPowerOfTwo( image ),\\n\\t\\t\\t\\t\\t\\tglFormat = utils.convert( texture.format ),\\n\\t\\t\\t\\t\\t\\tglType = utils.convert( texture.type );\\n\\n\\t\\t\\t\\t\\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( ! isCompressed ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( isDataTexture ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tmipmap = mipmaps[ j ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) {\\n\\n\\t\\t\\t\\t\\t\\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttextureProperties.__version = texture.version;\\n\\n\\t\\t\\t\\t\\tif ( texture.onUpdate ) texture.onUpdate( texture );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\n\\t\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction setTextureCubeDynamic( texture, slot ) {\\n\\n\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\n\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\\n\\n\\t\\t}\\n\\n\\t\\tfunction setTextureParameters( textureType, texture, isPowerOfTwoImage ) {\\n\\n\\t\\t\\tvar extension;\\n\\n\\t\\t\\tif ( isPowerOfTwoImage ) {\\n\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, utils.convert( texture.wrapS ) );\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, utils.convert( texture.wrapT ) );\\n\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, utils.convert( texture.magFilter ) );\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, utils.convert( texture.minFilter ) );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\\n\\n\\t\\t\\t\\tif ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\\n\\t\\t\\t\\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\\n\\n\\t\\t\\t\\tif ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\\n\\n\\t\\t\\tif ( extension ) {\\n\\n\\t\\t\\t\\tif ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\\n\\t\\t\\t\\tif ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\\n\\n\\t\\t\\t\\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\\n\\n\\t\\t\\t\\t\\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );\\n\\t\\t\\t\\t\\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction uploadTexture( textureProperties, texture, slot ) {\\n\\n\\t\\t\\tif ( textureProperties.__webglInit === undefined ) {\\n\\n\\t\\t\\t\\ttextureProperties.__webglInit = true;\\n\\n\\t\\t\\t\\ttexture.addEventListener( 'dispose', onTextureDispose );\\n\\n\\t\\t\\t\\ttextureProperties.__webglTexture = _gl.createTexture();\\n\\n\\t\\t\\t\\tif ( texture.isVideoTexture ) {\\n\\n\\t\\t\\t\\t\\t_videoTextures[ texture.id ] = texture;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tinfoMemory.textures ++;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.activeTexture( _gl.TEXTURE0 + slot );\\n\\t\\t\\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\\n\\n\\t\\t\\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\\n\\t\\t\\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\\n\\t\\t\\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\\n\\n\\t\\t\\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\\n\\n\\t\\t\\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\\n\\n\\t\\t\\t\\timage = makePowerOfTwo( image );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\\n\\t\\t\\t\\tglFormat = utils.convert( texture.format ),\\n\\t\\t\\t\\tglType = utils.convert( texture.type );\\n\\n\\t\\t\\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\\n\\n\\t\\t\\tvar mipmap, mipmaps = texture.mipmaps;\\n\\n\\t\\t\\tif ( texture.isDepthTexture ) {\\n\\n\\t\\t\\t\\t// populate depth texture with dummy data\\n\\n\\t\\t\\t\\tvar internalFormat = _gl.DEPTH_COMPONENT;\\n\\n\\t\\t\\t\\tif ( texture.type === FloatType ) {\\n\\n\\t\\t\\t\\t\\tif ( ! _isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );\\n\\t\\t\\t\\t\\tinternalFormat = _gl.DEPTH_COMPONENT32F;\\n\\n\\t\\t\\t\\t} else if ( _isWebGL2 ) {\\n\\n\\t\\t\\t\\t\\t// WebGL 2.0 requires signed internalformat for glTexImage2D\\n\\t\\t\\t\\t\\tinternalFormat = _gl.DEPTH_COMPONENT16;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT ) {\\n\\n\\t\\t\\t\\t\\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\\n\\t\\t\\t\\t\\t// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT\\n\\t\\t\\t\\t\\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\\n\\t\\t\\t\\t\\tif ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );\\n\\n\\t\\t\\t\\t\\t\\ttexture.type = UnsignedShortType;\\n\\t\\t\\t\\t\\t\\tglType = utils.convert( texture.type );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Depth stencil textures need the DEPTH_STENCIL internal format\\n\\t\\t\\t\\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\\n\\t\\t\\t\\tif ( texture.format === DepthStencilFormat ) {\\n\\n\\t\\t\\t\\t\\tinternalFormat = _gl.DEPTH_STENCIL;\\n\\n\\t\\t\\t\\t\\t// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are\\n\\t\\t\\t\\t\\t// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.\\n\\t\\t\\t\\t\\t// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)\\n\\t\\t\\t\\t\\tif ( texture.type !== UnsignedInt248Type ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );\\n\\n\\t\\t\\t\\t\\t\\ttexture.type = UnsignedInt248Type;\\n\\t\\t\\t\\t\\t\\tglType = utils.convert( texture.type );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\\n\\n\\t\\t\\t} else if ( texture.isDataTexture ) {\\n\\n\\t\\t\\t\\t// use manually created mipmaps if available\\n\\t\\t\\t\\t// if there are no manual mipmaps\\n\\t\\t\\t\\t// set 0 level mipmap and then use GL to generate other mipmap levels\\n\\n\\t\\t\\t\\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tmipmap = mipmaps[ i ];\\n\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttexture.generateMipmaps = false;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( texture.isCompressedTexture ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tmipmap = mipmaps[ i ];\\n\\n\\t\\t\\t\\t\\tif ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// regular Texture (image, video, canvas)\\n\\n\\t\\t\\t\\t// use manually created mipmaps if available\\n\\t\\t\\t\\t// if there are no manual mipmaps\\n\\t\\t\\t\\t// set 0 level mipmap and then use GL to generate other mipmap levels\\n\\n\\t\\t\\t\\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tmipmap = mipmaps[ i ];\\n\\t\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttexture.generateMipmaps = false;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( textureNeedsGenerateMipmaps( texture, isPowerOfTwoImage ) ) _gl.generateMipmap( _gl.TEXTURE_2D );\\n\\n\\t\\t\\ttextureProperties.__version = texture.version;\\n\\n\\t\\t\\tif ( texture.onUpdate ) texture.onUpdate( texture );\\n\\n\\t\\t}\\n\\n\\t\\t// Render targets\\n\\n\\t\\t// Setup storage for target texture and bind it to correct framebuffer\\n\\t\\tfunction setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {\\n\\n\\t\\t\\tvar glFormat = utils.convert( renderTarget.texture.format );\\n\\t\\t\\tvar glType = utils.convert( renderTarget.texture.type );\\n\\t\\t\\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\\n\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\\n\\t\\t\\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\\n\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\\n\\n\\t\\t}\\n\\n\\t\\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\\n\\t\\tfunction setupRenderBufferStorage( renderbuffer, renderTarget ) {\\n\\n\\t\\t\\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\\n\\n\\t\\t\\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\\n\\n\\t\\t\\t\\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\\n\\t\\t\\t\\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\\n\\n\\t\\t\\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\\n\\n\\t\\t\\t\\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\\n\\t\\t\\t\\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// FIXME: We don't support !depth !stencil\\n\\t\\t\\t\\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\\n\\n\\t\\t}\\n\\n\\t\\t// Setup resources for a Depth Texture for a FBO (needs an extension)\\n\\t\\tfunction setupDepthTexture( framebuffer, renderTarget ) {\\n\\n\\t\\t\\tvar isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );\\n\\t\\t\\tif ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );\\n\\n\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\\n\\n\\t\\t\\tif ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {\\n\\n\\t\\t\\t\\tthrow new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// upload an empty depth texture with framebuffer size\\n\\t\\t\\tif ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||\\n\\t\\t\\t\\t\\trenderTarget.depthTexture.image.width !== renderTarget.width ||\\n\\t\\t\\t\\t\\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\\n\\n\\t\\t\\t\\trenderTarget.depthTexture.image.width = renderTarget.width;\\n\\t\\t\\t\\trenderTarget.depthTexture.image.height = renderTarget.height;\\n\\t\\t\\t\\trenderTarget.depthTexture.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tsetTexture2D( renderTarget.depthTexture, 0 );\\n\\n\\t\\t\\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\\n\\n\\t\\t\\tif ( renderTarget.depthTexture.format === DepthFormat ) {\\n\\n\\t\\t\\t\\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\\n\\n\\t\\t\\t} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {\\n\\n\\t\\t\\t\\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthrow new Error( 'Unknown depthTexture format' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// Setup GL resources for a non-texture depth buffer\\n\\t\\tfunction setupDepthRenderbuffer( renderTarget ) {\\n\\n\\t\\t\\tvar renderTargetProperties = properties.get( renderTarget );\\n\\n\\t\\t\\tvar isCube = ( renderTarget.isWebGLRenderTargetCube === true );\\n\\n\\t\\t\\tif ( renderTarget.depthTexture ) {\\n\\n\\t\\t\\t\\tif ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );\\n\\n\\t\\t\\t\\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tif ( isCube ) {\\n\\n\\t\\t\\t\\t\\trenderTargetProperties.__webglDepthbuffer = [];\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\\n\\t\\t\\t\\t\\t\\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\\n\\t\\t\\t\\t\\t\\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\\n\\t\\t\\t\\t\\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\\n\\t\\t\\t\\t\\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\\n\\n\\t\\t}\\n\\n\\t\\t// Set up GL resources for the render target\\n\\t\\tfunction setupRenderTarget( renderTarget ) {\\n\\n\\t\\t\\tvar renderTargetProperties = properties.get( renderTarget );\\n\\t\\t\\tvar textureProperties = properties.get( renderTarget.texture );\\n\\n\\t\\t\\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\\n\\n\\t\\t\\ttextureProperties.__webglTexture = _gl.createTexture();\\n\\n\\t\\t\\tinfoMemory.textures ++;\\n\\n\\t\\t\\tvar isCube = ( renderTarget.isWebGLRenderTargetCube === true );\\n\\t\\t\\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\\n\\n\\t\\t\\t// Setup framebuffer\\n\\n\\t\\t\\tif ( isCube ) {\\n\\n\\t\\t\\t\\trenderTargetProperties.__webglFramebuffer = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Setup color buffer\\n\\n\\t\\t\\tif ( isCube ) {\\n\\n\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\\n\\t\\t\\t\\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\t\\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\\n\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\\n\\t\\t\\t\\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\\n\\t\\t\\t\\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\\n\\n\\t\\t\\t\\tif ( textureNeedsGenerateMipmaps( renderTarget.texture, isTargetPowerOfTwo ) ) _gl.generateMipmap( _gl.TEXTURE_2D );\\n\\t\\t\\t\\tstate.bindTexture( _gl.TEXTURE_2D, null );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Setup depth and stencil buffers\\n\\n\\t\\t\\tif ( renderTarget.depthBuffer ) {\\n\\n\\t\\t\\t\\tsetupDepthRenderbuffer( renderTarget );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction updateRenderTargetMipmap( renderTarget ) {\\n\\n\\t\\t\\tvar texture = renderTarget.texture;\\n\\t\\t\\tvar isTargetPowerOfTwo = isPowerOfTwo( renderTarget );\\n\\n\\t\\t\\tif ( textureNeedsGenerateMipmaps( texture, isTargetPowerOfTwo ) ) {\\n\\n\\t\\t\\t\\tvar target = renderTarget.isWebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\\n\\t\\t\\t\\tvar webglTexture = properties.get( texture ).__webglTexture;\\n\\n\\t\\t\\t\\tstate.bindTexture( target, webglTexture );\\n\\t\\t\\t\\t_gl.generateMipmap( target );\\n\\t\\t\\t\\tstate.bindTexture( target, null );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction updateVideoTextures() {\\n\\n\\t\\t\\tfor ( var id in _videoTextures ) {\\n\\n\\t\\t\\t\\t_videoTextures[ id ].update();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tthis.setTexture2D = setTexture2D;\\n\\t\\tthis.setTextureCube = setTextureCube;\\n\\t\\tthis.setTextureCubeDynamic = setTextureCubeDynamic;\\n\\t\\tthis.setupRenderTarget = setupRenderTarget;\\n\\t\\tthis.updateRenderTargetMipmap = updateRenderTargetMipmap;\\n\\t\\tthis.updateVideoTextures = updateVideoTextures;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author fordacious / fordacious.github.io\\n\\t */\\n\\n\\tfunction WebGLProperties() {\\n\\n\\t\\tvar properties = {};\\n\\n\\t\\tfunction get( object ) {\\n\\n\\t\\t\\tvar uuid = object.uuid;\\n\\t\\t\\tvar map = properties[ uuid ];\\n\\n\\t\\t\\tif ( map === undefined ) {\\n\\n\\t\\t\\t\\tmap = {};\\n\\t\\t\\t\\tproperties[ uuid ] = map;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn map;\\n\\n\\t\\t}\\n\\n\\t\\tfunction remove( object ) {\\n\\n\\t\\t\\tdelete properties[ object.uuid ];\\n\\n\\t\\t}\\n\\n\\t\\tfunction clear() {\\n\\n\\t\\t\\tproperties = {};\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\tget: get,\\n\\t\\t\\tremove: remove,\\n\\t\\t\\tclear: clear\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLState( gl, extensions, utils ) {\\n\\n\\t\\tfunction ColorBuffer() {\\n\\n\\t\\t\\tvar locked = false;\\n\\n\\t\\t\\tvar color = new Vector4();\\n\\t\\t\\tvar currentColorMask = null;\\n\\t\\t\\tvar currentColorClear = new Vector4( 0, 0, 0, 0 );\\n\\n\\t\\t\\treturn {\\n\\n\\t\\t\\t\\tsetMask: function ( colorMask ) {\\n\\n\\t\\t\\t\\t\\tif ( currentColorMask !== colorMask && ! locked ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\\n\\t\\t\\t\\t\\t\\tcurrentColorMask = colorMask;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetLocked: function ( lock ) {\\n\\n\\t\\t\\t\\t\\tlocked = lock;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetClear: function ( r, g, b, a, premultipliedAlpha ) {\\n\\n\\t\\t\\t\\t\\tif ( premultipliedAlpha === true ) {\\n\\n\\t\\t\\t\\t\\t\\tr *= a; g *= a; b *= a;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcolor.set( r, g, b, a );\\n\\n\\t\\t\\t\\t\\tif ( currentColorClear.equals( color ) === false ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.clearColor( r, g, b, a );\\n\\t\\t\\t\\t\\t\\tcurrentColorClear.copy( color );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\treset: function () {\\n\\n\\t\\t\\t\\t\\tlocked = false;\\n\\n\\t\\t\\t\\t\\tcurrentColorMask = null;\\n\\t\\t\\t\\t\\tcurrentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}\\n\\n\\t\\tfunction DepthBuffer() {\\n\\n\\t\\t\\tvar locked = false;\\n\\n\\t\\t\\tvar currentDepthMask = null;\\n\\t\\t\\tvar currentDepthFunc = null;\\n\\t\\t\\tvar currentDepthClear = null;\\n\\n\\t\\t\\treturn {\\n\\n\\t\\t\\t\\tsetTest: function ( depthTest ) {\\n\\n\\t\\t\\t\\t\\tif ( depthTest ) {\\n\\n\\t\\t\\t\\t\\t\\tenable( gl.DEPTH_TEST );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tdisable( gl.DEPTH_TEST );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetMask: function ( depthMask ) {\\n\\n\\t\\t\\t\\t\\tif ( currentDepthMask !== depthMask && ! locked ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.depthMask( depthMask );\\n\\t\\t\\t\\t\\t\\tcurrentDepthMask = depthMask;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetFunc: function ( depthFunc ) {\\n\\n\\t\\t\\t\\t\\tif ( currentDepthFunc !== depthFunc ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( depthFunc ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tswitch ( depthFunc ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase NeverDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.NEVER );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase AlwaysDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.ALWAYS );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase LessDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.LESS );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase LessEqualDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.LEQUAL );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase EqualDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.EQUAL );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase GreaterEqualDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.GEQUAL );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase GreaterDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.GREATER );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase NotEqualDepth:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.NOTEQUAL );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.LEQUAL );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tgl.depthFunc( gl.LEQUAL );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tcurrentDepthFunc = depthFunc;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetLocked: function ( lock ) {\\n\\n\\t\\t\\t\\t\\tlocked = lock;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetClear: function ( depth ) {\\n\\n\\t\\t\\t\\t\\tif ( currentDepthClear !== depth ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.clearDepth( depth );\\n\\t\\t\\t\\t\\t\\tcurrentDepthClear = depth;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\treset: function () {\\n\\n\\t\\t\\t\\t\\tlocked = false;\\n\\n\\t\\t\\t\\t\\tcurrentDepthMask = null;\\n\\t\\t\\t\\t\\tcurrentDepthFunc = null;\\n\\t\\t\\t\\t\\tcurrentDepthClear = null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}\\n\\n\\t\\tfunction StencilBuffer() {\\n\\n\\t\\t\\tvar locked = false;\\n\\n\\t\\t\\tvar currentStencilMask = null;\\n\\t\\t\\tvar currentStencilFunc = null;\\n\\t\\t\\tvar currentStencilRef = null;\\n\\t\\t\\tvar currentStencilFuncMask = null;\\n\\t\\t\\tvar currentStencilFail = null;\\n\\t\\t\\tvar currentStencilZFail = null;\\n\\t\\t\\tvar currentStencilZPass = null;\\n\\t\\t\\tvar currentStencilClear = null;\\n\\n\\t\\t\\treturn {\\n\\n\\t\\t\\t\\tsetTest: function ( stencilTest ) {\\n\\n\\t\\t\\t\\t\\tif ( stencilTest ) {\\n\\n\\t\\t\\t\\t\\t\\tenable( gl.STENCIL_TEST );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tdisable( gl.STENCIL_TEST );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetMask: function ( stencilMask ) {\\n\\n\\t\\t\\t\\t\\tif ( currentStencilMask !== stencilMask && ! locked ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.stencilMask( stencilMask );\\n\\t\\t\\t\\t\\t\\tcurrentStencilMask = stencilMask;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetFunc: function ( stencilFunc, stencilRef, stencilMask ) {\\n\\n\\t\\t\\t\\t\\tif ( currentStencilFunc !== stencilFunc ||\\n\\t\\t\\t\\t\\t     currentStencilRef \\t!== stencilRef \\t||\\n\\t\\t\\t\\t\\t     currentStencilFuncMask !== stencilMask ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.stencilFunc( stencilFunc, stencilRef, stencilMask );\\n\\n\\t\\t\\t\\t\\t\\tcurrentStencilFunc = stencilFunc;\\n\\t\\t\\t\\t\\t\\tcurrentStencilRef = stencilRef;\\n\\t\\t\\t\\t\\t\\tcurrentStencilFuncMask = stencilMask;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetOp: function ( stencilFail, stencilZFail, stencilZPass ) {\\n\\n\\t\\t\\t\\t\\tif ( currentStencilFail\\t !== stencilFail \\t||\\n\\t\\t\\t\\t\\t     currentStencilZFail !== stencilZFail ||\\n\\t\\t\\t\\t\\t     currentStencilZPass !== stencilZPass ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.stencilOp( stencilFail, stencilZFail, stencilZPass );\\n\\n\\t\\t\\t\\t\\t\\tcurrentStencilFail = stencilFail;\\n\\t\\t\\t\\t\\t\\tcurrentStencilZFail = stencilZFail;\\n\\t\\t\\t\\t\\t\\tcurrentStencilZPass = stencilZPass;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetLocked: function ( lock ) {\\n\\n\\t\\t\\t\\t\\tlocked = lock;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tsetClear: function ( stencil ) {\\n\\n\\t\\t\\t\\t\\tif ( currentStencilClear !== stencil ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.clearStencil( stencil );\\n\\t\\t\\t\\t\\t\\tcurrentStencilClear = stencil;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\treset: function () {\\n\\n\\t\\t\\t\\t\\tlocked = false;\\n\\n\\t\\t\\t\\t\\tcurrentStencilMask = null;\\n\\t\\t\\t\\t\\tcurrentStencilFunc = null;\\n\\t\\t\\t\\t\\tcurrentStencilRef = null;\\n\\t\\t\\t\\t\\tcurrentStencilFuncMask = null;\\n\\t\\t\\t\\t\\tcurrentStencilFail = null;\\n\\t\\t\\t\\t\\tcurrentStencilZFail = null;\\n\\t\\t\\t\\t\\tcurrentStencilZPass = null;\\n\\t\\t\\t\\t\\tcurrentStencilClear = null;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tvar colorBuffer = new ColorBuffer();\\n\\t\\tvar depthBuffer = new DepthBuffer();\\n\\t\\tvar stencilBuffer = new StencilBuffer();\\n\\n\\t\\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\\n\\t\\tvar newAttributes = new Uint8Array( maxVertexAttributes );\\n\\t\\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\\n\\t\\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\\n\\n\\t\\tvar capabilities = {};\\n\\n\\t\\tvar compressedTextureFormats = null;\\n\\n\\t\\tvar currentProgram = null;\\n\\n\\t\\tvar currentBlending = null;\\n\\t\\tvar currentBlendEquation = null;\\n\\t\\tvar currentBlendSrc = null;\\n\\t\\tvar currentBlendDst = null;\\n\\t\\tvar currentBlendEquationAlpha = null;\\n\\t\\tvar currentBlendSrcAlpha = null;\\n\\t\\tvar currentBlendDstAlpha = null;\\n\\t\\tvar currentPremultipledAlpha = false;\\n\\n\\t\\tvar currentFlipSided = null;\\n\\t\\tvar currentCullFace = null;\\n\\n\\t\\tvar currentLineWidth = null;\\n\\n\\t\\tvar currentPolygonOffsetFactor = null;\\n\\t\\tvar currentPolygonOffsetUnits = null;\\n\\n\\t\\tvar maxTextures = gl.getParameter( gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS );\\n\\n\\t\\tvar version = parseFloat( /^WebGL\\\\ ([0-9])/.exec( gl.getParameter( gl.VERSION ) )[ 1 ] );\\n\\t\\tvar lineWidthAvailable = parseFloat( version ) >= 1.0;\\n\\n\\t\\tvar currentTextureSlot = null;\\n\\t\\tvar currentBoundTextures = {};\\n\\n\\t\\tvar currentScissor = new Vector4();\\n\\t\\tvar currentViewport = new Vector4();\\n\\n\\t\\tfunction createTexture( type, target, count ) {\\n\\n\\t\\t\\tvar data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.\\n\\t\\t\\tvar texture = gl.createTexture();\\n\\n\\t\\t\\tgl.bindTexture( type, texture );\\n\\t\\t\\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\\n\\t\\t\\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\\n\\n\\t\\t\\tfor ( var i = 0; i < count; i ++ ) {\\n\\n\\t\\t\\t\\tgl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t}\\n\\n\\t\\tvar emptyTextures = {};\\n\\t\\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\\n\\t\\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\\n\\n\\t\\t// init\\n\\n\\t\\tcolorBuffer.setClear( 0, 0, 0, 1 );\\n\\t\\tdepthBuffer.setClear( 1 );\\n\\t\\tstencilBuffer.setClear( 0 );\\n\\n\\t\\tenable( gl.DEPTH_TEST );\\n\\t\\tdepthBuffer.setFunc( LessEqualDepth );\\n\\n\\t\\tsetFlipSided( false );\\n\\t\\tsetCullFace( CullFaceBack );\\n\\t\\tenable( gl.CULL_FACE );\\n\\n\\t\\tenable( gl.BLEND );\\n\\t\\tsetBlending( NormalBlending );\\n\\n\\t\\t//\\n\\n\\t\\tfunction initAttributes() {\\n\\n\\t\\t\\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tnewAttributes[ i ] = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction enableAttribute( attribute ) {\\n\\n\\t\\t\\tnewAttributes[ attribute ] = 1;\\n\\n\\t\\t\\tif ( enabledAttributes[ attribute ] === 0 ) {\\n\\n\\t\\t\\t\\tgl.enableVertexAttribArray( attribute );\\n\\t\\t\\t\\tenabledAttributes[ attribute ] = 1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( attributeDivisors[ attribute ] !== 0 ) {\\n\\n\\t\\t\\t\\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\\n\\n\\t\\t\\t\\textension.vertexAttribDivisorANGLE( attribute, 0 );\\n\\t\\t\\t\\tattributeDivisors[ attribute ] = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction enableAttributeAndDivisor( attribute, meshPerAttribute ) {\\n\\n\\t\\t\\tnewAttributes[ attribute ] = 1;\\n\\n\\t\\t\\tif ( enabledAttributes[ attribute ] === 0 ) {\\n\\n\\t\\t\\t\\tgl.enableVertexAttribArray( attribute );\\n\\t\\t\\t\\tenabledAttributes[ attribute ] = 1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\\n\\n\\t\\t\\t\\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\\n\\n\\t\\t\\t\\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\\n\\t\\t\\t\\tattributeDivisors[ attribute ] = meshPerAttribute;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction disableUnusedAttributes() {\\n\\n\\t\\t\\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\\n\\n\\t\\t\\t\\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\\n\\n\\t\\t\\t\\t\\tgl.disableVertexAttribArray( i );\\n\\t\\t\\t\\t\\tenabledAttributes[ i ] = 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction enable( id ) {\\n\\n\\t\\t\\tif ( capabilities[ id ] !== true ) {\\n\\n\\t\\t\\t\\tgl.enable( id );\\n\\t\\t\\t\\tcapabilities[ id ] = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction disable( id ) {\\n\\n\\t\\t\\tif ( capabilities[ id ] !== false ) {\\n\\n\\t\\t\\t\\tgl.disable( id );\\n\\t\\t\\t\\tcapabilities[ id ] = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction getCompressedTextureFormats() {\\n\\n\\t\\t\\tif ( compressedTextureFormats === null ) {\\n\\n\\t\\t\\t\\tcompressedTextureFormats = [];\\n\\n\\t\\t\\t\\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\\n\\t\\t\\t\\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\\n\\t\\t\\t\\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\\n\\n\\t\\t\\t\\t\\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < formats.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tcompressedTextureFormats.push( formats[ i ] );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn compressedTextureFormats;\\n\\n\\t\\t}\\n\\n\\t\\tfunction useProgram( program ) {\\n\\n\\t\\t\\tif ( currentProgram !== program ) {\\n\\n\\t\\t\\t\\tgl.useProgram( program );\\n\\n\\t\\t\\t\\tcurrentProgram = program;\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn false;\\n\\n\\t\\t}\\n\\n\\t\\tfunction setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\\n\\n\\t\\t\\tif ( blending !== NoBlending ) {\\n\\n\\t\\t\\t\\tenable( gl.BLEND );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdisable( gl.BLEND );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( blending !== CustomBlending ) {\\n\\n\\t\\t\\t\\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\\n\\n\\t\\t\\t\\t\\tswitch ( blending ) {\\n\\n\\t\\t\\t\\t\\t\\tcase AdditiveBlending:\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( premultipliedAlpha ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquation( gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase SubtractiveBlending:\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( premultipliedAlpha ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquation( gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase MultiplyBlending:\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( premultipliedAlpha ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquation( gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( premultipliedAlpha ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\\n\\t\\t\\t\\t\\t\\t\\t\\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcurrentBlendEquation = null;\\n\\t\\t\\t\\tcurrentBlendSrc = null;\\n\\t\\t\\t\\tcurrentBlendDst = null;\\n\\t\\t\\t\\tcurrentBlendEquationAlpha = null;\\n\\t\\t\\t\\tcurrentBlendSrcAlpha = null;\\n\\t\\t\\t\\tcurrentBlendDstAlpha = null;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tblendEquationAlpha = blendEquationAlpha || blendEquation;\\n\\t\\t\\t\\tblendSrcAlpha = blendSrcAlpha || blendSrc;\\n\\t\\t\\t\\tblendDstAlpha = blendDstAlpha || blendDst;\\n\\n\\t\\t\\t\\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\\n\\n\\t\\t\\t\\t\\tgl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );\\n\\n\\t\\t\\t\\t\\tcurrentBlendEquation = blendEquation;\\n\\t\\t\\t\\t\\tcurrentBlendEquationAlpha = blendEquationAlpha;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\\n\\n\\t\\t\\t\\t\\tgl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );\\n\\n\\t\\t\\t\\t\\tcurrentBlendSrc = blendSrc;\\n\\t\\t\\t\\t\\tcurrentBlendDst = blendDst;\\n\\t\\t\\t\\t\\tcurrentBlendSrcAlpha = blendSrcAlpha;\\n\\t\\t\\t\\t\\tcurrentBlendDstAlpha = blendDstAlpha;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurrentBlending = blending;\\n\\t\\t\\tcurrentPremultipledAlpha = premultipliedAlpha;\\n\\n\\t\\t}\\n\\n\\t\\tfunction setMaterial( material, frontFaceCW ) {\\n\\n\\t\\t\\tmaterial.side === DoubleSide\\n\\t\\t\\t\\t? disable( gl.CULL_FACE )\\n\\t\\t\\t\\t: enable( gl.CULL_FACE );\\n\\n\\t\\t\\tvar flipSided = ( material.side === BackSide );\\n\\t\\t\\tif ( frontFaceCW ) flipSided = ! flipSided;\\n\\n\\t\\t\\tsetFlipSided( flipSided );\\n\\n\\t\\t\\tmaterial.transparent === true\\n\\t\\t\\t\\t? setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )\\n\\t\\t\\t\\t: setBlending( NoBlending );\\n\\n\\t\\t\\tdepthBuffer.setFunc( material.depthFunc );\\n\\t\\t\\tdepthBuffer.setTest( material.depthTest );\\n\\t\\t\\tdepthBuffer.setMask( material.depthWrite );\\n\\t\\t\\tcolorBuffer.setMask( material.colorWrite );\\n\\n\\t\\t\\tsetPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction setFlipSided( flipSided ) {\\n\\n\\t\\t\\tif ( currentFlipSided !== flipSided ) {\\n\\n\\t\\t\\t\\tif ( flipSided ) {\\n\\n\\t\\t\\t\\t\\tgl.frontFace( gl.CW );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tgl.frontFace( gl.CCW );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcurrentFlipSided = flipSided;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction setCullFace( cullFace ) {\\n\\n\\t\\t\\tif ( cullFace !== CullFaceNone ) {\\n\\n\\t\\t\\t\\tenable( gl.CULL_FACE );\\n\\n\\t\\t\\t\\tif ( cullFace !== currentCullFace ) {\\n\\n\\t\\t\\t\\t\\tif ( cullFace === CullFaceBack ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.cullFace( gl.BACK );\\n\\n\\t\\t\\t\\t\\t} else if ( cullFace === CullFaceFront ) {\\n\\n\\t\\t\\t\\t\\t\\tgl.cullFace( gl.FRONT );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tgl.cullFace( gl.FRONT_AND_BACK );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdisable( gl.CULL_FACE );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tcurrentCullFace = cullFace;\\n\\n\\t\\t}\\n\\n\\t\\tfunction setLineWidth( width ) {\\n\\n\\t\\t\\tif ( width !== currentLineWidth ) {\\n\\n\\t\\t\\t\\tif ( lineWidthAvailable ) gl.lineWidth( width );\\n\\n\\t\\t\\t\\tcurrentLineWidth = width;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction setPolygonOffset( polygonOffset, factor, units ) {\\n\\n\\t\\t\\tif ( polygonOffset ) {\\n\\n\\t\\t\\t\\tenable( gl.POLYGON_OFFSET_FILL );\\n\\n\\t\\t\\t\\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\\n\\n\\t\\t\\t\\t\\tgl.polygonOffset( factor, units );\\n\\n\\t\\t\\t\\t\\tcurrentPolygonOffsetFactor = factor;\\n\\t\\t\\t\\t\\tcurrentPolygonOffsetUnits = units;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdisable( gl.POLYGON_OFFSET_FILL );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction setScissorTest( scissorTest ) {\\n\\n\\t\\t\\tif ( scissorTest ) {\\n\\n\\t\\t\\t\\tenable( gl.SCISSOR_TEST );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdisable( gl.SCISSOR_TEST );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// texture\\n\\n\\t\\tfunction activeTexture( webglSlot ) {\\n\\n\\t\\t\\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\\n\\n\\t\\t\\tif ( currentTextureSlot !== webglSlot ) {\\n\\n\\t\\t\\t\\tgl.activeTexture( webglSlot );\\n\\t\\t\\t\\tcurrentTextureSlot = webglSlot;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction bindTexture( webglType, webglTexture ) {\\n\\n\\t\\t\\tif ( currentTextureSlot === null ) {\\n\\n\\t\\t\\t\\tactiveTexture();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\\n\\n\\t\\t\\tif ( boundTexture === undefined ) {\\n\\n\\t\\t\\t\\tboundTexture = { type: undefined, texture: undefined };\\n\\t\\t\\t\\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\\n\\n\\t\\t\\t\\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\\n\\n\\t\\t\\t\\tboundTexture.type = webglType;\\n\\t\\t\\t\\tboundTexture.texture = webglTexture;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction compressedTexImage2D() {\\n\\n\\t\\t\\ttry {\\n\\n\\t\\t\\t\\tgl.compressedTexImage2D.apply( gl, arguments );\\n\\n\\t\\t\\t} catch ( error ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLState:', error );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction texImage2D() {\\n\\n\\t\\t\\ttry {\\n\\n\\t\\t\\t\\tgl.texImage2D.apply( gl, arguments );\\n\\n\\t\\t\\t} catch ( error ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLState:', error );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction scissor( scissor ) {\\n\\n\\t\\t\\tif ( currentScissor.equals( scissor ) === false ) {\\n\\n\\t\\t\\t\\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\\n\\t\\t\\t\\tcurrentScissor.copy( scissor );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction viewport( viewport ) {\\n\\n\\t\\t\\tif ( currentViewport.equals( viewport ) === false ) {\\n\\n\\t\\t\\t\\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\\n\\t\\t\\t\\tcurrentViewport.copy( viewport );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tfunction reset() {\\n\\n\\t\\t\\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\\n\\n\\t\\t\\t\\tif ( enabledAttributes[ i ] === 1 ) {\\n\\n\\t\\t\\t\\t\\tgl.disableVertexAttribArray( i );\\n\\t\\t\\t\\t\\tenabledAttributes[ i ] = 0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tcapabilities = {};\\n\\n\\t\\t\\tcompressedTextureFormats = null;\\n\\n\\t\\t\\tcurrentTextureSlot = null;\\n\\t\\t\\tcurrentBoundTextures = {};\\n\\n\\t\\t\\tcurrentProgram = null;\\n\\n\\t\\t\\tcurrentBlending = null;\\n\\n\\t\\t\\tcurrentFlipSided = null;\\n\\t\\t\\tcurrentCullFace = null;\\n\\n\\t\\t\\tcolorBuffer.reset();\\n\\t\\t\\tdepthBuffer.reset();\\n\\t\\t\\tstencilBuffer.reset();\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tbuffers: {\\n\\t\\t\\t\\tcolor: colorBuffer,\\n\\t\\t\\t\\tdepth: depthBuffer,\\n\\t\\t\\t\\tstencil: stencilBuffer\\n\\t\\t\\t},\\n\\n\\t\\t\\tinitAttributes: initAttributes,\\n\\t\\t\\tenableAttribute: enableAttribute,\\n\\t\\t\\tenableAttributeAndDivisor: enableAttributeAndDivisor,\\n\\t\\t\\tdisableUnusedAttributes: disableUnusedAttributes,\\n\\t\\t\\tenable: enable,\\n\\t\\t\\tdisable: disable,\\n\\t\\t\\tgetCompressedTextureFormats: getCompressedTextureFormats,\\n\\n\\t\\t\\tuseProgram: useProgram,\\n\\n\\t\\t\\tsetBlending: setBlending,\\n\\t\\t\\tsetMaterial: setMaterial,\\n\\n\\t\\t\\tsetFlipSided: setFlipSided,\\n\\t\\t\\tsetCullFace: setCullFace,\\n\\n\\t\\t\\tsetLineWidth: setLineWidth,\\n\\t\\t\\tsetPolygonOffset: setPolygonOffset,\\n\\n\\t\\t\\tsetScissorTest: setScissorTest,\\n\\n\\t\\t\\tactiveTexture: activeTexture,\\n\\t\\t\\tbindTexture: bindTexture,\\n\\t\\t\\tcompressedTexImage2D: compressedTexImage2D,\\n\\t\\t\\ttexImage2D: texImage2D,\\n\\n\\t\\t\\tscissor: scissor,\\n\\t\\t\\tviewport: viewport,\\n\\n\\t\\t\\treset: reset\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLCapabilities( gl, extensions, parameters ) {\\n\\n\\t\\tvar maxAnisotropy;\\n\\n\\t\\tfunction getMaxAnisotropy() {\\n\\n\\t\\t\\tif ( maxAnisotropy !== undefined ) return maxAnisotropy;\\n\\n\\t\\t\\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\\n\\n\\t\\t\\tif ( extension !== null ) {\\n\\n\\t\\t\\t\\tmaxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tmaxAnisotropy = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn maxAnisotropy;\\n\\n\\t\\t}\\n\\n\\t\\tfunction getMaxPrecision( precision ) {\\n\\n\\t\\t\\tif ( precision === 'highp' ) {\\n\\n\\t\\t\\t\\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\\n\\t\\t\\t\\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\\n\\n\\t\\t\\t\\t\\treturn 'highp';\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tprecision = 'mediump';\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( precision === 'mediump' ) {\\n\\n\\t\\t\\t\\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\\n\\t\\t\\t\\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\\n\\n\\t\\t\\t\\t\\treturn 'mediump';\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 'lowp';\\n\\n\\t\\t}\\n\\n\\t\\tvar precision = parameters.precision !== undefined ? parameters.precision : 'highp';\\n\\t\\tvar maxPrecision = getMaxPrecision( precision );\\n\\n\\t\\tif ( maxPrecision !== precision ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );\\n\\t\\t\\tprecision = maxPrecision;\\n\\n\\t\\t}\\n\\n\\t\\tvar logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\\n\\n\\t\\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\\n\\t\\tvar maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\\n\\t\\tvar maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\\n\\t\\tvar maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\\n\\n\\t\\tvar maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\\n\\t\\tvar maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\\n\\t\\tvar maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\\n\\t\\tvar maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\\n\\n\\t\\tvar vertexTextures = maxVertexTextures > 0;\\n\\t\\tvar floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\\n\\t\\tvar floatVertexTextures = vertexTextures && floatFragmentTextures;\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tgetMaxAnisotropy: getMaxAnisotropy,\\n\\t\\t\\tgetMaxPrecision: getMaxPrecision,\\n\\n\\t\\t\\tprecision: precision,\\n\\t\\t\\tlogarithmicDepthBuffer: logarithmicDepthBuffer,\\n\\n\\t\\t\\tmaxTextures: maxTextures,\\n\\t\\t\\tmaxVertexTextures: maxVertexTextures,\\n\\t\\t\\tmaxTextureSize: maxTextureSize,\\n\\t\\t\\tmaxCubemapSize: maxCubemapSize,\\n\\n\\t\\t\\tmaxAttributes: maxAttributes,\\n\\t\\t\\tmaxVertexUniforms: maxVertexUniforms,\\n\\t\\t\\tmaxVaryings: maxVaryings,\\n\\t\\t\\tmaxFragmentUniforms: maxFragmentUniforms,\\n\\n\\t\\t\\tvertexTextures: vertexTextures,\\n\\t\\t\\tfloatFragmentTextures: floatFragmentTextures,\\n\\t\\t\\tfloatVertexTextures: floatVertexTextures\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author greggman / http://games.greggman.com/\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction PerspectiveCamera( fov, aspect, near, far ) {\\n\\n\\t\\tCamera.call( this );\\n\\n\\t\\tthis.type = 'PerspectiveCamera';\\n\\n\\t\\tthis.fov = fov !== undefined ? fov : 50;\\n\\t\\tthis.zoom = 1;\\n\\n\\t\\tthis.near = near !== undefined ? near : 0.1;\\n\\t\\tthis.far = far !== undefined ? far : 2000;\\n\\t\\tthis.focus = 10;\\n\\n\\t\\tthis.aspect = aspect !== undefined ? aspect : 1;\\n\\t\\tthis.view = null;\\n\\n\\t\\tthis.filmGauge = 35;\\t// width of the film (default in millimeters)\\n\\t\\tthis.filmOffset = 0;\\t// horizontal film offset (same unit as gauge)\\n\\n\\t\\tthis.updateProjectionMatrix();\\n\\n\\t}\\n\\n\\tPerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {\\n\\n\\t\\tconstructor: PerspectiveCamera,\\n\\n\\t\\tisPerspectiveCamera: true,\\n\\n\\t\\tcopy: function ( source, recursive ) {\\n\\n\\t\\t\\tCamera.prototype.copy.call( this, source, recursive );\\n\\n\\t\\t\\tthis.fov = source.fov;\\n\\t\\t\\tthis.zoom = source.zoom;\\n\\n\\t\\t\\tthis.near = source.near;\\n\\t\\t\\tthis.far = source.far;\\n\\t\\t\\tthis.focus = source.focus;\\n\\n\\t\\t\\tthis.aspect = source.aspect;\\n\\t\\t\\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\\n\\n\\t\\t\\tthis.filmGauge = source.filmGauge;\\n\\t\\t\\tthis.filmOffset = source.filmOffset;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Sets the FOV by focal length in respect to the current .filmGauge.\\n\\t\\t *\\n\\t\\t * The default film gauge is 35, so that the focal length can be specified for\\n\\t\\t * a 35mm (full frame) camera.\\n\\t\\t *\\n\\t\\t * Values for focal length and film gauge must have the same unit.\\n\\t\\t */\\n\\t\\tsetFocalLength: function ( focalLength ) {\\n\\n\\t\\t\\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\\n\\t\\t\\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\\n\\n\\t\\t\\tthis.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\\n\\t\\t\\tthis.updateProjectionMatrix();\\n\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Calculates the focal length from the current .fov and .filmGauge.\\n\\t\\t */\\n\\t\\tgetFocalLength: function () {\\n\\n\\t\\t\\tvar vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );\\n\\n\\t\\t\\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\\n\\n\\t\\t},\\n\\n\\t\\tgetEffectiveFOV: function () {\\n\\n\\t\\t\\treturn _Math.RAD2DEG * 2 * Math.atan(\\n\\t\\t\\t\\tMath.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\\n\\n\\t\\t},\\n\\n\\t\\tgetFilmWidth: function () {\\n\\n\\t\\t\\t// film not completely covered in portrait format (aspect < 1)\\n\\t\\t\\treturn this.filmGauge * Math.min( this.aspect, 1 );\\n\\n\\t\\t},\\n\\n\\t\\tgetFilmHeight: function () {\\n\\n\\t\\t\\t// film not completely covered in landscape format (aspect > 1)\\n\\t\\t\\treturn this.filmGauge / Math.max( this.aspect, 1 );\\n\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Sets an offset in a larger frustum. This is useful for multi-window or\\n\\t\\t * multi-monitor/multi-machine setups.\\n\\t\\t *\\n\\t\\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\\n\\t\\t * the monitors are in grid like this\\n\\t\\t *\\n\\t\\t *   +---+---+---+\\n\\t\\t *   | A | B | C |\\n\\t\\t *   +---+---+---+\\n\\t\\t *   | D | E | F |\\n\\t\\t *   +---+---+---+\\n\\t\\t *\\n\\t\\t * then for each monitor you would call it like this\\n\\t\\t *\\n\\t\\t *   var w = 1920;\\n\\t\\t *   var h = 1080;\\n\\t\\t *   var fullWidth = w * 3;\\n\\t\\t *   var fullHeight = h * 2;\\n\\t\\t *\\n\\t\\t *   --A--\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\\n\\t\\t *   --B--\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\\n\\t\\t *   --C--\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\\n\\t\\t *   --D--\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\\n\\t\\t *   --E--\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\\n\\t\\t *   --F--\\n\\t\\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\\n\\t\\t *\\n\\t\\t *   Note there is no reason monitors have to be the same size or in a grid.\\n\\t\\t */\\n\\t\\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\\n\\n\\t\\t\\tthis.aspect = fullWidth / fullHeight;\\n\\n\\t\\t\\tif ( this.view === null ) {\\n\\n\\t\\t\\t\\tthis.view = {\\n\\t\\t\\t\\t\\tenabled: true,\\n\\t\\t\\t\\t\\tfullWidth: 1,\\n\\t\\t\\t\\t\\tfullHeight: 1,\\n\\t\\t\\t\\t\\toffsetX: 0,\\n\\t\\t\\t\\t\\toffsetY: 0,\\n\\t\\t\\t\\t\\twidth: 1,\\n\\t\\t\\t\\t\\theight: 1\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.view.enabled = true;\\n\\t\\t\\tthis.view.fullWidth = fullWidth;\\n\\t\\t\\tthis.view.fullHeight = fullHeight;\\n\\t\\t\\tthis.view.offsetX = x;\\n\\t\\t\\tthis.view.offsetY = y;\\n\\t\\t\\tthis.view.width = width;\\n\\t\\t\\tthis.view.height = height;\\n\\n\\t\\t\\tthis.updateProjectionMatrix();\\n\\n\\t\\t},\\n\\n\\t\\tclearViewOffset: function () {\\n\\n\\t\\t\\tif ( this.view !== null ) {\\n\\n\\t\\t\\t\\tthis.view.enabled = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.updateProjectionMatrix();\\n\\n\\t\\t},\\n\\n\\t\\tupdateProjectionMatrix: function () {\\n\\n\\t\\t\\tvar near = this.near,\\n\\t\\t\\t\\ttop = near * Math.tan(\\n\\t\\t\\t\\t\\t_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\\n\\t\\t\\t\\theight = 2 * top,\\n\\t\\t\\t\\twidth = this.aspect * height,\\n\\t\\t\\t\\tleft = - 0.5 * width,\\n\\t\\t\\t\\tview = this.view;\\n\\n\\t\\t\\tif ( this.view !== null && this.view.enabled ) {\\n\\n\\t\\t\\t\\tvar fullWidth = view.fullWidth,\\n\\t\\t\\t\\t\\tfullHeight = view.fullHeight;\\n\\n\\t\\t\\t\\tleft += view.offsetX * width / fullWidth;\\n\\t\\t\\t\\ttop -= view.offsetY * height / fullHeight;\\n\\t\\t\\t\\twidth *= view.width / fullWidth;\\n\\t\\t\\t\\theight *= view.height / fullHeight;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar skew = this.filmOffset;\\n\\t\\t\\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\\n\\n\\t\\t\\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\n\\n\\t\\t\\tdata.object.fov = this.fov;\\n\\t\\t\\tdata.object.zoom = this.zoom;\\n\\n\\t\\t\\tdata.object.near = this.near;\\n\\t\\t\\tdata.object.far = this.far;\\n\\t\\t\\tdata.object.focus = this.focus;\\n\\n\\t\\t\\tdata.object.aspect = this.aspect;\\n\\n\\t\\t\\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\\n\\n\\t\\t\\tdata.object.filmGauge = this.filmGauge;\\n\\t\\t\\tdata.object.filmOffset = this.filmOffset;\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction ArrayCamera( array ) {\\n\\n\\t\\tPerspectiveCamera.call( this );\\n\\n\\t\\tthis.cameras = array || [];\\n\\n\\t}\\n\\n\\tArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {\\n\\n\\t\\tconstructor: ArrayCamera,\\n\\n\\t\\tisArrayCamera: true\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebVRManager( renderer ) {\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tvar device = null;\\n\\t\\tvar frameData = null;\\n\\n\\t\\tvar poseTarget = null;\\n\\n\\t\\tif ( typeof window !== 'undefined' && 'VRFrameData' in window ) {\\n\\n\\t\\t\\tframeData = new window.VRFrameData();\\n\\n\\t\\t}\\n\\n\\t\\tvar matrixWorldInverse = new Matrix4();\\n\\n\\t\\tvar cameraL = new PerspectiveCamera();\\n\\t\\tcameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );\\n\\t\\tcameraL.layers.enable( 1 );\\n\\n\\t\\tvar cameraR = new PerspectiveCamera();\\n\\t\\tcameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );\\n\\t\\tcameraR.layers.enable( 2 );\\n\\n\\t\\tvar cameraVR = new ArrayCamera( [ cameraL, cameraR ] );\\n\\t\\tcameraVR.layers.enable( 1 );\\n\\t\\tcameraVR.layers.enable( 2 );\\n\\n\\t\\t//\\n\\n\\t\\tvar currentSize, currentPixelRatio;\\n\\n\\t\\tfunction onVRDisplayPresentChange() {\\n\\n\\t\\t\\tif ( device !== null && device.isPresenting ) {\\n\\n\\t\\t\\t\\tvar eyeParameters = device.getEyeParameters( 'left' );\\n\\t\\t\\t\\tvar renderWidth = eyeParameters.renderWidth;\\n\\t\\t\\t\\tvar renderHeight = eyeParameters.renderHeight;\\n\\n\\t\\t\\t\\tcurrentPixelRatio = renderer.getPixelRatio();\\n\\t\\t\\t\\tcurrentSize = renderer.getSize();\\n\\n\\t\\t\\t\\trenderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );\\n\\n\\t\\t\\t} else if ( scope.enabled ) {\\n\\n\\t\\t\\t\\trenderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tif ( typeof window !== 'undefined' ) {\\n\\n\\t\\t\\twindow.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tthis.enabled = false;\\n\\n\\t\\tthis.getDevice = function () {\\n\\n\\t\\t\\treturn device;\\n\\n\\t\\t};\\n\\n\\t\\tthis.setDevice = function ( value ) {\\n\\n\\t\\t\\tif ( value !== undefined ) device = value;\\n\\n\\t\\t};\\n\\n\\t\\tthis.setPoseTarget = function ( object ) {\\n\\n\\t\\t\\tif ( object !== undefined ) poseTarget = object;\\n\\n\\t\\t};\\n\\n\\t\\tthis.getCamera = function ( camera ) {\\n\\n\\t\\t\\tif ( device === null ) return camera;\\n\\n\\t\\t\\tdevice.depthNear = camera.near;\\n\\t\\t\\tdevice.depthFar = camera.far;\\n\\n\\t\\t\\tdevice.getFrameData( frameData );\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar pose = frameData.pose;\\n\\t\\t\\tvar poseObject = poseTarget !== null ? poseTarget : camera;\\n\\n\\t\\t\\tif ( pose.position !== null ) {\\n\\n\\t\\t\\t\\tposeObject.position.fromArray( pose.position );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tposeObject.position.set( 0, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( pose.orientation !== null ) {\\n\\n\\t\\t\\t\\tposeObject.quaternion.fromArray( pose.orientation );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tposeObject.updateMatrixWorld();\\n\\n\\t\\t\\tif ( device.isPresenting === false ) return camera;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tcameraL.near = camera.near;\\n\\t\\t\\tcameraR.near = camera.near;\\n\\n\\t\\t\\tcameraL.far = camera.far;\\n\\t\\t\\tcameraR.far = camera.far;\\n\\n\\t\\t\\tcameraVR.matrixWorld.copy( camera.matrixWorld );\\n\\t\\t\\tcameraVR.matrixWorldInverse.copy( camera.matrixWorldInverse );\\n\\n\\t\\t\\tcameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );\\n\\t\\t\\tcameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );\\n\\n\\t\\t\\tvar parent = poseObject.parent;\\n\\n\\t\\t\\tif ( parent !== null ) {\\n\\n\\t\\t\\t\\tmatrixWorldInverse.getInverse( parent.matrixWorld );\\n\\n\\t\\t\\t\\tcameraL.matrixWorldInverse.multiply( matrixWorldInverse );\\n\\t\\t\\t\\tcameraR.matrixWorldInverse.multiply( matrixWorldInverse );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// envMap and Mirror needs camera.matrixWorld\\n\\n\\t\\t\\tcameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );\\n\\t\\t\\tcameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );\\n\\n\\t\\t\\tcameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );\\n\\t\\t\\tcameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );\\n\\n\\t\\t\\t// HACK @mrdoob\\n\\t\\t\\t// https://github.com/w3c/webvr/issues/203\\n\\n\\t\\t\\tcameraVR.projectionMatrix.copy( cameraL.projectionMatrix );\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar layers = device.getLayers();\\n\\n\\t\\t\\tif ( layers.length ) {\\n\\n\\t\\t\\t\\tvar layer = layers[ 0 ];\\n\\n\\t\\t\\t\\tif ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {\\n\\n\\t\\t\\t\\t\\tcameraL.bounds.fromArray( layer.leftBounds );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {\\n\\n\\t\\t\\t\\t\\tcameraR.bounds.fromArray( layer.rightBounds );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn cameraVR;\\n\\n\\t\\t};\\n\\n\\t\\tthis.submitFrame = function () {\\n\\n\\t\\t\\tif ( device && device.isPresenting ) device.submitFrame();\\n\\n\\t\\t};\\n\\n\\t\\tthis.dispose = function () {\\n\\n\\t\\t\\tif ( typeof window !== 'undefined' ) {\\n\\n\\t\\t\\t\\twindow.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction WebGLExtensions( gl ) {\\n\\n\\t\\tvar extensions = {};\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tget: function ( name ) {\\n\\n\\t\\t\\t\\tif ( extensions[ name ] !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn extensions[ name ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar extension;\\n\\n\\t\\t\\t\\tswitch ( name ) {\\n\\n\\t\\t\\t\\t\\tcase 'WEBGL_depth_texture':\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'EXT_texture_filter_anisotropic':\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'WEBGL_compressed_texture_s3tc':\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'WEBGL_compressed_texture_pvrtc':\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'WEBGL_compressed_texture_etc1':\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\textension = gl.getExtension( name );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( extension === null ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\textensions[ name ] = extension;\\n\\n\\t\\t\\t\\treturn extension;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction WebGLClipping() {\\n\\n\\t\\tvar scope = this,\\n\\n\\t\\t\\tglobalState = null,\\n\\t\\t\\tnumGlobalPlanes = 0,\\n\\t\\t\\tlocalClippingEnabled = false,\\n\\t\\t\\trenderingShadows = false,\\n\\n\\t\\t\\tplane = new Plane(),\\n\\t\\t\\tviewNormalMatrix = new Matrix3(),\\n\\n\\t\\t\\tuniform = { value: null, needsUpdate: false };\\n\\n\\t\\tthis.uniform = uniform;\\n\\t\\tthis.numPlanes = 0;\\n\\t\\tthis.numIntersection = 0;\\n\\n\\t\\tthis.init = function ( planes, enableLocalClipping, camera ) {\\n\\n\\t\\t\\tvar enabled =\\n\\t\\t\\t\\tplanes.length !== 0 ||\\n\\t\\t\\t\\tenableLocalClipping ||\\n\\t\\t\\t\\t// enable state of previous frame - the clipping code has to\\n\\t\\t\\t\\t// run another frame in order to reset the state:\\n\\t\\t\\t\\tnumGlobalPlanes !== 0 ||\\n\\t\\t\\t\\tlocalClippingEnabled;\\n\\n\\t\\t\\tlocalClippingEnabled = enableLocalClipping;\\n\\n\\t\\t\\tglobalState = projectPlanes( planes, camera, 0 );\\n\\t\\t\\tnumGlobalPlanes = planes.length;\\n\\n\\t\\t\\treturn enabled;\\n\\n\\t\\t};\\n\\n\\t\\tthis.beginShadows = function () {\\n\\n\\t\\t\\trenderingShadows = true;\\n\\t\\t\\tprojectPlanes( null );\\n\\n\\t\\t};\\n\\n\\t\\tthis.endShadows = function () {\\n\\n\\t\\t\\trenderingShadows = false;\\n\\t\\t\\tresetGlobalState();\\n\\n\\t\\t};\\n\\n\\t\\tthis.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {\\n\\n\\t\\t\\tif ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {\\n\\n\\t\\t\\t\\t// there's no local clipping\\n\\n\\t\\t\\t\\tif ( renderingShadows ) {\\n\\n\\t\\t\\t\\t\\t// there's no global clipping\\n\\n\\t\\t\\t\\t\\tprojectPlanes( null );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tresetGlobalState();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\\n\\t\\t\\t\\t\\tlGlobal = nGlobal * 4,\\n\\n\\t\\t\\t\\t\\tdstArray = cache.clippingState || null;\\n\\n\\t\\t\\t\\tuniform.value = dstArray; // ensure unique state\\n\\n\\t\\t\\t\\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\\n\\n\\t\\t\\t\\tfor ( var i = 0; i !== lGlobal; ++ i ) {\\n\\n\\t\\t\\t\\t\\tdstArray[ i ] = globalState[ i ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcache.clippingState = dstArray;\\n\\t\\t\\t\\tthis.numIntersection = clipIntersection ? this.numPlanes : 0;\\n\\t\\t\\t\\tthis.numPlanes += nGlobal;\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t};\\n\\n\\t\\tfunction resetGlobalState() {\\n\\n\\t\\t\\tif ( uniform.value !== globalState ) {\\n\\n\\t\\t\\t\\tuniform.value = globalState;\\n\\t\\t\\t\\tuniform.needsUpdate = numGlobalPlanes > 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscope.numPlanes = numGlobalPlanes;\\n\\t\\t\\tscope.numIntersection = 0;\\n\\n\\t\\t}\\n\\n\\t\\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\\n\\n\\t\\t\\tvar nPlanes = planes !== null ? planes.length : 0,\\n\\t\\t\\t\\tdstArray = null;\\n\\n\\t\\t\\tif ( nPlanes !== 0 ) {\\n\\n\\t\\t\\t\\tdstArray = uniform.value;\\n\\n\\t\\t\\t\\tif ( skipTransform !== true || dstArray === null ) {\\n\\n\\t\\t\\t\\t\\tvar flatSize = dstOffset + nPlanes * 4,\\n\\t\\t\\t\\t\\t\\tviewMatrix = camera.matrixWorldInverse;\\n\\n\\t\\t\\t\\t\\tviewNormalMatrix.getNormalMatrix( viewMatrix );\\n\\n\\t\\t\\t\\t\\tif ( dstArray === null || dstArray.length < flatSize ) {\\n\\n\\t\\t\\t\\t\\t\\tdstArray = new Float32Array( flatSize );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {\\n\\n\\t\\t\\t\\t\\t\\tplane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );\\n\\n\\t\\t\\t\\t\\t\\tplane.normal.toArray( dstArray, i4 );\\n\\t\\t\\t\\t\\t\\tdstArray[ i4 + 3 ] = plane.constant;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tuniform.value = dstArray;\\n\\t\\t\\t\\tuniform.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscope.numPlanes = nPlanes;\\n\\n\\t\\t\\treturn dstArray;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author thespite / http://www.twitter.com/thespite\\n\\t */\\n\\n\\tfunction WebGLUtils( gl, extensions ) {\\n\\n\\t\\tfunction convert( p ) {\\n\\n\\t\\t\\tvar extension;\\n\\n\\t\\t\\tif ( p === RepeatWrapping ) return gl.REPEAT;\\n\\t\\t\\tif ( p === ClampToEdgeWrapping ) return gl.CLAMP_TO_EDGE;\\n\\t\\t\\tif ( p === MirroredRepeatWrapping ) return gl.MIRRORED_REPEAT;\\n\\n\\t\\t\\tif ( p === NearestFilter ) return gl.NEAREST;\\n\\t\\t\\tif ( p === NearestMipMapNearestFilter ) return gl.NEAREST_MIPMAP_NEAREST;\\n\\t\\t\\tif ( p === NearestMipMapLinearFilter ) return gl.NEAREST_MIPMAP_LINEAR;\\n\\n\\t\\t\\tif ( p === LinearFilter ) return gl.LINEAR;\\n\\t\\t\\tif ( p === LinearMipMapNearestFilter ) return gl.LINEAR_MIPMAP_NEAREST;\\n\\t\\t\\tif ( p === LinearMipMapLinearFilter ) return gl.LINEAR_MIPMAP_LINEAR;\\n\\n\\t\\t\\tif ( p === UnsignedByteType ) return gl.UNSIGNED_BYTE;\\n\\t\\t\\tif ( p === UnsignedShort4444Type ) return gl.UNSIGNED_SHORT_4_4_4_4;\\n\\t\\t\\tif ( p === UnsignedShort5551Type ) return gl.UNSIGNED_SHORT_5_5_5_1;\\n\\t\\t\\tif ( p === UnsignedShort565Type ) return gl.UNSIGNED_SHORT_5_6_5;\\n\\n\\t\\t\\tif ( p === ByteType ) return gl.BYTE;\\n\\t\\t\\tif ( p === ShortType ) return gl.SHORT;\\n\\t\\t\\tif ( p === UnsignedShortType ) return gl.UNSIGNED_SHORT;\\n\\t\\t\\tif ( p === IntType ) return gl.INT;\\n\\t\\t\\tif ( p === UnsignedIntType ) return gl.UNSIGNED_INT;\\n\\t\\t\\tif ( p === FloatType ) return gl.FLOAT;\\n\\n\\t\\t\\tif ( p === HalfFloatType ) {\\n\\n\\t\\t\\t\\textension = extensions.get( 'OES_texture_half_float' );\\n\\n\\t\\t\\t\\tif ( extension !== null ) return extension.HALF_FLOAT_OES;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( p === AlphaFormat ) return gl.ALPHA;\\n\\t\\t\\tif ( p === RGBFormat ) return gl.RGB;\\n\\t\\t\\tif ( p === RGBAFormat ) return gl.RGBA;\\n\\t\\t\\tif ( p === LuminanceFormat ) return gl.LUMINANCE;\\n\\t\\t\\tif ( p === LuminanceAlphaFormat ) return gl.LUMINANCE_ALPHA;\\n\\t\\t\\tif ( p === DepthFormat ) return gl.DEPTH_COMPONENT;\\n\\t\\t\\tif ( p === DepthStencilFormat ) return gl.DEPTH_STENCIL;\\n\\n\\t\\t\\tif ( p === AddEquation ) return gl.FUNC_ADD;\\n\\t\\t\\tif ( p === SubtractEquation ) return gl.FUNC_SUBTRACT;\\n\\t\\t\\tif ( p === ReverseSubtractEquation ) return gl.FUNC_REVERSE_SUBTRACT;\\n\\n\\t\\t\\tif ( p === ZeroFactor ) return gl.ZERO;\\n\\t\\t\\tif ( p === OneFactor ) return gl.ONE;\\n\\t\\t\\tif ( p === SrcColorFactor ) return gl.SRC_COLOR;\\n\\t\\t\\tif ( p === OneMinusSrcColorFactor ) return gl.ONE_MINUS_SRC_COLOR;\\n\\t\\t\\tif ( p === SrcAlphaFactor ) return gl.SRC_ALPHA;\\n\\t\\t\\tif ( p === OneMinusSrcAlphaFactor ) return gl.ONE_MINUS_SRC_ALPHA;\\n\\t\\t\\tif ( p === DstAlphaFactor ) return gl.DST_ALPHA;\\n\\t\\t\\tif ( p === OneMinusDstAlphaFactor ) return gl.ONE_MINUS_DST_ALPHA;\\n\\n\\t\\t\\tif ( p === DstColorFactor ) return gl.DST_COLOR;\\n\\t\\t\\tif ( p === OneMinusDstColorFactor ) return gl.ONE_MINUS_DST_COLOR;\\n\\t\\t\\tif ( p === SrcAlphaSaturateFactor ) return gl.SRC_ALPHA_SATURATE;\\n\\n\\t\\t\\tif ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||\\n\\t\\t\\t\\tp === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {\\n\\n\\t\\t\\t\\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\\n\\n\\t\\t\\t\\tif ( extension !== null ) {\\n\\n\\t\\t\\t\\t\\tif ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\\n\\t\\t\\t\\t\\tif ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\\n\\t\\t\\t\\t\\tif ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\\n\\t\\t\\t\\t\\tif ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||\\n\\t\\t\\t\\tp === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {\\n\\n\\t\\t\\t\\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\\n\\n\\t\\t\\t\\tif ( extension !== null ) {\\n\\n\\t\\t\\t\\t\\tif ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\\n\\t\\t\\t\\t\\tif ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\\n\\t\\t\\t\\t\\tif ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\\n\\t\\t\\t\\t\\tif ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( p === RGB_ETC1_Format ) {\\n\\n\\t\\t\\t\\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\\n\\n\\t\\t\\t\\tif ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( p === MinEquation || p === MaxEquation ) {\\n\\n\\t\\t\\t\\textension = extensions.get( 'EXT_blend_minmax' );\\n\\n\\t\\t\\t\\tif ( extension !== null ) {\\n\\n\\t\\t\\t\\t\\tif ( p === MinEquation ) return extension.MIN_EXT;\\n\\t\\t\\t\\t\\tif ( p === MaxEquation ) return extension.MAX_EXT;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( p === UnsignedInt248Type ) {\\n\\n\\t\\t\\t\\textension = extensions.get( 'WEBGL_depth_texture' );\\n\\n\\t\\t\\t\\tif ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn 0;\\n\\n\\t\\t}\\n\\n\\t\\treturn { convert: convert };\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author supereggbert / http://www.paulbrunt.co.uk/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author szimek / https://github.com/szimek/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction WebGLRenderer( parameters ) {\\n\\n\\t\\tconsole.log( 'THREE.WebGLRenderer', REVISION );\\n\\n\\t\\tparameters = parameters || {};\\n\\n\\t\\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),\\n\\t\\t\\t_context = parameters.context !== undefined ? parameters.context : null,\\n\\n\\t\\t\\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\\n\\t\\t\\t_depth = parameters.depth !== undefined ? parameters.depth : true,\\n\\t\\t\\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\\n\\t\\t\\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\\n\\t\\t\\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\\n\\t\\t\\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,\\n\\t\\t\\t_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';\\n\\n\\t\\tvar lightsArray = [];\\n\\t\\tvar shadowsArray = [];\\n\\n\\t\\tvar currentRenderList = null;\\n\\n\\t\\tvar spritesArray = [];\\n\\t\\tvar flaresArray = [];\\n\\n\\t\\t// public properties\\n\\n\\t\\tthis.domElement = _canvas;\\n\\t\\tthis.context = null;\\n\\n\\t\\t// clearing\\n\\n\\t\\tthis.autoClear = true;\\n\\t\\tthis.autoClearColor = true;\\n\\t\\tthis.autoClearDepth = true;\\n\\t\\tthis.autoClearStencil = true;\\n\\n\\t\\t// scene graph\\n\\n\\t\\tthis.sortObjects = true;\\n\\n\\t\\t// user-defined clipping\\n\\n\\t\\tthis.clippingPlanes = [];\\n\\t\\tthis.localClippingEnabled = false;\\n\\n\\t\\t// physically based shading\\n\\n\\t\\tthis.gammaFactor = 2.0;\\t// for backwards compatibility\\n\\t\\tthis.gammaInput = false;\\n\\t\\tthis.gammaOutput = false;\\n\\n\\t\\t// physical lights\\n\\n\\t\\tthis.physicallyCorrectLights = false;\\n\\n\\t\\t// tone mapping\\n\\n\\t\\tthis.toneMapping = LinearToneMapping;\\n\\t\\tthis.toneMappingExposure = 1.0;\\n\\t\\tthis.toneMappingWhitePoint = 1.0;\\n\\n\\t\\t// morphs\\n\\n\\t\\tthis.maxMorphTargets = 8;\\n\\t\\tthis.maxMorphNormals = 4;\\n\\n\\t\\t// internal properties\\n\\n\\t\\tvar _this = this,\\n\\n\\t\\t\\t_isContextLost = false,\\n\\n\\t\\t\\t// internal state cache\\n\\n\\t\\t\\t_currentRenderTarget = null,\\n\\t\\t\\t_currentFramebuffer = null,\\n\\t\\t\\t_currentMaterialId = - 1,\\n\\t\\t\\t_currentGeometryProgram = '',\\n\\n\\t\\t\\t_currentCamera = null,\\n\\t\\t\\t_currentArrayCamera = null,\\n\\n\\t\\t\\t_currentViewport = new Vector4(),\\n\\t\\t\\t_currentScissor = new Vector4(),\\n\\t\\t\\t_currentScissorTest = null,\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\t_usedTextureUnits = 0,\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\t_width = _canvas.width,\\n\\t\\t\\t_height = _canvas.height,\\n\\n\\t\\t\\t_pixelRatio = 1,\\n\\n\\t\\t\\t_viewport = new Vector4( 0, 0, _width, _height ),\\n\\t\\t\\t_scissor = new Vector4( 0, 0, _width, _height ),\\n\\t\\t\\t_scissorTest = false,\\n\\n\\t\\t\\t// frustum\\n\\n\\t\\t\\t_frustum = new Frustum(),\\n\\n\\t\\t\\t// clipping\\n\\n\\t\\t\\t_clipping = new WebGLClipping(),\\n\\t\\t\\t_clippingEnabled = false,\\n\\t\\t\\t_localClippingEnabled = false,\\n\\n\\t\\t\\t// camera matrices cache\\n\\n\\t\\t\\t_projScreenMatrix = new Matrix4(),\\n\\n\\t\\t\\t_vector3 = new Vector3(),\\n\\n\\t\\t\\t// info\\n\\n\\t\\t\\t_infoMemory = {\\n\\t\\t\\t\\tgeometries: 0,\\n\\t\\t\\t\\ttextures: 0\\n\\t\\t\\t},\\n\\n\\t\\t\\t_infoRender = {\\n\\n\\t\\t\\t\\tframe: 0,\\n\\t\\t\\t\\tcalls: 0,\\n\\t\\t\\t\\tvertices: 0,\\n\\t\\t\\t\\tfaces: 0,\\n\\t\\t\\t\\tpoints: 0\\n\\n\\t\\t\\t};\\n\\n\\t\\tthis.info = {\\n\\n\\t\\t\\trender: _infoRender,\\n\\t\\t\\tmemory: _infoMemory,\\n\\t\\t\\tprograms: null\\n\\n\\t\\t};\\n\\n\\t\\tfunction getTargetPixelRatio() {\\n\\n\\t\\t\\treturn _currentRenderTarget === null ? _pixelRatio : 1;\\n\\n\\t\\t}\\n\\n\\t\\t// initialize\\n\\n\\t\\tvar _gl;\\n\\n\\t\\ttry {\\n\\n\\t\\t\\tvar contextAttributes = {\\n\\t\\t\\t\\talpha: _alpha,\\n\\t\\t\\t\\tdepth: _depth,\\n\\t\\t\\t\\tstencil: _stencil,\\n\\t\\t\\t\\tantialias: _antialias,\\n\\t\\t\\t\\tpremultipliedAlpha: _premultipliedAlpha,\\n\\t\\t\\t\\tpreserveDrawingBuffer: _preserveDrawingBuffer,\\n\\t\\t\\t\\tpowerPreference: _powerPreference\\n\\t\\t\\t};\\n\\n\\t\\t\\t// event listeners must be registered before WebGL context is created, see #12753\\n\\n\\t\\t\\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\\n\\t\\t\\t_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );\\n\\n\\t\\t\\t_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );\\n\\n\\t\\t\\tif ( _gl === null ) {\\n\\n\\t\\t\\t\\tif ( _canvas.getContext( 'webgl' ) !== null ) {\\n\\n\\t\\t\\t\\t\\tthrow new Error( 'Error creating WebGL context with your selected attributes.' );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tthrow new Error( 'Error creating WebGL context.' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\\n\\n\\t\\t\\tif ( _gl.getShaderPrecisionFormat === undefined ) {\\n\\n\\t\\t\\t\\t_gl.getShaderPrecisionFormat = function () {\\n\\n\\t\\t\\t\\t\\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\\n\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t}\\n\\n\\t\\t} catch ( error ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.WebGLRenderer: ' + error.message );\\n\\n\\t\\t}\\n\\n\\t\\tvar extensions, capabilities, state;\\n\\t\\tvar properties, textures, attributes, geometries, objects, lights;\\n\\t\\tvar programCache, renderLists;\\n\\n\\t\\tvar background, morphtargets, bufferRenderer, indexedBufferRenderer;\\n\\t\\tvar flareRenderer, spriteRenderer;\\n\\n\\t\\tvar utils;\\n\\n\\t\\tfunction initGLContext() {\\n\\n\\t\\t\\textensions = new WebGLExtensions( _gl );\\n\\t\\t\\textensions.get( 'WEBGL_depth_texture' );\\n\\t\\t\\textensions.get( 'OES_texture_float' );\\n\\t\\t\\textensions.get( 'OES_texture_float_linear' );\\n\\t\\t\\textensions.get( 'OES_texture_half_float' );\\n\\t\\t\\textensions.get( 'OES_texture_half_float_linear' );\\n\\t\\t\\textensions.get( 'OES_standard_derivatives' );\\n\\t\\t\\textensions.get( 'OES_element_index_uint' );\\n\\t\\t\\textensions.get( 'ANGLE_instanced_arrays' );\\n\\n\\t\\t\\tutils = new WebGLUtils( _gl, extensions );\\n\\n\\t\\t\\tcapabilities = new WebGLCapabilities( _gl, extensions, parameters );\\n\\n\\t\\t\\tstate = new WebGLState( _gl, extensions, utils );\\n\\t\\t\\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\\n\\t\\t\\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\\n\\n\\t\\t\\tproperties = new WebGLProperties();\\n\\t\\t\\ttextures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, _infoMemory );\\n\\t\\t\\tattributes = new WebGLAttributes( _gl );\\n\\t\\t\\tgeometries = new WebGLGeometries( _gl, attributes, _infoMemory );\\n\\t\\t\\tobjects = new WebGLObjects( geometries, _infoRender );\\n\\t\\t\\tmorphtargets = new WebGLMorphtargets( _gl );\\n\\t\\t\\tprogramCache = new WebGLPrograms( _this, extensions, capabilities );\\n\\t\\t\\tlights = new WebGLLights();\\n\\t\\t\\trenderLists = new WebGLRenderLists();\\n\\n\\t\\t\\tbackground = new WebGLBackground( _this, state, geometries, _premultipliedAlpha );\\n\\n\\t\\t\\tbufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );\\n\\t\\t\\tindexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\\n\\n\\t\\t\\tflareRenderer = new WebGLFlareRenderer( _this, _gl, state, textures, capabilities );\\n\\t\\t\\tspriteRenderer = new WebGLSpriteRenderer( _this, _gl, state, textures, capabilities );\\n\\n\\t\\t\\t_this.info.programs = programCache.programs;\\n\\n\\t\\t\\t_this.context = _gl;\\n\\t\\t\\t_this.capabilities = capabilities;\\n\\t\\t\\t_this.extensions = extensions;\\n\\t\\t\\t_this.properties = properties;\\n\\t\\t\\t_this.renderLists = renderLists;\\n\\t\\t\\t_this.state = state;\\n\\n\\t\\t}\\n\\n\\t\\tinitGLContext();\\n\\n\\t\\t// vr\\n\\n\\t\\tvar vr = new WebVRManager( _this );\\n\\n\\t\\tthis.vr = vr;\\n\\n\\t\\t// shadow map\\n\\n\\t\\tvar shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );\\n\\n\\t\\tthis.shadowMap = shadowMap;\\n\\n\\t\\t// API\\n\\n\\t\\tthis.getContext = function () {\\n\\n\\t\\t\\treturn _gl;\\n\\n\\t\\t};\\n\\n\\t\\tthis.getContextAttributes = function () {\\n\\n\\t\\t\\treturn _gl.getContextAttributes();\\n\\n\\t\\t};\\n\\n\\t\\tthis.forceContextLoss = function () {\\n\\n\\t\\t\\tvar extension = extensions.get( 'WEBGL_lose_context' );\\n\\t\\t\\tif ( extension ) extension.loseContext();\\n\\n\\t\\t};\\n\\n\\t\\tthis.forceContextRestore = function () {\\n\\n\\t\\t\\tvar extension = extensions.get( 'WEBGL_lose_context' );\\n\\t\\t\\tif ( extension ) extension.restoreContext();\\n\\n\\t\\t};\\n\\n\\t\\tthis.getPixelRatio = function () {\\n\\n\\t\\t\\treturn _pixelRatio;\\n\\n\\t\\t};\\n\\n\\t\\tthis.setPixelRatio = function ( value ) {\\n\\n\\t\\t\\tif ( value === undefined ) return;\\n\\n\\t\\t\\t_pixelRatio = value;\\n\\n\\t\\t\\tthis.setSize( _width, _height, false );\\n\\n\\t\\t};\\n\\n\\t\\tthis.getSize = function () {\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\twidth: _width,\\n\\t\\t\\t\\theight: _height\\n\\t\\t\\t};\\n\\n\\t\\t};\\n\\n\\t\\tthis.setSize = function ( width, height, updateStyle ) {\\n\\n\\t\\t\\tvar device = vr.getDevice();\\n\\n\\t\\t\\tif ( device && device.isPresenting ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Can\\\\'t change size while VR device is presenting.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t_width = width;\\n\\t\\t\\t_height = height;\\n\\n\\t\\t\\t_canvas.width = width * _pixelRatio;\\n\\t\\t\\t_canvas.height = height * _pixelRatio;\\n\\n\\t\\t\\tif ( updateStyle !== false ) {\\n\\n\\t\\t\\t\\t_canvas.style.width = width + 'px';\\n\\t\\t\\t\\t_canvas.style.height = height + 'px';\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.setViewport( 0, 0, width, height );\\n\\n\\t\\t};\\n\\n\\t\\tthis.getDrawingBufferSize = function () {\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\twidth: _width * _pixelRatio,\\n\\t\\t\\t\\theight: _height * _pixelRatio\\n\\t\\t\\t};\\n\\n\\t\\t};\\n\\n\\t\\tthis.setDrawingBufferSize = function ( width, height, pixelRatio ) {\\n\\n\\t\\t\\t_width = width;\\n\\t\\t\\t_height = height;\\n\\n\\t\\t\\t_pixelRatio = pixelRatio;\\n\\n\\t\\t\\t_canvas.width = width * pixelRatio;\\n\\t\\t\\t_canvas.height = height * pixelRatio;\\n\\n\\t\\t\\tthis.setViewport( 0, 0, width, height );\\n\\n\\t\\t};\\n\\n\\t\\tthis.setViewport = function ( x, y, width, height ) {\\n\\n\\t\\t\\t_viewport.set( x, _height - y - height, width, height );\\n\\t\\t\\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\\n\\n\\t\\t};\\n\\n\\t\\tthis.setScissor = function ( x, y, width, height ) {\\n\\n\\t\\t\\t_scissor.set( x, _height - y - height, width, height );\\n\\t\\t\\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\\n\\n\\t\\t};\\n\\n\\t\\tthis.setScissorTest = function ( boolean ) {\\n\\n\\t\\t\\tstate.setScissorTest( _scissorTest = boolean );\\n\\n\\t\\t};\\n\\n\\t\\t// Clearing\\n\\n\\t\\tthis.getClearColor = function () {\\n\\n\\t\\t\\treturn background.getClearColor();\\n\\n\\t\\t};\\n\\n\\t\\tthis.setClearColor = function () {\\n\\n\\t\\t\\tbackground.setClearColor.apply( background, arguments );\\n\\n\\t\\t};\\n\\n\\t\\tthis.getClearAlpha = function () {\\n\\n\\t\\t\\treturn background.getClearAlpha();\\n\\n\\t\\t};\\n\\n\\t\\tthis.setClearAlpha = function () {\\n\\n\\t\\t\\tbackground.setClearAlpha.apply( background, arguments );\\n\\n\\t\\t};\\n\\n\\t\\tthis.clear = function ( color, depth, stencil ) {\\n\\n\\t\\t\\tvar bits = 0;\\n\\n\\t\\t\\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\\n\\t\\t\\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\\n\\t\\t\\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\\n\\n\\t\\t\\t_gl.clear( bits );\\n\\n\\t\\t};\\n\\n\\t\\tthis.clearColor = function () {\\n\\n\\t\\t\\tthis.clear( true, false, false );\\n\\n\\t\\t};\\n\\n\\t\\tthis.clearDepth = function () {\\n\\n\\t\\t\\tthis.clear( false, true, false );\\n\\n\\t\\t};\\n\\n\\t\\tthis.clearStencil = function () {\\n\\n\\t\\t\\tthis.clear( false, false, true );\\n\\n\\t\\t};\\n\\n\\t\\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\\n\\n\\t\\t\\tthis.setRenderTarget( renderTarget );\\n\\t\\t\\tthis.clear( color, depth, stencil );\\n\\n\\t\\t};\\n\\n\\t\\t//\\n\\n\\t\\tthis.dispose = function () {\\n\\n\\t\\t\\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\\n\\t\\t\\t_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );\\n\\n\\t\\t\\trenderLists.dispose();\\n\\n\\t\\t\\tvr.dispose();\\n\\n\\t\\t};\\n\\n\\t\\t// Events\\n\\n\\t\\tfunction onContextLost( event ) {\\n\\n\\t\\t\\tevent.preventDefault();\\n\\n\\t\\t\\tconsole.log( 'THREE.WebGLRenderer: Context Lost.' );\\n\\n\\t\\t\\t_isContextLost = true;\\n\\n\\t\\t}\\n\\n\\t\\tfunction onContextRestore( /* event */ ) {\\n\\n\\t\\t\\tconsole.log( 'THREE.WebGLRenderer: Context Restored.' );\\n\\n\\t\\t\\t_isContextLost = false;\\n\\n\\t\\t\\tinitGLContext();\\n\\n\\t\\t}\\n\\n\\t\\tfunction onMaterialDispose( event ) {\\n\\n\\t\\t\\tvar material = event.target;\\n\\n\\t\\t\\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\\n\\n\\t\\t\\tdeallocateMaterial( material );\\n\\n\\t\\t}\\n\\n\\t\\t// Buffer deallocation\\n\\n\\t\\tfunction deallocateMaterial( material ) {\\n\\n\\t\\t\\treleaseMaterialProgramReference( material );\\n\\n\\t\\t\\tproperties.remove( material );\\n\\n\\t\\t}\\n\\n\\n\\t\\tfunction releaseMaterialProgramReference( material ) {\\n\\n\\t\\t\\tvar programInfo = properties.get( material ).program;\\n\\n\\t\\t\\tmaterial.program = undefined;\\n\\n\\t\\t\\tif ( programInfo !== undefined ) {\\n\\n\\t\\t\\t\\tprogramCache.releaseProgram( programInfo );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// Buffer rendering\\n\\n\\t\\tfunction renderObjectImmediate( object, program, material ) {\\n\\n\\t\\t\\tobject.render( function ( object ) {\\n\\n\\t\\t\\t\\t_this.renderBufferImmediate( object, program, material );\\n\\n\\t\\t\\t} );\\n\\n\\t\\t}\\n\\n\\t\\tthis.renderBufferImmediate = function ( object, program, material ) {\\n\\n\\t\\t\\tstate.initAttributes();\\n\\n\\t\\t\\tvar buffers = properties.get( object );\\n\\n\\t\\t\\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\\n\\t\\t\\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\\n\\t\\t\\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\\n\\t\\t\\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\\n\\n\\t\\t\\tvar programAttributes = program.getAttributes();\\n\\n\\t\\t\\tif ( object.hasPositions ) {\\n\\n\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\\n\\t\\t\\t\\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\\n\\n\\t\\t\\t\\tstate.enableAttribute( programAttributes.position );\\n\\t\\t\\t\\t_gl.vertexAttribPointer( programAttributes.position, 3, _gl.FLOAT, false, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( object.hasNormals ) {\\n\\n\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\\n\\n\\t\\t\\t\\tif ( ! material.isMeshPhongMaterial &&\\n\\t\\t\\t\\t\\t! material.isMeshStandardMaterial &&\\n\\t\\t\\t\\t\\t! material.isMeshNormalMaterial &&\\n\\t\\t\\t\\t\\tmaterial.flatShading === true ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\\n\\n\\t\\t\\t\\t\\t\\tvar array = object.normalArray;\\n\\n\\t\\t\\t\\t\\t\\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\\n\\t\\t\\t\\t\\t\\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\\n\\t\\t\\t\\t\\t\\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\\n\\n\\t\\t\\t\\t\\t\\tarray[ i + 0 ] = nx;\\n\\t\\t\\t\\t\\t\\tarray[ i + 1 ] = ny;\\n\\t\\t\\t\\t\\t\\tarray[ i + 2 ] = nz;\\n\\n\\t\\t\\t\\t\\t\\tarray[ i + 3 ] = nx;\\n\\t\\t\\t\\t\\t\\tarray[ i + 4 ] = ny;\\n\\t\\t\\t\\t\\t\\tarray[ i + 5 ] = nz;\\n\\n\\t\\t\\t\\t\\t\\tarray[ i + 6 ] = nx;\\n\\t\\t\\t\\t\\t\\tarray[ i + 7 ] = ny;\\n\\t\\t\\t\\t\\t\\tarray[ i + 8 ] = nz;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\\n\\n\\t\\t\\t\\tstate.enableAttribute( programAttributes.normal );\\n\\n\\t\\t\\t\\t_gl.vertexAttribPointer( programAttributes.normal, 3, _gl.FLOAT, false, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( object.hasUvs && material.map ) {\\n\\n\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\\n\\t\\t\\t\\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\\n\\n\\t\\t\\t\\tstate.enableAttribute( programAttributes.uv );\\n\\n\\t\\t\\t\\t_gl.vertexAttribPointer( programAttributes.uv, 2, _gl.FLOAT, false, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( object.hasColors && material.vertexColors !== NoColors ) {\\n\\n\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\\n\\t\\t\\t\\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\\n\\n\\t\\t\\t\\tstate.enableAttribute( programAttributes.color );\\n\\n\\t\\t\\t\\t_gl.vertexAttribPointer( programAttributes.color, 3, _gl.FLOAT, false, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.disableUnusedAttributes();\\n\\n\\t\\t\\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\\n\\n\\t\\t\\tobject.count = 0;\\n\\n\\t\\t};\\n\\n\\t\\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\\n\\n\\t\\t\\tvar frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\\n\\n\\t\\t\\tstate.setMaterial( material, frontFaceCW );\\n\\n\\t\\t\\tvar program = setProgram( camera, fog, material, object );\\n\\t\\t\\tvar geometryProgram = geometry.id + '_' + program.id + '_' + ( material.wireframe === true );\\n\\n\\t\\t\\tvar updateBuffers = false;\\n\\n\\t\\t\\tif ( geometryProgram !== _currentGeometryProgram ) {\\n\\n\\t\\t\\t\\t_currentGeometryProgram = geometryProgram;\\n\\t\\t\\t\\tupdateBuffers = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( object.morphTargetInfluences ) {\\n\\n\\t\\t\\t\\tmorphtargets.update( object, geometry, material, program );\\n\\n\\t\\t\\t\\tupdateBuffers = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar index = geometry.index;\\n\\t\\t\\tvar position = geometry.attributes.position;\\n\\t\\t\\tvar rangeFactor = 1;\\n\\n\\t\\t\\tif ( material.wireframe === true ) {\\n\\n\\t\\t\\t\\tindex = geometries.getWireframeAttribute( geometry );\\n\\t\\t\\t\\trangeFactor = 2;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar attribute;\\n\\t\\t\\tvar renderer = bufferRenderer;\\n\\n\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\tattribute = attributes.get( index );\\n\\n\\t\\t\\t\\trenderer = indexedBufferRenderer;\\n\\t\\t\\t\\trenderer.setIndex( attribute );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( updateBuffers ) {\\n\\n\\t\\t\\t\\tsetupVertexAttributes( material, program, geometry );\\n\\n\\t\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\t\\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attribute.buffer );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar dataCount = 0;\\n\\n\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\tdataCount = index.count;\\n\\n\\t\\t\\t} else if ( position !== undefined ) {\\n\\n\\t\\t\\t\\tdataCount = position.count;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar rangeStart = geometry.drawRange.start * rangeFactor;\\n\\t\\t\\tvar rangeCount = geometry.drawRange.count * rangeFactor;\\n\\n\\t\\t\\tvar groupStart = group !== null ? group.start * rangeFactor : 0;\\n\\t\\t\\tvar groupCount = group !== null ? group.count * rangeFactor : Infinity;\\n\\n\\t\\t\\tvar drawStart = Math.max( rangeStart, groupStart );\\n\\t\\t\\tvar drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\\n\\n\\t\\t\\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\\n\\n\\t\\t\\tif ( drawCount === 0 ) return;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tif ( object.isMesh ) {\\n\\n\\t\\t\\t\\tif ( material.wireframe === true ) {\\n\\n\\t\\t\\t\\t\\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\\n\\t\\t\\t\\t\\trenderer.setMode( _gl.LINES );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tswitch ( object.drawMode ) {\\n\\n\\t\\t\\t\\t\\t\\tcase TrianglesDrawMode:\\n\\t\\t\\t\\t\\t\\t\\trenderer.setMode( _gl.TRIANGLES );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase TriangleStripDrawMode:\\n\\t\\t\\t\\t\\t\\t\\trenderer.setMode( _gl.TRIANGLE_STRIP );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase TriangleFanDrawMode:\\n\\t\\t\\t\\t\\t\\t\\trenderer.setMode( _gl.TRIANGLE_FAN );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t} else if ( object.isLine ) {\\n\\n\\t\\t\\t\\tvar lineWidth = material.linewidth;\\n\\n\\t\\t\\t\\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\\n\\n\\t\\t\\t\\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\\n\\n\\t\\t\\t\\tif ( object.isLineSegments ) {\\n\\n\\t\\t\\t\\t\\trenderer.setMode( _gl.LINES );\\n\\n\\t\\t\\t\\t} else if ( object.isLineLoop ) {\\n\\n\\t\\t\\t\\t\\trenderer.setMode( _gl.LINE_LOOP );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\trenderer.setMode( _gl.LINE_STRIP );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( object.isPoints ) {\\n\\n\\t\\t\\t\\trenderer.setMode( _gl.POINTS );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( geometry && geometry.isInstancedBufferGeometry ) {\\n\\n\\t\\t\\t\\tif ( geometry.maxInstancedCount > 0 ) {\\n\\n\\t\\t\\t\\t\\trenderer.renderInstances( geometry, drawStart, drawCount );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\trenderer.render( drawStart, drawCount );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\\n\\n\\t\\t\\tif ( geometry && geometry.isInstancedBufferGeometry ) {\\n\\n\\t\\t\\t\\tif ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\\n\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( startIndex === undefined ) startIndex = 0;\\n\\n\\t\\t\\tstate.initAttributes();\\n\\n\\t\\t\\tvar geometryAttributes = geometry.attributes;\\n\\n\\t\\t\\tvar programAttributes = program.getAttributes();\\n\\n\\t\\t\\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\\n\\n\\t\\t\\tfor ( var name in programAttributes ) {\\n\\n\\t\\t\\t\\tvar programAttribute = programAttributes[ name ];\\n\\n\\t\\t\\t\\tif ( programAttribute >= 0 ) {\\n\\n\\t\\t\\t\\t\\tvar geometryAttribute = geometryAttributes[ name ];\\n\\n\\t\\t\\t\\t\\tif ( geometryAttribute !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tvar normalized = geometryAttribute.normalized;\\n\\t\\t\\t\\t\\t\\tvar size = geometryAttribute.itemSize;\\n\\n\\t\\t\\t\\t\\t\\tvar attribute = attributes.get( geometryAttribute );\\n\\n\\t\\t\\t\\t\\t\\t// TODO Attribute may not be available on context restore\\n\\n\\t\\t\\t\\t\\t\\tif ( attribute === undefined ) continue;\\n\\n\\t\\t\\t\\t\\t\\tvar buffer = attribute.buffer;\\n\\t\\t\\t\\t\\t\\tvar type = attribute.type;\\n\\t\\t\\t\\t\\t\\tvar bytesPerElement = attribute.bytesPerElement;\\n\\n\\t\\t\\t\\t\\t\\tif ( geometryAttribute.isInterleavedBufferAttribute ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar data = geometryAttribute.data;\\n\\t\\t\\t\\t\\t\\t\\tvar stride = data.stride;\\n\\t\\t\\t\\t\\t\\t\\tvar offset = geometryAttribute.offset;\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( data && data.isInstancedInterleavedBuffer ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( geometry.maxInstancedCount === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.enableAttribute( programAttribute );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\\n\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( geometryAttribute.isInstancedBufferAttribute ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( geometry.maxInstancedCount === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tstate.enableAttribute( programAttribute );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\\n\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else if ( materialDefaultAttributeValues !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tvar value = materialDefaultAttributeValues[ name ];\\n\\n\\t\\t\\t\\t\\t\\tif ( value !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tswitch ( value.length ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 2:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib2fv( programAttribute, value );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 3:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib3fv( programAttribute, value );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcase 4:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib4fv( programAttribute, value );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t_gl.vertexAttrib1fv( programAttribute, value );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.disableUnusedAttributes();\\n\\n\\t\\t}\\n\\n\\t\\t// Compile\\n\\n\\t\\tthis.compile = function ( scene, camera ) {\\n\\n\\t\\t\\tlightsArray.length = 0;\\n\\t\\t\\tshadowsArray.length = 0;\\n\\n\\t\\t\\tscene.traverse( function ( object ) {\\n\\n\\t\\t\\t\\tif ( object.isLight ) {\\n\\n\\t\\t\\t\\t\\tlightsArray.push( object );\\n\\n\\t\\t\\t\\t\\tif ( object.castShadow ) {\\n\\n\\t\\t\\t\\t\\t\\tshadowsArray.push( object );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} );\\n\\n\\t\\t\\tlights.setup( lightsArray, shadowsArray, camera );\\n\\n\\t\\t\\tscene.traverse( function ( object ) {\\n\\n\\t\\t\\t\\tif ( object.material ) {\\n\\n\\t\\t\\t\\t\\tif ( Array.isArray( object.material ) ) {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < object.material.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tinitMaterial( object.material[ i ], scene.fog, object );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tinitMaterial( object.material, scene.fog, object );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} );\\n\\n\\t\\t};\\n\\n\\t\\t// Animation Loop\\n\\n\\t\\tvar isAnimating = false;\\n\\t\\tvar onAnimationFrame = null;\\n\\n\\t\\tfunction start() {\\n\\n\\t\\t\\tif ( isAnimating ) return;\\n\\n\\t\\t\\tvar device = vr.getDevice();\\n\\n\\t\\t\\tif ( device && device.isPresenting ) {\\n\\n\\t\\t\\t\\tdevice.requestAnimationFrame( loop );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\twindow.requestAnimationFrame( loop );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tisAnimating = true;\\n\\n\\t\\t}\\n\\n\\t\\tfunction loop( time ) {\\n\\n\\t\\t\\tif ( onAnimationFrame !== null ) onAnimationFrame( time );\\n\\n\\t\\t\\tvar device = vr.getDevice();\\n\\n\\t\\t\\tif ( device && device.isPresenting ) {\\n\\n\\t\\t\\t\\tdevice.requestAnimationFrame( loop );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\twindow.requestAnimationFrame( loop );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tthis.animate = function ( callback ) {\\n\\n\\t\\t\\tonAnimationFrame = callback;\\n\\t\\t\\tstart();\\n\\n\\t\\t};\\n\\n\\t\\t// Rendering\\n\\n\\t\\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\\n\\n\\t\\t\\tif ( ! ( camera && camera.isCamera ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( _isContextLost ) return;\\n\\n\\t\\t\\t// reset caching for this frame\\n\\n\\t\\t\\t_currentGeometryProgram = '';\\n\\t\\t\\t_currentMaterialId = - 1;\\n\\t\\t\\t_currentCamera = null;\\n\\n\\t\\t\\t// update scene graph\\n\\n\\t\\t\\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\\n\\n\\t\\t\\t// update camera matrices and frustum\\n\\n\\t\\t\\tif ( camera.parent === null ) camera.updateMatrixWorld();\\n\\n\\t\\t\\tif ( vr.enabled ) {\\n\\n\\t\\t\\t\\tcamera = vr.getCamera( camera );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\\n\\t\\t\\t_frustum.setFromMatrix( _projScreenMatrix );\\n\\n\\t\\t\\tlightsArray.length = 0;\\n\\t\\t\\tshadowsArray.length = 0;\\n\\n\\t\\t\\tspritesArray.length = 0;\\n\\t\\t\\tflaresArray.length = 0;\\n\\n\\t\\t\\t_localClippingEnabled = this.localClippingEnabled;\\n\\t\\t\\t_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );\\n\\n\\t\\t\\tcurrentRenderList = renderLists.get( scene, camera );\\n\\t\\t\\tcurrentRenderList.init();\\n\\n\\t\\t\\tprojectObject( scene, camera, _this.sortObjects );\\n\\n\\t\\t\\tif ( _this.sortObjects === true ) {\\n\\n\\t\\t\\t\\tcurrentRenderList.sort();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\ttextures.updateVideoTextures();\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tif ( _clippingEnabled ) _clipping.beginShadows();\\n\\n\\t\\t\\tshadowMap.render( shadowsArray, scene, camera );\\n\\n\\t\\t\\tlights.setup( lightsArray, shadowsArray, camera );\\n\\n\\t\\t\\tif ( _clippingEnabled ) _clipping.endShadows();\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\t_infoRender.frame ++;\\n\\t\\t\\t_infoRender.calls = 0;\\n\\t\\t\\t_infoRender.vertices = 0;\\n\\t\\t\\t_infoRender.faces = 0;\\n\\t\\t\\t_infoRender.points = 0;\\n\\n\\t\\t\\tif ( renderTarget === undefined ) {\\n\\n\\t\\t\\t\\trenderTarget = null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.setRenderTarget( renderTarget );\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tbackground.render( currentRenderList, scene, camera, forceClear );\\n\\n\\t\\t\\t// render scene\\n\\n\\t\\t\\tvar opaqueObjects = currentRenderList.opaque;\\n\\t\\t\\tvar transparentObjects = currentRenderList.transparent;\\n\\n\\t\\t\\tif ( scene.overrideMaterial ) {\\n\\n\\t\\t\\t\\tvar overrideMaterial = scene.overrideMaterial;\\n\\n\\t\\t\\t\\tif ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );\\n\\t\\t\\t\\tif ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// opaque pass (front-to-back order)\\n\\n\\t\\t\\t\\tif ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );\\n\\n\\t\\t\\t\\t// transparent pass (back-to-front order)\\n\\n\\t\\t\\t\\tif ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// custom renderers\\n\\n\\t\\t\\tspriteRenderer.render( spritesArray, scene, camera );\\n\\t\\t\\tflareRenderer.render( flaresArray, scene, camera, _currentViewport );\\n\\n\\t\\t\\t// Generate mipmap if we're using any kind of mipmap filtering\\n\\n\\t\\t\\tif ( renderTarget ) {\\n\\n\\t\\t\\t\\ttextures.updateRenderTargetMipmap( renderTarget );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Ensure depth buffer writing is enabled so it can be cleared on next render\\n\\n\\t\\t\\tstate.buffers.depth.setTest( true );\\n\\t\\t\\tstate.buffers.depth.setMask( true );\\n\\t\\t\\tstate.buffers.color.setMask( true );\\n\\n\\t\\t\\tstate.setPolygonOffset( false );\\n\\n\\t\\t\\tif ( vr.enabled ) {\\n\\n\\t\\t\\t\\tvr.submitFrame();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// _gl.finish();\\n\\n\\t\\t};\\n\\n\\t\\t/*\\n\\t\\t// TODO Duplicated code (Frustum)\\n\\n\\t\\tvar _sphere = new Sphere();\\n\\n\\t\\tfunction isObjectViewable( object ) {\\n\\n\\t\\t\\tvar geometry = object.geometry;\\n\\n\\t\\t\\tif ( geometry.boundingSphere === null )\\n\\t\\t\\t\\tgeometry.computeBoundingSphere();\\n\\n\\t\\t\\t_sphere.copy( geometry.boundingSphere ).\\n\\t\\t\\tapplyMatrix4( object.matrixWorld );\\n\\n\\t\\t\\treturn isSphereViewable( _sphere );\\n\\n\\t\\t}\\n\\n\\t\\tfunction isSpriteViewable( sprite ) {\\n\\n\\t\\t\\t_sphere.center.set( 0, 0, 0 );\\n\\t\\t\\t_sphere.radius = 0.7071067811865476;\\n\\t\\t\\t_sphere.applyMatrix4( sprite.matrixWorld );\\n\\n\\t\\t\\treturn isSphereViewable( _sphere );\\n\\n\\t\\t}\\n\\n\\t\\tfunction isSphereViewable( sphere ) {\\n\\n\\t\\t\\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\\n\\n\\t\\t\\tvar numPlanes = _clipping.numPlanes;\\n\\n\\t\\t\\tif ( numPlanes === 0 ) return true;\\n\\n\\t\\t\\tvar planes = _this.clippingPlanes,\\n\\n\\t\\t\\t\\tcenter = sphere.center,\\n\\t\\t\\t\\tnegRad = - sphere.radius,\\n\\t\\t\\t\\ti = 0;\\n\\n\\t\\t\\tdo {\\n\\n\\t\\t\\t\\t// out when deeper than radius in the negative halfspace\\n\\t\\t\\t\\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\\n\\n\\t\\t\\t} while ( ++ i !== numPlanes );\\n\\n\\t\\t\\treturn true;\\n\\n\\t\\t}\\n\\t\\t*/\\n\\n\\t\\tfunction projectObject( object, camera, sortObjects ) {\\n\\n\\t\\t\\tif ( object.visible === false ) return;\\n\\n\\t\\t\\tvar visible = object.layers.test( camera.layers );\\n\\n\\t\\t\\tif ( visible ) {\\n\\n\\t\\t\\t\\tif ( object.isLight ) {\\n\\n\\t\\t\\t\\t\\tlightsArray.push( object );\\n\\n\\t\\t\\t\\t\\tif ( object.castShadow ) {\\n\\n\\t\\t\\t\\t\\t\\tshadowsArray.push( object );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( object.isSprite ) {\\n\\n\\t\\t\\t\\t\\tif ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {\\n\\n\\t\\t\\t\\t\\t\\tspritesArray.push( object );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( object.isLensFlare ) {\\n\\n\\t\\t\\t\\t\\tflaresArray.push( object );\\n\\n\\t\\t\\t\\t} else if ( object.isImmediateRenderObject ) {\\n\\n\\t\\t\\t\\t\\tif ( sortObjects ) {\\n\\n\\t\\t\\t\\t\\t\\t_vector3.setFromMatrixPosition( object.matrixWorld )\\n\\t\\t\\t\\t\\t\\t\\t.applyMatrix4( _projScreenMatrix );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tcurrentRenderList.push( object, null, object.material, _vector3.z, null );\\n\\n\\t\\t\\t\\t} else if ( object.isMesh || object.isLine || object.isPoints ) {\\n\\n\\t\\t\\t\\t\\tif ( object.isSkinnedMesh ) {\\n\\n\\t\\t\\t\\t\\t\\tobject.skeleton.update();\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( sortObjects ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t_vector3.setFromMatrixPosition( object.matrixWorld )\\n\\t\\t\\t\\t\\t\\t\\t\\t.applyMatrix4( _projScreenMatrix );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tvar geometry = objects.update( object );\\n\\t\\t\\t\\t\\t\\tvar material = object.material;\\n\\n\\t\\t\\t\\t\\t\\tif ( Array.isArray( material ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar groups = geometry.groups;\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar group = groups[ i ];\\n\\t\\t\\t\\t\\t\\t\\t\\tvar groupMaterial = material[ group.materialIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( groupMaterial && groupMaterial.visible ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcurrentRenderList.push( object, geometry, groupMaterial, _vector3.z, group );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t} else if ( material.visible ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcurrentRenderList.push( object, geometry, material, _vector3.z, null );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar children = object.children;\\n\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tprojectObject( children[ i ], camera, sortObjects );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction renderObjects( renderList, scene, camera, overrideMaterial ) {\\n\\n\\t\\t\\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar renderItem = renderList[ i ];\\n\\n\\t\\t\\t\\tvar object = renderItem.object;\\n\\t\\t\\t\\tvar geometry = renderItem.geometry;\\n\\t\\t\\t\\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\\n\\t\\t\\t\\tvar group = renderItem.group;\\n\\n\\t\\t\\t\\tif ( camera.isArrayCamera ) {\\n\\n\\t\\t\\t\\t\\t_currentArrayCamera = camera;\\n\\n\\t\\t\\t\\t\\tvar cameras = camera.cameras;\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = cameras.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar camera2 = cameras[ j ];\\n\\n\\t\\t\\t\\t\\t\\tif ( object.layers.test( camera2.layers ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar bounds = camera2.bounds;\\n\\n\\t\\t\\t\\t\\t\\t\\tvar x = bounds.x * _width;\\n\\t\\t\\t\\t\\t\\t\\tvar y = bounds.y * _height;\\n\\t\\t\\t\\t\\t\\t\\tvar width = bounds.z * _width;\\n\\t\\t\\t\\t\\t\\t\\tvar height = bounds.w * _height;\\n\\n\\t\\t\\t\\t\\t\\t\\tstate.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );\\n\\n\\t\\t\\t\\t\\t\\t\\trenderObject( object, scene, camera2, geometry, material, group );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t_currentArrayCamera = null;\\n\\n\\t\\t\\t\\t\\trenderObject( object, scene, camera, geometry, material, group );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction renderObject( object, scene, camera, geometry, material, group ) {\\n\\n\\t\\t\\tobject.onBeforeRender( _this, scene, camera, geometry, material, group );\\n\\n\\t\\t\\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\\n\\t\\t\\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\\n\\n\\t\\t\\tif ( object.isImmediateRenderObject ) {\\n\\n\\t\\t\\t\\tvar frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );\\n\\n\\t\\t\\t\\tstate.setMaterial( material, frontFaceCW );\\n\\n\\t\\t\\t\\tvar program = setProgram( camera, scene.fog, material, object );\\n\\n\\t\\t\\t\\t_currentGeometryProgram = '';\\n\\n\\t\\t\\t\\trenderObjectImmediate( object, program, material );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tobject.onAfterRender( _this, scene, camera, geometry, material, group );\\n\\n\\t\\t}\\n\\n\\t\\tfunction initMaterial( material, fog, object ) {\\n\\n\\t\\t\\tvar materialProperties = properties.get( material );\\n\\n\\t\\t\\tvar parameters = programCache.getParameters(\\n\\t\\t\\t\\tmaterial, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );\\n\\n\\t\\t\\tvar code = programCache.getProgramCode( material, parameters );\\n\\n\\t\\t\\tvar program = materialProperties.program;\\n\\t\\t\\tvar programChange = true;\\n\\n\\t\\t\\tif ( program === undefined ) {\\n\\n\\t\\t\\t\\t// new material\\n\\t\\t\\t\\tmaterial.addEventListener( 'dispose', onMaterialDispose );\\n\\n\\t\\t\\t} else if ( program.code !== code ) {\\n\\n\\t\\t\\t\\t// changed glsl or parameters\\n\\t\\t\\t\\treleaseMaterialProgramReference( material );\\n\\n\\t\\t\\t} else if ( parameters.shaderID !== undefined ) {\\n\\n\\t\\t\\t\\t// same glsl and uniform list\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// only rebuild uniform list\\n\\t\\t\\t\\tprogramChange = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( programChange ) {\\n\\n\\t\\t\\t\\tif ( parameters.shaderID ) {\\n\\n\\t\\t\\t\\t\\tvar shader = ShaderLib[ parameters.shaderID ];\\n\\n\\t\\t\\t\\t\\tmaterialProperties.shader = {\\n\\t\\t\\t\\t\\t\\tname: material.type,\\n\\t\\t\\t\\t\\t\\tuniforms: UniformsUtils.clone( shader.uniforms ),\\n\\t\\t\\t\\t\\t\\tvertexShader: shader.vertexShader,\\n\\t\\t\\t\\t\\t\\tfragmentShader: shader.fragmentShader\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tmaterialProperties.shader = {\\n\\t\\t\\t\\t\\t\\tname: material.type,\\n\\t\\t\\t\\t\\t\\tuniforms: material.uniforms,\\n\\t\\t\\t\\t\\t\\tvertexShader: material.vertexShader,\\n\\t\\t\\t\\t\\t\\tfragmentShader: material.fragmentShader\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tmaterial.onBeforeCompile( materialProperties.shader );\\n\\n\\t\\t\\t\\tprogram = programCache.acquireProgram( material, materialProperties.shader, parameters, code );\\n\\n\\t\\t\\t\\tmaterialProperties.program = program;\\n\\t\\t\\t\\tmaterial.program = program;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar programAttributes = program.getAttributes();\\n\\n\\t\\t\\tif ( material.morphTargets ) {\\n\\n\\t\\t\\t\\tmaterial.numSupportedMorphTargets = 0;\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( programAttributes[ 'morphTarget' + i ] >= 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tmaterial.numSupportedMorphTargets ++;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.morphNormals ) {\\n\\n\\t\\t\\t\\tmaterial.numSupportedMorphNormals = 0;\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( programAttributes[ 'morphNormal' + i ] >= 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tmaterial.numSupportedMorphNormals ++;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar uniforms = materialProperties.shader.uniforms;\\n\\n\\t\\t\\tif ( ! material.isShaderMaterial &&\\n\\t\\t\\t\\t! material.isRawShaderMaterial ||\\n\\t\\t\\t\\tmaterial.clipping === true ) {\\n\\n\\t\\t\\t\\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\\n\\t\\t\\t\\tmaterialProperties.numIntersection = _clipping.numIntersection;\\n\\t\\t\\t\\tuniforms.clippingPlanes = _clipping.uniform;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tmaterialProperties.fog = fog;\\n\\n\\t\\t\\t// store the light setup it was created for\\n\\n\\t\\t\\tmaterialProperties.lightsHash = lights.state.hash;\\n\\n\\t\\t\\tif ( material.lights ) {\\n\\n\\t\\t\\t\\t// wire up the material to this renderer's lighting state\\n\\n\\t\\t\\t\\tuniforms.ambientLightColor.value = lights.state.ambient;\\n\\t\\t\\t\\tuniforms.directionalLights.value = lights.state.directional;\\n\\t\\t\\t\\tuniforms.spotLights.value = lights.state.spot;\\n\\t\\t\\t\\tuniforms.rectAreaLights.value = lights.state.rectArea;\\n\\t\\t\\t\\tuniforms.pointLights.value = lights.state.point;\\n\\t\\t\\t\\tuniforms.hemisphereLights.value = lights.state.hemi;\\n\\n\\t\\t\\t\\tuniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\\n\\t\\t\\t\\tuniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\\n\\t\\t\\t\\tuniforms.spotShadowMap.value = lights.state.spotShadowMap;\\n\\t\\t\\t\\tuniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\\n\\t\\t\\t\\tuniforms.pointShadowMap.value = lights.state.pointShadowMap;\\n\\t\\t\\t\\tuniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\\n\\t\\t\\t\\t// TODO (abelnation): add area lights shadow info to uniforms\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar progUniforms = materialProperties.program.getUniforms(),\\n\\t\\t\\t\\tuniformsList =\\n\\t\\t\\t\\t\\tWebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\\n\\n\\t\\t\\tmaterialProperties.uniformsList = uniformsList;\\n\\n\\t\\t}\\n\\n\\t\\tfunction setProgram( camera, fog, material, object ) {\\n\\n\\t\\t\\t_usedTextureUnits = 0;\\n\\n\\t\\t\\tvar materialProperties = properties.get( material );\\n\\n\\t\\t\\tif ( _clippingEnabled ) {\\n\\n\\t\\t\\t\\tif ( _localClippingEnabled || camera !== _currentCamera ) {\\n\\n\\t\\t\\t\\t\\tvar useCache =\\n\\t\\t\\t\\t\\t\\tcamera === _currentCamera &&\\n\\t\\t\\t\\t\\t\\tmaterial.id === _currentMaterialId;\\n\\n\\t\\t\\t\\t\\t// we might want to call this function with some ClippingGroup\\n\\t\\t\\t\\t\\t// object instead of the material, once it becomes feasible\\n\\t\\t\\t\\t\\t// (#8465, #8379)\\n\\t\\t\\t\\t\\t_clipping.setState(\\n\\t\\t\\t\\t\\t\\tmaterial.clippingPlanes, material.clipIntersection, material.clipShadows,\\n\\t\\t\\t\\t\\t\\tcamera, materialProperties, useCache );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.needsUpdate === false ) {\\n\\n\\t\\t\\t\\tif ( materialProperties.program === undefined ) {\\n\\n\\t\\t\\t\\t\\tmaterial.needsUpdate = true;\\n\\n\\t\\t\\t\\t} else if ( material.fog && materialProperties.fog !== fog ) {\\n\\n\\t\\t\\t\\t\\tmaterial.needsUpdate = true;\\n\\n\\t\\t\\t\\t} else if ( material.lights && materialProperties.lightsHash !== lights.state.hash ) {\\n\\n\\t\\t\\t\\t\\tmaterial.needsUpdate = true;\\n\\n\\t\\t\\t\\t} else if ( materialProperties.numClippingPlanes !== undefined &&\\n\\t\\t\\t\\t\\t( materialProperties.numClippingPlanes !== _clipping.numPlanes ||\\n\\t\\t\\t\\t\\tmaterialProperties.numIntersection !== _clipping.numIntersection ) ) {\\n\\n\\t\\t\\t\\t\\tmaterial.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.needsUpdate ) {\\n\\n\\t\\t\\t\\tinitMaterial( material, fog, object );\\n\\t\\t\\t\\tmaterial.needsUpdate = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar refreshProgram = false;\\n\\t\\t\\tvar refreshMaterial = false;\\n\\t\\t\\tvar refreshLights = false;\\n\\n\\t\\t\\tvar program = materialProperties.program,\\n\\t\\t\\t\\tp_uniforms = program.getUniforms(),\\n\\t\\t\\t\\tm_uniforms = materialProperties.shader.uniforms;\\n\\n\\t\\t\\tif ( state.useProgram( program.program ) ) {\\n\\n\\t\\t\\t\\trefreshProgram = true;\\n\\t\\t\\t\\trefreshMaterial = true;\\n\\t\\t\\t\\trefreshLights = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.id !== _currentMaterialId ) {\\n\\n\\t\\t\\t\\t_currentMaterialId = material.id;\\n\\n\\t\\t\\t\\trefreshMaterial = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( refreshProgram || camera !== _currentCamera ) {\\n\\n\\t\\t\\t\\tp_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );\\n\\n\\t\\t\\t\\tif ( capabilities.logarithmicDepthBuffer ) {\\n\\n\\t\\t\\t\\t\\tp_uniforms.setValue( _gl, 'logDepthBufFC',\\n\\t\\t\\t\\t\\t\\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Avoid unneeded uniform updates per ArrayCamera's sub-camera\\n\\n\\t\\t\\t\\tif ( _currentCamera !== ( _currentArrayCamera || camera ) ) {\\n\\n\\t\\t\\t\\t\\t_currentCamera = ( _currentArrayCamera || camera );\\n\\n\\t\\t\\t\\t\\t// lighting uniforms depend on the camera so enforce an update\\n\\t\\t\\t\\t\\t// now, in case this material supports lights - or later, when\\n\\t\\t\\t\\t\\t// the next material that does gets activated:\\n\\n\\t\\t\\t\\t\\trefreshMaterial = true;\\t\\t// set to true on material change\\n\\t\\t\\t\\t\\trefreshLights = true;\\t\\t// remains set until update done\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// load material specific uniforms\\n\\t\\t\\t\\t// (shader material also gets them for the sake of genericity)\\n\\n\\t\\t\\t\\tif ( material.isShaderMaterial ||\\n\\t\\t\\t\\t\\tmaterial.isMeshPhongMaterial ||\\n\\t\\t\\t\\t\\tmaterial.isMeshStandardMaterial ||\\n\\t\\t\\t\\t\\tmaterial.envMap ) {\\n\\n\\t\\t\\t\\t\\tvar uCamPos = p_uniforms.map.cameraPosition;\\n\\n\\t\\t\\t\\t\\tif ( uCamPos !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tuCamPos.setValue( _gl,\\n\\t\\t\\t\\t\\t\\t\\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( material.isMeshPhongMaterial ||\\n\\t\\t\\t\\t\\tmaterial.isMeshLambertMaterial ||\\n\\t\\t\\t\\t\\tmaterial.isMeshBasicMaterial ||\\n\\t\\t\\t\\t\\tmaterial.isMeshStandardMaterial ||\\n\\t\\t\\t\\t\\tmaterial.isShaderMaterial ||\\n\\t\\t\\t\\t\\tmaterial.skinning ) {\\n\\n\\t\\t\\t\\t\\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// skinning uniforms must be set even if material didn't change\\n\\t\\t\\t// auto-setting of texture unit for bone texture must go before other textures\\n\\t\\t\\t// not sure why, but otherwise weird things happen\\n\\n\\t\\t\\tif ( material.skinning ) {\\n\\n\\t\\t\\t\\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\\n\\t\\t\\t\\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\\n\\n\\t\\t\\t\\tvar skeleton = object.skeleton;\\n\\n\\t\\t\\t\\tif ( skeleton ) {\\n\\n\\t\\t\\t\\t\\tvar bones = skeleton.bones;\\n\\n\\t\\t\\t\\t\\tif ( capabilities.floatVertexTextures ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( skeleton.boneTexture === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// layout (1 matrix = 4 pixels)\\n\\t\\t\\t\\t\\t\\t\\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\\n\\t\\t\\t\\t\\t\\t\\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\\n\\t\\t\\t\\t\\t\\t\\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\\n\\t\\t\\t\\t\\t\\t\\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\\n\\t\\t\\t\\t\\t\\t\\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\\n\\n\\n\\t\\t\\t\\t\\t\\t\\tvar size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix\\n\\t\\t\\t\\t\\t\\t\\tsize = _Math.ceilPowerOfTwo( size );\\n\\t\\t\\t\\t\\t\\t\\tsize = Math.max( size, 4 );\\n\\n\\t\\t\\t\\t\\t\\t\\tvar boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel\\n\\t\\t\\t\\t\\t\\t\\tboneMatrices.set( skeleton.boneMatrices ); // copy current values\\n\\n\\t\\t\\t\\t\\t\\t\\tvar boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );\\n\\n\\t\\t\\t\\t\\t\\t\\tskeleton.boneMatrices = boneMatrices;\\n\\t\\t\\t\\t\\t\\t\\tskeleton.boneTexture = boneTexture;\\n\\t\\t\\t\\t\\t\\t\\tskeleton.boneTextureSize = size;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tp_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );\\n\\t\\t\\t\\t\\t\\tp_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( refreshMaterial ) {\\n\\n\\t\\t\\t\\tp_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );\\n\\t\\t\\t\\tp_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );\\n\\n\\t\\t\\t\\tif ( material.lights ) {\\n\\n\\t\\t\\t\\t\\t// the current material requires lighting info\\n\\n\\t\\t\\t\\t\\t// note: all lighting uniforms are always set correctly\\n\\t\\t\\t\\t\\t// they simply reference the renderer's state for their\\n\\t\\t\\t\\t\\t// values\\n\\t\\t\\t\\t\\t//\\n\\t\\t\\t\\t\\t// use the current material's .needsUpdate flags to set\\n\\t\\t\\t\\t\\t// the GL state when required\\n\\n\\t\\t\\t\\t\\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// refresh uniforms common to several materials\\n\\n\\t\\t\\t\\tif ( fog && material.fog ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsFog( m_uniforms, fog );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( material.isMeshBasicMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\n\\t\\t\\t\\t} else if ( material.isMeshLambertMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\t\\t\\t\\t\\trefreshUniformsLambert( m_uniforms, material );\\n\\n\\t\\t\\t\\t} else if ( material.isMeshPhongMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\tif ( material.isMeshToonMaterial ) {\\n\\n\\t\\t\\t\\t\\t\\trefreshUniformsToon( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\trefreshUniformsPhong( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( material.isMeshStandardMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\tif ( material.isMeshPhysicalMaterial ) {\\n\\n\\t\\t\\t\\t\\t\\trefreshUniformsPhysical( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\trefreshUniformsStandard( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( material.isMeshDepthMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\t\\t\\t\\t\\trefreshUniformsDepth( m_uniforms, material );\\n\\n\\t\\t\\t\\t} else if ( material.isMeshDistanceMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\t\\t\\t\\t\\trefreshUniformsDistance( m_uniforms, material );\\n\\n\\t\\t\\t\\t} else if ( material.isMeshNormalMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsCommon( m_uniforms, material );\\n\\t\\t\\t\\t\\trefreshUniformsNormal( m_uniforms, material );\\n\\n\\t\\t\\t\\t} else if ( material.isLineBasicMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsLine( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\tif ( material.isLineDashedMaterial ) {\\n\\n\\t\\t\\t\\t\\t\\trefreshUniformsDash( m_uniforms, material );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( material.isPointsMaterial ) {\\n\\n\\t\\t\\t\\t\\trefreshUniformsPoints( m_uniforms, material );\\n\\n\\t\\t\\t\\t} else if ( material.isShadowMaterial ) {\\n\\n\\t\\t\\t\\t\\tm_uniforms.color.value = material.color;\\n\\t\\t\\t\\t\\tm_uniforms.opacity.value = material.opacity;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// RectAreaLight Texture\\n\\t\\t\\t\\t// TODO (mrdoob): Find a nicer implementation\\n\\n\\t\\t\\t\\tif ( m_uniforms.ltcMat !== undefined ) m_uniforms.ltcMat.value = UniformsLib.LTC_MAT_TEXTURE;\\n\\t\\t\\t\\tif ( m_uniforms.ltcMag !== undefined ) m_uniforms.ltcMag.value = UniformsLib.LTC_MAG_TEXTURE;\\n\\n\\t\\t\\t\\tWebGLUniforms.upload(\\n\\t\\t\\t\\t\\t_gl, materialProperties.uniformsList, m_uniforms, _this );\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\t// common matrices\\n\\n\\t\\t\\tp_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );\\n\\t\\t\\tp_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );\\n\\t\\t\\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\\n\\n\\t\\t\\treturn program;\\n\\n\\t\\t}\\n\\n\\t\\t// Uniforms (refresh uniforms objects)\\n\\n\\t\\tfunction refreshUniformsCommon( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.opacity.value = material.opacity;\\n\\n\\t\\t\\tif ( material.color ) {\\n\\n\\t\\t\\t\\tuniforms.diffuse.value = material.color;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.emissive ) {\\n\\n\\t\\t\\t\\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.map ) {\\n\\n\\t\\t\\t\\tuniforms.map.value = material.map;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.alphaMap ) {\\n\\n\\t\\t\\t\\tuniforms.alphaMap.value = material.alphaMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.specularMap ) {\\n\\n\\t\\t\\t\\tuniforms.specularMap.value = material.specularMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.envMap ) {\\n\\n\\t\\t\\t\\tuniforms.envMap.value = material.envMap;\\n\\n\\t\\t\\t\\t// don't flip CubeTexture envMaps, flip everything else:\\n\\t\\t\\t\\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\\n\\t\\t\\t\\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\\n\\t\\t\\t\\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\\n\\t\\t\\t\\tuniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;\\n\\n\\t\\t\\t\\tuniforms.reflectivity.value = material.reflectivity;\\n\\t\\t\\t\\tuniforms.refractionRatio.value = material.refractionRatio;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.lightMap ) {\\n\\n\\t\\t\\t\\tuniforms.lightMap.value = material.lightMap;\\n\\t\\t\\t\\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.aoMap ) {\\n\\n\\t\\t\\t\\tuniforms.aoMap.value = material.aoMap;\\n\\t\\t\\t\\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// uv repeat and offset setting priorities\\n\\t\\t\\t// 1. color map\\n\\t\\t\\t// 2. specular map\\n\\t\\t\\t// 3. normal map\\n\\t\\t\\t// 4. bump map\\n\\t\\t\\t// 5. alpha map\\n\\t\\t\\t// 6. emissive map\\n\\n\\t\\t\\tvar uvScaleMap;\\n\\n\\t\\t\\tif ( material.map ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.map;\\n\\n\\t\\t\\t} else if ( material.specularMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.specularMap;\\n\\n\\t\\t\\t} else if ( material.displacementMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.displacementMap;\\n\\n\\t\\t\\t} else if ( material.normalMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.normalMap;\\n\\n\\t\\t\\t} else if ( material.bumpMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.bumpMap;\\n\\n\\t\\t\\t} else if ( material.roughnessMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.roughnessMap;\\n\\n\\t\\t\\t} else if ( material.metalnessMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.metalnessMap;\\n\\n\\t\\t\\t} else if ( material.alphaMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.alphaMap;\\n\\n\\t\\t\\t} else if ( material.emissiveMap ) {\\n\\n\\t\\t\\t\\tuvScaleMap = material.emissiveMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( uvScaleMap !== undefined ) {\\n\\n\\t\\t\\t\\t// backwards compatibility\\n\\t\\t\\t\\tif ( uvScaleMap.isWebGLRenderTarget ) {\\n\\n\\t\\t\\t\\t\\tuvScaleMap = uvScaleMap.texture;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( uvScaleMap.matrixAutoUpdate === true ) {\\n\\n\\t\\t\\t\\t\\tvar offset = uvScaleMap.offset;\\n\\t\\t\\t\\t\\tvar repeat = uvScaleMap.repeat;\\n\\t\\t\\t\\t\\tvar rotation = uvScaleMap.rotation;\\n\\t\\t\\t\\t\\tvar center = uvScaleMap.center;\\n\\n\\t\\t\\t\\t\\tuvScaleMap.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tuniforms.uvTransform.value.copy( uvScaleMap.matrix );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsLine( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.diffuse.value = material.color;\\n\\t\\t\\tuniforms.opacity.value = material.opacity;\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsDash( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.dashSize.value = material.dashSize;\\n\\t\\t\\tuniforms.totalSize.value = material.dashSize + material.gapSize;\\n\\t\\t\\tuniforms.scale.value = material.scale;\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsPoints( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.diffuse.value = material.color;\\n\\t\\t\\tuniforms.opacity.value = material.opacity;\\n\\t\\t\\tuniforms.size.value = material.size * _pixelRatio;\\n\\t\\t\\tuniforms.scale.value = _height * 0.5;\\n\\n\\t\\t\\tuniforms.map.value = material.map;\\n\\n\\t\\t\\tif ( material.map !== null ) {\\n\\n\\t\\t\\t\\tif ( material.map.matrixAutoUpdate === true ) {\\n\\n\\t\\t\\t\\t\\tvar offset = material.map.offset;\\n\\t\\t\\t\\t\\tvar repeat = material.map.repeat;\\n\\t\\t\\t\\t\\tvar rotation = material.map.rotation;\\n\\t\\t\\t\\t\\tvar center = material.map.center;\\n\\n\\t\\t\\t\\t\\tmaterial.map.matrix.setUvTransform( offset.x, offset.y, repeat.x, repeat.y, rotation, center.x, center.y );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tuniforms.uvTransform.value.copy( material.map.matrix );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsFog( uniforms, fog ) {\\n\\n\\t\\t\\tuniforms.fogColor.value = fog.color;\\n\\n\\t\\t\\tif ( fog.isFog ) {\\n\\n\\t\\t\\t\\tuniforms.fogNear.value = fog.near;\\n\\t\\t\\t\\tuniforms.fogFar.value = fog.far;\\n\\n\\t\\t\\t} else if ( fog.isFogExp2 ) {\\n\\n\\t\\t\\t\\tuniforms.fogDensity.value = fog.density;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsLambert( uniforms, material ) {\\n\\n\\t\\t\\tif ( material.emissiveMap ) {\\n\\n\\t\\t\\t\\tuniforms.emissiveMap.value = material.emissiveMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsPhong( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.specular.value = material.specular;\\n\\t\\t\\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\\n\\n\\t\\t\\tif ( material.emissiveMap ) {\\n\\n\\t\\t\\t\\tuniforms.emissiveMap.value = material.emissiveMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.bumpMap ) {\\n\\n\\t\\t\\t\\tuniforms.bumpMap.value = material.bumpMap;\\n\\t\\t\\t\\tuniforms.bumpScale.value = material.bumpScale;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.normalMap ) {\\n\\n\\t\\t\\t\\tuniforms.normalMap.value = material.normalMap;\\n\\t\\t\\t\\tuniforms.normalScale.value.copy( material.normalScale );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.displacementMap ) {\\n\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsToon( uniforms, material ) {\\n\\n\\t\\t\\trefreshUniformsPhong( uniforms, material );\\n\\n\\t\\t\\tif ( material.gradientMap ) {\\n\\n\\t\\t\\t\\tuniforms.gradientMap.value = material.gradientMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsStandard( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.roughness.value = material.roughness;\\n\\t\\t\\tuniforms.metalness.value = material.metalness;\\n\\n\\t\\t\\tif ( material.roughnessMap ) {\\n\\n\\t\\t\\t\\tuniforms.roughnessMap.value = material.roughnessMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.metalnessMap ) {\\n\\n\\t\\t\\t\\tuniforms.metalnessMap.value = material.metalnessMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.emissiveMap ) {\\n\\n\\t\\t\\t\\tuniforms.emissiveMap.value = material.emissiveMap;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.bumpMap ) {\\n\\n\\t\\t\\t\\tuniforms.bumpMap.value = material.bumpMap;\\n\\t\\t\\t\\tuniforms.bumpScale.value = material.bumpScale;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.normalMap ) {\\n\\n\\t\\t\\t\\tuniforms.normalMap.value = material.normalMap;\\n\\t\\t\\t\\tuniforms.normalScale.value.copy( material.normalScale );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.displacementMap ) {\\n\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.envMap ) {\\n\\n\\t\\t\\t\\t//uniforms.envMap.value = material.envMap; // part of uniforms common\\n\\t\\t\\t\\tuniforms.envMapIntensity.value = material.envMapIntensity;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsPhysical( uniforms, material ) {\\n\\n\\t\\t\\tuniforms.clearCoat.value = material.clearCoat;\\n\\t\\t\\tuniforms.clearCoatRoughness.value = material.clearCoatRoughness;\\n\\n\\t\\t\\trefreshUniformsStandard( uniforms, material );\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsDepth( uniforms, material ) {\\n\\n\\t\\t\\tif ( material.displacementMap ) {\\n\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsDistance( uniforms, material ) {\\n\\n\\t\\t\\tif ( material.displacementMap ) {\\n\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tuniforms.referencePosition.value.copy( material.referencePosition );\\n\\t\\t\\tuniforms.nearDistance.value = material.nearDistance;\\n\\t\\t\\tuniforms.farDistance.value = material.farDistance;\\n\\n\\t\\t}\\n\\n\\t\\tfunction refreshUniformsNormal( uniforms, material ) {\\n\\n\\t\\t\\tif ( material.bumpMap ) {\\n\\n\\t\\t\\t\\tuniforms.bumpMap.value = material.bumpMap;\\n\\t\\t\\t\\tuniforms.bumpScale.value = material.bumpScale;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.normalMap ) {\\n\\n\\t\\t\\t\\tuniforms.normalMap.value = material.normalMap;\\n\\t\\t\\t\\tuniforms.normalScale.value.copy( material.normalScale );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( material.displacementMap ) {\\n\\n\\t\\t\\t\\tuniforms.displacementMap.value = material.displacementMap;\\n\\t\\t\\t\\tuniforms.displacementScale.value = material.displacementScale;\\n\\t\\t\\t\\tuniforms.displacementBias.value = material.displacementBias;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\\n\\n\\t\\tfunction markUniformsLightsNeedsUpdate( uniforms, value ) {\\n\\n\\t\\t\\tuniforms.ambientLightColor.needsUpdate = value;\\n\\n\\t\\t\\tuniforms.directionalLights.needsUpdate = value;\\n\\t\\t\\tuniforms.pointLights.needsUpdate = value;\\n\\t\\t\\tuniforms.spotLights.needsUpdate = value;\\n\\t\\t\\tuniforms.rectAreaLights.needsUpdate = value;\\n\\t\\t\\tuniforms.hemisphereLights.needsUpdate = value;\\n\\n\\t\\t}\\n\\n\\t\\t// GL state setting\\n\\n\\t\\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\\n\\n\\t\\t\\tstate.setCullFace( cullFace );\\n\\t\\t\\tstate.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );\\n\\n\\t\\t};\\n\\n\\t\\t// Textures\\n\\n\\t\\tfunction allocTextureUnit() {\\n\\n\\t\\t\\tvar textureUnit = _usedTextureUnits;\\n\\n\\t\\t\\tif ( textureUnit >= capabilities.maxTextures ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t_usedTextureUnits += 1;\\n\\n\\t\\t\\treturn textureUnit;\\n\\n\\t\\t}\\n\\n\\t\\tthis.allocTextureUnit = allocTextureUnit;\\n\\n\\t\\t// this.setTexture2D = setTexture2D;\\n\\t\\tthis.setTexture2D = ( function () {\\n\\n\\t\\t\\tvar warned = false;\\n\\n\\t\\t\\t// backwards compatibility: peel texture.texture\\n\\t\\t\\treturn function setTexture2D( texture, slot ) {\\n\\n\\t\\t\\t\\tif ( texture && texture.isWebGLRenderTarget ) {\\n\\n\\t\\t\\t\\t\\tif ( ! warned ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\\\" );\\n\\t\\t\\t\\t\\t\\twarned = true;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttexture = texture.texture;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttextures.setTexture2D( texture, slot );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() );\\n\\n\\t\\tthis.setTexture = ( function () {\\n\\n\\t\\t\\tvar warned = false;\\n\\n\\t\\t\\treturn function setTexture( texture, slot ) {\\n\\n\\t\\t\\t\\tif ( ! warned ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\\\" );\\n\\t\\t\\t\\t\\twarned = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttextures.setTexture2D( texture, slot );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() );\\n\\n\\t\\tthis.setTextureCube = ( function () {\\n\\n\\t\\t\\tvar warned = false;\\n\\n\\t\\t\\treturn function setTextureCube( texture, slot ) {\\n\\n\\t\\t\\t\\t// backwards compatibility: peel texture.texture\\n\\t\\t\\t\\tif ( texture && texture.isWebGLRenderTargetCube ) {\\n\\n\\t\\t\\t\\t\\tif ( ! warned ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( \\\"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\\\" );\\n\\t\\t\\t\\t\\t\\twarned = true;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttexture = texture.texture;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\\n\\t\\t\\t\\t// TODO: unify these code paths\\n\\t\\t\\t\\tif ( ( texture && texture.isCubeTexture ) ||\\n\\t\\t\\t\\t\\t( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\\n\\n\\t\\t\\t\\t\\t// CompressedTexture can have Array in image :/\\n\\n\\t\\t\\t\\t\\t// this function alone should take care of cube textures\\n\\t\\t\\t\\t\\ttextures.setTextureCube( texture, slot );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// assumed: texture property of THREE.WebGLRenderTargetCube\\n\\n\\t\\t\\t\\t\\ttextures.setTextureCubeDynamic( texture, slot );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() );\\n\\n\\t\\tthis.getRenderTarget = function () {\\n\\n\\t\\t\\treturn _currentRenderTarget;\\n\\n\\t\\t};\\n\\n\\t\\tthis.setRenderTarget = function ( renderTarget ) {\\n\\n\\t\\t\\t_currentRenderTarget = renderTarget;\\n\\n\\t\\t\\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\\n\\n\\t\\t\\t\\ttextures.setupRenderTarget( renderTarget );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar framebuffer = null;\\n\\t\\t\\tvar isCube = false;\\n\\n\\t\\t\\tif ( renderTarget ) {\\n\\n\\t\\t\\t\\tvar __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;\\n\\n\\t\\t\\t\\tif ( renderTarget.isWebGLRenderTargetCube ) {\\n\\n\\t\\t\\t\\t\\tframebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ];\\n\\t\\t\\t\\t\\tisCube = true;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tframebuffer = __webglFramebuffer;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t_currentViewport.copy( renderTarget.viewport );\\n\\t\\t\\t\\t_currentScissor.copy( renderTarget.scissor );\\n\\t\\t\\t\\t_currentScissorTest = renderTarget.scissorTest;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\\n\\t\\t\\t\\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\\n\\t\\t\\t\\t_currentScissorTest = _scissorTest;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( _currentFramebuffer !== framebuffer ) {\\n\\n\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\\n\\t\\t\\t\\t_currentFramebuffer = framebuffer;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tstate.viewport( _currentViewport );\\n\\t\\t\\tstate.scissor( _currentScissor );\\n\\t\\t\\tstate.setScissorTest( _currentScissorTest );\\n\\n\\t\\t\\tif ( isCube ) {\\n\\n\\t\\t\\t\\tvar textureProperties = properties.get( renderTarget.texture );\\n\\t\\t\\t\\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\\n\\n\\t\\t\\tif ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\\n\\n\\t\\t\\tif ( framebuffer ) {\\n\\n\\t\\t\\t\\tvar restore = false;\\n\\n\\t\\t\\t\\tif ( framebuffer !== _currentFramebuffer ) {\\n\\n\\t\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\\n\\n\\t\\t\\t\\t\\trestore = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\tvar texture = renderTarget.texture;\\n\\t\\t\\t\\t\\tvar textureFormat = texture.format;\\n\\t\\t\\t\\t\\tvar textureType = texture.type;\\n\\n\\t\\t\\t\\t\\tif ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\\n\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)\\n\\t\\t\\t\\t\\t\\t! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox\\n\\t\\t\\t\\t\\t\\t! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\\n\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\\n\\n\\t\\t\\t\\t\\t\\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\\n\\n\\t\\t\\t\\t\\t\\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} finally {\\n\\n\\t\\t\\t\\t\\tif ( restore ) {\\n\\n\\t\\t\\t\\t\\t\\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction FogExp2( color, density ) {\\n\\n\\t\\tthis.name = '';\\n\\n\\t\\tthis.color = new Color( color );\\n\\t\\tthis.density = ( density !== undefined ) ? density : 0.00025;\\n\\n\\t}\\n\\n\\tFogExp2.prototype.isFogExp2 = true;\\n\\n\\tFogExp2.prototype.clone = function () {\\n\\n\\t\\treturn new FogExp2( this.color.getHex(), this.density );\\n\\n\\t};\\n\\n\\tFogExp2.prototype.toJSON = function ( /* meta */ ) {\\n\\n\\t\\treturn {\\n\\t\\t\\ttype: 'FogExp2',\\n\\t\\t\\tcolor: this.color.getHex(),\\n\\t\\t\\tdensity: this.density\\n\\t\\t};\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Fog( color, near, far ) {\\n\\n\\t\\tthis.name = '';\\n\\n\\t\\tthis.color = new Color( color );\\n\\n\\t\\tthis.near = ( near !== undefined ) ? near : 1;\\n\\t\\tthis.far = ( far !== undefined ) ? far : 1000;\\n\\n\\t}\\n\\n\\tFog.prototype.isFog = true;\\n\\n\\tFog.prototype.clone = function () {\\n\\n\\t\\treturn new Fog( this.color.getHex(), this.near, this.far );\\n\\n\\t};\\n\\n\\tFog.prototype.toJSON = function ( /* meta */ ) {\\n\\n\\t\\treturn {\\n\\t\\t\\ttype: 'Fog',\\n\\t\\t\\tcolor: this.color.getHex(),\\n\\t\\t\\tnear: this.near,\\n\\t\\t\\tfar: this.far\\n\\t\\t};\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Scene() {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Scene';\\n\\n\\t\\tthis.background = null;\\n\\t\\tthis.fog = null;\\n\\t\\tthis.overrideMaterial = null;\\n\\n\\t\\tthis.autoUpdate = true; // checked by the renderer\\n\\n\\t}\\n\\n\\tScene.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Scene,\\n\\n\\t\\tcopy: function ( source, recursive ) {\\n\\n\\t\\t\\tObject3D.prototype.copy.call( this, source, recursive );\\n\\n\\t\\t\\tif ( source.background !== null ) this.background = source.background.clone();\\n\\t\\t\\tif ( source.fog !== null ) this.fog = source.fog.clone();\\n\\t\\t\\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\\n\\n\\t\\t\\tthis.autoUpdate = source.autoUpdate;\\n\\t\\t\\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\n\\n\\t\\t\\tif ( this.background !== null ) data.object.background = this.background.toJSON( meta );\\n\\t\\t\\tif ( this.fog !== null ) data.object.fog = this.fog.toJSON();\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction LensFlare( texture, size, distance, blending, color ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.lensFlares = [];\\n\\n\\t\\tthis.positionScreen = new Vector3();\\n\\t\\tthis.customUpdateCallback = undefined;\\n\\n\\t\\tif ( texture !== undefined ) {\\n\\n\\t\\t\\tthis.add( texture, size, distance, blending, color );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tLensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: LensFlare,\\n\\n\\t\\tisLensFlare: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tObject3D.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.positionScreen.copy( source.positionScreen );\\n\\t\\t\\tthis.customUpdateCallback = source.customUpdateCallback;\\n\\n\\t\\t\\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tthis.lensFlares.push( source.lensFlares[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tadd: function ( texture, size, distance, blending, color, opacity ) {\\n\\n\\t\\t\\tif ( size === undefined ) size = - 1;\\n\\t\\t\\tif ( distance === undefined ) distance = 0;\\n\\t\\t\\tif ( opacity === undefined ) opacity = 1;\\n\\t\\t\\tif ( color === undefined ) color = new Color( 0xffffff );\\n\\t\\t\\tif ( blending === undefined ) blending = NormalBlending;\\n\\n\\t\\t\\tdistance = Math.min( distance, Math.max( 0, distance ) );\\n\\n\\t\\t\\tthis.lensFlares.push( {\\n\\t\\t\\t\\ttexture: texture,\\t// THREE.Texture\\n\\t\\t\\t\\tsize: size, \\t\\t// size in pixels (-1 = use texture.width)\\n\\t\\t\\t\\tdistance: distance, \\t// distance (0-1) from light source (0=at light source)\\n\\t\\t\\t\\tx: 0, y: 0, z: 0,\\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\\n\\t\\t\\t\\tscale: 1, \\t\\t// scale\\n\\t\\t\\t\\trotation: 0, \\t\\t// rotation\\n\\t\\t\\t\\topacity: opacity,\\t// opacity\\n\\t\\t\\t\\tcolor: color,\\t\\t// color\\n\\t\\t\\t\\tblending: blending\\t// blending\\n\\t\\t\\t} );\\n\\n\\t\\t},\\n\\n\\t\\t/*\\n\\t\\t * Update lens flares update positions on all flares based on the screen position\\n\\t\\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\\n\\t\\t */\\n\\n\\t\\tupdateLensFlares: function () {\\n\\n\\t\\t\\tvar f, fl = this.lensFlares.length;\\n\\t\\t\\tvar flare;\\n\\t\\t\\tvar vecX = - this.positionScreen.x * 2;\\n\\t\\t\\tvar vecY = - this.positionScreen.y * 2;\\n\\n\\t\\t\\tfor ( f = 0; f < fl; f ++ ) {\\n\\n\\t\\t\\t\\tflare = this.lensFlares[ f ];\\n\\n\\t\\t\\t\\tflare.x = this.positionScreen.x + vecX * flare.distance;\\n\\t\\t\\t\\tflare.y = this.positionScreen.y + vecY * flare.distance;\\n\\n\\t\\t\\t\\tflare.wantedRotation = flare.x * Math.PI * 0.25;\\n\\t\\t\\t\\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  opacity: <float>,\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *\\tuvOffset: new THREE.Vector2(),\\n\\t *\\tuvScale: new THREE.Vector2()\\n\\t * }\\n\\t */\\n\\n\\tfunction SpriteMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'SpriteMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff );\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.rotation = 0;\\n\\n\\t\\tthis.fog = false;\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tSpriteMaterial.prototype = Object.create( Material.prototype );\\n\\tSpriteMaterial.prototype.constructor = SpriteMaterial;\\n\\tSpriteMaterial.prototype.isSpriteMaterial = true;\\n\\n\\tSpriteMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.color.copy( source.color );\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.rotation = source.rotation;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Sprite( material ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Sprite';\\n\\n\\t\\tthis.material = ( material !== undefined ) ? material : new SpriteMaterial();\\n\\n\\t}\\n\\n\\tSprite.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Sprite,\\n\\n\\t\\tisSprite: true,\\n\\n\\t\\traycast: ( function () {\\n\\n\\t\\t\\tvar intersectPoint = new Vector3();\\n\\t\\t\\tvar worldPosition = new Vector3();\\n\\t\\t\\tvar worldScale = new Vector3();\\n\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\n\\n\\t\\t\\t\\tworldPosition.setFromMatrixPosition( this.matrixWorld );\\n\\t\\t\\t\\traycaster.ray.closestPointToPoint( worldPosition, intersectPoint );\\n\\n\\t\\t\\t\\tworldScale.setFromMatrixScale( this.matrixWorld );\\n\\t\\t\\t\\tvar guessSizeSq = worldScale.x * worldScale.y / 4;\\n\\n\\t\\t\\t\\tif ( worldPosition.distanceToSquared( intersectPoint ) > guessSizeSq ) return;\\n\\n\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\\n\\n\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) return;\\n\\n\\t\\t\\t\\tintersects.push( {\\n\\n\\t\\t\\t\\t\\tdistance: distance,\\n\\t\\t\\t\\t\\tpoint: intersectPoint.clone(),\\n\\t\\t\\t\\t\\tface: null,\\n\\t\\t\\t\\t\\tobject: this\\n\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() ),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.material ).copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction LOD() {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'LOD';\\n\\n\\t\\tObject.defineProperties( this, {\\n\\t\\t\\tlevels: {\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\tvalue: []\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t}\\n\\n\\tLOD.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: LOD,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tObject3D.prototype.copy.call( this, source, false );\\n\\n\\t\\t\\tvar levels = source.levels;\\n\\n\\t\\t\\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar level = levels[ i ];\\n\\n\\t\\t\\t\\tthis.addLevel( level.object.clone(), level.distance );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\taddLevel: function ( object, distance ) {\\n\\n\\t\\t\\tif ( distance === undefined ) distance = 0;\\n\\n\\t\\t\\tdistance = Math.abs( distance );\\n\\n\\t\\t\\tvar levels = this.levels;\\n\\n\\t\\t\\tfor ( var l = 0; l < levels.length; l ++ ) {\\n\\n\\t\\t\\t\\tif ( distance < levels[ l ].distance ) {\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tlevels.splice( l, 0, { distance: distance, object: object } );\\n\\n\\t\\t\\tthis.add( object );\\n\\n\\t\\t},\\n\\n\\t\\tgetObjectForDistance: function ( distance ) {\\n\\n\\t\\t\\tvar levels = this.levels;\\n\\n\\t\\t\\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tif ( distance < levels[ i ].distance ) {\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn levels[ i - 1 ].object;\\n\\n\\t\\t},\\n\\n\\t\\traycast: ( function () {\\n\\n\\t\\t\\tvar matrixPosition = new Vector3();\\n\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\n\\n\\t\\t\\t\\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\\n\\n\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\\n\\n\\t\\t\\t\\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() ),\\n\\n\\t\\tupdate: function () {\\n\\n\\t\\t\\tvar v1 = new Vector3();\\n\\t\\t\\tvar v2 = new Vector3();\\n\\n\\t\\t\\treturn function update( camera ) {\\n\\n\\t\\t\\t\\tvar levels = this.levels;\\n\\n\\t\\t\\t\\tif ( levels.length > 1 ) {\\n\\n\\t\\t\\t\\t\\tv1.setFromMatrixPosition( camera.matrixWorld );\\n\\t\\t\\t\\t\\tv2.setFromMatrixPosition( this.matrixWorld );\\n\\n\\t\\t\\t\\t\\tvar distance = v1.distanceTo( v2 );\\n\\n\\t\\t\\t\\t\\tlevels[ 0 ].object.visible = true;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( distance >= levels[ i ].distance ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tlevels[ i - 1 ].object.visible = false;\\n\\t\\t\\t\\t\\t\\t\\tlevels[ i ].object.visible = true;\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfor ( ; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tlevels[ i ].object.visible = false;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\n\\n\\t\\t\\tdata.object.levels = [];\\n\\n\\t\\t\\tvar levels = this.levels;\\n\\n\\t\\t\\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar level = levels[ i ];\\n\\n\\t\\t\\t\\tdata.object.levels.push( {\\n\\t\\t\\t\\t\\tobject: level.object.uuid,\\n\\t\\t\\t\\t\\tdistance: level.distance\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author michael guerrero / http://realitymeltdown.com\\n\\t * @author ikerr / http://verold.com\\n\\t */\\n\\n\\tfunction Skeleton( bones, boneInverses ) {\\n\\n\\t\\t// copy the bone array\\n\\n\\t\\tbones = bones || [];\\n\\n\\t\\tthis.bones = bones.slice( 0 );\\n\\t\\tthis.boneMatrices = new Float32Array( this.bones.length * 16 );\\n\\n\\t\\t// use the supplied bone inverses or calculate the inverses\\n\\n\\t\\tif ( boneInverses === undefined ) {\\n\\n\\t\\t\\tthis.calculateInverses();\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tif ( this.bones.length === boneInverses.length ) {\\n\\n\\t\\t\\t\\tthis.boneInverses = boneInverses.slice( 0 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Skeleton boneInverses is the wrong length.' );\\n\\n\\t\\t\\t\\tthis.boneInverses = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tthis.boneInverses.push( new Matrix4() );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tObject.assign( Skeleton.prototype, {\\n\\n\\t\\tcalculateInverses: function () {\\n\\n\\t\\t\\tthis.boneInverses = [];\\n\\n\\t\\t\\tfor ( var i = 0, il = this.bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar inverse = new Matrix4();\\n\\n\\t\\t\\t\\tif ( this.bones[ i ] ) {\\n\\n\\t\\t\\t\\t\\tinverse.getInverse( this.bones[ i ].matrixWorld );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.boneInverses.push( inverse );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tpose: function () {\\n\\n\\t\\t\\tvar bone, i, il;\\n\\n\\t\\t\\t// recover the bind-time world matrices\\n\\n\\t\\t\\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tbone = this.bones[ i ];\\n\\n\\t\\t\\t\\tif ( bone ) {\\n\\n\\t\\t\\t\\t\\tbone.matrixWorld.getInverse( this.boneInverses[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// compute the local matrices, positions, rotations and scales\\n\\n\\t\\t\\tfor ( i = 0, il = this.bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tbone = this.bones[ i ];\\n\\n\\t\\t\\t\\tif ( bone ) {\\n\\n\\t\\t\\t\\t\\tif ( bone.parent && bone.parent.isBone ) {\\n\\n\\t\\t\\t\\t\\t\\tbone.matrix.getInverse( bone.parent.matrixWorld );\\n\\t\\t\\t\\t\\t\\tbone.matrix.multiply( bone.matrixWorld );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tbone.matrix.copy( bone.matrixWorld );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tupdate: ( function () {\\n\\n\\t\\t\\tvar offsetMatrix = new Matrix4();\\n\\t\\t\\tvar identityMatrix = new Matrix4();\\n\\n\\t\\t\\treturn function update() {\\n\\n\\t\\t\\t\\tvar bones = this.bones;\\n\\t\\t\\t\\tvar boneInverses = this.boneInverses;\\n\\t\\t\\t\\tvar boneMatrices = this.boneMatrices;\\n\\t\\t\\t\\tvar boneTexture = this.boneTexture;\\n\\n\\t\\t\\t\\t// flatten bone matrices to array\\n\\n\\t\\t\\t\\tfor ( var i = 0, il = bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t// compute the offset between the current and the original transform\\n\\n\\t\\t\\t\\t\\tvar matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;\\n\\n\\t\\t\\t\\t\\toffsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );\\n\\t\\t\\t\\t\\toffsetMatrix.toArray( boneMatrices, i * 16 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( boneTexture !== undefined ) {\\n\\n\\t\\t\\t\\t\\tboneTexture.needsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )(),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new Skeleton( this.bones, this.boneInverses );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author ikerr / http://verold.com\\n\\t */\\n\\n\\tfunction Bone() {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Bone';\\n\\n\\t}\\n\\n\\tBone.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Bone,\\n\\n\\t\\tisBone: true\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mikael emtinger / http://gomo.se/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author ikerr / http://verold.com\\n\\t */\\n\\n\\tfunction SkinnedMesh( geometry, material ) {\\n\\n\\t\\tMesh.call( this, geometry, material );\\n\\n\\t\\tthis.type = 'SkinnedMesh';\\n\\n\\t\\tthis.bindMode = 'attached';\\n\\t\\tthis.bindMatrix = new Matrix4();\\n\\t\\tthis.bindMatrixInverse = new Matrix4();\\n\\n\\t\\tvar bones = this.initBones();\\n\\t\\tvar skeleton = new Skeleton( bones );\\n\\n\\t\\tthis.bind( skeleton, this.matrixWorld );\\n\\n\\t\\tthis.normalizeSkinWeights();\\n\\n\\t}\\n\\n\\tSkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {\\n\\n\\t\\tconstructor: SkinnedMesh,\\n\\n\\t\\tisSkinnedMesh: true,\\n\\n\\t\\tinitBones: function () {\\n\\n\\t\\t\\tvar bones = [], bone, gbone;\\n\\t\\t\\tvar i, il;\\n\\n\\t\\t\\tif ( this.geometry && this.geometry.bones !== undefined ) {\\n\\n\\t\\t\\t\\t// first, create array of 'Bone' objects from geometry data\\n\\n\\t\\t\\t\\tfor ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tgbone = this.geometry.bones[ i ];\\n\\n\\t\\t\\t\\t\\t// create new 'Bone' object\\n\\n\\t\\t\\t\\t\\tbone = new Bone();\\n\\t\\t\\t\\t\\tbones.push( bone );\\n\\n\\t\\t\\t\\t\\t// apply values\\n\\n\\t\\t\\t\\t\\tbone.name = gbone.name;\\n\\t\\t\\t\\t\\tbone.position.fromArray( gbone.pos );\\n\\t\\t\\t\\t\\tbone.quaternion.fromArray( gbone.rotq );\\n\\t\\t\\t\\t\\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// second, create bone hierarchy\\n\\n\\t\\t\\t\\tfor ( i = 0, il = this.geometry.bones.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tgbone = this.geometry.bones[ i ];\\n\\n\\t\\t\\t\\t\\tif ( ( gbone.parent !== - 1 ) && ( gbone.parent !== null ) && ( bones[ gbone.parent ] !== undefined ) ) {\\n\\n\\t\\t\\t\\t\\t\\t// subsequent bones in the hierarchy\\n\\n\\t\\t\\t\\t\\t\\tbones[ gbone.parent ].add( bones[ i ] );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// topmost bone, immediate child of the skinned mesh\\n\\n\\t\\t\\t\\t\\t\\tthis.add( bones[ i ] );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// now the bones are part of the scene graph and children of the skinned mesh.\\n\\t\\t\\t// let's update the corresponding matrices\\n\\n\\t\\t\\tthis.updateMatrixWorld( true );\\n\\n\\t\\t\\treturn bones;\\n\\n\\t\\t},\\n\\n\\t\\tbind: function ( skeleton, bindMatrix ) {\\n\\n\\t\\t\\tthis.skeleton = skeleton;\\n\\n\\t\\t\\tif ( bindMatrix === undefined ) {\\n\\n\\t\\t\\t\\tthis.updateMatrixWorld( true );\\n\\n\\t\\t\\t\\tthis.skeleton.calculateInverses();\\n\\n\\t\\t\\t\\tbindMatrix = this.matrixWorld;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.bindMatrix.copy( bindMatrix );\\n\\t\\t\\tthis.bindMatrixInverse.getInverse( bindMatrix );\\n\\n\\t\\t},\\n\\n\\t\\tpose: function () {\\n\\n\\t\\t\\tthis.skeleton.pose();\\n\\n\\t\\t},\\n\\n\\t\\tnormalizeSkinWeights: function () {\\n\\n\\t\\t\\tvar scale, i;\\n\\n\\t\\t\\tif ( this.geometry && this.geometry.isGeometry ) {\\n\\n\\t\\t\\t\\tfor ( i = 0; i < this.geometry.skinWeights.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar sw = this.geometry.skinWeights[ i ];\\n\\n\\t\\t\\t\\t\\tscale = 1.0 / sw.manhattanLength();\\n\\n\\t\\t\\t\\t\\tif ( scale !== Infinity ) {\\n\\n\\t\\t\\t\\t\\t\\tsw.multiplyScalar( scale );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tsw.set( 1, 0, 0, 0 ); // do something reasonable\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( this.geometry && this.geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\tvar vec = new Vector4();\\n\\n\\t\\t\\t\\tvar skinWeight = this.geometry.attributes.skinWeight;\\n\\n\\t\\t\\t\\tfor ( i = 0; i < skinWeight.count; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvec.x = skinWeight.getX( i );\\n\\t\\t\\t\\t\\tvec.y = skinWeight.getY( i );\\n\\t\\t\\t\\t\\tvec.z = skinWeight.getZ( i );\\n\\t\\t\\t\\t\\tvec.w = skinWeight.getW( i );\\n\\n\\t\\t\\t\\t\\tscale = 1.0 / vec.manhattanLength();\\n\\n\\t\\t\\t\\t\\tif ( scale !== Infinity ) {\\n\\n\\t\\t\\t\\t\\t\\tvec.multiplyScalar( scale );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tvec.set( 1, 0, 0, 0 ); // do something reasonable\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tupdateMatrixWorld: function ( force ) {\\n\\n\\t\\t\\tMesh.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t\\t\\tif ( this.bindMode === 'attached' ) {\\n\\n\\t\\t\\t\\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\\n\\n\\t\\t\\t} else if ( this.bindMode === 'detached' ) {\\n\\n\\t\\t\\t\\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  linewidth: <float>,\\n\\t *  linecap: \\\"round\\\",\\n\\t *  linejoin: \\\"round\\\"\\n\\t * }\\n\\t */\\n\\n\\tfunction LineBasicMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'LineBasicMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff );\\n\\n\\t\\tthis.linewidth = 1;\\n\\t\\tthis.linecap = 'round';\\n\\t\\tthis.linejoin = 'round';\\n\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tLineBasicMaterial.prototype = Object.create( Material.prototype );\\n\\tLineBasicMaterial.prototype.constructor = LineBasicMaterial;\\n\\n\\tLineBasicMaterial.prototype.isLineBasicMaterial = true;\\n\\n\\tLineBasicMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.color.copy( source.color );\\n\\n\\t\\tthis.linewidth = source.linewidth;\\n\\t\\tthis.linecap = source.linecap;\\n\\t\\tthis.linejoin = source.linejoin;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Line( geometry, material, mode ) {\\n\\n\\t\\tif ( mode === 1 ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\\n\\t\\t\\treturn new LineSegments( geometry, material );\\n\\n\\t\\t}\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Line';\\n\\n\\t\\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\\n\\t\\tthis.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );\\n\\n\\t}\\n\\n\\tLine.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Line,\\n\\n\\t\\tisLine: true,\\n\\n\\t\\traycast: ( function () {\\n\\n\\t\\t\\tvar inverseMatrix = new Matrix4();\\n\\t\\t\\tvar ray = new Ray();\\n\\t\\t\\tvar sphere = new Sphere();\\n\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\n\\n\\t\\t\\t\\tvar precision = raycaster.linePrecision;\\n\\t\\t\\t\\tvar precisionSq = precision * precision;\\n\\n\\t\\t\\t\\tvar geometry = this.geometry;\\n\\t\\t\\t\\tvar matrixWorld = this.matrixWorld;\\n\\n\\t\\t\\t\\t// Checking boundingSphere distance to ray\\n\\n\\t\\t\\t\\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\\n\\n\\t\\t\\t\\tsphere.copy( geometry.boundingSphere );\\n\\t\\t\\t\\tsphere.applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\\n\\n\\t\\t\\t\\t//\\n\\n\\t\\t\\t\\tinverseMatrix.getInverse( matrixWorld );\\n\\t\\t\\t\\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\\n\\n\\t\\t\\t\\tvar vStart = new Vector3();\\n\\t\\t\\t\\tvar vEnd = new Vector3();\\n\\t\\t\\t\\tvar interSegment = new Vector3();\\n\\t\\t\\t\\tvar interRay = new Vector3();\\n\\t\\t\\t\\tvar step = ( this && this.isLineSegments ) ? 2 : 1;\\n\\n\\t\\t\\t\\tif ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\t\\tvar index = geometry.index;\\n\\t\\t\\t\\t\\tvar attributes = geometry.attributes;\\n\\t\\t\\t\\t\\tvar positions = attributes.position.array;\\n\\n\\t\\t\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\t\\t\\tvar indices = index.array;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar a = indices[ i ];\\n\\t\\t\\t\\t\\t\\t\\tvar b = indices[ i + 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\tvStart.fromArray( positions, a * 3 );\\n\\t\\t\\t\\t\\t\\t\\tvEnd.fromArray( positions, b * 3 );\\n\\n\\t\\t\\t\\t\\t\\t\\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( distSq > precisionSq ) continue;\\n\\n\\t\\t\\t\\t\\t\\t\\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\\n\\n\\t\\t\\t\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( interRay );\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\\n\\n\\t\\t\\t\\t\\t\\t\\tintersects.push( {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tdistance: distance,\\n\\t\\t\\t\\t\\t\\t\\t\\t// What do we want? intersection point on the ray or on the segment??\\n\\t\\t\\t\\t\\t\\t\\t\\t// point: raycaster.ray.at( distance ),\\n\\t\\t\\t\\t\\t\\t\\t\\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\\n\\t\\t\\t\\t\\t\\t\\t\\tindex: i,\\n\\t\\t\\t\\t\\t\\t\\t\\tface: null,\\n\\t\\t\\t\\t\\t\\t\\t\\tfaceIndex: null,\\n\\t\\t\\t\\t\\t\\t\\t\\tobject: this\\n\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvStart.fromArray( positions, 3 * i );\\n\\t\\t\\t\\t\\t\\t\\tvEnd.fromArray( positions, 3 * i + 3 );\\n\\n\\t\\t\\t\\t\\t\\t\\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( distSq > precisionSq ) continue;\\n\\n\\t\\t\\t\\t\\t\\t\\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\\n\\n\\t\\t\\t\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( interRay );\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\\n\\n\\t\\t\\t\\t\\t\\t\\tintersects.push( {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tdistance: distance,\\n\\t\\t\\t\\t\\t\\t\\t\\t// What do we want? intersection point on the ray or on the segment??\\n\\t\\t\\t\\t\\t\\t\\t\\t// point: raycaster.ray.at( distance ),\\n\\t\\t\\t\\t\\t\\t\\t\\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\\n\\t\\t\\t\\t\\t\\t\\t\\tindex: i,\\n\\t\\t\\t\\t\\t\\t\\t\\tface: null,\\n\\t\\t\\t\\t\\t\\t\\t\\tfaceIndex: null,\\n\\t\\t\\t\\t\\t\\t\\t\\tobject: this\\n\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( geometry.isGeometry ) {\\n\\n\\t\\t\\t\\t\\tvar vertices = geometry.vertices;\\n\\t\\t\\t\\t\\tvar nbVertices = vertices.length;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\\n\\n\\t\\t\\t\\t\\t\\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\\n\\n\\t\\t\\t\\t\\t\\tif ( distSq > precisionSq ) continue;\\n\\n\\t\\t\\t\\t\\t\\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\\n\\n\\t\\t\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( interRay );\\n\\n\\t\\t\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\\n\\n\\t\\t\\t\\t\\t\\tintersects.push( {\\n\\n\\t\\t\\t\\t\\t\\t\\tdistance: distance,\\n\\t\\t\\t\\t\\t\\t\\t// What do we want? intersection point on the ray or on the segment??\\n\\t\\t\\t\\t\\t\\t\\t// point: raycaster.ray.at( distance ),\\n\\t\\t\\t\\t\\t\\t\\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\\n\\t\\t\\t\\t\\t\\t\\tindex: i,\\n\\t\\t\\t\\t\\t\\t\\tface: null,\\n\\t\\t\\t\\t\\t\\t\\tfaceIndex: null,\\n\\t\\t\\t\\t\\t\\t\\tobject: this\\n\\n\\t\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() ),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction LineSegments( geometry, material ) {\\n\\n\\t\\tLine.call( this, geometry, material );\\n\\n\\t\\tthis.type = 'LineSegments';\\n\\n\\t}\\n\\n\\tLineSegments.prototype = Object.assign( Object.create( Line.prototype ), {\\n\\n\\t\\tconstructor: LineSegments,\\n\\n\\t\\tisLineSegments: true\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mgreter / http://github.com/mgreter\\n\\t */\\n\\n\\tfunction LineLoop( geometry, material ) {\\n\\n\\t\\tLine.call( this, geometry, material );\\n\\n\\t\\tthis.type = 'LineLoop';\\n\\n\\t}\\n\\n\\tLineLoop.prototype = Object.assign( Object.create( Line.prototype ), {\\n\\n\\t\\tconstructor: LineLoop,\\n\\n\\t\\tisLineLoop: true,\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  opacity: <float>,\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  size: <float>,\\n\\t *  sizeAttenuation: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction PointsMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'PointsMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff );\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.size = 1;\\n\\t\\tthis.sizeAttenuation = true;\\n\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tPointsMaterial.prototype = Object.create( Material.prototype );\\n\\tPointsMaterial.prototype.constructor = PointsMaterial;\\n\\n\\tPointsMaterial.prototype.isPointsMaterial = true;\\n\\n\\tPointsMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.color.copy( source.color );\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.size = source.size;\\n\\t\\tthis.sizeAttenuation = source.sizeAttenuation;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Points( geometry, material ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Points';\\n\\n\\t\\tthis.geometry = geometry !== undefined ? geometry : new BufferGeometry();\\n\\t\\tthis.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );\\n\\n\\t}\\n\\n\\tPoints.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Points,\\n\\n\\t\\tisPoints: true,\\n\\n\\t\\traycast: ( function () {\\n\\n\\t\\t\\tvar inverseMatrix = new Matrix4();\\n\\t\\t\\tvar ray = new Ray();\\n\\t\\t\\tvar sphere = new Sphere();\\n\\n\\t\\t\\treturn function raycast( raycaster, intersects ) {\\n\\n\\t\\t\\t\\tvar object = this;\\n\\t\\t\\t\\tvar geometry = this.geometry;\\n\\t\\t\\t\\tvar matrixWorld = this.matrixWorld;\\n\\t\\t\\t\\tvar threshold = raycaster.params.Points.threshold;\\n\\n\\t\\t\\t\\t// Checking boundingSphere distance to ray\\n\\n\\t\\t\\t\\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\\n\\n\\t\\t\\t\\tsphere.copy( geometry.boundingSphere );\\n\\t\\t\\t\\tsphere.applyMatrix4( matrixWorld );\\n\\t\\t\\t\\tsphere.radius += threshold;\\n\\n\\t\\t\\t\\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\\n\\n\\t\\t\\t\\t//\\n\\n\\t\\t\\t\\tinverseMatrix.getInverse( matrixWorld );\\n\\t\\t\\t\\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\\n\\n\\t\\t\\t\\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\\n\\t\\t\\t\\tvar localThresholdSq = localThreshold * localThreshold;\\n\\t\\t\\t\\tvar position = new Vector3();\\n\\n\\t\\t\\t\\tfunction testPoint( point, index ) {\\n\\n\\t\\t\\t\\t\\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\\n\\n\\t\\t\\t\\t\\tif ( rayPointDistanceSq < localThresholdSq ) {\\n\\n\\t\\t\\t\\t\\t\\tvar intersectPoint = ray.closestPointToPoint( point );\\n\\t\\t\\t\\t\\t\\tintersectPoint.applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\t\\t\\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\\n\\n\\t\\t\\t\\t\\t\\tif ( distance < raycaster.near || distance > raycaster.far ) return;\\n\\n\\t\\t\\t\\t\\t\\tintersects.push( {\\n\\n\\t\\t\\t\\t\\t\\t\\tdistance: distance,\\n\\t\\t\\t\\t\\t\\t\\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\\n\\t\\t\\t\\t\\t\\t\\tpoint: intersectPoint.clone(),\\n\\t\\t\\t\\t\\t\\t\\tindex: index,\\n\\t\\t\\t\\t\\t\\t\\tface: null,\\n\\t\\t\\t\\t\\t\\t\\tobject: object\\n\\n\\t\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\t\\tvar index = geometry.index;\\n\\t\\t\\t\\t\\tvar attributes = geometry.attributes;\\n\\t\\t\\t\\t\\tvar positions = attributes.position.array;\\n\\n\\t\\t\\t\\t\\tif ( index !== null ) {\\n\\n\\t\\t\\t\\t\\t\\tvar indices = index.array;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar a = indices[ i ];\\n\\n\\t\\t\\t\\t\\t\\t\\tposition.fromArray( positions, a * 3 );\\n\\n\\t\\t\\t\\t\\t\\t\\ttestPoint( position, a );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tposition.fromArray( positions, i * 3 );\\n\\n\\t\\t\\t\\t\\t\\t\\ttestPoint( position, i );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvar vertices = geometry.vertices;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\ttestPoint( vertices[ i ], i );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t}() ),\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor( this.geometry, this.material ).copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Group() {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Group';\\n\\n\\t}\\n\\n\\tGroup.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Group,\\n\\n\\t\\tisGroup: true\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\\n\\n\\t\\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\\n\\n\\t\\tthis.generateMipmaps = false;\\n\\n\\t\\t// Set needsUpdate when first frame is ready\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tfunction onLoaded() {\\n\\n\\t\\t\\tvideo.removeEventListener( 'loadeddata', onLoaded, false );\\n\\t\\t\\tscope.needsUpdate = true;\\n\\n\\t\\t}\\n\\n\\t\\tvideo.addEventListener( 'loadeddata', onLoaded, false );\\n\\n\\t}\\n\\n\\tVideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {\\n\\n\\t\\tconstructor: VideoTexture,\\n\\n\\t\\tisVideoTexture: true,\\n\\n\\t\\tupdate: function () {\\n\\n\\t\\t\\tvar video = this.image;\\n\\n\\t\\t\\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\\n\\n\\t\\t\\t\\tthis.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\\n\\n\\t\\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\\n\\n\\t\\tthis.image = { width: width, height: height };\\n\\t\\tthis.mipmaps = mipmaps;\\n\\n\\t\\t// no flipping for cube textures\\n\\t\\t// (also flipping doesn't work for compressed textures )\\n\\n\\t\\tthis.flipY = false;\\n\\n\\t\\t// can't generate mipmaps for compressed textures\\n\\t\\t// mips must be embedded in DDS files\\n\\n\\t\\tthis.generateMipmaps = false;\\n\\n\\t}\\n\\n\\tCompressedTexture.prototype = Object.create( Texture.prototype );\\n\\tCompressedTexture.prototype.constructor = CompressedTexture;\\n\\n\\tCompressedTexture.prototype.isCompressedTexture = true;\\n\\n\\t/**\\n\\t * @author Matt DesLauriers / @mattdesl\\n\\t * @author atix / arthursilber.de\\n\\t */\\n\\n\\tfunction DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {\\n\\n\\t\\tformat = format !== undefined ? format : DepthFormat;\\n\\n\\t\\tif ( format !== DepthFormat && format !== DepthStencilFormat ) {\\n\\n\\t\\t\\tthrow new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );\\n\\n\\t\\t}\\n\\n\\t\\tif ( type === undefined && format === DepthFormat ) type = UnsignedShortType;\\n\\t\\tif ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;\\n\\n\\t\\tTexture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\\n\\n\\t\\tthis.image = { width: width, height: height };\\n\\n\\t\\tthis.magFilter = magFilter !== undefined ? magFilter : NearestFilter;\\n\\t\\tthis.minFilter = minFilter !== undefined ? minFilter : NearestFilter;\\n\\n\\t\\tthis.flipY = false;\\n\\t\\tthis.generateMipmaps\\t= false;\\n\\n\\t}\\n\\n\\tDepthTexture.prototype = Object.create( Texture.prototype );\\n\\tDepthTexture.prototype.constructor = DepthTexture;\\n\\tDepthTexture.prototype.isDepthTexture = true;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\tfunction WireframeGeometry( geometry ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'WireframeGeometry';\\n\\n\\t\\t// buffer\\n\\n\\t\\tvar vertices = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar i, j, l, o, ol;\\n\\t\\tvar edge = [ 0, 0 ], edges = {}, e, edge1, edge2;\\n\\t\\tvar key, keys = [ 'a', 'b', 'c' ];\\n\\t\\tvar vertex;\\n\\n\\t\\t// different logic for Geometry and BufferGeometry\\n\\n\\t\\tif ( geometry && geometry.isGeometry ) {\\n\\n\\t\\t\\t// create a data structure that contains all edges without duplicates\\n\\n\\t\\t\\tvar faces = geometry.faces;\\n\\n\\t\\t\\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\tfor ( j = 0; j < 3; j ++ ) {\\n\\n\\t\\t\\t\\t\\tedge1 = face[ keys[ j ] ];\\n\\t\\t\\t\\t\\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\\n\\t\\t\\t\\t\\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\\n\\t\\t\\t\\t\\tedge[ 1 ] = Math.max( edge1, edge2 );\\n\\n\\t\\t\\t\\t\\tkey = edge[ 0 ] + ',' + edge[ 1 ];\\n\\n\\t\\t\\t\\t\\tif ( edges[ key ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// generate vertices\\n\\n\\t\\t\\tfor ( key in edges ) {\\n\\n\\t\\t\\t\\te = edges[ key ];\\n\\n\\t\\t\\t\\tvertex = geometry.vertices[ e.index1 ];\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\tvertex = geometry.vertices[ e.index2 ];\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else if ( geometry && geometry.isBufferGeometry ) {\\n\\n\\t\\t\\tvar position, indices, groups;\\n\\t\\t\\tvar group, start, count;\\n\\t\\t\\tvar index1, index2;\\n\\n\\t\\t\\tvertex = new Vector3();\\n\\n\\t\\t\\tif ( geometry.index !== null ) {\\n\\n\\t\\t\\t\\t// indexed BufferGeometry\\n\\n\\t\\t\\t\\tposition = geometry.attributes.position;\\n\\t\\t\\t\\tindices = geometry.index;\\n\\t\\t\\t\\tgroups = geometry.groups;\\n\\n\\t\\t\\t\\tif ( groups.length === 0 ) {\\n\\n\\t\\t\\t\\t\\tgroups = [ { start: 0, count: indices.count, materialIndex: 0 } ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// create a data structure that contains all eges without duplicates\\n\\n\\t\\t\\t\\tfor ( o = 0, ol = groups.length; o < ol; ++ o ) {\\n\\n\\t\\t\\t\\t\\tgroup = groups[ o ];\\n\\n\\t\\t\\t\\t\\tstart = group.start;\\n\\t\\t\\t\\t\\tcount = group.count;\\n\\n\\t\\t\\t\\t\\tfor ( i = start, l = ( start + count ); i < l; i += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\tfor ( j = 0; j < 3; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tedge1 = indices.getX( i + j );\\n\\t\\t\\t\\t\\t\\t\\tedge2 = indices.getX( i + ( j + 1 ) % 3 );\\n\\t\\t\\t\\t\\t\\t\\tedge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates\\n\\t\\t\\t\\t\\t\\t\\tedge[ 1 ] = Math.max( edge1, edge2 );\\n\\n\\t\\t\\t\\t\\t\\t\\tkey = edge[ 0 ] + ',' + edge[ 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( edges[ key ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// generate vertices\\n\\n\\t\\t\\t\\tfor ( key in edges ) {\\n\\n\\t\\t\\t\\t\\te = edges[ key ];\\n\\n\\t\\t\\t\\t\\tvertex.fromBufferAttribute( position, e.index1 );\\n\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t\\tvertex.fromBufferAttribute( position, e.index2 );\\n\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// non-indexed BufferGeometry\\n\\n\\t\\t\\t\\tposition = geometry.attributes.position;\\n\\n\\t\\t\\t\\tfor ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tfor ( j = 0; j < 3; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t// three edges per triangle, an edge is represented as (index1, index2)\\n\\t\\t\\t\\t\\t\\t// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)\\n\\n\\t\\t\\t\\t\\t\\tindex1 = 3 * i + j;\\n\\t\\t\\t\\t\\t\\tvertex.fromBufferAttribute( position, index1 );\\n\\t\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t\\t\\tindex2 = 3 * i + ( ( j + 1 ) % 3 );\\n\\t\\t\\t\\t\\t\\tvertex.fromBufferAttribute( position, index2 );\\n\\t\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\n\\t}\\n\\n\\tWireframeGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tWireframeGeometry.prototype.constructor = WireframeGeometry;\\n\\n\\t/**\\n\\t * @author zz85 / https://github.com/zz85\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t *\\n\\t * Parametric Surfaces Geometry\\n\\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\\n\\t */\\n\\n\\t// ParametricGeometry\\n\\n\\tfunction ParametricGeometry( func, slices, stacks ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'ParametricGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tfunc: func,\\n\\t\\t\\tslices: slices,\\n\\t\\t\\tstacks: stacks\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tParametricGeometry.prototype = Object.create( Geometry.prototype );\\n\\tParametricGeometry.prototype.constructor = ParametricGeometry;\\n\\n\\t// ParametricBufferGeometry\\n\\n\\tfunction ParametricBufferGeometry( func, slices, stacks ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'ParametricBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tfunc: func,\\n\\t\\t\\tslices: slices,\\n\\t\\t\\tstacks: stacks\\n\\t\\t};\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\tvar EPS = 0.00001;\\n\\n\\t\\tvar normal = new Vector3();\\n\\n\\t\\tvar p0 = new Vector3(), p1 = new Vector3();\\n\\t\\tvar pu = new Vector3(), pv = new Vector3();\\n\\n\\t\\tvar i, j;\\n\\n\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\tvar sliceCount = slices + 1;\\n\\n\\t\\tfor ( i = 0; i <= stacks; i ++ ) {\\n\\n\\t\\t\\tvar v = i / stacks;\\n\\n\\t\\t\\tfor ( j = 0; j <= slices; j ++ ) {\\n\\n\\t\\t\\t\\tvar u = j / slices;\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tp0 = func( u, v, p0 );\\n\\t\\t\\t\\tvertices.push( p0.x, p0.y, p0.z );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\t// approximate tangent vectors via finite differences\\n\\n\\t\\t\\t\\tif ( u - EPS >= 0 ) {\\n\\n\\t\\t\\t\\t\\tp1 = func( u - EPS, v, p1 );\\n\\t\\t\\t\\t\\tpu.subVectors( p0, p1 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tp1 = func( u + EPS, v, p1 );\\n\\t\\t\\t\\t\\tpu.subVectors( p1, p0 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( v - EPS >= 0 ) {\\n\\n\\t\\t\\t\\t\\tp1 = func( u, v - EPS, p1 );\\n\\t\\t\\t\\t\\tpv.subVectors( p0, p1 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tp1 = func( u, v + EPS, p1 );\\n\\t\\t\\t\\t\\tpv.subVectors( p1, p0 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// cross product of tangent vectors returns surface normal\\n\\n\\t\\t\\t\\tnormal.crossVectors( pu, pv ).normalize();\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuvs.push( u, v );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// generate indices\\n\\n\\t\\tfor ( i = 0; i < stacks; i ++ ) {\\n\\n\\t\\t\\tfor ( j = 0; j < slices; j ++ ) {\\n\\n\\t\\t\\t\\tvar a = i * sliceCount + j;\\n\\t\\t\\t\\tvar b = i * sliceCount + j + 1;\\n\\t\\t\\t\\tvar c = ( i + 1 ) * sliceCount + j + 1;\\n\\t\\t\\t\\tvar d = ( i + 1 ) * sliceCount + j;\\n\\n\\t\\t\\t\\t// faces one and two\\n\\n\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t}\\n\\n\\tParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;\\n\\n\\t/**\\n\\t * @author clockworkgeek / https://github.com/clockworkgeek\\n\\t * @author timothypratley / https://github.com/timothypratley\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// PolyhedronGeometry\\n\\n\\tfunction PolyhedronGeometry( vertices, indices, radius, detail ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'PolyhedronGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tvertices: vertices,\\n\\t\\t\\tindices: indices,\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tPolyhedronGeometry.prototype = Object.create( Geometry.prototype );\\n\\tPolyhedronGeometry.prototype.constructor = PolyhedronGeometry;\\n\\n\\t// PolyhedronBufferGeometry\\n\\n\\tfunction PolyhedronBufferGeometry( vertices, indices, radius, detail ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'PolyhedronBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tvertices: vertices,\\n\\t\\t\\tindices: indices,\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t\\tradius = radius || 1;\\n\\t\\tdetail = detail || 0;\\n\\n\\t\\t// default buffer data\\n\\n\\t\\tvar vertexBuffer = [];\\n\\t\\tvar uvBuffer = [];\\n\\n\\t\\t// the subdivision creates the vertex buffer data\\n\\n\\t\\tsubdivide( detail );\\n\\n\\t\\t// all vertices should lie on a conceptual sphere with a given radius\\n\\n\\t\\tappplyRadius( radius );\\n\\n\\t\\t// finally, create the uv data\\n\\n\\t\\tgenerateUVs();\\n\\n\\t\\t// build non-indexed geometry\\n\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );\\n\\n\\t\\tif ( detail === 0 ) {\\n\\n\\t\\t\\tthis.computeVertexNormals(); // flat normals\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tthis.normalizeNormals(); // smooth normals\\n\\n\\t\\t}\\n\\n\\t\\t// helper functions\\n\\n\\t\\tfunction subdivide( detail ) {\\n\\n\\t\\t\\tvar a = new Vector3();\\n\\t\\t\\tvar b = new Vector3();\\n\\t\\t\\tvar c = new Vector3();\\n\\n\\t\\t\\t// iterate over all faces and apply a subdivison with the given detail value\\n\\n\\t\\t\\tfor ( var i = 0; i < indices.length; i += 3 ) {\\n\\n\\t\\t\\t\\t// get the vertices of the face\\n\\n\\t\\t\\t\\tgetVertexByIndex( indices[ i + 0 ], a );\\n\\t\\t\\t\\tgetVertexByIndex( indices[ i + 1 ], b );\\n\\t\\t\\t\\tgetVertexByIndex( indices[ i + 2 ], c );\\n\\n\\t\\t\\t\\t// perform subdivision\\n\\n\\t\\t\\t\\tsubdivideFace( a, b, c, detail );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction subdivideFace( a, b, c, detail ) {\\n\\n\\t\\t\\tvar cols = Math.pow( 2, detail );\\n\\n\\t\\t\\t// we use this multidimensional array as a data structure for creating the subdivision\\n\\n\\t\\t\\tvar v = [];\\n\\n\\t\\t\\tvar i, j;\\n\\n\\t\\t\\t// construct all of the vertices for this subdivision\\n\\n\\t\\t\\tfor ( i = 0; i <= cols; i ++ ) {\\n\\n\\t\\t\\t\\tv[ i ] = [];\\n\\n\\t\\t\\t\\tvar aj = a.clone().lerp( c, i / cols );\\n\\t\\t\\t\\tvar bj = b.clone().lerp( c, i / cols );\\n\\n\\t\\t\\t\\tvar rows = cols - i;\\n\\n\\t\\t\\t\\tfor ( j = 0; j <= rows; j ++ ) {\\n\\n\\t\\t\\t\\t\\tif ( j === 0 && i === cols ) {\\n\\n\\t\\t\\t\\t\\t\\tv[ i ][ j ] = aj;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tv[ i ][ j ] = aj.clone().lerp( bj, j / rows );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// construct all of the faces\\n\\n\\t\\t\\tfor ( i = 0; i < cols; i ++ ) {\\n\\n\\t\\t\\t\\tfor ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\\n\\n\\t\\t\\t\\t\\tvar k = Math.floor( j / 2 );\\n\\n\\t\\t\\t\\t\\tif ( j % 2 === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i ][ k + 1 ] );\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i + 1 ][ k ] );\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i ][ k ] );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i ][ k + 1 ] );\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i + 1 ][ k + 1 ] );\\n\\t\\t\\t\\t\\t\\tpushVertex( v[ i + 1 ][ k ] );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction appplyRadius( radius ) {\\n\\n\\t\\t\\tvar vertex = new Vector3();\\n\\n\\t\\t\\t// iterate over the entire buffer and apply the radius to each vertex\\n\\n\\t\\t\\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\\n\\n\\t\\t\\t\\tvertex.x = vertexBuffer[ i + 0 ];\\n\\t\\t\\t\\tvertex.y = vertexBuffer[ i + 1 ];\\n\\t\\t\\t\\tvertex.z = vertexBuffer[ i + 2 ];\\n\\n\\t\\t\\t\\tvertex.normalize().multiplyScalar( radius );\\n\\n\\t\\t\\t\\tvertexBuffer[ i + 0 ] = vertex.x;\\n\\t\\t\\t\\tvertexBuffer[ i + 1 ] = vertex.y;\\n\\t\\t\\t\\tvertexBuffer[ i + 2 ] = vertex.z;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction generateUVs() {\\n\\n\\t\\t\\tvar vertex = new Vector3();\\n\\n\\t\\t\\tfor ( var i = 0; i < vertexBuffer.length; i += 3 ) {\\n\\n\\t\\t\\t\\tvertex.x = vertexBuffer[ i + 0 ];\\n\\t\\t\\t\\tvertex.y = vertexBuffer[ i + 1 ];\\n\\t\\t\\t\\tvertex.z = vertexBuffer[ i + 2 ];\\n\\n\\t\\t\\t\\tvar u = azimuth( vertex ) / 2 / Math.PI + 0.5;\\n\\t\\t\\t\\tvar v = inclination( vertex ) / Math.PI + 0.5;\\n\\t\\t\\t\\tuvBuffer.push( u, 1 - v );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tcorrectUVs();\\n\\n\\t\\t\\tcorrectSeam();\\n\\n\\t\\t}\\n\\n\\t\\tfunction correctSeam() {\\n\\n\\t\\t\\t// handle case when face straddles the seam, see #3269\\n\\n\\t\\t\\tfor ( var i = 0; i < uvBuffer.length; i += 6 ) {\\n\\n\\t\\t\\t\\t// uv data of a single face\\n\\n\\t\\t\\t\\tvar x0 = uvBuffer[ i + 0 ];\\n\\t\\t\\t\\tvar x1 = uvBuffer[ i + 2 ];\\n\\t\\t\\t\\tvar x2 = uvBuffer[ i + 4 ];\\n\\n\\t\\t\\t\\tvar max = Math.max( x0, x1, x2 );\\n\\t\\t\\t\\tvar min = Math.min( x0, x1, x2 );\\n\\n\\t\\t\\t\\t// 0.9 is somewhat arbitrary\\n\\n\\t\\t\\t\\tif ( max > 0.9 && min < 0.1 ) {\\n\\n\\t\\t\\t\\t\\tif ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;\\n\\t\\t\\t\\t\\tif ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;\\n\\t\\t\\t\\t\\tif ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction pushVertex( vertex ) {\\n\\n\\t\\t\\tvertexBuffer.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t}\\n\\n\\t\\tfunction getVertexByIndex( index, vertex ) {\\n\\n\\t\\t\\tvar stride = index * 3;\\n\\n\\t\\t\\tvertex.x = vertices[ stride + 0 ];\\n\\t\\t\\tvertex.y = vertices[ stride + 1 ];\\n\\t\\t\\tvertex.z = vertices[ stride + 2 ];\\n\\n\\t\\t}\\n\\n\\t\\tfunction correctUVs() {\\n\\n\\t\\t\\tvar a = new Vector3();\\n\\t\\t\\tvar b = new Vector3();\\n\\t\\t\\tvar c = new Vector3();\\n\\n\\t\\t\\tvar centroid = new Vector3();\\n\\n\\t\\t\\tvar uvA = new Vector2();\\n\\t\\t\\tvar uvB = new Vector2();\\n\\t\\t\\tvar uvC = new Vector2();\\n\\n\\t\\t\\tfor ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {\\n\\n\\t\\t\\t\\ta.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );\\n\\t\\t\\t\\tb.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );\\n\\t\\t\\t\\tc.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );\\n\\n\\t\\t\\t\\tuvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );\\n\\t\\t\\t\\tuvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );\\n\\t\\t\\t\\tuvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );\\n\\n\\t\\t\\t\\tcentroid.copy( a ).add( b ).add( c ).divideScalar( 3 );\\n\\n\\t\\t\\t\\tvar azi = azimuth( centroid );\\n\\n\\t\\t\\t\\tcorrectUV( uvA, j + 0, a, azi );\\n\\t\\t\\t\\tcorrectUV( uvB, j + 2, b, azi );\\n\\t\\t\\t\\tcorrectUV( uvC, j + 4, c, azi );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction correctUV( uv, stride, vector, azimuth ) {\\n\\n\\t\\t\\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {\\n\\n\\t\\t\\t\\tuvBuffer[ stride ] = uv.x - 1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {\\n\\n\\t\\t\\t\\tuvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// Angle around the Y axis, counter-clockwise when looking from above.\\n\\n\\t\\tfunction azimuth( vector ) {\\n\\n\\t\\t\\treturn Math.atan2( vector.z, - vector.x );\\n\\n\\t\\t}\\n\\n\\n\\t\\t// Angle above the XZ plane.\\n\\n\\t\\tfunction inclination( vector ) {\\n\\n\\t\\t\\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tPolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tPolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;\\n\\n\\t/**\\n\\t * @author timothypratley / https://github.com/timothypratley\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// TetrahedronGeometry\\n\\n\\tfunction TetrahedronGeometry( radius, detail ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'TetrahedronGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tTetrahedronGeometry.prototype = Object.create( Geometry.prototype );\\n\\tTetrahedronGeometry.prototype.constructor = TetrahedronGeometry;\\n\\n\\t// TetrahedronBufferGeometry\\n\\n\\tfunction TetrahedronBufferGeometry( radius, detail ) {\\n\\n\\t\\tvar vertices = [\\n\\t\\t\\t1, 1, 1, \\t- 1, - 1, 1, \\t- 1, 1, - 1, \\t1, - 1, - 1\\n\\t\\t];\\n\\n\\t\\tvar indices = [\\n\\t\\t\\t2, 1, 0, \\t0, 3, 2,\\t1, 3, 0,\\t2, 3, 1\\n\\t\\t];\\n\\n\\t\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\n\\n\\t\\tthis.type = 'TetrahedronBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t}\\n\\n\\tTetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\n\\tTetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;\\n\\n\\t/**\\n\\t * @author timothypratley / https://github.com/timothypratley\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// OctahedronGeometry\\n\\n\\tfunction OctahedronGeometry( radius, detail ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'OctahedronGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tOctahedronGeometry.prototype = Object.create( Geometry.prototype );\\n\\tOctahedronGeometry.prototype.constructor = OctahedronGeometry;\\n\\n\\t// OctahedronBufferGeometry\\n\\n\\tfunction OctahedronBufferGeometry( radius, detail ) {\\n\\n\\t\\tvar vertices = [\\n\\t\\t\\t1, 0, 0, \\t- 1, 0, 0,\\t0, 1, 0,\\n\\t\\t\\t0, - 1, 0, \\t0, 0, 1,\\t0, 0, - 1\\n\\t\\t];\\n\\n\\t\\tvar indices = [\\n\\t\\t\\t0, 2, 4,\\t0, 4, 3,\\t0, 3, 5,\\n\\t\\t\\t0, 5, 2,\\t1, 2, 5,\\t1, 5, 3,\\n\\t\\t\\t1, 3, 4,\\t1, 4, 2\\n\\t\\t];\\n\\n\\t\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\n\\n\\t\\tthis.type = 'OctahedronBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t}\\n\\n\\tOctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\n\\tOctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;\\n\\n\\t/**\\n\\t * @author timothypratley / https://github.com/timothypratley\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// IcosahedronGeometry\\n\\n\\tfunction IcosahedronGeometry( radius, detail ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'IcosahedronGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tIcosahedronGeometry.prototype = Object.create( Geometry.prototype );\\n\\tIcosahedronGeometry.prototype.constructor = IcosahedronGeometry;\\n\\n\\t// IcosahedronBufferGeometry\\n\\n\\tfunction IcosahedronBufferGeometry( radius, detail ) {\\n\\n\\t\\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\\n\\n\\t\\tvar vertices = [\\n\\t\\t\\t- 1, t, 0, \\t1, t, 0, \\t- 1, - t, 0, \\t1, - t, 0,\\n\\t\\t\\t 0, - 1, t, \\t0, 1, t,\\t0, - 1, - t, \\t0, 1, - t,\\n\\t\\t\\t t, 0, - 1, \\tt, 0, 1, \\t- t, 0, - 1, \\t- t, 0, 1\\n\\t\\t];\\n\\n\\t\\tvar indices = [\\n\\t\\t\\t 0, 11, 5, \\t0, 5, 1, \\t0, 1, 7, \\t0, 7, 10, \\t0, 10, 11,\\n\\t\\t\\t 1, 5, 9, \\t5, 11, 4,\\t11, 10, 2,\\t10, 7, 6,\\t7, 1, 8,\\n\\t\\t\\t 3, 9, 4, \\t3, 4, 2,\\t3, 2, 6,\\t3, 6, 8,\\t3, 8, 9,\\n\\t\\t\\t 4, 9, 5, \\t2, 4, 11,\\t6, 2, 10,\\t8, 6, 7,\\t9, 8, 1\\n\\t\\t];\\n\\n\\t\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\n\\n\\t\\tthis.type = 'IcosahedronBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t}\\n\\n\\tIcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\n\\tIcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;\\n\\n\\t/**\\n\\t * @author Abe Pazos / https://hamoid.com\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// DodecahedronGeometry\\n\\n\\tfunction DodecahedronGeometry( radius, detail ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'DodecahedronGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tDodecahedronGeometry.prototype = Object.create( Geometry.prototype );\\n\\tDodecahedronGeometry.prototype.constructor = DodecahedronGeometry;\\n\\n\\t// DodecahedronBufferGeometry\\n\\n\\tfunction DodecahedronBufferGeometry( radius, detail ) {\\n\\n\\t\\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\\n\\t\\tvar r = 1 / t;\\n\\n\\t\\tvar vertices = [\\n\\n\\t\\t\\t// (1, 1, 1)\\n\\t\\t\\t- 1, - 1, - 1,\\t- 1, - 1, 1,\\n\\t\\t\\t- 1, 1, - 1, - 1, 1, 1,\\n\\t\\t\\t1, - 1, - 1, 1, - 1, 1,\\n\\t\\t\\t1, 1, - 1, 1, 1, 1,\\n\\n\\t\\t\\t// (0, 1/, )\\n\\t\\t\\t 0, - r, - t, 0, - r, t,\\n\\t\\t\\t 0, r, - t, 0, r, t,\\n\\n\\t\\t\\t// (1/, , 0)\\n\\t\\t\\t- r, - t, 0, - r, t, 0,\\n\\t\\t\\t r, - t, 0, r, t, 0,\\n\\n\\t\\t\\t// (, 0, 1/)\\n\\t\\t\\t- t, 0, - r, t, 0, - r,\\n\\t\\t\\t- t, 0, r, t, 0, r\\n\\t\\t];\\n\\n\\t\\tvar indices = [\\n\\t\\t\\t3, 11, 7, \\t3, 7, 15, \\t3, 15, 13,\\n\\t\\t\\t7, 19, 17, \\t7, 17, 6, \\t7, 6, 15,\\n\\t\\t\\t17, 4, 8, \\t17, 8, 10, \\t17, 10, 6,\\n\\t\\t\\t8, 0, 16, \\t8, 16, 2, \\t8, 2, 10,\\n\\t\\t\\t0, 12, 1, \\t0, 1, 18, \\t0, 18, 16,\\n\\t\\t\\t6, 10, 2, \\t6, 2, 13, \\t6, 13, 15,\\n\\t\\t\\t2, 16, 18, \\t2, 18, 3, \\t2, 3, 13,\\n\\t\\t\\t18, 1, 9, \\t18, 9, 11, \\t18, 11, 3,\\n\\t\\t\\t4, 14, 12, \\t4, 12, 0, \\t4, 0, 8,\\n\\t\\t\\t11, 9, 5, \\t11, 5, 19, \\t11, 19, 7,\\n\\t\\t\\t19, 5, 14, \\t19, 14, 4, \\t19, 4, 17,\\n\\t\\t\\t1, 12, 14, \\t1, 14, 5, \\t1, 5, 9\\n\\t\\t];\\n\\n\\t\\tPolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );\\n\\n\\t\\tthis.type = 'DodecahedronBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tdetail: detail\\n\\t\\t};\\n\\n\\t}\\n\\n\\tDodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );\\n\\tDodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;\\n\\n\\t/**\\n\\t * @author oosmoxiecode / https://github.com/oosmoxiecode\\n\\t * @author WestLangley / https://github.com/WestLangley\\n\\t * @author zz85 / https://github.com/zz85\\n\\t * @author miningold / https://github.com/miningold\\n\\t * @author jonobr1 / https://github.com/jonobr1\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t *\\n\\t */\\n\\n\\t// TubeGeometry\\n\\n\\tfunction TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'TubeGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tpath: path,\\n\\t\\t\\ttubularSegments: tubularSegments,\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\tclosed: closed\\n\\t\\t};\\n\\n\\t\\tif ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );\\n\\n\\t\\tvar bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );\\n\\n\\t\\t// expose internals\\n\\n\\t\\tthis.tangents = bufferGeometry.tangents;\\n\\t\\tthis.normals = bufferGeometry.normals;\\n\\t\\tthis.binormals = bufferGeometry.binormals;\\n\\n\\t\\t// create geometry\\n\\n\\t\\tthis.fromBufferGeometry( bufferGeometry );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tTubeGeometry.prototype = Object.create( Geometry.prototype );\\n\\tTubeGeometry.prototype.constructor = TubeGeometry;\\n\\n\\t// TubeBufferGeometry\\n\\n\\tfunction TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'TubeBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tpath: path,\\n\\t\\t\\ttubularSegments: tubularSegments,\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\tclosed: closed\\n\\t\\t};\\n\\n\\t\\ttubularSegments = tubularSegments || 64;\\n\\t\\tradius = radius || 1;\\n\\t\\tradialSegments = radialSegments || 8;\\n\\t\\tclosed = closed || false;\\n\\n\\t\\tvar frames = path.computeFrenetFrames( tubularSegments, closed );\\n\\n\\t\\t// expose internals\\n\\n\\t\\tthis.tangents = frames.tangents;\\n\\t\\tthis.normals = frames.normals;\\n\\t\\tthis.binormals = frames.binormals;\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar normal = new Vector3();\\n\\t\\tvar uv = new Vector2();\\n\\t\\tvar P = new Vector3();\\n\\n\\t\\tvar i, j;\\n\\n\\t\\t// buffer\\n\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\t\\tvar indices = [];\\n\\n\\t\\t// create buffer data\\n\\n\\t\\tgenerateBufferData();\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t\\t// functions\\n\\n\\t\\tfunction generateBufferData() {\\n\\n\\t\\t\\tfor ( i = 0; i < tubularSegments; i ++ ) {\\n\\n\\t\\t\\t\\tgenerateSegment( i );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// if the geometry is not closed, generate the last row of vertices and normals\\n\\t\\t\\t// at the regular position on the given path\\n\\t\\t\\t//\\n\\t\\t\\t// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\\n\\n\\t\\t\\tgenerateSegment( ( closed === false ) ? tubularSegments : 0 );\\n\\n\\t\\t\\t// uvs are generated in a separate function.\\n\\t\\t\\t// this makes it easy compute correct values for closed geometries\\n\\n\\t\\t\\tgenerateUVs();\\n\\n\\t\\t\\t// finally create faces\\n\\n\\t\\t\\tgenerateIndices();\\n\\n\\t\\t}\\n\\n\\t\\tfunction generateSegment( i ) {\\n\\n\\t\\t\\t// we use getPointAt to sample evenly distributed points from the given path\\n\\n\\t\\t\\tP = path.getPointAt( i / tubularSegments, P );\\n\\n\\t\\t\\t// retrieve corresponding normal and binormal\\n\\n\\t\\t\\tvar N = frames.normals[ i ];\\n\\t\\t\\tvar B = frames.binormals[ i ];\\n\\n\\t\\t\\t// generate normals and vertices for the current segment\\n\\n\\t\\t\\tfor ( j = 0; j <= radialSegments; j ++ ) {\\n\\n\\t\\t\\t\\tvar v = j / radialSegments * Math.PI * 2;\\n\\n\\t\\t\\t\\tvar sin = Math.sin( v );\\n\\t\\t\\t\\tvar cos = - Math.cos( v );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\tnormal.x = ( cos * N.x + sin * B.x );\\n\\t\\t\\t\\tnormal.y = ( cos * N.y + sin * B.y );\\n\\t\\t\\t\\tnormal.z = ( cos * N.z + sin * B.z );\\n\\t\\t\\t\\tnormal.normalize();\\n\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertex.x = P.x + radius * normal.x;\\n\\t\\t\\t\\tvertex.y = P.y + radius * normal.y;\\n\\t\\t\\t\\tvertex.z = P.z + radius * normal.z;\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction generateIndices() {\\n\\n\\t\\t\\tfor ( j = 1; j <= tubularSegments; j ++ ) {\\n\\n\\t\\t\\t\\tfor ( i = 1; i <= radialSegments; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\\n\\t\\t\\t\\t\\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\\n\\t\\t\\t\\t\\tvar c = ( radialSegments + 1 ) * j + i;\\n\\t\\t\\t\\t\\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\\n\\n\\t\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction generateUVs() {\\n\\n\\t\\t\\tfor ( i = 0; i <= tubularSegments; i ++ ) {\\n\\n\\t\\t\\t\\tfor ( j = 0; j <= radialSegments; j ++ ) {\\n\\n\\t\\t\\t\\t\\tuv.x = i / tubularSegments;\\n\\t\\t\\t\\t\\tuv.y = j / radialSegments;\\n\\n\\t\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tTubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tTubeBufferGeometry.prototype.constructor = TubeBufferGeometry;\\n\\n\\t/**\\n\\t * @author oosmoxiecode\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t *\\n\\t * based on http://www.blackpawn.com/texts/pqtorus/\\n\\t */\\n\\n\\t// TorusKnotGeometry\\n\\n\\tfunction TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'TorusKnotGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\ttube: tube,\\n\\t\\t\\ttubularSegments: tubularSegments,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\tp: p,\\n\\t\\t\\tq: q\\n\\t\\t};\\n\\n\\t\\tif ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\\n\\n\\t\\tthis.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tTorusKnotGeometry.prototype = Object.create( Geometry.prototype );\\n\\tTorusKnotGeometry.prototype.constructor = TorusKnotGeometry;\\n\\n\\t// TorusKnotBufferGeometry\\n\\n\\tfunction TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'TorusKnotBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\ttube: tube,\\n\\t\\t\\ttubularSegments: tubularSegments,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\tp: p,\\n\\t\\t\\tq: q\\n\\t\\t};\\n\\n\\t\\tradius = radius || 1;\\n\\t\\ttube = tube || 0.4;\\n\\t\\ttubularSegments = Math.floor( tubularSegments ) || 64;\\n\\t\\tradialSegments = Math.floor( radialSegments ) || 8;\\n\\t\\tp = p || 2;\\n\\t\\tq = q || 3;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar i, j;\\n\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar normal = new Vector3();\\n\\n\\t\\tvar P1 = new Vector3();\\n\\t\\tvar P2 = new Vector3();\\n\\n\\t\\tvar B = new Vector3();\\n\\t\\tvar T = new Vector3();\\n\\t\\tvar N = new Vector3();\\n\\n\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\tfor ( i = 0; i <= tubularSegments; ++ i ) {\\n\\n\\t\\t\\t// the radian \\\"u\\\" is used to calculate the position on the torus curve of the current tubular segement\\n\\n\\t\\t\\tvar u = i / tubularSegments * p * Math.PI * 2;\\n\\n\\t\\t\\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\\n\\t\\t\\t// these points are used to create a special \\\"coordinate space\\\", which is necessary to calculate the correct vertex positions\\n\\n\\t\\t\\tcalculatePositionOnCurve( u, p, q, radius, P1 );\\n\\t\\t\\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\\n\\n\\t\\t\\t// calculate orthonormal basis\\n\\n\\t\\t\\tT.subVectors( P2, P1 );\\n\\t\\t\\tN.addVectors( P2, P1 );\\n\\t\\t\\tB.crossVectors( T, N );\\n\\t\\t\\tN.crossVectors( B, T );\\n\\n\\t\\t\\t// normalize B, N. T can be ignored, we don't use it\\n\\n\\t\\t\\tB.normalize();\\n\\t\\t\\tN.normalize();\\n\\n\\t\\t\\tfor ( j = 0; j <= radialSegments; ++ j ) {\\n\\n\\t\\t\\t\\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\\n\\t\\t\\t\\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\\n\\n\\t\\t\\t\\tvar v = j / radialSegments * Math.PI * 2;\\n\\t\\t\\t\\tvar cx = - tube * Math.cos( v );\\n\\t\\t\\t\\tvar cy = tube * Math.sin( v );\\n\\n\\t\\t\\t\\t// now calculate the final vertex position.\\n\\t\\t\\t\\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\\n\\n\\t\\t\\t\\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\\n\\t\\t\\t\\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\\n\\t\\t\\t\\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\\n\\n\\t\\t\\t\\tnormal.subVectors( vertex, P1 ).normalize();\\n\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuvs.push( i / tubularSegments );\\n\\t\\t\\t\\tuvs.push( j / radialSegments );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// generate indices\\n\\n\\t\\tfor ( j = 1; j <= tubularSegments; j ++ ) {\\n\\n\\t\\t\\tfor ( i = 1; i <= radialSegments; i ++ ) {\\n\\n\\t\\t\\t\\t// indices\\n\\n\\t\\t\\t\\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\\n\\t\\t\\t\\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\\n\\t\\t\\t\\tvar c = ( radialSegments + 1 ) * j + i;\\n\\t\\t\\t\\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\\n\\n\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t\\t// this function calculates the current position on the torus curve\\n\\n\\t\\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\\n\\n\\t\\t\\tvar cu = Math.cos( u );\\n\\t\\t\\tvar su = Math.sin( u );\\n\\t\\t\\tvar quOverP = q / p * u;\\n\\t\\t\\tvar cs = Math.cos( quOverP );\\n\\n\\t\\t\\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\\n\\t\\t\\tposition.y = radius * ( 2 + cs ) * su * 0.5;\\n\\t\\t\\tposition.z = radius * Math.sin( quOverP ) * 0.5;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tTorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tTorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;\\n\\n\\t/**\\n\\t * @author oosmoxiecode\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// TorusGeometry\\n\\n\\tfunction TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'TorusGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\ttube: tube,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\ttubularSegments: tubularSegments,\\n\\t\\t\\tarc: arc\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tTorusGeometry.prototype = Object.create( Geometry.prototype );\\n\\tTorusGeometry.prototype.constructor = TorusGeometry;\\n\\n\\t// TorusBufferGeometry\\n\\n\\tfunction TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'TorusBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\ttube: tube,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\ttubularSegments: tubularSegments,\\n\\t\\t\\tarc: arc\\n\\t\\t};\\n\\n\\t\\tradius = radius || 1;\\n\\t\\ttube = tube || 0.4;\\n\\t\\tradialSegments = Math.floor( radialSegments ) || 8;\\n\\t\\ttubularSegments = Math.floor( tubularSegments ) || 6;\\n\\t\\tarc = arc || Math.PI * 2;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar center = new Vector3();\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar normal = new Vector3();\\n\\n\\t\\tvar j, i;\\n\\n\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\tfor ( j = 0; j <= radialSegments; j ++ ) {\\n\\n\\t\\t\\tfor ( i = 0; i <= tubularSegments; i ++ ) {\\n\\n\\t\\t\\t\\tvar u = i / tubularSegments * arc;\\n\\t\\t\\t\\tvar v = j / radialSegments * Math.PI * 2;\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\\n\\t\\t\\t\\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\\n\\t\\t\\t\\tvertex.z = tube * Math.sin( v );\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\tcenter.x = radius * Math.cos( u );\\n\\t\\t\\t\\tcenter.y = radius * Math.sin( u );\\n\\t\\t\\t\\tnormal.subVectors( vertex, center ).normalize();\\n\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuvs.push( i / tubularSegments );\\n\\t\\t\\t\\tuvs.push( j / radialSegments );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// generate indices\\n\\n\\t\\tfor ( j = 1; j <= radialSegments; j ++ ) {\\n\\n\\t\\t\\tfor ( i = 1; i <= tubularSegments; i ++ ) {\\n\\n\\t\\t\\t\\t// indices\\n\\n\\t\\t\\t\\tvar a = ( tubularSegments + 1 ) * j + i - 1;\\n\\t\\t\\t\\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\\n\\t\\t\\t\\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\\n\\t\\t\\t\\tvar d = ( tubularSegments + 1 ) * j + i;\\n\\n\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t}\\n\\n\\tTorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tTorusBufferGeometry.prototype.constructor = TorusBufferGeometry;\\n\\n\\t/**\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t * Port from https://github.com/mapbox/earcut (v2.1.2)\\n\\t */\\n\\n\\tvar Earcut = {\\n\\n\\t\\ttriangulate: function ( data, holeIndices, dim ) {\\n\\n\\t\\t\\tdim = dim || 2;\\n\\n\\t\\t\\tvar hasHoles = holeIndices && holeIndices.length,\\n\\t\\t\\t\\touterLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,\\n\\t\\t\\t\\touterNode = linkedList( data, 0, outerLen, dim, true ),\\n\\t\\t\\t\\ttriangles = [];\\n\\n\\t\\t\\tif ( ! outerNode ) return triangles;\\n\\n\\t\\t\\tvar minX, minY, maxX, maxY, x, y, invSize;\\n\\n\\t\\t\\tif ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );\\n\\n\\t\\t\\t// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\\n\\n\\t\\t\\tif ( data.length > 80 * dim ) {\\n\\n\\t\\t\\t\\tminX = maxX = data[ 0 ];\\n\\t\\t\\t\\tminY = maxY = data[ 1 ];\\n\\n\\t\\t\\t\\tfor ( var i = dim; i < outerLen; i += dim ) {\\n\\n\\t\\t\\t\\t\\tx = data[ i ];\\n\\t\\t\\t\\t\\ty = data[ i + 1 ];\\n\\t\\t\\t\\t\\tif ( x < minX ) minX = x;\\n\\t\\t\\t\\t\\tif ( y < minY ) minY = y;\\n\\t\\t\\t\\t\\tif ( x > maxX ) maxX = x;\\n\\t\\t\\t\\t\\tif ( y > maxY ) maxY = y;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// minX, minY and invSize are later used to transform coords into integers for z-order calculation\\n\\n\\t\\t\\t\\tinvSize = Math.max( maxX - minX, maxY - minY );\\n\\t\\t\\t\\tinvSize = invSize !== 0 ? 1 / invSize : 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tearcutLinked( outerNode, triangles, dim, minX, minY, invSize );\\n\\n\\t\\t\\treturn triangles;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t// create a circular doubly linked list from polygon points in the specified winding order\\n\\n\\tfunction linkedList( data, start, end, dim, clockwise ) {\\n\\n\\t\\tvar i, last;\\n\\n\\t\\tif ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {\\n\\n\\t\\t\\tfor ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tfor ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );\\n\\n\\t\\t}\\n\\n\\t\\tif ( last && equals( last, last.next ) ) {\\n\\n\\t\\t\\tremoveNode( last );\\n\\t\\t\\tlast = last.next;\\n\\n\\t\\t}\\n\\n\\t\\treturn last;\\n\\n\\t}\\n\\n\\t// eliminate colinear or duplicate points\\n\\n\\tfunction filterPoints( start, end ) {\\n\\n\\t\\tif ( ! start ) return start;\\n\\t\\tif ( ! end ) end = start;\\n\\n\\t\\tvar p = start, again;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tagain = false;\\n\\n\\t\\t\\tif ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {\\n\\n\\t\\t\\t\\tremoveNode( p );\\n\\t\\t\\t\\tp = end = p.prev;\\n\\t\\t\\t\\tif ( p === p.next ) break;\\n\\t\\t\\t\\tagain = true;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tp = p.next;\\n\\n\\t\\t\\t}\\n\\n\\t\\t} while ( again || p !== end );\\n\\n\\t\\treturn end;\\n\\n\\t}\\n\\n\\t// main ear slicing loop which triangulates a polygon (given as a linked list)\\n\\n\\tfunction earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {\\n\\n\\t\\tif ( ! ear ) return;\\n\\n\\t\\t// interlink polygon nodes in z-order\\n\\n\\t\\tif ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );\\n\\n\\t\\tvar stop = ear, prev, next;\\n\\n\\t\\t// iterate through ears, slicing them one by one\\n\\n\\t\\twhile ( ear.prev !== ear.next ) {\\n\\n\\t\\t\\tprev = ear.prev;\\n\\t\\t\\tnext = ear.next;\\n\\n\\t\\t\\tif ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {\\n\\n\\t\\t\\t\\t// cut off the triangle\\n\\t\\t\\t\\ttriangles.push( prev.i / dim );\\n\\t\\t\\t\\ttriangles.push( ear.i / dim );\\n\\t\\t\\t\\ttriangles.push( next.i / dim );\\n\\n\\t\\t\\t\\tremoveNode( ear );\\n\\n\\t\\t\\t\\t// skipping the next vertice leads to less sliver triangles\\n\\t\\t\\t\\tear = next.next;\\n\\t\\t\\t\\tstop = next.next;\\n\\n\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tear = next;\\n\\n\\t\\t\\t// if we looped through the whole remaining polygon and can't find any more ears\\n\\n\\t\\t\\tif ( ear === stop ) {\\n\\n\\t\\t\\t\\t// try filtering points and slicing again\\n\\n\\t\\t\\t\\tif ( ! pass ) {\\n\\n\\t\\t\\t\\t\\tearcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );\\n\\n\\t\\t\\t\\t\\t// if this didn't work, try curing all small self-intersections locally\\n\\n\\t\\t\\t\\t} else if ( pass === 1 ) {\\n\\n\\t\\t\\t\\t\\tear = cureLocalIntersections( ear, triangles, dim );\\n\\t\\t\\t\\t\\tearcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );\\n\\n\\t\\t\\t\\t// as a last resort, try splitting the remaining polygon into two\\n\\n\\t\\t\\t\\t} else if ( pass === 2 ) {\\n\\n\\t\\t\\t\\t\\tsplitEarcut( ear, triangles, dim, minX, minY, invSize );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// check whether a polygon node forms a valid ear with adjacent nodes\\n\\n\\tfunction isEar( ear ) {\\n\\n\\t\\tvar a = ear.prev,\\n\\t\\t\\tb = ear,\\n\\t\\t\\tc = ear.next;\\n\\n\\t\\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\\n\\n\\t\\t// now make sure we don't have other points inside the potential ear\\n\\t\\tvar p = ear.next.next;\\n\\n\\t\\twhile ( p !== ear.prev ) {\\n\\n\\t\\t\\tif ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) {\\n\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\n\\t}\\n\\n\\tfunction isEarHashed( ear, minX, minY, invSize ) {\\n\\n\\t\\tvar a = ear.prev,\\n\\t\\t\\tb = ear,\\n\\t\\t\\tc = ear.next;\\n\\n\\t\\tif ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear\\n\\n\\t\\t// triangle bbox; min & max are calculated like this for speed\\n\\n\\t\\tvar minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),\\n\\t\\t\\tminTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),\\n\\t\\t\\tmaxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),\\n\\t\\t\\tmaxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );\\n\\n\\t\\t// z-order range for the current triangle bbox;\\n\\n\\t\\tvar minZ = zOrder( minTX, minTY, minX, minY, invSize ),\\n\\t\\t\\tmaxZ = zOrder( maxTX, maxTY, minX, minY, invSize );\\n\\n\\t\\t// first look for points inside the triangle in increasing z-order\\n\\n\\t\\tvar p = ear.nextZ;\\n\\n\\t\\twhile ( p && p.z <= maxZ ) {\\n\\n\\t\\t\\tif ( p !== ear.prev && p !== ear.next &&\\n\\t\\t\\t\\t\\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\\n\\t\\t\\t\\t\\tarea( p.prev, p, p.next ) >= 0 ) return false;\\n\\t\\t\\tp = p.nextZ;\\n\\n\\t\\t}\\n\\n\\t\\t// then look for points in decreasing z-order\\n\\n\\t\\tp = ear.prevZ;\\n\\n\\t\\twhile ( p && p.z >= minZ ) {\\n\\n\\t\\t\\tif ( p !== ear.prev && p !== ear.next &&\\n\\t\\t\\t\\t\\tpointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&\\n\\t\\t\\t\\t\\tarea( p.prev, p, p.next ) >= 0 ) return false;\\n\\n\\t\\t\\tp = p.prevZ;\\n\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\n\\t}\\n\\n\\t// go through all polygon nodes and cure small local self-intersections\\n\\n\\tfunction cureLocalIntersections( start, triangles, dim ) {\\n\\n\\t\\tvar p = start;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tvar a = p.prev, b = p.next.next;\\n\\n\\t\\t\\tif ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {\\n\\n\\t\\t\\t\\ttriangles.push( a.i / dim );\\n\\t\\t\\t\\ttriangles.push( p.i / dim );\\n\\t\\t\\t\\ttriangles.push( b.i / dim );\\n\\n\\t\\t\\t\\t// remove two nodes involved\\n\\n\\t\\t\\t\\tremoveNode( p );\\n\\t\\t\\t\\tremoveNode( p.next );\\n\\n\\t\\t\\t\\tp = start = b;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t} while ( p !== start );\\n\\n\\t\\treturn p;\\n\\n\\t}\\n\\n\\t// try splitting polygon into two and triangulate them independently\\n\\n\\tfunction splitEarcut( start, triangles, dim, minX, minY, invSize ) {\\n\\n\\t\\t// look for a valid diagonal that divides the polygon into two\\n\\n\\t\\tvar a = start;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tvar b = a.next.next;\\n\\n\\t\\t\\twhile ( b !== a.prev ) {\\n\\n\\t\\t\\t\\tif ( a.i !== b.i && isValidDiagonal( a, b ) ) {\\n\\n\\t\\t\\t\\t\\t// split the polygon in two by the diagonal\\n\\n\\t\\t\\t\\t\\tvar c = splitPolygon( a, b );\\n\\n\\t\\t\\t\\t\\t// filter colinear points around the cuts\\n\\n\\t\\t\\t\\t\\ta = filterPoints( a, a.next );\\n\\t\\t\\t\\t\\tc = filterPoints( c, c.next );\\n\\n\\t\\t\\t\\t\\t// run earcut on each half\\n\\n\\t\\t\\t\\t\\tearcutLinked( a, triangles, dim, minX, minY, invSize );\\n\\t\\t\\t\\t\\tearcutLinked( c, triangles, dim, minX, minY, invSize );\\n\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tb = b.next;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\ta = a.next;\\n\\n\\t\\t} while ( a !== start );\\n\\n\\t}\\n\\n\\t// link every hole into the outer loop, producing a single-ring polygon without holes\\n\\n\\tfunction eliminateHoles( data, holeIndices, outerNode, dim ) {\\n\\n\\t\\tvar queue = [], i, len, start, end, list;\\n\\n\\t\\tfor ( i = 0, len = holeIndices.length; i < len; i ++ ) {\\n\\n\\t\\t\\tstart = holeIndices[ i ] * dim;\\n\\t\\t\\tend = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;\\n\\t\\t\\tlist = linkedList( data, start, end, dim, false );\\n\\t\\t\\tif ( list === list.next ) list.steiner = true;\\n\\t\\t\\tqueue.push( getLeftmost( list ) );\\n\\n\\t\\t}\\n\\n\\t\\tqueue.sort( compareX );\\n\\n\\t\\t// process holes from left to right\\n\\n\\t\\tfor ( i = 0; i < queue.length; i ++ ) {\\n\\n\\t\\t\\teliminateHole( queue[ i ], outerNode );\\n\\t\\t\\touterNode = filterPoints( outerNode, outerNode.next );\\n\\n\\t\\t}\\n\\n\\t\\treturn outerNode;\\n\\n\\t}\\n\\n\\tfunction compareX( a, b ) {\\n\\n\\t\\treturn a.x - b.x;\\n\\n\\t}\\n\\n\\t// find a bridge between vertices that connects hole with an outer ring and and link it\\n\\n\\tfunction eliminateHole( hole, outerNode ) {\\n\\n\\t\\touterNode = findHoleBridge( hole, outerNode );\\n\\n\\t\\tif ( outerNode ) {\\n\\n\\t\\t\\tvar b = splitPolygon( outerNode, hole );\\n\\n\\t\\t\\tfilterPoints( b, b.next );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// David Eberly's algorithm for finding a bridge between hole and outer polygon\\n\\n\\tfunction findHoleBridge( hole, outerNode ) {\\n\\n\\t\\tvar p = outerNode,\\n\\t\\t\\thx = hole.x,\\n\\t\\t\\thy = hole.y,\\n\\t\\t\\tqx = - Infinity,\\n\\t\\t\\tm;\\n\\n\\t\\t// find a segment intersected by a ray from the hole's leftmost point to the left;\\n\\t\\t// segment's endpoint with lesser x will be potential connection point\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tif ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {\\n\\n\\t\\t\\t\\tvar x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );\\n\\n\\t\\t\\t\\tif ( x <= hx && x > qx ) {\\n\\n\\t\\t\\t\\t\\tqx = x;\\n\\n\\t\\t\\t\\t\\tif ( x === hx ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( hy === p.y ) return p;\\n\\t\\t\\t\\t\\t\\tif ( hy === p.next.y ) return p.next;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tm = p.x < p.next.x ? p : p.next;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t} while ( p !== outerNode );\\n\\n\\t\\tif ( ! m ) return null;\\n\\n\\t\\tif ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint\\n\\n\\t\\t// look for points inside the triangle of hole point, segment intersection and endpoint;\\n\\t\\t// if there are no points found, we have a valid connection;\\n\\t\\t// otherwise choose the point of the minimum angle with the ray as connection point\\n\\n\\t\\tvar stop = m,\\n\\t\\t\\tmx = m.x,\\n\\t\\t\\tmy = m.y,\\n\\t\\t\\ttanMin = Infinity,\\n\\t\\t\\ttan;\\n\\n\\t\\tp = m.next;\\n\\n\\t\\twhile ( p !== stop ) {\\n\\n\\t\\t\\tif ( hx >= p.x && p.x >= mx && hx !== p.x &&\\n\\t\\t\\t\\t\\t\\t\\tpointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {\\n\\n\\t\\t\\t\\ttan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential\\n\\n\\t\\t\\t\\tif ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {\\n\\n\\t\\t\\t\\t\\tm = p;\\n\\t\\t\\t\\t\\ttanMin = tan;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t}\\n\\n\\t\\treturn m;\\n\\n\\t}\\n\\n\\t// interlink polygon nodes in z-order\\n\\n\\tfunction indexCurve( start, minX, minY, invSize ) {\\n\\n\\t\\tvar p = start;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tif ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );\\n\\t\\t\\tp.prevZ = p.prev;\\n\\t\\t\\tp.nextZ = p.next;\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t} while ( p !== start );\\n\\n\\t\\tp.prevZ.nextZ = null;\\n\\t\\tp.prevZ = null;\\n\\n\\t\\tsortLinked( p );\\n\\n\\t}\\n\\n\\t// Simon Tatham's linked list merge sort algorithm\\n\\t// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\\n\\n\\tfunction sortLinked( list ) {\\n\\n\\t\\tvar i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tp = list;\\n\\t\\t\\tlist = null;\\n\\t\\t\\ttail = null;\\n\\t\\t\\tnumMerges = 0;\\n\\n\\t\\t\\twhile ( p ) {\\n\\n\\t\\t\\t\\tnumMerges ++;\\n\\t\\t\\t\\tq = p;\\n\\t\\t\\t\\tpSize = 0;\\n\\n\\t\\t\\t\\tfor ( i = 0; i < inSize; i ++ ) {\\n\\n\\t\\t\\t\\t\\tpSize ++;\\n\\t\\t\\t\\t\\tq = q.nextZ;\\n\\t\\t\\t\\t\\tif ( ! q ) break;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tqSize = inSize;\\n\\n\\t\\t\\t\\twhile ( pSize > 0 || ( qSize > 0 && q ) ) {\\n\\n\\t\\t\\t\\t\\tif ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {\\n\\n\\t\\t\\t\\t\\t\\te = p;\\n\\t\\t\\t\\t\\t\\tp = p.nextZ;\\n\\t\\t\\t\\t\\t\\tpSize --;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\te = q;\\n\\t\\t\\t\\t\\t\\tq = q.nextZ;\\n\\t\\t\\t\\t\\t\\tqSize --;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( tail ) tail.nextZ = e;\\n\\t\\t\\t\\t\\telse list = e;\\n\\n\\t\\t\\t\\t\\te.prevZ = tail;\\n\\t\\t\\t\\t\\ttail = e;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tp = q;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\ttail.nextZ = null;\\n\\t\\t\\tinSize *= 2;\\n\\n\\t\\t} while ( numMerges > 1 );\\n\\n\\t\\treturn list;\\n\\n\\t}\\n\\n\\t// z-order of a point given coords and inverse of the longer side of data bbox\\n\\n\\tfunction zOrder( x, y, minX, minY, invSize ) {\\n\\n\\t\\t// coords are transformed into non-negative 15-bit integer range\\n\\n\\t\\tx = 32767 * ( x - minX ) * invSize;\\n\\t\\ty = 32767 * ( y - minY ) * invSize;\\n\\n\\t\\tx = ( x | ( x << 8 ) ) & 0x00FF00FF;\\n\\t\\tx = ( x | ( x << 4 ) ) & 0x0F0F0F0F;\\n\\t\\tx = ( x | ( x << 2 ) ) & 0x33333333;\\n\\t\\tx = ( x | ( x << 1 ) ) & 0x55555555;\\n\\n\\t\\ty = ( y | ( y << 8 ) ) & 0x00FF00FF;\\n\\t\\ty = ( y | ( y << 4 ) ) & 0x0F0F0F0F;\\n\\t\\ty = ( y | ( y << 2 ) ) & 0x33333333;\\n\\t\\ty = ( y | ( y << 1 ) ) & 0x55555555;\\n\\n\\t\\treturn x | ( y << 1 );\\n\\n\\t}\\n\\n\\t// find the leftmost node of a polygon ring\\n\\n\\tfunction getLeftmost( start ) {\\n\\n\\t\\tvar p = start, leftmost = start;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tif ( p.x < leftmost.x ) leftmost = p;\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t} while ( p !== start );\\n\\n\\t\\treturn leftmost;\\n\\n\\t}\\n\\n\\t// check if a point lies within a convex triangle\\n\\n\\tfunction pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {\\n\\n\\t\\treturn ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&\\n\\t\\t ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&\\n\\t\\t ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;\\n\\n\\t}\\n\\n\\t// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\\n\\n\\tfunction isValidDiagonal( a, b ) {\\n\\n\\t\\treturn a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&\\n\\t\\t\\tlocallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );\\n\\n\\t}\\n\\n\\t// signed area of a triangle\\n\\n\\tfunction area( p, q, r ) {\\n\\n\\t\\treturn ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );\\n\\n\\t}\\n\\n\\t// check if two points are equal\\n\\n\\tfunction equals( p1, p2 ) {\\n\\n\\t\\treturn p1.x === p2.x && p1.y === p2.y;\\n\\n\\t}\\n\\n\\t// check if two segments intersect\\n\\n\\tfunction intersects( p1, q1, p2, q2 ) {\\n\\n\\t\\tif ( ( equals( p1, q1 ) && equals( p2, q2 ) ) ||\\n\\t\\t\\t\\t( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;\\n\\n\\t\\treturn area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&\\n\\t\\t\\t\\t\\t area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;\\n\\n\\t}\\n\\n\\t// check if a polygon diagonal intersects any polygon segments\\n\\n\\tfunction intersectsPolygon( a, b ) {\\n\\n\\t\\tvar p = a;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tif ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\\n\\t\\t\\t\\t\\t\\t\\tintersects( p, p.next, a, b ) ) {\\n\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t} while ( p !== a );\\n\\n\\t\\treturn false;\\n\\n\\t}\\n\\n\\t// check if a polygon diagonal is locally inside the polygon\\n\\n\\tfunction locallyInside( a, b ) {\\n\\n\\t\\treturn area( a.prev, a, a.next ) < 0 ?\\n\\t\\t\\tarea( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :\\n\\t\\t\\tarea( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;\\n\\n\\t}\\n\\n\\t// check if the middle point of a polygon diagonal is inside the polygon\\n\\n\\tfunction middleInside( a, b ) {\\n\\n\\t\\tvar p = a,\\n\\t\\t\\tinside = false,\\n\\t\\t\\tpx = ( a.x + b.x ) / 2,\\n\\t\\t\\tpy = ( a.y + b.y ) / 2;\\n\\n\\t\\tdo {\\n\\n\\t\\t\\tif ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&\\n\\t\\t\\t\\t\\t\\t\\t( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {\\n\\n\\t\\t\\t\\tinside = ! inside;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tp = p.next;\\n\\n\\t\\t} while ( p !== a );\\n\\n\\t\\treturn inside;\\n\\n\\t}\\n\\n\\t// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\\n\\t// if one belongs to the outer ring and another to a hole, it merges it into a single ring\\n\\n\\tfunction splitPolygon( a, b ) {\\n\\n\\t\\tvar a2 = new Node( a.i, a.x, a.y ),\\n\\t\\t\\tb2 = new Node( b.i, b.x, b.y ),\\n\\t\\t\\tan = a.next,\\n\\t\\t\\tbp = b.prev;\\n\\n\\t\\ta.next = b;\\n\\t\\tb.prev = a;\\n\\n\\t\\ta2.next = an;\\n\\t\\tan.prev = a2;\\n\\n\\t\\tb2.next = a2;\\n\\t\\ta2.prev = b2;\\n\\n\\t\\tbp.next = b2;\\n\\t\\tb2.prev = bp;\\n\\n\\t\\treturn b2;\\n\\n\\t}\\n\\n\\t// create a node and optionally link it with previous one (in a circular doubly linked list)\\n\\n\\tfunction insertNode( i, x, y, last ) {\\n\\n\\t\\tvar p = new Node( i, x, y );\\n\\n\\t\\tif ( ! last ) {\\n\\n\\t\\t\\tp.prev = p;\\n\\t\\t\\tp.next = p;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tp.next = last.next;\\n\\t\\t\\tp.prev = last;\\n\\t\\t\\tlast.next.prev = p;\\n\\t\\t\\tlast.next = p;\\n\\n\\t\\t}\\n\\n\\t\\treturn p;\\n\\n\\t}\\n\\n\\tfunction removeNode( p ) {\\n\\n\\t\\tp.next.prev = p.prev;\\n\\t\\tp.prev.next = p.next;\\n\\n\\t\\tif ( p.prevZ ) p.prevZ.nextZ = p.nextZ;\\n\\t\\tif ( p.nextZ ) p.nextZ.prevZ = p.prevZ;\\n\\n\\t}\\n\\n\\tfunction Node( i, x, y ) {\\n\\n\\t\\t// vertice index in coordinates array\\n\\t\\tthis.i = i;\\n\\n\\t\\t// vertex coordinates\\n\\t\\tthis.x = x;\\n\\t\\tthis.y = y;\\n\\n\\t\\t// previous and next vertice nodes in a polygon ring\\n\\t\\tthis.prev = null;\\n\\t\\tthis.next = null;\\n\\n\\t\\t// z-order curve value\\n\\t\\tthis.z = null;\\n\\n\\t\\t// previous and next nodes in z-order\\n\\t\\tthis.prevZ = null;\\n\\t\\tthis.nextZ = null;\\n\\n\\t\\t// indicates whether this is a steiner point\\n\\t\\tthis.steiner = false;\\n\\n\\t}\\n\\n\\tfunction signedArea( data, start, end, dim ) {\\n\\n\\t\\tvar sum = 0;\\n\\n\\t\\tfor ( var i = start, j = end - dim; i < end; i += dim ) {\\n\\n\\t\\t\\tsum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );\\n\\t\\t\\tj = i;\\n\\n\\t\\t}\\n\\n\\t\\treturn sum;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t */\\n\\n\\tvar ShapeUtils = {\\n\\n\\t\\t// calculate area of the contour polygon\\n\\n\\t\\tarea: function ( contour ) {\\n\\n\\t\\t\\tvar n = contour.length;\\n\\t\\t\\tvar a = 0.0;\\n\\n\\t\\t\\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\\n\\n\\t\\t\\t\\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn a * 0.5;\\n\\n\\t\\t},\\n\\n\\t\\tisClockWise: function ( pts ) {\\n\\n\\t\\t\\treturn ShapeUtils.area( pts ) < 0;\\n\\n\\t\\t},\\n\\n\\t\\ttriangulateShape: function ( contour, holes ) {\\n\\n\\t\\t\\tfunction removeDupEndPts( points ) {\\n\\n\\t\\t\\t\\tvar l = points.length;\\n\\n\\t\\t\\t\\tif ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {\\n\\n\\t\\t\\t\\t\\tpoints.pop();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction addContour( vertices, contour ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < contour.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvertices.push( contour[ i ].x );\\n\\t\\t\\t\\t\\tvertices.push( contour[ i ].y );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]\\n\\t\\t\\tvar holeIndices = []; // array of hole indices\\n\\t\\t\\tvar faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]\\n\\n\\t\\t\\tremoveDupEndPts( contour );\\n\\t\\t\\taddContour( vertices, contour );\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar holeIndex = contour.length;\\n\\t\\t\\tholes.forEach( removeDupEndPts );\\n\\n\\t\\t\\tfor ( i = 0; i < holes.length; i ++ ) {\\n\\n\\t\\t\\t\\tholeIndices.push( holeIndex );\\n\\t\\t\\t\\tholeIndex += holes[ i ].length;\\n\\t\\t\\t\\taddContour( vertices, holes[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar triangles = Earcut.triangulate( vertices, holeIndices );\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tfor ( var i = 0; i < triangles.length; i += 3 ) {\\n\\n\\t\\t\\t\\tfaces.push( triangles.slice( i, i + 3 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn faces;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t *\\n\\t * Creates extruded geometry from a path shape.\\n\\t *\\n\\t * parameters = {\\n\\t *\\n\\t *  curveSegments: <int>, // number of points on the curves\\n\\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\\n\\t *  amount: <int>, // Depth to extrude the shape\\n\\t *\\n\\t *  bevelEnabled: <bool>, // turn on bevel\\n\\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\\n\\t *  bevelSize: <float>, // how far from shape outline is bevel\\n\\t *  bevelSegments: <int>, // number of bevel layers\\n\\t *\\n\\t *  extrudePath: <THREE.Curve> // curve to extrude shape along\\n\\t *  frames: <Object> // containing arrays of tangents, normals, binormals\\n\\t *\\n\\t *  UVGenerator: <Object> // object that provides UV generator functions\\n\\t *\\n\\t * }\\n\\t */\\n\\n\\t// ExtrudeGeometry\\n\\n\\tfunction ExtrudeGeometry( shapes, options ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'ExtrudeGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tshapes: shapes,\\n\\t\\t\\toptions: options\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tExtrudeGeometry.prototype = Object.create( Geometry.prototype );\\n\\tExtrudeGeometry.prototype.constructor = ExtrudeGeometry;\\n\\n\\t// ExtrudeBufferGeometry\\n\\n\\tfunction ExtrudeBufferGeometry( shapes, options ) {\\n\\n\\t\\tif ( typeof ( shapes ) === \\\"undefined\\\" ) {\\n\\n\\t\\t\\treturn;\\n\\n\\t\\t}\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'ExtrudeBufferGeometry';\\n\\n\\t\\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\\n\\n\\t\\tthis.addShapeList( shapes, options );\\n\\n\\t\\tthis.computeVertexNormals();\\n\\n\\t\\t// can't really use automatic vertex normals\\n\\t\\t// as then front and back sides get smoothed too\\n\\t\\t// should do separate smoothing just for sides\\n\\n\\t\\t//this.computeVertexNormals();\\n\\n\\t\\t//console.log( \\\"took\\\", ( Date.now() - startTime ) );\\n\\n\\t}\\n\\n\\tExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;\\n\\n\\tExtrudeBufferGeometry.prototype.getArrays = function () {\\n\\n\\t\\tvar positionAttribute = this.getAttribute( \\\"position\\\" );\\n\\t\\tvar verticesArray = positionAttribute ? Array.prototype.slice.call( positionAttribute.array ) : [];\\n\\n\\t\\tvar uvAttribute = this.getAttribute( \\\"uv\\\" );\\n\\t\\tvar uvArray = uvAttribute ? Array.prototype.slice.call( uvAttribute.array ) : [];\\n\\n\\t\\tvar IndexAttribute = this.index;\\n\\t\\tvar indicesArray = IndexAttribute ? Array.prototype.slice.call( IndexAttribute.array ) : [];\\n\\n\\t\\treturn {\\n\\t\\t\\tposition: verticesArray,\\n\\t\\t\\tuv: uvArray,\\n\\t\\t\\tindex: indicesArray\\n\\t\\t};\\n\\n\\t};\\n\\n\\tExtrudeBufferGeometry.prototype.addShapeList = function ( shapes, options ) {\\n\\n\\t\\tvar sl = shapes.length;\\n\\t\\toptions.arrays = this.getArrays();\\n\\n\\t\\tfor ( var s = 0; s < sl; s ++ ) {\\n\\n\\t\\t\\tvar shape = shapes[ s ];\\n\\t\\t\\tthis.addShape( shape, options );\\n\\n\\t\\t}\\n\\n\\t\\tthis.setIndex( options.arrays.index );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( options.arrays.position, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( options.arrays.uv, 2 ) );\\n\\n\\t};\\n\\n\\tExtrudeBufferGeometry.prototype.addShape = function ( shape, options ) {\\n\\n\\t\\tvar arrays = options.arrays ? options.arrays : this.getArrays();\\n\\t\\tvar verticesArray = arrays.position;\\n\\t\\tvar indicesArray = arrays.index;\\n\\t\\tvar uvArray = arrays.uv;\\n\\n\\t\\tvar placeholder = [];\\n\\n\\n\\t\\tvar amount = options.amount !== undefined ? options.amount : 100;\\n\\n\\t\\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\\n\\t\\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\\n\\t\\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\\n\\n\\t\\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\\n\\n\\t\\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\\n\\n\\t\\tvar steps = options.steps !== undefined ? options.steps : 1;\\n\\n\\t\\tvar extrudePath = options.extrudePath;\\n\\t\\tvar extrudePts, extrudeByPath = false;\\n\\n\\t\\t// Use default WorldUVGenerator if no UV generators are specified.\\n\\t\\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;\\n\\n\\t\\tvar splineTube, binormal, normal, position2;\\n\\t\\tif ( extrudePath ) {\\n\\n\\t\\t\\textrudePts = extrudePath.getSpacedPoints( steps );\\n\\n\\t\\t\\textrudeByPath = true;\\n\\t\\t\\tbevelEnabled = false; // bevels not supported for path extrusion\\n\\n\\t\\t\\t// SETUP TNB variables\\n\\n\\t\\t\\t// TODO1 - have a .isClosed in spline?\\n\\n\\t\\t\\tsplineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );\\n\\n\\t\\t\\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\\n\\n\\t\\t\\tbinormal = new Vector3();\\n\\t\\t\\tnormal = new Vector3();\\n\\t\\t\\tposition2 = new Vector3();\\n\\n\\t\\t}\\n\\n\\t\\t// Safeguards if bevels are not enabled\\n\\n\\t\\tif ( ! bevelEnabled ) {\\n\\n\\t\\t\\tbevelSegments = 0;\\n\\t\\t\\tbevelThickness = 0;\\n\\t\\t\\tbevelSize = 0;\\n\\n\\t\\t}\\n\\n\\t\\t// Variables initialization\\n\\n\\t\\tvar ahole, h, hl; // looping of holes\\n\\t\\tvar scope = this;\\n\\n\\t\\tvar shapePoints = shape.extractPoints( curveSegments );\\n\\n\\t\\tvar vertices = shapePoints.shape;\\n\\t\\tvar holes = shapePoints.holes;\\n\\n\\t\\tvar reverse = ! ShapeUtils.isClockWise( vertices );\\n\\n\\t\\tif ( reverse ) {\\n\\n\\t\\t\\tvertices = vertices.reverse();\\n\\n\\t\\t\\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\\n\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\n\\n\\t\\t\\t\\tahole = holes[ h ];\\n\\n\\t\\t\\t\\tif ( ShapeUtils.isClockWise( ahole ) ) {\\n\\n\\t\\t\\t\\t\\tholes[ h ] = ahole.reverse();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\n\\t\\tvar faces = ShapeUtils.triangulateShape( vertices, holes );\\n\\n\\t\\t/* Vertices */\\n\\n\\t\\tvar contour = vertices; // vertices has all points but contour has only points of circumference\\n\\n\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\n\\n\\t\\t\\tahole = holes[ h ];\\n\\n\\t\\t\\tvertices = vertices.concat( ahole );\\n\\n\\t\\t}\\n\\n\\n\\t\\tfunction scalePt2( pt, vec, size ) {\\n\\n\\t\\t\\tif ( ! vec ) console.error( \\\"THREE.ExtrudeGeometry: vec does not exist\\\" );\\n\\n\\t\\t\\treturn vec.clone().multiplyScalar( size ).add( pt );\\n\\n\\t\\t}\\n\\n\\t\\tvar b, bs, t, z,\\n\\t\\t\\tvert, vlen = vertices.length,\\n\\t\\t\\tface, flen = faces.length;\\n\\n\\n\\t\\t// Find directions for point movement\\n\\n\\n\\t\\tfunction getBevelVec( inPt, inPrev, inNext ) {\\n\\n\\t\\t\\t// computes for inPt the corresponding point inPt' on a new contour\\n\\t\\t\\t//   shifted by 1 unit (length of normalized vector) to the left\\n\\t\\t\\t// if we walk along contour clockwise, this new contour is outside the old one\\n\\t\\t\\t//\\n\\t\\t\\t// inPt' is the intersection of the two lines parallel to the two\\n\\t\\t\\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\\n\\n\\t\\t\\tvar v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt\\n\\n\\t\\t\\t// good reading for geometry algorithms (here: line-line intersection)\\n\\t\\t\\t// http://geomalgorithms.com/a05-_intersect-1.html\\n\\n\\t\\t\\tvar v_prev_x = inPt.x - inPrev.x,\\n\\t\\t\\t\\tv_prev_y = inPt.y - inPrev.y;\\n\\t\\t\\tvar v_next_x = inNext.x - inPt.x,\\n\\t\\t\\t\\tv_next_y = inNext.y - inPt.y;\\n\\n\\t\\t\\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\\n\\n\\t\\t\\t// check for collinear edges\\n\\t\\t\\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\\n\\n\\t\\t\\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\\n\\n\\t\\t\\t\\t// not collinear\\n\\n\\t\\t\\t\\t// length of vectors for normalizing\\n\\n\\t\\t\\t\\tvar v_prev_len = Math.sqrt( v_prev_lensq );\\n\\t\\t\\t\\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\\n\\n\\t\\t\\t\\t// shift adjacent points by unit vectors to the left\\n\\n\\t\\t\\t\\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\\n\\t\\t\\t\\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\\n\\n\\t\\t\\t\\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\\n\\t\\t\\t\\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\\n\\n\\t\\t\\t\\t// scaling factor for v_prev to intersection point\\n\\n\\t\\t\\t\\tvar sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\\n\\t\\t\\t\\t\\t\\t( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /\\n\\t\\t\\t\\t\\t( v_prev_x * v_next_y - v_prev_y * v_next_x );\\n\\n\\t\\t\\t\\t// vector from inPt to intersection point\\n\\n\\t\\t\\t\\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\\n\\t\\t\\t\\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\\n\\n\\t\\t\\t\\t// Don't normalize!, otherwise sharp corners become ugly\\n\\t\\t\\t\\t//  but prevent crazy spikes\\n\\t\\t\\t\\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\\n\\t\\t\\t\\tif ( v_trans_lensq <= 2 ) {\\n\\n\\t\\t\\t\\t\\treturn new Vector2( v_trans_x, v_trans_y );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// handle special case of collinear edges\\n\\n\\t\\t\\t\\tvar direction_eq = false; // assumes: opposite\\n\\t\\t\\t\\tif ( v_prev_x > Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\tif ( v_next_x > Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\t\\tdirection_eq = true;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tif ( v_prev_x < - Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( v_next_x < - Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tdirection_eq = true;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tdirection_eq = true;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( direction_eq ) {\\n\\n\\t\\t\\t\\t\\t// console.log(\\\"Warning: lines are a straight sequence\\\");\\n\\t\\t\\t\\t\\tv_trans_x = - v_prev_y;\\n\\t\\t\\t\\t\\tv_trans_y = v_prev_x;\\n\\t\\t\\t\\t\\tshrink_by = Math.sqrt( v_prev_lensq );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// console.log(\\\"Warning: lines are a straight spike\\\");\\n\\t\\t\\t\\t\\tv_trans_x = v_prev_x;\\n\\t\\t\\t\\t\\tv_trans_y = v_prev_y;\\n\\t\\t\\t\\t\\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\\n\\n\\t\\t}\\n\\n\\n\\t\\tvar contourMovements = [];\\n\\n\\t\\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\\n\\n\\t\\t\\tif ( j === il ) j = 0;\\n\\t\\t\\tif ( k === il ) k = 0;\\n\\n\\t\\t\\t//  (j)---(i)---(k)\\n\\t\\t\\t// console.log('i,j,k', i, j , k)\\n\\n\\t\\t\\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\\n\\n\\t\\t}\\n\\n\\t\\tvar holesMovements = [],\\n\\t\\t\\toneHoleMovements, verticesMovements = contourMovements.concat();\\n\\n\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\n\\n\\t\\t\\tahole = holes[ h ];\\n\\n\\t\\t\\toneHoleMovements = [];\\n\\n\\t\\t\\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\\n\\n\\t\\t\\t\\tif ( j === il ) j = 0;\\n\\t\\t\\t\\tif ( k === il ) k = 0;\\n\\n\\t\\t\\t\\t//  (j)---(i)---(k)\\n\\t\\t\\t\\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tholesMovements.push( oneHoleMovements );\\n\\t\\t\\tverticesMovements = verticesMovements.concat( oneHoleMovements );\\n\\n\\t\\t}\\n\\n\\n\\t\\t// Loop bevelSegments, 1 for the front, 1 for the back\\n\\n\\t\\tfor ( b = 0; b < bevelSegments; b ++ ) {\\n\\n\\t\\t\\t//for ( b = bevelSegments; b > 0; b -- ) {\\n\\n\\t\\t\\tt = b / bevelSegments;\\n\\t\\t\\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\\n\\t\\t\\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\\n\\n\\t\\t\\t// contract shape\\n\\n\\t\\t\\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\\n\\n\\t\\t\\t\\tv( vert.x, vert.y, - z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// expand holes\\n\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\n\\n\\t\\t\\t\\tahole = holes[ h ];\\n\\t\\t\\t\\toneHoleMovements = holesMovements[ h ];\\n\\n\\t\\t\\t\\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\\n\\n\\t\\t\\t\\t\\tv( vert.x, vert.y, - z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tbs = bevelSize;\\n\\n\\t\\t// Back facing vertices\\n\\n\\t\\tfor ( i = 0; i < vlen; i ++ ) {\\n\\n\\t\\t\\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\\n\\n\\t\\t\\tif ( ! extrudeByPath ) {\\n\\n\\t\\t\\t\\tv( vert.x, vert.y, 0 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\\n\\n\\t\\t\\t\\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\\n\\t\\t\\t\\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\\n\\n\\t\\t\\t\\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\\n\\n\\t\\t\\t\\tv( position2.x, position2.y, position2.z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// Add stepped vertices...\\n\\t\\t// Including front facing vertices\\n\\n\\t\\tvar s;\\n\\n\\t\\tfor ( s = 1; s <= steps; s ++ ) {\\n\\n\\t\\t\\tfor ( i = 0; i < vlen; i ++ ) {\\n\\n\\t\\t\\t\\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\\n\\n\\t\\t\\t\\tif ( ! extrudeByPath ) {\\n\\n\\t\\t\\t\\t\\tv( vert.x, vert.y, amount / steps * s );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\\n\\n\\t\\t\\t\\t\\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\\n\\t\\t\\t\\t\\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\\n\\n\\t\\t\\t\\t\\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\\n\\n\\t\\t\\t\\t\\tv( position2.x, position2.y, position2.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\n\\t\\t// Add bevel segments planes\\n\\n\\t\\t//for ( b = 1; b <= bevelSegments; b ++ ) {\\n\\t\\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\\n\\n\\t\\t\\tt = b / bevelSegments;\\n\\t\\t\\tz = bevelThickness * Math.cos( t * Math.PI / 2 );\\n\\t\\t\\tbs = bevelSize * Math.sin( t * Math.PI / 2 );\\n\\n\\t\\t\\t// contract shape\\n\\n\\t\\t\\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\\n\\t\\t\\t\\tv( vert.x, vert.y, amount + z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// expand holes\\n\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\n\\n\\t\\t\\t\\tahole = holes[ h ];\\n\\t\\t\\t\\toneHoleMovements = holesMovements[ h ];\\n\\n\\t\\t\\t\\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\\n\\n\\t\\t\\t\\t\\tif ( ! extrudeByPath ) {\\n\\n\\t\\t\\t\\t\\t\\tv( vert.x, vert.y, amount + z );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t/* Faces */\\n\\n\\t\\t// Top and bottom faces\\n\\n\\t\\tbuildLidFaces();\\n\\n\\t\\t// Sides faces\\n\\n\\t\\tbuildSideFaces();\\n\\n\\n\\t\\t/////  Internal functions\\n\\n\\t\\tfunction buildLidFaces() {\\n\\n\\t\\t\\tvar start = verticesArray.length / 3;\\n\\n\\t\\t\\tif ( bevelEnabled ) {\\n\\n\\t\\t\\t\\tvar layer = 0; // steps + 1\\n\\t\\t\\t\\tvar offset = vlen * layer;\\n\\n\\t\\t\\t\\t// Bottom faces\\n\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\n\\n\\t\\t\\t\\t\\tface = faces[ i ];\\n\\t\\t\\t\\t\\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlayer = steps + bevelSegments * 2;\\n\\t\\t\\t\\toffset = vlen * layer;\\n\\n\\t\\t\\t\\t// Top faces\\n\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\n\\n\\t\\t\\t\\t\\tface = faces[ i ];\\n\\t\\t\\t\\t\\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Bottom faces\\n\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\n\\n\\t\\t\\t\\t\\tface = faces[ i ];\\n\\t\\t\\t\\t\\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// Top faces\\n\\n\\t\\t\\t\\tfor ( i = 0; i < flen; i ++ ) {\\n\\n\\t\\t\\t\\t\\tface = faces[ i ];\\n\\t\\t\\t\\t\\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscope.addGroup( start, verticesArray.length / 3 - start, options.material !== undefined ? options.material : 0 );\\n\\n\\t\\t}\\n\\n\\t\\t// Create faces for the z-sides of the shape\\n\\n\\t\\tfunction buildSideFaces() {\\n\\n\\t\\t\\tvar start = verticesArray.length / 3;\\n\\t\\t\\tvar layeroffset = 0;\\n\\t\\t\\tsidewalls( contour, layeroffset );\\n\\t\\t\\tlayeroffset += contour.length;\\n\\n\\t\\t\\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\\n\\n\\t\\t\\t\\tahole = holes[ h ];\\n\\t\\t\\t\\tsidewalls( ahole, layeroffset );\\n\\n\\t\\t\\t\\t//, true\\n\\t\\t\\t\\tlayeroffset += ahole.length;\\n\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tscope.addGroup( start, verticesArray.length / 3 - start, options.extrudeMaterial !== undefined ? options.extrudeMaterial : 1 );\\n\\n\\n\\t\\t}\\n\\n\\t\\tfunction sidewalls( contour, layeroffset ) {\\n\\n\\t\\t\\tvar j, k;\\n\\t\\t\\ti = contour.length;\\n\\n\\t\\t\\twhile ( -- i >= 0 ) {\\n\\n\\t\\t\\t\\tj = i;\\n\\t\\t\\t\\tk = i - 1;\\n\\t\\t\\t\\tif ( k < 0 ) k = contour.length - 1;\\n\\n\\t\\t\\t\\t//console.log('b', i,j, i-1, k,vertices.length);\\n\\n\\t\\t\\t\\tvar s = 0,\\n\\t\\t\\t\\t\\tsl = steps + bevelSegments * 2;\\n\\n\\t\\t\\t\\tfor ( s = 0; s < sl; s ++ ) {\\n\\n\\t\\t\\t\\t\\tvar slen1 = vlen * s;\\n\\t\\t\\t\\t\\tvar slen2 = vlen * ( s + 1 );\\n\\n\\t\\t\\t\\t\\tvar a = layeroffset + j + slen1,\\n\\t\\t\\t\\t\\t\\tb = layeroffset + k + slen1,\\n\\t\\t\\t\\t\\t\\tc = layeroffset + k + slen2,\\n\\t\\t\\t\\t\\t\\td = layeroffset + j + slen2;\\n\\n\\t\\t\\t\\t\\tf4( a, b, c, d );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tfunction v( x, y, z ) {\\n\\n\\t\\t\\tplaceholder.push( x );\\n\\t\\t\\tplaceholder.push( y );\\n\\t\\t\\tplaceholder.push( z );\\n\\n\\t\\t}\\n\\n\\n\\t\\tfunction f3( a, b, c ) {\\n\\n\\t\\t\\taddVertex( a );\\n\\t\\t\\taddVertex( b );\\n\\t\\t\\taddVertex( c );\\n\\n\\t\\t\\tvar nextIndex = verticesArray.length / 3;\\n\\t\\t\\tvar uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\\n\\n\\t\\t\\taddUV( uvs[ 0 ] );\\n\\t\\t\\taddUV( uvs[ 1 ] );\\n\\t\\t\\taddUV( uvs[ 2 ] );\\n\\n\\t\\t}\\n\\n\\t\\tfunction f4( a, b, c, d ) {\\n\\n\\t\\t\\taddVertex( a );\\n\\t\\t\\taddVertex( b );\\n\\t\\t\\taddVertex( d );\\n\\n\\t\\t\\taddVertex( b );\\n\\t\\t\\taddVertex( c );\\n\\t\\t\\taddVertex( d );\\n\\n\\n\\t\\t\\tvar nextIndex = verticesArray.length / 3;\\n\\t\\t\\tvar uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );\\n\\n\\t\\t\\taddUV( uvs[ 0 ] );\\n\\t\\t\\taddUV( uvs[ 1 ] );\\n\\t\\t\\taddUV( uvs[ 3 ] );\\n\\n\\t\\t\\taddUV( uvs[ 1 ] );\\n\\t\\t\\taddUV( uvs[ 2 ] );\\n\\t\\t\\taddUV( uvs[ 3 ] );\\n\\n\\t\\t}\\n\\n\\t\\tfunction addVertex( index ) {\\n\\n\\t\\t\\tindicesArray.push( verticesArray.length / 3 );\\n\\t\\t\\tverticesArray.push( placeholder[ index * 3 + 0 ] );\\n\\t\\t\\tverticesArray.push( placeholder[ index * 3 + 1 ] );\\n\\t\\t\\tverticesArray.push( placeholder[ index * 3 + 2 ] );\\n\\n\\t\\t}\\n\\n\\n\\t\\tfunction addUV( vector2 ) {\\n\\n\\t\\t\\tuvArray.push( vector2.x );\\n\\t\\t\\tuvArray.push( vector2.y );\\n\\n\\t\\t}\\n\\n\\t\\tif ( ! options.arrays ) {\\n\\n\\t\\t\\tthis.setIndex( indicesArray );\\n\\t\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );\\n\\t\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tExtrudeGeometry.WorldUVGenerator = {\\n\\n\\t\\tgenerateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {\\n\\n\\t\\t\\tvar a_x = vertices[ indexA * 3 ];\\n\\t\\t\\tvar a_y = vertices[ indexA * 3 + 1 ];\\n\\t\\t\\tvar b_x = vertices[ indexB * 3 ];\\n\\t\\t\\tvar b_y = vertices[ indexB * 3 + 1 ];\\n\\t\\t\\tvar c_x = vertices[ indexC * 3 ];\\n\\t\\t\\tvar c_y = vertices[ indexC * 3 + 1 ];\\n\\n\\t\\t\\treturn [\\n\\t\\t\\t\\tnew Vector2( a_x, a_y ),\\n\\t\\t\\t\\tnew Vector2( b_x, b_y ),\\n\\t\\t\\t\\tnew Vector2( c_x, c_y )\\n\\t\\t\\t];\\n\\n\\t\\t},\\n\\n\\t\\tgenerateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {\\n\\n\\t\\t\\tvar a_x = vertices[ indexA * 3 ];\\n\\t\\t\\tvar a_y = vertices[ indexA * 3 + 1 ];\\n\\t\\t\\tvar a_z = vertices[ indexA * 3 + 2 ];\\n\\t\\t\\tvar b_x = vertices[ indexB * 3 ];\\n\\t\\t\\tvar b_y = vertices[ indexB * 3 + 1 ];\\n\\t\\t\\tvar b_z = vertices[ indexB * 3 + 2 ];\\n\\t\\t\\tvar c_x = vertices[ indexC * 3 ];\\n\\t\\t\\tvar c_y = vertices[ indexC * 3 + 1 ];\\n\\t\\t\\tvar c_z = vertices[ indexC * 3 + 2 ];\\n\\t\\t\\tvar d_x = vertices[ indexD * 3 ];\\n\\t\\t\\tvar d_y = vertices[ indexD * 3 + 1 ];\\n\\t\\t\\tvar d_z = vertices[ indexD * 3 + 2 ];\\n\\n\\t\\t\\tif ( Math.abs( a_y - b_y ) < 0.01 ) {\\n\\n\\t\\t\\t\\treturn [\\n\\t\\t\\t\\t\\tnew Vector2( a_x, 1 - a_z ),\\n\\t\\t\\t\\t\\tnew Vector2( b_x, 1 - b_z ),\\n\\t\\t\\t\\t\\tnew Vector2( c_x, 1 - c_z ),\\n\\t\\t\\t\\t\\tnew Vector2( d_x, 1 - d_z )\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\treturn [\\n\\t\\t\\t\\t\\tnew Vector2( a_y, 1 - a_z ),\\n\\t\\t\\t\\t\\tnew Vector2( b_y, 1 - b_z ),\\n\\t\\t\\t\\t\\tnew Vector2( c_y, 1 - c_z ),\\n\\t\\t\\t\\t\\tnew Vector2( d_y, 1 - d_z )\\n\\t\\t\\t\\t];\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * Text = 3D Text\\n\\t *\\n\\t * parameters = {\\n\\t *  font: <THREE.Font>, // font\\n\\t *\\n\\t *  size: <float>, // size of the text\\n\\t *  height: <float>, // thickness to extrude text\\n\\t *  curveSegments: <int>, // number of points on the curves\\n\\t *\\n\\t *  bevelEnabled: <bool>, // turn on bevel\\n\\t *  bevelThickness: <float>, // how deep into text bevel goes\\n\\t *  bevelSize: <float> // how far from text outline is bevel\\n\\t * }\\n\\t */\\n\\n\\t// TextGeometry\\n\\n\\tfunction TextGeometry( text, parameters ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'TextGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\ttext: text,\\n\\t\\t\\tparameters: parameters\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tTextGeometry.prototype = Object.create( Geometry.prototype );\\n\\tTextGeometry.prototype.constructor = TextGeometry;\\n\\n\\t// TextBufferGeometry\\n\\n\\tfunction TextBufferGeometry( text, parameters ) {\\n\\n\\t\\tparameters = parameters || {};\\n\\n\\t\\tvar font = parameters.font;\\n\\n\\t\\tif ( ! ( font && font.isFont ) ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\\n\\t\\t\\treturn new Geometry();\\n\\n\\t\\t}\\n\\n\\t\\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\\n\\n\\t\\t// translate parameters to ExtrudeGeometry API\\n\\n\\t\\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\\n\\n\\t\\t// defaults\\n\\n\\t\\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\\n\\t\\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\\n\\t\\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\\n\\n\\t\\tExtrudeBufferGeometry.call( this, shapes, parameters );\\n\\n\\t\\tthis.type = 'TextBufferGeometry';\\n\\n\\t}\\n\\n\\tTextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );\\n\\tTextBufferGeometry.prototype.constructor = TextBufferGeometry;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// SphereGeometry\\n\\n\\tfunction SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'SphereGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\twidthSegments: widthSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\tphiStart: phiStart,\\n\\t\\t\\tphiLength: phiLength,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tSphereGeometry.prototype = Object.create( Geometry.prototype );\\n\\tSphereGeometry.prototype.constructor = SphereGeometry;\\n\\n\\t// SphereBufferGeometry\\n\\n\\tfunction SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'SphereBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\twidthSegments: widthSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\tphiStart: phiStart,\\n\\t\\t\\tphiLength: phiLength,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tradius = radius || 1;\\n\\n\\t\\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\\n\\t\\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\\n\\n\\t\\tphiStart = phiStart !== undefined ? phiStart : 0;\\n\\t\\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\\n\\n\\t\\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\\n\\t\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\\n\\n\\t\\tvar thetaEnd = thetaStart + thetaLength;\\n\\n\\t\\tvar ix, iy;\\n\\n\\t\\tvar index = 0;\\n\\t\\tvar grid = [];\\n\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar normal = new Vector3();\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\tfor ( iy = 0; iy <= heightSegments; iy ++ ) {\\n\\n\\t\\t\\tvar verticesRow = [];\\n\\n\\t\\t\\tvar v = iy / heightSegments;\\n\\n\\t\\t\\tfor ( ix = 0; ix <= widthSegments; ix ++ ) {\\n\\n\\t\\t\\t\\tvar u = ix / widthSegments;\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\\n\\t\\t\\t\\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\\n\\t\\t\\t\\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\tnormal.set( vertex.x, vertex.y, vertex.z ).normalize();\\n\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuvs.push( u, 1 - v );\\n\\n\\t\\t\\t\\tverticesRow.push( index ++ );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tgrid.push( verticesRow );\\n\\n\\t\\t}\\n\\n\\t\\t// indices\\n\\n\\t\\tfor ( iy = 0; iy < heightSegments; iy ++ ) {\\n\\n\\t\\t\\tfor ( ix = 0; ix < widthSegments; ix ++ ) {\\n\\n\\t\\t\\t\\tvar a = grid[ iy ][ ix + 1 ];\\n\\t\\t\\t\\tvar b = grid[ iy ][ ix ];\\n\\t\\t\\t\\tvar c = grid[ iy + 1 ][ ix ];\\n\\t\\t\\t\\tvar d = grid[ iy + 1 ][ ix + 1 ];\\n\\n\\t\\t\\t\\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\\n\\t\\t\\t\\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t}\\n\\n\\tSphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tSphereBufferGeometry.prototype.constructor = SphereBufferGeometry;\\n\\n\\t/**\\n\\t * @author Kaleb Murphy\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// RingGeometry\\n\\n\\tfunction RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'RingGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tinnerRadius: innerRadius,\\n\\t\\t\\touterRadius: outerRadius,\\n\\t\\t\\tthetaSegments: thetaSegments,\\n\\t\\t\\tphiSegments: phiSegments,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tRingGeometry.prototype = Object.create( Geometry.prototype );\\n\\tRingGeometry.prototype.constructor = RingGeometry;\\n\\n\\t// RingBufferGeometry\\n\\n\\tfunction RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'RingBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tinnerRadius: innerRadius,\\n\\t\\t\\touterRadius: outerRadius,\\n\\t\\t\\tthetaSegments: thetaSegments,\\n\\t\\t\\tphiSegments: phiSegments,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tinnerRadius = innerRadius || 0.5;\\n\\t\\touterRadius = outerRadius || 1;\\n\\n\\t\\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\\n\\t\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\\n\\n\\t\\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\\n\\t\\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// some helper variables\\n\\n\\t\\tvar segment;\\n\\t\\tvar radius = innerRadius;\\n\\t\\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar uv = new Vector2();\\n\\t\\tvar j, i;\\n\\n\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\tfor ( j = 0; j <= phiSegments; j ++ ) {\\n\\n\\t\\t\\tfor ( i = 0; i <= thetaSegments; i ++ ) {\\n\\n\\t\\t\\t\\t// values are generate from the inside of the ring to the outside\\n\\n\\t\\t\\t\\tsegment = thetaStart + i / thetaSegments * thetaLength;\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertex.x = radius * Math.cos( segment );\\n\\t\\t\\t\\tvertex.y = radius * Math.sin( segment );\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\tnormals.push( 0, 0, 1 );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\\n\\t\\t\\t\\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\\n\\n\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// increase the radius for next row of vertices\\n\\n\\t\\t\\tradius += radiusStep;\\n\\n\\t\\t}\\n\\n\\t\\t// indices\\n\\n\\t\\tfor ( j = 0; j < phiSegments; j ++ ) {\\n\\n\\t\\t\\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\\n\\n\\t\\t\\tfor ( i = 0; i < thetaSegments; i ++ ) {\\n\\n\\t\\t\\t\\tsegment = i + thetaSegmentLevel;\\n\\n\\t\\t\\t\\tvar a = segment;\\n\\t\\t\\t\\tvar b = segment + thetaSegments + 1;\\n\\t\\t\\t\\tvar c = segment + thetaSegments + 2;\\n\\t\\t\\t\\tvar d = segment + 1;\\n\\n\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t}\\n\\n\\tRingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tRingBufferGeometry.prototype.constructor = RingBufferGeometry;\\n\\n\\t/**\\n\\t * @author astrodud / http://astrodud.isgreat.org/\\n\\t * @author zz85 / https://github.com/zz85\\n\\t * @author bhouston / http://clara.io\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// LatheGeometry\\n\\n\\tfunction LatheGeometry( points, segments, phiStart, phiLength ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'LatheGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tpoints: points,\\n\\t\\t\\tsegments: segments,\\n\\t\\t\\tphiStart: phiStart,\\n\\t\\t\\tphiLength: phiLength\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tLatheGeometry.prototype = Object.create( Geometry.prototype );\\n\\tLatheGeometry.prototype.constructor = LatheGeometry;\\n\\n\\t// LatheBufferGeometry\\n\\n\\tfunction LatheBufferGeometry( points, segments, phiStart, phiLength ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'LatheBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tpoints: points,\\n\\t\\t\\tsegments: segments,\\n\\t\\t\\tphiStart: phiStart,\\n\\t\\t\\tphiLength: phiLength\\n\\t\\t};\\n\\n\\t\\tsegments = Math.floor( segments ) || 12;\\n\\t\\tphiStart = phiStart || 0;\\n\\t\\tphiLength = phiLength || Math.PI * 2;\\n\\n\\t\\t// clamp phiLength so it's in range of [ 0, 2PI ]\\n\\n\\t\\tphiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );\\n\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar base;\\n\\t\\tvar inverseSegments = 1.0 / segments;\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar uv = new Vector2();\\n\\t\\tvar i, j;\\n\\n\\t\\t// generate vertices and uvs\\n\\n\\t\\tfor ( i = 0; i <= segments; i ++ ) {\\n\\n\\t\\t\\tvar phi = phiStart + i * inverseSegments * phiLength;\\n\\n\\t\\t\\tvar sin = Math.sin( phi );\\n\\t\\t\\tvar cos = Math.cos( phi );\\n\\n\\t\\t\\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertex.x = points[ j ].x * sin;\\n\\t\\t\\t\\tvertex.y = points[ j ].y;\\n\\t\\t\\t\\tvertex.z = points[ j ].x * cos;\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuv.x = i / segments;\\n\\t\\t\\t\\tuv.y = j / ( points.length - 1 );\\n\\n\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\n\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// indices\\n\\n\\t\\tfor ( i = 0; i < segments; i ++ ) {\\n\\n\\t\\t\\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\\n\\n\\t\\t\\t\\tbase = j + i * points.length;\\n\\n\\t\\t\\t\\tvar a = base;\\n\\t\\t\\t\\tvar b = base + points.length;\\n\\t\\t\\t\\tvar c = base + points.length + 1;\\n\\t\\t\\t\\tvar d = base + 1;\\n\\n\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t\\t// generate normals\\n\\n\\t\\tthis.computeVertexNormals();\\n\\n\\t\\t// if the geometry is closed, we need to average the normals along the seam.\\n\\t\\t// because the corresponding vertices are identical (but still have different UVs).\\n\\n\\t\\tif ( phiLength === Math.PI * 2 ) {\\n\\n\\t\\t\\tvar normals = this.attributes.normal.array;\\n\\t\\t\\tvar n1 = new Vector3();\\n\\t\\t\\tvar n2 = new Vector3();\\n\\t\\t\\tvar n = new Vector3();\\n\\n\\t\\t\\t// this is the buffer offset for the last line of vertices\\n\\n\\t\\t\\tbase = segments * points.length * 3;\\n\\n\\t\\t\\tfor ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\\n\\n\\t\\t\\t\\t// select the normal of the vertex in the first line\\n\\n\\t\\t\\t\\tn1.x = normals[ j + 0 ];\\n\\t\\t\\t\\tn1.y = normals[ j + 1 ];\\n\\t\\t\\t\\tn1.z = normals[ j + 2 ];\\n\\n\\t\\t\\t\\t// select the normal of the vertex in the last line\\n\\n\\t\\t\\t\\tn2.x = normals[ base + j + 0 ];\\n\\t\\t\\t\\tn2.y = normals[ base + j + 1 ];\\n\\t\\t\\t\\tn2.z = normals[ base + j + 2 ];\\n\\n\\t\\t\\t\\t// average normals\\n\\n\\t\\t\\t\\tn.addVectors( n1, n2 ).normalize();\\n\\n\\t\\t\\t\\t// assign the new values to both normals\\n\\n\\t\\t\\t\\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\\n\\t\\t\\t\\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\\n\\t\\t\\t\\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tLatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tLatheBufferGeometry.prototype.constructor = LatheBufferGeometry;\\n\\n\\t/**\\n\\t * @author jonobr1 / http://jonobr1.com\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// ShapeGeometry\\n\\n\\tfunction ShapeGeometry( shapes, curveSegments ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'ShapeGeometry';\\n\\n\\t\\tif ( typeof curveSegments === 'object' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );\\n\\n\\t\\t\\tcurveSegments = curveSegments.curveSegments;\\n\\n\\t\\t}\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tshapes: shapes,\\n\\t\\t\\tcurveSegments: curveSegments\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tShapeGeometry.prototype = Object.create( Geometry.prototype );\\n\\tShapeGeometry.prototype.constructor = ShapeGeometry;\\n\\n\\tShapeGeometry.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Geometry.prototype.toJSON.call( this );\\n\\n\\t\\tvar shapes = this.parameters.shapes;\\n\\n\\t\\treturn toJSON( shapes, data );\\n\\n\\t};\\n\\n\\t// ShapeBufferGeometry\\n\\n\\tfunction ShapeBufferGeometry( shapes, curveSegments ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'ShapeBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tshapes: shapes,\\n\\t\\t\\tcurveSegments: curveSegments\\n\\t\\t};\\n\\n\\t\\tcurveSegments = curveSegments || 12;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar groupStart = 0;\\n\\t\\tvar groupCount = 0;\\n\\n\\t\\t// allow single and array values for \\\"shapes\\\" parameter\\n\\n\\t\\tif ( Array.isArray( shapes ) === false ) {\\n\\n\\t\\t\\taddShape( shapes );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tfor ( var i = 0; i < shapes.length; i ++ ) {\\n\\n\\t\\t\\t\\taddShape( shapes[ i ] );\\n\\n\\t\\t\\t\\tthis.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support\\n\\n\\t\\t\\t\\tgroupStart += groupCount;\\n\\t\\t\\t\\tgroupCount = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\n\\t\\t// helper functions\\n\\n\\t\\tfunction addShape( shape ) {\\n\\n\\t\\t\\tvar i, l, shapeHole;\\n\\n\\t\\t\\tvar indexOffset = vertices.length / 3;\\n\\t\\t\\tvar points = shape.extractPoints( curveSegments );\\n\\n\\t\\t\\tvar shapeVertices = points.shape;\\n\\t\\t\\tvar shapeHoles = points.holes;\\n\\n\\t\\t\\t// check direction of vertices\\n\\n\\t\\t\\tif ( ShapeUtils.isClockWise( shapeVertices ) === false ) {\\n\\n\\t\\t\\t\\tshapeVertices = shapeVertices.reverse();\\n\\n\\t\\t\\t\\t// also check if holes are in the opposite direction\\n\\n\\t\\t\\t\\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tshapeHole = shapeHoles[ i ];\\n\\n\\t\\t\\t\\t\\tif ( ShapeUtils.isClockWise( shapeHole ) === true ) {\\n\\n\\t\\t\\t\\t\\t\\tshapeHoles[ i ] = shapeHole.reverse();\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );\\n\\n\\t\\t\\t// join vertices of inner and outer paths to a single array\\n\\n\\t\\t\\tfor ( i = 0, l = shapeHoles.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tshapeHole = shapeHoles[ i ];\\n\\t\\t\\t\\tshapeVertices = shapeVertices.concat( shapeHole );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// vertices, normals, uvs\\n\\n\\t\\t\\tfor ( i = 0, l = shapeVertices.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar vertex = shapeVertices[ i ];\\n\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, 0 );\\n\\t\\t\\t\\tnormals.push( 0, 0, 1 );\\n\\t\\t\\t\\tuvs.push( vertex.x, vertex.y ); // world uvs\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// incides\\n\\n\\t\\t\\tfor ( i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\tvar a = face[ 0 ] + indexOffset;\\n\\t\\t\\t\\tvar b = face[ 1 ] + indexOffset;\\n\\t\\t\\t\\tvar c = face[ 2 ] + indexOffset;\\n\\n\\t\\t\\t\\tindices.push( a, b, c );\\n\\t\\t\\t\\tgroupCount += 3;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;\\n\\n\\tShapeBufferGeometry.prototype.toJSON = function () {\\n\\n\\t\\tvar data = BufferGeometry.prototype.toJSON.call( this );\\n\\n\\t\\tvar shapes = this.parameters.shapes;\\n\\n\\t\\treturn toJSON( shapes, data );\\n\\n\\t};\\n\\n\\t//\\n\\n\\tfunction toJSON( shapes, data ) {\\n\\n\\t\\tdata.shapes = [];\\n\\n\\t\\tif ( Array.isArray( shapes ) ) {\\n\\n\\t\\t\\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar shape = shapes[ i ];\\n\\n\\t\\t\\t\\tdata.shapes.push( shape.uuid );\\n\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tdata.shapes.push( shapes.uuid );\\n\\n\\t\\t}\\n\\n\\t\\treturn data;\\n\\n\\t}\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\tfunction EdgesGeometry( geometry, thresholdAngle ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'EdgesGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tthresholdAngle: thresholdAngle\\n\\t\\t};\\n\\n\\t\\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\\n\\n\\t\\t// buffer\\n\\n\\t\\tvar vertices = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );\\n\\t\\tvar edge = [ 0, 0 ], edges = {}, edge1, edge2;\\n\\t\\tvar key, keys = [ 'a', 'b', 'c' ];\\n\\n\\t\\t// prepare source geometry\\n\\n\\t\\tvar geometry2;\\n\\n\\t\\tif ( geometry.isBufferGeometry ) {\\n\\n\\t\\t\\tgeometry2 = new Geometry();\\n\\t\\t\\tgeometry2.fromBufferGeometry( geometry );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tgeometry2 = geometry.clone();\\n\\n\\t\\t}\\n\\n\\t\\tgeometry2.mergeVertices();\\n\\t\\tgeometry2.computeFaceNormals();\\n\\n\\t\\tvar sourceVertices = geometry2.vertices;\\n\\t\\tvar faces = geometry2.faces;\\n\\n\\t\\t// now create a data structure where each entry represents an edge with its adjoining faces\\n\\n\\t\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\tfor ( var j = 0; j < 3; j ++ ) {\\n\\n\\t\\t\\t\\tedge1 = face[ keys[ j ] ];\\n\\t\\t\\t\\tedge2 = face[ keys[ ( j + 1 ) % 3 ] ];\\n\\t\\t\\t\\tedge[ 0 ] = Math.min( edge1, edge2 );\\n\\t\\t\\t\\tedge[ 1 ] = Math.max( edge1, edge2 );\\n\\n\\t\\t\\t\\tkey = edge[ 0 ] + ',' + edge[ 1 ];\\n\\n\\t\\t\\t\\tif ( edges[ key ] === undefined ) {\\n\\n\\t\\t\\t\\t\\tedges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tedges[ key ].face2 = i;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// generate vertices\\n\\n\\t\\tfor ( key in edges ) {\\n\\n\\t\\t\\tvar e = edges[ key ];\\n\\n\\t\\t\\t// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\\n\\n\\t\\t\\tif ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {\\n\\n\\t\\t\\t\\tvar vertex = sourceVertices[ e.index1 ];\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\tvertex = sourceVertices[ e.index2 ];\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\n\\t}\\n\\n\\tEdgesGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tEdgesGeometry.prototype.constructor = EdgesGeometry;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\t// CylinderGeometry\\n\\n\\tfunction CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'CylinderGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradiusTop: radiusTop,\\n\\t\\t\\tradiusBottom: radiusBottom,\\n\\t\\t\\theight: height,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\topenEnded: openEnded,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tCylinderGeometry.prototype = Object.create( Geometry.prototype );\\n\\tCylinderGeometry.prototype.constructor = CylinderGeometry;\\n\\n\\t// CylinderBufferGeometry\\n\\n\\tfunction CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'CylinderBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradiusTop: radiusTop,\\n\\t\\t\\tradiusBottom: radiusBottom,\\n\\t\\t\\theight: height,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\topenEnded: openEnded,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tradiusTop = radiusTop !== undefined ? radiusTop : 1;\\n\\t\\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 1;\\n\\t\\theight = height || 1;\\n\\n\\t\\tradialSegments = Math.floor( radialSegments ) || 8;\\n\\t\\theightSegments = Math.floor( heightSegments ) || 1;\\n\\n\\t\\topenEnded = openEnded !== undefined ? openEnded : false;\\n\\t\\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\\n\\t\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar index = 0;\\n\\t\\tvar indexArray = [];\\n\\t\\tvar halfHeight = height / 2;\\n\\t\\tvar groupStart = 0;\\n\\n\\t\\t// generate geometry\\n\\n\\t\\tgenerateTorso();\\n\\n\\t\\tif ( openEnded === false ) {\\n\\n\\t\\t\\tif ( radiusTop > 0 ) generateCap( true );\\n\\t\\t\\tif ( radiusBottom > 0 ) generateCap( false );\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t\\tfunction generateTorso() {\\n\\n\\t\\t\\tvar x, y;\\n\\t\\t\\tvar normal = new Vector3();\\n\\t\\t\\tvar vertex = new Vector3();\\n\\n\\t\\t\\tvar groupCount = 0;\\n\\n\\t\\t\\t// this will be used to calculate the normal\\n\\t\\t\\tvar slope = ( radiusBottom - radiusTop ) / height;\\n\\n\\t\\t\\t// generate vertices, normals and uvs\\n\\n\\t\\t\\tfor ( y = 0; y <= heightSegments; y ++ ) {\\n\\n\\t\\t\\t\\tvar indexRow = [];\\n\\n\\t\\t\\t\\tvar v = y / heightSegments;\\n\\n\\t\\t\\t\\t// calculate the radius of the current row\\n\\n\\t\\t\\t\\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\\n\\n\\t\\t\\t\\tfor ( x = 0; x <= radialSegments; x ++ ) {\\n\\n\\t\\t\\t\\t\\tvar u = x / radialSegments;\\n\\n\\t\\t\\t\\t\\tvar theta = u * thetaLength + thetaStart;\\n\\n\\t\\t\\t\\t\\tvar sinTheta = Math.sin( theta );\\n\\t\\t\\t\\t\\tvar cosTheta = Math.cos( theta );\\n\\n\\t\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\t\\tvertex.x = radius * sinTheta;\\n\\t\\t\\t\\t\\tvertex.y = - v * height + halfHeight;\\n\\t\\t\\t\\t\\tvertex.z = radius * cosTheta;\\n\\t\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\t\\tnormal.set( sinTheta, slope, cosTheta ).normalize();\\n\\t\\t\\t\\t\\tnormals.push( normal.x, normal.y, normal.z );\\n\\n\\t\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\t\\tuvs.push( u, 1 - v );\\n\\n\\t\\t\\t\\t\\t// save index of vertex in respective row\\n\\n\\t\\t\\t\\t\\tindexRow.push( index ++ );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// now save vertices of the row in our index array\\n\\n\\t\\t\\t\\tindexArray.push( indexRow );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// generate indices\\n\\n\\t\\t\\tfor ( x = 0; x < radialSegments; x ++ ) {\\n\\n\\t\\t\\t\\tfor ( y = 0; y < heightSegments; y ++ ) {\\n\\n\\t\\t\\t\\t\\t// we use the index array to access the correct indices\\n\\n\\t\\t\\t\\t\\tvar a = indexArray[ y ][ x ];\\n\\t\\t\\t\\t\\tvar b = indexArray[ y + 1 ][ x ];\\n\\t\\t\\t\\t\\tvar c = indexArray[ y + 1 ][ x + 1 ];\\n\\t\\t\\t\\t\\tvar d = indexArray[ y ][ x + 1 ];\\n\\n\\t\\t\\t\\t\\t// faces\\n\\n\\t\\t\\t\\t\\tindices.push( a, b, d );\\n\\t\\t\\t\\t\\tindices.push( b, c, d );\\n\\n\\t\\t\\t\\t\\t// update group counter\\n\\n\\t\\t\\t\\t\\tgroupCount += 6;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// add a group to the geometry. this will ensure multi material support\\n\\n\\t\\t\\tscope.addGroup( groupStart, groupCount, 0 );\\n\\n\\t\\t\\t// calculate new start value for groups\\n\\n\\t\\t\\tgroupStart += groupCount;\\n\\n\\t\\t}\\n\\n\\t\\tfunction generateCap( top ) {\\n\\n\\t\\t\\tvar x, centerIndexStart, centerIndexEnd;\\n\\n\\t\\t\\tvar uv = new Vector2();\\n\\t\\t\\tvar vertex = new Vector3();\\n\\n\\t\\t\\tvar groupCount = 0;\\n\\n\\t\\t\\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\\n\\t\\t\\tvar sign = ( top === true ) ? 1 : - 1;\\n\\n\\t\\t\\t// save the index of the first center vertex\\n\\t\\t\\tcenterIndexStart = index;\\n\\n\\t\\t\\t// first we generate the center vertex data of the cap.\\n\\t\\t\\t// because the geometry needs one set of uvs per face,\\n\\t\\t\\t// we must generate a center vertex per face/segment\\n\\n\\t\\t\\tfor ( x = 1; x <= radialSegments; x ++ ) {\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertices.push( 0, halfHeight * sign, 0 );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\tnormals.push( 0, sign, 0 );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuvs.push( 0.5, 0.5 );\\n\\n\\t\\t\\t\\t// increase index\\n\\n\\t\\t\\t\\tindex ++;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// save the index of the last center vertex\\n\\n\\t\\t\\tcenterIndexEnd = index;\\n\\n\\t\\t\\t// now we generate the surrounding vertices, normals and uvs\\n\\n\\t\\t\\tfor ( x = 0; x <= radialSegments; x ++ ) {\\n\\n\\t\\t\\t\\tvar u = x / radialSegments;\\n\\t\\t\\t\\tvar theta = u * thetaLength + thetaStart;\\n\\n\\t\\t\\t\\tvar cosTheta = Math.cos( theta );\\n\\t\\t\\t\\tvar sinTheta = Math.sin( theta );\\n\\n\\t\\t\\t\\t// vertex\\n\\n\\t\\t\\t\\tvertex.x = radius * sinTheta;\\n\\t\\t\\t\\tvertex.y = halfHeight * sign;\\n\\t\\t\\t\\tvertex.z = radius * cosTheta;\\n\\t\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t\\t// normal\\n\\n\\t\\t\\t\\tnormals.push( 0, sign, 0 );\\n\\n\\t\\t\\t\\t// uv\\n\\n\\t\\t\\t\\tuv.x = ( cosTheta * 0.5 ) + 0.5;\\n\\t\\t\\t\\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\\n\\t\\t\\t\\tuvs.push( uv.x, uv.y );\\n\\n\\t\\t\\t\\t// increase index\\n\\n\\t\\t\\t\\tindex ++;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// generate indices\\n\\n\\t\\t\\tfor ( x = 0; x < radialSegments; x ++ ) {\\n\\n\\t\\t\\t\\tvar c = centerIndexStart + x;\\n\\t\\t\\t\\tvar i = centerIndexEnd + x;\\n\\n\\t\\t\\t\\tif ( top === true ) {\\n\\n\\t\\t\\t\\t\\t// face top\\n\\n\\t\\t\\t\\t\\tindices.push( i, i + 1, c );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// face bottom\\n\\n\\t\\t\\t\\t\\tindices.push( i + 1, i, c );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgroupCount += 3;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// add a group to the geometry. this will ensure multi material support\\n\\n\\t\\t\\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\\n\\n\\t\\t\\t// calculate new start value for groups\\n\\n\\t\\t\\tgroupStart += groupCount;\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tCylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tCylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;\\n\\n\\t/**\\n\\t * @author abelnation / http://github.com/abelnation\\n\\t */\\n\\n\\t// ConeGeometry\\n\\n\\tfunction ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\n\\n\\t\\tCylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\\n\\n\\t\\tthis.type = 'ConeGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\theight: height,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\topenEnded: openEnded,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t}\\n\\n\\tConeGeometry.prototype = Object.create( CylinderGeometry.prototype );\\n\\tConeGeometry.prototype.constructor = ConeGeometry;\\n\\n\\t// ConeBufferGeometry\\n\\n\\tfunction ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\\n\\n\\t\\tCylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );\\n\\n\\t\\tthis.type = 'ConeBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\theight: height,\\n\\t\\t\\tradialSegments: radialSegments,\\n\\t\\t\\theightSegments: heightSegments,\\n\\t\\t\\topenEnded: openEnded,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t}\\n\\n\\tConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );\\n\\tConeBufferGeometry.prototype.constructor = ConeBufferGeometry;\\n\\n\\t/**\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t * @author hughes\\n\\t */\\n\\n\\t// CircleGeometry\\n\\n\\tfunction CircleGeometry( radius, segments, thetaStart, thetaLength ) {\\n\\n\\t\\tGeometry.call( this );\\n\\n\\t\\tthis.type = 'CircleGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tsegments: segments,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tthis.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\\n\\t\\tthis.mergeVertices();\\n\\n\\t}\\n\\n\\tCircleGeometry.prototype = Object.create( Geometry.prototype );\\n\\tCircleGeometry.prototype.constructor = CircleGeometry;\\n\\n\\t// CircleBufferGeometry\\n\\n\\tfunction CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'CircleBufferGeometry';\\n\\n\\t\\tthis.parameters = {\\n\\t\\t\\tradius: radius,\\n\\t\\t\\tsegments: segments,\\n\\t\\t\\tthetaStart: thetaStart,\\n\\t\\t\\tthetaLength: thetaLength\\n\\t\\t};\\n\\n\\t\\tradius = radius || 1;\\n\\t\\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\\n\\n\\t\\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\\n\\t\\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\\n\\n\\t\\t// buffers\\n\\n\\t\\tvar indices = [];\\n\\t\\tvar vertices = [];\\n\\t\\tvar normals = [];\\n\\t\\tvar uvs = [];\\n\\n\\t\\t// helper variables\\n\\n\\t\\tvar i, s;\\n\\t\\tvar vertex = new Vector3();\\n\\t\\tvar uv = new Vector2();\\n\\n\\t\\t// center point\\n\\n\\t\\tvertices.push( 0, 0, 0 );\\n\\t\\tnormals.push( 0, 0, 1 );\\n\\t\\tuvs.push( 0.5, 0.5 );\\n\\n\\t\\tfor ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {\\n\\n\\t\\t\\tvar segment = thetaStart + s / segments * thetaLength;\\n\\n\\t\\t\\t// vertex\\n\\n\\t\\t\\tvertex.x = radius * Math.cos( segment );\\n\\t\\t\\tvertex.y = radius * Math.sin( segment );\\n\\n\\t\\t\\tvertices.push( vertex.x, vertex.y, vertex.z );\\n\\n\\t\\t\\t// normal\\n\\n\\t\\t\\tnormals.push( 0, 0, 1 );\\n\\n\\t\\t\\t// uvs\\n\\n\\t\\t\\tuv.x = ( vertices[ i ] / radius + 1 ) / 2;\\n\\t\\t\\tuv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;\\n\\n\\t\\t\\tuvs.push( uv.x, uv.y );\\n\\n\\t\\t}\\n\\n\\t\\t// indices\\n\\n\\t\\tfor ( i = 1; i <= segments; i ++ ) {\\n\\n\\t\\t\\tindices.push( i, i + 1, 0 );\\n\\n\\t\\t}\\n\\n\\t\\t// build geometry\\n\\n\\t\\tthis.setIndex( indices );\\n\\t\\tthis.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tthis.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\\n\\t\\tthis.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\\n\\n\\t}\\n\\n\\tCircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );\\n\\tCircleBufferGeometry.prototype.constructor = CircleBufferGeometry;\\n\\n\\n\\n\\tvar Geometries = Object.freeze({\\n\\t\\tWireframeGeometry: WireframeGeometry,\\n\\t\\tParametricGeometry: ParametricGeometry,\\n\\t\\tParametricBufferGeometry: ParametricBufferGeometry,\\n\\t\\tTetrahedronGeometry: TetrahedronGeometry,\\n\\t\\tTetrahedronBufferGeometry: TetrahedronBufferGeometry,\\n\\t\\tOctahedronGeometry: OctahedronGeometry,\\n\\t\\tOctahedronBufferGeometry: OctahedronBufferGeometry,\\n\\t\\tIcosahedronGeometry: IcosahedronGeometry,\\n\\t\\tIcosahedronBufferGeometry: IcosahedronBufferGeometry,\\n\\t\\tDodecahedronGeometry: DodecahedronGeometry,\\n\\t\\tDodecahedronBufferGeometry: DodecahedronBufferGeometry,\\n\\t\\tPolyhedronGeometry: PolyhedronGeometry,\\n\\t\\tPolyhedronBufferGeometry: PolyhedronBufferGeometry,\\n\\t\\tTubeGeometry: TubeGeometry,\\n\\t\\tTubeBufferGeometry: TubeBufferGeometry,\\n\\t\\tTorusKnotGeometry: TorusKnotGeometry,\\n\\t\\tTorusKnotBufferGeometry: TorusKnotBufferGeometry,\\n\\t\\tTorusGeometry: TorusGeometry,\\n\\t\\tTorusBufferGeometry: TorusBufferGeometry,\\n\\t\\tTextGeometry: TextGeometry,\\n\\t\\tTextBufferGeometry: TextBufferGeometry,\\n\\t\\tSphereGeometry: SphereGeometry,\\n\\t\\tSphereBufferGeometry: SphereBufferGeometry,\\n\\t\\tRingGeometry: RingGeometry,\\n\\t\\tRingBufferGeometry: RingBufferGeometry,\\n\\t\\tPlaneGeometry: PlaneGeometry,\\n\\t\\tPlaneBufferGeometry: PlaneBufferGeometry,\\n\\t\\tLatheGeometry: LatheGeometry,\\n\\t\\tLatheBufferGeometry: LatheBufferGeometry,\\n\\t\\tShapeGeometry: ShapeGeometry,\\n\\t\\tShapeBufferGeometry: ShapeBufferGeometry,\\n\\t\\tExtrudeGeometry: ExtrudeGeometry,\\n\\t\\tExtrudeBufferGeometry: ExtrudeBufferGeometry,\\n\\t\\tEdgesGeometry: EdgesGeometry,\\n\\t\\tConeGeometry: ConeGeometry,\\n\\t\\tConeBufferGeometry: ConeBufferGeometry,\\n\\t\\tCylinderGeometry: CylinderGeometry,\\n\\t\\tCylinderBufferGeometry: CylinderBufferGeometry,\\n\\t\\tCircleGeometry: CircleGeometry,\\n\\t\\tCircleBufferGeometry: CircleBufferGeometry,\\n\\t\\tBoxGeometry: BoxGeometry,\\n\\t\\tBoxBufferGeometry: BoxBufferGeometry\\n\\t});\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <THREE.Color>,\\n\\t *  opacity: <float>\\n\\t * }\\n\\t */\\n\\n\\tfunction ShadowMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'ShadowMaterial';\\n\\n\\t\\tthis.color = new Color( 0x000000 );\\n\\t\\tthis.opacity = 1.0;\\n\\n\\t\\tthis.lights = true;\\n\\t\\tthis.transparent = true;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tShadowMaterial.prototype = Object.create( Material.prototype );\\n\\tShadowMaterial.prototype.constructor = ShadowMaterial;\\n\\n\\tShadowMaterial.prototype.isShadowMaterial = true;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction RawShaderMaterial( parameters ) {\\n\\n\\t\\tShaderMaterial.call( this, parameters );\\n\\n\\t\\tthis.type = 'RawShaderMaterial';\\n\\n\\t}\\n\\n\\tRawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );\\n\\tRawShaderMaterial.prototype.constructor = RawShaderMaterial;\\n\\n\\tRawShaderMaterial.prototype.isRawShaderMaterial = true;\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  roughness: <float>,\\n\\t *  metalness: <float>,\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  lightMap: new THREE.Texture( <Image> ),\\n\\t *  lightMapIntensity: <float>\\n\\t *\\n\\t *  aoMap: new THREE.Texture( <Image> ),\\n\\t *  aoMapIntensity: <float>\\n\\t *\\n\\t *  emissive: <hex>,\\n\\t *  emissiveIntensity: <float>\\n\\t *  emissiveMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  bumpMap: new THREE.Texture( <Image> ),\\n\\t *  bumpScale: <float>,\\n\\t *\\n\\t *  normalMap: new THREE.Texture( <Image> ),\\n\\t *  normalScale: <Vector2>,\\n\\t *\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\n\\t *  displacementScale: <float>,\\n\\t *  displacementBias: <float>,\\n\\t *\\n\\t *  roughnessMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  metalnessMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\\n\\t *  envMapIntensity: <float>\\n\\t *\\n\\t *  refractionRatio: <float>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>,\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>,\\n\\t *  morphNormals: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshStandardMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.defines = { 'STANDARD': '' };\\n\\n\\t\\tthis.type = 'MeshStandardMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff ); // diffuse\\n\\t\\tthis.roughness = 0.5;\\n\\t\\tthis.metalness = 0.5;\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.lightMap = null;\\n\\t\\tthis.lightMapIntensity = 1.0;\\n\\n\\t\\tthis.aoMap = null;\\n\\t\\tthis.aoMapIntensity = 1.0;\\n\\n\\t\\tthis.emissive = new Color( 0x000000 );\\n\\t\\tthis.emissiveIntensity = 1.0;\\n\\t\\tthis.emissiveMap = null;\\n\\n\\t\\tthis.bumpMap = null;\\n\\t\\tthis.bumpScale = 1;\\n\\n\\t\\tthis.normalMap = null;\\n\\t\\tthis.normalScale = new Vector2( 1, 1 );\\n\\n\\t\\tthis.displacementMap = null;\\n\\t\\tthis.displacementScale = 1;\\n\\t\\tthis.displacementBias = 0;\\n\\n\\t\\tthis.roughnessMap = null;\\n\\n\\t\\tthis.metalnessMap = null;\\n\\n\\t\\tthis.alphaMap = null;\\n\\n\\t\\tthis.envMap = null;\\n\\t\\tthis.envMapIntensity = 1.0;\\n\\n\\t\\tthis.refractionRatio = 0.98;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\t\\tthis.wireframeLinecap = 'round';\\n\\t\\tthis.wireframeLinejoin = 'round';\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\t\\tthis.morphNormals = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshStandardMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\\n\\n\\tMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\\n\\n\\tMeshStandardMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.defines = { 'STANDARD': '' };\\n\\n\\t\\tthis.color.copy( source.color );\\n\\t\\tthis.roughness = source.roughness;\\n\\t\\tthis.metalness = source.metalness;\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.lightMap = source.lightMap;\\n\\t\\tthis.lightMapIntensity = source.lightMapIntensity;\\n\\n\\t\\tthis.aoMap = source.aoMap;\\n\\t\\tthis.aoMapIntensity = source.aoMapIntensity;\\n\\n\\t\\tthis.emissive.copy( source.emissive );\\n\\t\\tthis.emissiveMap = source.emissiveMap;\\n\\t\\tthis.emissiveIntensity = source.emissiveIntensity;\\n\\n\\t\\tthis.bumpMap = source.bumpMap;\\n\\t\\tthis.bumpScale = source.bumpScale;\\n\\n\\t\\tthis.normalMap = source.normalMap;\\n\\t\\tthis.normalScale.copy( source.normalScale );\\n\\n\\t\\tthis.displacementMap = source.displacementMap;\\n\\t\\tthis.displacementScale = source.displacementScale;\\n\\t\\tthis.displacementBias = source.displacementBias;\\n\\n\\t\\tthis.roughnessMap = source.roughnessMap;\\n\\n\\t\\tthis.metalnessMap = source.metalnessMap;\\n\\n\\t\\tthis.alphaMap = source.alphaMap;\\n\\n\\t\\tthis.envMap = source.envMap;\\n\\t\\tthis.envMapIntensity = source.envMapIntensity;\\n\\n\\t\\tthis.refractionRatio = source.refractionRatio;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\t\\tthis.wireframeLinecap = source.wireframeLinecap;\\n\\t\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\t\\tthis.morphNormals = source.morphNormals;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t *\\n\\t * parameters = {\\n\\t *  reflectivity: <float>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshPhysicalMaterial( parameters ) {\\n\\n\\t\\tMeshStandardMaterial.call( this );\\n\\n\\t\\tthis.defines = { 'PHYSICAL': '' };\\n\\n\\t\\tthis.type = 'MeshPhysicalMaterial';\\n\\n\\t\\tthis.reflectivity = 0.5; // maps to F0 = 0.04\\n\\n\\t\\tthis.clearCoat = 0.0;\\n\\t\\tthis.clearCoatRoughness = 0.0;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );\\n\\tMeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;\\n\\n\\tMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\\n\\n\\tMeshPhysicalMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMeshStandardMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.defines = { 'PHYSICAL': '' };\\n\\n\\t\\tthis.reflectivity = source.reflectivity;\\n\\n\\t\\tthis.clearCoat = source.clearCoat;\\n\\t\\tthis.clearCoatRoughness = source.clearCoatRoughness;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  specular: <hex>,\\n\\t *  shininess: <float>,\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  lightMap: new THREE.Texture( <Image> ),\\n\\t *  lightMapIntensity: <float>\\n\\t *\\n\\t *  aoMap: new THREE.Texture( <Image> ),\\n\\t *  aoMapIntensity: <float>\\n\\t *\\n\\t *  emissive: <hex>,\\n\\t *  emissiveIntensity: <float>\\n\\t *  emissiveMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  bumpMap: new THREE.Texture( <Image> ),\\n\\t *  bumpScale: <float>,\\n\\t *\\n\\t *  normalMap: new THREE.Texture( <Image> ),\\n\\t *  normalScale: <Vector2>,\\n\\t *\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\n\\t *  displacementScale: <float>,\\n\\t *  displacementBias: <float>,\\n\\t *\\n\\t *  specularMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\\n\\t *  combine: THREE.Multiply,\\n\\t *  reflectivity: <float>,\\n\\t *  refractionRatio: <float>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>,\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>,\\n\\t *  morphNormals: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshPhongMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'MeshPhongMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff ); // diffuse\\n\\t\\tthis.specular = new Color( 0x111111 );\\n\\t\\tthis.shininess = 30;\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.lightMap = null;\\n\\t\\tthis.lightMapIntensity = 1.0;\\n\\n\\t\\tthis.aoMap = null;\\n\\t\\tthis.aoMapIntensity = 1.0;\\n\\n\\t\\tthis.emissive = new Color( 0x000000 );\\n\\t\\tthis.emissiveIntensity = 1.0;\\n\\t\\tthis.emissiveMap = null;\\n\\n\\t\\tthis.bumpMap = null;\\n\\t\\tthis.bumpScale = 1;\\n\\n\\t\\tthis.normalMap = null;\\n\\t\\tthis.normalScale = new Vector2( 1, 1 );\\n\\n\\t\\tthis.displacementMap = null;\\n\\t\\tthis.displacementScale = 1;\\n\\t\\tthis.displacementBias = 0;\\n\\n\\t\\tthis.specularMap = null;\\n\\n\\t\\tthis.alphaMap = null;\\n\\n\\t\\tthis.envMap = null;\\n\\t\\tthis.combine = MultiplyOperation;\\n\\t\\tthis.reflectivity = 1;\\n\\t\\tthis.refractionRatio = 0.98;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\t\\tthis.wireframeLinecap = 'round';\\n\\t\\tthis.wireframeLinejoin = 'round';\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\t\\tthis.morphNormals = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshPhongMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshPhongMaterial.prototype.constructor = MeshPhongMaterial;\\n\\n\\tMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\\n\\n\\tMeshPhongMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.color.copy( source.color );\\n\\t\\tthis.specular.copy( source.specular );\\n\\t\\tthis.shininess = source.shininess;\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.lightMap = source.lightMap;\\n\\t\\tthis.lightMapIntensity = source.lightMapIntensity;\\n\\n\\t\\tthis.aoMap = source.aoMap;\\n\\t\\tthis.aoMapIntensity = source.aoMapIntensity;\\n\\n\\t\\tthis.emissive.copy( source.emissive );\\n\\t\\tthis.emissiveMap = source.emissiveMap;\\n\\t\\tthis.emissiveIntensity = source.emissiveIntensity;\\n\\n\\t\\tthis.bumpMap = source.bumpMap;\\n\\t\\tthis.bumpScale = source.bumpScale;\\n\\n\\t\\tthis.normalMap = source.normalMap;\\n\\t\\tthis.normalScale.copy( source.normalScale );\\n\\n\\t\\tthis.displacementMap = source.displacementMap;\\n\\t\\tthis.displacementScale = source.displacementScale;\\n\\t\\tthis.displacementBias = source.displacementBias;\\n\\n\\t\\tthis.specularMap = source.specularMap;\\n\\n\\t\\tthis.alphaMap = source.alphaMap;\\n\\n\\t\\tthis.envMap = source.envMap;\\n\\t\\tthis.combine = source.combine;\\n\\t\\tthis.reflectivity = source.reflectivity;\\n\\t\\tthis.refractionRatio = source.refractionRatio;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\t\\tthis.wireframeLinecap = source.wireframeLinecap;\\n\\t\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\t\\tthis.morphNormals = source.morphNormals;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author takahirox / http://github.com/takahirox\\n\\t *\\n\\t * parameters = {\\n\\t *  gradientMap: new THREE.Texture( <Image> )\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshToonMaterial( parameters ) {\\n\\n\\t\\tMeshPhongMaterial.call( this );\\n\\n\\t\\tthis.defines = { 'TOON': '' };\\n\\n\\t\\tthis.type = 'MeshToonMaterial';\\n\\n\\t\\tthis.gradientMap = null;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );\\n\\tMeshToonMaterial.prototype.constructor = MeshToonMaterial;\\n\\n\\tMeshToonMaterial.prototype.isMeshToonMaterial = true;\\n\\n\\tMeshToonMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMeshPhongMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.gradientMap = source.gradientMap;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t *\\n\\t * parameters = {\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  bumpMap: new THREE.Texture( <Image> ),\\n\\t *  bumpScale: <float>,\\n\\t *\\n\\t *  normalMap: new THREE.Texture( <Image> ),\\n\\t *  normalScale: <Vector2>,\\n\\t *\\n\\t *  displacementMap: new THREE.Texture( <Image> ),\\n\\t *  displacementScale: <float>,\\n\\t *  displacementBias: <float>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>,\\n\\t *  morphNormals: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshNormalMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'MeshNormalMaterial';\\n\\n\\t\\tthis.bumpMap = null;\\n\\t\\tthis.bumpScale = 1;\\n\\n\\t\\tthis.normalMap = null;\\n\\t\\tthis.normalScale = new Vector2( 1, 1 );\\n\\n\\t\\tthis.displacementMap = null;\\n\\t\\tthis.displacementScale = 1;\\n\\t\\tthis.displacementBias = 0;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\n\\t\\tthis.fog = false;\\n\\t\\tthis.lights = false;\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\t\\tthis.morphNormals = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshNormalMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshNormalMaterial.prototype.constructor = MeshNormalMaterial;\\n\\n\\tMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\\n\\n\\tMeshNormalMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.bumpMap = source.bumpMap;\\n\\t\\tthis.bumpScale = source.bumpScale;\\n\\n\\t\\tthis.normalMap = source.normalMap;\\n\\t\\tthis.normalScale.copy( source.normalScale );\\n\\n\\t\\tthis.displacementMap = source.displacementMap;\\n\\t\\tthis.displacementScale = source.displacementScale;\\n\\t\\tthis.displacementBias = source.displacementBias;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\t\\tthis.morphNormals = source.morphNormals;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  map: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  lightMap: new THREE.Texture( <Image> ),\\n\\t *  lightMapIntensity: <float>\\n\\t *\\n\\t *  aoMap: new THREE.Texture( <Image> ),\\n\\t *  aoMapIntensity: <float>\\n\\t *\\n\\t *  emissive: <hex>,\\n\\t *  emissiveIntensity: <float>\\n\\t *  emissiveMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  specularMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  alphaMap: new THREE.Texture( <Image> ),\\n\\t *\\n\\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\\n\\t *  combine: THREE.Multiply,\\n\\t *  reflectivity: <float>,\\n\\t *  refractionRatio: <float>,\\n\\t *\\n\\t *  wireframe: <boolean>,\\n\\t *  wireframeLinewidth: <float>,\\n\\t *\\n\\t *  skinning: <bool>,\\n\\t *  morphTargets: <bool>,\\n\\t *  morphNormals: <bool>\\n\\t * }\\n\\t */\\n\\n\\tfunction MeshLambertMaterial( parameters ) {\\n\\n\\t\\tMaterial.call( this );\\n\\n\\t\\tthis.type = 'MeshLambertMaterial';\\n\\n\\t\\tthis.color = new Color( 0xffffff ); // diffuse\\n\\n\\t\\tthis.map = null;\\n\\n\\t\\tthis.lightMap = null;\\n\\t\\tthis.lightMapIntensity = 1.0;\\n\\n\\t\\tthis.aoMap = null;\\n\\t\\tthis.aoMapIntensity = 1.0;\\n\\n\\t\\tthis.emissive = new Color( 0x000000 );\\n\\t\\tthis.emissiveIntensity = 1.0;\\n\\t\\tthis.emissiveMap = null;\\n\\n\\t\\tthis.specularMap = null;\\n\\n\\t\\tthis.alphaMap = null;\\n\\n\\t\\tthis.envMap = null;\\n\\t\\tthis.combine = MultiplyOperation;\\n\\t\\tthis.reflectivity = 1;\\n\\t\\tthis.refractionRatio = 0.98;\\n\\n\\t\\tthis.wireframe = false;\\n\\t\\tthis.wireframeLinewidth = 1;\\n\\t\\tthis.wireframeLinecap = 'round';\\n\\t\\tthis.wireframeLinejoin = 'round';\\n\\n\\t\\tthis.skinning = false;\\n\\t\\tthis.morphTargets = false;\\n\\t\\tthis.morphNormals = false;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tMeshLambertMaterial.prototype = Object.create( Material.prototype );\\n\\tMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\\n\\n\\tMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\\n\\n\\tMeshLambertMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.color.copy( source.color );\\n\\n\\t\\tthis.map = source.map;\\n\\n\\t\\tthis.lightMap = source.lightMap;\\n\\t\\tthis.lightMapIntensity = source.lightMapIntensity;\\n\\n\\t\\tthis.aoMap = source.aoMap;\\n\\t\\tthis.aoMapIntensity = source.aoMapIntensity;\\n\\n\\t\\tthis.emissive.copy( source.emissive );\\n\\t\\tthis.emissiveMap = source.emissiveMap;\\n\\t\\tthis.emissiveIntensity = source.emissiveIntensity;\\n\\n\\t\\tthis.specularMap = source.specularMap;\\n\\n\\t\\tthis.alphaMap = source.alphaMap;\\n\\n\\t\\tthis.envMap = source.envMap;\\n\\t\\tthis.combine = source.combine;\\n\\t\\tthis.reflectivity = source.reflectivity;\\n\\t\\tthis.refractionRatio = source.refractionRatio;\\n\\n\\t\\tthis.wireframe = source.wireframe;\\n\\t\\tthis.wireframeLinewidth = source.wireframeLinewidth;\\n\\t\\tthis.wireframeLinecap = source.wireframeLinecap;\\n\\t\\tthis.wireframeLinejoin = source.wireframeLinejoin;\\n\\n\\t\\tthis.skinning = source.skinning;\\n\\t\\tthis.morphTargets = source.morphTargets;\\n\\t\\tthis.morphNormals = source.morphNormals;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t *\\n\\t * parameters = {\\n\\t *  color: <hex>,\\n\\t *  opacity: <float>,\\n\\t *\\n\\t *  linewidth: <float>,\\n\\t *\\n\\t *  scale: <float>,\\n\\t *  dashSize: <float>,\\n\\t *  gapSize: <float>\\n\\t * }\\n\\t */\\n\\n\\tfunction LineDashedMaterial( parameters ) {\\n\\n\\t\\tLineBasicMaterial.call( this );\\n\\n\\t\\tthis.type = 'LineDashedMaterial';\\n\\n\\t\\tthis.scale = 1;\\n\\t\\tthis.dashSize = 3;\\n\\t\\tthis.gapSize = 1;\\n\\n\\t\\tthis.setValues( parameters );\\n\\n\\t}\\n\\n\\tLineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );\\n\\tLineDashedMaterial.prototype.constructor = LineDashedMaterial;\\n\\n\\tLineDashedMaterial.prototype.isLineDashedMaterial = true;\\n\\n\\tLineDashedMaterial.prototype.copy = function ( source ) {\\n\\n\\t\\tLineBasicMaterial.prototype.copy.call( this, source );\\n\\n\\t\\tthis.scale = source.scale;\\n\\t\\tthis.dashSize = source.dashSize;\\n\\t\\tthis.gapSize = source.gapSize;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\n\\n\\tvar Materials = Object.freeze({\\n\\t\\tShadowMaterial: ShadowMaterial,\\n\\t\\tSpriteMaterial: SpriteMaterial,\\n\\t\\tRawShaderMaterial: RawShaderMaterial,\\n\\t\\tShaderMaterial: ShaderMaterial,\\n\\t\\tPointsMaterial: PointsMaterial,\\n\\t\\tMeshPhysicalMaterial: MeshPhysicalMaterial,\\n\\t\\tMeshStandardMaterial: MeshStandardMaterial,\\n\\t\\tMeshPhongMaterial: MeshPhongMaterial,\\n\\t\\tMeshToonMaterial: MeshToonMaterial,\\n\\t\\tMeshNormalMaterial: MeshNormalMaterial,\\n\\t\\tMeshLambertMaterial: MeshLambertMaterial,\\n\\t\\tMeshDepthMaterial: MeshDepthMaterial,\\n\\t\\tMeshDistanceMaterial: MeshDistanceMaterial,\\n\\t\\tMeshBasicMaterial: MeshBasicMaterial,\\n\\t\\tLineDashedMaterial: LineDashedMaterial,\\n\\t\\tLineBasicMaterial: LineBasicMaterial,\\n\\t\\tMaterial: Material\\n\\t});\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar Cache = {\\n\\n\\t\\tenabled: false,\\n\\n\\t\\tfiles: {},\\n\\n\\t\\tadd: function ( key, file ) {\\n\\n\\t\\t\\tif ( this.enabled === false ) return;\\n\\n\\t\\t\\t// console.log( 'THREE.Cache', 'Adding key:', key );\\n\\n\\t\\t\\tthis.files[ key ] = file;\\n\\n\\t\\t},\\n\\n\\t\\tget: function ( key ) {\\n\\n\\t\\t\\tif ( this.enabled === false ) return;\\n\\n\\t\\t\\t// console.log( 'THREE.Cache', 'Checking key:', key );\\n\\n\\t\\t\\treturn this.files[ key ];\\n\\n\\t\\t},\\n\\n\\t\\tremove: function ( key ) {\\n\\n\\t\\t\\tdelete this.files[ key ];\\n\\n\\t\\t},\\n\\n\\t\\tclear: function () {\\n\\n\\t\\t\\tthis.files = {};\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction LoadingManager( onLoad, onProgress, onError ) {\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tvar isLoading = false;\\n\\t\\tvar itemsLoaded = 0;\\n\\t\\tvar itemsTotal = 0;\\n\\t\\tvar urlModifier = undefined;\\n\\n\\t\\tthis.onStart = undefined;\\n\\t\\tthis.onLoad = onLoad;\\n\\t\\tthis.onProgress = onProgress;\\n\\t\\tthis.onError = onError;\\n\\n\\t\\tthis.itemStart = function ( url ) {\\n\\n\\t\\t\\titemsTotal ++;\\n\\n\\t\\t\\tif ( isLoading === false ) {\\n\\n\\t\\t\\t\\tif ( scope.onStart !== undefined ) {\\n\\n\\t\\t\\t\\t\\tscope.onStart( url, itemsLoaded, itemsTotal );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tisLoading = true;\\n\\n\\t\\t};\\n\\n\\t\\tthis.itemEnd = function ( url ) {\\n\\n\\t\\t\\titemsLoaded ++;\\n\\n\\t\\t\\tif ( scope.onProgress !== undefined ) {\\n\\n\\t\\t\\t\\tscope.onProgress( url, itemsLoaded, itemsTotal );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( itemsLoaded === itemsTotal ) {\\n\\n\\t\\t\\t\\tisLoading = false;\\n\\n\\t\\t\\t\\tif ( scope.onLoad !== undefined ) {\\n\\n\\t\\t\\t\\t\\tscope.onLoad();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tthis.itemError = function ( url ) {\\n\\n\\t\\t\\tif ( scope.onError !== undefined ) {\\n\\n\\t\\t\\t\\tscope.onError( url );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t\\tthis.resolveURL = function ( url ) {\\n\\n\\t\\t\\tif ( urlModifier ) {\\n\\n\\t\\t\\t\\treturn urlModifier( url );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn url;\\n\\n\\t\\t};\\n\\n\\t\\tthis.setURLModifier = function ( transform ) {\\n\\n\\t\\t\\turlModifier = transform;\\n\\t\\t\\treturn this;\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\tvar DefaultLoadingManager = new LoadingManager();\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar loading = {};\\n\\n\\tfunction FileLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( FileLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tif ( url === undefined ) url = '';\\n\\n\\t\\t\\tif ( this.path !== undefined ) url = this.path + url;\\n\\n\\t\\t\\turl = this.manager.resolveURL( url );\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar cached = Cache.get( url );\\n\\n\\t\\t\\tif ( cached !== undefined ) {\\n\\n\\t\\t\\t\\tscope.manager.itemStart( url );\\n\\n\\t\\t\\t\\tsetTimeout( function () {\\n\\n\\t\\t\\t\\t\\tif ( onLoad ) onLoad( cached );\\n\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t}, 0 );\\n\\n\\t\\t\\t\\treturn cached;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Check if request is duplicate\\n\\n\\t\\t\\tif ( loading[ url ] !== undefined ) {\\n\\n\\t\\t\\t\\tloading[ url ].push( {\\n\\n\\t\\t\\t\\t\\tonLoad: onLoad,\\n\\t\\t\\t\\t\\tonProgress: onProgress,\\n\\t\\t\\t\\t\\tonError: onError\\n\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Check for data: URI\\n\\t\\t\\tvar dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\\n\\t\\t\\tvar dataUriRegexResult = url.match( dataUriRegex );\\n\\n\\t\\t\\t// Safari can not handle Data URIs through XMLHttpRequest so process manually\\n\\t\\t\\tif ( dataUriRegexResult ) {\\n\\n\\t\\t\\t\\tvar mimeType = dataUriRegexResult[ 1 ];\\n\\t\\t\\t\\tvar isBase64 = !! dataUriRegexResult[ 2 ];\\n\\t\\t\\t\\tvar data = dataUriRegexResult[ 3 ];\\n\\n\\t\\t\\t\\tdata = window.decodeURIComponent( data );\\n\\n\\t\\t\\t\\tif ( isBase64 ) data = window.atob( data );\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\tvar response;\\n\\t\\t\\t\\t\\tvar responseType = ( this.responseType || '' ).toLowerCase();\\n\\n\\t\\t\\t\\t\\tswitch ( responseType ) {\\n\\n\\t\\t\\t\\t\\t\\tcase 'arraybuffer':\\n\\t\\t\\t\\t\\t\\tcase 'blob':\\n\\n\\t\\t\\t\\t\\t\\t\\tvar view = new Uint8Array( data.length );\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < data.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tview[ i ] = data.charCodeAt( i );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( responseType === 'blob' ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tresponse = new Blob( [ view.buffer ], { type: mimeType } );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tresponse = view.buffer;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'document':\\n\\n\\t\\t\\t\\t\\t\\t\\tvar parser = new DOMParser();\\n\\t\\t\\t\\t\\t\\t\\tresponse = parser.parseFromString( data, mimeType );\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'json':\\n\\n\\t\\t\\t\\t\\t\\t\\tresponse = JSON.parse( data );\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tdefault: // 'text' or other\\n\\n\\t\\t\\t\\t\\t\\t\\tresponse = data;\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\\n\\t\\t\\t\\t\\twindow.setTimeout( function () {\\n\\n\\t\\t\\t\\t\\t\\tif ( onLoad ) onLoad( response );\\n\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t\\t}, 0 );\\n\\n\\t\\t\\t\\t} catch ( error ) {\\n\\n\\t\\t\\t\\t\\t// Wait for next browser tick like standard XMLHttpRequest event dispatching does\\n\\t\\t\\t\\t\\twindow.setTimeout( function () {\\n\\n\\t\\t\\t\\t\\t\\tif ( onError ) onError( error );\\n\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\t\\t\\t\\t\\t\\tscope.manager.itemError( url );\\n\\n\\t\\t\\t\\t\\t}, 0 );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// Initialise array for duplicate requests\\n\\n\\t\\t\\t\\tloading[ url ] = [];\\n\\n\\t\\t\\t\\tloading[ url ].push( {\\n\\n\\t\\t\\t\\t\\tonLoad: onLoad,\\n\\t\\t\\t\\t\\tonProgress: onProgress,\\n\\t\\t\\t\\t\\tonError: onError\\n\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\tvar request = new XMLHttpRequest();\\n\\n\\t\\t\\t\\trequest.open( 'GET', url, true );\\n\\n\\t\\t\\t\\trequest.addEventListener( 'load', function ( event ) {\\n\\n\\t\\t\\t\\t\\tvar response = this.response;\\n\\n\\t\\t\\t\\t\\tCache.add( url, response );\\n\\n\\t\\t\\t\\t\\tvar callbacks = loading[ url ];\\n\\n\\t\\t\\t\\t\\tdelete loading[ url ];\\n\\n\\t\\t\\t\\t\\tif ( this.status === 200 ) {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\n\\t\\t\\t\\t\\t\\t\\tif ( callback.onLoad ) callback.onLoad( response );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t\\t} else if ( this.status === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t// Some browsers return HTTP Status 0 when using non-http protocol\\n\\t\\t\\t\\t\\t\\t// e.g. 'file://' or 'data://'. Handle as success.\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.FileLoader: HTTP Status 0 received.' );\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\n\\t\\t\\t\\t\\t\\t\\tif ( callback.onLoad ) callback.onLoad( response );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\n\\t\\t\\t\\t\\t\\t\\tif ( callback.onError ) callback.onError( event );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\t\\t\\t\\t\\t\\tscope.manager.itemError( url );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}, false );\\n\\n\\t\\t\\t\\trequest.addEventListener( 'progress', function ( event ) {\\n\\n\\t\\t\\t\\t\\tvar callbacks = loading[ url ];\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\n\\t\\t\\t\\t\\t\\tif ( callback.onProgress ) callback.onProgress( event );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}, false );\\n\\n\\t\\t\\t\\trequest.addEventListener( 'error', function ( event ) {\\n\\n\\t\\t\\t\\t\\tvar callbacks = loading[ url ];\\n\\n\\t\\t\\t\\t\\tdelete loading[ url ];\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, il = callbacks.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar callback = callbacks[ i ];\\n\\t\\t\\t\\t\\t\\tif ( callback.onError ) callback.onError( event );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\t\\t\\t\\t\\tscope.manager.itemError( url );\\n\\n\\t\\t\\t\\t}, false );\\n\\n\\t\\t\\t\\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\\n\\t\\t\\t\\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\\n\\n\\t\\t\\t\\tif ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );\\n\\n\\t\\t\\t\\tfor ( var header in this.requestHeader ) {\\n\\n\\t\\t\\t\\t\\trequest.setRequestHeader( header, this.requestHeader[ header ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\trequest.send( null );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscope.manager.itemStart( url );\\n\\n\\t\\t\\treturn request;\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetResponseType: function ( value ) {\\n\\n\\t\\t\\tthis.responseType = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetWithCredentials: function ( value ) {\\n\\n\\t\\t\\tthis.withCredentials = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetMimeType: function ( value ) {\\n\\n\\t\\t\\tthis.mimeType = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetRequestHeader: function ( value ) {\\n\\n\\t\\t\\tthis.requestHeader = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t *\\n\\t * Abstract Base class to block based textures loader (dds, pvr, ...)\\n\\t */\\n\\n\\tfunction CompressedTextureLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t\\t// override in sub classes\\n\\t\\tthis._parser = null;\\n\\n\\t}\\n\\n\\tObject.assign( CompressedTextureLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar images = [];\\n\\n\\t\\t\\tvar texture = new CompressedTexture();\\n\\t\\t\\ttexture.image = images;\\n\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\n\\t\\t\\tloader.setPath( this.path );\\n\\t\\t\\tloader.setResponseType( 'arraybuffer' );\\n\\n\\t\\t\\tfunction loadTexture( i ) {\\n\\n\\t\\t\\t\\tloader.load( url[ i ], function ( buffer ) {\\n\\n\\t\\t\\t\\t\\tvar texDatas = scope._parser( buffer, true );\\n\\n\\t\\t\\t\\t\\timages[ i ] = {\\n\\t\\t\\t\\t\\t\\twidth: texDatas.width,\\n\\t\\t\\t\\t\\t\\theight: texDatas.height,\\n\\t\\t\\t\\t\\t\\tformat: texDatas.format,\\n\\t\\t\\t\\t\\t\\tmipmaps: texDatas.mipmaps\\n\\t\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t\\tloaded += 1;\\n\\n\\t\\t\\t\\t\\tif ( loaded === 6 ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( texDatas.mipmapCount === 1 )\\n\\t\\t\\t\\t\\t\\t\\ttexture.minFilter = LinearFilter;\\n\\n\\t\\t\\t\\t\\t\\ttexture.format = texDatas.format;\\n\\t\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\t\\t\\tif ( onLoad ) onLoad( texture );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( Array.isArray( url ) ) {\\n\\n\\t\\t\\t\\tvar loaded = 0;\\n\\n\\t\\t\\t\\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\\n\\n\\t\\t\\t\\t\\tloadTexture( i );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// compressed cubemap texture stored in a single DDS file\\n\\n\\t\\t\\t\\tloader.load( url, function ( buffer ) {\\n\\n\\t\\t\\t\\t\\tvar texDatas = scope._parser( buffer, true );\\n\\n\\t\\t\\t\\t\\tif ( texDatas.isCubemap ) {\\n\\n\\t\\t\\t\\t\\t\\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var f = 0; f < faces; f ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\timages[ f ] = { mipmaps: [] };\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\\n\\t\\t\\t\\t\\t\\t\\t\\timages[ f ].format = texDatas.format;\\n\\t\\t\\t\\t\\t\\t\\t\\timages[ f ].width = texDatas.width;\\n\\t\\t\\t\\t\\t\\t\\t\\timages[ f ].height = texDatas.height;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\ttexture.image.width = texDatas.width;\\n\\t\\t\\t\\t\\t\\ttexture.image.height = texDatas.height;\\n\\t\\t\\t\\t\\t\\ttexture.mipmaps = texDatas.mipmaps;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( texDatas.mipmapCount === 1 ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.minFilter = LinearFilter;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttexture.format = texDatas.format;\\n\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\t\\tif ( onLoad ) onLoad( texture );\\n\\n\\t\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author Nikos M. / https://github.com/foo123/\\n\\t *\\n\\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\\n\\t */\\n\\n\\tfunction DataTextureLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t\\t// override in sub classes\\n\\t\\tthis._parser = null;\\n\\n\\t}\\n\\n\\tObject.assign( DataTextureLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar texture = new DataTexture();\\n\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\n\\t\\t\\tloader.setResponseType( 'arraybuffer' );\\n\\n\\t\\t\\tloader.load( url, function ( buffer ) {\\n\\n\\t\\t\\t\\tvar texData = scope._parser( buffer );\\n\\n\\t\\t\\t\\tif ( ! texData ) return;\\n\\n\\t\\t\\t\\tif ( undefined !== texData.image ) {\\n\\n\\t\\t\\t\\t\\ttexture.image = texData.image;\\n\\n\\t\\t\\t\\t} else if ( undefined !== texData.data ) {\\n\\n\\t\\t\\t\\t\\ttexture.image.width = texData.width;\\n\\t\\t\\t\\t\\ttexture.image.height = texData.height;\\n\\t\\t\\t\\t\\ttexture.image.data = texData.data;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;\\n\\t\\t\\t\\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;\\n\\n\\t\\t\\t\\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;\\n\\t\\t\\t\\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;\\n\\n\\t\\t\\t\\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\\n\\n\\t\\t\\t\\tif ( undefined !== texData.format ) {\\n\\n\\t\\t\\t\\t\\ttexture.format = texData.format;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( undefined !== texData.type ) {\\n\\n\\t\\t\\t\\t\\ttexture.type = texData.type;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( undefined !== texData.mipmaps ) {\\n\\n\\t\\t\\t\\t\\ttexture.mipmaps = texData.mipmaps;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( 1 === texData.mipmapCount ) {\\n\\n\\t\\t\\t\\t\\ttexture.minFilter = LinearFilter;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\tif ( onLoad ) onLoad( texture, texData );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction ImageLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( ImageLoader.prototype, {\\n\\n\\t\\tcrossOrigin: 'Anonymous',\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tif ( url === undefined ) url = '';\\n\\n\\t\\t\\tif ( this.path !== undefined ) url = this.path + url;\\n\\n\\t\\t\\turl = this.manager.resolveURL( url );\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar cached = Cache.get( url );\\n\\n\\t\\t\\tif ( cached !== undefined ) {\\n\\n\\t\\t\\t\\tscope.manager.itemStart( url );\\n\\n\\t\\t\\t\\tsetTimeout( function () {\\n\\n\\t\\t\\t\\t\\tif ( onLoad ) onLoad( cached );\\n\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t}, 0 );\\n\\n\\t\\t\\t\\treturn cached;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\\n\\n\\t\\t\\timage.addEventListener( 'load', function () {\\n\\n\\t\\t\\t\\tCache.add( url, this );\\n\\n\\t\\t\\t\\tif ( onLoad ) onLoad( this );\\n\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t}, false );\\n\\n\\t\\t\\t/*\\n\\t\\t\\timage.addEventListener( 'progress', function ( event ) {\\n\\n\\t\\t\\t\\tif ( onProgress ) onProgress( event );\\n\\n\\t\\t\\t}, false );\\n\\t\\t\\t*/\\n\\n\\t\\t\\timage.addEventListener( 'error', function ( event ) {\\n\\n\\t\\t\\t\\tif ( onError ) onError( event );\\n\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\t\\t\\t\\tscope.manager.itemError( url );\\n\\n\\t\\t\\t}, false );\\n\\n\\t\\t\\tif ( url.substr( 0, 5 ) !== 'data:' ) {\\n\\n\\t\\t\\t\\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tscope.manager.itemStart( url );\\n\\n\\t\\t\\timage.src = url;\\n\\n\\t\\t\\treturn image;\\n\\n\\t\\t},\\n\\n\\t\\tsetCrossOrigin: function ( value ) {\\n\\n\\t\\t\\tthis.crossOrigin = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction CubeTextureLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( CubeTextureLoader.prototype, {\\n\\n\\t\\tcrossOrigin: 'Anonymous',\\n\\n\\t\\tload: function ( urls, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar texture = new CubeTexture();\\n\\n\\t\\t\\tvar loader = new ImageLoader( this.manager );\\n\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\t\\t\\tloader.setPath( this.path );\\n\\n\\t\\t\\tvar loaded = 0;\\n\\n\\t\\t\\tfunction loadTexture( i ) {\\n\\n\\t\\t\\t\\tloader.load( urls[ i ], function ( image ) {\\n\\n\\t\\t\\t\\t\\ttexture.images[ i ] = image;\\n\\n\\t\\t\\t\\t\\tloaded ++;\\n\\n\\t\\t\\t\\t\\tif ( loaded === 6 ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\t\\t\\tif ( onLoad ) onLoad( texture );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}, undefined, onError );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0; i < urls.length; ++ i ) {\\n\\n\\t\\t\\t\\tloadTexture( i );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t},\\n\\n\\t\\tsetCrossOrigin: function ( value ) {\\n\\n\\t\\t\\tthis.crossOrigin = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction TextureLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( TextureLoader.prototype, {\\n\\n\\t\\tcrossOrigin: 'Anonymous',\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar texture = new Texture();\\n\\n\\t\\t\\tvar loader = new ImageLoader( this.manager );\\n\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\t\\t\\tloader.setPath( this.path );\\n\\n\\t\\t\\tloader.load( url, function ( image ) {\\n\\n\\t\\t\\t\\ttexture.image = image;\\n\\n\\t\\t\\t\\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\\n\\t\\t\\t\\tvar isJPEG = url.search( /\\\\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\\\\:image\\\\/jpeg/ ) === 0;\\n\\n\\t\\t\\t\\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\\n\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\tif ( onLoad !== undefined ) {\\n\\n\\t\\t\\t\\t\\tonLoad( texture );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t},\\n\\n\\t\\tsetCrossOrigin: function ( value ) {\\n\\n\\t\\t\\tthis.crossOrigin = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * Extensible curve object\\n\\t *\\n\\t * Some common of curve methods:\\n\\t * .getPoint( t, optionalTarget ), .getTangent( t )\\n\\t * .getPointAt( u, optionalTarget ), .getTangentAt( u )\\n\\t * .getPoints(), .getSpacedPoints()\\n\\t * .getLength()\\n\\t * .updateArcLengths()\\n\\t *\\n\\t * This following curves inherit from THREE.Curve:\\n\\t *\\n\\t * -- 2D curves --\\n\\t * THREE.ArcCurve\\n\\t * THREE.CubicBezierCurve\\n\\t * THREE.EllipseCurve\\n\\t * THREE.LineCurve\\n\\t * THREE.QuadraticBezierCurve\\n\\t * THREE.SplineCurve\\n\\t *\\n\\t * -- 3D curves --\\n\\t * THREE.CatmullRomCurve3\\n\\t * THREE.CubicBezierCurve3\\n\\t * THREE.LineCurve3\\n\\t * THREE.QuadraticBezierCurve3\\n\\t *\\n\\t * A series of curves can be represented as a THREE.CurvePath.\\n\\t *\\n\\t **/\\n\\n\\t/**************************************************************\\n\\t *\\tAbstract Curve base class\\n\\t **************************************************************/\\n\\n\\tfunction Curve() {\\n\\n\\t\\tthis.type = 'Curve';\\n\\n\\t\\tthis.arcLengthDivisions = 200;\\n\\n\\t}\\n\\n\\tObject.assign( Curve.prototype, {\\n\\n\\t\\t// Virtual base class method to overwrite and implement in subclasses\\n\\t\\t//\\t- t [0 .. 1]\\n\\n\\t\\tgetPoint: function ( /* t, optionalTarget */ ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\\n\\t\\t\\treturn null;\\n\\n\\t\\t},\\n\\n\\t\\t// Get point at relative position in curve according to arc length\\n\\t\\t// - u [0 .. 1]\\n\\n\\t\\tgetPointAt: function ( u, optionalTarget ) {\\n\\n\\t\\t\\tvar t = this.getUtoTmapping( u );\\n\\t\\t\\treturn this.getPoint( t, optionalTarget );\\n\\n\\t\\t},\\n\\n\\t\\t// Get sequence of points using getPoint( t )\\n\\n\\t\\tgetPoints: function ( divisions ) {\\n\\n\\t\\t\\tif ( divisions === undefined ) divisions = 5;\\n\\n\\t\\t\\tvar points = [];\\n\\n\\t\\t\\tfor ( var d = 0; d <= divisions; d ++ ) {\\n\\n\\t\\t\\t\\tpoints.push( this.getPoint( d / divisions ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn points;\\n\\n\\t\\t},\\n\\n\\t\\t// Get sequence of points using getPointAt( u )\\n\\n\\t\\tgetSpacedPoints: function ( divisions ) {\\n\\n\\t\\t\\tif ( divisions === undefined ) divisions = 5;\\n\\n\\t\\t\\tvar points = [];\\n\\n\\t\\t\\tfor ( var d = 0; d <= divisions; d ++ ) {\\n\\n\\t\\t\\t\\tpoints.push( this.getPointAt( d / divisions ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn points;\\n\\n\\t\\t},\\n\\n\\t\\t// Get total curve arc length\\n\\n\\t\\tgetLength: function () {\\n\\n\\t\\t\\tvar lengths = this.getLengths();\\n\\t\\t\\treturn lengths[ lengths.length - 1 ];\\n\\n\\t\\t},\\n\\n\\t\\t// Get list of cumulative segment lengths\\n\\n\\t\\tgetLengths: function ( divisions ) {\\n\\n\\t\\t\\tif ( divisions === undefined ) divisions = this.arcLengthDivisions;\\n\\n\\t\\t\\tif ( this.cacheArcLengths &&\\n\\t\\t\\t\\t( this.cacheArcLengths.length === divisions + 1 ) &&\\n\\t\\t\\t\\t! this.needsUpdate ) {\\n\\n\\t\\t\\t\\treturn this.cacheArcLengths;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.needsUpdate = false;\\n\\n\\t\\t\\tvar cache = [];\\n\\t\\t\\tvar current, last = this.getPoint( 0 );\\n\\t\\t\\tvar p, sum = 0;\\n\\n\\t\\t\\tcache.push( 0 );\\n\\n\\t\\t\\tfor ( p = 1; p <= divisions; p ++ ) {\\n\\n\\t\\t\\t\\tcurrent = this.getPoint( p / divisions );\\n\\t\\t\\t\\tsum += current.distanceTo( last );\\n\\t\\t\\t\\tcache.push( sum );\\n\\t\\t\\t\\tlast = current;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.cacheArcLengths = cache;\\n\\n\\t\\t\\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\\n\\n\\t\\t},\\n\\n\\t\\tupdateArcLengths: function () {\\n\\n\\t\\t\\tthis.needsUpdate = true;\\n\\t\\t\\tthis.getLengths();\\n\\n\\t\\t},\\n\\n\\t\\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\\n\\n\\t\\tgetUtoTmapping: function ( u, distance ) {\\n\\n\\t\\t\\tvar arcLengths = this.getLengths();\\n\\n\\t\\t\\tvar i = 0, il = arcLengths.length;\\n\\n\\t\\t\\tvar targetArcLength; // The targeted u distance value to get\\n\\n\\t\\t\\tif ( distance ) {\\n\\n\\t\\t\\t\\ttargetArcLength = distance;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\ttargetArcLength = u * arcLengths[ il - 1 ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// binary search for the index with largest value smaller than target u distance\\n\\n\\t\\t\\tvar low = 0, high = il - 1, comparison;\\n\\n\\t\\t\\twhile ( low <= high ) {\\n\\n\\t\\t\\t\\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\\n\\n\\t\\t\\t\\tcomparison = arcLengths[ i ] - targetArcLength;\\n\\n\\t\\t\\t\\tif ( comparison < 0 ) {\\n\\n\\t\\t\\t\\t\\tlow = i + 1;\\n\\n\\t\\t\\t\\t} else if ( comparison > 0 ) {\\n\\n\\t\\t\\t\\t\\thigh = i - 1;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\thigh = i;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t// DONE\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\ti = high;\\n\\n\\t\\t\\tif ( arcLengths[ i ] === targetArcLength ) {\\n\\n\\t\\t\\t\\treturn i / ( il - 1 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// we could get finer grain at lengths, or use simple interpolation between two points\\n\\n\\t\\t\\tvar lengthBefore = arcLengths[ i ];\\n\\t\\t\\tvar lengthAfter = arcLengths[ i + 1 ];\\n\\n\\t\\t\\tvar segmentLength = lengthAfter - lengthBefore;\\n\\n\\t\\t\\t// determine where we are between the 'before' and 'after' points\\n\\n\\t\\t\\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\\n\\n\\t\\t\\t// add that fractional amount to t\\n\\n\\t\\t\\tvar t = ( i + segmentFraction ) / ( il - 1 );\\n\\n\\t\\t\\treturn t;\\n\\n\\t\\t},\\n\\n\\t\\t// Returns a unit vector tangent at t\\n\\t\\t// In case any sub curve does not implement its tangent derivation,\\n\\t\\t// 2 points a small delta apart will be used to find its gradient\\n\\t\\t// which seems to give a reasonable approximation\\n\\n\\t\\tgetTangent: function ( t ) {\\n\\n\\t\\t\\tvar delta = 0.0001;\\n\\t\\t\\tvar t1 = t - delta;\\n\\t\\t\\tvar t2 = t + delta;\\n\\n\\t\\t\\t// Capping in case of danger\\n\\n\\t\\t\\tif ( t1 < 0 ) t1 = 0;\\n\\t\\t\\tif ( t2 > 1 ) t2 = 1;\\n\\n\\t\\t\\tvar pt1 = this.getPoint( t1 );\\n\\t\\t\\tvar pt2 = this.getPoint( t2 );\\n\\n\\t\\t\\tvar vec = pt2.clone().sub( pt1 );\\n\\t\\t\\treturn vec.normalize();\\n\\n\\t\\t},\\n\\n\\t\\tgetTangentAt: function ( u ) {\\n\\n\\t\\t\\tvar t = this.getUtoTmapping( u );\\n\\t\\t\\treturn this.getTangent( t );\\n\\n\\t\\t},\\n\\n\\t\\tcomputeFrenetFrames: function ( segments, closed ) {\\n\\n\\t\\t\\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\\n\\n\\t\\t\\tvar normal = new Vector3();\\n\\n\\t\\t\\tvar tangents = [];\\n\\t\\t\\tvar normals = [];\\n\\t\\t\\tvar binormals = [];\\n\\n\\t\\t\\tvar vec = new Vector3();\\n\\t\\t\\tvar mat = new Matrix4();\\n\\n\\t\\t\\tvar i, u, theta;\\n\\n\\t\\t\\t// compute the tangent vectors for each segment on the curve\\n\\n\\t\\t\\tfor ( i = 0; i <= segments; i ++ ) {\\n\\n\\t\\t\\t\\tu = i / segments;\\n\\n\\t\\t\\t\\ttangents[ i ] = this.getTangentAt( u );\\n\\t\\t\\t\\ttangents[ i ].normalize();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// select an initial normal vector perpendicular to the first tangent vector,\\n\\t\\t\\t// and in the direction of the minimum tangent xyz component\\n\\n\\t\\t\\tnormals[ 0 ] = new Vector3();\\n\\t\\t\\tbinormals[ 0 ] = new Vector3();\\n\\t\\t\\tvar min = Number.MAX_VALUE;\\n\\t\\t\\tvar tx = Math.abs( tangents[ 0 ].x );\\n\\t\\t\\tvar ty = Math.abs( tangents[ 0 ].y );\\n\\t\\t\\tvar tz = Math.abs( tangents[ 0 ].z );\\n\\n\\t\\t\\tif ( tx <= min ) {\\n\\n\\t\\t\\t\\tmin = tx;\\n\\t\\t\\t\\tnormal.set( 1, 0, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( ty <= min ) {\\n\\n\\t\\t\\t\\tmin = ty;\\n\\t\\t\\t\\tnormal.set( 0, 1, 0 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( tz <= min ) {\\n\\n\\t\\t\\t\\tnormal.set( 0, 0, 1 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\\n\\n\\t\\t\\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\\n\\t\\t\\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\\n\\n\\n\\t\\t\\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\\n\\n\\t\\t\\tfor ( i = 1; i <= segments; i ++ ) {\\n\\n\\t\\t\\t\\tnormals[ i ] = normals[ i - 1 ].clone();\\n\\n\\t\\t\\t\\tbinormals[ i ] = binormals[ i - 1 ].clone();\\n\\n\\t\\t\\t\\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\\n\\n\\t\\t\\t\\tif ( vec.length() > Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\tvec.normalize();\\n\\n\\t\\t\\t\\t\\ttheta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\\n\\n\\t\\t\\t\\t\\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\\n\\n\\t\\t\\tif ( closed === true ) {\\n\\n\\t\\t\\t\\ttheta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\\n\\t\\t\\t\\ttheta /= segments;\\n\\n\\t\\t\\t\\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\\n\\n\\t\\t\\t\\t\\ttheta = - theta;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( i = 1; i <= segments; i ++ ) {\\n\\n\\t\\t\\t\\t\\t// twist a little...\\n\\t\\t\\t\\t\\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\\n\\t\\t\\t\\t\\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\ttangents: tangents,\\n\\t\\t\\t\\tnormals: normals,\\n\\t\\t\\t\\tbinormals: binormals\\n\\t\\t\\t};\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.arcLengthDivisions = source.arcLengthDivisions;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar data = {\\n\\t\\t\\t\\tmetadata: {\\n\\t\\t\\t\\t\\tversion: 4.5,\\n\\t\\t\\t\\t\\ttype: 'Curve',\\n\\t\\t\\t\\t\\tgenerator: 'Curve.toJSON'\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\n\\t\\t\\tdata.arcLengthDivisions = this.arcLengthDivisions;\\n\\t\\t\\tdata.type = this.type;\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tfromJSON: function ( json ) {\\n\\n\\t\\t\\tthis.arcLengthDivisions = json.arcLengthDivisions;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tfunction EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'EllipseCurve';\\n\\n\\t\\tthis.aX = aX || 0;\\n\\t\\tthis.aY = aY || 0;\\n\\n\\t\\tthis.xRadius = xRadius || 1;\\n\\t\\tthis.yRadius = yRadius || 1;\\n\\n\\t\\tthis.aStartAngle = aStartAngle || 0;\\n\\t\\tthis.aEndAngle = aEndAngle || 2 * Math.PI;\\n\\n\\t\\tthis.aClockwise = aClockwise || false;\\n\\n\\t\\tthis.aRotation = aRotation || 0;\\n\\n\\t}\\n\\n\\tEllipseCurve.prototype = Object.create( Curve.prototype );\\n\\tEllipseCurve.prototype.constructor = EllipseCurve;\\n\\n\\tEllipseCurve.prototype.isEllipseCurve = true;\\n\\n\\tEllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector2();\\n\\n\\t\\tvar twoPi = Math.PI * 2;\\n\\t\\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\\n\\t\\tvar samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\\n\\n\\t\\t// ensures that deltaAngle is 0 .. 2 PI\\n\\t\\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\\n\\t\\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\\n\\n\\t\\tif ( deltaAngle < Number.EPSILON ) {\\n\\n\\t\\t\\tif ( samePoints ) {\\n\\n\\t\\t\\t\\tdeltaAngle = 0;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdeltaAngle = twoPi;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tif ( this.aClockwise === true && ! samePoints ) {\\n\\n\\t\\t\\tif ( deltaAngle === twoPi ) {\\n\\n\\t\\t\\t\\tdeltaAngle = - twoPi;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tdeltaAngle = deltaAngle - twoPi;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvar angle = this.aStartAngle + t * deltaAngle;\\n\\t\\tvar x = this.aX + this.xRadius * Math.cos( angle );\\n\\t\\tvar y = this.aY + this.yRadius * Math.sin( angle );\\n\\n\\t\\tif ( this.aRotation !== 0 ) {\\n\\n\\t\\t\\tvar cos = Math.cos( this.aRotation );\\n\\t\\t\\tvar sin = Math.sin( this.aRotation );\\n\\n\\t\\t\\tvar tx = x - this.aX;\\n\\t\\t\\tvar ty = y - this.aY;\\n\\n\\t\\t\\t// Rotate the point about the center of the ellipse.\\n\\t\\t\\tx = tx * cos - ty * sin + this.aX;\\n\\t\\t\\ty = tx * sin + ty * cos + this.aY;\\n\\n\\t\\t}\\n\\n\\t\\treturn point.set( x, y );\\n\\n\\t};\\n\\n\\tEllipseCurve.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.aX = source.aX;\\n\\t\\tthis.aY = source.aY;\\n\\n\\t\\tthis.xRadius = source.xRadius;\\n\\t\\tthis.yRadius = source.yRadius;\\n\\n\\t\\tthis.aStartAngle = source.aStartAngle;\\n\\t\\tthis.aEndAngle = source.aEndAngle;\\n\\n\\t\\tthis.aClockwise = source.aClockwise;\\n\\n\\t\\tthis.aRotation = source.aRotation;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\n\\tEllipseCurve.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.aX = this.aX;\\n\\t\\tdata.aY = this.aY;\\n\\n\\t\\tdata.xRadius = this.xRadius;\\n\\t\\tdata.yRadius = this.yRadius;\\n\\n\\t\\tdata.aStartAngle = this.aStartAngle;\\n\\t\\tdata.aEndAngle = this.aEndAngle;\\n\\n\\t\\tdata.aClockwise = this.aClockwise;\\n\\n\\t\\tdata.aRotation = this.aRotation;\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tEllipseCurve.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.aX = json.aX;\\n\\t\\tthis.aY = json.aY;\\n\\n\\t\\tthis.xRadius = json.xRadius;\\n\\t\\tthis.yRadius = json.yRadius;\\n\\n\\t\\tthis.aStartAngle = json.aStartAngle;\\n\\t\\tthis.aEndAngle = json.aEndAngle;\\n\\n\\t\\tthis.aClockwise = json.aClockwise;\\n\\n\\t\\tthis.aRotation = json.aRotation;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\\n\\n\\t\\tEllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\\n\\n\\t\\tthis.type = 'ArcCurve';\\n\\n\\t}\\n\\n\\tArcCurve.prototype = Object.create( EllipseCurve.prototype );\\n\\tArcCurve.prototype.constructor = ArcCurve;\\n\\n\\tArcCurve.prototype.isArcCurve = true;\\n\\n\\t/**\\n\\t * @author zz85 https://github.com/zz85\\n\\t *\\n\\t * Centripetal CatmullRom Curve - which is useful for avoiding\\n\\t * cusps and self-intersections in non-uniform catmull rom curves.\\n\\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\\n\\t *\\n\\t * curve.type accepts centripetal(default), chordal and catmullrom\\n\\t * curve.tension is used for catmullrom which defaults to 0.5\\n\\t */\\n\\n\\n\\t/*\\n\\tBased on an optimized c++ solution in\\n\\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\\n\\t - http://ideone.com/NoEbVM\\n\\n\\tThis CubicPoly class could be used for reusing some variables and calculations,\\n\\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\\n\\twhich can be placed in CurveUtils.\\n\\t*/\\n\\n\\tfunction CubicPoly() {\\n\\n\\t\\tvar c0 = 0, c1 = 0, c2 = 0, c3 = 0;\\n\\n\\t\\t/*\\n\\t\\t * Compute coefficients for a cubic polynomial\\n\\t\\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\\n\\t\\t * such that\\n\\t\\t *   p(0) = x0, p(1) = x1\\n\\t\\t *  and\\n\\t\\t *   p'(0) = t0, p'(1) = t1.\\n\\t\\t */\\n\\t\\tfunction init( x0, x1, t0, t1 ) {\\n\\n\\t\\t\\tc0 = x0;\\n\\t\\t\\tc1 = t0;\\n\\t\\t\\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\\n\\t\\t\\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\\n\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\n\\t\\t\\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\\n\\n\\t\\t\\t\\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\\n\\n\\t\\t\\t\\t// compute tangents when parameterized in [t1,t2]\\n\\t\\t\\t\\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\\n\\t\\t\\t\\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\\n\\n\\t\\t\\t\\t// rescale tangents for parametrization in [0,1]\\n\\t\\t\\t\\tt1 *= dt1;\\n\\t\\t\\t\\tt2 *= dt1;\\n\\n\\t\\t\\t\\tinit( x1, x2, t1, t2 );\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tcalc: function ( t ) {\\n\\n\\t\\t\\t\\tvar t2 = t * t;\\n\\t\\t\\t\\tvar t3 = t2 * t;\\n\\t\\t\\t\\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t//\\n\\n\\tvar tmp = new Vector3();\\n\\tvar px = new CubicPoly();\\n\\tvar py = new CubicPoly();\\n\\tvar pz = new CubicPoly();\\n\\n\\tfunction CatmullRomCurve3( points, closed, curveType, tension ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'CatmullRomCurve3';\\n\\n\\t\\tthis.points = points || [];\\n\\t\\tthis.closed = closed || false;\\n\\t\\tthis.curveType = curveType || 'centripetal';\\n\\t\\tthis.tension = tension || 0.5;\\n\\n\\t}\\n\\n\\tCatmullRomCurve3.prototype = Object.create( Curve.prototype );\\n\\tCatmullRomCurve3.prototype.constructor = CatmullRomCurve3;\\n\\n\\tCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\\n\\n\\tCatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector3();\\n\\n\\t\\tvar points = this.points;\\n\\t\\tvar l = points.length;\\n\\n\\t\\tvar p = ( l - ( this.closed ? 0 : 1 ) ) * t;\\n\\t\\tvar intPoint = Math.floor( p );\\n\\t\\tvar weight = p - intPoint;\\n\\n\\t\\tif ( this.closed ) {\\n\\n\\t\\t\\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\\n\\n\\t\\t} else if ( weight === 0 && intPoint === l - 1 ) {\\n\\n\\t\\t\\tintPoint = l - 2;\\n\\t\\t\\tweight = 1;\\n\\n\\t\\t}\\n\\n\\t\\tvar p0, p1, p2, p3; // 4 points\\n\\n\\t\\tif ( this.closed || intPoint > 0 ) {\\n\\n\\t\\t\\tp0 = points[ ( intPoint - 1 ) % l ];\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// extrapolate first point\\n\\t\\t\\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\\n\\t\\t\\tp0 = tmp;\\n\\n\\t\\t}\\n\\n\\t\\tp1 = points[ intPoint % l ];\\n\\t\\tp2 = points[ ( intPoint + 1 ) % l ];\\n\\n\\t\\tif ( this.closed || intPoint + 2 < l ) {\\n\\n\\t\\t\\tp3 = points[ ( intPoint + 2 ) % l ];\\n\\n\\t\\t} else {\\n\\n\\t\\t\\t// extrapolate last point\\n\\t\\t\\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\\n\\t\\t\\tp3 = tmp;\\n\\n\\t\\t}\\n\\n\\t\\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\\n\\n\\t\\t\\t// init Centripetal / Chordal Catmull-Rom\\n\\t\\t\\tvar pow = this.curveType === 'chordal' ? 0.5 : 0.25;\\n\\t\\t\\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\\n\\t\\t\\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\\n\\t\\t\\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\\n\\n\\t\\t\\t// safety check for repeated points\\n\\t\\t\\tif ( dt1 < 1e-4 ) dt1 = 1.0;\\n\\t\\t\\tif ( dt0 < 1e-4 ) dt0 = dt1;\\n\\t\\t\\tif ( dt2 < 1e-4 ) dt2 = dt1;\\n\\n\\t\\t\\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\\n\\t\\t\\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\\n\\t\\t\\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\\n\\n\\t\\t} else if ( this.curveType === 'catmullrom' ) {\\n\\n\\t\\t\\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\\n\\t\\t\\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\\n\\t\\t\\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\\n\\n\\t\\t}\\n\\n\\t\\tpoint.set(\\n\\t\\t\\tpx.calc( weight ),\\n\\t\\t\\tpy.calc( weight ),\\n\\t\\t\\tpz.calc( weight )\\n\\t\\t);\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\tCatmullRomCurve3.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.points = [];\\n\\n\\t\\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar point = source.points[ i ];\\n\\n\\t\\t\\tthis.points.push( point.clone() );\\n\\n\\t\\t}\\n\\n\\t\\tthis.closed = source.closed;\\n\\t\\tthis.curveType = source.curveType;\\n\\t\\tthis.tension = source.tension;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tCatmullRomCurve3.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.points = [];\\n\\n\\t\\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar point = this.points[ i ];\\n\\t\\t\\tdata.points.push( point.toArray() );\\n\\n\\t\\t}\\n\\n\\t\\tdata.closed = this.closed;\\n\\t\\tdata.curveType = this.curveType;\\n\\t\\tdata.tension = this.tension;\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tCatmullRomCurve3.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.points = [];\\n\\n\\t\\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar point = json.points[ i ];\\n\\t\\t\\tthis.points.push( new Vector3().fromArray( point ) );\\n\\n\\t\\t}\\n\\n\\t\\tthis.closed = json.closed;\\n\\t\\tthis.curveType = json.curveType;\\n\\t\\tthis.tension = json.tension;\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t *\\n\\t * Bezier Curves formulas obtained from\\n\\t * http://en.wikipedia.org/wiki/Bzier_curve\\n\\t */\\n\\n\\tfunction CatmullRom( t, p0, p1, p2, p3 ) {\\n\\n\\t\\tvar v0 = ( p2 - p0 ) * 0.5;\\n\\t\\tvar v1 = ( p3 - p1 ) * 0.5;\\n\\t\\tvar t2 = t * t;\\n\\t\\tvar t3 = t * t2;\\n\\t\\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\\n\\n\\t}\\n\\n\\t//\\n\\n\\tfunction QuadraticBezierP0( t, p ) {\\n\\n\\t\\tvar k = 1 - t;\\n\\t\\treturn k * k * p;\\n\\n\\t}\\n\\n\\tfunction QuadraticBezierP1( t, p ) {\\n\\n\\t\\treturn 2 * ( 1 - t ) * t * p;\\n\\n\\t}\\n\\n\\tfunction QuadraticBezierP2( t, p ) {\\n\\n\\t\\treturn t * t * p;\\n\\n\\t}\\n\\n\\tfunction QuadraticBezier( t, p0, p1, p2 ) {\\n\\n\\t\\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\\n\\t\\t\\tQuadraticBezierP2( t, p2 );\\n\\n\\t}\\n\\n\\t//\\n\\n\\tfunction CubicBezierP0( t, p ) {\\n\\n\\t\\tvar k = 1 - t;\\n\\t\\treturn k * k * k * p;\\n\\n\\t}\\n\\n\\tfunction CubicBezierP1( t, p ) {\\n\\n\\t\\tvar k = 1 - t;\\n\\t\\treturn 3 * k * k * t * p;\\n\\n\\t}\\n\\n\\tfunction CubicBezierP2( t, p ) {\\n\\n\\t\\treturn 3 * ( 1 - t ) * t * t * p;\\n\\n\\t}\\n\\n\\tfunction CubicBezierP3( t, p ) {\\n\\n\\t\\treturn t * t * t * p;\\n\\n\\t}\\n\\n\\tfunction CubicBezier( t, p0, p1, p2, p3 ) {\\n\\n\\t\\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\\n\\t\\t\\tCubicBezierP3( t, p3 );\\n\\n\\t}\\n\\n\\tfunction CubicBezierCurve( v0, v1, v2, v3 ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'CubicBezierCurve';\\n\\n\\t\\tthis.v0 = v0 || new Vector2();\\n\\t\\tthis.v1 = v1 || new Vector2();\\n\\t\\tthis.v2 = v2 || new Vector2();\\n\\t\\tthis.v3 = v3 || new Vector2();\\n\\n\\t}\\n\\n\\tCubicBezierCurve.prototype = Object.create( Curve.prototype );\\n\\tCubicBezierCurve.prototype.constructor = CubicBezierCurve;\\n\\n\\tCubicBezierCurve.prototype.isCubicBezierCurve = true;\\n\\n\\tCubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector2();\\n\\n\\t\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\\n\\n\\t\\tpoint.set(\\n\\t\\t\\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\\n\\t\\t\\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\\n\\t\\t);\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\tCubicBezierCurve.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.v0.copy( source.v0 );\\n\\t\\tthis.v1.copy( source.v1 );\\n\\t\\tthis.v2.copy( source.v2 );\\n\\t\\tthis.v3.copy( source.v3 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tCubicBezierCurve.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.v0 = this.v0.toArray();\\n\\t\\tdata.v1 = this.v1.toArray();\\n\\t\\tdata.v2 = this.v2.toArray();\\n\\t\\tdata.v3 = this.v3.toArray();\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tCubicBezierCurve.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.v0.fromArray( json.v0 );\\n\\t\\tthis.v1.fromArray( json.v1 );\\n\\t\\tthis.v2.fromArray( json.v2 );\\n\\t\\tthis.v3.fromArray( json.v3 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction CubicBezierCurve3( v0, v1, v2, v3 ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'CubicBezierCurve3';\\n\\n\\t\\tthis.v0 = v0 || new Vector3();\\n\\t\\tthis.v1 = v1 || new Vector3();\\n\\t\\tthis.v2 = v2 || new Vector3();\\n\\t\\tthis.v3 = v3 || new Vector3();\\n\\n\\t}\\n\\n\\tCubicBezierCurve3.prototype = Object.create( Curve.prototype );\\n\\tCubicBezierCurve3.prototype.constructor = CubicBezierCurve3;\\n\\n\\tCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\\n\\n\\tCubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector3();\\n\\n\\t\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\\n\\n\\t\\tpoint.set(\\n\\t\\t\\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\\n\\t\\t\\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\\n\\t\\t\\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\\n\\t\\t);\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\tCubicBezierCurve3.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.v0.copy( source.v0 );\\n\\t\\tthis.v1.copy( source.v1 );\\n\\t\\tthis.v2.copy( source.v2 );\\n\\t\\tthis.v3.copy( source.v3 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tCubicBezierCurve3.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.v0 = this.v0.toArray();\\n\\t\\tdata.v1 = this.v1.toArray();\\n\\t\\tdata.v2 = this.v2.toArray();\\n\\t\\tdata.v3 = this.v3.toArray();\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tCubicBezierCurve3.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.v0.fromArray( json.v0 );\\n\\t\\tthis.v1.fromArray( json.v1 );\\n\\t\\tthis.v2.fromArray( json.v2 );\\n\\t\\tthis.v3.fromArray( json.v3 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction LineCurve( v1, v2 ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'LineCurve';\\n\\n\\t\\tthis.v1 = v1 || new Vector2();\\n\\t\\tthis.v2 = v2 || new Vector2();\\n\\n\\t}\\n\\n\\tLineCurve.prototype = Object.create( Curve.prototype );\\n\\tLineCurve.prototype.constructor = LineCurve;\\n\\n\\tLineCurve.prototype.isLineCurve = true;\\n\\n\\tLineCurve.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector2();\\n\\n\\t\\tif ( t === 1 ) {\\n\\n\\t\\t\\tpoint.copy( this.v2 );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tpoint.copy( this.v2 ).sub( this.v1 );\\n\\t\\t\\tpoint.multiplyScalar( t ).add( this.v1 );\\n\\n\\t\\t}\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\t// Line curve is linear, so we can overwrite default getPointAt\\n\\n\\tLineCurve.prototype.getPointAt = function ( u, optionalTarget ) {\\n\\n\\t\\treturn this.getPoint( u, optionalTarget );\\n\\n\\t};\\n\\n\\tLineCurve.prototype.getTangent = function ( /* t */ ) {\\n\\n\\t\\tvar tangent = this.v2.clone().sub( this.v1 );\\n\\n\\t\\treturn tangent.normalize();\\n\\n\\t};\\n\\n\\tLineCurve.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.v1.copy( source.v1 );\\n\\t\\tthis.v2.copy( source.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tLineCurve.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.v1 = this.v1.toArray();\\n\\t\\tdata.v2 = this.v2.toArray();\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tLineCurve.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.v1.fromArray( json.v1 );\\n\\t\\tthis.v2.fromArray( json.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction LineCurve3( v1, v2 ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'LineCurve3';\\n\\n\\t\\tthis.v1 = v1 || new Vector3();\\n\\t\\tthis.v2 = v2 || new Vector3();\\n\\n\\t}\\n\\n\\tLineCurve3.prototype = Object.create( Curve.prototype );\\n\\tLineCurve3.prototype.constructor = LineCurve3;\\n\\n\\tLineCurve3.prototype.isLineCurve3 = true;\\n\\n\\tLineCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector3();\\n\\n\\t\\tif ( t === 1 ) {\\n\\n\\t\\t\\tpoint.copy( this.v2 );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tpoint.copy( this.v2 ).sub( this.v1 );\\n\\t\\t\\tpoint.multiplyScalar( t ).add( this.v1 );\\n\\n\\t\\t}\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\t// Line curve is linear, so we can overwrite default getPointAt\\n\\n\\tLineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {\\n\\n\\t\\treturn this.getPoint( u, optionalTarget );\\n\\n\\t};\\n\\n\\tLineCurve3.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.v1.copy( source.v1 );\\n\\t\\tthis.v2.copy( source.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tLineCurve3.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.v1 = this.v1.toArray();\\n\\t\\tdata.v2 = this.v2.toArray();\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tLineCurve3.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.v1.fromArray( json.v1 );\\n\\t\\tthis.v2.fromArray( json.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction QuadraticBezierCurve( v0, v1, v2 ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'QuadraticBezierCurve';\\n\\n\\t\\tthis.v0 = v0 || new Vector2();\\n\\t\\tthis.v1 = v1 || new Vector2();\\n\\t\\tthis.v2 = v2 || new Vector2();\\n\\n\\t}\\n\\n\\tQuadraticBezierCurve.prototype = Object.create( Curve.prototype );\\n\\tQuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;\\n\\n\\tQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\\n\\n\\tQuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector2();\\n\\n\\t\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\\n\\n\\t\\tpoint.set(\\n\\t\\t\\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\\n\\t\\t\\tQuadraticBezier( t, v0.y, v1.y, v2.y )\\n\\t\\t);\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\tQuadraticBezierCurve.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.v0.copy( source.v0 );\\n\\t\\tthis.v1.copy( source.v1 );\\n\\t\\tthis.v2.copy( source.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tQuadraticBezierCurve.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.v0 = this.v0.toArray();\\n\\t\\tdata.v1 = this.v1.toArray();\\n\\t\\tdata.v2 = this.v2.toArray();\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tQuadraticBezierCurve.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.v0.fromArray( json.v0 );\\n\\t\\tthis.v1.fromArray( json.v1 );\\n\\t\\tthis.v2.fromArray( json.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction QuadraticBezierCurve3( v0, v1, v2 ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'QuadraticBezierCurve3';\\n\\n\\t\\tthis.v0 = v0 || new Vector3();\\n\\t\\tthis.v1 = v1 || new Vector3();\\n\\t\\tthis.v2 = v2 || new Vector3();\\n\\n\\t}\\n\\n\\tQuadraticBezierCurve3.prototype = Object.create( Curve.prototype );\\n\\tQuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;\\n\\n\\tQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\\n\\n\\tQuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector3();\\n\\n\\t\\tvar v0 = this.v0, v1 = this.v1, v2 = this.v2;\\n\\n\\t\\tpoint.set(\\n\\t\\t\\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\\n\\t\\t\\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\\n\\t\\t\\tQuadraticBezier( t, v0.z, v1.z, v2.z )\\n\\t\\t);\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\tQuadraticBezierCurve3.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.v0.copy( source.v0 );\\n\\t\\tthis.v1.copy( source.v1 );\\n\\t\\tthis.v2.copy( source.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tQuadraticBezierCurve3.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.v0 = this.v0.toArray();\\n\\t\\tdata.v1 = this.v1.toArray();\\n\\t\\tdata.v2 = this.v2.toArray();\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tQuadraticBezierCurve3.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.v0.fromArray( json.v0 );\\n\\t\\tthis.v1.fromArray( json.v1 );\\n\\t\\tthis.v2.fromArray( json.v2 );\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tfunction SplineCurve( points /* array of Vector2 */ ) {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'SplineCurve';\\n\\n\\t\\tthis.points = points || [];\\n\\n\\t}\\n\\n\\tSplineCurve.prototype = Object.create( Curve.prototype );\\n\\tSplineCurve.prototype.constructor = SplineCurve;\\n\\n\\tSplineCurve.prototype.isSplineCurve = true;\\n\\n\\tSplineCurve.prototype.getPoint = function ( t, optionalTarget ) {\\n\\n\\t\\tvar point = optionalTarget || new Vector2();\\n\\n\\t\\tvar points = this.points;\\n\\t\\tvar p = ( points.length - 1 ) * t;\\n\\n\\t\\tvar intPoint = Math.floor( p );\\n\\t\\tvar weight = p - intPoint;\\n\\n\\t\\tvar p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\\n\\t\\tvar p1 = points[ intPoint ];\\n\\t\\tvar p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\\n\\t\\tvar p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\\n\\n\\t\\tpoint.set(\\n\\t\\t\\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\\n\\t\\t\\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\\n\\t\\t);\\n\\n\\t\\treturn point;\\n\\n\\t};\\n\\n\\tSplineCurve.prototype.copy = function ( source ) {\\n\\n\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\tthis.points = [];\\n\\n\\t\\tfor ( var i = 0, l = source.points.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar point = source.points[ i ];\\n\\n\\t\\t\\tthis.points.push( point.clone() );\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tSplineCurve.prototype.toJSON = function () {\\n\\n\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\tdata.points = [];\\n\\n\\t\\tfor ( var i = 0, l = this.points.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar point = this.points[ i ];\\n\\t\\t\\tdata.points.push( point.toArray() );\\n\\n\\t\\t}\\n\\n\\t\\treturn data;\\n\\n\\t};\\n\\n\\tSplineCurve.prototype.fromJSON = function ( json ) {\\n\\n\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\tthis.points = [];\\n\\n\\t\\tfor ( var i = 0, l = json.points.length; i < l; i ++ ) {\\n\\n\\t\\t\\tvar point = json.points[ i ];\\n\\t\\t\\tthis.points.push( new Vector2().fromArray( point ) );\\n\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\n\\n\\tvar Curves = Object.freeze({\\n\\t\\tArcCurve: ArcCurve,\\n\\t\\tCatmullRomCurve3: CatmullRomCurve3,\\n\\t\\tCubicBezierCurve: CubicBezierCurve,\\n\\t\\tCubicBezierCurve3: CubicBezierCurve3,\\n\\t\\tEllipseCurve: EllipseCurve,\\n\\t\\tLineCurve: LineCurve,\\n\\t\\tLineCurve3: LineCurve3,\\n\\t\\tQuadraticBezierCurve: QuadraticBezierCurve,\\n\\t\\tQuadraticBezierCurve3: QuadraticBezierCurve3,\\n\\t\\tSplineCurve: SplineCurve\\n\\t});\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t *\\n\\t **/\\n\\n\\t/**************************************************************\\n\\t *\\tCurved Path - a curve path is simply a array of connected\\n\\t *  curves, but retains the api of a curve\\n\\t **************************************************************/\\n\\n\\tfunction CurvePath() {\\n\\n\\t\\tCurve.call( this );\\n\\n\\t\\tthis.type = 'CurvePath';\\n\\n\\t\\tthis.curves = [];\\n\\t\\tthis.autoClose = false; // Automatically closes the path\\n\\n\\t}\\n\\n\\tCurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {\\n\\n\\t\\tconstructor: CurvePath,\\n\\n\\t\\tadd: function ( curve ) {\\n\\n\\t\\t\\tthis.curves.push( curve );\\n\\n\\t\\t},\\n\\n\\t\\tclosePath: function () {\\n\\n\\t\\t\\t// Add a line curve if start and end of lines are not connected\\n\\t\\t\\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\\n\\t\\t\\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\\n\\n\\t\\t\\tif ( ! startPoint.equals( endPoint ) ) {\\n\\n\\t\\t\\t\\tthis.curves.push( new LineCurve( endPoint, startPoint ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t// To get accurate point with reference to\\n\\t\\t// entire path distance at time t,\\n\\t\\t// following has to be done:\\n\\n\\t\\t// 1. Length of each sub path have to be known\\n\\t\\t// 2. Locate and identify type of curve\\n\\t\\t// 3. Get t for the curve\\n\\t\\t// 4. Return curve.getPointAt(t')\\n\\n\\t\\tgetPoint: function ( t ) {\\n\\n\\t\\t\\tvar d = t * this.getLength();\\n\\t\\t\\tvar curveLengths = this.getCurveLengths();\\n\\t\\t\\tvar i = 0;\\n\\n\\t\\t\\t// To think about boundaries points.\\n\\n\\t\\t\\twhile ( i < curveLengths.length ) {\\n\\n\\t\\t\\t\\tif ( curveLengths[ i ] >= d ) {\\n\\n\\t\\t\\t\\t\\tvar diff = curveLengths[ i ] - d;\\n\\t\\t\\t\\t\\tvar curve = this.curves[ i ];\\n\\n\\t\\t\\t\\t\\tvar segmentLength = curve.getLength();\\n\\t\\t\\t\\t\\tvar u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\\n\\n\\t\\t\\t\\t\\treturn curve.getPointAt( u );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ti ++;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\n\\t\\t\\t// loop where sum != 0, sum > d , sum+1 <d\\n\\n\\t\\t},\\n\\n\\t\\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\\n\\t\\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\\n\\t\\t// getPoint() depends on getLength\\n\\n\\t\\tgetLength: function () {\\n\\n\\t\\t\\tvar lens = this.getCurveLengths();\\n\\t\\t\\treturn lens[ lens.length - 1 ];\\n\\n\\t\\t},\\n\\n\\t\\t// cacheLengths must be recalculated.\\n\\t\\tupdateArcLengths: function () {\\n\\n\\t\\t\\tthis.needsUpdate = true;\\n\\t\\t\\tthis.cacheLengths = null;\\n\\t\\t\\tthis.getCurveLengths();\\n\\n\\t\\t},\\n\\n\\t\\t// Compute lengths and cache them\\n\\t\\t// We cannot overwrite getLengths() because UtoT mapping uses it.\\n\\n\\t\\tgetCurveLengths: function () {\\n\\n\\t\\t\\t// We use cache values if curves and cache array are same length\\n\\n\\t\\t\\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\\n\\n\\t\\t\\t\\treturn this.cacheLengths;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Get length of sub-curve\\n\\t\\t\\t// Push sums into cached array\\n\\n\\t\\t\\tvar lengths = [], sums = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tsums += this.curves[ i ].getLength();\\n\\t\\t\\t\\tlengths.push( sums );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.cacheLengths = lengths;\\n\\n\\t\\t\\treturn lengths;\\n\\n\\t\\t},\\n\\n\\t\\tgetSpacedPoints: function ( divisions ) {\\n\\n\\t\\t\\tif ( divisions === undefined ) divisions = 40;\\n\\n\\t\\t\\tvar points = [];\\n\\n\\t\\t\\tfor ( var i = 0; i <= divisions; i ++ ) {\\n\\n\\t\\t\\t\\tpoints.push( this.getPoint( i / divisions ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.autoClose ) {\\n\\n\\t\\t\\t\\tpoints.push( points[ 0 ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn points;\\n\\n\\t\\t},\\n\\n\\t\\tgetPoints: function ( divisions ) {\\n\\n\\t\\t\\tdivisions = divisions || 12;\\n\\n\\t\\t\\tvar points = [], last;\\n\\n\\t\\t\\tfor ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar curve = curves[ i ];\\n\\t\\t\\t\\tvar resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2\\n\\t\\t\\t\\t\\t: ( curve && curve.isLineCurve ) ? 1\\n\\t\\t\\t\\t\\t\\t: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length\\n\\t\\t\\t\\t\\t\\t\\t: divisions;\\n\\n\\t\\t\\t\\tvar pts = curve.getPoints( resolution );\\n\\n\\t\\t\\t\\tfor ( var j = 0; j < pts.length; j ++ ) {\\n\\n\\t\\t\\t\\t\\tvar point = pts[ j ];\\n\\n\\t\\t\\t\\t\\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\\n\\n\\t\\t\\t\\t\\tpoints.push( point );\\n\\t\\t\\t\\t\\tlast = point;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\\n\\n\\t\\t\\t\\tpoints.push( points[ 0 ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn points;\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tCurve.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.curves = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = source.curves.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar curve = source.curves[ i ];\\n\\n\\t\\t\\t\\tthis.curves.push( curve.clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.autoClose = source.autoClose;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar data = Curve.prototype.toJSON.call( this );\\n\\n\\t\\t\\tdata.autoClose = this.autoClose;\\n\\t\\t\\tdata.curves = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar curve = this.curves[ i ];\\n\\t\\t\\t\\tdata.curves.push( curve.toJSON() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tfromJSON: function ( json ) {\\n\\n\\t\\t\\tCurve.prototype.fromJSON.call( this, json );\\n\\n\\t\\t\\tthis.autoClose = json.autoClose;\\n\\t\\t\\tthis.curves = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = json.curves.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar curve = json.curves[ i ];\\n\\t\\t\\t\\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * Creates free form 2d path using series of points, lines or curves.\\n\\t **/\\n\\n\\tfunction Path( points ) {\\n\\n\\t\\tCurvePath.call( this );\\n\\n\\t\\tthis.type = 'Path';\\n\\n\\t\\tthis.currentPoint = new Vector2();\\n\\n\\t\\tif ( points ) {\\n\\n\\t\\t\\tthis.setFromPoints( points );\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tPath.prototype = Object.assign( Object.create( CurvePath.prototype ), {\\n\\n\\t\\tconstructor: Path,\\n\\n\\t\\tsetFromPoints: function ( points ) {\\n\\n\\t\\t\\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\\n\\n\\t\\t\\tfor ( var i = 1, l = points.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tthis.lineTo( points[ i ].x, points[ i ].y );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tmoveTo: function ( x, y ) {\\n\\n\\t\\t\\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\\n\\n\\t\\t},\\n\\n\\t\\tlineTo: function ( x, y ) {\\n\\n\\t\\t\\tvar curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\\n\\t\\t\\tthis.curves.push( curve );\\n\\n\\t\\t\\tthis.currentPoint.set( x, y );\\n\\n\\t\\t},\\n\\n\\t\\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\\n\\n\\t\\t\\tvar curve = new QuadraticBezierCurve(\\n\\t\\t\\t\\tthis.currentPoint.clone(),\\n\\t\\t\\t\\tnew Vector2( aCPx, aCPy ),\\n\\t\\t\\t\\tnew Vector2( aX, aY )\\n\\t\\t\\t);\\n\\n\\t\\t\\tthis.curves.push( curve );\\n\\n\\t\\t\\tthis.currentPoint.set( aX, aY );\\n\\n\\t\\t},\\n\\n\\t\\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\\n\\n\\t\\t\\tvar curve = new CubicBezierCurve(\\n\\t\\t\\t\\tthis.currentPoint.clone(),\\n\\t\\t\\t\\tnew Vector2( aCP1x, aCP1y ),\\n\\t\\t\\t\\tnew Vector2( aCP2x, aCP2y ),\\n\\t\\t\\t\\tnew Vector2( aX, aY )\\n\\t\\t\\t);\\n\\n\\t\\t\\tthis.curves.push( curve );\\n\\n\\t\\t\\tthis.currentPoint.set( aX, aY );\\n\\n\\t\\t},\\n\\n\\t\\tsplineThru: function ( pts /*Array of Vector*/ ) {\\n\\n\\t\\t\\tvar npts = [ this.currentPoint.clone() ].concat( pts );\\n\\n\\t\\t\\tvar curve = new SplineCurve( npts );\\n\\t\\t\\tthis.curves.push( curve );\\n\\n\\t\\t\\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\\n\\n\\t\\t},\\n\\n\\t\\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\\n\\n\\t\\t\\tvar x0 = this.currentPoint.x;\\n\\t\\t\\tvar y0 = this.currentPoint.y;\\n\\n\\t\\t\\tthis.absarc( aX + x0, aY + y0, aRadius,\\n\\t\\t\\t\\taStartAngle, aEndAngle, aClockwise );\\n\\n\\t\\t},\\n\\n\\t\\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\\n\\n\\t\\t\\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\\n\\n\\t\\t},\\n\\n\\t\\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\\n\\n\\t\\t\\tvar x0 = this.currentPoint.x;\\n\\t\\t\\tvar y0 = this.currentPoint.y;\\n\\n\\t\\t\\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\\n\\n\\t\\t},\\n\\n\\t\\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\\n\\n\\t\\t\\tvar curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\\n\\n\\t\\t\\tif ( this.curves.length > 0 ) {\\n\\n\\t\\t\\t\\t// if a previous curve is present, attempt to join\\n\\t\\t\\t\\tvar firstPoint = curve.getPoint( 0 );\\n\\n\\t\\t\\t\\tif ( ! firstPoint.equals( this.currentPoint ) ) {\\n\\n\\t\\t\\t\\t\\tthis.lineTo( firstPoint.x, firstPoint.y );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.curves.push( curve );\\n\\n\\t\\t\\tvar lastPoint = curve.getPoint( 1 );\\n\\t\\t\\tthis.currentPoint.copy( lastPoint );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tCurvePath.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.currentPoint.copy( source.currentPoint );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar data = CurvePath.prototype.toJSON.call( this );\\n\\n\\t\\t\\tdata.currentPoint = this.currentPoint.toArray();\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tfromJSON: function ( json ) {\\n\\n\\t\\t\\tCurvePath.prototype.fromJSON.call( this, json );\\n\\n\\t\\t\\tthis.currentPoint.fromArray( json.currentPoint );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * Defines a 2d shape plane using paths.\\n\\t **/\\n\\n\\t// STEP 1 Create a path.\\n\\t// STEP 2 Turn path into shape.\\n\\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\\n\\t// STEP 3a - Extract points from each shape, turn to vertices\\n\\t// STEP 3b - Triangulate each shape, add faces.\\n\\n\\tfunction Shape( points ) {\\n\\n\\t\\tPath.call( this, points );\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.type = 'Shape';\\n\\n\\t\\tthis.holes = [];\\n\\n\\t}\\n\\n\\tShape.prototype = Object.assign( Object.create( Path.prototype ), {\\n\\n\\t\\tconstructor: Shape,\\n\\n\\t\\tgetPointsHoles: function ( divisions ) {\\n\\n\\t\\t\\tvar holesPts = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn holesPts;\\n\\n\\t\\t},\\n\\n\\t\\t// get points of shape and holes (keypoints based on segments parameter)\\n\\n\\t\\textractPoints: function ( divisions ) {\\n\\n\\t\\t\\treturn {\\n\\n\\t\\t\\t\\tshape: this.getPoints( divisions ),\\n\\t\\t\\t\\tholes: this.getPointsHoles( divisions )\\n\\n\\t\\t\\t};\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tPath.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.holes = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = source.holes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar hole = source.holes[ i ];\\n\\n\\t\\t\\t\\tthis.holes.push( hole.clone() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar data = Path.prototype.toJSON.call( this );\\n\\n\\t\\t\\tdata.uuid = this.uuid;\\n\\t\\t\\tdata.holes = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar hole = this.holes[ i ];\\n\\t\\t\\t\\tdata.holes.push( hole.toJSON() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t},\\n\\n\\t\\tfromJSON: function ( json ) {\\n\\n\\t\\t\\tPath.prototype.fromJSON.call( this, json );\\n\\n\\t\\t\\tthis.uuid = json.uuid;\\n\\t\\t\\tthis.holes = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = json.holes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar hole = json.holes[ i ];\\n\\t\\t\\t\\tthis.holes.push( new Path().fromJSON( hole ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Light( color, intensity ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Light';\\n\\n\\t\\tthis.color = new Color( color );\\n\\t\\tthis.intensity = intensity !== undefined ? intensity : 1;\\n\\n\\t\\tthis.receiveShadow = undefined;\\n\\n\\t}\\n\\n\\tLight.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Light,\\n\\n\\t\\tisLight: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tObject3D.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.color.copy( source.color );\\n\\t\\t\\tthis.intensity = source.intensity;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar data = Object3D.prototype.toJSON.call( this, meta );\\n\\n\\t\\t\\tdata.object.color = this.color.getHex();\\n\\t\\t\\tdata.object.intensity = this.intensity;\\n\\n\\t\\t\\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\\n\\n\\t\\t\\tif ( this.distance !== undefined ) data.object.distance = this.distance;\\n\\t\\t\\tif ( this.angle !== undefined ) data.object.angle = this.angle;\\n\\t\\t\\tif ( this.decay !== undefined ) data.object.decay = this.decay;\\n\\t\\t\\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\\n\\n\\t\\t\\tif ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction HemisphereLight( skyColor, groundColor, intensity ) {\\n\\n\\t\\tLight.call( this, skyColor, intensity );\\n\\n\\t\\tthis.type = 'HemisphereLight';\\n\\n\\t\\tthis.castShadow = undefined;\\n\\n\\t\\tthis.position.copy( Object3D.DefaultUp );\\n\\t\\tthis.updateMatrix();\\n\\n\\t\\tthis.groundColor = new Color( groundColor );\\n\\n\\t}\\n\\n\\tHemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {\\n\\n\\t\\tconstructor: HemisphereLight,\\n\\n\\t\\tisHemisphereLight: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.groundColor.copy( source.groundColor );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction LightShadow( camera ) {\\n\\n\\t\\tthis.camera = camera;\\n\\n\\t\\tthis.bias = 0;\\n\\t\\tthis.radius = 1;\\n\\n\\t\\tthis.mapSize = new Vector2( 512, 512 );\\n\\n\\t\\tthis.map = null;\\n\\t\\tthis.matrix = new Matrix4();\\n\\n\\t}\\n\\n\\tObject.assign( LightShadow.prototype, {\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.camera = source.camera.clone();\\n\\n\\t\\t\\tthis.bias = source.bias;\\n\\t\\t\\tthis.radius = source.radius;\\n\\n\\t\\t\\tthis.mapSize.copy( source.mapSize );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function () {\\n\\n\\t\\t\\tvar object = {};\\n\\n\\t\\t\\tif ( this.bias !== 0 ) object.bias = this.bias;\\n\\t\\t\\tif ( this.radius !== 1 ) object.radius = this.radius;\\n\\t\\t\\tif ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();\\n\\n\\t\\t\\tobject.camera = this.camera.toJSON( false ).object;\\n\\t\\t\\tdelete object.camera.matrix;\\n\\n\\t\\t\\treturn object;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction SpotLightShadow() {\\n\\n\\t\\tLightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );\\n\\n\\t}\\n\\n\\tSpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\\n\\n\\t\\tconstructor: SpotLightShadow,\\n\\n\\t\\tisSpotLightShadow: true,\\n\\n\\t\\tupdate: function ( light ) {\\n\\n\\t\\t\\tvar camera = this.camera;\\n\\n\\t\\t\\tvar fov = _Math.RAD2DEG * 2 * light.angle;\\n\\t\\t\\tvar aspect = this.mapSize.width / this.mapSize.height;\\n\\t\\t\\tvar far = light.distance || camera.far;\\n\\n\\t\\t\\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\\n\\n\\t\\t\\t\\tcamera.fov = fov;\\n\\t\\t\\t\\tcamera.aspect = aspect;\\n\\t\\t\\t\\tcamera.far = far;\\n\\t\\t\\t\\tcamera.updateProjectionMatrix();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction SpotLight( color, intensity, distance, angle, penumbra, decay ) {\\n\\n\\t\\tLight.call( this, color, intensity );\\n\\n\\t\\tthis.type = 'SpotLight';\\n\\n\\t\\tthis.position.copy( Object3D.DefaultUp );\\n\\t\\tthis.updateMatrix();\\n\\n\\t\\tthis.target = new Object3D();\\n\\n\\t\\tObject.defineProperty( this, 'power', {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\t// intensity = power per solid angle.\\n\\t\\t\\t\\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\\n\\t\\t\\t\\treturn this.intensity * Math.PI;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( power ) {\\n\\n\\t\\t\\t\\t// intensity = power per solid angle.\\n\\t\\t\\t\\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\\n\\t\\t\\t\\tthis.intensity = power / Math.PI;\\n\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t\\tthis.distance = ( distance !== undefined ) ? distance : 0;\\n\\t\\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\\n\\t\\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\\n\\t\\tthis.decay = ( decay !== undefined ) ? decay : 1;\\t// for physically correct lights, should be 2.\\n\\n\\t\\tthis.shadow = new SpotLightShadow();\\n\\n\\t}\\n\\n\\tSpotLight.prototype = Object.assign( Object.create( Light.prototype ), {\\n\\n\\t\\tconstructor: SpotLight,\\n\\n\\t\\tisSpotLight: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.distance = source.distance;\\n\\t\\t\\tthis.angle = source.angle;\\n\\t\\t\\tthis.penumbra = source.penumbra;\\n\\t\\t\\tthis.decay = source.decay;\\n\\n\\t\\t\\tthis.target = source.target.clone();\\n\\n\\t\\t\\tthis.shadow = source.shadow.clone();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\n\\tfunction PointLight( color, intensity, distance, decay ) {\\n\\n\\t\\tLight.call( this, color, intensity );\\n\\n\\t\\tthis.type = 'PointLight';\\n\\n\\t\\tObject.defineProperty( this, 'power', {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\t// intensity = power per solid angle.\\n\\t\\t\\t\\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\\n\\t\\t\\t\\treturn this.intensity * 4 * Math.PI;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( power ) {\\n\\n\\t\\t\\t\\t// intensity = power per solid angle.\\n\\t\\t\\t\\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\\n\\t\\t\\t\\tthis.intensity = power / ( 4 * Math.PI );\\n\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t\\tthis.distance = ( distance !== undefined ) ? distance : 0;\\n\\t\\tthis.decay = ( decay !== undefined ) ? decay : 1;\\t// for physically correct lights, should be 2.\\n\\n\\t\\tthis.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\\n\\n\\t}\\n\\n\\tPointLight.prototype = Object.assign( Object.create( Light.prototype ), {\\n\\n\\t\\tconstructor: PointLight,\\n\\n\\t\\tisPointLight: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.distance = source.distance;\\n\\t\\t\\tthis.decay = source.decay;\\n\\n\\t\\t\\tthis.shadow = source.shadow.clone();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction DirectionalLightShadow( ) {\\n\\n\\t\\tLightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\\n\\n\\t}\\n\\n\\tDirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {\\n\\n\\t\\tconstructor: DirectionalLightShadow\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction DirectionalLight( color, intensity ) {\\n\\n\\t\\tLight.call( this, color, intensity );\\n\\n\\t\\tthis.type = 'DirectionalLight';\\n\\n\\t\\tthis.position.copy( Object3D.DefaultUp );\\n\\t\\tthis.updateMatrix();\\n\\n\\t\\tthis.target = new Object3D();\\n\\n\\t\\tthis.shadow = new DirectionalLightShadow();\\n\\n\\t}\\n\\n\\tDirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {\\n\\n\\t\\tconstructor: DirectionalLight,\\n\\n\\t\\tisDirectionalLight: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.target = source.target.clone();\\n\\n\\t\\t\\tthis.shadow = source.shadow.clone();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction AmbientLight( color, intensity ) {\\n\\n\\t\\tLight.call( this, color, intensity );\\n\\n\\t\\tthis.type = 'AmbientLight';\\n\\n\\t\\tthis.castShadow = undefined;\\n\\n\\t}\\n\\n\\tAmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {\\n\\n\\t\\tconstructor: AmbientLight,\\n\\n\\t\\tisAmbientLight: true\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author abelnation / http://github.com/abelnation\\n\\t */\\n\\n\\tfunction RectAreaLight( color, intensity, width, height ) {\\n\\n\\t\\tLight.call( this, color, intensity );\\n\\n\\t\\tthis.type = 'RectAreaLight';\\n\\n\\t\\tthis.position.set( 0, 1, 0 );\\n\\t\\tthis.updateMatrix();\\n\\n\\t\\tthis.width = ( width !== undefined ) ? width : 10;\\n\\t\\tthis.height = ( height !== undefined ) ? height : 10;\\n\\n\\t\\t// TODO (abelnation): distance/decay\\n\\n\\t\\t// TODO (abelnation): update method for RectAreaLight to update transform to lookat target\\n\\n\\t\\t// TODO (abelnation): shadows\\n\\n\\t}\\n\\n\\t// TODO (abelnation): RectAreaLight update when light shape is changed\\n\\tRectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {\\n\\n\\t\\tconstructor: RectAreaLight,\\n\\n\\t\\tisRectAreaLight: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tLight.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.width = source.width;\\n\\t\\t\\tthis.height = source.height;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( meta ) {\\n\\n\\t\\t\\tvar data = Light.prototype.toJSON.call( this, meta );\\n\\n\\t\\t\\tdata.object.width = this.width;\\n\\t\\t\\tdata.object.height = this.height;\\n\\n\\t\\t\\treturn data;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A Track that interpolates Strings\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction StringKeyframeTrack( name, times, values, interpolation ) {\\n\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\n\\n\\t}\\n\\n\\tStringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\n\\n\\t\\tconstructor: StringKeyframeTrack,\\n\\n\\t\\tValueTypeName: 'string',\\n\\t\\tValueBufferType: Array,\\n\\n\\t\\tDefaultInterpolation: InterpolateDiscrete,\\n\\n\\t\\tInterpolantFactoryMethodLinear: undefined,\\n\\n\\t\\tInterpolantFactoryMethodSmooth: undefined\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A Track of Boolean keyframe values.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction BooleanKeyframeTrack( name, times, values ) {\\n\\n\\t\\tKeyframeTrack.call( this, name, times, values );\\n\\n\\t}\\n\\n\\tBooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\n\\n\\t\\tconstructor: BooleanKeyframeTrack,\\n\\n\\t\\tValueTypeName: 'bool',\\n\\t\\tValueBufferType: Array,\\n\\n\\t\\tDefaultInterpolation: InterpolateDiscrete,\\n\\n\\t\\tInterpolantFactoryMethodLinear: undefined,\\n\\t\\tInterpolantFactoryMethodSmooth: undefined\\n\\n\\t\\t// Note: Actually this track could have a optimized / compressed\\n\\t\\t// representation of a single value and a custom interpolant that\\n\\t\\t// computes \\\"firstValue ^ isOdd( index )\\\".\\n\\n\\t} );\\n\\n\\t/**\\n\\t * Abstract base class of interpolants over parametric samples.\\n\\t *\\n\\t * The parameter domain is one dimensional, typically the time or a path\\n\\t * along a curve defined by the data.\\n\\t *\\n\\t * The sample values can have any dimensionality and derived classes may\\n\\t * apply special interpretations to the data.\\n\\t *\\n\\t * This class provides the interval seek in a Template Method, deferring\\n\\t * the actual interpolation to derived classes.\\n\\t *\\n\\t * Time complexity is O(1) for linear access crossing at most two points\\n\\t * and O(log N) for random access, where N is the number of positions.\\n\\t *\\n\\t * References:\\n\\t *\\n\\t * \\t\\thttp://www.oodesign.com/template-method-pattern.html\\n\\t *\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\n\\n\\t\\tthis.parameterPositions = parameterPositions;\\n\\t\\tthis._cachedIndex = 0;\\n\\n\\t\\tthis.resultBuffer = resultBuffer !== undefined ?\\n\\t\\t\\tresultBuffer : new sampleValues.constructor( sampleSize );\\n\\t\\tthis.sampleValues = sampleValues;\\n\\t\\tthis.valueSize = sampleSize;\\n\\n\\t}\\n\\n\\tObject.assign( Interpolant.prototype, {\\n\\n\\t\\tevaluate: function ( t ) {\\n\\n\\t\\t\\tvar pp = this.parameterPositions,\\n\\t\\t\\t\\ti1 = this._cachedIndex,\\n\\n\\t\\t\\t\\tt1 = pp[ i1 ],\\n\\t\\t\\t\\tt0 = pp[ i1 - 1 ];\\n\\n\\t\\t\\tvalidate_interval: {\\n\\n\\t\\t\\t\\tseek: {\\n\\n\\t\\t\\t\\t\\tvar right;\\n\\n\\t\\t\\t\\t\\tlinear_scan: {\\n\\n\\t\\t\\t\\t\\t\\t//- See http://jsperf.com/comparison-to-undefined/3\\n\\t\\t\\t\\t\\t\\t//- slower code:\\n\\t\\t\\t\\t\\t\\t//-\\n\\t\\t\\t\\t\\t\\t//- \\t\\t\\t\\tif ( t >= t1 || t1 === undefined ) {\\n\\t\\t\\t\\t\\t\\tforward_scan: if ( ! ( t < t1 ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var giveUpAt = i1 + 2; ; ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( t1 === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( t < t0 ) break forward_scan;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// after end\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\ti1 = pp.length;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthis._cachedIndex = i1;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn this.afterEnd_( i1 - 1, t, t0 );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i1 === giveUpAt ) break; // this loop\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tt0 = t1;\\n\\t\\t\\t\\t\\t\\t\\t\\tt1 = pp[ ++ i1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( t < t1 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// we have arrived at the sought interval\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak seek;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// prepare binary search on the right side of the index\\n\\t\\t\\t\\t\\t\\t\\tright = pp.length;\\n\\t\\t\\t\\t\\t\\t\\tbreak linear_scan;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t//- slower code:\\n\\t\\t\\t\\t\\t\\t//-\\t\\t\\t\\t\\tif ( t < t0 || t0 === undefined ) {\\n\\t\\t\\t\\t\\t\\tif ( ! ( t >= t0 ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// looping?\\n\\n\\t\\t\\t\\t\\t\\t\\tvar t1global = pp[ 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( t < t1global ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\ti1 = 2; // + 1, using the scan for the details\\n\\t\\t\\t\\t\\t\\t\\t\\tt0 = t1global;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// linear reverse scan\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var giveUpAt = i1 - 2; ; ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( t0 === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// before start\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthis._cachedIndex = 0;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\treturn this.beforeStart_( 0, t, t1 );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i1 === giveUpAt ) break; // this loop\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tt1 = t0;\\n\\t\\t\\t\\t\\t\\t\\t\\tt0 = pp[ -- i1 - 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( t >= t0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t// we have arrived at the sought interval\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbreak seek;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t// prepare binary search on the left side of the index\\n\\t\\t\\t\\t\\t\\t\\tright = i1;\\n\\t\\t\\t\\t\\t\\t\\ti1 = 0;\\n\\t\\t\\t\\t\\t\\t\\tbreak linear_scan;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// the interval is valid\\n\\n\\t\\t\\t\\t\\t\\tbreak validate_interval;\\n\\n\\t\\t\\t\\t\\t} // linear scan\\n\\n\\t\\t\\t\\t\\t// binary search\\n\\n\\t\\t\\t\\t\\twhile ( i1 < right ) {\\n\\n\\t\\t\\t\\t\\t\\tvar mid = ( i1 + right ) >>> 1;\\n\\n\\t\\t\\t\\t\\t\\tif ( t < pp[ mid ] ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tright = mid;\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\ti1 = mid + 1;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tt1 = pp[ i1 ];\\n\\t\\t\\t\\t\\tt0 = pp[ i1 - 1 ];\\n\\n\\t\\t\\t\\t\\t// check boundary cases, again\\n\\n\\t\\t\\t\\t\\tif ( t0 === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tthis._cachedIndex = 0;\\n\\t\\t\\t\\t\\t\\treturn this.beforeStart_( 0, t, t1 );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( t1 === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ti1 = pp.length;\\n\\t\\t\\t\\t\\t\\tthis._cachedIndex = i1;\\n\\t\\t\\t\\t\\t\\treturn this.afterEnd_( i1 - 1, t0, t );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} // seek\\n\\n\\t\\t\\t\\tthis._cachedIndex = i1;\\n\\n\\t\\t\\t\\tthis.intervalChanged_( i1, t0, t1 );\\n\\n\\t\\t\\t} // validate_interval\\n\\n\\t\\t\\treturn this.interpolate_( i1, t0, t, t1 );\\n\\n\\t\\t},\\n\\n\\t\\tsettings: null, // optional, subclass-specific settings structure\\n\\t\\t// Note: The indirection allows central control of many interpolants.\\n\\n\\t\\t// --- Protected interface\\n\\n\\t\\tDefaultSettings_: {},\\n\\n\\t\\tgetSettings_: function () {\\n\\n\\t\\t\\treturn this.settings || this.DefaultSettings_;\\n\\n\\t\\t},\\n\\n\\t\\tcopySampleValue_: function ( index ) {\\n\\n\\t\\t\\t// copies a sample value to the result buffer\\n\\n\\t\\t\\tvar result = this.resultBuffer,\\n\\t\\t\\t\\tvalues = this.sampleValues,\\n\\t\\t\\t\\tstride = this.valueSize,\\n\\t\\t\\t\\toffset = index * stride;\\n\\n\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\n\\n\\t\\t\\t\\tresult[ i ] = values[ offset + i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t},\\n\\n\\t\\t// Template methods for derived classes:\\n\\n\\t\\tinterpolate_: function ( /* i1, t0, t, t1 */ ) {\\n\\n\\t\\t\\tthrow new Error( 'call to abstract method' );\\n\\t\\t\\t// implementations shall return this.resultBuffer\\n\\n\\t\\t},\\n\\n\\t\\tintervalChanged_: function ( /* i1, t0, t1 */ ) {\\n\\n\\t\\t\\t// empty\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//!\\\\ DECLARE ALIAS AFTER assign prototype !\\n\\tObject.assign( Interpolant.prototype, {\\n\\n\\t\\t//( 0, t, t0 ), returns this.resultBuffer\\n\\t\\tbeforeStart_: Interpolant.prototype.copySampleValue_,\\n\\n\\t\\t//( N-1, tN-1, t ), returns this.resultBuffer\\n\\t\\tafterEnd_: Interpolant.prototype.copySampleValue_,\\n\\n\\t} );\\n\\n\\t/**\\n\\t * Spherical linear unit quaternion interpolant.\\n\\t *\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\n\\n\\t\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\n\\n\\t}\\n\\n\\tQuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\n\\n\\t\\tconstructor: QuaternionLinearInterpolant,\\n\\n\\t\\tinterpolate_: function ( i1, t0, t, t1 ) {\\n\\n\\t\\t\\tvar result = this.resultBuffer,\\n\\t\\t\\t\\tvalues = this.sampleValues,\\n\\t\\t\\t\\tstride = this.valueSize,\\n\\n\\t\\t\\t\\toffset = i1 * stride,\\n\\n\\t\\t\\t\\talpha = ( t - t0 ) / ( t1 - t0 );\\n\\n\\t\\t\\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\\n\\n\\t\\t\\t\\tQuaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A Track of quaternion keyframe values.\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction QuaternionKeyframeTrack( name, times, values, interpolation ) {\\n\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\n\\n\\t}\\n\\n\\tQuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\n\\n\\t\\tconstructor: QuaternionKeyframeTrack,\\n\\n\\t\\tValueTypeName: 'quaternion',\\n\\n\\t\\t// ValueBufferType is inherited\\n\\n\\t\\tDefaultInterpolation: InterpolateLinear,\\n\\n\\t\\tInterpolantFactoryMethodLinear: function ( result ) {\\n\\n\\t\\t\\treturn new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );\\n\\n\\t\\t},\\n\\n\\t\\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A Track of keyframe values that represent color.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction ColorKeyframeTrack( name, times, values, interpolation ) {\\n\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\n\\n\\t}\\n\\n\\tColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\n\\n\\t\\tconstructor: ColorKeyframeTrack,\\n\\n\\t\\tValueTypeName: 'color'\\n\\n\\t\\t// ValueBufferType is inherited\\n\\n\\t\\t// DefaultInterpolation is inherited\\n\\n\\t\\t// Note: Very basic implementation and nothing special yet.\\n\\t\\t// However, this is the place for color space parameterization.\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A Track of numeric keyframe values.\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction NumberKeyframeTrack( name, times, values, interpolation ) {\\n\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\n\\n\\t}\\n\\n\\tNumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\n\\n\\t\\tconstructor: NumberKeyframeTrack,\\n\\n\\t\\tValueTypeName: 'number'\\n\\n\\t\\t// ValueBufferType is inherited\\n\\n\\t\\t// DefaultInterpolation is inherited\\n\\n\\t} );\\n\\n\\t/**\\n\\t * Fast and simple cubic spline interpolant.\\n\\t *\\n\\t * It was derived from a Hermitian construction setting the first derivative\\n\\t * at each sample position to the linear slope between neighboring positions\\n\\t * over their parameter interval.\\n\\t *\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\n\\n\\t\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\n\\n\\t\\tthis._weightPrev = - 0;\\n\\t\\tthis._offsetPrev = - 0;\\n\\t\\tthis._weightNext = - 0;\\n\\t\\tthis._offsetNext = - 0;\\n\\n\\t}\\n\\n\\tCubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\n\\n\\t\\tconstructor: CubicInterpolant,\\n\\n\\t\\tDefaultSettings_: {\\n\\n\\t\\t\\tendingStart: ZeroCurvatureEnding,\\n\\t\\t\\tendingEnd: ZeroCurvatureEnding\\n\\n\\t\\t},\\n\\n\\t\\tintervalChanged_: function ( i1, t0, t1 ) {\\n\\n\\t\\t\\tvar pp = this.parameterPositions,\\n\\t\\t\\t\\tiPrev = i1 - 2,\\n\\t\\t\\t\\tiNext = i1 + 1,\\n\\n\\t\\t\\t\\ttPrev = pp[ iPrev ],\\n\\t\\t\\t\\ttNext = pp[ iNext ];\\n\\n\\t\\t\\tif ( tPrev === undefined ) {\\n\\n\\t\\t\\t\\tswitch ( this.getSettings_().endingStart ) {\\n\\n\\t\\t\\t\\t\\tcase ZeroSlopeEnding:\\n\\n\\t\\t\\t\\t\\t\\t// f'(t0) = 0\\n\\t\\t\\t\\t\\t\\tiPrev = i1;\\n\\t\\t\\t\\t\\t\\ttPrev = 2 * t0 - t1;\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase WrapAroundEnding:\\n\\n\\t\\t\\t\\t\\t\\t// use the other end of the curve\\n\\t\\t\\t\\t\\t\\tiPrev = pp.length - 2;\\n\\t\\t\\t\\t\\t\\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tdefault: // ZeroCurvatureEnding\\n\\n\\t\\t\\t\\t\\t\\t// f''(t0) = 0 a.k.a. Natural Spline\\n\\t\\t\\t\\t\\t\\tiPrev = i1;\\n\\t\\t\\t\\t\\t\\ttPrev = t1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( tNext === undefined ) {\\n\\n\\t\\t\\t\\tswitch ( this.getSettings_().endingEnd ) {\\n\\n\\t\\t\\t\\t\\tcase ZeroSlopeEnding:\\n\\n\\t\\t\\t\\t\\t\\t// f'(tN) = 0\\n\\t\\t\\t\\t\\t\\tiNext = i1;\\n\\t\\t\\t\\t\\t\\ttNext = 2 * t1 - t0;\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase WrapAroundEnding:\\n\\n\\t\\t\\t\\t\\t\\t// use the other end of the curve\\n\\t\\t\\t\\t\\t\\tiNext = 1;\\n\\t\\t\\t\\t\\t\\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tdefault: // ZeroCurvatureEnding\\n\\n\\t\\t\\t\\t\\t\\t// f''(tN) = 0, a.k.a. Natural Spline\\n\\t\\t\\t\\t\\t\\tiNext = i1 - 1;\\n\\t\\t\\t\\t\\t\\ttNext = t0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar halfDt = ( t1 - t0 ) * 0.5,\\n\\t\\t\\t\\tstride = this.valueSize;\\n\\n\\t\\t\\tthis._weightPrev = halfDt / ( t0 - tPrev );\\n\\t\\t\\tthis._weightNext = halfDt / ( tNext - t1 );\\n\\t\\t\\tthis._offsetPrev = iPrev * stride;\\n\\t\\t\\tthis._offsetNext = iNext * stride;\\n\\n\\t\\t},\\n\\n\\t\\tinterpolate_: function ( i1, t0, t, t1 ) {\\n\\n\\t\\t\\tvar result = this.resultBuffer,\\n\\t\\t\\t\\tvalues = this.sampleValues,\\n\\t\\t\\t\\tstride = this.valueSize,\\n\\n\\t\\t\\t\\to1 = i1 * stride,\\t\\to0 = o1 - stride,\\n\\t\\t\\t\\toP = this._offsetPrev, \\toN = this._offsetNext,\\n\\t\\t\\t\\twP = this._weightPrev,\\twN = this._weightNext,\\n\\n\\t\\t\\t\\tp = ( t - t0 ) / ( t1 - t0 ),\\n\\t\\t\\t\\tpp = p * p,\\n\\t\\t\\t\\tppp = pp * p;\\n\\n\\t\\t\\t// evaluate polynomials\\n\\n\\t\\t\\tvar sP = - wP * ppp + 2 * wP * pp - wP * p;\\n\\t\\t\\tvar s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;\\n\\t\\t\\tvar s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;\\n\\t\\t\\tvar sN = wN * ppp - wN * pp;\\n\\n\\t\\t\\t// combine data linearly\\n\\n\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\n\\n\\t\\t\\t\\tresult[ i ] =\\n\\t\\t\\t\\t\\t\\tsP * values[ oP + i ] +\\n\\t\\t\\t\\t\\t\\ts0 * values[ o0 + i ] +\\n\\t\\t\\t\\t\\t\\ts1 * values[ o1 + i ] +\\n\\t\\t\\t\\t\\t\\tsN * values[ oN + i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\n\\n\\t\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\n\\n\\t}\\n\\n\\tLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\n\\n\\t\\tconstructor: LinearInterpolant,\\n\\n\\t\\tinterpolate_: function ( i1, t0, t, t1 ) {\\n\\n\\t\\t\\tvar result = this.resultBuffer,\\n\\t\\t\\t\\tvalues = this.sampleValues,\\n\\t\\t\\t\\tstride = this.valueSize,\\n\\n\\t\\t\\t\\toffset1 = i1 * stride,\\n\\t\\t\\t\\toffset0 = offset1 - stride,\\n\\n\\t\\t\\t\\tweight1 = ( t - t0 ) / ( t1 - t0 ),\\n\\t\\t\\t\\tweight0 = 1 - weight1;\\n\\n\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\n\\n\\t\\t\\t\\tresult[ i ] =\\n\\t\\t\\t\\t\\t\\tvalues[ offset0 + i ] * weight0 +\\n\\t\\t\\t\\t\\t\\tvalues[ offset1 + i ] * weight1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * Interpolant that evaluates to the sample value at the position preceeding\\n\\t * the parameter.\\n\\t *\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {\\n\\n\\t\\tInterpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );\\n\\n\\t}\\n\\n\\tDiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {\\n\\n\\t\\tconstructor: DiscreteInterpolant,\\n\\n\\t\\tinterpolate_: function ( i1 /*, t0, t, t1 */ ) {\\n\\n\\t\\t\\treturn this.copySampleValue_( i1 - 1 );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author tschw\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t */\\n\\n\\tvar AnimationUtils = {\\n\\n\\t\\t// same as Array.prototype.slice, but also works on typed arrays\\n\\t\\tarraySlice: function ( array, from, to ) {\\n\\n\\t\\t\\tif ( AnimationUtils.isTypedArray( array ) ) {\\n\\n\\t\\t\\t\\t// in ios9 array.subarray(from, undefined) will return empty array\\n\\t\\t\\t\\t// but array.subarray(from) or array.subarray(from, len) is correct\\n\\t\\t\\t\\treturn new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn array.slice( from, to );\\n\\n\\t\\t},\\n\\n\\t\\t// converts an array to a specific type\\n\\t\\tconvertArray: function ( array, type, forceClone ) {\\n\\n\\t\\t\\tif ( ! array || // let 'undefined' and 'null' pass\\n\\t\\t\\t\\t\\t! forceClone && array.constructor === type ) return array;\\n\\n\\t\\t\\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\\n\\n\\t\\t\\t\\treturn new type( array ); // create typed array\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn Array.prototype.slice.call( array ); // create Array\\n\\n\\t\\t},\\n\\n\\t\\tisTypedArray: function ( object ) {\\n\\n\\t\\t\\treturn ArrayBuffer.isView( object ) &&\\n\\t\\t\\t\\t\\t! ( object instanceof DataView );\\n\\n\\t\\t},\\n\\n\\t\\t// returns an array by which times and values can be sorted\\n\\t\\tgetKeyframeOrder: function ( times ) {\\n\\n\\t\\t\\tfunction compareTime( i, j ) {\\n\\n\\t\\t\\t\\treturn times[ i ] - times[ j ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar n = times.length;\\n\\t\\t\\tvar result = new Array( n );\\n\\t\\t\\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\\n\\n\\t\\t\\tresult.sort( compareTime );\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t},\\n\\n\\t\\t// uses the array previously returned by 'getKeyframeOrder' to sort data\\n\\t\\tsortedArray: function ( values, stride, order ) {\\n\\n\\t\\t\\tvar nValues = values.length;\\n\\t\\t\\tvar result = new values.constructor( nValues );\\n\\n\\t\\t\\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\\n\\n\\t\\t\\t\\tvar srcOffset = order[ i ] * stride;\\n\\n\\t\\t\\t\\tfor ( var j = 0; j !== stride; ++ j ) {\\n\\n\\t\\t\\t\\t\\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn result;\\n\\n\\t\\t},\\n\\n\\t\\t// function for parsing AOS keyframe formats\\n\\t\\tflattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {\\n\\n\\t\\t\\tvar i = 1, key = jsonKeys[ 0 ];\\n\\n\\t\\t\\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\\n\\n\\t\\t\\t\\tkey = jsonKeys[ i ++ ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( key === undefined ) return; // no data\\n\\n\\t\\t\\tvar value = key[ valuePropertyName ];\\n\\t\\t\\tif ( value === undefined ) return; // no data\\n\\n\\t\\t\\tif ( Array.isArray( value ) ) {\\n\\n\\t\\t\\t\\tdo {\\n\\n\\t\\t\\t\\t\\tvalue = key[ valuePropertyName ];\\n\\n\\t\\t\\t\\t\\tif ( value !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttimes.push( key.time );\\n\\t\\t\\t\\t\\t\\tvalues.push.apply( values, value ); // push all elements\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tkey = jsonKeys[ i ++ ];\\n\\n\\t\\t\\t\\t} while ( key !== undefined );\\n\\n\\t\\t\\t} else if ( value.toArray !== undefined ) {\\n\\n\\t\\t\\t\\t// ...assume THREE.Math-ish\\n\\n\\t\\t\\t\\tdo {\\n\\n\\t\\t\\t\\t\\tvalue = key[ valuePropertyName ];\\n\\n\\t\\t\\t\\t\\tif ( value !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttimes.push( key.time );\\n\\t\\t\\t\\t\\t\\tvalue.toArray( values, values.length );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tkey = jsonKeys[ i ++ ];\\n\\n\\t\\t\\t\\t} while ( key !== undefined );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// otherwise push as-is\\n\\n\\t\\t\\t\\tdo {\\n\\n\\t\\t\\t\\t\\tvalue = key[ valuePropertyName ];\\n\\n\\t\\t\\t\\t\\tif ( value !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttimes.push( key.time );\\n\\t\\t\\t\\t\\t\\tvalues.push( value );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tkey = jsonKeys[ i ++ ];\\n\\n\\t\\t\\t\\t} while ( key !== undefined );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t *\\n\\t * A timed sequence of keyframes for a specific property.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction KeyframeTrack( name, times, values, interpolation ) {\\n\\n\\t\\tif ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );\\n\\t\\tif ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );\\n\\n\\t\\tthis.name = name;\\n\\n\\t\\tthis.times = AnimationUtils.convertArray( times, this.TimeBufferType );\\n\\t\\tthis.values = AnimationUtils.convertArray( values, this.ValueBufferType );\\n\\n\\t\\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\\n\\n\\t\\tthis.validate();\\n\\t\\tthis.optimize();\\n\\n\\t}\\n\\n\\t// Static methods:\\n\\n\\tObject.assign( KeyframeTrack, {\\n\\n\\t\\t// Serialization (in static context, because of constructor invocation\\n\\t\\t// and automatic invocation of .toJSON):\\n\\n\\t\\tparse: function ( json ) {\\n\\n\\t\\t\\tif ( json.type === undefined ) {\\n\\n\\t\\t\\t\\tthrow new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );\\n\\n\\t\\t\\tif ( json.times === undefined ) {\\n\\n\\t\\t\\t\\tvar times = [], values = [];\\n\\n\\t\\t\\t\\tAnimationUtils.flattenJSON( json.keys, times, values, 'value' );\\n\\n\\t\\t\\t\\tjson.times = times;\\n\\t\\t\\t\\tjson.values = values;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// derived classes can define a static parse method\\n\\t\\t\\tif ( trackType.parse !== undefined ) {\\n\\n\\t\\t\\t\\treturn trackType.parse( json );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// by default, we assume a constructor compatible with the base\\n\\t\\t\\t\\treturn new trackType( json.name, json.times, json.values, json.interpolation );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( track ) {\\n\\n\\t\\t\\tvar trackType = track.constructor;\\n\\n\\t\\t\\tvar json;\\n\\n\\t\\t\\t// derived classes can define a static toJSON method\\n\\t\\t\\tif ( trackType.toJSON !== undefined ) {\\n\\n\\t\\t\\t\\tjson = trackType.toJSON( track );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// by default, we assume the data can be serialized as-is\\n\\t\\t\\t\\tjson = {\\n\\n\\t\\t\\t\\t\\t'name': track.name,\\n\\t\\t\\t\\t\\t'times': AnimationUtils.convertArray( track.times, Array ),\\n\\t\\t\\t\\t\\t'values': AnimationUtils.convertArray( track.values, Array )\\n\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tvar interpolation = track.getInterpolation();\\n\\n\\t\\t\\t\\tif ( interpolation !== track.DefaultInterpolation ) {\\n\\n\\t\\t\\t\\t\\tjson.interpolation = interpolation;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tjson.type = track.ValueTypeName; // mandatory\\n\\n\\t\\t\\treturn json;\\n\\n\\t\\t},\\n\\n\\t\\t_getTrackTypeForValueTypeName: function ( typeName ) {\\n\\n\\t\\t\\tswitch ( typeName.toLowerCase() ) {\\n\\n\\t\\t\\t\\tcase 'scalar':\\n\\t\\t\\t\\tcase 'double':\\n\\t\\t\\t\\tcase 'float':\\n\\t\\t\\t\\tcase 'number':\\n\\t\\t\\t\\tcase 'integer':\\n\\n\\t\\t\\t\\t\\treturn NumberKeyframeTrack;\\n\\n\\t\\t\\t\\tcase 'vector':\\n\\t\\t\\t\\tcase 'vector2':\\n\\t\\t\\t\\tcase 'vector3':\\n\\t\\t\\t\\tcase 'vector4':\\n\\n\\t\\t\\t\\t\\treturn VectorKeyframeTrack;\\n\\n\\t\\t\\t\\tcase 'color':\\n\\n\\t\\t\\t\\t\\treturn ColorKeyframeTrack;\\n\\n\\t\\t\\t\\tcase 'quaternion':\\n\\n\\t\\t\\t\\t\\treturn QuaternionKeyframeTrack;\\n\\n\\t\\t\\t\\tcase 'bool':\\n\\t\\t\\t\\tcase 'boolean':\\n\\n\\t\\t\\t\\t\\treturn BooleanKeyframeTrack;\\n\\n\\t\\t\\t\\tcase 'string':\\n\\n\\t\\t\\t\\t\\treturn StringKeyframeTrack;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthrow new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( KeyframeTrack.prototype, {\\n\\n\\t\\tconstructor: KeyframeTrack,\\n\\n\\t\\tTimeBufferType: Float32Array,\\n\\n\\t\\tValueBufferType: Float32Array,\\n\\n\\t\\tDefaultInterpolation: InterpolateLinear,\\n\\n\\t\\tInterpolantFactoryMethodDiscrete: function ( result ) {\\n\\n\\t\\t\\treturn new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );\\n\\n\\t\\t},\\n\\n\\t\\tInterpolantFactoryMethodLinear: function ( result ) {\\n\\n\\t\\t\\treturn new LinearInterpolant( this.times, this.values, this.getValueSize(), result );\\n\\n\\t\\t},\\n\\n\\t\\tInterpolantFactoryMethodSmooth: function ( result ) {\\n\\n\\t\\t\\treturn new CubicInterpolant( this.times, this.values, this.getValueSize(), result );\\n\\n\\t\\t},\\n\\n\\t\\tsetInterpolation: function ( interpolation ) {\\n\\n\\t\\t\\tvar factoryMethod;\\n\\n\\t\\t\\tswitch ( interpolation ) {\\n\\n\\t\\t\\t\\tcase InterpolateDiscrete:\\n\\n\\t\\t\\t\\t\\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase InterpolateLinear:\\n\\n\\t\\t\\t\\t\\tfactoryMethod = this.InterpolantFactoryMethodLinear;\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase InterpolateSmooth:\\n\\n\\t\\t\\t\\t\\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\\n\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( factoryMethod === undefined ) {\\n\\n\\t\\t\\t\\tvar message = \\\"unsupported interpolation for \\\" +\\n\\t\\t\\t\\t\\tthis.ValueTypeName + \\\" keyframe track named \\\" + this.name;\\n\\n\\t\\t\\t\\tif ( this.createInterpolant === undefined ) {\\n\\n\\t\\t\\t\\t\\t// fall back to default, unless the default itself is messed up\\n\\t\\t\\t\\t\\tif ( interpolation !== this.DefaultInterpolation ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.setInterpolation( this.DefaultInterpolation );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tthrow new Error( message ); // fatal, in this case\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.KeyframeTrack:', message );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.createInterpolant = factoryMethod;\\n\\n\\t\\t},\\n\\n\\t\\tgetInterpolation: function () {\\n\\n\\t\\t\\tswitch ( this.createInterpolant ) {\\n\\n\\t\\t\\t\\tcase this.InterpolantFactoryMethodDiscrete:\\n\\n\\t\\t\\t\\t\\treturn InterpolateDiscrete;\\n\\n\\t\\t\\t\\tcase this.InterpolantFactoryMethodLinear:\\n\\n\\t\\t\\t\\t\\treturn InterpolateLinear;\\n\\n\\t\\t\\t\\tcase this.InterpolantFactoryMethodSmooth:\\n\\n\\t\\t\\t\\t\\treturn InterpolateSmooth;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tgetValueSize: function () {\\n\\n\\t\\t\\treturn this.values.length / this.times.length;\\n\\n\\t\\t},\\n\\n\\t\\t// move all keyframes either forwards or backwards in time\\n\\t\\tshift: function ( timeOffset ) {\\n\\n\\t\\t\\tif ( timeOffset !== 0.0 ) {\\n\\n\\t\\t\\t\\tvar times = this.times;\\n\\n\\t\\t\\t\\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\ttimes[ i ] += timeOffset;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\\n\\t\\tscale: function ( timeScale ) {\\n\\n\\t\\t\\tif ( timeScale !== 1.0 ) {\\n\\n\\t\\t\\t\\tvar times = this.times;\\n\\n\\t\\t\\t\\tfor ( var i = 0, n = times.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\ttimes[ i ] *= timeScale;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\\n\\t\\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\\n\\t\\ttrim: function ( startTime, endTime ) {\\n\\n\\t\\t\\tvar times = this.times,\\n\\t\\t\\t\\tnKeys = times.length,\\n\\t\\t\\t\\tfrom = 0,\\n\\t\\t\\t\\tto = nKeys - 1;\\n\\n\\t\\t\\twhile ( from !== nKeys && times[ from ] < startTime ) {\\n\\n\\t\\t\\t\\t++ from;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile ( to !== - 1 && times[ to ] > endTime ) {\\n\\n\\t\\t\\t\\t-- to;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t++ to; // inclusive -> exclusive bound\\n\\n\\t\\t\\tif ( from !== 0 || to !== nKeys ) {\\n\\n\\t\\t\\t\\t// empty tracks are forbidden, so keep at least one keyframe\\n\\t\\t\\t\\tif ( from >= to ) to = Math.max( to, 1 ), from = to - 1;\\n\\n\\t\\t\\t\\tvar stride = this.getValueSize();\\n\\t\\t\\t\\tthis.times = AnimationUtils.arraySlice( times, from, to );\\n\\t\\t\\t\\tthis.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\\n\\t\\tvalidate: function () {\\n\\n\\t\\t\\tvar valid = true;\\n\\n\\t\\t\\tvar valueSize = this.getValueSize();\\n\\t\\t\\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );\\n\\t\\t\\t\\tvalid = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar times = this.times,\\n\\t\\t\\t\\tvalues = this.values,\\n\\n\\t\\t\\t\\tnKeys = times.length;\\n\\n\\t\\t\\tif ( nKeys === 0 ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Track is empty.', this );\\n\\t\\t\\t\\tvalid = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar prevTime = null;\\n\\n\\t\\t\\tfor ( var i = 0; i !== nKeys; i ++ ) {\\n\\n\\t\\t\\t\\tvar currTime = times[ i ];\\n\\n\\t\\t\\t\\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );\\n\\t\\t\\t\\t\\tvalid = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( prevTime !== null && prevTime > currTime ) {\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );\\n\\t\\t\\t\\t\\tvalid = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tprevTime = currTime;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( values !== undefined ) {\\n\\n\\t\\t\\t\\tif ( AnimationUtils.isTypedArray( values ) ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\t\\tvar value = values[ i ];\\n\\n\\t\\t\\t\\t\\t\\tif ( isNaN( value ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );\\n\\t\\t\\t\\t\\t\\t\\tvalid = false;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn valid;\\n\\n\\t\\t},\\n\\n\\t\\t// removes equivalent sequential keys as common in morph target sequences\\n\\t\\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\\n\\t\\toptimize: function () {\\n\\n\\t\\t\\tvar times = this.times,\\n\\t\\t\\t\\tvalues = this.values,\\n\\t\\t\\t\\tstride = this.getValueSize(),\\n\\n\\t\\t\\t\\tsmoothInterpolation = this.getInterpolation() === InterpolateSmooth,\\n\\n\\t\\t\\t\\twriteIndex = 1,\\n\\t\\t\\t\\tlastIndex = times.length - 1;\\n\\n\\t\\t\\tfor ( var i = 1; i < lastIndex; ++ i ) {\\n\\n\\t\\t\\t\\tvar keep = false;\\n\\n\\t\\t\\t\\tvar time = times[ i ];\\n\\t\\t\\t\\tvar timeNext = times[ i + 1 ];\\n\\n\\t\\t\\t\\t// remove adjacent keyframes scheduled at the same time\\n\\n\\t\\t\\t\\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\\n\\n\\t\\t\\t\\t\\tif ( ! smoothInterpolation ) {\\n\\n\\t\\t\\t\\t\\t\\t// remove unnecessary keyframes same as their neighbors\\n\\n\\t\\t\\t\\t\\t\\tvar offset = i * stride,\\n\\t\\t\\t\\t\\t\\t\\toffsetP = offset - stride,\\n\\t\\t\\t\\t\\t\\t\\toffsetN = offset + stride;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0; j !== stride; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar value = values[ offset + j ];\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( value !== values[ offsetP + j ] ||\\n\\t\\t\\t\\t\\t\\t\\t\\tvalue !== values[ offsetN + j ] ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tkeep = true;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tkeep = true;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// in-place compaction\\n\\n\\t\\t\\t\\tif ( keep ) {\\n\\n\\t\\t\\t\\t\\tif ( i !== writeIndex ) {\\n\\n\\t\\t\\t\\t\\t\\ttimes[ writeIndex ] = times[ i ];\\n\\n\\t\\t\\t\\t\\t\\tvar readOffset = i * stride,\\n\\t\\t\\t\\t\\t\\t\\twriteOffset = writeIndex * stride;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0; j !== stride; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvalues[ writeOffset + j ] = values[ readOffset + j ];\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t++ writeIndex;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// flush last keyframe (compaction looks ahead)\\n\\n\\t\\t\\tif ( lastIndex > 0 ) {\\n\\n\\t\\t\\t\\ttimes[ writeIndex ] = times[ lastIndex ];\\n\\n\\t\\t\\t\\tfor ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {\\n\\n\\t\\t\\t\\t\\tvalues[ writeOffset + j ] = values[ readOffset + j ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t++ writeIndex;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( writeIndex !== times.length ) {\\n\\n\\t\\t\\t\\tthis.times = AnimationUtils.arraySlice( times, 0, writeIndex );\\n\\t\\t\\t\\tthis.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A Track of vectored keyframe values.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction VectorKeyframeTrack( name, times, values, interpolation ) {\\n\\n\\t\\tKeyframeTrack.call( this, name, times, values, interpolation );\\n\\n\\t}\\n\\n\\tVectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {\\n\\n\\t\\tconstructor: VectorKeyframeTrack,\\n\\n\\t\\tValueTypeName: 'vector'\\n\\n\\t\\t// ValueBufferType is inherited\\n\\n\\t\\t// DefaultInterpolation is inherited\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * Reusable set of Tracks that represent an animation.\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t */\\n\\n\\tfunction AnimationClip( name, duration, tracks ) {\\n\\n\\t\\tthis.name = name;\\n\\t\\tthis.tracks = tracks;\\n\\t\\tthis.duration = ( duration !== undefined ) ? duration : - 1;\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\t// this means it should figure out its duration by scanning the tracks\\n\\t\\tif ( this.duration < 0 ) {\\n\\n\\t\\t\\tthis.resetDuration();\\n\\n\\t\\t}\\n\\n\\t\\tthis.optimize();\\n\\n\\t}\\n\\n\\tObject.assign( AnimationClip, {\\n\\n\\t\\tparse: function ( json ) {\\n\\n\\t\\t\\tvar tracks = [],\\n\\t\\t\\t\\tjsonTracks = json.tracks,\\n\\t\\t\\t\\tframeTime = 1.0 / ( json.fps || 1.0 );\\n\\n\\t\\t\\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\ttracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn new AnimationClip( json.name, json.duration, tracks );\\n\\n\\t\\t},\\n\\n\\t\\ttoJSON: function ( clip ) {\\n\\n\\t\\t\\tvar tracks = [],\\n\\t\\t\\t\\tclipTracks = clip.tracks;\\n\\n\\t\\t\\tvar json = {\\n\\n\\t\\t\\t\\t'name': clip.name,\\n\\t\\t\\t\\t'duration': clip.duration,\\n\\t\\t\\t\\t'tracks': tracks\\n\\n\\t\\t\\t};\\n\\n\\t\\t\\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\ttracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn json;\\n\\n\\t\\t},\\n\\n\\t\\tCreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {\\n\\n\\t\\t\\tvar numMorphTargets = morphTargetSequence.length;\\n\\t\\t\\tvar tracks = [];\\n\\n\\t\\t\\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\\n\\n\\t\\t\\t\\tvar times = [];\\n\\t\\t\\t\\tvar values = [];\\n\\n\\t\\t\\t\\ttimes.push(\\n\\t\\t\\t\\t\\t( i + numMorphTargets - 1 ) % numMorphTargets,\\n\\t\\t\\t\\t\\ti,\\n\\t\\t\\t\\t\\t( i + 1 ) % numMorphTargets );\\n\\n\\t\\t\\t\\tvalues.push( 0, 1, 0 );\\n\\n\\t\\t\\t\\tvar order = AnimationUtils.getKeyframeOrder( times );\\n\\t\\t\\t\\ttimes = AnimationUtils.sortedArray( times, 1, order );\\n\\t\\t\\t\\tvalues = AnimationUtils.sortedArray( values, 1, order );\\n\\n\\t\\t\\t\\t// if there is a key at the first frame, duplicate it as the\\n\\t\\t\\t\\t// last frame as well for perfect loop.\\n\\t\\t\\t\\tif ( ! noLoop && times[ 0 ] === 0 ) {\\n\\n\\t\\t\\t\\t\\ttimes.push( numMorphTargets );\\n\\t\\t\\t\\t\\tvalues.push( values[ 0 ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\ttracks.push(\\n\\t\\t\\t\\t\\tnew NumberKeyframeTrack(\\n\\t\\t\\t\\t\\t\\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\\n\\t\\t\\t\\t\\t\\ttimes, values\\n\\t\\t\\t\\t\\t).scale( 1.0 / fps ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn new AnimationClip( name, - 1, tracks );\\n\\n\\t\\t},\\n\\n\\t\\tfindByName: function ( objectOrClipArray, name ) {\\n\\n\\t\\t\\tvar clipArray = objectOrClipArray;\\n\\n\\t\\t\\tif ( ! Array.isArray( objectOrClipArray ) ) {\\n\\n\\t\\t\\t\\tvar o = objectOrClipArray;\\n\\t\\t\\t\\tclipArray = o.geometry && o.geometry.animations || o.animations;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0; i < clipArray.length; i ++ ) {\\n\\n\\t\\t\\t\\tif ( clipArray[ i ].name === name ) {\\n\\n\\t\\t\\t\\t\\treturn clipArray[ i ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\n\\t\\t},\\n\\n\\t\\tCreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {\\n\\n\\t\\t\\tvar animationToMorphTargets = {};\\n\\n\\t\\t\\t// tested with https://regex101.com/ on trick sequences\\n\\t\\t\\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\\n\\t\\t\\tvar pattern = /^([\\\\w-]*?)([\\\\d]+)$/;\\n\\n\\t\\t\\t// sort morph target names into animation groups based\\n\\t\\t\\t// patterns like Walk_001, Walk_002, Run_001, Run_002\\n\\t\\t\\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\tvar morphTarget = morphTargets[ i ];\\n\\t\\t\\t\\tvar parts = morphTarget.name.match( pattern );\\n\\n\\t\\t\\t\\tif ( parts && parts.length > 1 ) {\\n\\n\\t\\t\\t\\t\\tvar name = parts[ 1 ];\\n\\n\\t\\t\\t\\t\\tvar animationMorphTargets = animationToMorphTargets[ name ];\\n\\t\\t\\t\\t\\tif ( ! animationMorphTargets ) {\\n\\n\\t\\t\\t\\t\\t\\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tanimationMorphTargets.push( morphTarget );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar clips = [];\\n\\n\\t\\t\\tfor ( var name in animationToMorphTargets ) {\\n\\n\\t\\t\\t\\tclips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn clips;\\n\\n\\t\\t},\\n\\n\\t\\t// parse the animation.hierarchy format\\n\\t\\tparseAnimation: function ( animation, bones ) {\\n\\n\\t\\t\\tif ( ! animation ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );\\n\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {\\n\\n\\t\\t\\t\\t// only return track if there are actually keys.\\n\\t\\t\\t\\tif ( animationKeys.length !== 0 ) {\\n\\n\\t\\t\\t\\t\\tvar times = [];\\n\\t\\t\\t\\t\\tvar values = [];\\n\\n\\t\\t\\t\\t\\tAnimationUtils.flattenJSON( animationKeys, times, values, propertyName );\\n\\n\\t\\t\\t\\t\\t// empty keys are filtered out, so check again\\n\\t\\t\\t\\t\\tif ( times.length !== 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tdestTracks.push( new trackType( trackName, times, values ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t\\tvar tracks = [];\\n\\n\\t\\t\\tvar clipName = animation.name || 'default';\\n\\t\\t\\t// automatic length determination in AnimationClip.\\n\\t\\t\\tvar duration = animation.length || - 1;\\n\\t\\t\\tvar fps = animation.fps || 30;\\n\\n\\t\\t\\tvar hierarchyTracks = animation.hierarchy || [];\\n\\n\\t\\t\\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\\n\\n\\t\\t\\t\\tvar animationKeys = hierarchyTracks[ h ].keys;\\n\\n\\t\\t\\t\\t// skip empty tracks\\n\\t\\t\\t\\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\\n\\n\\t\\t\\t\\t// process morph targets\\n\\t\\t\\t\\tif ( animationKeys[ 0 ].morphTargets ) {\\n\\n\\t\\t\\t\\t\\t// figure out all morph targets used in this track\\n\\t\\t\\t\\t\\tvar morphTargetNames = {};\\n\\n\\t\\t\\t\\t\\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( animationKeys[ k ].morphTargets ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tmorphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// create a track for each morph target with all zero\\n\\t\\t\\t\\t\\t// morphTargetInfluences except for the keys in which\\n\\t\\t\\t\\t\\t// the morphTarget is named.\\n\\t\\t\\t\\t\\tfor ( var morphTargetName in morphTargetNames ) {\\n\\n\\t\\t\\t\\t\\t\\tvar times = [];\\n\\t\\t\\t\\t\\t\\tvar values = [];\\n\\n\\t\\t\\t\\t\\t\\tfor ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar animationKey = animationKeys[ k ];\\n\\n\\t\\t\\t\\t\\t\\t\\ttimes.push( animationKey.time );\\n\\t\\t\\t\\t\\t\\t\\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\ttracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tduration = morphTargetNames.length * ( fps || 1.0 );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t// ...assume skeletal animation\\n\\n\\t\\t\\t\\t\\tvar boneName = '.bones[' + bones[ h ].name + ']';\\n\\n\\t\\t\\t\\t\\taddNonemptyTrack(\\n\\t\\t\\t\\t\\t\\tVectorKeyframeTrack, boneName + '.position',\\n\\t\\t\\t\\t\\t\\tanimationKeys, 'pos', tracks );\\n\\n\\t\\t\\t\\t\\taddNonemptyTrack(\\n\\t\\t\\t\\t\\t\\tQuaternionKeyframeTrack, boneName + '.quaternion',\\n\\t\\t\\t\\t\\t\\tanimationKeys, 'rot', tracks );\\n\\n\\t\\t\\t\\t\\taddNonemptyTrack(\\n\\t\\t\\t\\t\\t\\tVectorKeyframeTrack, boneName + '.scale',\\n\\t\\t\\t\\t\\t\\tanimationKeys, 'scl', tracks );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( tracks.length === 0 ) {\\n\\n\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar clip = new AnimationClip( clipName, duration, tracks );\\n\\n\\t\\t\\treturn clip;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( AnimationClip.prototype, {\\n\\n\\t\\tresetDuration: function () {\\n\\n\\t\\t\\tvar tracks = this.tracks, duration = 0;\\n\\n\\t\\t\\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tvar track = this.tracks[ i ];\\n\\n\\t\\t\\t\\tduration = Math.max( duration, track.times[ track.times.length - 1 ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.duration = duration;\\n\\n\\t\\t},\\n\\n\\t\\ttrim: function () {\\n\\n\\t\\t\\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\\n\\n\\t\\t\\t\\tthis.tracks[ i ].trim( 0, this.duration );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\toptimize: function () {\\n\\n\\t\\t\\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\\n\\n\\t\\t\\t\\tthis.tracks[ i ].optimize();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction MaterialLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\t\\tthis.textures = {};\\n\\n\\t}\\n\\n\\tObject.assign( MaterialLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar loader = new FileLoader( scope.manager );\\n\\t\\t\\tloader.load( url, function ( text ) {\\n\\n\\t\\t\\t\\tonLoad( scope.parse( JSON.parse( text ) ) );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t},\\n\\n\\t\\tsetTextures: function ( value ) {\\n\\n\\t\\t\\tthis.textures = value;\\n\\n\\t\\t},\\n\\n\\t\\tparse: function ( json ) {\\n\\n\\t\\t\\tvar textures = this.textures;\\n\\n\\t\\t\\tfunction getTexture( name ) {\\n\\n\\t\\t\\t\\tif ( textures[ name ] === undefined ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn textures[ name ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar material = new Materials[ json.type ]();\\n\\n\\t\\t\\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\\n\\t\\t\\tif ( json.name !== undefined ) material.name = json.name;\\n\\t\\t\\tif ( json.color !== undefined ) material.color.setHex( json.color );\\n\\t\\t\\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\\n\\t\\t\\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\\n\\t\\t\\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\\n\\t\\t\\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\\n\\t\\t\\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\\n\\t\\t\\tif ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;\\n\\t\\t\\tif ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;\\n\\t\\t\\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\\n\\t\\t\\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\\n\\t\\t\\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\\n\\t\\t\\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\\n\\t\\t\\tif ( json.fog !== undefined ) material.fog = json.fog;\\n\\t\\t\\tif ( json.flatShading !== undefined ) material.flatShading = json.flatShading;\\n\\t\\t\\tif ( json.blending !== undefined ) material.blending = json.blending;\\n\\t\\t\\tif ( json.side !== undefined ) material.side = json.side;\\n\\t\\t\\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\\n\\t\\t\\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\\n\\t\\t\\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\\n\\t\\t\\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\\n\\t\\t\\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\\n\\t\\t\\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\\n\\t\\t\\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\\n\\t\\t\\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\\n\\t\\t\\tif ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;\\n\\t\\t\\tif ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;\\n\\n\\t\\t\\tif ( json.rotation !== undefined ) material.rotation = json.rotation;\\n\\n\\t\\t\\tif ( json.linewidth !== 1 ) material.linewidth = json.linewidth;\\n\\t\\t\\tif ( json.dashSize !== undefined ) material.dashSize = json.dashSize;\\n\\t\\t\\tif ( json.gapSize !== undefined ) material.gapSize = json.gapSize;\\n\\t\\t\\tif ( json.scale !== undefined ) material.scale = json.scale;\\n\\n\\t\\t\\tif ( json.skinning !== undefined ) material.skinning = json.skinning;\\n\\t\\t\\tif ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;\\n\\t\\t\\tif ( json.dithering !== undefined ) material.dithering = json.dithering;\\n\\n\\t\\t\\tif ( json.visible !== undefined ) material.visible = json.visible;\\n\\t\\t\\tif ( json.userData !== undefined ) material.userData = json.userData;\\n\\n\\t\\t\\t// Deprecated\\n\\n\\t\\t\\tif ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading\\n\\n\\t\\t\\t// for PointsMaterial\\n\\n\\t\\t\\tif ( json.size !== undefined ) material.size = json.size;\\n\\t\\t\\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\\n\\n\\t\\t\\t// maps\\n\\n\\t\\t\\tif ( json.map !== undefined ) material.map = getTexture( json.map );\\n\\n\\t\\t\\tif ( json.alphaMap !== undefined ) {\\n\\n\\t\\t\\t\\tmaterial.alphaMap = getTexture( json.alphaMap );\\n\\t\\t\\t\\tmaterial.transparent = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );\\n\\t\\t\\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\\n\\n\\t\\t\\tif ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );\\n\\t\\t\\tif ( json.normalScale !== undefined ) {\\n\\n\\t\\t\\t\\tvar normalScale = json.normalScale;\\n\\n\\t\\t\\t\\tif ( Array.isArray( normalScale ) === false ) {\\n\\n\\t\\t\\t\\t\\t// Blender exporter used to export a scalar. See #7459\\n\\n\\t\\t\\t\\t\\tnormalScale = [ normalScale, normalScale ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tmaterial.normalScale = new Vector2().fromArray( normalScale );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );\\n\\t\\t\\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\\n\\t\\t\\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\\n\\n\\t\\t\\tif ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );\\n\\t\\t\\tif ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );\\n\\n\\t\\t\\tif ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );\\n\\t\\t\\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\\n\\n\\t\\t\\tif ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );\\n\\n\\t\\t\\tif ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );\\n\\n\\t\\t\\tif ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;\\n\\n\\t\\t\\tif ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );\\n\\t\\t\\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\\n\\n\\t\\t\\tif ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );\\n\\t\\t\\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\\n\\n\\t\\t\\tif ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );\\n\\n\\t\\t\\treturn material;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction BufferGeometryLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( BufferGeometryLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar loader = new FileLoader( scope.manager );\\n\\t\\t\\tloader.load( url, function ( text ) {\\n\\n\\t\\t\\t\\tonLoad( scope.parse( JSON.parse( text ) ) );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t},\\n\\n\\t\\tparse: function ( json ) {\\n\\n\\t\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\t\\tvar index = json.data.index;\\n\\n\\t\\t\\tif ( index !== undefined ) {\\n\\n\\t\\t\\t\\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\\n\\t\\t\\t\\tgeometry.setIndex( new BufferAttribute( typedArray, 1 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar attributes = json.data.attributes;\\n\\n\\t\\t\\tfor ( var key in attributes ) {\\n\\n\\t\\t\\t\\tvar attribute = attributes[ key ];\\n\\t\\t\\t\\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\\n\\n\\t\\t\\t\\tgeometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\\n\\n\\t\\t\\tif ( groups !== undefined ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\tvar group = groups[ i ];\\n\\n\\t\\t\\t\\t\\tgeometry.addGroup( group.start, group.count, group.materialIndex );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar boundingSphere = json.data.boundingSphere;\\n\\n\\t\\t\\tif ( boundingSphere !== undefined ) {\\n\\n\\t\\t\\t\\tvar center = new Vector3();\\n\\n\\t\\t\\t\\tif ( boundingSphere.center !== undefined ) {\\n\\n\\t\\t\\t\\t\\tcenter.fromArray( boundingSphere.center );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.boundingSphere = new Sphere( center, boundingSphere.radius );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn geometry;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tvar TYPED_ARRAYS = {\\n\\t\\tInt8Array: Int8Array,\\n\\t\\tUint8Array: Uint8Array,\\n\\t\\t// Workaround for IE11 pre KB2929437. See #11440\\n\\t\\tUint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,\\n\\t\\tInt16Array: Int16Array,\\n\\t\\tUint16Array: Uint16Array,\\n\\t\\tInt32Array: Int32Array,\\n\\t\\tUint32Array: Uint32Array,\\n\\t\\tFloat32Array: Float32Array,\\n\\t\\tFloat64Array: Float64Array\\n\\t};\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Loader() {\\n\\n\\t\\tthis.onLoadStart = function () {};\\n\\t\\tthis.onLoadProgress = function () {};\\n\\t\\tthis.onLoadComplete = function () {};\\n\\n\\t}\\n\\n\\tLoader.Handlers = {\\n\\n\\t\\thandlers: [],\\n\\n\\t\\tadd: function ( regex, loader ) {\\n\\n\\t\\t\\tthis.handlers.push( regex, loader );\\n\\n\\t\\t},\\n\\n\\t\\tget: function ( file ) {\\n\\n\\t\\t\\tvar handlers = this.handlers;\\n\\n\\t\\t\\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\\n\\n\\t\\t\\t\\tvar regex = handlers[ i ];\\n\\t\\t\\t\\tvar loader = handlers[ i + 1 ];\\n\\n\\t\\t\\t\\tif ( regex.test( file ) ) {\\n\\n\\t\\t\\t\\t\\treturn loader;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tObject.assign( Loader.prototype, {\\n\\n\\t\\tcrossOrigin: undefined,\\n\\n\\t\\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\\n\\n\\t\\t\\tvar array = [];\\n\\n\\t\\t\\tfor ( var i = 0; i < materials.length; ++ i ) {\\n\\n\\t\\t\\t\\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn array;\\n\\n\\t\\t},\\n\\n\\t\\tcreateMaterial: ( function () {\\n\\n\\t\\t\\tvar BlendingMode = {\\n\\t\\t\\t\\tNoBlending: NoBlending,\\n\\t\\t\\t\\tNormalBlending: NormalBlending,\\n\\t\\t\\t\\tAdditiveBlending: AdditiveBlending,\\n\\t\\t\\t\\tSubtractiveBlending: SubtractiveBlending,\\n\\t\\t\\t\\tMultiplyBlending: MultiplyBlending,\\n\\t\\t\\t\\tCustomBlending: CustomBlending\\n\\t\\t\\t};\\n\\n\\t\\t\\tvar color = new Color();\\n\\t\\t\\tvar textureLoader = new TextureLoader();\\n\\t\\t\\tvar materialLoader = new MaterialLoader();\\n\\n\\t\\t\\treturn function createMaterial( m, texturePath, crossOrigin ) {\\n\\n\\t\\t\\t\\t// convert from old material format\\n\\n\\t\\t\\t\\tvar textures = {};\\n\\n\\t\\t\\t\\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\\n\\n\\t\\t\\t\\t\\tvar fullPath = texturePath + path;\\n\\t\\t\\t\\t\\tvar loader = Loader.Handlers.get( fullPath );\\n\\n\\t\\t\\t\\t\\tvar texture;\\n\\n\\t\\t\\t\\t\\tif ( loader !== null ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture = loader.load( fullPath );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\ttextureLoader.setCrossOrigin( crossOrigin );\\n\\t\\t\\t\\t\\t\\ttexture = textureLoader.load( fullPath );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( repeat !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.repeat.fromArray( repeat );\\n\\n\\t\\t\\t\\t\\t\\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;\\n\\t\\t\\t\\t\\t\\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( offset !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.offset.fromArray( offset );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( wrap !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;\\n\\t\\t\\t\\t\\t\\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;\\n\\n\\t\\t\\t\\t\\t\\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;\\n\\t\\t\\t\\t\\t\\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( anisotropy !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.anisotropy = anisotropy;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar uuid = _Math.generateUUID();\\n\\n\\t\\t\\t\\t\\ttextures[ uuid ] = texture;\\n\\n\\t\\t\\t\\t\\treturn uuid;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t//\\n\\n\\t\\t\\t\\tvar json = {\\n\\t\\t\\t\\t\\tuuid: _Math.generateUUID(),\\n\\t\\t\\t\\t\\ttype: 'MeshLambertMaterial'\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tfor ( var name in m ) {\\n\\n\\t\\t\\t\\t\\tvar value = m[ name ];\\n\\n\\t\\t\\t\\t\\tswitch ( name ) {\\n\\n\\t\\t\\t\\t\\t\\tcase 'DbgColor':\\n\\t\\t\\t\\t\\t\\tcase 'DbgIndex':\\n\\t\\t\\t\\t\\t\\tcase 'opticalDensity':\\n\\t\\t\\t\\t\\t\\tcase 'illumination':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'DbgName':\\n\\t\\t\\t\\t\\t\\t\\tjson.name = value;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'blending':\\n\\t\\t\\t\\t\\t\\t\\tjson.blending = BlendingMode[ value ];\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'colorAmbient':\\n\\t\\t\\t\\t\\t\\tcase 'mapAmbient':\\n\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'colorDiffuse':\\n\\t\\t\\t\\t\\t\\t\\tjson.color = color.fromArray( value ).getHex();\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'colorSpecular':\\n\\t\\t\\t\\t\\t\\t\\tjson.specular = color.fromArray( value ).getHex();\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'colorEmissive':\\n\\t\\t\\t\\t\\t\\t\\tjson.emissive = color.fromArray( value ).getHex();\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'specularCoef':\\n\\t\\t\\t\\t\\t\\t\\tjson.shininess = value;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'shading':\\n\\t\\t\\t\\t\\t\\t\\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\\n\\t\\t\\t\\t\\t\\t\\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\\n\\t\\t\\t\\t\\t\\t\\tif ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuse':\\n\\t\\t\\t\\t\\t\\t\\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuseRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuseOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuseWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapDiffuseAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissive':\\n\\t\\t\\t\\t\\t\\t\\tjson.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissiveRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissiveOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissiveWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapEmissiveAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapLight':\\n\\t\\t\\t\\t\\t\\t\\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapLightRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapLightOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapLightWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapLightAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapAO':\\n\\t\\t\\t\\t\\t\\t\\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapAORepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapAOOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapAOWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapAOAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapBump':\\n\\t\\t\\t\\t\\t\\t\\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpScale':\\n\\t\\t\\t\\t\\t\\t\\tjson.bumpScale = value;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapBumpAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapNormal':\\n\\t\\t\\t\\t\\t\\t\\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalFactor':\\n\\t\\t\\t\\t\\t\\t\\tjson.normalScale = [ value, value ];\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapNormalAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecular':\\n\\t\\t\\t\\t\\t\\t\\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecularRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecularOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecularWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapSpecularAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalness':\\n\\t\\t\\t\\t\\t\\t\\tjson.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalnessRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalnessOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalnessWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapMetalnessAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughness':\\n\\t\\t\\t\\t\\t\\t\\tjson.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughnessRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughnessOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughnessWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapRoughnessAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapAlpha':\\n\\t\\t\\t\\t\\t\\t\\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'mapAlphaRepeat':\\n\\t\\t\\t\\t\\t\\tcase 'mapAlphaOffset':\\n\\t\\t\\t\\t\\t\\tcase 'mapAlphaWrap':\\n\\t\\t\\t\\t\\t\\tcase 'mapAlphaAnisotropy':\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'flipSided':\\n\\t\\t\\t\\t\\t\\t\\tjson.side = BackSide;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'doubleSided':\\n\\t\\t\\t\\t\\t\\t\\tjson.side = DoubleSide;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'transparency':\\n\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\\n\\t\\t\\t\\t\\t\\t\\tjson.opacity = value;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'depthTest':\\n\\t\\t\\t\\t\\t\\tcase 'depthWrite':\\n\\t\\t\\t\\t\\t\\tcase 'colorWrite':\\n\\t\\t\\t\\t\\t\\tcase 'opacity':\\n\\t\\t\\t\\t\\t\\tcase 'reflectivity':\\n\\t\\t\\t\\t\\t\\tcase 'transparent':\\n\\t\\t\\t\\t\\t\\tcase 'visible':\\n\\t\\t\\t\\t\\t\\tcase 'wireframe':\\n\\t\\t\\t\\t\\t\\t\\tjson[ name ] = value;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcase 'vertexColors':\\n\\t\\t\\t\\t\\t\\t\\tif ( value === true ) json.vertexColors = VertexColors;\\n\\t\\t\\t\\t\\t\\t\\tif ( value === 'face' ) json.vertexColors = FaceColors;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\\n\\t\\t\\t\\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\\n\\n\\t\\t\\t\\tif ( json.opacity < 1 ) json.transparent = true;\\n\\n\\t\\t\\t\\tmaterialLoader.setTextures( textures );\\n\\n\\t\\t\\t\\treturn materialLoader.parse( json );\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )()\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author Don McCurdy / https://www.donmccurdy.com\\n\\t */\\n\\n\\tvar LoaderUtils = {\\n\\n\\t\\tdecodeText: function ( array ) {\\n\\n\\t\\t\\tif ( typeof TextDecoder !== 'undefined' ) {\\n\\n\\t\\t\\t\\treturn new TextDecoder().decode( array );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Avoid the String.fromCharCode.apply(null, array) shortcut, which\\n\\t\\t\\t// throws a \\\"maximum call stack size exceeded\\\" error for large arrays.\\n\\n\\t\\t\\tvar s = '';\\n\\n\\t\\t\\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\t// Implicitly assumes little-endian.\\n\\t\\t\\t\\ts += String.fromCharCode( array[ i ] );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn s;\\n\\n\\t\\t},\\n\\n\\t\\textractUrlBase: function ( url ) {\\n\\n\\t\\t\\tvar parts = url.split( '/' );\\n\\n\\t\\t\\tif ( parts.length === 1 ) return './';\\n\\n\\t\\t\\tparts.pop();\\n\\n\\t\\t\\treturn parts.join( '/' ) + '/';\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction JSONLoader( manager ) {\\n\\n\\t\\tif ( typeof manager === 'boolean' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\\n\\t\\t\\tmanager = undefined;\\n\\n\\t\\t}\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t\\tthis.withCredentials = false;\\n\\n\\t}\\n\\n\\tObject.assign( JSONLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar texturePath = this.texturePath && ( typeof this.texturePath === 'string' ) ? this.texturePath : LoaderUtils.extractUrlBase( url );\\n\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\n\\t\\t\\tloader.setWithCredentials( this.withCredentials );\\n\\t\\t\\tloader.load( url, function ( text ) {\\n\\n\\t\\t\\t\\tvar json = JSON.parse( text );\\n\\t\\t\\t\\tvar metadata = json.metadata;\\n\\n\\t\\t\\t\\tif ( metadata !== undefined ) {\\n\\n\\t\\t\\t\\t\\tvar type = metadata.type;\\n\\n\\t\\t\\t\\t\\tif ( type !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( type.toLowerCase() === 'object' ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( type.toLowerCase() === 'scene' ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar object = scope.parse( json, texturePath );\\n\\t\\t\\t\\tonLoad( object.geometry, object.materials );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t},\\n\\n\\t\\tsetTexturePath: function ( value ) {\\n\\n\\t\\t\\tthis.texturePath = value;\\n\\n\\t\\t},\\n\\n\\t\\tparse: ( function () {\\n\\n\\t\\t\\tfunction parseModel( json, geometry ) {\\n\\n\\t\\t\\t\\tfunction isBitSet( value, position ) {\\n\\n\\t\\t\\t\\t\\treturn value & ( 1 << position );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar i, j, fi,\\n\\n\\t\\t\\t\\t\\toffset, zLength,\\n\\n\\t\\t\\t\\t\\tcolorIndex, normalIndex, uvIndex, materialIndex,\\n\\n\\t\\t\\t\\t\\ttype,\\n\\t\\t\\t\\t\\tisQuad,\\n\\t\\t\\t\\t\\thasMaterial,\\n\\t\\t\\t\\t\\thasFaceVertexUv,\\n\\t\\t\\t\\t\\thasFaceNormal, hasFaceVertexNormal,\\n\\t\\t\\t\\t\\thasFaceColor, hasFaceVertexColor,\\n\\n\\t\\t\\t\\t\\tvertex, face, faceA, faceB, hex, normal,\\n\\n\\t\\t\\t\\t\\tuvLayer, uv, u, v,\\n\\n\\t\\t\\t\\t\\tfaces = json.faces,\\n\\t\\t\\t\\t\\tvertices = json.vertices,\\n\\t\\t\\t\\t\\tnormals = json.normals,\\n\\t\\t\\t\\t\\tcolors = json.colors,\\n\\n\\t\\t\\t\\t\\tscale = json.scale,\\n\\n\\t\\t\\t\\t\\tnUvLayers = 0;\\n\\n\\n\\t\\t\\t\\tif ( json.uvs !== undefined ) {\\n\\n\\t\\t\\t\\t\\t// disregard empty arrays\\n\\n\\t\\t\\t\\t\\tfor ( i = 0; i < json.uvs.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( json.uvs[ i ].length ) nUvLayers ++;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tfor ( i = 0; i < nUvLayers; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ] = [];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\toffset = 0;\\n\\t\\t\\t\\tzLength = vertices.length;\\n\\n\\t\\t\\t\\twhile ( offset < zLength ) {\\n\\n\\t\\t\\t\\t\\tvertex = new Vector3();\\n\\n\\t\\t\\t\\t\\tvertex.x = vertices[ offset ++ ] * scale;\\n\\t\\t\\t\\t\\tvertex.y = vertices[ offset ++ ] * scale;\\n\\t\\t\\t\\t\\tvertex.z = vertices[ offset ++ ] * scale;\\n\\n\\t\\t\\t\\t\\tgeometry.vertices.push( vertex );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\toffset = 0;\\n\\t\\t\\t\\tzLength = faces.length;\\n\\n\\t\\t\\t\\twhile ( offset < zLength ) {\\n\\n\\t\\t\\t\\t\\ttype = faces[ offset ++ ];\\n\\n\\t\\t\\t\\t\\tisQuad = isBitSet( type, 0 );\\n\\t\\t\\t\\t\\thasMaterial = isBitSet( type, 1 );\\n\\t\\t\\t\\t\\thasFaceVertexUv = isBitSet( type, 3 );\\n\\t\\t\\t\\t\\thasFaceNormal = isBitSet( type, 4 );\\n\\t\\t\\t\\t\\thasFaceVertexNormal = isBitSet( type, 5 );\\n\\t\\t\\t\\t\\thasFaceColor = isBitSet( type, 6 );\\n\\t\\t\\t\\t\\thasFaceVertexColor = isBitSet( type, 7 );\\n\\n\\t\\t\\t\\t\\t// console.log(\\\"type\\\", type, \\\"bits\\\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\\n\\n\\t\\t\\t\\t\\tif ( isQuad ) {\\n\\n\\t\\t\\t\\t\\t\\tfaceA = new Face3();\\n\\t\\t\\t\\t\\t\\tfaceA.a = faces[ offset ];\\n\\t\\t\\t\\t\\t\\tfaceA.b = faces[ offset + 1 ];\\n\\t\\t\\t\\t\\t\\tfaceA.c = faces[ offset + 3 ];\\n\\n\\t\\t\\t\\t\\t\\tfaceB = new Face3();\\n\\t\\t\\t\\t\\t\\tfaceB.a = faces[ offset + 1 ];\\n\\t\\t\\t\\t\\t\\tfaceB.b = faces[ offset + 2 ];\\n\\t\\t\\t\\t\\t\\tfaceB.c = faces[ offset + 3 ];\\n\\n\\t\\t\\t\\t\\t\\toffset += 4;\\n\\n\\t\\t\\t\\t\\t\\tif ( hasMaterial ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tmaterialIndex = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\t\\tfaceA.materialIndex = materialIndex;\\n\\t\\t\\t\\t\\t\\t\\tfaceB.materialIndex = materialIndex;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// to get face <=> uv index correspondence\\n\\n\\t\\t\\t\\t\\t\\tfi = geometry.faces.length;\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexUv ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < nUvLayers; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tuvLayer = json.uvs[ i ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ][ fi ] = [];\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tfor ( j = 0; j < 4; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuvIndex = faces[ offset ++ ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tu = uvLayer[ uvIndex * 2 ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tv = uvLayer[ uvIndex * 2 + 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuv = new Vector2( u, v );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceNormal ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tnormalIndex = faces[ offset ++ ] * 3;\\n\\n\\t\\t\\t\\t\\t\\t\\tfaceA.normal.set(\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ]\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tfaceB.normal.copy( faceA.normal );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexNormal ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < 4; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tnormalIndex = faces[ offset ++ ] * 3;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tnormal = new Vector3(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ]\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceColor ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcolorIndex = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\t\\thex = colors[ colorIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\tfaceA.color.setHex( hex );\\n\\t\\t\\t\\t\\t\\t\\tfaceB.color.setHex( hex );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexColor ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < 4; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcolorIndex = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\t\\t\\thex = colors[ colorIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tgeometry.faces.push( faceA );\\n\\t\\t\\t\\t\\t\\tgeometry.faces.push( faceB );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tface = new Face3();\\n\\t\\t\\t\\t\\t\\tface.a = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\tface.b = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\tface.c = faces[ offset ++ ];\\n\\n\\t\\t\\t\\t\\t\\tif ( hasMaterial ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tmaterialIndex = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\t\\tface.materialIndex = materialIndex;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// to get face <=> uv index correspondence\\n\\n\\t\\t\\t\\t\\t\\tfi = geometry.faces.length;\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexUv ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < nUvLayers; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tuvLayer = json.uvs[ i ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ][ fi ] = [];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tfor ( j = 0; j < 3; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuvIndex = faces[ offset ++ ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tu = uvLayer[ uvIndex * 2 ];\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tv = uvLayer[ uvIndex * 2 + 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tuv = new Vector2( u, v );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceNormal ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tnormalIndex = faces[ offset ++ ] * 3;\\n\\n\\t\\t\\t\\t\\t\\t\\tface.normal.set(\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ]\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexNormal ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < 3; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tnormalIndex = faces[ offset ++ ] * 3;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tnormal = new Vector3(\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ++ ],\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tnormals[ normalIndex ]\\n\\t\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tface.vertexNormals.push( normal );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceColor ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcolorIndex = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\t\\tface.color.setHex( colors[ colorIndex ] );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t\\tif ( hasFaceVertexColor ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( i = 0; i < 3; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcolorIndex = faces[ offset ++ ];\\n\\t\\t\\t\\t\\t\\t\\t\\tface.vertexColors.push( new Color( colors[ colorIndex ] ) );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tgeometry.faces.push( face );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction parseSkin( json, geometry ) {\\n\\n\\t\\t\\t\\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\\n\\n\\t\\t\\t\\tif ( json.skinWeights ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\\n\\n\\t\\t\\t\\t\\t\\tvar x = json.skinWeights[ i ];\\n\\t\\t\\t\\t\\t\\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\\n\\t\\t\\t\\t\\t\\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\\n\\t\\t\\t\\t\\t\\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\\n\\n\\t\\t\\t\\t\\t\\tgeometry.skinWeights.push( new Vector4( x, y, z, w ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( json.skinIndices ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\\n\\n\\t\\t\\t\\t\\t\\tvar a = json.skinIndices[ i ];\\n\\t\\t\\t\\t\\t\\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\\n\\t\\t\\t\\t\\t\\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\\n\\t\\t\\t\\t\\t\\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\\n\\n\\t\\t\\t\\t\\t\\tgeometry.skinIndices.push( new Vector4( a, b, c, d ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tgeometry.bones = json.bones;\\n\\n\\t\\t\\t\\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\\n\\t\\t\\t\\t\\t\\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction parseMorphing( json, geometry ) {\\n\\n\\t\\t\\t\\tvar scale = json.scale;\\n\\n\\t\\t\\t\\tif ( json.morphTargets !== undefined ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tgeometry.morphTargets[ i ] = {};\\n\\t\\t\\t\\t\\t\\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\\n\\t\\t\\t\\t\\t\\tgeometry.morphTargets[ i ].vertices = [];\\n\\n\\t\\t\\t\\t\\t\\tvar dstVertices = geometry.morphTargets[ i ].vertices;\\n\\t\\t\\t\\t\\t\\tvar srcVertices = json.morphTargets[ i ].vertices;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar vertex = new Vector3();\\n\\t\\t\\t\\t\\t\\t\\tvertex.x = srcVertices[ v ] * scale;\\n\\t\\t\\t\\t\\t\\t\\tvertex.y = srcVertices[ v + 1 ] * scale;\\n\\t\\t\\t\\t\\t\\t\\tvertex.z = srcVertices[ v + 2 ] * scale;\\n\\n\\t\\t\\t\\t\\t\\t\\tdstVertices.push( vertex );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.JSONLoader: \\\"morphColors\\\" no longer supported. Using them as face colors.' );\\n\\n\\t\\t\\t\\t\\tvar faces = geometry.faces;\\n\\t\\t\\t\\t\\tvar morphColors = json.morphColors[ 0 ].colors;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tfaces[ i ].color.fromArray( morphColors, i * 3 );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction parseAnimations( json, geometry ) {\\n\\n\\t\\t\\t\\tvar outputAnimations = [];\\n\\n\\t\\t\\t\\t// parse old style Bone/Hierarchy animations\\n\\t\\t\\t\\tvar animations = [];\\n\\n\\t\\t\\t\\tif ( json.animation !== undefined ) {\\n\\n\\t\\t\\t\\t\\tanimations.push( json.animation );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( json.animations !== undefined ) {\\n\\n\\t\\t\\t\\t\\tif ( json.animations.length ) {\\n\\n\\t\\t\\t\\t\\t\\tanimations = animations.concat( json.animations );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tanimations.push( json.animations );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < animations.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );\\n\\t\\t\\t\\t\\tif ( clip ) outputAnimations.push( clip );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// parse implicit morph animations\\n\\t\\t\\t\\tif ( geometry.morphTargets ) {\\n\\n\\t\\t\\t\\t\\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\\n\\t\\t\\t\\t\\tvar morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\\n\\t\\t\\t\\t\\toutputAnimations = outputAnimations.concat( morphAnimationClips );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn function ( json, texturePath ) {\\n\\n\\t\\t\\t\\tif ( json.data !== undefined ) {\\n\\n\\t\\t\\t\\t\\t// Geometry 4.0 spec\\n\\t\\t\\t\\t\\tjson = json.data;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( json.scale !== undefined ) {\\n\\n\\t\\t\\t\\t\\tjson.scale = 1.0 / json.scale;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tjson.scale = 1.0;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar geometry = new Geometry();\\n\\n\\t\\t\\t\\tparseModel( json, geometry );\\n\\t\\t\\t\\tparseSkin( json, geometry );\\n\\t\\t\\t\\tparseMorphing( json, geometry );\\n\\t\\t\\t\\tparseAnimations( json, geometry );\\n\\n\\t\\t\\t\\tgeometry.computeFaceNormals();\\n\\t\\t\\t\\tgeometry.computeBoundingSphere();\\n\\n\\t\\t\\t\\tif ( json.materials === undefined || json.materials.length === 0 ) {\\n\\n\\t\\t\\t\\t\\treturn { geometry: geometry };\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tvar materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\\n\\n\\t\\t\\t\\t\\treturn { geometry: geometry, materials: materials };\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )()\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction ObjectLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\t\\tthis.texturePath = '';\\n\\n\\t}\\n\\n\\tObject.assign( ObjectLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tif ( this.texturePath === '' ) {\\n\\n\\t\\t\\t\\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar loader = new FileLoader( scope.manager );\\n\\t\\t\\tloader.load( url, function ( text ) {\\n\\n\\t\\t\\t\\tvar json = null;\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\tjson = JSON.parse( text );\\n\\n\\t\\t\\t\\t} catch ( error ) {\\n\\n\\t\\t\\t\\t\\tif ( onError !== undefined ) onError( error );\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE:ObjectLoader: Can\\\\'t parse ' + url + '.', error.message );\\n\\n\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar metadata = json.metadata;\\n\\n\\t\\t\\t\\tif ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.ObjectLoader: Can\\\\'t load ' + url + '. Use THREE.JSONLoader instead.' );\\n\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tscope.parse( json, onLoad );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t},\\n\\n\\t\\tsetTexturePath: function ( value ) {\\n\\n\\t\\t\\tthis.texturePath = value;\\n\\n\\t\\t},\\n\\n\\t\\tsetCrossOrigin: function ( value ) {\\n\\n\\t\\t\\tthis.crossOrigin = value;\\n\\n\\t\\t},\\n\\n\\t\\tparse: function ( json, onLoad ) {\\n\\n\\t\\t\\tvar shapes = this.parseShape( json.shapes );\\n\\t\\t\\tvar geometries = this.parseGeometries( json.geometries, shapes );\\n\\n\\t\\t\\tvar images = this.parseImages( json.images, function () {\\n\\n\\t\\t\\t\\tif ( onLoad !== undefined ) onLoad( object );\\n\\n\\t\\t\\t} );\\n\\n\\t\\t\\tvar textures = this.parseTextures( json.textures, images );\\n\\t\\t\\tvar materials = this.parseMaterials( json.materials, textures );\\n\\n\\t\\t\\tvar object = this.parseObject( json.object, geometries, materials );\\n\\n\\t\\t\\tif ( json.animations ) {\\n\\n\\t\\t\\t\\tobject.animations = this.parseAnimations( json.animations );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( json.images === undefined || json.images.length === 0 ) {\\n\\n\\t\\t\\t\\tif ( onLoad !== undefined ) onLoad( object );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn object;\\n\\n\\t\\t},\\n\\n\\t\\tparseShape: function ( json ) {\\n\\n\\t\\t\\tvar shapes = {};\\n\\n\\t\\t\\tif ( json !== undefined ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar shape = new Shape().fromJSON( json[ i ] );\\n\\n\\t\\t\\t\\t\\tshapes[ shape.uuid ] = shape;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn shapes;\\n\\n\\t\\t},\\n\\n\\t\\tparseGeometries: function ( json, shapes ) {\\n\\n\\t\\t\\tvar geometries = {};\\n\\n\\t\\t\\tif ( json !== undefined ) {\\n\\n\\t\\t\\t\\tvar geometryLoader = new JSONLoader();\\n\\t\\t\\t\\tvar bufferGeometryLoader = new BufferGeometryLoader();\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar geometry;\\n\\t\\t\\t\\t\\tvar data = json[ i ];\\n\\n\\t\\t\\t\\t\\tswitch ( data.type ) {\\n\\n\\t\\t\\t\\t\\t\\tcase 'PlaneGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'PlaneBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.width,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.height,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.widthSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'BoxGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'BoxBufferGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'CubeGeometry': // backwards compatible\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.width,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.height,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.depth,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.widthSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.depthSegments\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'CircleGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'CircleBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.segments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'CylinderGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'CylinderBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radiusTop,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radiusBottom,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.height,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.openEnded,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'ConeGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'ConeBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.height,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.openEnded,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'SphereGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'SphereBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.widthSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.heightSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiLength,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'DodecahedronGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'DodecahedronBufferGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'IcosahedronGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'IcosahedronBufferGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'OctahedronGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'OctahedronBufferGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'TetrahedronGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'TetrahedronBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.detail\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'RingGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'RingBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.innerRadius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.outerRadius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.thetaLength\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'TorusGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'TorusBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.tube,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.tubularSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.arc\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'TorusKnotGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'TorusKnotBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.tube,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.tubularSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radialSegments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.p,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.q\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'LatheGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'LatheBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.points,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.segments,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiStart,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.phiLength\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'PolyhedronGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'PolyhedronBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.vertices,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.indices,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.radius,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.details\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'ShapeGeometry':\\n\\t\\t\\t\\t\\t\\tcase 'ShapeBufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tvar geometryShapes = [];\\n\\n\\t\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = data.shapes.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tvar shape = shapes[ data.shapes[ i ] ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometryShapes.push( shape );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = new Geometries[ data.type ](\\n\\t\\t\\t\\t\\t\\t\\t\\tgeometryShapes,\\n\\t\\t\\t\\t\\t\\t\\t\\tdata.curveSegments\\n\\t\\t\\t\\t\\t\\t\\t);\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'BufferGeometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = bufferGeometryLoader.parse( data );\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tcase 'Geometry':\\n\\n\\t\\t\\t\\t\\t\\t\\tgeometry = geometryLoader.parse( data, this.texturePath ).geometry;\\n\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \\\"' + data.type + '\\\"' );\\n\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tgeometry.uuid = data.uuid;\\n\\n\\t\\t\\t\\t\\tif ( data.name !== undefined ) geometry.name = data.name;\\n\\n\\t\\t\\t\\t\\tgeometries[ data.uuid ] = geometry;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn geometries;\\n\\n\\t\\t},\\n\\n\\t\\tparseMaterials: function ( json, textures ) {\\n\\n\\t\\t\\tvar materials = {};\\n\\n\\t\\t\\tif ( json !== undefined ) {\\n\\n\\t\\t\\t\\tvar loader = new MaterialLoader();\\n\\t\\t\\t\\tloader.setTextures( textures );\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar data = json[ i ];\\n\\n\\t\\t\\t\\t\\tif ( data.type === 'MultiMaterial' ) {\\n\\n\\t\\t\\t\\t\\t\\t// Deprecated\\n\\n\\t\\t\\t\\t\\t\\tvar array = [];\\n\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0; j < data.materials.length; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tarray.push( loader.parse( data.materials[ j ] ) );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tmaterials[ data.uuid ] = array;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tmaterials[ data.uuid ] = loader.parse( data );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn materials;\\n\\n\\t\\t},\\n\\n\\t\\tparseAnimations: function ( json ) {\\n\\n\\t\\t\\tvar animations = [];\\n\\n\\t\\t\\tfor ( var i = 0; i < json.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar clip = AnimationClip.parse( json[ i ] );\\n\\n\\t\\t\\t\\tanimations.push( clip );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn animations;\\n\\n\\t\\t},\\n\\n\\t\\tparseImages: function ( json, onLoad ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\t\\t\\tvar images = {};\\n\\n\\t\\t\\tfunction loadImage( url ) {\\n\\n\\t\\t\\t\\tscope.manager.itemStart( url );\\n\\n\\t\\t\\t\\treturn loader.load( url, function () {\\n\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t}, undefined, function () {\\n\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\t\\t\\t\\t\\tscope.manager.itemError( url );\\n\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( json !== undefined && json.length > 0 ) {\\n\\n\\t\\t\\t\\tvar manager = new LoadingManager( onLoad );\\n\\n\\t\\t\\t\\tvar loader = new ImageLoader( manager );\\n\\t\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar image = json[ i ];\\n\\t\\t\\t\\t\\tvar path = /^(\\\\/\\\\/)|([a-z]+:(\\\\/\\\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\\n\\n\\t\\t\\t\\t\\timages[ image.uuid ] = loadImage( path );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn images;\\n\\n\\t\\t},\\n\\n\\t\\tparseTextures: function ( json, images ) {\\n\\n\\t\\t\\tfunction parseConstant( value, type ) {\\n\\n\\t\\t\\t\\tif ( typeof value === 'number' ) return value;\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\\n\\n\\t\\t\\t\\treturn type[ value ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar textures = {};\\n\\n\\t\\t\\tif ( json !== undefined ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar data = json[ i ];\\n\\n\\t\\t\\t\\t\\tif ( data.image === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: No \\\"image\\\" specified for', data.uuid );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( images[ data.image ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar texture = new Texture( images[ data.image ] );\\n\\t\\t\\t\\t\\ttexture.needsUpdate = true;\\n\\n\\t\\t\\t\\t\\ttexture.uuid = data.uuid;\\n\\n\\t\\t\\t\\t\\tif ( data.name !== undefined ) texture.name = data.name;\\n\\n\\t\\t\\t\\t\\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );\\n\\n\\t\\t\\t\\t\\tif ( data.offset !== undefined ) texture.offset.fromArray( data.offset );\\n\\t\\t\\t\\t\\tif ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );\\n\\t\\t\\t\\t\\tif ( data.center !== undefined ) texture.center.fromArray( data.center );\\n\\t\\t\\t\\t\\tif ( data.rotation !== undefined ) texture.rotation = data.rotation;\\n\\n\\t\\t\\t\\t\\tif ( data.wrap !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\ttexture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );\\n\\t\\t\\t\\t\\t\\ttexture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );\\n\\t\\t\\t\\t\\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );\\n\\t\\t\\t\\t\\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\\n\\n\\t\\t\\t\\t\\tif ( data.flipY !== undefined ) texture.flipY = data.flipY;\\n\\n\\t\\t\\t\\t\\ttextures[ data.uuid ] = texture;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn textures;\\n\\n\\t\\t},\\n\\n\\t\\tparseObject: function () {\\n\\n\\t\\t\\tvar matrix = new Matrix4();\\n\\n\\t\\t\\treturn function parseObject( data, geometries, materials ) {\\n\\n\\t\\t\\t\\tvar object;\\n\\n\\t\\t\\t\\tfunction getGeometry( name ) {\\n\\n\\t\\t\\t\\t\\tif ( geometries[ name ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn geometries[ name ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfunction getMaterial( name ) {\\n\\n\\t\\t\\t\\t\\tif ( name === undefined ) return undefined;\\n\\n\\t\\t\\t\\t\\tif ( Array.isArray( name ) ) {\\n\\n\\t\\t\\t\\t\\t\\tvar array = [];\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, l = name.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar uuid = name[ i ];\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( materials[ uuid ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined material', uuid );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\tarray.push( materials[ uuid ] );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\treturn array;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( materials[ name ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn materials[ name ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tswitch ( data.type ) {\\n\\n\\t\\t\\t\\t\\tcase 'Scene':\\n\\n\\t\\t\\t\\t\\t\\tobject = new Scene();\\n\\n\\t\\t\\t\\t\\t\\tif ( data.background !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( Number.isInteger( data.background ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tobject.background = new Color( data.background );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( data.fog !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( data.fog.type === 'Fog' ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tobject.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );\\n\\n\\t\\t\\t\\t\\t\\t\\t} else if ( data.fog.type === 'FogExp2' ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tobject.fog = new FogExp2( data.fog.color, data.fog.density );\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'PerspectiveCamera':\\n\\n\\t\\t\\t\\t\\t\\tobject = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\\n\\n\\t\\t\\t\\t\\t\\tif ( data.focus !== undefined ) object.focus = data.focus;\\n\\t\\t\\t\\t\\t\\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\\n\\t\\t\\t\\t\\t\\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\\n\\t\\t\\t\\t\\t\\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\\n\\t\\t\\t\\t\\t\\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'OrthographicCamera':\\n\\n\\t\\t\\t\\t\\t\\tobject = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'AmbientLight':\\n\\n\\t\\t\\t\\t\\t\\tobject = new AmbientLight( data.color, data.intensity );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'DirectionalLight':\\n\\n\\t\\t\\t\\t\\t\\tobject = new DirectionalLight( data.color, data.intensity );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'PointLight':\\n\\n\\t\\t\\t\\t\\t\\tobject = new PointLight( data.color, data.intensity, data.distance, data.decay );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'RectAreaLight':\\n\\n\\t\\t\\t\\t\\t\\tobject = new RectAreaLight( data.color, data.intensity, data.width, data.height );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'SpotLight':\\n\\n\\t\\t\\t\\t\\t\\tobject = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'HemisphereLight':\\n\\n\\t\\t\\t\\t\\t\\tobject = new HemisphereLight( data.color, data.groundColor, data.intensity );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'SkinnedMesh':\\n\\n\\t\\t\\t\\t\\t\\tconsole.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );\\n\\n\\t\\t\\t\\t\\tcase 'Mesh':\\n\\n\\t\\t\\t\\t\\t\\tvar geometry = getGeometry( data.geometry );\\n\\t\\t\\t\\t\\t\\tvar material = getMaterial( data.material );\\n\\n\\t\\t\\t\\t\\t\\tif ( geometry.bones && geometry.bones.length > 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tobject = new SkinnedMesh( geometry, material );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tobject = new Mesh( geometry, material );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'LOD':\\n\\n\\t\\t\\t\\t\\t\\tobject = new LOD();\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'Line':\\n\\n\\t\\t\\t\\t\\t\\tobject = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'LineLoop':\\n\\n\\t\\t\\t\\t\\t\\tobject = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'LineSegments':\\n\\n\\t\\t\\t\\t\\t\\tobject = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'PointCloud':\\n\\t\\t\\t\\t\\tcase 'Points':\\n\\n\\t\\t\\t\\t\\t\\tobject = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'Sprite':\\n\\n\\t\\t\\t\\t\\t\\tobject = new Sprite( getMaterial( data.material ) );\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'Group':\\n\\n\\t\\t\\t\\t\\t\\tobject = new Group();\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\t\\tobject = new Object3D();\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tobject.uuid = data.uuid;\\n\\n\\t\\t\\t\\tif ( data.name !== undefined ) object.name = data.name;\\n\\t\\t\\t\\tif ( data.matrix !== undefined ) {\\n\\n\\t\\t\\t\\t\\tmatrix.fromArray( data.matrix );\\n\\t\\t\\t\\t\\tmatrix.decompose( object.position, object.quaternion, object.scale );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tif ( data.position !== undefined ) object.position.fromArray( data.position );\\n\\t\\t\\t\\t\\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\\n\\t\\t\\t\\t\\tif ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );\\n\\t\\t\\t\\t\\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\\n\\t\\t\\t\\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\\n\\n\\t\\t\\t\\tif ( data.shadow ) {\\n\\n\\t\\t\\t\\t\\tif ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;\\n\\t\\t\\t\\t\\tif ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;\\n\\t\\t\\t\\t\\tif ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );\\n\\t\\t\\t\\t\\tif ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( data.visible !== undefined ) object.visible = data.visible;\\n\\t\\t\\t\\tif ( data.userData !== undefined ) object.userData = data.userData;\\n\\n\\t\\t\\t\\tif ( data.children !== undefined ) {\\n\\n\\t\\t\\t\\t\\tvar children = data.children;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < children.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tobject.add( this.parseObject( children[ i ], geometries, materials ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( data.type === 'LOD' ) {\\n\\n\\t\\t\\t\\t\\tvar levels = data.levels;\\n\\n\\t\\t\\t\\t\\tfor ( var l = 0; l < levels.length; l ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar level = levels[ l ];\\n\\t\\t\\t\\t\\t\\tvar child = object.getObjectByProperty( 'uuid', level.object );\\n\\n\\t\\t\\t\\t\\t\\tif ( child !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tobject.addLevel( child, level.distance );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn object;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}()\\n\\n\\t} );\\n\\n\\tvar TEXTURE_MAPPING = {\\n\\t\\tUVMapping: UVMapping,\\n\\t\\tCubeReflectionMapping: CubeReflectionMapping,\\n\\t\\tCubeRefractionMapping: CubeRefractionMapping,\\n\\t\\tEquirectangularReflectionMapping: EquirectangularReflectionMapping,\\n\\t\\tEquirectangularRefractionMapping: EquirectangularRefractionMapping,\\n\\t\\tSphericalReflectionMapping: SphericalReflectionMapping,\\n\\t\\tCubeUVReflectionMapping: CubeUVReflectionMapping,\\n\\t\\tCubeUVRefractionMapping: CubeUVRefractionMapping\\n\\t};\\n\\n\\tvar TEXTURE_WRAPPING = {\\n\\t\\tRepeatWrapping: RepeatWrapping,\\n\\t\\tClampToEdgeWrapping: ClampToEdgeWrapping,\\n\\t\\tMirroredRepeatWrapping: MirroredRepeatWrapping\\n\\t};\\n\\n\\tvar TEXTURE_FILTER = {\\n\\t\\tNearestFilter: NearestFilter,\\n\\t\\tNearestMipMapNearestFilter: NearestMipMapNearestFilter,\\n\\t\\tNearestMipMapLinearFilter: NearestMipMapLinearFilter,\\n\\t\\tLinearFilter: LinearFilter,\\n\\t\\tLinearMipMapNearestFilter: LinearMipMapNearestFilter,\\n\\t\\tLinearMipMapLinearFilter: LinearMipMapLinearFilter\\n\\t};\\n\\n\\t/**\\n\\t * @author thespite / http://clicktorelease.com/\\n\\t */\\n\\n\\tfunction ImageBitmapLoader( manager ) {\\n\\n\\t\\tif ( typeof createImageBitmap === 'undefined' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );\\n\\n\\t\\t}\\n\\n\\t\\tif ( typeof fetch === 'undefined' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );\\n\\n\\t\\t}\\n\\n\\t\\tthis.manager = manager !== undefined ? manager : DefaultLoadingManager;\\n\\t\\tthis.options = undefined;\\n\\n\\t}\\n\\n\\tImageBitmapLoader.prototype = {\\n\\n\\t\\tconstructor: ImageBitmapLoader,\\n\\n\\t\\tsetOptions: function setOptions( options ) {\\n\\n\\t\\t\\tthis.options = options;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tload: function load( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tif ( url === undefined ) url = '';\\n\\n\\t\\t\\tif ( this.path !== undefined ) url = this.path + url;\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar cached = Cache.get( url );\\n\\n\\t\\t\\tif ( cached !== undefined ) {\\n\\n\\t\\t\\t\\tscope.manager.itemStart( url );\\n\\n\\t\\t\\t\\tsetTimeout( function () {\\n\\n\\t\\t\\t\\t\\tif ( onLoad ) onLoad( cached );\\n\\n\\t\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t\\t}, 0 );\\n\\n\\t\\t\\t\\treturn cached;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfetch( url ).then( function ( res ) {\\n\\n\\t\\t\\t\\treturn res.blob();\\n\\n\\t\\t\\t} ).then( function ( blob ) {\\n\\n\\t\\t\\t\\treturn createImageBitmap( blob, scope.options );\\n\\n\\t\\t\\t} ).then( function ( imageBitmap ) {\\n\\n\\t\\t\\t\\tCache.add( url, imageBitmap );\\n\\n\\t\\t\\t\\tif ( onLoad ) onLoad( imageBitmap );\\n\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\n\\t\\t\\t} ).catch( function ( e ) {\\n\\n\\t\\t\\t\\tif ( onError ) onError( e );\\n\\n\\t\\t\\t\\tscope.manager.itemEnd( url );\\n\\t\\t\\t\\tscope.manager.itemError( url );\\n\\n\\t\\t\\t} );\\n\\n\\t\\t},\\n\\n\\t\\tsetCrossOrigin: function ( /* value */ ) {\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * minimal class for proxing functions to Path. Replaces old \\\"extractSubpaths()\\\"\\n\\t **/\\n\\n\\tfunction ShapePath() {\\n\\n\\t\\tthis.type = 'ShapePath';\\n\\n\\t\\tthis.subPaths = [];\\n\\t\\tthis.currentPath = null;\\n\\n\\t}\\n\\n\\tObject.assign( ShapePath.prototype, {\\n\\n\\t\\tmoveTo: function ( x, y ) {\\n\\n\\t\\t\\tthis.currentPath = new Path();\\n\\t\\t\\tthis.subPaths.push( this.currentPath );\\n\\t\\t\\tthis.currentPath.moveTo( x, y );\\n\\n\\t\\t},\\n\\n\\t\\tlineTo: function ( x, y ) {\\n\\n\\t\\t\\tthis.currentPath.lineTo( x, y );\\n\\n\\t\\t},\\n\\n\\t\\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\\n\\n\\t\\t\\tthis.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );\\n\\n\\t\\t},\\n\\n\\t\\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\\n\\n\\t\\t\\tthis.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );\\n\\n\\t\\t},\\n\\n\\t\\tsplineThru: function ( pts ) {\\n\\n\\t\\t\\tthis.currentPath.splineThru( pts );\\n\\n\\t\\t},\\n\\n\\t\\ttoShapes: function ( isCCW, noHoles ) {\\n\\n\\t\\t\\tfunction toShapesNoHoles( inSubpaths ) {\\n\\n\\t\\t\\t\\tvar shapes = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar tmpPath = inSubpaths[ i ];\\n\\n\\t\\t\\t\\t\\tvar tmpShape = new Shape();\\n\\t\\t\\t\\t\\ttmpShape.curves = tmpPath.curves;\\n\\n\\t\\t\\t\\t\\tshapes.push( tmpShape );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn shapes;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction isPointInsidePolygon( inPt, inPolygon ) {\\n\\n\\t\\t\\t\\tvar polyLen = inPolygon.length;\\n\\n\\t\\t\\t\\t// inPt on polygon contour => immediate success    or\\n\\t\\t\\t\\t// toggling of inside/outside at every single! intersection point of an edge\\n\\t\\t\\t\\t//  with the horizontal line through inPt, left of inPt\\n\\t\\t\\t\\t//  not counting lowerY endpoints of edges and whole edges on that line\\n\\t\\t\\t\\tvar inside = false;\\n\\t\\t\\t\\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\\n\\n\\t\\t\\t\\t\\tvar edgeLowPt = inPolygon[ p ];\\n\\t\\t\\t\\t\\tvar edgeHighPt = inPolygon[ q ];\\n\\n\\t\\t\\t\\t\\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\\n\\t\\t\\t\\t\\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\\n\\n\\t\\t\\t\\t\\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\\n\\n\\t\\t\\t\\t\\t\\t// not parallel\\n\\t\\t\\t\\t\\t\\tif ( edgeDy < 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tedgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;\\n\\t\\t\\t\\t\\t\\t\\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\t\\tif ( inPt.y === edgeLowPt.y ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( inPt.x === edgeLowPt.x )\\t\\treturn\\ttrue;\\t\\t// inPt is on contour ?\\n\\t\\t\\t\\t\\t\\t\\t// continue;\\t\\t\\t\\t// no intersection or edgeLowPt => doesn't count !!!\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\\n\\t\\t\\t\\t\\t\\t\\tif ( perpEdge === 0 )\\t\\t\\t\\treturn\\ttrue;\\t\\t// inPt is on contour ?\\n\\t\\t\\t\\t\\t\\t\\tif ( perpEdge < 0 ) \\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t\\tinside = ! inside;\\t\\t// true intersection left of inPt\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// parallel or collinear\\n\\t\\t\\t\\t\\t\\tif ( inPt.y !== edgeLowPt.y ) \\t\\tcontinue;\\t\\t\\t// parallel\\n\\t\\t\\t\\t\\t\\t// edge lies on the same horizontal line as inPt\\n\\t\\t\\t\\t\\t\\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\\n\\t\\t\\t\\t\\t\\t\\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\\t\\treturn\\ttrue;\\t// inPt: Point on contour !\\n\\t\\t\\t\\t\\t\\t// continue;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn\\tinside;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar isClockWise = ShapeUtils.isClockWise;\\n\\n\\t\\t\\tvar subPaths = this.subPaths;\\n\\t\\t\\tif ( subPaths.length === 0 ) return [];\\n\\n\\t\\t\\tif ( noHoles === true )\\treturn\\ttoShapesNoHoles( subPaths );\\n\\n\\n\\t\\t\\tvar solid, tmpPath, tmpShape, shapes = [];\\n\\n\\t\\t\\tif ( subPaths.length === 1 ) {\\n\\n\\t\\t\\t\\ttmpPath = subPaths[ 0 ];\\n\\t\\t\\t\\ttmpShape = new Shape();\\n\\t\\t\\t\\ttmpShape.curves = tmpPath.curves;\\n\\t\\t\\t\\tshapes.push( tmpShape );\\n\\t\\t\\t\\treturn shapes;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\\n\\t\\t\\tholesFirst = isCCW ? ! holesFirst : holesFirst;\\n\\n\\t\\t\\t// console.log(\\\"Holes first\\\", holesFirst);\\n\\n\\t\\t\\tvar betterShapeHoles = [];\\n\\t\\t\\tvar newShapes = [];\\n\\t\\t\\tvar newShapeHoles = [];\\n\\t\\t\\tvar mainIdx = 0;\\n\\t\\t\\tvar tmpPoints;\\n\\n\\t\\t\\tnewShapes[ mainIdx ] = undefined;\\n\\t\\t\\tnewShapeHoles[ mainIdx ] = [];\\n\\n\\t\\t\\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\ttmpPath = subPaths[ i ];\\n\\t\\t\\t\\ttmpPoints = tmpPath.getPoints();\\n\\t\\t\\t\\tsolid = isClockWise( tmpPoints );\\n\\t\\t\\t\\tsolid = isCCW ? ! solid : solid;\\n\\n\\t\\t\\t\\tif ( solid ) {\\n\\n\\t\\t\\t\\t\\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\\tmainIdx ++;\\n\\n\\t\\t\\t\\t\\tnewShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };\\n\\t\\t\\t\\t\\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\\n\\n\\t\\t\\t\\t\\tif ( holesFirst )\\tmainIdx ++;\\n\\t\\t\\t\\t\\tnewShapeHoles[ mainIdx ] = [];\\n\\n\\t\\t\\t\\t\\t//console.log('cw', i);\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\\n\\n\\t\\t\\t\\t\\t//console.log('ccw', i);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// only Holes? -> probably all Shapes with wrong orientation\\n\\t\\t\\tif ( ! newShapes[ 0 ] )\\treturn\\ttoShapesNoHoles( subPaths );\\n\\n\\n\\t\\t\\tif ( newShapes.length > 1 ) {\\n\\n\\t\\t\\t\\tvar ambiguous = false;\\n\\t\\t\\t\\tvar toChange = [];\\n\\n\\t\\t\\t\\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\\n\\n\\t\\t\\t\\t\\tbetterShapeHoles[ sIdx ] = [];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\\n\\n\\t\\t\\t\\t\\tvar sho = newShapeHoles[ sIdx ];\\n\\n\\t\\t\\t\\t\\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar ho = sho[ hIdx ];\\n\\t\\t\\t\\t\\t\\tvar hole_unassigned = true;\\n\\n\\t\\t\\t\\t\\t\\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( sIdx !== s2Idx )\\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( hole_unassigned ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\thole_unassigned = false;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tbetterShapeHoles[ s2Idx ].push( ho );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tambiguous = true;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif ( hole_unassigned ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tbetterShapeHoles[ sIdx ].push( ho );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// console.log(\\\"ambiguous: \\\", ambiguous);\\n\\t\\t\\t\\tif ( toChange.length > 0 ) {\\n\\n\\t\\t\\t\\t\\t// console.log(\\\"to change: \\\", toChange);\\n\\t\\t\\t\\t\\tif ( ! ambiguous )\\tnewShapeHoles = betterShapeHoles;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar tmpHoles;\\n\\n\\t\\t\\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\\n\\n\\t\\t\\t\\ttmpShape = newShapes[ i ].s;\\n\\t\\t\\t\\tshapes.push( tmpShape );\\n\\t\\t\\t\\ttmpHoles = newShapeHoles[ i ];\\n\\n\\t\\t\\t\\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\ttmpShape.holes.push( tmpHoles[ j ].h );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//console.log(\\\"shape\\\", shapes);\\n\\n\\t\\t\\treturn shapes;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author zz85 / http://www.lab4games.net/zz85/blog\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Font( data ) {\\n\\n\\t\\tthis.type = 'Font';\\n\\n\\t\\tthis.data = data;\\n\\n\\t}\\n\\n\\tObject.assign( Font.prototype, {\\n\\n\\t\\tisFont: true,\\n\\n\\t\\tgenerateShapes: function ( text, size, divisions ) {\\n\\n\\t\\t\\tfunction createPaths( text ) {\\n\\n\\t\\t\\t\\tvar chars = String( text ).split( '' );\\n\\t\\t\\t\\tvar scale = size / data.resolution;\\n\\t\\t\\t\\tvar line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;\\n\\n\\t\\t\\t\\tvar offsetX = 0, offsetY = 0;\\n\\n\\t\\t\\t\\tvar paths = [];\\n\\n\\t\\t\\t\\tfor ( var i = 0; i < chars.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar char = chars[ i ];\\n\\n\\t\\t\\t\\t\\tif ( char === '\\\\n' ) {\\n\\n\\t\\t\\t\\t\\t\\toffsetX = 0;\\n\\t\\t\\t\\t\\t\\toffsetY -= line_height;\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tvar ret = createPath( char, scale, offsetX, offsetY );\\n\\t\\t\\t\\t\\t\\toffsetX += ret.offsetX;\\n\\t\\t\\t\\t\\t\\tpaths.push( ret.path );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn paths;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfunction createPath( c, scale, offsetX, offsetY ) {\\n\\n\\t\\t\\t\\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\\n\\n\\t\\t\\t\\tif ( ! glyph ) return;\\n\\n\\t\\t\\t\\tvar path = new ShapePath();\\n\\n\\t\\t\\t\\tvar pts = [];\\n\\t\\t\\t\\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\\n\\n\\t\\t\\t\\tif ( glyph.o ) {\\n\\n\\t\\t\\t\\t\\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, l = outline.length; i < l; ) {\\n\\n\\t\\t\\t\\t\\t\\tvar action = outline[ i ++ ];\\n\\n\\t\\t\\t\\t\\t\\tswitch ( action ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'm': // moveTo\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tx = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\ty = outline[ i ++ ] * scale + offsetY;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tpath.moveTo( x, y );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'l': // lineTo\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tx = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\ty = outline[ i ++ ] * scale + offsetY;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tpath.lineTo( x, y );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'q': // quadraticCurveTo\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy = outline[ i ++ ] * scale + offsetY;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx1 = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy1 = outline[ i ++ ] * scale + offsetY;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tlaste = pts[ pts.length - 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( laste ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcpx0 = laste.x;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcpy0 = laste.y;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\tcase 'b': // bezierCurveTo\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy = outline[ i ++ ] * scale + offsetY;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx1 = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy1 = outline[ i ++ ] * scale + offsetY;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpx2 = outline[ i ++ ] * scale + offsetX;\\n\\t\\t\\t\\t\\t\\t\\t\\tcpy2 = outline[ i ++ ] * scale + offsetY;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tlaste = pts[ pts.length - 1 ];\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tif ( laste ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcpx0 = laste.x;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tcpy0 = laste.y;\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\n\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn { offsetX: glyph.ha * scale, path: path };\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tif ( size === undefined ) size = 100;\\n\\t\\t\\tif ( divisions === undefined ) divisions = 4;\\n\\n\\t\\t\\tvar data = this.data;\\n\\n\\t\\t\\tvar paths = createPaths( text );\\n\\t\\t\\tvar shapes = [];\\n\\n\\t\\t\\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\\n\\n\\t\\t\\t\\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn shapes;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction FontLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( FontLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\n\\t\\t\\tloader.setPath( this.path );\\n\\t\\t\\tloader.load( url, function ( text ) {\\n\\n\\t\\t\\t\\tvar json;\\n\\n\\t\\t\\t\\ttry {\\n\\n\\t\\t\\t\\t\\tjson = JSON.parse( text );\\n\\n\\t\\t\\t\\t} catch ( e ) {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\\n\\t\\t\\t\\t\\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar font = scope.parse( json );\\n\\n\\t\\t\\t\\tif ( onLoad ) onLoad( font );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t},\\n\\n\\t\\tparse: function ( json ) {\\n\\n\\t\\t\\treturn new Font( json );\\n\\n\\t\\t},\\n\\n\\t\\tsetPath: function ( value ) {\\n\\n\\t\\t\\tthis.path = value;\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tvar context;\\n\\n\\tvar AudioContext = {\\n\\n\\t\\tgetContext: function () {\\n\\n\\t\\t\\tif ( context === undefined ) {\\n\\n\\t\\t\\t\\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn context;\\n\\n\\t\\t},\\n\\n\\t\\tsetContext: function ( value ) {\\n\\n\\t\\t\\tcontext = value;\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\\n\\t */\\n\\n\\tfunction AudioLoader( manager ) {\\n\\n\\t\\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\\n\\n\\t}\\n\\n\\tObject.assign( AudioLoader.prototype, {\\n\\n\\t\\tload: function ( url, onLoad, onProgress, onError ) {\\n\\n\\t\\t\\tvar loader = new FileLoader( this.manager );\\n\\t\\t\\tloader.setResponseType( 'arraybuffer' );\\n\\t\\t\\tloader.load( url, function ( buffer ) {\\n\\n\\t\\t\\t\\tvar context = AudioContext.getContext();\\n\\n\\t\\t\\t\\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\\n\\n\\t\\t\\t\\t\\tonLoad( audioBuffer );\\n\\n\\t\\t\\t\\t} );\\n\\n\\t\\t\\t}, onProgress, onError );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction StereoCamera() {\\n\\n\\t\\tthis.type = 'StereoCamera';\\n\\n\\t\\tthis.aspect = 1;\\n\\n\\t\\tthis.eyeSep = 0.064;\\n\\n\\t\\tthis.cameraL = new PerspectiveCamera();\\n\\t\\tthis.cameraL.layers.enable( 1 );\\n\\t\\tthis.cameraL.matrixAutoUpdate = false;\\n\\n\\t\\tthis.cameraR = new PerspectiveCamera();\\n\\t\\tthis.cameraR.layers.enable( 2 );\\n\\t\\tthis.cameraR.matrixAutoUpdate = false;\\n\\n\\t}\\n\\n\\tObject.assign( StereoCamera.prototype, {\\n\\n\\t\\tupdate: ( function () {\\n\\n\\t\\t\\tvar instance, focus, fov, aspect, near, far, zoom, eyeSep;\\n\\n\\t\\t\\tvar eyeRight = new Matrix4();\\n\\t\\t\\tvar eyeLeft = new Matrix4();\\n\\n\\t\\t\\treturn function update( camera ) {\\n\\n\\t\\t\\t\\tvar needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\taspect !== camera.aspect * this.aspect || near !== camera.near ||\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tfar !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;\\n\\n\\t\\t\\t\\tif ( needsUpdate ) {\\n\\n\\t\\t\\t\\t\\tinstance = this;\\n\\t\\t\\t\\t\\tfocus = camera.focus;\\n\\t\\t\\t\\t\\tfov = camera.fov;\\n\\t\\t\\t\\t\\taspect = camera.aspect * this.aspect;\\n\\t\\t\\t\\t\\tnear = camera.near;\\n\\t\\t\\t\\t\\tfar = camera.far;\\n\\t\\t\\t\\t\\tzoom = camera.zoom;\\n\\n\\t\\t\\t\\t\\t// Off-axis stereoscopic effect based on\\n\\t\\t\\t\\t\\t// http://paulbourke.net/stereographics/stereorender/\\n\\n\\t\\t\\t\\t\\tvar projectionMatrix = camera.projectionMatrix.clone();\\n\\t\\t\\t\\t\\teyeSep = this.eyeSep / 2;\\n\\t\\t\\t\\t\\tvar eyeSepOnProjection = eyeSep * near / focus;\\n\\t\\t\\t\\t\\tvar ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;\\n\\t\\t\\t\\t\\tvar xmin, xmax;\\n\\n\\t\\t\\t\\t\\t// translate xOffset\\n\\n\\t\\t\\t\\t\\teyeLeft.elements[ 12 ] = - eyeSep;\\n\\t\\t\\t\\t\\teyeRight.elements[ 12 ] = eyeSep;\\n\\n\\t\\t\\t\\t\\t// for left eye\\n\\n\\t\\t\\t\\t\\txmin = - ymax * aspect + eyeSepOnProjection;\\n\\t\\t\\t\\t\\txmax = ymax * aspect + eyeSepOnProjection;\\n\\n\\t\\t\\t\\t\\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\\n\\t\\t\\t\\t\\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\\n\\n\\t\\t\\t\\t\\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\\n\\n\\t\\t\\t\\t\\t// for right eye\\n\\n\\t\\t\\t\\t\\txmin = - ymax * aspect - eyeSepOnProjection;\\n\\t\\t\\t\\t\\txmax = ymax * aspect - eyeSepOnProjection;\\n\\n\\t\\t\\t\\t\\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\\n\\t\\t\\t\\t\\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\\n\\n\\t\\t\\t\\t\\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\\n\\t\\t\\t\\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )()\\n\\n\\t} );\\n\\n\\t/**\\n\\t * Camera for rendering cube maps\\n\\t *\\t- renders scene into axis-aligned cube\\n\\t *\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction CubeCamera( near, far, cubeResolution ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'CubeCamera';\\n\\n\\t\\tvar fov = 90, aspect = 1;\\n\\n\\t\\tvar cameraPX = new PerspectiveCamera( fov, aspect, near, far );\\n\\t\\tcameraPX.up.set( 0, - 1, 0 );\\n\\t\\tcameraPX.lookAt( new Vector3( 1, 0, 0 ) );\\n\\t\\tthis.add( cameraPX );\\n\\n\\t\\tvar cameraNX = new PerspectiveCamera( fov, aspect, near, far );\\n\\t\\tcameraNX.up.set( 0, - 1, 0 );\\n\\t\\tcameraNX.lookAt( new Vector3( - 1, 0, 0 ) );\\n\\t\\tthis.add( cameraNX );\\n\\n\\t\\tvar cameraPY = new PerspectiveCamera( fov, aspect, near, far );\\n\\t\\tcameraPY.up.set( 0, 0, 1 );\\n\\t\\tcameraPY.lookAt( new Vector3( 0, 1, 0 ) );\\n\\t\\tthis.add( cameraPY );\\n\\n\\t\\tvar cameraNY = new PerspectiveCamera( fov, aspect, near, far );\\n\\t\\tcameraNY.up.set( 0, 0, - 1 );\\n\\t\\tcameraNY.lookAt( new Vector3( 0, - 1, 0 ) );\\n\\t\\tthis.add( cameraNY );\\n\\n\\t\\tvar cameraPZ = new PerspectiveCamera( fov, aspect, near, far );\\n\\t\\tcameraPZ.up.set( 0, - 1, 0 );\\n\\t\\tcameraPZ.lookAt( new Vector3( 0, 0, 1 ) );\\n\\t\\tthis.add( cameraPZ );\\n\\n\\t\\tvar cameraNZ = new PerspectiveCamera( fov, aspect, near, far );\\n\\t\\tcameraNZ.up.set( 0, - 1, 0 );\\n\\t\\tcameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );\\n\\t\\tthis.add( cameraNZ );\\n\\n\\t\\tvar options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };\\n\\n\\t\\tthis.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\\n\\t\\tthis.renderTarget.texture.name = \\\"CubeCamera\\\";\\n\\n\\t\\tthis.update = function ( renderer, scene ) {\\n\\n\\t\\t\\tif ( this.parent === null ) this.updateMatrixWorld();\\n\\n\\t\\t\\tvar renderTarget = this.renderTarget;\\n\\t\\t\\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\\n\\n\\t\\t\\trenderTarget.texture.generateMipmaps = false;\\n\\n\\t\\t\\trenderTarget.activeCubeFace = 0;\\n\\t\\t\\trenderer.render( scene, cameraPX, renderTarget );\\n\\n\\t\\t\\trenderTarget.activeCubeFace = 1;\\n\\t\\t\\trenderer.render( scene, cameraNX, renderTarget );\\n\\n\\t\\t\\trenderTarget.activeCubeFace = 2;\\n\\t\\t\\trenderer.render( scene, cameraPY, renderTarget );\\n\\n\\t\\t\\trenderTarget.activeCubeFace = 3;\\n\\t\\t\\trenderer.render( scene, cameraNY, renderTarget );\\n\\n\\t\\t\\trenderTarget.activeCubeFace = 4;\\n\\t\\t\\trenderer.render( scene, cameraPZ, renderTarget );\\n\\n\\t\\t\\trenderTarget.texture.generateMipmaps = generateMipmaps;\\n\\n\\t\\t\\trenderTarget.activeCubeFace = 5;\\n\\t\\t\\trenderer.render( scene, cameraNZ, renderTarget );\\n\\n\\t\\t\\trenderer.setRenderTarget( null );\\n\\n\\t\\t};\\n\\n\\t\\tthis.clear = function ( renderer, color, depth, stencil ) {\\n\\n\\t\\t\\tvar renderTarget = this.renderTarget;\\n\\n\\t\\t\\tfor ( var i = 0; i < 6; i ++ ) {\\n\\n\\t\\t\\t\\trenderTarget.activeCubeFace = i;\\n\\t\\t\\t\\trenderer.setRenderTarget( renderTarget );\\n\\n\\t\\t\\t\\trenderer.clear( color, depth, stencil );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\trenderer.setRenderTarget( null );\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\tCubeCamera.prototype = Object.create( Object3D.prototype );\\n\\tCubeCamera.prototype.constructor = CubeCamera;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction AudioListener() {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'AudioListener';\\n\\n\\t\\tthis.context = AudioContext.getContext();\\n\\n\\t\\tthis.gain = this.context.createGain();\\n\\t\\tthis.gain.connect( this.context.destination );\\n\\n\\t\\tthis.filter = null;\\n\\n\\t}\\n\\n\\tAudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: AudioListener,\\n\\n\\t\\tgetInput: function () {\\n\\n\\t\\t\\treturn this.gain;\\n\\n\\t\\t},\\n\\n\\t\\tremoveFilter: function ( ) {\\n\\n\\t\\t\\tif ( this.filter !== null ) {\\n\\n\\t\\t\\t\\tthis.gain.disconnect( this.filter );\\n\\t\\t\\t\\tthis.filter.disconnect( this.context.destination );\\n\\t\\t\\t\\tthis.gain.connect( this.context.destination );\\n\\t\\t\\t\\tthis.filter = null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tgetFilter: function () {\\n\\n\\t\\t\\treturn this.filter;\\n\\n\\t\\t},\\n\\n\\t\\tsetFilter: function ( value ) {\\n\\n\\t\\t\\tif ( this.filter !== null ) {\\n\\n\\t\\t\\t\\tthis.gain.disconnect( this.filter );\\n\\t\\t\\t\\tthis.filter.disconnect( this.context.destination );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.gain.disconnect( this.context.destination );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.filter = value;\\n\\t\\t\\tthis.gain.connect( this.filter );\\n\\t\\t\\tthis.filter.connect( this.context.destination );\\n\\n\\t\\t},\\n\\n\\t\\tgetMasterVolume: function () {\\n\\n\\t\\t\\treturn this.gain.gain.value;\\n\\n\\t\\t},\\n\\n\\t\\tsetMasterVolume: function ( value ) {\\n\\n\\t\\t\\tthis.gain.gain.value = value;\\n\\n\\t\\t},\\n\\n\\t\\tupdateMatrixWorld: ( function () {\\n\\n\\t\\t\\tvar position = new Vector3();\\n\\t\\t\\tvar quaternion = new Quaternion();\\n\\t\\t\\tvar scale = new Vector3();\\n\\n\\t\\t\\tvar orientation = new Vector3();\\n\\n\\t\\t\\treturn function updateMatrixWorld( force ) {\\n\\n\\t\\t\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t\\t\\t\\tvar listener = this.context.listener;\\n\\t\\t\\t\\tvar up = this.up;\\n\\n\\t\\t\\t\\tthis.matrixWorld.decompose( position, quaternion, scale );\\n\\n\\t\\t\\t\\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\\n\\n\\t\\t\\t\\tif ( listener.positionX ) {\\n\\n\\t\\t\\t\\t\\tlistener.positionX.setValueAtTime( position.x, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.positionY.setValueAtTime( position.y, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.positionZ.setValueAtTime( position.z, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.upX.setValueAtTime( up.x, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.upY.setValueAtTime( up.y, this.context.currentTime );\\n\\t\\t\\t\\t\\tlistener.upZ.setValueAtTime( up.z, this.context.currentTime );\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tlistener.setPosition( position.x, position.y, position.z );\\n\\t\\t\\t\\t\\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )()\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\\n\\t */\\n\\n\\tfunction Audio( listener ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.type = 'Audio';\\n\\n\\t\\tthis.context = listener.context;\\n\\n\\t\\tthis.gain = this.context.createGain();\\n\\t\\tthis.gain.connect( listener.getInput() );\\n\\n\\t\\tthis.autoplay = false;\\n\\n\\t\\tthis.buffer = null;\\n\\t\\tthis.loop = false;\\n\\t\\tthis.startTime = 0;\\n\\t\\tthis.offset = 0;\\n\\t\\tthis.playbackRate = 1;\\n\\t\\tthis.isPlaying = false;\\n\\t\\tthis.hasPlaybackControl = true;\\n\\t\\tthis.sourceType = 'empty';\\n\\n\\t\\tthis.filters = [];\\n\\n\\t}\\n\\n\\tAudio.prototype = Object.assign( Object.create( Object3D.prototype ), {\\n\\n\\t\\tconstructor: Audio,\\n\\n\\t\\tgetOutput: function () {\\n\\n\\t\\t\\treturn this.gain;\\n\\n\\t\\t},\\n\\n\\t\\tsetNodeSource: function ( audioNode ) {\\n\\n\\t\\t\\tthis.hasPlaybackControl = false;\\n\\t\\t\\tthis.sourceType = 'audioNode';\\n\\t\\t\\tthis.source = audioNode;\\n\\t\\t\\tthis.connect();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetBuffer: function ( audioBuffer ) {\\n\\n\\t\\t\\tthis.buffer = audioBuffer;\\n\\t\\t\\tthis.sourceType = 'buffer';\\n\\n\\t\\t\\tif ( this.autoplay ) this.play();\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tplay: function () {\\n\\n\\t\\t\\tif ( this.isPlaying === true ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar source = this.context.createBufferSource();\\n\\n\\t\\t\\tsource.buffer = this.buffer;\\n\\t\\t\\tsource.loop = this.loop;\\n\\t\\t\\tsource.onended = this.onEnded.bind( this );\\n\\t\\t\\tsource.playbackRate.setValueAtTime( this.playbackRate, this.startTime );\\n\\t\\t\\tthis.startTime = this.context.currentTime;\\n\\t\\t\\tsource.start( this.startTime, this.offset );\\n\\n\\t\\t\\tthis.isPlaying = true;\\n\\n\\t\\t\\tthis.source = source;\\n\\n\\t\\t\\treturn this.connect();\\n\\n\\t\\t},\\n\\n\\t\\tpause: function () {\\n\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.isPlaying === true ) {\\n\\n\\t\\t\\t\\tthis.source.stop();\\n\\t\\t\\t\\tthis.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;\\n\\t\\t\\t\\tthis.isPlaying = false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tstop: function () {\\n\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.source.stop();\\n\\t\\t\\tthis.offset = 0;\\n\\t\\t\\tthis.isPlaying = false;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tconnect: function () {\\n\\n\\t\\t\\tif ( this.filters.length > 0 ) {\\n\\n\\t\\t\\t\\tthis.source.connect( this.filters[ 0 ] );\\n\\n\\t\\t\\t\\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.source.connect( this.getOutput() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tdisconnect: function () {\\n\\n\\t\\t\\tif ( this.filters.length > 0 ) {\\n\\n\\t\\t\\t\\tthis.source.disconnect( this.filters[ 0 ] );\\n\\n\\t\\t\\t\\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.source.disconnect( this.getOutput() );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetFilters: function () {\\n\\n\\t\\t\\treturn this.filters;\\n\\n\\t\\t},\\n\\n\\t\\tsetFilters: function ( value ) {\\n\\n\\t\\t\\tif ( ! value ) value = [];\\n\\n\\t\\t\\tif ( this.isPlaying === true ) {\\n\\n\\t\\t\\t\\tthis.disconnect();\\n\\t\\t\\t\\tthis.filters = value;\\n\\t\\t\\t\\tthis.connect();\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.filters = value;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetFilter: function () {\\n\\n\\t\\t\\treturn this.getFilters()[ 0 ];\\n\\n\\t\\t},\\n\\n\\t\\tsetFilter: function ( filter ) {\\n\\n\\t\\t\\treturn this.setFilters( filter ? [ filter ] : [] );\\n\\n\\t\\t},\\n\\n\\t\\tsetPlaybackRate: function ( value ) {\\n\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.playbackRate = value;\\n\\n\\t\\t\\tif ( this.isPlaying === true ) {\\n\\n\\t\\t\\t\\tthis.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetPlaybackRate: function () {\\n\\n\\t\\t\\treturn this.playbackRate;\\n\\n\\t\\t},\\n\\n\\t\\tonEnded: function () {\\n\\n\\t\\t\\tthis.isPlaying = false;\\n\\n\\t\\t},\\n\\n\\t\\tgetLoop: function () {\\n\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this.loop;\\n\\n\\t\\t},\\n\\n\\t\\tsetLoop: function ( value ) {\\n\\n\\t\\t\\tif ( this.hasPlaybackControl === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.loop = value;\\n\\n\\t\\t\\tif ( this.isPlaying === true ) {\\n\\n\\t\\t\\t\\tthis.source.loop = this.loop;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetVolume: function () {\\n\\n\\t\\t\\treturn this.gain.gain.value;\\n\\n\\t\\t},\\n\\n\\t\\tsetVolume: function ( value ) {\\n\\n\\t\\t\\tthis.gain.gain.value = value;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction PositionalAudio( listener ) {\\n\\n\\t\\tAudio.call( this, listener );\\n\\n\\t\\tthis.panner = this.context.createPanner();\\n\\t\\tthis.panner.connect( this.gain );\\n\\n\\t}\\n\\n\\tPositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {\\n\\n\\t\\tconstructor: PositionalAudio,\\n\\n\\t\\tgetOutput: function () {\\n\\n\\t\\t\\treturn this.panner;\\n\\n\\t\\t},\\n\\n\\t\\tgetRefDistance: function () {\\n\\n\\t\\t\\treturn this.panner.refDistance;\\n\\n\\t\\t},\\n\\n\\t\\tsetRefDistance: function ( value ) {\\n\\n\\t\\t\\tthis.panner.refDistance = value;\\n\\n\\t\\t},\\n\\n\\t\\tgetRolloffFactor: function () {\\n\\n\\t\\t\\treturn this.panner.rolloffFactor;\\n\\n\\t\\t},\\n\\n\\t\\tsetRolloffFactor: function ( value ) {\\n\\n\\t\\t\\tthis.panner.rolloffFactor = value;\\n\\n\\t\\t},\\n\\n\\t\\tgetDistanceModel: function () {\\n\\n\\t\\t\\treturn this.panner.distanceModel;\\n\\n\\t\\t},\\n\\n\\t\\tsetDistanceModel: function ( value ) {\\n\\n\\t\\t\\tthis.panner.distanceModel = value;\\n\\n\\t\\t},\\n\\n\\t\\tgetMaxDistance: function () {\\n\\n\\t\\t\\treturn this.panner.maxDistance;\\n\\n\\t\\t},\\n\\n\\t\\tsetMaxDistance: function ( value ) {\\n\\n\\t\\t\\tthis.panner.maxDistance = value;\\n\\n\\t\\t},\\n\\n\\t\\tupdateMatrixWorld: ( function () {\\n\\n\\t\\t\\tvar position = new Vector3();\\n\\n\\t\\t\\treturn function updateMatrixWorld( force ) {\\n\\n\\t\\t\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t\\t\\t\\tposition.setFromMatrixPosition( this.matrixWorld );\\n\\n\\t\\t\\t\\tthis.panner.setPosition( position.x, position.y, position.z );\\n\\n\\t\\t\\t};\\n\\n\\t\\t} )()\\n\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction AudioAnalyser( audio, fftSize ) {\\n\\n\\t\\tthis.analyser = audio.context.createAnalyser();\\n\\t\\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\\n\\n\\t\\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\\n\\n\\t\\taudio.getOutput().connect( this.analyser );\\n\\n\\t}\\n\\n\\tObject.assign( AudioAnalyser.prototype, {\\n\\n\\t\\tgetFrequencyData: function () {\\n\\n\\t\\t\\tthis.analyser.getByteFrequencyData( this.data );\\n\\n\\t\\t\\treturn this.data;\\n\\n\\t\\t},\\n\\n\\t\\tgetAverageFrequency: function () {\\n\\n\\t\\t\\tvar value = 0, data = this.getFrequencyData();\\n\\n\\t\\t\\tfor ( var i = 0; i < data.length; i ++ ) {\\n\\n\\t\\t\\t\\tvalue += data[ i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn value / data.length;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * Buffered scene graph property that allows weighted accumulation.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction PropertyMixer( binding, typeName, valueSize ) {\\n\\n\\t\\tthis.binding = binding;\\n\\t\\tthis.valueSize = valueSize;\\n\\n\\t\\tvar bufferType = Float64Array,\\n\\t\\t\\tmixFunction;\\n\\n\\t\\tswitch ( typeName ) {\\n\\n\\t\\t\\tcase 'quaternion':\\n\\t\\t\\t\\tmixFunction = this._slerp;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase 'string':\\n\\t\\t\\tcase 'bool':\\n\\t\\t\\t\\tbufferType = Array;\\n\\t\\t\\t\\tmixFunction = this._select;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tdefault:\\n\\t\\t\\t\\tmixFunction = this._lerp;\\n\\n\\t\\t}\\n\\n\\t\\tthis.buffer = new bufferType( valueSize * 4 );\\n\\t\\t// layout: [ incoming | accu0 | accu1 | orig ]\\n\\t\\t//\\n\\t\\t// interpolators can use .buffer as their .result\\n\\t\\t// the data then goes to 'incoming'\\n\\t\\t//\\n\\t\\t// 'accu0' and 'accu1' are used frame-interleaved for\\n\\t\\t// the cumulative result and are compared to detect\\n\\t\\t// changes\\n\\t\\t//\\n\\t\\t// 'orig' stores the original state of the property\\n\\n\\t\\tthis._mixBufferRegion = mixFunction;\\n\\n\\t\\tthis.cumulativeWeight = 0;\\n\\n\\t\\tthis.useCount = 0;\\n\\t\\tthis.referenceCount = 0;\\n\\n\\t}\\n\\n\\tObject.assign( PropertyMixer.prototype, {\\n\\n\\t\\t// accumulate data in the 'incoming' region into 'accu<i>'\\n\\t\\taccumulate: function ( accuIndex, weight ) {\\n\\n\\t\\t\\t// note: happily accumulating nothing when weight = 0, the caller knows\\n\\t\\t\\t// the weight and shouldn't have made the call in the first place\\n\\n\\t\\t\\tvar buffer = this.buffer,\\n\\t\\t\\t\\tstride = this.valueSize,\\n\\t\\t\\t\\toffset = accuIndex * stride + stride,\\n\\n\\t\\t\\t\\tcurrentWeight = this.cumulativeWeight;\\n\\n\\t\\t\\tif ( currentWeight === 0 ) {\\n\\n\\t\\t\\t\\t// accuN := incoming * weight\\n\\n\\t\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\n\\n\\t\\t\\t\\t\\tbuffer[ offset + i ] = buffer[ i ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcurrentWeight = weight;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// accuN := accuN + incoming * weight\\n\\n\\t\\t\\t\\tcurrentWeight += weight;\\n\\t\\t\\t\\tvar mix = weight / currentWeight;\\n\\t\\t\\t\\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.cumulativeWeight = currentWeight;\\n\\n\\t\\t},\\n\\n\\t\\t// apply the state of 'accu<i>' to the binding when accus differ\\n\\t\\tapply: function ( accuIndex ) {\\n\\n\\t\\t\\tvar stride = this.valueSize,\\n\\t\\t\\t\\tbuffer = this.buffer,\\n\\t\\t\\t\\toffset = accuIndex * stride + stride,\\n\\n\\t\\t\\t\\tweight = this.cumulativeWeight,\\n\\n\\t\\t\\t\\tbinding = this.binding;\\n\\n\\t\\t\\tthis.cumulativeWeight = 0;\\n\\n\\t\\t\\tif ( weight < 1 ) {\\n\\n\\t\\t\\t\\t// accuN := accuN + original * ( 1 - cumulativeWeight )\\n\\n\\t\\t\\t\\tvar originalValueOffset = stride * 3;\\n\\n\\t\\t\\t\\tthis._mixBufferRegion(\\n\\t\\t\\t\\t\\tbuffer, offset, originalValueOffset, 1 - weight, stride );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\\n\\n\\t\\t\\t\\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\\n\\n\\t\\t\\t\\t\\t// value has changed -> update scene graph\\n\\n\\t\\t\\t\\t\\tbinding.setValue( buffer, offset );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t// remember the state of the bound property and copy it to both accus\\n\\t\\tsaveOriginalState: function () {\\n\\n\\t\\t\\tvar binding = this.binding;\\n\\n\\t\\t\\tvar buffer = this.buffer,\\n\\t\\t\\t\\tstride = this.valueSize,\\n\\n\\t\\t\\t\\toriginalValueOffset = stride * 3;\\n\\n\\t\\t\\tbinding.getValue( buffer, originalValueOffset );\\n\\n\\t\\t\\t// accu[0..1] := orig -- initially detect changes against the original\\n\\t\\t\\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\\n\\n\\t\\t\\t\\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.cumulativeWeight = 0;\\n\\n\\t\\t},\\n\\n\\t\\t// apply the state previously taken via 'saveOriginalState' to the binding\\n\\t\\trestoreOriginalState: function () {\\n\\n\\t\\t\\tvar originalValueOffset = this.valueSize * 3;\\n\\t\\t\\tthis.binding.setValue( this.buffer, originalValueOffset );\\n\\n\\t\\t},\\n\\n\\n\\t\\t// mix functions\\n\\n\\t\\t_select: function ( buffer, dstOffset, srcOffset, t, stride ) {\\n\\n\\t\\t\\tif ( t >= 0.5 ) {\\n\\n\\t\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\n\\n\\t\\t\\t\\t\\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_slerp: function ( buffer, dstOffset, srcOffset, t ) {\\n\\n\\t\\t\\tQuaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );\\n\\n\\t\\t},\\n\\n\\t\\t_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {\\n\\n\\t\\t\\tvar s = 1 - t;\\n\\n\\t\\t\\tfor ( var i = 0; i !== stride; ++ i ) {\\n\\n\\t\\t\\t\\tvar j = dstOffset + i;\\n\\n\\t\\t\\t\\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A reference to a real property in the scene graph.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction Composite( targetGroup, path, optionalParsedPath ) {\\n\\n\\t\\tvar parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );\\n\\n\\t\\tthis._targetGroup = targetGroup;\\n\\t\\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\\n\\n\\t}\\n\\n\\tObject.assign( Composite.prototype, {\\n\\n\\t\\tgetValue: function ( array, offset ) {\\n\\n\\t\\t\\tthis.bind(); // bind all binding\\n\\n\\t\\t\\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\\n\\t\\t\\t\\tbinding = this._bindings[ firstValidIndex ];\\n\\n\\t\\t\\t// and only call .getValue on the first\\n\\t\\t\\tif ( binding !== undefined ) binding.getValue( array, offset );\\n\\n\\t\\t},\\n\\n\\t\\tsetValue: function ( array, offset ) {\\n\\n\\t\\t\\tvar bindings = this._bindings;\\n\\n\\t\\t\\tfor ( var i = this._targetGroup.nCachedObjects_,\\n\\t\\t\\t\\t\\t  n = bindings.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tbindings[ i ].setValue( array, offset );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tbind: function () {\\n\\n\\t\\t\\tvar bindings = this._bindings;\\n\\n\\t\\t\\tfor ( var i = this._targetGroup.nCachedObjects_,\\n\\t\\t\\t\\t\\t  n = bindings.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tbindings[ i ].bind();\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tunbind: function () {\\n\\n\\t\\t\\tvar bindings = this._bindings;\\n\\n\\t\\t\\tfor ( var i = this._targetGroup.nCachedObjects_,\\n\\t\\t\\t\\t\\t  n = bindings.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tbindings[ i ].unbind();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\n\\tfunction PropertyBinding( rootNode, path, parsedPath ) {\\n\\n\\t\\tthis.path = path;\\n\\t\\tthis.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );\\n\\n\\t\\tthis.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;\\n\\n\\t\\tthis.rootNode = rootNode;\\n\\n\\t}\\n\\n\\tObject.assign( PropertyBinding, {\\n\\n\\t\\tComposite: Composite,\\n\\n\\t\\tcreate: function ( root, path, parsedPath ) {\\n\\n\\t\\t\\tif ( ! ( root && root.isAnimationObjectGroup ) ) {\\n\\n\\t\\t\\t\\treturn new PropertyBinding( root, path, parsedPath );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\treturn new PropertyBinding.Composite( root, path, parsedPath );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Replaces spaces with underscores and removes unsupported characters from\\n\\t\\t * node names, to ensure compatibility with parseTrackName().\\n\\t\\t *\\n\\t\\t * @param  {string} name Node name to be sanitized.\\n\\t\\t * @return {string}\\n\\t\\t */\\n\\t\\tsanitizeNodeName: function ( name ) {\\n\\n\\t\\t\\treturn name.replace( /\\\\s/g, '_' ).replace( /[^\\\\w-]/g, '' );\\n\\n\\t\\t},\\n\\n\\t\\tparseTrackName: function () {\\n\\n\\t\\t\\t// Parent directories, delimited by '/' or ':'. Currently unused, but must\\n\\t\\t\\t// be matched to parse the rest of the track name.\\n\\t\\t\\tvar directoryRe = /((?:[\\\\w-]+[\\\\/:])*)/;\\n\\n\\t\\t\\t// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.\\n\\t\\t\\tvar nodeRe = /([\\\\w-\\\\.]+)?/;\\n\\n\\t\\t\\t// Object on target node, and accessor. Name may contain only word\\n\\t\\t\\t// characters. Accessor may contain any character except closing bracket.\\n\\t\\t\\tvar objectRe = /(?:\\\\.([\\\\w-]+)(?:\\\\[(.+)\\\\])?)?/;\\n\\n\\t\\t\\t// Property and accessor. May contain only word characters. Accessor may\\n\\t\\t\\t// contain any non-bracket characters.\\n\\t\\t\\tvar propertyRe = /\\\\.([\\\\w-]+)(?:\\\\[(.+)\\\\])?/;\\n\\n\\t\\t\\tvar trackRe = new RegExp( ''\\n\\t\\t\\t\\t+ '^'\\n\\t\\t\\t\\t+ directoryRe.source\\n\\t\\t\\t\\t+ nodeRe.source\\n\\t\\t\\t\\t+ objectRe.source\\n\\t\\t\\t\\t+ propertyRe.source\\n\\t\\t\\t\\t+ '$'\\n\\t\\t\\t);\\n\\n\\t\\t\\tvar supportedObjectNames = [ 'material', 'materials', 'bones' ];\\n\\n\\t\\t\\treturn function ( trackName ) {\\n\\n\\t\\t\\t\\tvar matches = trackRe.exec( trackName );\\n\\n\\t\\t\\t\\tif ( ! matches ) {\\n\\n\\t\\t\\t\\t\\tthrow new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar results = {\\n\\t\\t\\t\\t\\t// directoryName: matches[ 1 ], // (tschw) currently unused\\n\\t\\t\\t\\t\\tnodeName: matches[ 2 ],\\n\\t\\t\\t\\t\\tobjectName: matches[ 3 ],\\n\\t\\t\\t\\t\\tobjectIndex: matches[ 4 ],\\n\\t\\t\\t\\t\\tpropertyName: matches[ 5 ], // required\\n\\t\\t\\t\\t\\tpropertyIndex: matches[ 6 ]\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tvar lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );\\n\\n\\t\\t\\t\\tif ( lastDot !== undefined && lastDot !== - 1 ) {\\n\\n\\t\\t\\t\\t\\tvar objectName = results.nodeName.substring( lastDot + 1 );\\n\\n\\t\\t\\t\\t\\t// Object names must be checked against a whitelist. Otherwise, there\\n\\t\\t\\t\\t\\t// is no way to parse 'foo.bar.baz': 'baz' must be a property, but\\n\\t\\t\\t\\t\\t// 'bar' could be the objectName, or part of a nodeName (which can\\n\\t\\t\\t\\t\\t// include '.' characters).\\n\\t\\t\\t\\t\\tif ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {\\n\\n\\t\\t\\t\\t\\t\\tresults.nodeName = results.nodeName.substring( 0, lastDot );\\n\\t\\t\\t\\t\\t\\tresults.objectName = objectName;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( results.propertyName === null || results.propertyName.length === 0 ) {\\n\\n\\t\\t\\t\\t\\tthrow new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn results;\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\n\\t\\tfindNode: function ( root, nodeName ) {\\n\\n\\t\\t\\tif ( ! nodeName || nodeName === \\\"\\\" || nodeName === \\\"root\\\" || nodeName === \\\".\\\" || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {\\n\\n\\t\\t\\t\\treturn root;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// search into skeleton bones.\\n\\t\\t\\tif ( root.skeleton ) {\\n\\n\\t\\t\\t\\tvar searchSkeleton = function ( skeleton ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < skeleton.bones.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar bone = skeleton.bones[ i ];\\n\\n\\t\\t\\t\\t\\t\\tif ( bone.name === nodeName ) {\\n\\n\\t\\t\\t\\t\\t\\t\\treturn bone;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tvar bone = searchSkeleton( root.skeleton );\\n\\n\\t\\t\\t\\tif ( bone ) {\\n\\n\\t\\t\\t\\t\\treturn bone;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// search into node subtree.\\n\\t\\t\\tif ( root.children ) {\\n\\n\\t\\t\\t\\tvar searchNodeSubtree = function ( children ) {\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0; i < children.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar childNode = children[ i ];\\n\\n\\t\\t\\t\\t\\t\\tif ( childNode.name === nodeName || childNode.uuid === nodeName ) {\\n\\n\\t\\t\\t\\t\\t\\t\\treturn childNode;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tvar result = searchNodeSubtree( childNode.children );\\n\\n\\t\\t\\t\\t\\t\\tif ( result ) return result;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn null;\\n\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tvar subTreeNode = searchNodeSubtree( root.children );\\n\\n\\t\\t\\t\\tif ( subTreeNode ) {\\n\\n\\t\\t\\t\\t\\treturn subTreeNode;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( PropertyBinding.prototype, { // prototype, continued\\n\\n\\t\\t// these are used to \\\"bind\\\" a nonexistent property\\n\\t\\t_getValue_unavailable: function () {},\\n\\t\\t_setValue_unavailable: function () {},\\n\\n\\t\\tBindingType: {\\n\\t\\t\\tDirect: 0,\\n\\t\\t\\tEntireArray: 1,\\n\\t\\t\\tArrayElement: 2,\\n\\t\\t\\tHasFromToArray: 3\\n\\t\\t},\\n\\n\\t\\tVersioning: {\\n\\t\\t\\tNone: 0,\\n\\t\\t\\tNeedsUpdate: 1,\\n\\t\\t\\tMatrixWorldNeedsUpdate: 2\\n\\t\\t},\\n\\n\\t\\tGetterByBindingType: [\\n\\n\\t\\t\\tfunction getValue_direct( buffer, offset ) {\\n\\n\\t\\t\\t\\tbuffer[ offset ] = this.node[ this.propertyName ];\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tfunction getValue_array( buffer, offset ) {\\n\\n\\t\\t\\t\\tvar source = this.resolvedProperty;\\n\\n\\t\\t\\t\\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\tbuffer[ offset ++ ] = source[ i ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tfunction getValue_arrayElement( buffer, offset ) {\\n\\n\\t\\t\\t\\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\\n\\n\\t\\t\\t},\\n\\n\\t\\t\\tfunction getValue_toArray( buffer, offset ) {\\n\\n\\t\\t\\t\\tthis.resolvedProperty.toArray( buffer, offset );\\n\\n\\t\\t\\t}\\n\\n\\t\\t],\\n\\n\\t\\tSetterByBindingTypeAndVersioning: [\\n\\n\\t\\t\\t[\\n\\t\\t\\t\\t// Direct\\n\\n\\t\\t\\t\\tfunction setValue_direct( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\\n\\t\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.targetObject[ this.propertyName ] = buffer[ offset ];\\n\\t\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t], [\\n\\n\\t\\t\\t\\t// EntireArray\\n\\n\\t\\t\\t\\tfunction setValue_array( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tvar dest = this.resolvedProperty;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\t\\tdest[ i ] = buffer[ offset ++ ];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tvar dest = this.resolvedProperty;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\t\\tdest[ i ] = buffer[ offset ++ ];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tvar dest = this.resolvedProperty;\\n\\n\\t\\t\\t\\t\\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\t\\tdest[ i ] = buffer[ offset ++ ];\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t], [\\n\\n\\t\\t\\t\\t// ArrayElement\\n\\n\\t\\t\\t\\tfunction setValue_arrayElement( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\\n\\t\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\\n\\t\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t], [\\n\\n\\t\\t\\t\\t// HasToFromArray\\n\\n\\t\\t\\t\\tfunction setValue_fromArray( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.resolvedProperty.fromArray( buffer, offset );\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.resolvedProperty.fromArray( buffer, offset );\\n\\t\\t\\t\\t\\tthis.targetObject.needsUpdate = true;\\n\\n\\t\\t\\t\\t},\\n\\n\\t\\t\\t\\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\\n\\n\\t\\t\\t\\t\\tthis.resolvedProperty.fromArray( buffer, offset );\\n\\t\\t\\t\\t\\tthis.targetObject.matrixWorldNeedsUpdate = true;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t]\\n\\n\\t\\t],\\n\\n\\t\\tgetValue: function getValue_unbound( targetArray, offset ) {\\n\\n\\t\\t\\tthis.bind();\\n\\t\\t\\tthis.getValue( targetArray, offset );\\n\\n\\t\\t\\t// Note: This class uses a State pattern on a per-method basis:\\n\\t\\t\\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\\n\\t\\t\\t// prototype version of these methods with one that represents\\n\\t\\t\\t// the bound state. When the property is not found, the methods\\n\\t\\t\\t// become no-ops.\\n\\n\\t\\t},\\n\\n\\t\\tsetValue: function getValue_unbound( sourceArray, offset ) {\\n\\n\\t\\t\\tthis.bind();\\n\\t\\t\\tthis.setValue( sourceArray, offset );\\n\\n\\t\\t},\\n\\n\\t\\t// create getter / setter pair for a property in the scene graph\\n\\t\\tbind: function () {\\n\\n\\t\\t\\tvar targetObject = this.node,\\n\\t\\t\\t\\tparsedPath = this.parsedPath,\\n\\n\\t\\t\\t\\tobjectName = parsedPath.objectName,\\n\\t\\t\\t\\tpropertyName = parsedPath.propertyName,\\n\\t\\t\\t\\tpropertyIndex = parsedPath.propertyIndex;\\n\\n\\t\\t\\tif ( ! targetObject ) {\\n\\n\\t\\t\\t\\ttargetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;\\n\\n\\t\\t\\t\\tthis.node = targetObject;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// set fail state so we can just 'return' on error\\n\\t\\t\\tthis.getValue = this._getValue_unavailable;\\n\\t\\t\\tthis.setValue = this._setValue_unavailable;\\n\\n\\t\\t\\t// ensure there is a value node\\n\\t\\t\\tif ( ! targetObject ) {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\\\\'t found.' );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( objectName ) {\\n\\n\\t\\t\\t\\tvar objectIndex = parsedPath.objectIndex;\\n\\n\\t\\t\\t\\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\\n\\t\\t\\t\\tswitch ( objectName ) {\\n\\n\\t\\t\\t\\t\\tcase 'materials':\\n\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.material ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.material.materials ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\ttargetObject = targetObject.material.materials;\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tcase 'bones':\\n\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.skeleton ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// potential future optimization: skip this if propertyIndex is already an integer\\n\\t\\t\\t\\t\\t\\t// and convert the integer string to a true integer.\\n\\n\\t\\t\\t\\t\\t\\ttargetObject = targetObject.skeleton.bones;\\n\\n\\t\\t\\t\\t\\t\\t// support resolving morphTarget names into indices.\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < targetObject.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( targetObject[ i ].name === objectIndex ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tobjectIndex = i;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\tdefault:\\n\\n\\t\\t\\t\\t\\t\\tif ( targetObject[ objectName ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\ttargetObject = targetObject[ objectName ];\\n\\n\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\tif ( objectIndex !== undefined ) {\\n\\n\\t\\t\\t\\t\\tif ( targetObject[ objectIndex ] === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );\\n\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ttargetObject = targetObject[ objectIndex ];\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// resolve property\\n\\t\\t\\tvar nodeProperty = targetObject[ propertyName ];\\n\\n\\t\\t\\tif ( nodeProperty === undefined ) {\\n\\n\\t\\t\\t\\tvar nodeName = parsedPath.nodeName;\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +\\n\\t\\t\\t\\t\\t'.' + propertyName + ' but it wasn\\\\'t found.', targetObject );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// determine versioning scheme\\n\\t\\t\\tvar versioning = this.Versioning.None;\\n\\n\\t\\t\\tif ( targetObject.needsUpdate !== undefined ) { // material\\n\\n\\t\\t\\t\\tversioning = this.Versioning.NeedsUpdate;\\n\\t\\t\\t\\tthis.targetObject = targetObject;\\n\\n\\t\\t\\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\\n\\n\\t\\t\\t\\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\\n\\t\\t\\t\\tthis.targetObject = targetObject;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// determine how the property gets bound\\n\\t\\t\\tvar bindingType = this.BindingType.Direct;\\n\\n\\t\\t\\tif ( propertyIndex !== undefined ) {\\n\\n\\t\\t\\t\\t// access a sub element of the property array (only primitives are supported right now)\\n\\n\\t\\t\\t\\tif ( propertyName === \\\"morphTargetInfluences\\\" ) {\\n\\n\\t\\t\\t\\t\\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\\n\\n\\t\\t\\t\\t\\t// support resolving morphTarget names into indices.\\n\\t\\t\\t\\t\\tif ( ! targetObject.geometry ) {\\n\\n\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );\\n\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif ( targetObject.geometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.geometry.morphAttributes ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tpropertyIndex = i;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\tif ( ! targetObject.geometry.morphTargets ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tconsole.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t\\tpropertyIndex = i;\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbindingType = this.BindingType.ArrayElement;\\n\\n\\t\\t\\t\\tthis.resolvedProperty = nodeProperty;\\n\\t\\t\\t\\tthis.propertyIndex = propertyIndex;\\n\\n\\t\\t\\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\\n\\n\\t\\t\\t\\t// must use copy for Object3D.Euler/Quaternion\\n\\n\\t\\t\\t\\tbindingType = this.BindingType.HasFromToArray;\\n\\n\\t\\t\\t\\tthis.resolvedProperty = nodeProperty;\\n\\n\\t\\t\\t} else if ( Array.isArray( nodeProperty ) ) {\\n\\n\\t\\t\\t\\tbindingType = this.BindingType.EntireArray;\\n\\n\\t\\t\\t\\tthis.resolvedProperty = nodeProperty;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.propertyName = propertyName;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// select getter / setter\\n\\t\\t\\tthis.getValue = this.GetterByBindingType[ bindingType ];\\n\\t\\t\\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\\n\\n\\t\\t},\\n\\n\\t\\tunbind: function () {\\n\\n\\t\\t\\tthis.node = null;\\n\\n\\t\\t\\t// back to the prototype version of getValue / setValue\\n\\t\\t\\t// note: avoiding to mutate the shape of 'this' via 'delete'\\n\\t\\t\\tthis.getValue = this._getValue_unbound;\\n\\t\\t\\tthis.setValue = this._setValue_unbound;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//!\\\\ DECLARE ALIAS AFTER assign prototype !\\n\\tObject.assign( PropertyBinding.prototype, {\\n\\n\\t\\t// initial state of these methods that calls 'bind'\\n\\t\\t_getValue_unbound: PropertyBinding.prototype.getValue,\\n\\t\\t_setValue_unbound: PropertyBinding.prototype.setValue,\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * A group of objects that receives a shared animation state.\\n\\t *\\n\\t * Usage:\\n\\t *\\n\\t * \\t-\\tAdd objects you would otherwise pass as 'root' to the\\n\\t * \\t\\tconstructor or the .clipAction method of AnimationMixer.\\n\\t *\\n\\t * \\t-\\tInstead pass this object as 'root'.\\n\\t *\\n\\t * \\t-\\tYou can also add and remove objects later when the mixer\\n\\t * \\t\\tis running.\\n\\t *\\n\\t * Note:\\n\\t *\\n\\t *  \\tObjects of this class appear as one object to the mixer,\\n\\t *  \\tso cache control of the individual objects must be done\\n\\t *  \\ton the group.\\n\\t *\\n\\t * Limitation:\\n\\t *\\n\\t * \\t- \\tThe animated properties must be compatible among the\\n\\t * \\t\\tall objects in the group.\\n\\t *\\n\\t *  -\\tA single property can either be controlled through a\\n\\t *  \\ttarget group or directly, but not both.\\n\\t *\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction AnimationObjectGroup() {\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\t// cached objects followed by the active ones\\n\\t\\tthis._objects = Array.prototype.slice.call( arguments );\\n\\n\\t\\tthis.nCachedObjects_ = 0;\\t\\t\\t// threshold\\n\\t\\t// note: read by PropertyBinding.Composite\\n\\n\\t\\tvar indices = {};\\n\\t\\tthis._indicesByUUID = indices;\\t\\t// for bookkeeping\\n\\n\\t\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\n\\n\\t\\t\\tindices[ arguments[ i ].uuid ] = i;\\n\\n\\t\\t}\\n\\n\\t\\tthis._paths = [];\\t\\t\\t\\t\\t// inside: string\\n\\t\\tthis._parsedPaths = [];\\t\\t\\t\\t// inside: { we don't care, here }\\n\\t\\tthis._bindings = []; \\t\\t\\t\\t// inside: Array< PropertyBinding >\\n\\t\\tthis._bindingsIndicesByPath = {}; \\t// inside: indices in these arrays\\n\\n\\t\\tvar scope = this;\\n\\n\\t\\tthis.stats = {\\n\\n\\t\\t\\tobjects: {\\n\\t\\t\\t\\tget total() {\\n\\n\\t\\t\\t\\t\\treturn scope._objects.length;\\n\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tget inUse() {\\n\\n\\t\\t\\t\\t\\treturn this.total - scope.nCachedObjects_;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\tget bindingsPerObject() {\\n\\n\\t\\t\\t\\treturn scope._bindings.length;\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\tObject.assign( AnimationObjectGroup.prototype, {\\n\\n\\t\\tisAnimationObjectGroup: true,\\n\\n\\t\\tadd: function () {\\n\\n\\t\\t\\tvar objects = this._objects,\\n\\t\\t\\t\\tnObjects = objects.length,\\n\\t\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\n\\t\\t\\t\\tindicesByUUID = this._indicesByUUID,\\n\\t\\t\\t\\tpaths = this._paths,\\n\\t\\t\\t\\tparsedPaths = this._parsedPaths,\\n\\t\\t\\t\\tbindings = this._bindings,\\n\\t\\t\\t\\tnBindings = bindings.length;\\n\\n\\t\\t\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tvar object = arguments[ i ],\\n\\t\\t\\t\\t\\tuuid = object.uuid,\\n\\t\\t\\t\\t\\tindex = indicesByUUID[ uuid ],\\n\\t\\t\\t\\t\\tknownObject = undefined;\\n\\n\\t\\t\\t\\tif ( index === undefined ) {\\n\\n\\t\\t\\t\\t\\t// unknown object -> add it to the ACTIVE region\\n\\n\\t\\t\\t\\t\\tindex = nObjects ++;\\n\\t\\t\\t\\t\\tindicesByUUID[ uuid ] = index;\\n\\t\\t\\t\\t\\tobjects.push( object );\\n\\n\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\tbindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( index < nCachedObjects ) {\\n\\n\\t\\t\\t\\t\\tknownObject = objects[ index ];\\n\\n\\t\\t\\t\\t\\t// move existing object to the ACTIVE region\\n\\n\\t\\t\\t\\t\\tvar firstActiveIndex = -- nCachedObjects,\\n\\t\\t\\t\\t\\t\\tlastCachedObject = objects[ firstActiveIndex ];\\n\\n\\t\\t\\t\\t\\tindicesByUUID[ lastCachedObject.uuid ] = index;\\n\\t\\t\\t\\t\\tobjects[ index ] = lastCachedObject;\\n\\n\\t\\t\\t\\t\\tindicesByUUID[ uuid ] = firstActiveIndex;\\n\\t\\t\\t\\t\\tobjects[ firstActiveIndex ] = object;\\n\\n\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ],\\n\\t\\t\\t\\t\\t\\t\\tlastCached = bindingsForPath[ firstActiveIndex ],\\n\\t\\t\\t\\t\\t\\t\\tbinding = bindingsForPath[ index ];\\n\\n\\t\\t\\t\\t\\t\\tbindingsForPath[ index ] = lastCached;\\n\\n\\t\\t\\t\\t\\t\\tif ( binding === undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// since we do not bother to create new bindings\\n\\t\\t\\t\\t\\t\\t\\t// for objects that are cached, the binding may\\n\\t\\t\\t\\t\\t\\t\\t// or may not exist\\n\\n\\t\\t\\t\\t\\t\\t\\tbinding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tbindingsForPath[ firstActiveIndex ] = binding;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t} else if ( objects[ index ] !== knownObject ) {\\n\\n\\t\\t\\t\\t\\tconsole.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +\\n\\t\\t\\t\\t\\t\\t\\t'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );\\n\\n\\t\\t\\t\\t} // else the object is already where we want it to be\\n\\n\\t\\t\\t} // for arguments\\n\\n\\t\\t\\tthis.nCachedObjects_ = nCachedObjects;\\n\\n\\t\\t},\\n\\n\\t\\tremove: function () {\\n\\n\\t\\t\\tvar objects = this._objects,\\n\\t\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\n\\t\\t\\t\\tindicesByUUID = this._indicesByUUID,\\n\\t\\t\\t\\tbindings = this._bindings,\\n\\t\\t\\t\\tnBindings = bindings.length;\\n\\n\\t\\t\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tvar object = arguments[ i ],\\n\\t\\t\\t\\t\\tuuid = object.uuid,\\n\\t\\t\\t\\t\\tindex = indicesByUUID[ uuid ];\\n\\n\\t\\t\\t\\tif ( index !== undefined && index >= nCachedObjects ) {\\n\\n\\t\\t\\t\\t\\t// move existing object into the CACHED region\\n\\n\\t\\t\\t\\t\\tvar lastCachedIndex = nCachedObjects ++,\\n\\t\\t\\t\\t\\t\\tfirstActiveObject = objects[ lastCachedIndex ];\\n\\n\\t\\t\\t\\t\\tindicesByUUID[ firstActiveObject.uuid ] = index;\\n\\t\\t\\t\\t\\tobjects[ index ] = firstActiveObject;\\n\\n\\t\\t\\t\\t\\tindicesByUUID[ uuid ] = lastCachedIndex;\\n\\t\\t\\t\\t\\tobjects[ lastCachedIndex ] = object;\\n\\n\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ],\\n\\t\\t\\t\\t\\t\\t\\tfirstActive = bindingsForPath[ lastCachedIndex ],\\n\\t\\t\\t\\t\\t\\t\\tbinding = bindingsForPath[ index ];\\n\\n\\t\\t\\t\\t\\t\\tbindingsForPath[ index ] = firstActive;\\n\\t\\t\\t\\t\\t\\tbindingsForPath[ lastCachedIndex ] = binding;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} // for arguments\\n\\n\\t\\t\\tthis.nCachedObjects_ = nCachedObjects;\\n\\n\\t\\t},\\n\\n\\t\\t// remove & forget\\n\\t\\tuncache: function () {\\n\\n\\t\\t\\tvar objects = this._objects,\\n\\t\\t\\t\\tnObjects = objects.length,\\n\\t\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\n\\t\\t\\t\\tindicesByUUID = this._indicesByUUID,\\n\\t\\t\\t\\tbindings = this._bindings,\\n\\t\\t\\t\\tnBindings = bindings.length;\\n\\n\\t\\t\\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tvar object = arguments[ i ],\\n\\t\\t\\t\\t\\tuuid = object.uuid,\\n\\t\\t\\t\\t\\tindex = indicesByUUID[ uuid ];\\n\\n\\t\\t\\t\\tif ( index !== undefined ) {\\n\\n\\t\\t\\t\\t\\tdelete indicesByUUID[ uuid ];\\n\\n\\t\\t\\t\\t\\tif ( index < nCachedObjects ) {\\n\\n\\t\\t\\t\\t\\t\\t// object is cached, shrink the CACHED region\\n\\n\\t\\t\\t\\t\\t\\tvar firstActiveIndex = -- nCachedObjects,\\n\\t\\t\\t\\t\\t\\t\\tlastCachedObject = objects[ firstActiveIndex ],\\n\\t\\t\\t\\t\\t\\t\\tlastIndex = -- nObjects,\\n\\t\\t\\t\\t\\t\\t\\tlastObject = objects[ lastIndex ];\\n\\n\\t\\t\\t\\t\\t\\t// last cached object takes this object's place\\n\\t\\t\\t\\t\\t\\tindicesByUUID[ lastCachedObject.uuid ] = index;\\n\\t\\t\\t\\t\\t\\tobjects[ index ] = lastCachedObject;\\n\\n\\t\\t\\t\\t\\t\\t// last object goes to the activated slot and pop\\n\\t\\t\\t\\t\\t\\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\\n\\t\\t\\t\\t\\t\\tobjects[ firstActiveIndex ] = lastObject;\\n\\t\\t\\t\\t\\t\\tobjects.pop();\\n\\n\\t\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\n\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ],\\n\\t\\t\\t\\t\\t\\t\\t\\tlastCached = bindingsForPath[ firstActiveIndex ],\\n\\t\\t\\t\\t\\t\\t\\t\\tlast = bindingsForPath[ lastIndex ];\\n\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath[ index ] = lastCached;\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath[ firstActiveIndex ] = last;\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath.pop();\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// object is active, just swap with the last and pop\\n\\n\\t\\t\\t\\t\\t\\tvar lastIndex = -- nObjects,\\n\\t\\t\\t\\t\\t\\t\\tlastObject = objects[ lastIndex ];\\n\\n\\t\\t\\t\\t\\t\\tindicesByUUID[ lastObject.uuid ] = index;\\n\\t\\t\\t\\t\\t\\tobjects[ index ] = lastObject;\\n\\t\\t\\t\\t\\t\\tobjects.pop();\\n\\n\\t\\t\\t\\t\\t\\t// accounting is done, now do the same for all bindings\\n\\n\\t\\t\\t\\t\\t\\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\\n\\n\\t\\t\\t\\t\\t\\t\\tvar bindingsForPath = bindings[ j ];\\n\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\\n\\t\\t\\t\\t\\t\\t\\tbindingsForPath.pop();\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t} // cached or active\\n\\n\\t\\t\\t\\t} // if object is known\\n\\n\\t\\t\\t} // for arguments\\n\\n\\t\\t\\tthis.nCachedObjects_ = nCachedObjects;\\n\\n\\t\\t},\\n\\n\\t\\t// Internal interface used by befriended PropertyBinding.Composite:\\n\\n\\t\\tsubscribe_: function ( path, parsedPath ) {\\n\\n\\t\\t\\t// returns an array of bindings for the given path that is changed\\n\\t\\t\\t// according to the contained objects in the group\\n\\n\\t\\t\\tvar indicesByPath = this._bindingsIndicesByPath,\\n\\t\\t\\t\\tindex = indicesByPath[ path ],\\n\\t\\t\\t\\tbindings = this._bindings;\\n\\n\\t\\t\\tif ( index !== undefined ) return bindings[ index ];\\n\\n\\t\\t\\tvar paths = this._paths,\\n\\t\\t\\t\\tparsedPaths = this._parsedPaths,\\n\\t\\t\\t\\tobjects = this._objects,\\n\\t\\t\\t\\tnObjects = objects.length,\\n\\t\\t\\t\\tnCachedObjects = this.nCachedObjects_,\\n\\t\\t\\t\\tbindingsForPath = new Array( nObjects );\\n\\n\\t\\t\\tindex = bindings.length;\\n\\n\\t\\t\\tindicesByPath[ path ] = index;\\n\\n\\t\\t\\tpaths.push( path );\\n\\t\\t\\tparsedPaths.push( parsedPath );\\n\\t\\t\\tbindings.push( bindingsForPath );\\n\\n\\t\\t\\tfor ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tvar object = objects[ i ];\\n\\t\\t\\t\\tbindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn bindingsForPath;\\n\\n\\t\\t},\\n\\n\\t\\tunsubscribe_: function ( path ) {\\n\\n\\t\\t\\t// tells the group to forget about a property path and no longer\\n\\t\\t\\t// update the array previously obtained with 'subscribe_'\\n\\n\\t\\t\\tvar indicesByPath = this._bindingsIndicesByPath,\\n\\t\\t\\t\\tindex = indicesByPath[ path ];\\n\\n\\t\\t\\tif ( index !== undefined ) {\\n\\n\\t\\t\\t\\tvar paths = this._paths,\\n\\t\\t\\t\\t\\tparsedPaths = this._parsedPaths,\\n\\t\\t\\t\\t\\tbindings = this._bindings,\\n\\t\\t\\t\\t\\tlastBindingsIndex = bindings.length - 1,\\n\\t\\t\\t\\t\\tlastBindings = bindings[ lastBindingsIndex ],\\n\\t\\t\\t\\t\\tlastBindingsPath = path[ lastBindingsIndex ];\\n\\n\\t\\t\\t\\tindicesByPath[ lastBindingsPath ] = index;\\n\\n\\t\\t\\t\\tbindings[ index ] = lastBindings;\\n\\t\\t\\t\\tbindings.pop();\\n\\n\\t\\t\\t\\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\\n\\t\\t\\t\\tparsedPaths.pop();\\n\\n\\t\\t\\t\\tpaths[ index ] = paths[ lastBindingsIndex ];\\n\\t\\t\\t\\tpaths.pop();\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * Action provided by AnimationMixer for scheduling clip playback on specific\\n\\t * objects.\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t *\\n\\t */\\n\\n\\tfunction AnimationAction( mixer, clip, localRoot ) {\\n\\n\\t\\tthis._mixer = mixer;\\n\\t\\tthis._clip = clip;\\n\\t\\tthis._localRoot = localRoot || null;\\n\\n\\t\\tvar tracks = clip.tracks,\\n\\t\\t\\tnTracks = tracks.length,\\n\\t\\t\\tinterpolants = new Array( nTracks );\\n\\n\\t\\tvar interpolantSettings = {\\n\\t\\t\\tendingStart: ZeroCurvatureEnding,\\n\\t\\t\\tendingEnd: ZeroCurvatureEnding\\n\\t\\t};\\n\\n\\t\\tfor ( var i = 0; i !== nTracks; ++ i ) {\\n\\n\\t\\t\\tvar interpolant = tracks[ i ].createInterpolant( null );\\n\\t\\t\\tinterpolants[ i ] = interpolant;\\n\\t\\t\\tinterpolant.settings = interpolantSettings;\\n\\n\\t\\t}\\n\\n\\t\\tthis._interpolantSettings = interpolantSettings;\\n\\n\\t\\tthis._interpolants = interpolants;\\t// bound by the mixer\\n\\n\\t\\t// inside: PropertyMixer (managed by the mixer)\\n\\t\\tthis._propertyBindings = new Array( nTracks );\\n\\n\\t\\tthis._cacheIndex = null;\\t\\t\\t// for the memory manager\\n\\t\\tthis._byClipCacheIndex = null;\\t\\t// for the memory manager\\n\\n\\t\\tthis._timeScaleInterpolant = null;\\n\\t\\tthis._weightInterpolant = null;\\n\\n\\t\\tthis.loop = LoopRepeat;\\n\\t\\tthis._loopCount = - 1;\\n\\n\\t\\t// global mixer time when the action is to be started\\n\\t\\t// it's set back to 'null' upon start of the action\\n\\t\\tthis._startTime = null;\\n\\n\\t\\t// scaled local time of the action\\n\\t\\t// gets clamped or wrapped to 0..clip.duration according to loop\\n\\t\\tthis.time = 0;\\n\\n\\t\\tthis.timeScale = 1;\\n\\t\\tthis._effectiveTimeScale = 1;\\n\\n\\t\\tthis.weight = 1;\\n\\t\\tthis._effectiveWeight = 1;\\n\\n\\t\\tthis.repetitions = Infinity; \\t\\t// no. of repetitions when looping\\n\\n\\t\\tthis.paused = false;\\t\\t\\t\\t// true -> zero effective time scale\\n\\t\\tthis.enabled = true;\\t\\t\\t\\t// false -> zero effective weight\\n\\n\\t\\tthis.clampWhenFinished \\t= false;\\t// keep feeding the last frame?\\n\\n\\t\\tthis.zeroSlopeAtStart \\t= true;\\t\\t// for smooth interpolation w/o separate\\n\\t\\tthis.zeroSlopeAtEnd\\t\\t= true;\\t\\t// clips for start, loop and end\\n\\n\\t}\\n\\n\\tObject.assign( AnimationAction.prototype, {\\n\\n\\t\\t// State & Scheduling\\n\\n\\t\\tplay: function () {\\n\\n\\t\\t\\tthis._mixer._activateAction( this );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tstop: function () {\\n\\n\\t\\t\\tthis._mixer._deactivateAction( this );\\n\\n\\t\\t\\treturn this.reset();\\n\\n\\t\\t},\\n\\n\\t\\treset: function () {\\n\\n\\t\\t\\tthis.paused = false;\\n\\t\\t\\tthis.enabled = true;\\n\\n\\t\\t\\tthis.time = 0;\\t\\t\\t// restart clip\\n\\t\\t\\tthis._loopCount = - 1;\\t// forget previous loops\\n\\t\\t\\tthis._startTime = null;\\t// forget scheduling\\n\\n\\t\\t\\treturn this.stopFading().stopWarping();\\n\\n\\t\\t},\\n\\n\\t\\tisRunning: function () {\\n\\n\\t\\t\\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\\n\\t\\t\\t\\t\\tthis._startTime === null && this._mixer._isActiveAction( this );\\n\\n\\t\\t},\\n\\n\\t\\t// return true when play has been called\\n\\t\\tisScheduled: function () {\\n\\n\\t\\t\\treturn this._mixer._isActiveAction( this );\\n\\n\\t\\t},\\n\\n\\t\\tstartAt: function ( time ) {\\n\\n\\t\\t\\tthis._startTime = time;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetLoop: function ( mode, repetitions ) {\\n\\n\\t\\t\\tthis.loop = mode;\\n\\t\\t\\tthis.repetitions = repetitions;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// Weight\\n\\n\\t\\t// set the weight stopping any scheduled fading\\n\\t\\t// although .enabled = false yields an effective weight of zero, this\\n\\t\\t// method does *not* change .enabled, because it would be confusing\\n\\t\\tsetEffectiveWeight: function ( weight ) {\\n\\n\\t\\t\\tthis.weight = weight;\\n\\n\\t\\t\\t// note: same logic as when updated at runtime\\n\\t\\t\\tthis._effectiveWeight = this.enabled ? weight : 0;\\n\\n\\t\\t\\treturn this.stopFading();\\n\\n\\t\\t},\\n\\n\\t\\t// return the weight considering fading and .enabled\\n\\t\\tgetEffectiveWeight: function () {\\n\\n\\t\\t\\treturn this._effectiveWeight;\\n\\n\\t\\t},\\n\\n\\t\\tfadeIn: function ( duration ) {\\n\\n\\t\\t\\treturn this._scheduleFading( duration, 0, 1 );\\n\\n\\t\\t},\\n\\n\\t\\tfadeOut: function ( duration ) {\\n\\n\\t\\t\\treturn this._scheduleFading( duration, 1, 0 );\\n\\n\\t\\t},\\n\\n\\t\\tcrossFadeFrom: function ( fadeOutAction, duration, warp ) {\\n\\n\\t\\t\\tfadeOutAction.fadeOut( duration );\\n\\t\\t\\tthis.fadeIn( duration );\\n\\n\\t\\t\\tif ( warp ) {\\n\\n\\t\\t\\t\\tvar fadeInDuration = this._clip.duration,\\n\\t\\t\\t\\t\\tfadeOutDuration = fadeOutAction._clip.duration,\\n\\n\\t\\t\\t\\t\\tstartEndRatio = fadeOutDuration / fadeInDuration,\\n\\t\\t\\t\\t\\tendStartRatio = fadeInDuration / fadeOutDuration;\\n\\n\\t\\t\\t\\tfadeOutAction.warp( 1.0, startEndRatio, duration );\\n\\t\\t\\t\\tthis.warp( endStartRatio, 1.0, duration );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcrossFadeTo: function ( fadeInAction, duration, warp ) {\\n\\n\\t\\t\\treturn fadeInAction.crossFadeFrom( this, duration, warp );\\n\\n\\t\\t},\\n\\n\\t\\tstopFading: function () {\\n\\n\\t\\t\\tvar weightInterpolant = this._weightInterpolant;\\n\\n\\t\\t\\tif ( weightInterpolant !== null ) {\\n\\n\\t\\t\\t\\tthis._weightInterpolant = null;\\n\\t\\t\\t\\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// Time Scale Control\\n\\n\\t\\t// set the time scale stopping any scheduled warping\\n\\t\\t// although .paused = true yields an effective time scale of zero, this\\n\\t\\t// method does *not* change .paused, because it would be confusing\\n\\t\\tsetEffectiveTimeScale: function ( timeScale ) {\\n\\n\\t\\t\\tthis.timeScale = timeScale;\\n\\t\\t\\tthis._effectiveTimeScale = this.paused ? 0 : timeScale;\\n\\n\\t\\t\\treturn this.stopWarping();\\n\\n\\t\\t},\\n\\n\\t\\t// return the time scale considering warping and .paused\\n\\t\\tgetEffectiveTimeScale: function () {\\n\\n\\t\\t\\treturn this._effectiveTimeScale;\\n\\n\\t\\t},\\n\\n\\t\\tsetDuration: function ( duration ) {\\n\\n\\t\\t\\tthis.timeScale = this._clip.duration / duration;\\n\\n\\t\\t\\treturn this.stopWarping();\\n\\n\\t\\t},\\n\\n\\t\\tsyncWith: function ( action ) {\\n\\n\\t\\t\\tthis.time = action.time;\\n\\t\\t\\tthis.timeScale = action.timeScale;\\n\\n\\t\\t\\treturn this.stopWarping();\\n\\n\\t\\t},\\n\\n\\t\\thalt: function ( duration ) {\\n\\n\\t\\t\\treturn this.warp( this._effectiveTimeScale, 0, duration );\\n\\n\\t\\t},\\n\\n\\t\\twarp: function ( startTimeScale, endTimeScale, duration ) {\\n\\n\\t\\t\\tvar mixer = this._mixer, now = mixer.time,\\n\\t\\t\\t\\tinterpolant = this._timeScaleInterpolant,\\n\\n\\t\\t\\t\\ttimeScale = this.timeScale;\\n\\n\\t\\t\\tif ( interpolant === null ) {\\n\\n\\t\\t\\t\\tinterpolant = mixer._lendControlInterpolant();\\n\\t\\t\\t\\tthis._timeScaleInterpolant = interpolant;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar times = interpolant.parameterPositions,\\n\\t\\t\\t\\tvalues = interpolant.sampleValues;\\n\\n\\t\\t\\ttimes[ 0 ] = now;\\n\\t\\t\\ttimes[ 1 ] = now + duration;\\n\\n\\t\\t\\tvalues[ 0 ] = startTimeScale / timeScale;\\n\\t\\t\\tvalues[ 1 ] = endTimeScale / timeScale;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tstopWarping: function () {\\n\\n\\t\\t\\tvar timeScaleInterpolant = this._timeScaleInterpolant;\\n\\n\\t\\t\\tif ( timeScaleInterpolant !== null ) {\\n\\n\\t\\t\\t\\tthis._timeScaleInterpolant = null;\\n\\t\\t\\t\\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// Object Accessors\\n\\n\\t\\tgetMixer: function () {\\n\\n\\t\\t\\treturn this._mixer;\\n\\n\\t\\t},\\n\\n\\t\\tgetClip: function () {\\n\\n\\t\\t\\treturn this._clip;\\n\\n\\t\\t},\\n\\n\\t\\tgetRoot: function () {\\n\\n\\t\\t\\treturn this._localRoot || this._mixer._root;\\n\\n\\t\\t},\\n\\n\\t\\t// Interna\\n\\n\\t\\t_update: function ( time, deltaTime, timeDirection, accuIndex ) {\\n\\n\\t\\t\\t// called by the mixer\\n\\n\\t\\t\\tif ( ! this.enabled ) {\\n\\n\\t\\t\\t\\t// call ._updateWeight() to update ._effectiveWeight\\n\\n\\t\\t\\t\\tthis._updateWeight( time );\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar startTime = this._startTime;\\n\\n\\t\\t\\tif ( startTime !== null ) {\\n\\n\\t\\t\\t\\t// check for scheduled start of action\\n\\n\\t\\t\\t\\tvar timeRunning = ( time - startTime ) * timeDirection;\\n\\t\\t\\t\\tif ( timeRunning < 0 || timeDirection === 0 ) {\\n\\n\\t\\t\\t\\t\\treturn; // yet to come / don't decide when delta = 0\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// start\\n\\n\\t\\t\\t\\tthis._startTime = null; // unschedule\\n\\t\\t\\t\\tdeltaTime = timeDirection * timeRunning;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// apply time scale and advance time\\n\\n\\t\\t\\tdeltaTime *= this._updateTimeScale( time );\\n\\t\\t\\tvar clipTime = this._updateTime( deltaTime );\\n\\n\\t\\t\\t// note: _updateTime may disable the action resulting in\\n\\t\\t\\t// an effective weight of 0\\n\\n\\t\\t\\tvar weight = this._updateWeight( time );\\n\\n\\t\\t\\tif ( weight > 0 ) {\\n\\n\\t\\t\\t\\tvar interpolants = this._interpolants;\\n\\t\\t\\t\\tvar propertyMixers = this._propertyBindings;\\n\\n\\t\\t\\t\\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\\n\\n\\t\\t\\t\\t\\tinterpolants[ j ].evaluate( clipTime );\\n\\t\\t\\t\\t\\tpropertyMixers[ j ].accumulate( accuIndex, weight );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_updateWeight: function ( time ) {\\n\\n\\t\\t\\tvar weight = 0;\\n\\n\\t\\t\\tif ( this.enabled ) {\\n\\n\\t\\t\\t\\tweight = this.weight;\\n\\t\\t\\t\\tvar interpolant = this._weightInterpolant;\\n\\n\\t\\t\\t\\tif ( interpolant !== null ) {\\n\\n\\t\\t\\t\\t\\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\\n\\n\\t\\t\\t\\t\\tweight *= interpolantValue;\\n\\n\\t\\t\\t\\t\\tif ( time > interpolant.parameterPositions[ 1 ] ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.stopFading();\\n\\n\\t\\t\\t\\t\\t\\tif ( interpolantValue === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// faded out, disable\\n\\t\\t\\t\\t\\t\\t\\tthis.enabled = false;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._effectiveWeight = weight;\\n\\t\\t\\treturn weight;\\n\\n\\t\\t},\\n\\n\\t\\t_updateTimeScale: function ( time ) {\\n\\n\\t\\t\\tvar timeScale = 0;\\n\\n\\t\\t\\tif ( ! this.paused ) {\\n\\n\\t\\t\\t\\ttimeScale = this.timeScale;\\n\\n\\t\\t\\t\\tvar interpolant = this._timeScaleInterpolant;\\n\\n\\t\\t\\t\\tif ( interpolant !== null ) {\\n\\n\\t\\t\\t\\t\\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\\n\\n\\t\\t\\t\\t\\ttimeScale *= interpolantValue;\\n\\n\\t\\t\\t\\t\\tif ( time > interpolant.parameterPositions[ 1 ] ) {\\n\\n\\t\\t\\t\\t\\t\\tthis.stopWarping();\\n\\n\\t\\t\\t\\t\\t\\tif ( timeScale === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// motion has halted, pause\\n\\t\\t\\t\\t\\t\\t\\tthis.paused = true;\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\t// warp done - apply final time scale\\n\\t\\t\\t\\t\\t\\t\\tthis.timeScale = timeScale;\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._effectiveTimeScale = timeScale;\\n\\t\\t\\treturn timeScale;\\n\\n\\t\\t},\\n\\n\\t\\t_updateTime: function ( deltaTime ) {\\n\\n\\t\\t\\tvar time = this.time + deltaTime;\\n\\n\\t\\t\\tif ( deltaTime === 0 ) return time;\\n\\n\\t\\t\\tvar duration = this._clip.duration,\\n\\n\\t\\t\\t\\tloop = this.loop,\\n\\t\\t\\t\\tloopCount = this._loopCount;\\n\\n\\t\\t\\tif ( loop === LoopOnce ) {\\n\\n\\t\\t\\t\\tif ( loopCount === - 1 ) {\\n\\n\\t\\t\\t\\t\\t// just started\\n\\n\\t\\t\\t\\t\\tthis._loopCount = 0;\\n\\t\\t\\t\\t\\tthis._setEndings( true, true, false );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\thandle_stop: {\\n\\n\\t\\t\\t\\t\\tif ( time >= duration ) {\\n\\n\\t\\t\\t\\t\\t\\ttime = duration;\\n\\n\\t\\t\\t\\t\\t} else if ( time < 0 ) {\\n\\n\\t\\t\\t\\t\\t\\ttime = 0;\\n\\n\\t\\t\\t\\t\\t} else break handle_stop;\\n\\n\\t\\t\\t\\t\\tif ( this.clampWhenFinished ) this.paused = true;\\n\\t\\t\\t\\t\\telse this.enabled = false;\\n\\n\\t\\t\\t\\t\\tthis._mixer.dispatchEvent( {\\n\\t\\t\\t\\t\\t\\ttype: 'finished', action: this,\\n\\t\\t\\t\\t\\t\\tdirection: deltaTime < 0 ? - 1 : 1\\n\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else { // repetitive Repeat or PingPong\\n\\n\\t\\t\\t\\tvar pingPong = ( loop === LoopPingPong );\\n\\n\\t\\t\\t\\tif ( loopCount === - 1 ) {\\n\\n\\t\\t\\t\\t\\t// just started\\n\\n\\t\\t\\t\\t\\tif ( deltaTime >= 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tloopCount = 0;\\n\\n\\t\\t\\t\\t\\t\\tthis._setEndings( true, this.repetitions === 0, pingPong );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// when looping in reverse direction, the initial\\n\\t\\t\\t\\t\\t\\t// transition through zero counts as a repetition,\\n\\t\\t\\t\\t\\t\\t// so leave loopCount at -1\\n\\n\\t\\t\\t\\t\\t\\tthis._setEndings( this.repetitions === 0, true, pingPong );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( time >= duration || time < 0 ) {\\n\\n\\t\\t\\t\\t\\t// wrap around\\n\\n\\t\\t\\t\\t\\tvar loopDelta = Math.floor( time / duration ); // signed\\n\\t\\t\\t\\t\\ttime -= duration * loopDelta;\\n\\n\\t\\t\\t\\t\\tloopCount += Math.abs( loopDelta );\\n\\n\\t\\t\\t\\t\\tvar pending = this.repetitions - loopCount;\\n\\n\\t\\t\\t\\t\\tif ( pending < 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t// have to stop (switch state, clamp time, fire event)\\n\\n\\t\\t\\t\\t\\t\\tif ( this.clampWhenFinished ) this.paused = true;\\n\\t\\t\\t\\t\\t\\telse this.enabled = false;\\n\\n\\t\\t\\t\\t\\t\\ttime = deltaTime > 0 ? duration : 0;\\n\\n\\t\\t\\t\\t\\t\\tthis._mixer.dispatchEvent( {\\n\\t\\t\\t\\t\\t\\t\\ttype: 'finished', action: this,\\n\\t\\t\\t\\t\\t\\t\\tdirection: deltaTime > 0 ? 1 : - 1\\n\\t\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t// keep running\\n\\n\\t\\t\\t\\t\\t\\tif ( pending === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// entering the last round\\n\\n\\t\\t\\t\\t\\t\\t\\tvar atStart = deltaTime < 0;\\n\\t\\t\\t\\t\\t\\t\\tthis._setEndings( atStart, ! atStart, pingPong );\\n\\n\\t\\t\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\t\\t\\tthis._setEndings( false, false, pingPong );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tthis._loopCount = loopCount;\\n\\n\\t\\t\\t\\t\\t\\tthis._mixer.dispatchEvent( {\\n\\t\\t\\t\\t\\t\\t\\ttype: 'loop', action: this, loopDelta: loopDelta\\n\\t\\t\\t\\t\\t\\t} );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\\n\\n\\t\\t\\t\\t\\t// invert time for the \\\"pong round\\\"\\n\\n\\t\\t\\t\\t\\tthis.time = time;\\n\\t\\t\\t\\t\\treturn duration - time;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.time = time;\\n\\t\\t\\treturn time;\\n\\n\\t\\t},\\n\\n\\t\\t_setEndings: function ( atStart, atEnd, pingPong ) {\\n\\n\\t\\t\\tvar settings = this._interpolantSettings;\\n\\n\\t\\t\\tif ( pingPong ) {\\n\\n\\t\\t\\t\\tsettings.endingStart \\t= ZeroSlopeEnding;\\n\\t\\t\\t\\tsettings.endingEnd\\t\\t= ZeroSlopeEnding;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t// assuming for LoopOnce atStart == atEnd == true\\n\\n\\t\\t\\t\\tif ( atStart ) {\\n\\n\\t\\t\\t\\t\\tsettings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tsettings.endingStart = WrapAroundEnding;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif ( atEnd ) {\\n\\n\\t\\t\\t\\t\\tsettings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tsettings.endingEnd \\t = WrapAroundEnding;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_scheduleFading: function ( duration, weightNow, weightThen ) {\\n\\n\\t\\t\\tvar mixer = this._mixer, now = mixer.time,\\n\\t\\t\\t\\tinterpolant = this._weightInterpolant;\\n\\n\\t\\t\\tif ( interpolant === null ) {\\n\\n\\t\\t\\t\\tinterpolant = mixer._lendControlInterpolant();\\n\\t\\t\\t\\tthis._weightInterpolant = interpolant;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar times = interpolant.parameterPositions,\\n\\t\\t\\t\\tvalues = interpolant.sampleValues;\\n\\n\\t\\t\\ttimes[ 0 ] = now; \\t\\t\\t\\tvalues[ 0 ] = weightNow;\\n\\t\\t\\ttimes[ 1 ] = now + duration;\\tvalues[ 1 ] = weightThen;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t *\\n\\t * Player for AnimationClips.\\n\\t *\\n\\t *\\n\\t * @author Ben Houston / http://clara.io/\\n\\t * @author David Sarno / http://lighthaus.us/\\n\\t * @author tschw\\n\\t */\\n\\n\\tfunction AnimationMixer( root ) {\\n\\n\\t\\tthis._root = root;\\n\\t\\tthis._initMemoryManager();\\n\\t\\tthis._accuIndex = 0;\\n\\n\\t\\tthis.time = 0;\\n\\n\\t\\tthis.timeScale = 1.0;\\n\\n\\t}\\n\\n\\tAnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {\\n\\n\\t\\tconstructor: AnimationMixer,\\n\\n\\t\\t_bindAction: function ( action, prototypeAction ) {\\n\\n\\t\\t\\tvar root = action._localRoot || this._root,\\n\\t\\t\\t\\ttracks = action._clip.tracks,\\n\\t\\t\\t\\tnTracks = tracks.length,\\n\\t\\t\\t\\tbindings = action._propertyBindings,\\n\\t\\t\\t\\tinterpolants = action._interpolants,\\n\\t\\t\\t\\trootUuid = root.uuid,\\n\\t\\t\\t\\tbindingsByRoot = this._bindingsByRootAndName,\\n\\t\\t\\t\\tbindingsByName = bindingsByRoot[ rootUuid ];\\n\\n\\t\\t\\tif ( bindingsByName === undefined ) {\\n\\n\\t\\t\\t\\tbindingsByName = {};\\n\\t\\t\\t\\tbindingsByRoot[ rootUuid ] = bindingsByName;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0; i !== nTracks; ++ i ) {\\n\\n\\t\\t\\t\\tvar track = tracks[ i ],\\n\\t\\t\\t\\t\\ttrackName = track.name,\\n\\t\\t\\t\\t\\tbinding = bindingsByName[ trackName ];\\n\\n\\t\\t\\t\\tif ( binding !== undefined ) {\\n\\n\\t\\t\\t\\t\\tbindings[ i ] = binding;\\n\\n\\t\\t\\t\\t} else {\\n\\n\\t\\t\\t\\t\\tbinding = bindings[ i ];\\n\\n\\t\\t\\t\\t\\tif ( binding !== undefined ) {\\n\\n\\t\\t\\t\\t\\t\\t// existing binding, make sure the cache knows\\n\\n\\t\\t\\t\\t\\t\\tif ( binding._cacheIndex === null ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t++ binding.referenceCount;\\n\\t\\t\\t\\t\\t\\t\\tthis._addInactiveBinding( binding, rootUuid, trackName );\\n\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar path = prototypeAction && prototypeAction.\\n\\t\\t\\t\\t\\t\\t_propertyBindings[ i ].binding.parsedPath;\\n\\n\\t\\t\\t\\t\\tbinding = new PropertyMixer(\\n\\t\\t\\t\\t\\t\\tPropertyBinding.create( root, trackName, path ),\\n\\t\\t\\t\\t\\t\\ttrack.ValueTypeName, track.getValueSize() );\\n\\n\\t\\t\\t\\t\\t++ binding.referenceCount;\\n\\t\\t\\t\\t\\tthis._addInactiveBinding( binding, rootUuid, trackName );\\n\\n\\t\\t\\t\\t\\tbindings[ i ] = binding;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tinterpolants[ i ].resultBuffer = binding.buffer;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_activateAction: function ( action ) {\\n\\n\\t\\t\\tif ( ! this._isActiveAction( action ) ) {\\n\\n\\t\\t\\t\\tif ( action._cacheIndex === null ) {\\n\\n\\t\\t\\t\\t\\t// this action has been forgotten by the cache, but the user\\n\\t\\t\\t\\t\\t// appears to be still using it -> rebind\\n\\n\\t\\t\\t\\t\\tvar rootUuid = ( action._localRoot || this._root ).uuid,\\n\\t\\t\\t\\t\\t\\tclipUuid = action._clip.uuid,\\n\\t\\t\\t\\t\\t\\tactionsForClip = this._actionsByClip[ clipUuid ];\\n\\n\\t\\t\\t\\t\\tthis._bindAction( action,\\n\\t\\t\\t\\t\\t\\tactionsForClip && actionsForClip.knownActions[ 0 ] );\\n\\n\\t\\t\\t\\t\\tthis._addInactiveAction( action, clipUuid, rootUuid );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar bindings = action._propertyBindings;\\n\\n\\t\\t\\t\\t// increment reference counts / sort out state\\n\\t\\t\\t\\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\tvar binding = bindings[ i ];\\n\\n\\t\\t\\t\\t\\tif ( binding.useCount ++ === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tthis._lendBinding( binding );\\n\\t\\t\\t\\t\\t\\tbinding.saveOriginalState();\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis._lendAction( action );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_deactivateAction: function ( action ) {\\n\\n\\t\\t\\tif ( this._isActiveAction( action ) ) {\\n\\n\\t\\t\\t\\tvar bindings = action._propertyBindings;\\n\\n\\t\\t\\t\\t// decrement reference counts / sort out state\\n\\t\\t\\t\\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\tvar binding = bindings[ i ];\\n\\n\\t\\t\\t\\t\\tif ( -- binding.useCount === 0 ) {\\n\\n\\t\\t\\t\\t\\t\\tbinding.restoreOriginalState();\\n\\t\\t\\t\\t\\t\\tthis._takeBackBinding( binding );\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tthis._takeBackAction( action );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t// Memory manager\\n\\n\\t\\t_initMemoryManager: function () {\\n\\n\\t\\t\\tthis._actions = []; // 'nActiveActions' followed by inactive ones\\n\\t\\t\\tthis._nActiveActions = 0;\\n\\n\\t\\t\\tthis._actionsByClip = {};\\n\\t\\t\\t// inside:\\n\\t\\t\\t// {\\n\\t\\t\\t// \\t\\tknownActions: Array< AnimationAction >\\t- used as prototypes\\n\\t\\t\\t// \\t\\tactionByRoot: AnimationAction\\t\\t\\t- lookup\\n\\t\\t\\t// }\\n\\n\\n\\t\\t\\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\\n\\t\\t\\tthis._nActiveBindings = 0;\\n\\n\\t\\t\\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\\n\\n\\n\\t\\t\\tthis._controlInterpolants = []; // same game as above\\n\\t\\t\\tthis._nActiveControlInterpolants = 0;\\n\\n\\t\\t\\tvar scope = this;\\n\\n\\t\\t\\tthis.stats = {\\n\\n\\t\\t\\t\\tactions: {\\n\\t\\t\\t\\t\\tget total() {\\n\\n\\t\\t\\t\\t\\t\\treturn scope._actions.length;\\n\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\tget inUse() {\\n\\n\\t\\t\\t\\t\\t\\treturn scope._nActiveActions;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tbindings: {\\n\\t\\t\\t\\t\\tget total() {\\n\\n\\t\\t\\t\\t\\t\\treturn scope._bindings.length;\\n\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\tget inUse() {\\n\\n\\t\\t\\t\\t\\t\\treturn scope._nActiveBindings;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tcontrolInterpolants: {\\n\\t\\t\\t\\t\\tget total() {\\n\\n\\t\\t\\t\\t\\t\\treturn scope._controlInterpolants.length;\\n\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\tget inUse() {\\n\\n\\t\\t\\t\\t\\t\\treturn scope._nActiveControlInterpolants;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t};\\n\\n\\t\\t},\\n\\n\\t\\t// Memory management for AnimationAction objects\\n\\n\\t\\t_isActiveAction: function ( action ) {\\n\\n\\t\\t\\tvar index = action._cacheIndex;\\n\\t\\t\\treturn index !== null && index < this._nActiveActions;\\n\\n\\t\\t},\\n\\n\\t\\t_addInactiveAction: function ( action, clipUuid, rootUuid ) {\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tactionsByClip = this._actionsByClip,\\n\\t\\t\\t\\tactionsForClip = actionsByClip[ clipUuid ];\\n\\n\\t\\t\\tif ( actionsForClip === undefined ) {\\n\\n\\t\\t\\t\\tactionsForClip = {\\n\\n\\t\\t\\t\\t\\tknownActions: [ action ],\\n\\t\\t\\t\\t\\tactionByRoot: {}\\n\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\taction._byClipCacheIndex = 0;\\n\\n\\t\\t\\t\\tactionsByClip[ clipUuid ] = actionsForClip;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar knownActions = actionsForClip.knownActions;\\n\\n\\t\\t\\t\\taction._byClipCacheIndex = knownActions.length;\\n\\t\\t\\t\\tknownActions.push( action );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\taction._cacheIndex = actions.length;\\n\\t\\t\\tactions.push( action );\\n\\n\\t\\t\\tactionsForClip.actionByRoot[ rootUuid ] = action;\\n\\n\\t\\t},\\n\\n\\t\\t_removeInactiveAction: function ( action ) {\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tlastInactiveAction = actions[ actions.length - 1 ],\\n\\t\\t\\t\\tcacheIndex = action._cacheIndex;\\n\\n\\t\\t\\tlastInactiveAction._cacheIndex = cacheIndex;\\n\\t\\t\\tactions[ cacheIndex ] = lastInactiveAction;\\n\\t\\t\\tactions.pop();\\n\\n\\t\\t\\taction._cacheIndex = null;\\n\\n\\n\\t\\t\\tvar clipUuid = action._clip.uuid,\\n\\t\\t\\t\\tactionsByClip = this._actionsByClip,\\n\\t\\t\\t\\tactionsForClip = actionsByClip[ clipUuid ],\\n\\t\\t\\t\\tknownActionsForClip = actionsForClip.knownActions,\\n\\n\\t\\t\\t\\tlastKnownAction =\\n\\t\\t\\t\\t\\tknownActionsForClip[ knownActionsForClip.length - 1 ],\\n\\n\\t\\t\\t\\tbyClipCacheIndex = action._byClipCacheIndex;\\n\\n\\t\\t\\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\\n\\t\\t\\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\\n\\t\\t\\tknownActionsForClip.pop();\\n\\n\\t\\t\\taction._byClipCacheIndex = null;\\n\\n\\n\\t\\t\\tvar actionByRoot = actionsForClip.actionByRoot,\\n\\t\\t\\t\\trootUuid = ( action._localRoot || this._root ).uuid;\\n\\n\\t\\t\\tdelete actionByRoot[ rootUuid ];\\n\\n\\t\\t\\tif ( knownActionsForClip.length === 0 ) {\\n\\n\\t\\t\\t\\tdelete actionsByClip[ clipUuid ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis._removeInactiveBindingsForAction( action );\\n\\n\\t\\t},\\n\\n\\t\\t_removeInactiveBindingsForAction: function ( action ) {\\n\\n\\t\\t\\tvar bindings = action._propertyBindings;\\n\\t\\t\\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\tvar binding = bindings[ i ];\\n\\n\\t\\t\\t\\tif ( -- binding.referenceCount === 0 ) {\\n\\n\\t\\t\\t\\t\\tthis._removeInactiveBinding( binding );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_lendAction: function ( action ) {\\n\\n\\t\\t\\t// [ active actions |  inactive actions  ]\\n\\t\\t\\t// [  active actions >| inactive actions ]\\n\\t\\t\\t//                 s        a\\n\\t\\t\\t//                  <-swap->\\n\\t\\t\\t//                 a        s\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tprevIndex = action._cacheIndex,\\n\\n\\t\\t\\t\\tlastActiveIndex = this._nActiveActions ++,\\n\\n\\t\\t\\t\\tfirstInactiveAction = actions[ lastActiveIndex ];\\n\\n\\t\\t\\taction._cacheIndex = lastActiveIndex;\\n\\t\\t\\tactions[ lastActiveIndex ] = action;\\n\\n\\t\\t\\tfirstInactiveAction._cacheIndex = prevIndex;\\n\\t\\t\\tactions[ prevIndex ] = firstInactiveAction;\\n\\n\\t\\t},\\n\\n\\t\\t_takeBackAction: function ( action ) {\\n\\n\\t\\t\\t// [  active actions  | inactive actions ]\\n\\t\\t\\t// [ active actions |< inactive actions  ]\\n\\t\\t\\t//        a        s\\n\\t\\t\\t//         <-swap->\\n\\t\\t\\t//        s        a\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tprevIndex = action._cacheIndex,\\n\\n\\t\\t\\t\\tfirstInactiveIndex = -- this._nActiveActions,\\n\\n\\t\\t\\t\\tlastActiveAction = actions[ firstInactiveIndex ];\\n\\n\\t\\t\\taction._cacheIndex = firstInactiveIndex;\\n\\t\\t\\tactions[ firstInactiveIndex ] = action;\\n\\n\\t\\t\\tlastActiveAction._cacheIndex = prevIndex;\\n\\t\\t\\tactions[ prevIndex ] = lastActiveAction;\\n\\n\\t\\t},\\n\\n\\t\\t// Memory management for PropertyMixer objects\\n\\n\\t\\t_addInactiveBinding: function ( binding, rootUuid, trackName ) {\\n\\n\\t\\t\\tvar bindingsByRoot = this._bindingsByRootAndName,\\n\\t\\t\\t\\tbindingByName = bindingsByRoot[ rootUuid ],\\n\\n\\t\\t\\t\\tbindings = this._bindings;\\n\\n\\t\\t\\tif ( bindingByName === undefined ) {\\n\\n\\t\\t\\t\\tbindingByName = {};\\n\\t\\t\\t\\tbindingsByRoot[ rootUuid ] = bindingByName;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tbindingByName[ trackName ] = binding;\\n\\n\\t\\t\\tbinding._cacheIndex = bindings.length;\\n\\t\\t\\tbindings.push( binding );\\n\\n\\t\\t},\\n\\n\\t\\t_removeInactiveBinding: function ( binding ) {\\n\\n\\t\\t\\tvar bindings = this._bindings,\\n\\t\\t\\t\\tpropBinding = binding.binding,\\n\\t\\t\\t\\trootUuid = propBinding.rootNode.uuid,\\n\\t\\t\\t\\ttrackName = propBinding.path,\\n\\t\\t\\t\\tbindingsByRoot = this._bindingsByRootAndName,\\n\\t\\t\\t\\tbindingByName = bindingsByRoot[ rootUuid ],\\n\\n\\t\\t\\t\\tlastInactiveBinding = bindings[ bindings.length - 1 ],\\n\\t\\t\\t\\tcacheIndex = binding._cacheIndex;\\n\\n\\t\\t\\tlastInactiveBinding._cacheIndex = cacheIndex;\\n\\t\\t\\tbindings[ cacheIndex ] = lastInactiveBinding;\\n\\t\\t\\tbindings.pop();\\n\\n\\t\\t\\tdelete bindingByName[ trackName ];\\n\\n\\t\\t\\tremove_empty_map: {\\n\\n\\t\\t\\t\\tfor ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars\\n\\n\\t\\t\\t\\tdelete bindingsByRoot[ rootUuid ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t_lendBinding: function ( binding ) {\\n\\n\\t\\t\\tvar bindings = this._bindings,\\n\\t\\t\\t\\tprevIndex = binding._cacheIndex,\\n\\n\\t\\t\\t\\tlastActiveIndex = this._nActiveBindings ++,\\n\\n\\t\\t\\t\\tfirstInactiveBinding = bindings[ lastActiveIndex ];\\n\\n\\t\\t\\tbinding._cacheIndex = lastActiveIndex;\\n\\t\\t\\tbindings[ lastActiveIndex ] = binding;\\n\\n\\t\\t\\tfirstInactiveBinding._cacheIndex = prevIndex;\\n\\t\\t\\tbindings[ prevIndex ] = firstInactiveBinding;\\n\\n\\t\\t},\\n\\n\\t\\t_takeBackBinding: function ( binding ) {\\n\\n\\t\\t\\tvar bindings = this._bindings,\\n\\t\\t\\t\\tprevIndex = binding._cacheIndex,\\n\\n\\t\\t\\t\\tfirstInactiveIndex = -- this._nActiveBindings,\\n\\n\\t\\t\\t\\tlastActiveBinding = bindings[ firstInactiveIndex ];\\n\\n\\t\\t\\tbinding._cacheIndex = firstInactiveIndex;\\n\\t\\t\\tbindings[ firstInactiveIndex ] = binding;\\n\\n\\t\\t\\tlastActiveBinding._cacheIndex = prevIndex;\\n\\t\\t\\tbindings[ prevIndex ] = lastActiveBinding;\\n\\n\\t\\t},\\n\\n\\n\\t\\t// Memory management of Interpolants for weight and time scale\\n\\n\\t\\t_lendControlInterpolant: function () {\\n\\n\\t\\t\\tvar interpolants = this._controlInterpolants,\\n\\t\\t\\t\\tlastActiveIndex = this._nActiveControlInterpolants ++,\\n\\t\\t\\t\\tinterpolant = interpolants[ lastActiveIndex ];\\n\\n\\t\\t\\tif ( interpolant === undefined ) {\\n\\n\\t\\t\\t\\tinterpolant = new LinearInterpolant(\\n\\t\\t\\t\\t\\tnew Float32Array( 2 ), new Float32Array( 2 ),\\n\\t\\t\\t\\t\\t1, this._controlInterpolantsResultBuffer );\\n\\n\\t\\t\\t\\tinterpolant.__cacheIndex = lastActiveIndex;\\n\\t\\t\\t\\tinterpolants[ lastActiveIndex ] = interpolant;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn interpolant;\\n\\n\\t\\t},\\n\\n\\t\\t_takeBackControlInterpolant: function ( interpolant ) {\\n\\n\\t\\t\\tvar interpolants = this._controlInterpolants,\\n\\t\\t\\t\\tprevIndex = interpolant.__cacheIndex,\\n\\n\\t\\t\\t\\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\\n\\n\\t\\t\\t\\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\\n\\n\\t\\t\\tinterpolant.__cacheIndex = firstInactiveIndex;\\n\\t\\t\\tinterpolants[ firstInactiveIndex ] = interpolant;\\n\\n\\t\\t\\tlastActiveInterpolant.__cacheIndex = prevIndex;\\n\\t\\t\\tinterpolants[ prevIndex ] = lastActiveInterpolant;\\n\\n\\t\\t},\\n\\n\\t\\t_controlInterpolantsResultBuffer: new Float32Array( 1 ),\\n\\n\\t\\t// return an action for a clip optionally using a custom root target\\n\\t\\t// object (this method allocates a lot of dynamic memory in case a\\n\\t\\t// previously unknown clip/root combination is specified)\\n\\t\\tclipAction: function ( clip, optionalRoot ) {\\n\\n\\t\\t\\tvar root = optionalRoot || this._root,\\n\\t\\t\\t\\trootUuid = root.uuid,\\n\\n\\t\\t\\t\\tclipObject = typeof clip === 'string' ?\\n\\t\\t\\t\\t\\tAnimationClip.findByName( root, clip ) : clip,\\n\\n\\t\\t\\t\\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\\n\\n\\t\\t\\t\\tactionsForClip = this._actionsByClip[ clipUuid ],\\n\\t\\t\\t\\tprototypeAction = null;\\n\\n\\t\\t\\tif ( actionsForClip !== undefined ) {\\n\\n\\t\\t\\t\\tvar existingAction =\\n\\t\\t\\t\\t\\t\\tactionsForClip.actionByRoot[ rootUuid ];\\n\\n\\t\\t\\t\\tif ( existingAction !== undefined ) {\\n\\n\\t\\t\\t\\t\\treturn existingAction;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// we know the clip, so we don't have to parse all\\n\\t\\t\\t\\t// the bindings again but can just copy\\n\\t\\t\\t\\tprototypeAction = actionsForClip.knownActions[ 0 ];\\n\\n\\t\\t\\t\\t// also, take the clip from the prototype action\\n\\t\\t\\t\\tif ( clipObject === null )\\n\\t\\t\\t\\t\\tclipObject = prototypeAction._clip;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// clip must be known when specified via string\\n\\t\\t\\tif ( clipObject === null ) return null;\\n\\n\\t\\t\\t// allocate all resources required to run it\\n\\t\\t\\tvar newAction = new AnimationAction( this, clipObject, optionalRoot );\\n\\n\\t\\t\\tthis._bindAction( newAction, prototypeAction );\\n\\n\\t\\t\\t// and make the action known to the memory manager\\n\\t\\t\\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\\n\\n\\t\\t\\treturn newAction;\\n\\n\\t\\t},\\n\\n\\t\\t// get an existing action\\n\\t\\texistingAction: function ( clip, optionalRoot ) {\\n\\n\\t\\t\\tvar root = optionalRoot || this._root,\\n\\t\\t\\t\\trootUuid = root.uuid,\\n\\n\\t\\t\\t\\tclipObject = typeof clip === 'string' ?\\n\\t\\t\\t\\t\\tAnimationClip.findByName( root, clip ) : clip,\\n\\n\\t\\t\\t\\tclipUuid = clipObject ? clipObject.uuid : clip,\\n\\n\\t\\t\\t\\tactionsForClip = this._actionsByClip[ clipUuid ];\\n\\n\\t\\t\\tif ( actionsForClip !== undefined ) {\\n\\n\\t\\t\\t\\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn null;\\n\\n\\t\\t},\\n\\n\\t\\t// deactivates all previously scheduled actions\\n\\t\\tstopAllAction: function () {\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tnActions = this._nActiveActions,\\n\\t\\t\\t\\tbindings = this._bindings,\\n\\t\\t\\t\\tnBindings = this._nActiveBindings;\\n\\n\\t\\t\\tthis._nActiveActions = 0;\\n\\t\\t\\tthis._nActiveBindings = 0;\\n\\n\\t\\t\\tfor ( var i = 0; i !== nActions; ++ i ) {\\n\\n\\t\\t\\t\\tactions[ i ].reset();\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0; i !== nBindings; ++ i ) {\\n\\n\\t\\t\\t\\tbindings[ i ].useCount = 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// advance the time and update apply the animation\\n\\t\\tupdate: function ( deltaTime ) {\\n\\n\\t\\t\\tdeltaTime *= this.timeScale;\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tnActions = this._nActiveActions,\\n\\n\\t\\t\\t\\ttime = this.time += deltaTime,\\n\\t\\t\\t\\ttimeDirection = Math.sign( deltaTime ),\\n\\n\\t\\t\\t\\taccuIndex = this._accuIndex ^= 1;\\n\\n\\t\\t\\t// run active actions\\n\\n\\t\\t\\tfor ( var i = 0; i !== nActions; ++ i ) {\\n\\n\\t\\t\\t\\tvar action = actions[ i ];\\n\\n\\t\\t\\t\\taction._update( time, deltaTime, timeDirection, accuIndex );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\t// update scene graph\\n\\n\\t\\t\\tvar bindings = this._bindings,\\n\\t\\t\\t\\tnBindings = this._nActiveBindings;\\n\\n\\t\\t\\tfor ( var i = 0; i !== nBindings; ++ i ) {\\n\\n\\t\\t\\t\\tbindings[ i ].apply( accuIndex );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// return this mixer's root target object\\n\\t\\tgetRoot: function () {\\n\\n\\t\\t\\treturn this._root;\\n\\n\\t\\t},\\n\\n\\t\\t// free all resources specific to a particular clip\\n\\t\\tuncacheClip: function ( clip ) {\\n\\n\\t\\t\\tvar actions = this._actions,\\n\\t\\t\\t\\tclipUuid = clip.uuid,\\n\\t\\t\\t\\tactionsByClip = this._actionsByClip,\\n\\t\\t\\t\\tactionsForClip = actionsByClip[ clipUuid ];\\n\\n\\t\\t\\tif ( actionsForClip !== undefined ) {\\n\\n\\t\\t\\t\\t// note: just calling _removeInactiveAction would mess up the\\n\\t\\t\\t\\t// iteration state and also require updating the state we can\\n\\t\\t\\t\\t// just throw away\\n\\n\\t\\t\\t\\tvar actionsToRemove = actionsForClip.knownActions;\\n\\n\\t\\t\\t\\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\\n\\n\\t\\t\\t\\t\\tvar action = actionsToRemove[ i ];\\n\\n\\t\\t\\t\\t\\tthis._deactivateAction( action );\\n\\n\\t\\t\\t\\t\\tvar cacheIndex = action._cacheIndex,\\n\\t\\t\\t\\t\\t\\tlastInactiveAction = actions[ actions.length - 1 ];\\n\\n\\t\\t\\t\\t\\taction._cacheIndex = null;\\n\\t\\t\\t\\t\\taction._byClipCacheIndex = null;\\n\\n\\t\\t\\t\\t\\tlastInactiveAction._cacheIndex = cacheIndex;\\n\\t\\t\\t\\t\\tactions[ cacheIndex ] = lastInactiveAction;\\n\\t\\t\\t\\t\\tactions.pop();\\n\\n\\t\\t\\t\\t\\tthis._removeInactiveBindingsForAction( action );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tdelete actionsByClip[ clipUuid ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t// free all resources specific to a particular root target object\\n\\t\\tuncacheRoot: function ( root ) {\\n\\n\\t\\t\\tvar rootUuid = root.uuid,\\n\\t\\t\\t\\tactionsByClip = this._actionsByClip;\\n\\n\\t\\t\\tfor ( var clipUuid in actionsByClip ) {\\n\\n\\t\\t\\t\\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\\n\\t\\t\\t\\t\\taction = actionByRoot[ rootUuid ];\\n\\n\\t\\t\\t\\tif ( action !== undefined ) {\\n\\n\\t\\t\\t\\t\\tthis._deactivateAction( action );\\n\\t\\t\\t\\t\\tthis._removeInactiveAction( action );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar bindingsByRoot = this._bindingsByRootAndName,\\n\\t\\t\\t\\tbindingByName = bindingsByRoot[ rootUuid ];\\n\\n\\t\\t\\tif ( bindingByName !== undefined ) {\\n\\n\\t\\t\\t\\tfor ( var trackName in bindingByName ) {\\n\\n\\t\\t\\t\\t\\tvar binding = bindingByName[ trackName ];\\n\\t\\t\\t\\t\\tbinding.restoreOriginalState();\\n\\t\\t\\t\\t\\tthis._removeInactiveBinding( binding );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\t// remove a targeted clip from the cache\\n\\t\\tuncacheAction: function ( clip, optionalRoot ) {\\n\\n\\t\\t\\tvar action = this.existingAction( clip, optionalRoot );\\n\\n\\t\\t\\tif ( action !== null ) {\\n\\n\\t\\t\\t\\tthis._deactivateAction( action );\\n\\t\\t\\t\\tthis._removeInactiveAction( action );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Uniform( value ) {\\n\\n\\t\\tif ( typeof value === 'string' ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\\n\\t\\t\\tvalue = arguments[ 1 ];\\n\\n\\t\\t}\\n\\n\\t\\tthis.value = value;\\n\\n\\t}\\n\\n\\tUniform.prototype.clone = function () {\\n\\n\\t\\treturn new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t */\\n\\n\\tfunction InstancedBufferGeometry() {\\n\\n\\t\\tBufferGeometry.call( this );\\n\\n\\t\\tthis.type = 'InstancedBufferGeometry';\\n\\t\\tthis.maxInstancedCount = undefined;\\n\\n\\t}\\n\\n\\tInstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {\\n\\n\\t\\tconstructor: InstancedBufferGeometry,\\n\\n\\t\\tisInstancedBufferGeometry: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tBufferGeometry.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.maxInstancedCount = source.maxInstancedCount;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t */\\n\\n\\tfunction InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.data = interleavedBuffer;\\n\\t\\tthis.itemSize = itemSize;\\n\\t\\tthis.offset = offset;\\n\\n\\t\\tthis.normalized = normalized === true;\\n\\n\\t}\\n\\n\\tObject.defineProperties( InterleavedBufferAttribute.prototype, {\\n\\n\\t\\tcount: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.data.count;\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tarray: {\\n\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.data.array;\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( InterleavedBufferAttribute.prototype, {\\n\\n\\t\\tisInterleavedBufferAttribute: true,\\n\\n\\t\\tsetX: function ( index, x ) {\\n\\n\\t\\t\\tthis.data.array[ index * this.data.stride + this.offset ] = x;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetY: function ( index, y ) {\\n\\n\\t\\t\\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetZ: function ( index, z ) {\\n\\n\\t\\t\\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetW: function ( index, w ) {\\n\\n\\t\\t\\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tgetX: function ( index ) {\\n\\n\\t\\t\\treturn this.data.array[ index * this.data.stride + this.offset ];\\n\\n\\t\\t},\\n\\n\\t\\tgetY: function ( index ) {\\n\\n\\t\\t\\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\\n\\n\\t\\t},\\n\\n\\t\\tgetZ: function ( index ) {\\n\\n\\t\\t\\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\\n\\n\\t\\t},\\n\\n\\t\\tgetW: function ( index ) {\\n\\n\\t\\t\\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\\n\\n\\t\\t},\\n\\n\\t\\tsetXY: function ( index, x, y ) {\\n\\n\\t\\t\\tindex = index * this.data.stride + this.offset;\\n\\n\\t\\t\\tthis.data.array[ index + 0 ] = x;\\n\\t\\t\\tthis.data.array[ index + 1 ] = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetXYZ: function ( index, x, y, z ) {\\n\\n\\t\\t\\tindex = index * this.data.stride + this.offset;\\n\\n\\t\\t\\tthis.data.array[ index + 0 ] = x;\\n\\t\\t\\tthis.data.array[ index + 1 ] = y;\\n\\t\\t\\tthis.data.array[ index + 2 ] = z;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetXYZW: function ( index, x, y, z, w ) {\\n\\n\\t\\t\\tindex = index * this.data.stride + this.offset;\\n\\n\\t\\t\\tthis.data.array[ index + 0 ] = x;\\n\\t\\t\\tthis.data.array[ index + 1 ] = y;\\n\\t\\t\\tthis.data.array[ index + 2 ] = z;\\n\\t\\t\\tthis.data.array[ index + 3 ] = w;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t */\\n\\n\\tfunction InterleavedBuffer( array, stride ) {\\n\\n\\t\\tthis.uuid = _Math.generateUUID();\\n\\n\\t\\tthis.array = array;\\n\\t\\tthis.stride = stride;\\n\\t\\tthis.count = array !== undefined ? array.length / stride : 0;\\n\\n\\t\\tthis.dynamic = false;\\n\\t\\tthis.updateRange = { offset: 0, count: - 1 };\\n\\n\\t\\tthis.onUploadCallback = function () {};\\n\\n\\t\\tthis.version = 0;\\n\\n\\t}\\n\\n\\tObject.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {\\n\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tif ( value === true ) this.version ++;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( InterleavedBuffer.prototype, {\\n\\n\\t\\tisInterleavedBuffer: true,\\n\\n\\t\\tsetArray: function ( array ) {\\n\\n\\t\\t\\tif ( Array.isArray( array ) ) {\\n\\n\\t\\t\\t\\tthrow new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.count = array !== undefined ? array.length / this.stride : 0;\\n\\t\\t\\tthis.array = array;\\n\\n\\t\\t},\\n\\n\\t\\tsetDynamic: function ( value ) {\\n\\n\\t\\t\\tthis.dynamic = value;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tthis.array = new source.array.constructor( source.array );\\n\\t\\t\\tthis.count = source.count;\\n\\t\\t\\tthis.stride = source.stride;\\n\\t\\t\\tthis.dynamic = source.dynamic;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tcopyAt: function ( index1, attribute, index2 ) {\\n\\n\\t\\t\\tindex1 *= this.stride;\\n\\t\\t\\tindex2 *= attribute.stride;\\n\\n\\t\\t\\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tset: function ( value, offset ) {\\n\\n\\t\\t\\tif ( offset === undefined ) offset = 0;\\n\\n\\t\\t\\tthis.array.set( value, offset );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tonUpload: function ( callback ) {\\n\\n\\t\\t\\tthis.onUploadCallback = callback;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t */\\n\\n\\tfunction InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {\\n\\n\\t\\tInterleavedBuffer.call( this, array, stride );\\n\\n\\t\\tthis.meshPerAttribute = meshPerAttribute || 1;\\n\\n\\t}\\n\\n\\tInstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {\\n\\n\\t\\tconstructor: InstancedInterleavedBuffer,\\n\\n\\t\\tisInstancedInterleavedBuffer: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tInterleavedBuffer.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.meshPerAttribute = source.meshPerAttribute;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author benaadams / https://twitter.com/ben_a_adams\\n\\t */\\n\\n\\tfunction InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {\\n\\n\\t\\tBufferAttribute.call( this, array, itemSize );\\n\\n\\t\\tthis.meshPerAttribute = meshPerAttribute || 1;\\n\\n\\t}\\n\\n\\tInstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {\\n\\n\\t\\tconstructor: InstancedBufferAttribute,\\n\\n\\t\\tisInstancedBufferAttribute: true,\\n\\n\\t\\tcopy: function ( source ) {\\n\\n\\t\\t\\tBufferAttribute.prototype.copy.call( this, source );\\n\\n\\t\\t\\tthis.meshPerAttribute = source.meshPerAttribute;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author bhouston / http://clara.io/\\n\\t * @author stephomi / http://stephaneginier.com/\\n\\t */\\n\\n\\tfunction Raycaster( origin, direction, near, far ) {\\n\\n\\t\\tthis.ray = new Ray( origin, direction );\\n\\t\\t// direction is assumed to be normalized (for accurate distance calculations)\\n\\n\\t\\tthis.near = near || 0;\\n\\t\\tthis.far = far || Infinity;\\n\\n\\t\\tthis.params = {\\n\\t\\t\\tMesh: {},\\n\\t\\t\\tLine: {},\\n\\t\\t\\tLOD: {},\\n\\t\\t\\tPoints: { threshold: 1 },\\n\\t\\t\\tSprite: {}\\n\\t\\t};\\n\\n\\t\\tObject.defineProperties( this.params, {\\n\\t\\t\\tPointCloud: {\\n\\t\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\t\\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\\n\\t\\t\\t\\t\\treturn this.Points;\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} );\\n\\n\\t}\\n\\n\\tfunction ascSort( a, b ) {\\n\\n\\t\\treturn a.distance - b.distance;\\n\\n\\t}\\n\\n\\tfunction intersectObject( object, raycaster, intersects, recursive ) {\\n\\n\\t\\tif ( object.visible === false ) return;\\n\\n\\t\\tobject.raycast( raycaster, intersects );\\n\\n\\t\\tif ( recursive === true ) {\\n\\n\\t\\t\\tvar children = object.children;\\n\\n\\t\\t\\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tintersectObject( children[ i ], raycaster, intersects, true );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t}\\n\\n\\tObject.assign( Raycaster.prototype, {\\n\\n\\t\\tlinePrecision: 1,\\n\\n\\t\\tset: function ( origin, direction ) {\\n\\n\\t\\t\\t// direction is assumed to be normalized (for accurate distance calculations)\\n\\n\\t\\t\\tthis.ray.set( origin, direction );\\n\\n\\t\\t},\\n\\n\\t\\tsetFromCamera: function ( coords, camera ) {\\n\\n\\t\\t\\tif ( ( camera && camera.isPerspectiveCamera ) ) {\\n\\n\\t\\t\\t\\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\\n\\t\\t\\t\\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\\n\\n\\t\\t\\t} else if ( ( camera && camera.isOrthographicCamera ) ) {\\n\\n\\t\\t\\t\\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\\n\\t\\t\\t\\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t},\\n\\n\\t\\tintersectObject: function ( object, recursive ) {\\n\\n\\t\\t\\tvar intersects = [];\\n\\n\\t\\t\\tintersectObject( object, this, intersects, recursive );\\n\\n\\t\\t\\tintersects.sort( ascSort );\\n\\n\\t\\t\\treturn intersects;\\n\\n\\t\\t},\\n\\n\\t\\tintersectObjects: function ( objects, recursive ) {\\n\\n\\t\\t\\tvar intersects = [];\\n\\n\\t\\t\\tif ( Array.isArray( objects ) === false ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\\n\\t\\t\\t\\treturn intersects;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tintersectObject( objects[ i ], this, intersects, recursive );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tintersects.sort( ascSort );\\n\\n\\t\\t\\treturn intersects;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction Clock( autoStart ) {\\n\\n\\t\\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\\n\\n\\t\\tthis.startTime = 0;\\n\\t\\tthis.oldTime = 0;\\n\\t\\tthis.elapsedTime = 0;\\n\\n\\t\\tthis.running = false;\\n\\n\\t}\\n\\n\\tObject.assign( Clock.prototype, {\\n\\n\\t\\tstart: function () {\\n\\n\\t\\t\\tthis.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732\\n\\n\\t\\t\\tthis.oldTime = this.startTime;\\n\\t\\t\\tthis.elapsedTime = 0;\\n\\t\\t\\tthis.running = true;\\n\\n\\t\\t},\\n\\n\\t\\tstop: function () {\\n\\n\\t\\t\\tthis.getElapsedTime();\\n\\t\\t\\tthis.running = false;\\n\\t\\t\\tthis.autoStart = false;\\n\\n\\t\\t},\\n\\n\\t\\tgetElapsedTime: function () {\\n\\n\\t\\t\\tthis.getDelta();\\n\\t\\t\\treturn this.elapsedTime;\\n\\n\\t\\t},\\n\\n\\t\\tgetDelta: function () {\\n\\n\\t\\t\\tvar diff = 0;\\n\\n\\t\\t\\tif ( this.autoStart && ! this.running ) {\\n\\n\\t\\t\\t\\tthis.start();\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.running ) {\\n\\n\\t\\t\\t\\tvar newTime = ( typeof performance === 'undefined' ? Date : performance ).now();\\n\\n\\t\\t\\t\\tdiff = ( newTime - this.oldTime ) / 1000;\\n\\t\\t\\t\\tthis.oldTime = newTime;\\n\\n\\t\\t\\t\\tthis.elapsedTime += diff;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn diff;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author bhouston / http://clara.io\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t *\\n\\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\\n\\t *\\n\\t * The poles (phi) are at the positive and negative y axis.\\n\\t * The equator starts at positive z.\\n\\t */\\n\\n\\tfunction Spherical( radius, phi, theta ) {\\n\\n\\t\\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\\n\\t\\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\\n\\t\\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\\n\\n\\t\\treturn this;\\n\\n\\t}\\n\\n\\tObject.assign( Spherical.prototype, {\\n\\n\\t\\tset: function ( radius, phi, theta ) {\\n\\n\\t\\t\\tthis.radius = radius;\\n\\t\\t\\tthis.phi = phi;\\n\\t\\t\\tthis.theta = theta;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( other ) {\\n\\n\\t\\t\\tthis.radius = other.radius;\\n\\t\\t\\tthis.phi = other.phi;\\n\\t\\t\\tthis.theta = other.theta;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\t// restrict phi to be betwee EPS and PI-EPS\\n\\t\\tmakeSafe: function () {\\n\\n\\t\\t\\tvar EPS = 0.000001;\\n\\t\\t\\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromVector3: function ( vec3 ) {\\n\\n\\t\\t\\tthis.radius = vec3.length();\\n\\n\\t\\t\\tif ( this.radius === 0 ) {\\n\\n\\t\\t\\t\\tthis.theta = 0;\\n\\t\\t\\t\\tthis.phi = 0;\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\\n\\t\\t\\t\\tthis.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t *\\n\\t * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system\\n\\t *\\n\\t */\\n\\n\\tfunction Cylindrical( radius, theta, y ) {\\n\\n\\t\\tthis.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane\\n\\t\\tthis.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis\\n\\t\\tthis.y = ( y !== undefined ) ? y : 0; // height above the x-z plane\\n\\n\\t\\treturn this;\\n\\n\\t}\\n\\n\\tObject.assign( Cylindrical.prototype, {\\n\\n\\t\\tset: function ( radius, theta, y ) {\\n\\n\\t\\t\\tthis.radius = radius;\\n\\t\\t\\tthis.theta = theta;\\n\\t\\t\\tthis.y = y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tclone: function () {\\n\\n\\t\\t\\treturn new this.constructor().copy( this );\\n\\n\\t\\t},\\n\\n\\t\\tcopy: function ( other ) {\\n\\n\\t\\t\\tthis.radius = other.radius;\\n\\t\\t\\tthis.theta = other.theta;\\n\\t\\t\\tthis.y = other.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t},\\n\\n\\t\\tsetFromVector3: function ( vec3 ) {\\n\\n\\t\\t\\tthis.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );\\n\\t\\t\\tthis.theta = Math.atan2( vec3.x, vec3.z );\\n\\t\\t\\tthis.y = vec3.y;\\n\\n\\t\\t\\treturn this;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tfunction ImmediateRenderObject( material ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.material = material;\\n\\t\\tthis.render = function ( /* renderCallback */ ) {};\\n\\n\\t}\\n\\n\\tImmediateRenderObject.prototype = Object.create( Object3D.prototype );\\n\\tImmediateRenderObject.prototype.constructor = ImmediateRenderObject;\\n\\n\\tImmediateRenderObject.prototype.isImmediateRenderObject = true;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction VertexNormalsHelper( object, size, hex, linewidth ) {\\n\\n\\t\\tthis.object = object;\\n\\n\\t\\tthis.size = ( size !== undefined ) ? size : 1;\\n\\n\\t\\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\\n\\n\\t\\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\\n\\n\\t\\t//\\n\\n\\t\\tvar nNormals = 0;\\n\\n\\t\\tvar objGeometry = this.object.geometry;\\n\\n\\t\\tif ( objGeometry && objGeometry.isGeometry ) {\\n\\n\\t\\t\\tnNormals = objGeometry.faces.length * 3;\\n\\n\\t\\t} else if ( objGeometry && objGeometry.isBufferGeometry ) {\\n\\n\\t\\t\\tnNormals = objGeometry.attributes.normal.count;\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\tvar positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\\n\\n\\t\\tgeometry.addAttribute( 'position', positions );\\n\\n\\t\\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\\n\\n\\t\\t//\\n\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tVertexNormalsHelper.prototype = Object.create( LineSegments.prototype );\\n\\tVertexNormalsHelper.prototype.constructor = VertexNormalsHelper;\\n\\n\\tVertexNormalsHelper.prototype.update = ( function () {\\n\\n\\t\\tvar v1 = new Vector3();\\n\\t\\tvar v2 = new Vector3();\\n\\t\\tvar normalMatrix = new Matrix3();\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tvar keys = [ 'a', 'b', 'c' ];\\n\\n\\t\\t\\tthis.object.updateMatrixWorld( true );\\n\\n\\t\\t\\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\\n\\n\\t\\t\\tvar matrixWorld = this.object.matrixWorld;\\n\\n\\t\\t\\tvar position = this.geometry.attributes.position;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar objGeometry = this.object.geometry;\\n\\n\\t\\t\\tif ( objGeometry && objGeometry.isGeometry ) {\\n\\n\\t\\t\\t\\tvar vertices = objGeometry.vertices;\\n\\n\\t\\t\\t\\tvar faces = objGeometry.faces;\\n\\n\\t\\t\\t\\tvar idx = 0;\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\t\\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\t\\tvar vertex = vertices[ face[ keys[ j ] ] ];\\n\\n\\t\\t\\t\\t\\t\\tvar normal = face.vertexNormals[ j ];\\n\\n\\t\\t\\t\\t\\t\\tv1.copy( vertex ).applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\t\\t\\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\\n\\n\\t\\t\\t\\t\\t\\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\\n\\n\\t\\t\\t\\t\\t\\tidx = idx + 1;\\n\\n\\t\\t\\t\\t\\t\\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\\n\\n\\t\\t\\t\\t\\t\\tidx = idx + 1;\\n\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t} else if ( objGeometry && objGeometry.isBufferGeometry ) {\\n\\n\\t\\t\\t\\tvar objPos = objGeometry.attributes.position;\\n\\n\\t\\t\\t\\tvar objNorm = objGeometry.attributes.normal;\\n\\n\\t\\t\\t\\tvar idx = 0;\\n\\n\\t\\t\\t\\t// for simplicity, ignore index and drawcalls, and render every normal\\n\\n\\t\\t\\t\\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\\n\\n\\t\\t\\t\\t\\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\t\\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\\n\\n\\t\\t\\t\\t\\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\\n\\n\\t\\t\\t\\t\\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\\n\\n\\t\\t\\t\\t\\tidx = idx + 1;\\n\\n\\t\\t\\t\\t\\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\\n\\n\\t\\t\\t\\t\\tidx = idx + 1;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tposition.needsUpdate = true;\\n\\n\\t\\t};\\n\\n\\t}() );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction SpotLightHelper( light, color ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.light = light;\\n\\t\\tthis.light.updateMatrixWorld();\\n\\n\\t\\tthis.matrix = light.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.color = color;\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\tvar positions = [\\n\\t\\t\\t0, 0, 0, \\t0, 0, 1,\\n\\t\\t\\t0, 0, 0, \\t1, 0, 1,\\n\\t\\t\\t0, 0, 0,\\t- 1, 0, 1,\\n\\t\\t\\t0, 0, 0, \\t0, 1, 1,\\n\\t\\t\\t0, 0, 0, \\t0, - 1, 1\\n\\t\\t];\\n\\n\\t\\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\\n\\n\\t\\t\\tvar p1 = ( i / l ) * Math.PI * 2;\\n\\t\\t\\tvar p2 = ( j / l ) * Math.PI * 2;\\n\\n\\t\\t\\tpositions.push(\\n\\t\\t\\t\\tMath.cos( p1 ), Math.sin( p1 ), 1,\\n\\t\\t\\t\\tMath.cos( p2 ), Math.sin( p2 ), 1\\n\\t\\t\\t);\\n\\n\\t\\t}\\n\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\\n\\n\\t\\tvar material = new LineBasicMaterial( { fog: false } );\\n\\n\\t\\tthis.cone = new LineSegments( geometry, material );\\n\\t\\tthis.add( this.cone );\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tSpotLightHelper.prototype = Object.create( Object3D.prototype );\\n\\tSpotLightHelper.prototype.constructor = SpotLightHelper;\\n\\n\\tSpotLightHelper.prototype.dispose = function () {\\n\\n\\t\\tthis.cone.geometry.dispose();\\n\\t\\tthis.cone.material.dispose();\\n\\n\\t};\\n\\n\\tSpotLightHelper.prototype.update = function () {\\n\\n\\t\\tvar vector = new Vector3();\\n\\t\\tvar vector2 = new Vector3();\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tthis.light.updateMatrixWorld();\\n\\n\\t\\t\\tvar coneLength = this.light.distance ? this.light.distance : 1000;\\n\\t\\t\\tvar coneWidth = coneLength * Math.tan( this.light.angle );\\n\\n\\t\\t\\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\\n\\n\\t\\t\\tvector.setFromMatrixPosition( this.light.matrixWorld );\\n\\t\\t\\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\\n\\n\\t\\t\\tthis.cone.lookAt( vector2.sub( vector ) );\\n\\n\\t\\t\\tif ( this.color !== undefined ) {\\n\\n\\t\\t\\t\\tthis.cone.material.color.set( this.color );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.cone.material.color.copy( this.light.color );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\t/**\\n\\t * @author Sean Griffin / http://twitter.com/sgrif\\n\\t * @author Michael Guerrero / http://realitymeltdown.com\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author ikerr / http://verold.com\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\tfunction getBoneList( object ) {\\n\\n\\t\\tvar boneList = [];\\n\\n\\t\\tif ( object && object.isBone ) {\\n\\n\\t\\t\\tboneList.push( object );\\n\\n\\t\\t}\\n\\n\\t\\tfor ( var i = 0; i < object.children.length; i ++ ) {\\n\\n\\t\\t\\tboneList.push.apply( boneList, getBoneList( object.children[ i ] ) );\\n\\n\\t\\t}\\n\\n\\t\\treturn boneList;\\n\\n\\t}\\n\\n\\tfunction SkeletonHelper( object ) {\\n\\n\\t\\tvar bones = getBoneList( object );\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\tvar vertices = [];\\n\\t\\tvar colors = [];\\n\\n\\t\\tvar color1 = new Color( 0, 0, 1 );\\n\\t\\tvar color2 = new Color( 0, 1, 0 );\\n\\n\\t\\tfor ( var i = 0; i < bones.length; i ++ ) {\\n\\n\\t\\t\\tvar bone = bones[ i ];\\n\\n\\t\\t\\tif ( bone.parent && bone.parent.isBone ) {\\n\\n\\t\\t\\t\\tvertices.push( 0, 0, 0 );\\n\\t\\t\\t\\tvertices.push( 0, 0, 0 );\\n\\t\\t\\t\\tcolors.push( color1.r, color1.g, color1.b );\\n\\t\\t\\t\\tcolors.push( color2.r, color2.g, color2.b );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\n\\n\\t\\tvar material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );\\n\\n\\t\\tLineSegments.call( this, geometry, material );\\n\\n\\t\\tthis.root = object;\\n\\t\\tthis.bones = bones;\\n\\n\\t\\tthis.matrix = object.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t}\\n\\n\\tSkeletonHelper.prototype = Object.create( LineSegments.prototype );\\n\\tSkeletonHelper.prototype.constructor = SkeletonHelper;\\n\\n\\tSkeletonHelper.prototype.updateMatrixWorld = function () {\\n\\n\\t\\tvar vector = new Vector3();\\n\\n\\t\\tvar boneMatrix = new Matrix4();\\n\\t\\tvar matrixWorldInv = new Matrix4();\\n\\n\\t\\treturn function updateMatrixWorld( force ) {\\n\\n\\t\\t\\tvar bones = this.bones;\\n\\n\\t\\t\\tvar geometry = this.geometry;\\n\\t\\t\\tvar position = geometry.getAttribute( 'position' );\\n\\n\\t\\t\\tmatrixWorldInv.getInverse( this.root.matrixWorld );\\n\\n\\t\\t\\tfor ( var i = 0, j = 0; i < bones.length; i ++ ) {\\n\\n\\t\\t\\t\\tvar bone = bones[ i ];\\n\\n\\t\\t\\t\\tif ( bone.parent && bone.parent.isBone ) {\\n\\n\\t\\t\\t\\t\\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\\n\\t\\t\\t\\t\\tvector.setFromMatrixPosition( boneMatrix );\\n\\t\\t\\t\\t\\tposition.setXYZ( j, vector.x, vector.y, vector.z );\\n\\n\\t\\t\\t\\t\\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\\n\\t\\t\\t\\t\\tvector.setFromMatrixPosition( boneMatrix );\\n\\t\\t\\t\\t\\tposition.setXYZ( j + 1, vector.x, vector.y, vector.z );\\n\\n\\t\\t\\t\\t\\tj += 2;\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tgeometry.getAttribute( 'position' ).needsUpdate = true;\\n\\n\\t\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction PointLightHelper( light, sphereSize, color ) {\\n\\n\\t\\tthis.light = light;\\n\\t\\tthis.light.updateMatrixWorld();\\n\\n\\t\\tthis.color = color;\\n\\n\\t\\tvar geometry = new SphereBufferGeometry( sphereSize, 4, 2 );\\n\\t\\tvar material = new MeshBasicMaterial( { wireframe: true, fog: false } );\\n\\n\\t\\tMesh.call( this, geometry, material );\\n\\n\\t\\tthis.matrix = this.light.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.update();\\n\\n\\n\\t\\t/*\\n\\t\\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\\n\\t\\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\\n\\n\\t\\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\\n\\t\\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\\n\\n\\t\\tvar d = light.distance;\\n\\n\\t\\tif ( d === 0.0 ) {\\n\\n\\t\\t\\tthis.lightDistance.visible = false;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tthis.lightDistance.scale.set( d, d, d );\\n\\n\\t\\t}\\n\\n\\t\\tthis.add( this.lightDistance );\\n\\t\\t*/\\n\\n\\t}\\n\\n\\tPointLightHelper.prototype = Object.create( Mesh.prototype );\\n\\tPointLightHelper.prototype.constructor = PointLightHelper;\\n\\n\\tPointLightHelper.prototype.dispose = function () {\\n\\n\\t\\tthis.geometry.dispose();\\n\\t\\tthis.material.dispose();\\n\\n\\t};\\n\\n\\tPointLightHelper.prototype.update = function () {\\n\\n\\t\\tif ( this.color !== undefined ) {\\n\\n\\t\\t\\tthis.material.color.set( this.color );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tthis.material.color.copy( this.light.color );\\n\\n\\t\\t}\\n\\n\\t\\t/*\\n\\t\\tvar d = this.light.distance;\\n\\n\\t\\tif ( d === 0.0 ) {\\n\\n\\t\\t\\tthis.lightDistance.visible = false;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tthis.lightDistance.visible = true;\\n\\t\\t\\tthis.lightDistance.scale.set( d, d, d );\\n\\n\\t\\t}\\n\\t\\t*/\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author abelnation / http://github.com/abelnation\\n\\t * @author Mugen87 / http://github.com/Mugen87\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction RectAreaLightHelper( light, color ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.light = light;\\n\\t\\tthis.light.updateMatrixWorld();\\n\\n\\t\\tthis.matrix = light.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.color = color;\\n\\n\\t\\tvar material = new LineBasicMaterial( { fog: false } );\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\tgeometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 5 * 3 ), 3 ) );\\n\\n\\t\\tthis.line = new Line( geometry, material );\\n\\t\\tthis.add( this.line );\\n\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tRectAreaLightHelper.prototype = Object.create( Object3D.prototype );\\n\\tRectAreaLightHelper.prototype.constructor = RectAreaLightHelper;\\n\\n\\tRectAreaLightHelper.prototype.dispose = function () {\\n\\n\\t\\tthis.children[ 0 ].geometry.dispose();\\n\\t\\tthis.children[ 0 ].material.dispose();\\n\\n\\t};\\n\\n\\tRectAreaLightHelper.prototype.update = function () {\\n\\n\\t\\t// calculate new dimensions of the helper\\n\\n\\t\\tvar hx = this.light.width * 0.5;\\n\\t\\tvar hy = this.light.height * 0.5;\\n\\n\\t\\tvar position = this.line.geometry.attributes.position;\\n\\t\\tvar array = position.array;\\n\\n\\t\\t// update vertices\\n\\n\\t\\tarray[ 0 ] = hx; array[ 1 ] = - hy; array[ 2 ] = 0;\\n\\t\\tarray[ 3 ] = hx; array[ 4 ] = hy; array[ 5 ] = 0;\\n\\t\\tarray[ 6 ] = - hx; array[ 7 ] = hy; array[ 8 ] = 0;\\n\\t\\tarray[ 9 ] = - hx; array[ 10 ] = - hy; array[ 11 ] = 0;\\n\\t\\tarray[ 12 ] = hx; array[ 13 ] = - hy; array[ 14 ] = 0;\\n\\n\\t\\tposition.needsUpdate = true;\\n\\n\\t\\tif ( this.color !== undefined ) {\\n\\n\\t\\t\\tthis.line.material.color.set( this.color );\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tthis.line.material.color.copy( this.light.color );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t */\\n\\n\\tfunction HemisphereLightHelper( light, size, color ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.light = light;\\n\\t\\tthis.light.updateMatrixWorld();\\n\\n\\t\\tthis.matrix = light.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.color = color;\\n\\n\\t\\tvar geometry = new OctahedronBufferGeometry( size );\\n\\t\\tgeometry.rotateY( Math.PI * 0.5 );\\n\\n\\t\\tthis.material = new MeshBasicMaterial( { wireframe: true, fog: false } );\\n\\t\\tif ( this.color === undefined ) this.material.vertexColors = VertexColors;\\n\\n\\t\\tvar position = geometry.getAttribute( 'position' );\\n\\t\\tvar colors = new Float32Array( position.count * 3 );\\n\\n\\t\\tgeometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );\\n\\n\\t\\tthis.add( new Mesh( geometry, this.material ) );\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tHemisphereLightHelper.prototype = Object.create( Object3D.prototype );\\n\\tHemisphereLightHelper.prototype.constructor = HemisphereLightHelper;\\n\\n\\tHemisphereLightHelper.prototype.dispose = function () {\\n\\n\\t\\tthis.children[ 0 ].geometry.dispose();\\n\\t\\tthis.children[ 0 ].material.dispose();\\n\\n\\t};\\n\\n\\tHemisphereLightHelper.prototype.update = function () {\\n\\n\\t\\tvar vector = new Vector3();\\n\\n\\t\\tvar color1 = new Color();\\n\\t\\tvar color2 = new Color();\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tvar mesh = this.children[ 0 ];\\n\\n\\t\\t\\tif ( this.color !== undefined ) {\\n\\n\\t\\t\\t\\tthis.material.color.set( this.color );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tvar colors = mesh.geometry.getAttribute( 'color' );\\n\\n\\t\\t\\t\\tcolor1.copy( this.light.color );\\n\\t\\t\\t\\tcolor2.copy( this.light.groundColor );\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = colors.count; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tvar color = ( i < ( l / 2 ) ) ? color1 : color2;\\n\\n\\t\\t\\t\\t\\tcolors.setXYZ( i, color.r, color.g, color.b );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tcolors.needsUpdate = true;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tmesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction GridHelper( size, divisions, color1, color2 ) {\\n\\n\\t\\tsize = size || 10;\\n\\t\\tdivisions = divisions || 10;\\n\\t\\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\\n\\t\\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\\n\\n\\t\\tvar center = divisions / 2;\\n\\t\\tvar step = size / divisions;\\n\\t\\tvar halfSize = size / 2;\\n\\n\\t\\tvar vertices = [], colors = [];\\n\\n\\t\\tfor ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {\\n\\n\\t\\t\\tvertices.push( - halfSize, 0, k, halfSize, 0, k );\\n\\t\\t\\tvertices.push( k, 0, - halfSize, k, 0, halfSize );\\n\\n\\t\\t\\tvar color = i === center ? color1 : color2;\\n\\n\\t\\t\\tcolor.toArray( colors, j ); j += 3;\\n\\t\\t\\tcolor.toArray( colors, j ); j += 3;\\n\\t\\t\\tcolor.toArray( colors, j ); j += 3;\\n\\t\\t\\tcolor.toArray( colors, j ); j += 3;\\n\\n\\t\\t}\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\n\\n\\t\\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\\n\\n\\t\\tLineSegments.call( this, geometry, material );\\n\\n\\t}\\n\\n\\tGridHelper.prototype = Object.create( LineSegments.prototype );\\n\\tGridHelper.prototype.constructor = GridHelper;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / http://github.com/Mugen87\\n\\t * @author Hectate / http://www.github.com/Hectate\\n\\t */\\n\\n\\tfunction PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {\\n\\n\\t\\tradius = radius || 10;\\n\\t\\tradials = radials || 16;\\n\\t\\tcircles = circles || 8;\\n\\t\\tdivisions = divisions || 64;\\n\\t\\tcolor1 = new Color( color1 !== undefined ? color1 : 0x444444 );\\n\\t\\tcolor2 = new Color( color2 !== undefined ? color2 : 0x888888 );\\n\\n\\t\\tvar vertices = [];\\n\\t\\tvar colors = [];\\n\\n\\t\\tvar x, z;\\n\\t\\tvar v, i, j, r, color;\\n\\n\\t\\t// create the radials\\n\\n\\t\\tfor ( i = 0; i <= radials; i ++ ) {\\n\\n\\t\\t\\tv = ( i / radials ) * ( Math.PI * 2 );\\n\\n\\t\\t\\tx = Math.sin( v ) * radius;\\n\\t\\t\\tz = Math.cos( v ) * radius;\\n\\n\\t\\t\\tvertices.push( 0, 0, 0 );\\n\\t\\t\\tvertices.push( x, 0, z );\\n\\n\\t\\t\\tcolor = ( i & 1 ) ? color1 : color2;\\n\\n\\t\\t\\tcolors.push( color.r, color.g, color.b );\\n\\t\\t\\tcolors.push( color.r, color.g, color.b );\\n\\n\\t\\t}\\n\\n\\t\\t// create the circles\\n\\n\\t\\tfor ( i = 0; i <= circles; i ++ ) {\\n\\n\\t\\t\\tcolor = ( i & 1 ) ? color1 : color2;\\n\\n\\t\\t\\tr = radius - ( radius / circles * i );\\n\\n\\t\\t\\tfor ( j = 0; j < divisions; j ++ ) {\\n\\n\\t\\t\\t\\t// first vertex\\n\\n\\t\\t\\t\\tv = ( j / divisions ) * ( Math.PI * 2 );\\n\\n\\t\\t\\t\\tx = Math.sin( v ) * r;\\n\\t\\t\\t\\tz = Math.cos( v ) * r;\\n\\n\\t\\t\\t\\tvertices.push( x, 0, z );\\n\\t\\t\\t\\tcolors.push( color.r, color.g, color.b );\\n\\n\\t\\t\\t\\t// second vertex\\n\\n\\t\\t\\t\\tv = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );\\n\\n\\t\\t\\t\\tx = Math.sin( v ) * r;\\n\\t\\t\\t\\tz = Math.cos( v ) * r;\\n\\n\\t\\t\\t\\tvertices.push( x, 0, z );\\n\\t\\t\\t\\tcolors.push( color.r, color.g, color.b );\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\n\\n\\t\\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\\n\\n\\t\\tLineSegments.call( this, geometry, material );\\n\\n\\t}\\n\\n\\tPolarGridHelper.prototype = Object.create( LineSegments.prototype );\\n\\tPolarGridHelper.prototype.constructor = PolarGridHelper;\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction FaceNormalsHelper( object, size, hex, linewidth ) {\\n\\n\\t\\t// FaceNormalsHelper only supports THREE.Geometry\\n\\n\\t\\tthis.object = object;\\n\\n\\t\\tthis.size = ( size !== undefined ) ? size : 1;\\n\\n\\t\\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\\n\\n\\t\\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\\n\\n\\t\\t//\\n\\n\\t\\tvar nNormals = 0;\\n\\n\\t\\tvar objGeometry = this.object.geometry;\\n\\n\\t\\tif ( objGeometry && objGeometry.isGeometry ) {\\n\\n\\t\\t\\tnNormals = objGeometry.faces.length;\\n\\n\\t\\t} else {\\n\\n\\t\\t\\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\\n\\n\\t\\t}\\n\\n\\t\\t//\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\tvar positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );\\n\\n\\t\\tgeometry.addAttribute( 'position', positions );\\n\\n\\t\\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );\\n\\n\\t\\t//\\n\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tFaceNormalsHelper.prototype = Object.create( LineSegments.prototype );\\n\\tFaceNormalsHelper.prototype.constructor = FaceNormalsHelper;\\n\\n\\tFaceNormalsHelper.prototype.update = ( function () {\\n\\n\\t\\tvar v1 = new Vector3();\\n\\t\\tvar v2 = new Vector3();\\n\\t\\tvar normalMatrix = new Matrix3();\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tthis.object.updateMatrixWorld( true );\\n\\n\\t\\t\\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\\n\\n\\t\\t\\tvar matrixWorld = this.object.matrixWorld;\\n\\n\\t\\t\\tvar position = this.geometry.attributes.position;\\n\\n\\t\\t\\t//\\n\\n\\t\\t\\tvar objGeometry = this.object.geometry;\\n\\n\\t\\t\\tvar vertices = objGeometry.vertices;\\n\\n\\t\\t\\tvar faces = objGeometry.faces;\\n\\n\\t\\t\\tvar idx = 0;\\n\\n\\t\\t\\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar face = faces[ i ];\\n\\n\\t\\t\\t\\tvar normal = face.normal;\\n\\n\\t\\t\\t\\tv1.copy( vertices[ face.a ] )\\n\\t\\t\\t\\t\\t.add( vertices[ face.b ] )\\n\\t\\t\\t\\t\\t.add( vertices[ face.c ] )\\n\\t\\t\\t\\t\\t.divideScalar( 3 )\\n\\t\\t\\t\\t\\t.applyMatrix4( matrixWorld );\\n\\n\\t\\t\\t\\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\\n\\n\\t\\t\\t\\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\\n\\n\\t\\t\\t\\tidx = idx + 1;\\n\\n\\t\\t\\t\\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\\n\\n\\t\\t\\t\\tidx = idx + 1;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tposition.needsUpdate = true;\\n\\n\\t\\t};\\n\\n\\t}() );\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction DirectionalLightHelper( light, size, color ) {\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tthis.light = light;\\n\\t\\tthis.light.updateMatrixWorld();\\n\\n\\t\\tthis.matrix = light.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.color = color;\\n\\n\\t\\tif ( size === undefined ) size = 1;\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( [\\n\\t\\t\\t- size, size, 0,\\n\\t\\t\\tsize, size, 0,\\n\\t\\t\\tsize, - size, 0,\\n\\t\\t\\t- size, - size, 0,\\n\\t\\t\\t- size, size, 0\\n\\t\\t], 3 ) );\\n\\n\\t\\tvar material = new LineBasicMaterial( { fog: false } );\\n\\n\\t\\tthis.lightPlane = new Line( geometry, material );\\n\\t\\tthis.add( this.lightPlane );\\n\\n\\t\\tgeometry = new BufferGeometry();\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\\n\\n\\t\\tthis.targetLine = new Line( geometry, material );\\n\\t\\tthis.add( this.targetLine );\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tDirectionalLightHelper.prototype = Object.create( Object3D.prototype );\\n\\tDirectionalLightHelper.prototype.constructor = DirectionalLightHelper;\\n\\n\\tDirectionalLightHelper.prototype.dispose = function () {\\n\\n\\t\\tthis.lightPlane.geometry.dispose();\\n\\t\\tthis.lightPlane.material.dispose();\\n\\t\\tthis.targetLine.geometry.dispose();\\n\\t\\tthis.targetLine.material.dispose();\\n\\n\\t};\\n\\n\\tDirectionalLightHelper.prototype.update = function () {\\n\\n\\t\\tvar v1 = new Vector3();\\n\\t\\tvar v2 = new Vector3();\\n\\t\\tvar v3 = new Vector3();\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tv1.setFromMatrixPosition( this.light.matrixWorld );\\n\\t\\t\\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\\n\\t\\t\\tv3.subVectors( v2, v1 );\\n\\n\\t\\t\\tthis.lightPlane.lookAt( v3 );\\n\\n\\t\\t\\tif ( this.color !== undefined ) {\\n\\n\\t\\t\\t\\tthis.lightPlane.material.color.set( this.color );\\n\\t\\t\\t\\tthis.targetLine.material.color.set( this.color );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\tthis.lightPlane.material.color.copy( this.light.color );\\n\\t\\t\\t\\tthis.targetLine.material.color.copy( this.light.color );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tthis.targetLine.lookAt( v3 );\\n\\t\\t\\tthis.targetLine.scale.z = v3.length();\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t * @author Mugen87 / https://github.com/Mugen87\\n\\t *\\n\\t *\\t- shows frustum, line of sight and up of the camera\\n\\t *\\t- suitable for fast updates\\n\\t * \\t- based on frustum visualization in lightgl.js shadowmap example\\n\\t *\\t\\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\\n\\t */\\n\\n\\tfunction CameraHelper( camera ) {\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tvar material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );\\n\\n\\t\\tvar vertices = [];\\n\\t\\tvar colors = [];\\n\\n\\t\\tvar pointMap = {};\\n\\n\\t\\t// colors\\n\\n\\t\\tvar colorFrustum = new Color( 0xffaa00 );\\n\\t\\tvar colorCone = new Color( 0xff0000 );\\n\\t\\tvar colorUp = new Color( 0x00aaff );\\n\\t\\tvar colorTarget = new Color( 0xffffff );\\n\\t\\tvar colorCross = new Color( 0x333333 );\\n\\n\\t\\t// near\\n\\n\\t\\taddLine( 'n1', 'n2', colorFrustum );\\n\\t\\taddLine( 'n2', 'n4', colorFrustum );\\n\\t\\taddLine( 'n4', 'n3', colorFrustum );\\n\\t\\taddLine( 'n3', 'n1', colorFrustum );\\n\\n\\t\\t// far\\n\\n\\t\\taddLine( 'f1', 'f2', colorFrustum );\\n\\t\\taddLine( 'f2', 'f4', colorFrustum );\\n\\t\\taddLine( 'f4', 'f3', colorFrustum );\\n\\t\\taddLine( 'f3', 'f1', colorFrustum );\\n\\n\\t\\t// sides\\n\\n\\t\\taddLine( 'n1', 'f1', colorFrustum );\\n\\t\\taddLine( 'n2', 'f2', colorFrustum );\\n\\t\\taddLine( 'n3', 'f3', colorFrustum );\\n\\t\\taddLine( 'n4', 'f4', colorFrustum );\\n\\n\\t\\t// cone\\n\\n\\t\\taddLine( 'p', 'n1', colorCone );\\n\\t\\taddLine( 'p', 'n2', colorCone );\\n\\t\\taddLine( 'p', 'n3', colorCone );\\n\\t\\taddLine( 'p', 'n4', colorCone );\\n\\n\\t\\t// up\\n\\n\\t\\taddLine( 'u1', 'u2', colorUp );\\n\\t\\taddLine( 'u2', 'u3', colorUp );\\n\\t\\taddLine( 'u3', 'u1', colorUp );\\n\\n\\t\\t// target\\n\\n\\t\\taddLine( 'c', 't', colorTarget );\\n\\t\\taddLine( 'p', 'c', colorCross );\\n\\n\\t\\t// cross\\n\\n\\t\\taddLine( 'cn1', 'cn2', colorCross );\\n\\t\\taddLine( 'cn3', 'cn4', colorCross );\\n\\n\\t\\taddLine( 'cf1', 'cf2', colorCross );\\n\\t\\taddLine( 'cf3', 'cf4', colorCross );\\n\\n\\t\\tfunction addLine( a, b, color ) {\\n\\n\\t\\t\\taddPoint( a, color );\\n\\t\\t\\taddPoint( b, color );\\n\\n\\t\\t}\\n\\n\\t\\tfunction addPoint( id, color ) {\\n\\n\\t\\t\\tvertices.push( 0, 0, 0 );\\n\\t\\t\\tcolors.push( color.r, color.g, color.b );\\n\\n\\t\\t\\tif ( pointMap[ id ] === undefined ) {\\n\\n\\t\\t\\t\\tpointMap[ id ] = [];\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tpointMap[ id ].push( ( vertices.length / 3 ) - 1 );\\n\\n\\t\\t}\\n\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\n\\n\\t\\tLineSegments.call( this, geometry, material );\\n\\n\\t\\tthis.camera = camera;\\n\\t\\tif ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();\\n\\n\\t\\tthis.matrix = camera.matrixWorld;\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.pointMap = pointMap;\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tCameraHelper.prototype = Object.create( LineSegments.prototype );\\n\\tCameraHelper.prototype.constructor = CameraHelper;\\n\\n\\tCameraHelper.prototype.update = function () {\\n\\n\\t\\tvar geometry, pointMap;\\n\\n\\t\\tvar vector = new Vector3();\\n\\t\\tvar camera = new Camera();\\n\\n\\t\\tfunction setPoint( point, x, y, z ) {\\n\\n\\t\\t\\tvector.set( x, y, z ).unproject( camera );\\n\\n\\t\\t\\tvar points = pointMap[ point ];\\n\\n\\t\\t\\tif ( points !== undefined ) {\\n\\n\\t\\t\\t\\tvar position = geometry.getAttribute( 'position' );\\n\\n\\t\\t\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\t\\tposition.setXYZ( points[ i ], vector.x, vector.y, vector.z );\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn function update() {\\n\\n\\t\\t\\tgeometry = this.geometry;\\n\\t\\t\\tpointMap = this.pointMap;\\n\\n\\t\\t\\tvar w = 1, h = 1;\\n\\n\\t\\t\\t// we need just camera projection matrix\\n\\t\\t\\t// world matrix must be identity\\n\\n\\t\\t\\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\\n\\n\\t\\t\\t// center / target\\n\\n\\t\\t\\tsetPoint( 'c', 0, 0, - 1 );\\n\\t\\t\\tsetPoint( 't', 0, 0, 1 );\\n\\n\\t\\t\\t// near\\n\\n\\t\\t\\tsetPoint( 'n1', - w, - h, - 1 );\\n\\t\\t\\tsetPoint( 'n2', w, - h, - 1 );\\n\\t\\t\\tsetPoint( 'n3', - w, h, - 1 );\\n\\t\\t\\tsetPoint( 'n4', w, h, - 1 );\\n\\n\\t\\t\\t// far\\n\\n\\t\\t\\tsetPoint( 'f1', - w, - h, 1 );\\n\\t\\t\\tsetPoint( 'f2', w, - h, 1 );\\n\\t\\t\\tsetPoint( 'f3', - w, h, 1 );\\n\\t\\t\\tsetPoint( 'f4', w, h, 1 );\\n\\n\\t\\t\\t// up\\n\\n\\t\\t\\tsetPoint( 'u1', w * 0.7, h * 1.1, - 1 );\\n\\t\\t\\tsetPoint( 'u2', - w * 0.7, h * 1.1, - 1 );\\n\\t\\t\\tsetPoint( 'u3', 0, h * 2, - 1 );\\n\\n\\t\\t\\t// cross\\n\\n\\t\\t\\tsetPoint( 'cf1', - w, 0, 1 );\\n\\t\\t\\tsetPoint( 'cf2', w, 0, 1 );\\n\\t\\t\\tsetPoint( 'cf3', 0, - h, 1 );\\n\\t\\t\\tsetPoint( 'cf4', 0, h, 1 );\\n\\n\\t\\t\\tsetPoint( 'cn1', - w, 0, - 1 );\\n\\t\\t\\tsetPoint( 'cn2', w, 0, - 1 );\\n\\t\\t\\tsetPoint( 'cn3', 0, - h, - 1 );\\n\\t\\t\\tsetPoint( 'cn4', 0, h, - 1 );\\n\\n\\t\\t\\tgeometry.getAttribute( 'position' ).needsUpdate = true;\\n\\n\\t\\t};\\n\\n\\t}();\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t * @author Mugen87 / http://github.com/Mugen87\\n\\t */\\n\\n\\tfunction BoxHelper( object, color ) {\\n\\n\\t\\tthis.object = object;\\n\\n\\t\\tif ( color === undefined ) color = 0xffff00;\\n\\n\\t\\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\\n\\t\\tvar positions = new Float32Array( 8 * 3 );\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\\n\\t\\tgeometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );\\n\\n\\t\\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\\n\\n\\t\\tthis.matrixAutoUpdate = false;\\n\\n\\t\\tthis.update();\\n\\n\\t}\\n\\n\\tBoxHelper.prototype = Object.create( LineSegments.prototype );\\n\\tBoxHelper.prototype.constructor = BoxHelper;\\n\\n\\tBoxHelper.prototype.update = ( function () {\\n\\n\\t\\tvar box = new Box3();\\n\\n\\t\\treturn function update( object ) {\\n\\n\\t\\t\\tif ( object !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( this.object !== undefined ) {\\n\\n\\t\\t\\t\\tbox.setFromObject( this.object );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( box.isEmpty() ) return;\\n\\n\\t\\t\\tvar min = box.min;\\n\\t\\t\\tvar max = box.max;\\n\\n\\t\\t\\t/*\\n\\t\\t\\t  5____4\\n\\t\\t\\t1/___0/|\\n\\t\\t\\t| 6__|_7\\n\\t\\t\\t2/___3/\\n\\n\\t\\t\\t0: max.x, max.y, max.z\\n\\t\\t\\t1: min.x, max.y, max.z\\n\\t\\t\\t2: min.x, min.y, max.z\\n\\t\\t\\t3: max.x, min.y, max.z\\n\\t\\t\\t4: max.x, max.y, min.z\\n\\t\\t\\t5: min.x, max.y, min.z\\n\\t\\t\\t6: min.x, min.y, min.z\\n\\t\\t\\t7: max.x, min.y, min.z\\n\\t\\t\\t*/\\n\\n\\t\\t\\tvar position = this.geometry.attributes.position;\\n\\t\\t\\tvar array = position.array;\\n\\n\\t\\t\\tarray[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;\\n\\t\\t\\tarray[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;\\n\\t\\t\\tarray[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;\\n\\t\\t\\tarray[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\\n\\t\\t\\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\\n\\t\\t\\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\\n\\t\\t\\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\\n\\t\\t\\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\\n\\n\\t\\t\\tposition.needsUpdate = true;\\n\\n\\t\\t\\tthis.geometry.computeBoundingSphere();\\n\\n\\t\\t};\\n\\n\\t} )();\\n\\n\\tBoxHelper.prototype.setFromObject = function ( object ) {\\n\\n\\t\\tthis.object = object;\\n\\t\\tthis.update();\\n\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction Box3Helper( box, hex ) {\\n\\n\\t\\tthis.type = 'Box3Helper';\\n\\n\\t\\tthis.box = box;\\n\\n\\t\\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\\n\\n\\t\\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\\n\\n\\t\\tvar positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\n\\t\\tgeometry.setIndex( new BufferAttribute( indices, 1 ) );\\n\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\\n\\n\\t\\tLineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );\\n\\n\\t\\tthis.geometry.computeBoundingSphere();\\n\\n\\t}\\n\\n\\tBox3Helper.prototype = Object.create( LineSegments.prototype );\\n\\tBox3Helper.prototype.constructor = Box3Helper;\\n\\n\\tBox3Helper.prototype.updateMatrixWorld = function ( force ) {\\n\\n\\t\\tvar box = this.box;\\n\\n\\t\\tif ( box.isEmpty() ) return;\\n\\n\\t\\tbox.getCenter( this.position );\\n\\n\\t\\tbox.getSize( this.scale );\\n\\n\\t\\tthis.scale.multiplyScalar( 0.5 );\\n\\n\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t */\\n\\n\\tfunction PlaneHelper( plane, size, hex ) {\\n\\n\\t\\tthis.type = 'PlaneHelper';\\n\\n\\t\\tthis.plane = plane;\\n\\n\\t\\tthis.size = ( size === undefined ) ? 1 : size;\\n\\n\\t\\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\\n\\n\\t\\tvar positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );\\n\\t\\tgeometry.computeBoundingSphere();\\n\\n\\t\\tLine.call( this, geometry, new LineBasicMaterial( { color: color } ) );\\n\\n\\t\\t//\\n\\n\\t\\tvar positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];\\n\\n\\t\\tvar geometry2 = new BufferGeometry();\\n\\t\\tgeometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );\\n\\t\\tgeometry2.computeBoundingSphere();\\n\\n\\t\\tthis.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );\\n\\n\\t}\\n\\n\\tPlaneHelper.prototype = Object.create( Line.prototype );\\n\\tPlaneHelper.prototype.constructor = PlaneHelper;\\n\\n\\tPlaneHelper.prototype.updateMatrixWorld = function ( force ) {\\n\\n\\t\\tvar scale = - this.plane.constant;\\n\\n\\t\\tif ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter\\n\\n\\t\\tthis.scale.set( 0.5 * this.size, 0.5 * this.size, scale );\\n\\n\\t\\tthis.lookAt( this.plane.normal );\\n\\n\\t\\tObject3D.prototype.updateMatrixWorld.call( this, force );\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author WestLangley / http://github.com/WestLangley\\n\\t * @author zz85 / http://github.com/zz85\\n\\t * @author bhouston / http://clara.io\\n\\t *\\n\\t * Creates an arrow for visualizing directions\\n\\t *\\n\\t * Parameters:\\n\\t *  dir - Vector3\\n\\t *  origin - Vector3\\n\\t *  length - Number\\n\\t *  color - color in hex value\\n\\t *  headLength - Number\\n\\t *  headWidth - Number\\n\\t */\\n\\n\\tvar lineGeometry;\\n\\tvar coneGeometry;\\n\\n\\tfunction ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\\n\\n\\t\\t// dir is assumed to be normalized\\n\\n\\t\\tObject3D.call( this );\\n\\n\\t\\tif ( color === undefined ) color = 0xffff00;\\n\\t\\tif ( length === undefined ) length = 1;\\n\\t\\tif ( headLength === undefined ) headLength = 0.2 * length;\\n\\t\\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\\n\\n\\t\\tif ( lineGeometry === undefined ) {\\n\\n\\t\\t\\tlineGeometry = new BufferGeometry();\\n\\t\\t\\tlineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\\n\\n\\t\\t\\tconeGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\\n\\t\\t\\tconeGeometry.translate( 0, - 0.5, 0 );\\n\\n\\t\\t}\\n\\n\\t\\tthis.position.copy( origin );\\n\\n\\t\\tthis.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );\\n\\t\\tthis.line.matrixAutoUpdate = false;\\n\\t\\tthis.add( this.line );\\n\\n\\t\\tthis.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );\\n\\t\\tthis.cone.matrixAutoUpdate = false;\\n\\t\\tthis.add( this.cone );\\n\\n\\t\\tthis.setDirection( dir );\\n\\t\\tthis.setLength( length, headLength, headWidth );\\n\\n\\t}\\n\\n\\tArrowHelper.prototype = Object.create( Object3D.prototype );\\n\\tArrowHelper.prototype.constructor = ArrowHelper;\\n\\n\\tArrowHelper.prototype.setDirection = ( function () {\\n\\n\\t\\tvar axis = new Vector3();\\n\\t\\tvar radians;\\n\\n\\t\\treturn function setDirection( dir ) {\\n\\n\\t\\t\\t// dir is assumed to be normalized\\n\\n\\t\\t\\tif ( dir.y > 0.99999 ) {\\n\\n\\t\\t\\t\\tthis.quaternion.set( 0, 0, 0, 1 );\\n\\n\\t\\t\\t} else if ( dir.y < - 0.99999 ) {\\n\\n\\t\\t\\t\\tthis.quaternion.set( 1, 0, 0, 0 );\\n\\n\\t\\t\\t} else {\\n\\n\\t\\t\\t\\taxis.set( dir.z, 0, - dir.x ).normalize();\\n\\n\\t\\t\\t\\tradians = Math.acos( dir.y );\\n\\n\\t\\t\\t\\tthis.quaternion.setFromAxisAngle( axis, radians );\\n\\n\\t\\t\\t}\\n\\n\\t\\t};\\n\\n\\t}() );\\n\\n\\tArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\\n\\n\\t\\tif ( headLength === undefined ) headLength = 0.2 * length;\\n\\t\\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\\n\\n\\t\\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\\n\\t\\tthis.line.updateMatrix();\\n\\n\\t\\tthis.cone.scale.set( headWidth, headLength, headWidth );\\n\\t\\tthis.cone.position.y = length;\\n\\t\\tthis.cone.updateMatrix();\\n\\n\\t};\\n\\n\\tArrowHelper.prototype.setColor = function ( color ) {\\n\\n\\t\\tthis.line.material.color.copy( color );\\n\\t\\tthis.cone.material.color.copy( color );\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author sroucheray / http://sroucheray.org/\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction AxesHelper( size ) {\\n\\n\\t\\tsize = size || 1;\\n\\n\\t\\tvar vertices = [\\n\\t\\t\\t0, 0, 0,\\tsize, 0, 0,\\n\\t\\t\\t0, 0, 0,\\t0, size, 0,\\n\\t\\t\\t0, 0, 0,\\t0, 0, size\\n\\t\\t];\\n\\n\\t\\tvar colors = [\\n\\t\\t\\t1, 0, 0,\\t1, 0.6, 0,\\n\\t\\t\\t0, 1, 0,\\t0.6, 1, 0,\\n\\t\\t\\t0, 0, 1,\\t0, 0.6, 1\\n\\t\\t];\\n\\n\\t\\tvar geometry = new BufferGeometry();\\n\\t\\tgeometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\\n\\t\\tgeometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );\\n\\n\\t\\tvar material = new LineBasicMaterial( { vertexColors: VertexColors } );\\n\\n\\t\\tLineSegments.call( this, geometry, material );\\n\\n\\t}\\n\\n\\tAxesHelper.prototype = Object.create( LineSegments.prototype );\\n\\tAxesHelper.prototype.constructor = AxesHelper;\\n\\n\\t/**\\n\\t * @author alteredq / http://alteredqualia.com/\\n\\t */\\n\\n\\tvar SceneUtils = {\\n\\n\\t\\tcreateMultiMaterialObject: function ( geometry, materials ) {\\n\\n\\t\\t\\tvar group = new Group();\\n\\n\\t\\t\\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tgroup.add( new Mesh( geometry, materials[ i ] ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn group;\\n\\n\\t\\t},\\n\\n\\t\\tdetach: function ( child, parent, scene ) {\\n\\n\\t\\t\\tchild.applyMatrix( parent.matrixWorld );\\n\\t\\t\\tparent.remove( child );\\n\\t\\t\\tscene.add( child );\\n\\n\\t\\t},\\n\\n\\t\\tattach: function ( child, scene, parent ) {\\n\\n\\t\\t\\tchild.applyMatrix( new Matrix4().getInverse( parent.matrixWorld ) );\\n\\n\\t\\t\\tscene.remove( child );\\n\\t\\t\\tparent.add( child );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t/**\\n\\t * @author mrdoob / http://mrdoob.com/\\n\\t */\\n\\n\\tfunction Face4( a, b, c, d, normal, color, materialIndex ) {\\n\\n\\t\\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\\n\\t\\treturn new Face3( a, b, c, normal, color, materialIndex );\\n\\n\\t}\\n\\n\\tvar LineStrip = 0;\\n\\n\\tvar LinePieces = 1;\\n\\n\\tfunction MeshFaceMaterial( materials ) {\\n\\n\\t\\tconsole.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );\\n\\t\\treturn materials;\\n\\n\\t}\\n\\n\\tfunction MultiMaterial( materials ) {\\n\\n\\t\\tif ( materials === undefined ) materials = [];\\n\\n\\t\\tconsole.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );\\n\\t\\tmaterials.isMultiMaterial = true;\\n\\t\\tmaterials.materials = materials;\\n\\t\\tmaterials.clone = function () {\\n\\n\\t\\t\\treturn materials.slice();\\n\\n\\t\\t};\\n\\t\\treturn materials;\\n\\n\\t}\\n\\n\\tfunction PointCloud( geometry, material ) {\\n\\n\\t\\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\\n\\t\\treturn new Points( geometry, material );\\n\\n\\t}\\n\\n\\tfunction Particle( material ) {\\n\\n\\t\\tconsole.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );\\n\\t\\treturn new Sprite( material );\\n\\n\\t}\\n\\n\\tfunction ParticleSystem( geometry, material ) {\\n\\n\\t\\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\\n\\t\\treturn new Points( geometry, material );\\n\\n\\t}\\n\\n\\tfunction PointCloudMaterial( parameters ) {\\n\\n\\t\\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\\n\\t\\treturn new PointsMaterial( parameters );\\n\\n\\t}\\n\\n\\tfunction ParticleBasicMaterial( parameters ) {\\n\\n\\t\\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\\n\\t\\treturn new PointsMaterial( parameters );\\n\\n\\t}\\n\\n\\tfunction ParticleSystemMaterial( parameters ) {\\n\\n\\t\\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\\n\\t\\treturn new PointsMaterial( parameters );\\n\\n\\t}\\n\\n\\tfunction Vertex( x, y, z ) {\\n\\n\\t\\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\\n\\t\\treturn new Vector3( x, y, z );\\n\\n\\t}\\n\\n\\t//\\n\\n\\tfunction DynamicBufferAttribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\\n\\t\\treturn new BufferAttribute( array, itemSize ).setDynamic( true );\\n\\n\\t}\\n\\n\\tfunction Int8Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );\\n\\t\\treturn new Int8BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Uint8Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );\\n\\t\\treturn new Uint8BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Uint8ClampedAttribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );\\n\\t\\treturn new Uint8ClampedBufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Int16Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );\\n\\t\\treturn new Int16BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Uint16Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );\\n\\t\\treturn new Uint16BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Int32Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );\\n\\t\\treturn new Int32BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Uint32Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );\\n\\t\\treturn new Uint32BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Float32Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );\\n\\t\\treturn new Float32BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\tfunction Float64Attribute( array, itemSize ) {\\n\\n\\t\\tconsole.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );\\n\\t\\treturn new Float64BufferAttribute( array, itemSize );\\n\\n\\t}\\n\\n\\t//\\n\\n\\tCurve.create = function ( construct, getPoint ) {\\n\\n\\t\\tconsole.log( 'THREE.Curve.create() has been deprecated' );\\n\\n\\t\\tconstruct.prototype = Object.create( Curve.prototype );\\n\\t\\tconstruct.prototype.constructor = construct;\\n\\t\\tconstruct.prototype.getPoint = getPoint;\\n\\n\\t\\treturn construct;\\n\\n\\t};\\n\\n\\t//\\n\\n\\tObject.assign( CurvePath.prototype, {\\n\\n\\t\\tcreatePointsGeometry: function ( divisions ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\\n\\n\\t\\t\\t// generate geometry from path points (for Line or Points objects)\\n\\n\\t\\t\\tvar pts = this.getPoints( divisions );\\n\\t\\t\\treturn this.createGeometry( pts );\\n\\n\\t\\t},\\n\\n\\t\\tcreateSpacedPointsGeometry: function ( divisions ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\\n\\n\\t\\t\\t// generate geometry from equidistant sampling along the path\\n\\n\\t\\t\\tvar pts = this.getSpacedPoints( divisions );\\n\\t\\t\\treturn this.createGeometry( pts );\\n\\n\\t\\t},\\n\\n\\t\\tcreateGeometry: function ( points ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );\\n\\n\\t\\t\\tvar geometry = new Geometry();\\n\\n\\t\\t\\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\\n\\n\\t\\t\\t\\tvar point = points[ i ];\\n\\t\\t\\t\\tgeometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn geometry;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.assign( Path.prototype, {\\n\\n\\t\\tfromPoints: function ( points ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );\\n\\t\\t\\tthis.setFromPoints( points );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tfunction ClosedSplineCurve3( points ) {\\n\\n\\t\\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\\n\\n\\t\\tCatmullRomCurve3.call( this, points );\\n\\t\\tthis.type = 'catmullrom';\\n\\t\\tthis.closed = true;\\n\\n\\t}\\n\\n\\tClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\\n\\n\\t//\\n\\n\\tfunction SplineCurve3( points ) {\\n\\n\\t\\tconsole.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );\\n\\n\\t\\tCatmullRomCurve3.call( this, points );\\n\\t\\tthis.type = 'catmullrom';\\n\\n\\t}\\n\\n\\tSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );\\n\\n\\t//\\n\\n\\tfunction Spline( points ) {\\n\\n\\t\\tconsole.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );\\n\\n\\t\\tCatmullRomCurve3.call( this, points );\\n\\t\\tthis.type = 'catmullrom';\\n\\n\\t}\\n\\n\\tSpline.prototype = Object.create( CatmullRomCurve3.prototype );\\n\\n\\tObject.assign( Spline.prototype, {\\n\\n\\t\\tinitFromArray: function ( /* a */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Spline: .initFromArray() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tgetControlPointsArray: function ( /* optionalTarget */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );\\n\\n\\t\\t},\\n\\t\\treparametrizeByArcLength: function ( /* samplingCoef */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tfunction AxisHelper( size ) {\\n\\n\\t\\tconsole.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );\\n\\t\\treturn new AxesHelper( size );\\n\\n\\t}\\n\\n\\tfunction BoundingBoxHelper( object, color ) {\\n\\n\\t\\tconsole.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );\\n\\t\\treturn new BoxHelper( object, color );\\n\\n\\t}\\n\\n\\tfunction EdgesHelper( object, hex ) {\\n\\n\\t\\tconsole.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );\\n\\t\\treturn new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\\n\\n\\t}\\n\\n\\tGridHelper.prototype.setColors = function () {\\n\\n\\t\\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\\n\\n\\t};\\n\\n\\tSkeletonHelper.prototype.update = function () {\\n\\n\\t\\tconsole.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );\\n\\n\\t};\\n\\n\\tfunction WireframeHelper( object, hex ) {\\n\\n\\t\\tconsole.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );\\n\\t\\treturn new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );\\n\\n\\t}\\n\\n\\t//\\n\\n\\tObject.assign( Loader.prototype, {\\n\\n\\t\\textractUrlBase: function ( url ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );\\n\\t\\t\\treturn LoaderUtils.extractUrlBase( url );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tfunction XHRLoader( manager ) {\\n\\n\\t\\tconsole.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );\\n\\t\\treturn new FileLoader( manager );\\n\\n\\t}\\n\\n\\tfunction BinaryTextureLoader( manager ) {\\n\\n\\t\\tconsole.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );\\n\\t\\treturn new DataTextureLoader( manager );\\n\\n\\t}\\n\\n\\t//\\n\\n\\tObject.assign( Box2.prototype, {\\n\\n\\t\\tcenter: function ( optionalTarget ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );\\n\\t\\t\\treturn this.getCenter( optionalTarget );\\n\\n\\t\\t},\\n\\t\\tempty: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\\n\\t\\t\\treturn this.isEmpty();\\n\\n\\t\\t},\\n\\t\\tisIntersectionBox: function ( box ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\\n\\t\\t\\treturn this.intersectsBox( box );\\n\\n\\t\\t},\\n\\t\\tsize: function ( optionalTarget ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );\\n\\t\\t\\treturn this.getSize( optionalTarget );\\n\\n\\t\\t}\\n\\t} );\\n\\n\\tObject.assign( Box3.prototype, {\\n\\n\\t\\tcenter: function ( optionalTarget ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );\\n\\t\\t\\treturn this.getCenter( optionalTarget );\\n\\n\\t\\t},\\n\\t\\tempty: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\\n\\t\\t\\treturn this.isEmpty();\\n\\n\\t\\t},\\n\\t\\tisIntersectionBox: function ( box ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\\n\\t\\t\\treturn this.intersectsBox( box );\\n\\n\\t\\t},\\n\\t\\tisIntersectionSphere: function ( sphere ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\\n\\t\\t\\treturn this.intersectsSphere( sphere );\\n\\n\\t\\t},\\n\\t\\tsize: function ( optionalTarget ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );\\n\\t\\t\\treturn this.getSize( optionalTarget );\\n\\n\\t\\t}\\n\\t} );\\n\\n\\tLine3.prototype.center = function ( optionalTarget ) {\\n\\n\\t\\tconsole.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );\\n\\t\\treturn this.getCenter( optionalTarget );\\n\\n\\t};\\n\\n\\tObject.assign( _Math, {\\n\\n\\t\\trandom16: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );\\n\\t\\t\\treturn Math.random();\\n\\n\\t\\t},\\n\\n\\t\\tnearestPowerOfTwo: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );\\n\\t\\t\\treturn _Math.floorPowerOfTwo( value );\\n\\n\\t\\t},\\n\\n\\t\\tnextPowerOfTwo: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );\\n\\t\\t\\treturn _Math.ceilPowerOfTwo( value );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Matrix3.prototype, {\\n\\n\\t\\tflattenToArrayOffset: function ( array, offset ) {\\n\\n\\t\\t\\tconsole.warn( \\\"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\\\" );\\n\\t\\t\\treturn this.toArray( array, offset );\\n\\n\\t\\t},\\n\\t\\tmultiplyVector3: function ( vector ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\\n\\t\\t\\treturn vector.applyMatrix3( this );\\n\\n\\t\\t},\\n\\t\\tmultiplyVector3Array: function ( /* a */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tapplyToBuffer: function ( buffer /*, offset, length */ ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );\\n\\t\\t\\treturn this.applyToBufferAttribute( buffer );\\n\\n\\t\\t},\\n\\t\\tapplyToVector3Array: function ( /* array, offset, length */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Matrix4.prototype, {\\n\\n\\t\\textractPosition: function ( m ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\\n\\t\\t\\treturn this.copyPosition( m );\\n\\n\\t\\t},\\n\\t\\tflattenToArrayOffset: function ( array, offset ) {\\n\\n\\t\\t\\tconsole.warn( \\\"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\\\" );\\n\\t\\t\\treturn this.toArray( array, offset );\\n\\n\\t\\t},\\n\\t\\tgetPosition: function () {\\n\\n\\t\\t\\tvar v1;\\n\\n\\t\\t\\treturn function getPosition() {\\n\\n\\t\\t\\t\\tif ( v1 === undefined ) v1 = new Vector3();\\n\\t\\t\\t\\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\\n\\t\\t\\t\\treturn v1.setFromMatrixColumn( this, 3 );\\n\\n\\t\\t\\t};\\n\\n\\t\\t}(),\\n\\t\\tsetRotationFromQuaternion: function ( q ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\\n\\t\\t\\treturn this.makeRotationFromQuaternion( q );\\n\\n\\t\\t},\\n\\t\\tmultiplyToArray: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tmultiplyVector3: function ( vector ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\\n\\t\\t\\treturn vector.applyMatrix4( this );\\n\\n\\t\\t},\\n\\t\\tmultiplyVector4: function ( vector ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\\n\\t\\t\\treturn vector.applyMatrix4( this );\\n\\n\\t\\t},\\n\\t\\tmultiplyVector3Array: function ( /* a */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );\\n\\n\\t\\t},\\n\\t\\trotateAxis: function ( v ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\\n\\t\\t\\tv.transformDirection( this );\\n\\n\\t\\t},\\n\\t\\tcrossVector: function ( vector ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\\n\\t\\t\\treturn vector.applyMatrix4( this );\\n\\n\\t\\t},\\n\\t\\ttranslate: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\\n\\n\\t\\t},\\n\\t\\trotateX: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\\n\\n\\t\\t},\\n\\t\\trotateY: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\\n\\n\\t\\t},\\n\\t\\trotateZ: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\\n\\n\\t\\t},\\n\\t\\trotateByAxis: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tapplyToBuffer: function ( buffer /*, offset, length */ ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );\\n\\t\\t\\treturn this.applyToBufferAttribute( buffer );\\n\\n\\t\\t},\\n\\t\\tapplyToVector3Array: function ( /* array, offset, length */ ) {\\n\\n\\t\\t\\tconsole.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );\\n\\t\\t\\treturn this.makePerspective( left, right, top, bottom, near, far );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tPlane.prototype.isIntersectionLine = function ( line ) {\\n\\n\\t\\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\\n\\t\\treturn this.intersectsLine( line );\\n\\n\\t};\\n\\n\\tQuaternion.prototype.multiplyVector3 = function ( vector ) {\\n\\n\\t\\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\\n\\t\\treturn vector.applyQuaternion( this );\\n\\n\\t};\\n\\n\\tObject.assign( Ray.prototype, {\\n\\n\\t\\tisIntersectionBox: function ( box ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\\n\\t\\t\\treturn this.intersectsBox( box );\\n\\n\\t\\t},\\n\\t\\tisIntersectionPlane: function ( plane ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\\n\\t\\t\\treturn this.intersectsPlane( plane );\\n\\n\\t\\t},\\n\\t\\tisIntersectionSphere: function ( sphere ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\\n\\t\\t\\treturn this.intersectsSphere( sphere );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Shape.prototype, {\\n\\n\\t\\textractAllPoints: function ( divisions ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );\\n\\t\\t\\treturn this.extractPoints( divisions );\\n\\n\\t\\t},\\n\\t\\textrude: function ( options ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );\\n\\t\\t\\treturn new ExtrudeGeometry( this, options );\\n\\n\\t\\t},\\n\\t\\tmakeGeometry: function ( options ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );\\n\\t\\t\\treturn new ShapeGeometry( this, options );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Vector2.prototype, {\\n\\n\\t\\tfromAttribute: function ( attribute, index, offset ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );\\n\\t\\t\\treturn this.fromBufferAttribute( attribute, index, offset );\\n\\n\\t\\t},\\n\\t\\tdistanceToManhattan: function ( v ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\\n\\t\\t\\treturn this.manhattanDistanceTo( v );\\n\\n\\t\\t},\\n\\t\\tlengthManhattan: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );\\n\\t\\t\\treturn this.manhattanLength();\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Vector3.prototype, {\\n\\n\\t\\tsetEulerFromRotationMatrix: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\\n\\n\\t\\t},\\n\\t\\tsetEulerFromQuaternion: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\\n\\n\\t\\t},\\n\\t\\tgetPositionFromMatrix: function ( m ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\\n\\t\\t\\treturn this.setFromMatrixPosition( m );\\n\\n\\t\\t},\\n\\t\\tgetScaleFromMatrix: function ( m ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\\n\\t\\t\\treturn this.setFromMatrixScale( m );\\n\\n\\t\\t},\\n\\t\\tgetColumnFromMatrix: function ( index, matrix ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\\n\\t\\t\\treturn this.setFromMatrixColumn( matrix, index );\\n\\n\\t\\t},\\n\\t\\tapplyProjection: function ( m ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );\\n\\t\\t\\treturn this.applyMatrix4( m );\\n\\n\\t\\t},\\n\\t\\tfromAttribute: function ( attribute, index, offset ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );\\n\\t\\t\\treturn this.fromBufferAttribute( attribute, index, offset );\\n\\n\\t\\t},\\n\\t\\tdistanceToManhattan: function ( v ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );\\n\\t\\t\\treturn this.manhattanDistanceTo( v );\\n\\n\\t\\t},\\n\\t\\tlengthManhattan: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );\\n\\t\\t\\treturn this.manhattanLength();\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( Vector4.prototype, {\\n\\n\\t\\tfromAttribute: function ( attribute, index, offset ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );\\n\\t\\t\\treturn this.fromBufferAttribute( attribute, index, offset );\\n\\n\\t\\t},\\n\\t\\tlengthManhattan: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );\\n\\t\\t\\treturn this.manhattanLength();\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tGeometry.prototype.computeTangents = function () {\\n\\n\\t\\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\\n\\n\\t};\\n\\n\\tObject.assign( Object3D.prototype, {\\n\\n\\t\\tgetChildByName: function ( name ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\\n\\t\\t\\treturn this.getObjectByName( name );\\n\\n\\t\\t},\\n\\t\\trenderDepth: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\\n\\n\\t\\t},\\n\\t\\ttranslate: function ( distance, axis ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\\n\\t\\t\\treturn this.translateOnAxis( axis, distance );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( Object3D.prototype, {\\n\\n\\t\\teulerOrder: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\\n\\t\\t\\t\\treturn this.rotation.order;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\\n\\t\\t\\t\\tthis.rotation.order = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tuseQuaternion: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( LOD.prototype, {\\n\\n\\t\\tobjects: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\\n\\t\\t\\t\\treturn this.levels;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperty( Skeleton.prototype, 'useVertexTexture', {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );\\n\\n\\t\\t},\\n\\t\\tset: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperty( Curve.prototype, '__arcLengthDivisions', {\\n\\n\\t\\tget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\\n\\t\\t\\treturn this.arcLengthDivisions;\\n\\n\\t\\t},\\n\\t\\tset: function ( value ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );\\n\\t\\t\\tthis.arcLengthDivisions = value;\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tPerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\\n\\n\\t\\tconsole.warn( \\\"THREE.PerspectiveCamera.setLens is deprecated. \\\" +\\n\\t\\t\\t\\t\\\"Use .setFocalLength and .filmGauge for a photographic setup.\\\" );\\n\\n\\t\\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\\n\\t\\tthis.setFocalLength( focalLength );\\n\\n\\t};\\n\\n\\t//\\n\\n\\tObject.defineProperties( Light.prototype, {\\n\\t\\tonlyShadow: {\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraFov: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\\n\\t\\t\\t\\tthis.shadow.camera.fov = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraLeft: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\\n\\t\\t\\t\\tthis.shadow.camera.left = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraRight: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\\n\\t\\t\\t\\tthis.shadow.camera.right = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraTop: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\\n\\t\\t\\t\\tthis.shadow.camera.top = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraBottom: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\\n\\t\\t\\t\\tthis.shadow.camera.bottom = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraNear: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\\n\\t\\t\\t\\tthis.shadow.camera.near = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraFar: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\\n\\t\\t\\t\\tthis.shadow.camera.far = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowCameraVisible: {\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowBias: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\\n\\t\\t\\t\\tthis.shadow.bias = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowDarkness: {\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowMapWidth: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\\n\\t\\t\\t\\tthis.shadow.mapSize.width = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowMapHeight: {\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\\n\\t\\t\\t\\tthis.shadow.mapSize.height = value;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.defineProperties( BufferAttribute.prototype, {\\n\\n\\t\\tlength: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );\\n\\t\\t\\t\\treturn this.array.length;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.assign( BufferGeometry.prototype, {\\n\\n\\t\\taddIndex: function ( index ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\\n\\t\\t\\tthis.setIndex( index );\\n\\n\\t\\t},\\n\\t\\taddDrawCall: function ( start, count, indexOffset ) {\\n\\n\\t\\t\\tif ( indexOffset !== undefined ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\\n\\n\\t\\t\\t}\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\\n\\t\\t\\tthis.addGroup( start, count );\\n\\n\\t\\t},\\n\\t\\tclearDrawCalls: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\\n\\t\\t\\tthis.clearGroups();\\n\\n\\t\\t},\\n\\t\\tcomputeTangents: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tcomputeOffsets: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( BufferGeometry.prototype, {\\n\\n\\t\\tdrawcalls: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\\n\\t\\t\\t\\treturn this.groups;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\toffsets: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\\n\\t\\t\\t\\treturn this.groups;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.defineProperties( Uniform.prototype, {\\n\\n\\t\\tdynamic: {\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tonUpdate: {\\n\\t\\t\\tvalue: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );\\n\\t\\t\\t\\treturn this;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.defineProperties( Material.prototype, {\\n\\n\\t\\twrapAround: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Material: .wrapAround has been removed.' );\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\twrapRGB: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.Material: .wrapRGB has been removed.' );\\n\\t\\t\\t\\treturn new Color();\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\tshading: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );\\n\\t\\t\\t\\tthis.flatShading = ( value === FlatShading );\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( MeshPhongMaterial.prototype, {\\n\\n\\t\\tmetal: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\\n\\t\\t\\t\\treturn false;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( ShaderMaterial.prototype, {\\n\\n\\t\\tderivatives: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\\n\\t\\t\\t\\treturn this.extensions.derivatives;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\\n\\t\\t\\t\\tthis.extensions.derivatives = value;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.assign( WebGLRenderer.prototype, {\\n\\n\\t\\tgetCurrentRenderTarget: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );\\n\\t\\t\\treturn this.getRenderTarget();\\n\\n\\t\\t},\\n\\n\\t\\tgetMaxAnisotropy: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );\\n\\t\\t\\treturn this.capabilities.getMaxAnisotropy();\\n\\n\\t\\t},\\n\\n\\t\\tgetPrecision: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );\\n\\t\\t\\treturn this.capabilities.precision;\\n\\n\\t\\t},\\n\\n\\t\\tresetGLState: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );\\n\\t\\t\\treturn this.state.reset();\\n\\n\\t\\t},\\n\\n\\t\\tsupportsFloatTextures: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\\\'OES_texture_float\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'OES_texture_float' );\\n\\n\\t\\t},\\n\\t\\tsupportsHalfFloatTextures: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\\\'OES_texture_half_float\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'OES_texture_half_float' );\\n\\n\\t\\t},\\n\\t\\tsupportsStandardDerivatives: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\\\'OES_standard_derivatives\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'OES_standard_derivatives' );\\n\\n\\t\\t},\\n\\t\\tsupportsCompressedTextureS3TC: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\\\'WEBGL_compressed_texture_s3tc\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\\n\\n\\t\\t},\\n\\t\\tsupportsCompressedTexturePVRTC: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\\\'WEBGL_compressed_texture_pvrtc\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\\n\\n\\t\\t},\\n\\t\\tsupportsBlendMinMax: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\\\'EXT_blend_minmax\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'EXT_blend_minmax' );\\n\\n\\t\\t},\\n\\t\\tsupportsVertexTextures: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );\\n\\t\\t\\treturn this.capabilities.vertexTextures;\\n\\n\\t\\t},\\n\\t\\tsupportsInstancedArrays: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\\\'ANGLE_instanced_arrays\\\\' ).' );\\n\\t\\t\\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\\n\\n\\t\\t},\\n\\t\\tenableScissorTest: function ( boolean ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\\n\\t\\t\\tthis.setScissorTest( boolean );\\n\\n\\t\\t},\\n\\t\\tinitMaterial: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\\n\\n\\t\\t},\\n\\t\\taddPrePlugin: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\\n\\n\\t\\t},\\n\\t\\taddPostPlugin: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\\n\\n\\t\\t},\\n\\t\\tupdateShadowMap: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( WebGLRenderer.prototype, {\\n\\n\\t\\tshadowMapEnabled: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.shadowMap.enabled;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\\n\\t\\t\\t\\tthis.shadowMap.enabled = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowMapType: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.shadowMap.type;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\\n\\t\\t\\t\\tthis.shadowMap.type = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tshadowMapCullFace: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.shadowMap.cullFace;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\\n\\t\\t\\t\\tthis.shadowMap.cullFace = value;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} );\\n\\n\\tObject.defineProperties( WebGLShadowMap.prototype, {\\n\\n\\t\\tcullFace: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\treturn this.renderReverseSided ? CullFaceFront : CullFaceBack;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( cullFace ) {\\n\\n\\t\\t\\t\\tvar value = ( cullFace !== CullFaceBack );\\n\\t\\t\\t\\tconsole.warn( \\\"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \\\" + value + \\\".\\\" );\\n\\t\\t\\t\\tthis.renderReverseSided = value;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.defineProperties( WebGLRenderTarget.prototype, {\\n\\n\\t\\twrapS: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\\n\\t\\t\\t\\treturn this.texture.wrapS;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\\n\\t\\t\\t\\tthis.texture.wrapS = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\twrapT: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\\n\\t\\t\\t\\treturn this.texture.wrapT;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\\n\\t\\t\\t\\tthis.texture.wrapT = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tmagFilter: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\\n\\t\\t\\t\\treturn this.texture.magFilter;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\\n\\t\\t\\t\\tthis.texture.magFilter = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tminFilter: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\\n\\t\\t\\t\\treturn this.texture.minFilter;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\\n\\t\\t\\t\\tthis.texture.minFilter = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tanisotropy: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\\n\\t\\t\\t\\treturn this.texture.anisotropy;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\\n\\t\\t\\t\\tthis.texture.anisotropy = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\toffset: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\\n\\t\\t\\t\\treturn this.texture.offset;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\\n\\t\\t\\t\\tthis.texture.offset = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\trepeat: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\\n\\t\\t\\t\\treturn this.texture.repeat;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\\n\\t\\t\\t\\tthis.texture.repeat = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tformat: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\\n\\t\\t\\t\\treturn this.texture.format;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\\n\\t\\t\\t\\tthis.texture.format = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\ttype: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\\n\\t\\t\\t\\treturn this.texture.type;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\\n\\t\\t\\t\\tthis.texture.type = value;\\n\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tgenerateMipmaps: {\\n\\t\\t\\tget: function () {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\\n\\t\\t\\t\\treturn this.texture.generateMipmaps;\\n\\n\\t\\t\\t},\\n\\t\\t\\tset: function ( value ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\\n\\t\\t\\t\\tthis.texture.generateMipmaps = value;\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tObject.assign( WebVRManager.prototype, {\\n\\n\\t\\tgetStandingMatrix: function () {\\n\\n\\t\\t\\tconsole.warn( 'THREE.WebVRManager: .getStandingMatrix() has been removed.' );\\n\\n\\t\\t}\\n\\n\\t} );\\n\\n\\tObject.defineProperties( WebVRManager.prototype, {\\n\\n\\t\\tstanding: {\\n\\t\\t\\tset: function ( /* value */ ) {\\n\\n\\t\\t\\t\\tconsole.warn( 'THREE.WebVRManager: .standing has been removed.' );\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t} );\\n\\n\\t//\\n\\n\\tAudio.prototype.load = function ( file ) {\\n\\n\\t\\tconsole.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );\\n\\t\\tvar scope = this;\\n\\t\\tvar audioLoader = new AudioLoader();\\n\\t\\taudioLoader.load( file, function ( buffer ) {\\n\\n\\t\\t\\tscope.setBuffer( buffer );\\n\\n\\t\\t} );\\n\\t\\treturn this;\\n\\n\\t};\\n\\n\\tAudioAnalyser.prototype.getData = function () {\\n\\n\\t\\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\\n\\t\\treturn this.getFrequencyData();\\n\\n\\t};\\n\\n\\t//\\n\\n\\tCubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {\\n\\n\\t\\tconsole.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );\\n\\t\\treturn this.update( renderer, scene );\\n\\n\\t};\\n\\n\\t//\\n\\n\\tvar GeometryUtils = {\\n\\n\\t\\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\\n\\t\\t\\tvar matrix;\\n\\n\\t\\t\\tif ( geometry2.isMesh ) {\\n\\n\\t\\t\\t\\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\\n\\n\\t\\t\\t\\tmatrix = geometry2.matrix;\\n\\t\\t\\t\\tgeometry2 = geometry2.geometry;\\n\\n\\t\\t\\t}\\n\\n\\t\\t\\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\\n\\n\\t\\t},\\n\\n\\t\\tcenter: function ( geometry ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\\n\\t\\t\\treturn geometry.center();\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\tvar ImageUtils = {\\n\\n\\t\\tcrossOrigin: undefined,\\n\\n\\t\\tloadTexture: function ( url, mapping, onLoad, onError ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\\n\\n\\t\\t\\tvar loader = new TextureLoader();\\n\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\n\\t\\t\\tvar texture = loader.load( url, onLoad, undefined, onError );\\n\\n\\t\\t\\tif ( mapping ) texture.mapping = mapping;\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t},\\n\\n\\t\\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\\n\\n\\t\\t\\tvar loader = new CubeTextureLoader();\\n\\t\\t\\tloader.setCrossOrigin( this.crossOrigin );\\n\\n\\t\\t\\tvar texture = loader.load( urls, onLoad, undefined, onError );\\n\\n\\t\\t\\tif ( mapping ) texture.mapping = mapping;\\n\\n\\t\\t\\treturn texture;\\n\\n\\t\\t},\\n\\n\\t\\tloadCompressedTexture: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\\n\\n\\t\\t},\\n\\n\\t\\tloadCompressedTextureCube: function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\\n\\n\\t\\t}\\n\\n\\t};\\n\\n\\t//\\n\\n\\tfunction Projector() {\\n\\n\\t\\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\\n\\n\\t\\tthis.projectVector = function ( vector, camera ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\\n\\t\\t\\tvector.project( camera );\\n\\n\\t\\t};\\n\\n\\t\\tthis.unprojectVector = function ( vector, camera ) {\\n\\n\\t\\t\\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\\n\\t\\t\\tvector.unproject( camera );\\n\\n\\t\\t};\\n\\n\\t\\tthis.pickingRay = function () {\\n\\n\\t\\t\\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\\n\\n\\t\\t};\\n\\n\\t}\\n\\n\\t//\\n\\n\\tfunction CanvasRenderer() {\\n\\n\\t\\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\\n\\n\\t\\tthis.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );\\n\\t\\tthis.clear = function () {};\\n\\t\\tthis.render = function () {};\\n\\t\\tthis.setClearColor = function () {};\\n\\t\\tthis.setSize = function () {};\\n\\n\\t}\\n\\n\\texports.WebGLRenderTargetCube = WebGLRenderTargetCube;\\n\\texports.WebGLRenderTarget = WebGLRenderTarget;\\n\\texports.WebGLRenderer = WebGLRenderer;\\n\\texports.ShaderLib = ShaderLib;\\n\\texports.UniformsLib = UniformsLib;\\n\\texports.UniformsUtils = UniformsUtils;\\n\\texports.ShaderChunk = ShaderChunk;\\n\\texports.FogExp2 = FogExp2;\\n\\texports.Fog = Fog;\\n\\texports.Scene = Scene;\\n\\texports.LensFlare = LensFlare;\\n\\texports.Sprite = Sprite;\\n\\texports.LOD = LOD;\\n\\texports.SkinnedMesh = SkinnedMesh;\\n\\texports.Skeleton = Skeleton;\\n\\texports.Bone = Bone;\\n\\texports.Mesh = Mesh;\\n\\texports.LineSegments = LineSegments;\\n\\texports.LineLoop = LineLoop;\\n\\texports.Line = Line;\\n\\texports.Points = Points;\\n\\texports.Group = Group;\\n\\texports.VideoTexture = VideoTexture;\\n\\texports.DataTexture = DataTexture;\\n\\texports.CompressedTexture = CompressedTexture;\\n\\texports.CubeTexture = CubeTexture;\\n\\texports.CanvasTexture = CanvasTexture;\\n\\texports.DepthTexture = DepthTexture;\\n\\texports.Texture = Texture;\\n\\texports.CompressedTextureLoader = CompressedTextureLoader;\\n\\texports.DataTextureLoader = DataTextureLoader;\\n\\texports.CubeTextureLoader = CubeTextureLoader;\\n\\texports.TextureLoader = TextureLoader;\\n\\texports.ObjectLoader = ObjectLoader;\\n\\texports.MaterialLoader = MaterialLoader;\\n\\texports.BufferGeometryLoader = BufferGeometryLoader;\\n\\texports.DefaultLoadingManager = DefaultLoadingManager;\\n\\texports.LoadingManager = LoadingManager;\\n\\texports.JSONLoader = JSONLoader;\\n\\texports.ImageLoader = ImageLoader;\\n\\texports.ImageBitmapLoader = ImageBitmapLoader;\\n\\texports.FontLoader = FontLoader;\\n\\texports.FileLoader = FileLoader;\\n\\texports.Loader = Loader;\\n\\texports.LoaderUtils = LoaderUtils;\\n\\texports.Cache = Cache;\\n\\texports.AudioLoader = AudioLoader;\\n\\texports.SpotLightShadow = SpotLightShadow;\\n\\texports.SpotLight = SpotLight;\\n\\texports.PointLight = PointLight;\\n\\texports.RectAreaLight = RectAreaLight;\\n\\texports.HemisphereLight = HemisphereLight;\\n\\texports.DirectionalLightShadow = DirectionalLightShadow;\\n\\texports.DirectionalLight = DirectionalLight;\\n\\texports.AmbientLight = AmbientLight;\\n\\texports.LightShadow = LightShadow;\\n\\texports.Light = Light;\\n\\texports.StereoCamera = StereoCamera;\\n\\texports.PerspectiveCamera = PerspectiveCamera;\\n\\texports.OrthographicCamera = OrthographicCamera;\\n\\texports.CubeCamera = CubeCamera;\\n\\texports.ArrayCamera = ArrayCamera;\\n\\texports.Camera = Camera;\\n\\texports.AudioListener = AudioListener;\\n\\texports.PositionalAudio = PositionalAudio;\\n\\texports.AudioContext = AudioContext;\\n\\texports.AudioAnalyser = AudioAnalyser;\\n\\texports.Audio = Audio;\\n\\texports.VectorKeyframeTrack = VectorKeyframeTrack;\\n\\texports.StringKeyframeTrack = StringKeyframeTrack;\\n\\texports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;\\n\\texports.NumberKeyframeTrack = NumberKeyframeTrack;\\n\\texports.ColorKeyframeTrack = ColorKeyframeTrack;\\n\\texports.BooleanKeyframeTrack = BooleanKeyframeTrack;\\n\\texports.PropertyMixer = PropertyMixer;\\n\\texports.PropertyBinding = PropertyBinding;\\n\\texports.KeyframeTrack = KeyframeTrack;\\n\\texports.AnimationUtils = AnimationUtils;\\n\\texports.AnimationObjectGroup = AnimationObjectGroup;\\n\\texports.AnimationMixer = AnimationMixer;\\n\\texports.AnimationClip = AnimationClip;\\n\\texports.Uniform = Uniform;\\n\\texports.InstancedBufferGeometry = InstancedBufferGeometry;\\n\\texports.BufferGeometry = BufferGeometry;\\n\\texports.Geometry = Geometry;\\n\\texports.InterleavedBufferAttribute = InterleavedBufferAttribute;\\n\\texports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;\\n\\texports.InterleavedBuffer = InterleavedBuffer;\\n\\texports.InstancedBufferAttribute = InstancedBufferAttribute;\\n\\texports.Face3 = Face3;\\n\\texports.Object3D = Object3D;\\n\\texports.Raycaster = Raycaster;\\n\\texports.Layers = Layers;\\n\\texports.EventDispatcher = EventDispatcher;\\n\\texports.Clock = Clock;\\n\\texports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;\\n\\texports.LinearInterpolant = LinearInterpolant;\\n\\texports.DiscreteInterpolant = DiscreteInterpolant;\\n\\texports.CubicInterpolant = CubicInterpolant;\\n\\texports.Interpolant = Interpolant;\\n\\texports.Triangle = Triangle;\\n\\texports.Math = _Math;\\n\\texports.Spherical = Spherical;\\n\\texports.Cylindrical = Cylindrical;\\n\\texports.Plane = Plane;\\n\\texports.Frustum = Frustum;\\n\\texports.Sphere = Sphere;\\n\\texports.Ray = Ray;\\n\\texports.Matrix4 = Matrix4;\\n\\texports.Matrix3 = Matrix3;\\n\\texports.Box3 = Box3;\\n\\texports.Box2 = Box2;\\n\\texports.Line3 = Line3;\\n\\texports.Euler = Euler;\\n\\texports.Vector4 = Vector4;\\n\\texports.Vector3 = Vector3;\\n\\texports.Vector2 = Vector2;\\n\\texports.Quaternion = Quaternion;\\n\\texports.Color = Color;\\n\\texports.ImmediateRenderObject = ImmediateRenderObject;\\n\\texports.VertexNormalsHelper = VertexNormalsHelper;\\n\\texports.SpotLightHelper = SpotLightHelper;\\n\\texports.SkeletonHelper = SkeletonHelper;\\n\\texports.PointLightHelper = PointLightHelper;\\n\\texports.RectAreaLightHelper = RectAreaLightHelper;\\n\\texports.HemisphereLightHelper = HemisphereLightHelper;\\n\\texports.GridHelper = GridHelper;\\n\\texports.PolarGridHelper = PolarGridHelper;\\n\\texports.FaceNormalsHelper = FaceNormalsHelper;\\n\\texports.DirectionalLightHelper = DirectionalLightHelper;\\n\\texports.CameraHelper = CameraHelper;\\n\\texports.BoxHelper = BoxHelper;\\n\\texports.Box3Helper = Box3Helper;\\n\\texports.PlaneHelper = PlaneHelper;\\n\\texports.ArrowHelper = ArrowHelper;\\n\\texports.AxesHelper = AxesHelper;\\n\\texports.Shape = Shape;\\n\\texports.Path = Path;\\n\\texports.ShapePath = ShapePath;\\n\\texports.Font = Font;\\n\\texports.CurvePath = CurvePath;\\n\\texports.Curve = Curve;\\n\\texports.ShapeUtils = ShapeUtils;\\n\\texports.SceneUtils = SceneUtils;\\n\\texports.WebGLUtils = WebGLUtils;\\n\\texports.WireframeGeometry = WireframeGeometry;\\n\\texports.ParametricGeometry = ParametricGeometry;\\n\\texports.ParametricBufferGeometry = ParametricBufferGeometry;\\n\\texports.TetrahedronGeometry = TetrahedronGeometry;\\n\\texports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;\\n\\texports.OctahedronGeometry = OctahedronGeometry;\\n\\texports.OctahedronBufferGeometry = OctahedronBufferGeometry;\\n\\texports.IcosahedronGeometry = IcosahedronGeometry;\\n\\texports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;\\n\\texports.DodecahedronGeometry = DodecahedronGeometry;\\n\\texports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;\\n\\texports.PolyhedronGeometry = PolyhedronGeometry;\\n\\texports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;\\n\\texports.TubeGeometry = TubeGeometry;\\n\\texports.TubeBufferGeometry = TubeBufferGeometry;\\n\\texports.TorusKnotGeometry = TorusKnotGeometry;\\n\\texports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;\\n\\texports.TorusGeometry = TorusGeometry;\\n\\texports.TorusBufferGeometry = TorusBufferGeometry;\\n\\texports.TextGeometry = TextGeometry;\\n\\texports.TextBufferGeometry = TextBufferGeometry;\\n\\texports.SphereGeometry = SphereGeometry;\\n\\texports.SphereBufferGeometry = SphereBufferGeometry;\\n\\texports.RingGeometry = RingGeometry;\\n\\texports.RingBufferGeometry = RingBufferGeometry;\\n\\texports.PlaneGeometry = PlaneGeometry;\\n\\texports.PlaneBufferGeometry = PlaneBufferGeometry;\\n\\texports.LatheGeometry = LatheGeometry;\\n\\texports.LatheBufferGeometry = LatheBufferGeometry;\\n\\texports.ShapeGeometry = ShapeGeometry;\\n\\texports.ShapeBufferGeometry = ShapeBufferGeometry;\\n\\texports.ExtrudeGeometry = ExtrudeGeometry;\\n\\texports.ExtrudeBufferGeometry = ExtrudeBufferGeometry;\\n\\texports.EdgesGeometry = EdgesGeometry;\\n\\texports.ConeGeometry = ConeGeometry;\\n\\texports.ConeBufferGeometry = ConeBufferGeometry;\\n\\texports.CylinderGeometry = CylinderGeometry;\\n\\texports.CylinderBufferGeometry = CylinderBufferGeometry;\\n\\texports.CircleGeometry = CircleGeometry;\\n\\texports.CircleBufferGeometry = CircleBufferGeometry;\\n\\texports.BoxGeometry = BoxGeometry;\\n\\texports.BoxBufferGeometry = BoxBufferGeometry;\\n\\texports.ShadowMaterial = ShadowMaterial;\\n\\texports.SpriteMaterial = SpriteMaterial;\\n\\texports.RawShaderMaterial = RawShaderMaterial;\\n\\texports.ShaderMaterial = ShaderMaterial;\\n\\texports.PointsMaterial = PointsMaterial;\\n\\texports.MeshPhysicalMaterial = MeshPhysicalMaterial;\\n\\texports.MeshStandardMaterial = MeshStandardMaterial;\\n\\texports.MeshPhongMaterial = MeshPhongMaterial;\\n\\texports.MeshToonMaterial = MeshToonMaterial;\\n\\texports.MeshNormalMaterial = MeshNormalMaterial;\\n\\texports.MeshLambertMaterial = MeshLambertMaterial;\\n\\texports.MeshDepthMaterial = MeshDepthMaterial;\\n\\texports.MeshDistanceMaterial = MeshDistanceMaterial;\\n\\texports.MeshBasicMaterial = MeshBasicMaterial;\\n\\texports.LineDashedMaterial = LineDashedMaterial;\\n\\texports.LineBasicMaterial = LineBasicMaterial;\\n\\texports.Material = Material;\\n\\texports.Float64BufferAttribute = Float64BufferAttribute;\\n\\texports.Float32BufferAttribute = Float32BufferAttribute;\\n\\texports.Uint32BufferAttribute = Uint32BufferAttribute;\\n\\texports.Int32BufferAttribute = Int32BufferAttribute;\\n\\texports.Uint16BufferAttribute = Uint16BufferAttribute;\\n\\texports.Int16BufferAttribute = Int16BufferAttribute;\\n\\texports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;\\n\\texports.Uint8BufferAttribute = Uint8BufferAttribute;\\n\\texports.Int8BufferAttribute = Int8BufferAttribute;\\n\\texports.BufferAttribute = BufferAttribute;\\n\\texports.ArcCurve = ArcCurve;\\n\\texports.CatmullRomCurve3 = CatmullRomCurve3;\\n\\texports.CubicBezierCurve = CubicBezierCurve;\\n\\texports.CubicBezierCurve3 = CubicBezierCurve3;\\n\\texports.EllipseCurve = EllipseCurve;\\n\\texports.LineCurve = LineCurve;\\n\\texports.LineCurve3 = LineCurve3;\\n\\texports.QuadraticBezierCurve = QuadraticBezierCurve;\\n\\texports.QuadraticBezierCurve3 = QuadraticBezierCurve3;\\n\\texports.SplineCurve = SplineCurve;\\n\\texports.REVISION = REVISION;\\n\\texports.MOUSE = MOUSE;\\n\\texports.CullFaceNone = CullFaceNone;\\n\\texports.CullFaceBack = CullFaceBack;\\n\\texports.CullFaceFront = CullFaceFront;\\n\\texports.CullFaceFrontBack = CullFaceFrontBack;\\n\\texports.FrontFaceDirectionCW = FrontFaceDirectionCW;\\n\\texports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;\\n\\texports.BasicShadowMap = BasicShadowMap;\\n\\texports.PCFShadowMap = PCFShadowMap;\\n\\texports.PCFSoftShadowMap = PCFSoftShadowMap;\\n\\texports.FrontSide = FrontSide;\\n\\texports.BackSide = BackSide;\\n\\texports.DoubleSide = DoubleSide;\\n\\texports.FlatShading = FlatShading;\\n\\texports.SmoothShading = SmoothShading;\\n\\texports.NoColors = NoColors;\\n\\texports.FaceColors = FaceColors;\\n\\texports.VertexColors = VertexColors;\\n\\texports.NoBlending = NoBlending;\\n\\texports.NormalBlending = NormalBlending;\\n\\texports.AdditiveBlending = AdditiveBlending;\\n\\texports.SubtractiveBlending = SubtractiveBlending;\\n\\texports.MultiplyBlending = MultiplyBlending;\\n\\texports.CustomBlending = CustomBlending;\\n\\texports.AddEquation = AddEquation;\\n\\texports.SubtractEquation = SubtractEquation;\\n\\texports.ReverseSubtractEquation = ReverseSubtractEquation;\\n\\texports.MinEquation = MinEquation;\\n\\texports.MaxEquation = MaxEquation;\\n\\texports.ZeroFactor = ZeroFactor;\\n\\texports.OneFactor = OneFactor;\\n\\texports.SrcColorFactor = SrcColorFactor;\\n\\texports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;\\n\\texports.SrcAlphaFactor = SrcAlphaFactor;\\n\\texports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;\\n\\texports.DstAlphaFactor = DstAlphaFactor;\\n\\texports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;\\n\\texports.DstColorFactor = DstColorFactor;\\n\\texports.OneMinusDstColorFactor = OneMinusDstColorFactor;\\n\\texports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;\\n\\texports.NeverDepth = NeverDepth;\\n\\texports.AlwaysDepth = AlwaysDepth;\\n\\texports.LessDepth = LessDepth;\\n\\texports.LessEqualDepth = LessEqualDepth;\\n\\texports.EqualDepth = EqualDepth;\\n\\texports.GreaterEqualDepth = GreaterEqualDepth;\\n\\texports.GreaterDepth = GreaterDepth;\\n\\texports.NotEqualDepth = NotEqualDepth;\\n\\texports.MultiplyOperation = MultiplyOperation;\\n\\texports.MixOperation = MixOperation;\\n\\texports.AddOperation = AddOperation;\\n\\texports.NoToneMapping = NoToneMapping;\\n\\texports.LinearToneMapping = LinearToneMapping;\\n\\texports.ReinhardToneMapping = ReinhardToneMapping;\\n\\texports.Uncharted2ToneMapping = Uncharted2ToneMapping;\\n\\texports.CineonToneMapping = CineonToneMapping;\\n\\texports.UVMapping = UVMapping;\\n\\texports.CubeReflectionMapping = CubeReflectionMapping;\\n\\texports.CubeRefractionMapping = CubeRefractionMapping;\\n\\texports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;\\n\\texports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;\\n\\texports.SphericalReflectionMapping = SphericalReflectionMapping;\\n\\texports.CubeUVReflectionMapping = CubeUVReflectionMapping;\\n\\texports.CubeUVRefractionMapping = CubeUVRefractionMapping;\\n\\texports.RepeatWrapping = RepeatWrapping;\\n\\texports.ClampToEdgeWrapping = ClampToEdgeWrapping;\\n\\texports.MirroredRepeatWrapping = MirroredRepeatWrapping;\\n\\texports.NearestFilter = NearestFilter;\\n\\texports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;\\n\\texports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;\\n\\texports.LinearFilter = LinearFilter;\\n\\texports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;\\n\\texports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;\\n\\texports.UnsignedByteType = UnsignedByteType;\\n\\texports.ByteType = ByteType;\\n\\texports.ShortType = ShortType;\\n\\texports.UnsignedShortType = UnsignedShortType;\\n\\texports.IntType = IntType;\\n\\texports.UnsignedIntType = UnsignedIntType;\\n\\texports.FloatType = FloatType;\\n\\texports.HalfFloatType = HalfFloatType;\\n\\texports.UnsignedShort4444Type = UnsignedShort4444Type;\\n\\texports.UnsignedShort5551Type = UnsignedShort5551Type;\\n\\texports.UnsignedShort565Type = UnsignedShort565Type;\\n\\texports.UnsignedInt248Type = UnsignedInt248Type;\\n\\texports.AlphaFormat = AlphaFormat;\\n\\texports.RGBFormat = RGBFormat;\\n\\texports.RGBAFormat = RGBAFormat;\\n\\texports.LuminanceFormat = LuminanceFormat;\\n\\texports.LuminanceAlphaFormat = LuminanceAlphaFormat;\\n\\texports.RGBEFormat = RGBEFormat;\\n\\texports.DepthFormat = DepthFormat;\\n\\texports.DepthStencilFormat = DepthStencilFormat;\\n\\texports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;\\n\\texports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;\\n\\texports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;\\n\\texports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;\\n\\texports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;\\n\\texports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;\\n\\texports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;\\n\\texports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;\\n\\texports.RGB_ETC1_Format = RGB_ETC1_Format;\\n\\texports.LoopOnce = LoopOnce;\\n\\texports.LoopRepeat = LoopRepeat;\\n\\texports.LoopPingPong = LoopPingPong;\\n\\texports.InterpolateDiscrete = InterpolateDiscrete;\\n\\texports.InterpolateLinear = InterpolateLinear;\\n\\texports.InterpolateSmooth = InterpolateSmooth;\\n\\texports.ZeroCurvatureEnding = ZeroCurvatureEnding;\\n\\texports.ZeroSlopeEnding = ZeroSlopeEnding;\\n\\texports.WrapAroundEnding = WrapAroundEnding;\\n\\texports.TrianglesDrawMode = TrianglesDrawMode;\\n\\texports.TriangleStripDrawMode = TriangleStripDrawMode;\\n\\texports.TriangleFanDrawMode = TriangleFanDrawMode;\\n\\texports.LinearEncoding = LinearEncoding;\\n\\texports.sRGBEncoding = sRGBEncoding;\\n\\texports.GammaEncoding = GammaEncoding;\\n\\texports.RGBEEncoding = RGBEEncoding;\\n\\texports.LogLuvEncoding = LogLuvEncoding;\\n\\texports.RGBM7Encoding = RGBM7Encoding;\\n\\texports.RGBM16Encoding = RGBM16Encoding;\\n\\texports.RGBDEncoding = RGBDEncoding;\\n\\texports.BasicDepthPacking = BasicDepthPacking;\\n\\texports.RGBADepthPacking = RGBADepthPacking;\\n\\texports.CubeGeometry = BoxGeometry;\\n\\texports.Face4 = Face4;\\n\\texports.LineStrip = LineStrip;\\n\\texports.LinePieces = LinePieces;\\n\\texports.MeshFaceMaterial = MeshFaceMaterial;\\n\\texports.MultiMaterial = MultiMaterial;\\n\\texports.PointCloud = PointCloud;\\n\\texports.Particle = Particle;\\n\\texports.ParticleSystem = ParticleSystem;\\n\\texports.PointCloudMaterial = PointCloudMaterial;\\n\\texports.ParticleBasicMaterial = ParticleBasicMaterial;\\n\\texports.ParticleSystemMaterial = ParticleSystemMaterial;\\n\\texports.Vertex = Vertex;\\n\\texports.DynamicBufferAttribute = DynamicBufferAttribute;\\n\\texports.Int8Attribute = Int8Attribute;\\n\\texports.Uint8Attribute = Uint8Attribute;\\n\\texports.Uint8ClampedAttribute = Uint8ClampedAttribute;\\n\\texports.Int16Attribute = Int16Attribute;\\n\\texports.Uint16Attribute = Uint16Attribute;\\n\\texports.Int32Attribute = Int32Attribute;\\n\\texports.Uint32Attribute = Uint32Attribute;\\n\\texports.Float32Attribute = Float32Attribute;\\n\\texports.Float64Attribute = Float64Attribute;\\n\\texports.ClosedSplineCurve3 = ClosedSplineCurve3;\\n\\texports.SplineCurve3 = SplineCurve3;\\n\\texports.Spline = Spline;\\n\\texports.AxisHelper = AxisHelper;\\n\\texports.BoundingBoxHelper = BoundingBoxHelper;\\n\\texports.EdgesHelper = EdgesHelper;\\n\\texports.WireframeHelper = WireframeHelper;\\n\\texports.XHRLoader = XHRLoader;\\n\\texports.BinaryTextureLoader = BinaryTextureLoader;\\n\\texports.GeometryUtils = GeometryUtils;\\n\\texports.ImageUtils = ImageUtils;\\n\\texports.Projector = Projector;\\n\\texports.CanvasRenderer = CanvasRenderer;\\n\\n\\tObject.defineProperty(exports, '__esModule', { value: true });\\n\\n})));\\n\"//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi92ZW5kb3IvdGhyZWUuanM/ZTA2NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwrQ0FBK0MsbU1BQW1NLElBQUksR0FBRyw0QkFBNEIsY0FBYyw2REFBNkQsNkNBQTZDLE9BQU8sNkNBQTZDLGlMQUFpTCxpR0FBaUcsVUFBVSxPQUFPLDhDQUE4Qyx5SUFBeUksdURBQXVELFVBQVUsT0FBTyxxREFBcUQsMkxBQTJMLDRCQUE0QixpRkFBaUYsV0FBVyxTQUFTLEdBQUcsT0FBTywwQ0FBMEMsc0pBQXNKLCtDQUErQyw0REFBNEQsa0ZBQWtGLGFBQWEsMENBQTBDLGdDQUFnQywwQkFBMEIsYUFBYSw4Q0FBOEMsOERBQThELCtDQUErQyxrRkFBa0YsMERBQTBELG1CQUFtQixpQkFBaUIsZUFBZSxhQUFhLDBCQUEwQixZQUFZLFNBQVMsS0FBSyxPQUFPLHVHQUF1RyxpREFBaUQsdURBQXVELG9FQUFvRSwwQ0FBMEMsa0RBQWtELG1DQUFtQyxXQUFXLGdFQUFnRSwrQ0FBK0MsV0FBVyxTQUFTLHdEQUF3RCw0REFBNEQsMENBQTBDLGtHQUFrRyxTQUFTLDJEQUEyRCxzREFBc0QsMENBQTBDLDhDQUE4Qyw4Q0FBOEMsMERBQTBELGtDQUFrQywrQ0FBK0MsYUFBYSxXQUFXLFNBQVMsNENBQTRDLHNEQUFzRCwwQ0FBMEMsb0RBQW9ELDhDQUE4QyxnQ0FBZ0MsaURBQWlELDhDQUE4QyxPQUFPLFNBQVMsNkNBQTZDLGFBQWEsV0FBVyxTQUFTLE9BQU8sR0FBRywwQkFBMEIsaUJBQWlCLGdDQUFnQyx5QkFBeUIseUJBQXlCLDBCQUEwQiw4QkFBOEIsaUNBQWlDLGtDQUFrQywyQkFBMkIseUJBQXlCLDZCQUE2QixzQkFBc0IscUJBQXFCLHVCQUF1Qix3QkFBd0IsMEJBQTBCLHFCQUFxQix1QkFBdUIseUJBQXlCLHVCQUF1QiwyQkFBMkIsNkJBQTZCLGdDQUFnQyw2QkFBNkIsMkJBQTJCLDBCQUEwQiwrQkFBK0Isc0NBQXNDLDBCQUEwQiwwQkFB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QUE4Qiw4Q0FBOEMsa0NBQWtDLDBDQUEwQywwREFBMEQsMERBQTBELHdEQUF3RCxvREFBb0Qsc0NBQXNDLGtDQUFrQyxvQ0FBb0MsOENBQThDLHdEQUF3RCxvQ0FBb0Msc0NBQXNDLG9EQUFvRCx3REFBd0QsMERBQTBELDBEQUEwRCwwREFBMEQsOERBQThELDhEQUE4RCxnRUFBZ0UsZ0VBQWdFLDhDQUE4QyxnQ0FBZ0Msb0NBQW9DLHdDQUF3QyxzREFBc0Qsa0RBQWtELGtEQUFrRCxzREFBc0QsOENBQThDLGdEQUFnRCxrREFBa0QsMERBQTBELHNEQUFzRCw0Q0FBNEMsd0NBQXdDLDBDQUEwQyx3Q0FBd0MsNENBQTRDLDBDQUEwQyw0Q0FBNEMsd0NBQXdDLGtEQUFrRCxnREFBZ0QsdUNBQXVDLDBCQUEwQixrQ0FBa0Msb0NBQW9DLGdEQUFnRCwwQ0FBMEMsb0NBQW9DLGdDQUFnQyw0Q0FBNEMsb0RBQW9ELDBEQUEwRCw0REFBNEQsNEJBQTRCLDREQUE0RCwwQ0FBMEMsNENBQTRDLDBEQUEwRCw0Q0FBNEMsOENBQThDLDRDQUE0Qyw4Q0FBOEMsZ0RBQWdELGdEQUFnRCxvREFBb0Qsd0NBQXdDLDRCQUE0QixvQ0FBb0Msa0RBQWtELHNDQUFzQyw4Q0FBOEMsa0NBQWtDLHNEQUFzRCwwQ0FBMEMsb0NBQW9DLGtDQUFrQyw0Q0FBNEMsb0RBQW9ELGNBQWMsRUFBRSxLQUFLLElBQUkiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEuL3ZlbmRvci90aHJlZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gXCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xcblxcdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoZXhwb3J0cykgOlxcblxcdHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSkgOlxcblxcdChmYWN0b3J5KChnbG9iYWwuVEhSRUUgPSB7fSkpKTtcXG59KHRoaXMsIChmdW5jdGlvbiAoZXhwb3J0cykgeyAndXNlIHN0cmljdCc7XFxuXFxuXFx0Ly8gUG9seWZpbGxzXFxuXFxuXFx0aWYgKCBOdW1iZXIuRVBTSUxPTiA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdE51bWJlci5FUFNJTE9OID0gTWF0aC5wb3coIDIsIC0gNTIgKTtcXG5cXG5cXHR9XFxuXFxuXFx0aWYgKCBOdW1iZXIuaXNJbnRlZ2VyID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0Ly8gTWlzc2luZyBpbiBJRVxcblxcdFxcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL051bWJlci9pc0ludGVnZXJcXG5cXG5cXHRcXHROdW1iZXIuaXNJbnRlZ2VyID0gZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSggdmFsdWUgKSAmJiBNYXRoLmZsb29yKCB2YWx1ZSApID09PSB2YWx1ZTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHQvL1xcblxcblxcdGlmICggTWF0aC5zaWduID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaWduXFxuXFxuXFx0XFx0TWF0aC5zaWduID0gZnVuY3Rpb24gKCB4ICkge1xcblxcblxcdFxcdFxcdHJldHVybiAoIHggPCAwICkgPyAtIDEgOiAoIHggPiAwICkgPyAxIDogKyB4O1xcblxcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdGlmICggJ25hbWUnIGluIEZ1bmN0aW9uLnByb3RvdHlwZSA9PT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0Ly8gTWlzc2luZyBpbiBJRVxcblxcdFxcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL25hbWVcXG5cXG5cXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIEZ1bmN0aW9uLnByb3RvdHlwZSwgJ25hbWUnLCB7XFxuXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMudG9TdHJpbmcoKS5tYXRjaCggL15cXFxccypmdW5jdGlvblxcXFxzKihbXlxcXFwoXFxcXHNdKikvIClbIDEgXTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSApO1xcblxcblxcdH1cXG5cXG5cXHRpZiAoIE9iamVjdC5hc3NpZ24gPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHQvLyBNaXNzaW5nIGluIElFXFxuXFx0XFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnblxcblxcblxcdFxcdCggZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdE9iamVjdC5hc3NpZ24gPSBmdW5jdGlvbiAoIHRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRhcmdldCA9PT0gdW5kZWZpbmVkIHx8IHRhcmdldCA9PT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnQ2Fubm90IGNvbnZlcnQgdW5kZWZpbmVkIG9yIG51bGwgdG8gb2JqZWN0JyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgb3V0cHV0ID0gT2JqZWN0KCB0YXJnZXQgKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4ICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBzb3VyY2UgPSBhcmd1bWVudHNbIGluZGV4IF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBzb3VyY2UgIT09IHVuZGVmaW5lZCAmJiBzb3VyY2UgIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIG5leHRLZXkgaW4gc291cmNlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKCBzb3VyY2UsIG5leHRLZXkgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvdXRwdXRbIG5leHRLZXkgXSA9IHNvdXJjZVsgbmV4dEtleSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gb3V0cHV0O1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSApKCk7XFxuXFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvZXZlbnRkaXNwYXRjaGVyLmpzL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEV2ZW50RGlzcGF0Y2hlcigpIHt9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICggdHlwZSwgbGlzdGVuZXIgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLl9saXN0ZW5lcnMgPT09IHVuZGVmaW5lZCApIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xcblxcblxcdFxcdFxcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XFxuXFxuXFx0XFx0XFx0aWYgKCBsaXN0ZW5lcnNbIHR5cGUgXSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGxpc3RlbmVyc1sgdHlwZSBdID0gW107XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSA9PT0gLSAxICkge1xcblxcblxcdFxcdFxcdFxcdGxpc3RlbmVyc1sgdHlwZSBdLnB1c2goIGxpc3RlbmVyICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0aGFzRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuIGZhbHNlO1xcblxcblxcdFxcdFxcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGxpc3RlbmVyc1sgdHlwZSBdICE9PSB1bmRlZmluZWQgJiYgbGlzdGVuZXJzWyB0eXBlIF0uaW5kZXhPZiggbGlzdGVuZXIgKSAhPT0gLSAxO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gKCB0eXBlLCBsaXN0ZW5lciApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuX2xpc3RlbmVycyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XFxuXFx0XFx0XFx0dmFyIGxpc3RlbmVyQXJyYXkgPSBsaXN0ZW5lcnNbIHR5cGUgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIGxpc3RlbmVyQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgaW5kZXggPSBsaXN0ZW5lckFycmF5LmluZGV4T2YoIGxpc3RlbmVyICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGxpc3RlbmVyQXJyYXkuc3BsaWNlKCBpbmRleCwgMSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAoIGV2ZW50ICkge1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5fbGlzdGVuZXJzID09PSB1bmRlZmluZWQgKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycztcXG5cXHRcXHRcXHR2YXIgbGlzdGVuZXJBcnJheSA9IGxpc3RlbmVyc1sgZXZlbnQudHlwZSBdO1xcblxcblxcdFxcdFxcdGlmICggbGlzdGVuZXJBcnJheSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGV2ZW50LnRhcmdldCA9IHRoaXM7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGFycmF5ID0gbGlzdGVuZXJBcnJheS5zbGljZSggMCApO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YXJyYXlbIGkgXS5jYWxsKCB0aGlzLCBldmVudCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHR2YXIgUkVWSVNJT04gPSAnODknO1xcblxcdHZhciBNT1VTRSA9IHsgTEVGVDogMCwgTUlERExFOiAxLCBSSUdIVDogMiB9O1xcblxcdHZhciBDdWxsRmFjZU5vbmUgPSAwO1xcblxcdHZhciBDdWxsRmFjZUJhY2sgPSAxO1xcblxcdHZhciBDdWxsRmFjZUZyb250ID0gMjtcXG5cXHR2YXIgQ3VsbEZhY2VGcm9udEJhY2sgPSAzO1xcblxcdHZhciBGcm9udEZhY2VEaXJlY3Rpb25DVyA9IDA7XFxuXFx0dmFyIEZyb250RmFjZURpcmVjdGlvbkNDVyA9IDE7XFxuXFx0dmFyIEJhc2ljU2hhZG93TWFwID0gMDtcXG5cXHR2YXIgUENGU2hhZG93TWFwID0gMTtcXG5cXHR2YXIgUENGU29mdFNoYWRvd01hcCA9IDI7XFxuXFx0dmFyIEZyb250U2lkZSA9IDA7XFxuXFx0dmFyIEJhY2tTaWRlID0gMTtcXG5cXHR2YXIgRG91YmxlU2lkZSA9IDI7XFxuXFx0dmFyIEZsYXRTaGFkaW5nID0gMTtcXG5cXHR2YXIgU21vb3RoU2hhZGluZyA9IDI7XFxuXFx0dmFyIE5vQ29sb3JzID0gMDtcXG5cXHR2YXIgRmFjZUNvbG9ycyA9IDE7XFxuXFx0dmFyIFZlcnRleENvbG9ycyA9IDI7XFxuXFx0dmFyIE5vQmxlbmRpbmcgPSAwO1xcblxcdHZhciBOb3JtYWxCbGVuZGluZyA9IDE7XFxuXFx0dmFyIEFkZGl0aXZlQmxlbmRpbmcgPSAyO1xcblxcdHZhciBTdWJ0cmFjdGl2ZUJsZW5kaW5nID0gMztcXG5cXHR2YXIgTXVsdGlwbHlCbGVuZGluZyA9IDQ7XFxuXFx0dmFyIEN1c3RvbUJsZW5kaW5nID0gNTtcXG5cXHR2YXIgQWRkRXF1YXRpb24gPSAxMDA7XFxuXFx0dmFyIFN1YnRyYWN0RXF1YXRpb24gPSAxMDE7XFxuXFx0dmFyIFJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uID0gMTAyO1xcblxcdHZhciBNaW5FcXVhdGlvbiA9IDEwMztcXG5cXHR2YXIgTWF4RXF1YXRpb24gPSAxMDQ7XFxuXFx0dmFyIFplcm9GYWN0b3IgPSAyMDA7XFxuXFx0dmFyIE9uZUZhY3RvciA9IDIwMTtcXG5cXHR2YXIgU3JjQ29sb3JGYWN0b3IgPSAyMDI7XFxuXFx0dmFyIE9uZU1pbnVzU3JjQ29sb3JGYWN0b3IgPSAyMDM7XFxuXFx0dmFyIFNyY0FscGhhRmFjdG9yID0gMjA0O1xcblxcdHZhciBPbmVNaW51c1NyY0FscGhhRmFjdG9yID0gMjA1O1xcblxcdHZhciBEc3RBbHBoYUZhY3RvciA9IDIwNjtcXG5cXHR2YXIgT25lTWludXNEc3RBbHBoYUZhY3RvciA9IDIwNztcXG5cXHR2YXIgRHN0Q29sb3JGYWN0b3IgPSAyMDg7XFxuXFx0dmFyIE9uZU1pbnVzRHN0Q29sb3JGYWN0b3IgPSAyMDk7XFxuXFx0dmFyIFNyY0FscGhhU2F0dXJhdGVGYWN0b3IgPSAyMTA7XFxuXFx0dmFyIE5ldmVyRGVwdGggPSAwO1xcblxcdHZhciBBbHdheXNEZXB0aCA9IDE7XFxuXFx0dmFyIExlc3NEZXB0aCA9IDI7XFxuXFx0dmFyIExlc3NFcXVhbERlcHRoID0gMztcXG5cXHR2YXIgRXF1YWxEZXB0aCA9IDQ7XFxuXFx0dmFyIEdyZWF0ZXJFcXVhbERlcHRoID0gNTtcXG5cXHR2YXIgR3JlYXRlckRlcHRoID0gNjtcXG5cXHR2YXIgTm90RXF1YWxEZXB0aCA9IDc7XFxuXFx0dmFyIE11bHRpcGx5T3BlcmF0aW9uID0gMDtcXG5cXHR2YXIgTWl4T3BlcmF0aW9uID0gMTtcXG5cXHR2YXIgQWRkT3BlcmF0aW9uID0gMjtcXG5cXHR2YXIgTm9Ub25lTWFwcGluZyA9IDA7XFxuXFx0dmFyIExpbmVhclRvbmVNYXBwaW5nID0gMTtcXG5cXHR2YXIgUmVpbmhhcmRUb25lTWFwcGluZyA9IDI7XFxuXFx0dmFyIFVuY2hhcnRlZDJUb25lTWFwcGluZyA9IDM7XFxuXFx0dmFyIENpbmVvblRvbmVNYXBwaW5nID0gNDtcXG5cXHR2YXIgVVZNYXBwaW5nID0gMzAwO1xcblxcdHZhciBDdWJlUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDE7XFxuXFx0dmFyIEN1YmVSZWZyYWN0aW9uTWFwcGluZyA9IDMwMjtcXG5cXHR2YXIgRXF1aXJlY3Rhbmd1bGFyUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDM7XFxuXFx0dmFyIEVxdWlyZWN0YW5ndWxhclJlZnJhY3Rpb25NYXBwaW5nID0gMzA0O1xcblxcdHZhciBTcGhlcmljYWxSZWZsZWN0aW9uTWFwcGluZyA9IDMwNTtcXG5cXHR2YXIgQ3ViZVVWUmVmbGVjdGlvbk1hcHBpbmcgPSAzMDY7XFxuXFx0dmFyIEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nID0gMzA3O1xcblxcdHZhciBSZXBlYXRXcmFwcGluZyA9IDEwMDA7XFxuXFx0dmFyIENsYW1wVG9FZGdlV3JhcHBpbmcgPSAxMDAxO1xcblxcdHZhciBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nID0gMTAwMjtcXG5cXHR2YXIgTmVhcmVzdEZpbHRlciA9IDEwMDM7XFxuXFx0dmFyIE5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyID0gMTAwNDtcXG5cXHR2YXIgTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciA9IDEwMDU7XFxuXFx0dmFyIExpbmVhckZpbHRlciA9IDEwMDY7XFxuXFx0dmFyIExpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIgPSAxMDA3O1xcblxcdHZhciBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXIgPSAxMDA4O1xcblxcdHZhciBVbnNpZ25lZEJ5dGVUeXBlID0gMTAwOTtcXG5cXHR2YXIgQnl0ZVR5cGUgPSAxMDEwO1xcblxcdHZhciBTaG9ydFR5cGUgPSAxMDExO1xcblxcdHZhciBVbnNpZ25lZFNob3J0VHlwZSA9IDEwMTI7XFxuXFx0dmFyIEludFR5cGUgPSAxMDEzO1xcblxcdHZhciBVbnNpZ25lZEludFR5cGUgPSAxMDE0O1xcblxcdHZhciBGbG9hdFR5cGUgPSAxMDE1O1xcblxcdHZhciBIYWxmRmxvYXRUeXBlID0gMTAxNjtcXG5cXHR2YXIgVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gMTAxNztcXG5cXHR2YXIgVW5zaWduZWRTaG9ydDU1NTFUeXBlID0gMTAxODtcXG5cXHR2YXIgVW5zaWduZWRTaG9ydDU2NVR5cGUgPSAxMDE5O1xcblxcdHZhciBVbnNpZ25lZEludDI0OFR5cGUgPSAxMDIwO1xcblxcdHZhciBBbHBoYUZvcm1hdCA9IDEwMjE7XFxuXFx0dmFyIFJHQkZvcm1hdCA9IDEwMjI7XFxuXFx0dmFyIFJHQkFGb3JtYXQgPSAxMDIzO1xcblxcdHZhciBMdW1pbmFuY2VGb3JtYXQgPSAxMDI0O1xcblxcdHZhciBMdW1pbmFuY2VBbHBoYUZvcm1hdCA9IDEwMjU7XFxuXFx0dmFyIFJHQkVGb3JtYXQgPSBSR0JBRm9ybWF0O1xcblxcdHZhciBEZXB0aEZvcm1hdCA9IDEwMjY7XFxuXFx0dmFyIERlcHRoU3RlbmNpbEZvcm1hdCA9IDEwMjc7XFxuXFx0dmFyIFJHQl9TM1RDX0RYVDFfRm9ybWF0ID0gMjAwMTtcXG5cXHR2YXIgUkdCQV9TM1RDX0RYVDFfRm9ybWF0ID0gMjAwMjtcXG5cXHR2YXIgUkdCQV9TM1RDX0RYVDNfRm9ybWF0ID0gMjAwMztcXG5cXHR2YXIgUkdCQV9TM1RDX0RYVDVfRm9ybWF0ID0gMjAwNDtcXG5cXHR2YXIgUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSAyMTAwO1xcblxcdHZhciBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IDIxMDE7XFxuXFx0dmFyIFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCA9IDIxMDI7XFxuXFx0dmFyIFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCA9IDIxMDM7XFxuXFx0dmFyIFJHQl9FVEMxX0Zvcm1hdCA9IDIxNTE7XFxuXFx0dmFyIExvb3BPbmNlID0gMjIwMDtcXG5cXHR2YXIgTG9vcFJlcGVhdCA9IDIyMDE7XFxuXFx0dmFyIExvb3BQaW5nUG9uZyA9IDIyMDI7XFxuXFx0dmFyIEludGVycG9sYXRlRGlzY3JldGUgPSAyMzAwO1xcblxcdHZhciBJbnRlcnBvbGF0ZUxpbmVhciA9IDIzMDE7XFxuXFx0dmFyIEludGVycG9sYXRlU21vb3RoID0gMjMwMjtcXG5cXHR2YXIgWmVyb0N1cnZhdHVyZUVuZGluZyA9IDI0MDA7XFxuXFx0dmFyIFplcm9TbG9wZUVuZGluZyA9IDI0MDE7XFxuXFx0dmFyIFdyYXBBcm91bmRFbmRpbmcgPSAyNDAyO1xcblxcdHZhciBUcmlhbmdsZXNEcmF3TW9kZSA9IDA7XFxuXFx0dmFyIFRyaWFuZ2xlU3RyaXBEcmF3TW9kZSA9IDE7XFxuXFx0dmFyIFRyaWFuZ2xlRmFuRHJhd01vZGUgPSAyO1xcblxcdHZhciBMaW5lYXJFbmNvZGluZyA9IDMwMDA7XFxuXFx0dmFyIHNSR0JFbmNvZGluZyA9IDMwMDE7XFxuXFx0dmFyIEdhbW1hRW5jb2RpbmcgPSAzMDA3O1xcblxcdHZhciBSR0JFRW5jb2RpbmcgPSAzMDAyO1xcblxcdHZhciBMb2dMdXZFbmNvZGluZyA9IDMwMDM7XFxuXFx0dmFyIFJHQk03RW5jb2RpbmcgPSAzMDA0O1xcblxcdHZhciBSR0JNMTZFbmNvZGluZyA9IDMwMDU7XFxuXFx0dmFyIFJHQkRFbmNvZGluZyA9IDMwMDY7XFxuXFx0dmFyIEJhc2ljRGVwdGhQYWNraW5nID0gMzIwMDtcXG5cXHR2YXIgUkdCQURlcHRoUGFja2luZyA9IDMyMDE7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdHZhciBfTWF0aCA9IHtcXG5cXG5cXHRcXHRERUcyUkFEOiBNYXRoLlBJIC8gMTgwLFxcblxcdFxcdFJBRDJERUc6IDE4MCAvIE1hdGguUEksXFxuXFxuXFx0XFx0Z2VuZXJhdGVVVUlEOiAoIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNTAzNC9ob3ctdG8tY3JlYXRlLWEtZ3VpZC11dWlkLWluLWphdmFzY3JpcHQvMjE5NjMxMzYjMjE5NjMxMzZcXG5cXG5cXHRcXHRcXHR2YXIgbHV0ID0gW107XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgMjU2OyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGx1dFsgaSBdID0gKCBpIDwgMTYgPyAnMCcgOiAnJyApICsgKCBpICkudG9TdHJpbmcoIDE2ICkudG9VcHBlckNhc2UoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZDAgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XFxuXFx0XFx0XFx0XFx0dmFyIGQxID0gTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmZmYgfCAwO1xcblxcdFxcdFxcdFxcdHZhciBkMiA9IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZmZmIHwgMDtcXG5cXHRcXHRcXHRcXHR2YXIgZDMgPSBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZiB8IDA7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGx1dFsgZDAgJiAweGZmIF0gKyBsdXRbIGQwID4+IDggJiAweGZmIF0gKyBsdXRbIGQwID4+IDE2ICYgMHhmZiBdICsgbHV0WyBkMCA+PiAyNCAmIDB4ZmYgXSArICctJyArXFxuXFx0XFx0XFx0XFx0XFx0bHV0WyBkMSAmIDB4ZmYgXSArIGx1dFsgZDEgPj4gOCAmIDB4ZmYgXSArICctJyArIGx1dFsgZDEgPj4gMTYgJiAweDBmIHwgMHg0MCBdICsgbHV0WyBkMSA+PiAyNCAmIDB4ZmYgXSArICctJyArXFxuXFx0XFx0XFx0XFx0XFx0bHV0WyBkMiAmIDB4M2YgfCAweDgwIF0gKyBsdXRbIGQyID4+IDggJiAweGZmIF0gKyAnLScgKyBsdXRbIGQyID4+IDE2ICYgMHhmZiBdICsgbHV0WyBkMiA+PiAyNCAmIDB4ZmYgXSArXFxuXFx0XFx0XFx0XFx0XFx0bHV0WyBkMyAmIDB4ZmYgXSArIGx1dFsgZDMgPj4gOCAmIDB4ZmYgXSArIGx1dFsgZDMgPj4gMTYgJiAweGZmIF0gKyBsdXRbIGQzID4+IDI0ICYgMHhmZiBdO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSApKCksXFxuXFxuXFx0XFx0Y2xhbXA6IGZ1bmN0aW9uICggdmFsdWUsIG1pbiwgbWF4ICkge1xcblxcblxcdFxcdFxcdHJldHVybiBNYXRoLm1heCggbWluLCBNYXRoLm1pbiggbWF4LCB2YWx1ZSApICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBjb21wdXRlIGV1Y2xpZGlhbiBtb2R1bG8gb2YgbSAlIG5cXG5cXHRcXHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Nb2R1bG9fb3BlcmF0aW9uXFxuXFxuXFx0XFx0ZXVjbGlkZWFuTW9kdWxvOiBmdW5jdGlvbiAoIG4sIG0gKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuICggKCBuICUgbSApICsgbSApICUgbTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIExpbmVhciBtYXBwaW5nIGZyb20gcmFuZ2UgPGExLCBhMj4gdG8gcmFuZ2UgPGIxLCBiMj5cXG5cXG5cXHRcXHRtYXBMaW5lYXI6IGZ1bmN0aW9uICggeCwgYTEsIGEyLCBiMSwgYjIgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGIxICsgKCB4IC0gYTEgKSAqICggYjIgLSBiMSApIC8gKCBhMiAtIGExICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lYXJfaW50ZXJwb2xhdGlvblxcblxcblxcdFxcdGxlcnA6IGZ1bmN0aW9uICggeCwgeSwgdCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gKCAxIC0gdCApICogeCArIHQgKiB5O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbW9vdGhzdGVwXFxuXFxuXFx0XFx0c21vb3Roc3RlcDogZnVuY3Rpb24gKCB4LCBtaW4sIG1heCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XFxuXFx0XFx0XFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xcblxcblxcdFxcdFxcdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHggKiB4ICogKCAzIC0gMiAqIHggKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNtb290aGVyc3RlcDogZnVuY3Rpb24gKCB4LCBtaW4sIG1heCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHggPD0gbWluICkgcmV0dXJuIDA7XFxuXFx0XFx0XFx0aWYgKCB4ID49IG1heCApIHJldHVybiAxO1xcblxcblxcdFxcdFxcdHggPSAoIHggLSBtaW4gKSAvICggbWF4IC0gbWluICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHggKiB4ICogeCAqICggeCAqICggeCAqIDYgLSAxNSApICsgMTAgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIFJhbmRvbSBpbnRlZ2VyIGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcXG5cXG5cXHRcXHRyYW5kSW50OiBmdW5jdGlvbiAoIGxvdywgaGlnaCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbG93ICsgTWF0aC5mbG9vciggTWF0aC5yYW5kb20oKSAqICggaGlnaCAtIGxvdyArIDEgKSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gUmFuZG9tIGZsb2F0IGZyb20gPGxvdywgaGlnaD4gaW50ZXJ2YWxcXG5cXG5cXHRcXHRyYW5kRmxvYXQ6IGZ1bmN0aW9uICggbG93LCBoaWdoICkge1xcblxcblxcdFxcdFxcdHJldHVybiBsb3cgKyBNYXRoLnJhbmRvbSgpICogKCBoaWdoIC0gbG93ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBSYW5kb20gZmxvYXQgZnJvbSA8LXJhbmdlLzIsIHJhbmdlLzI+IGludGVydmFsXFxuXFxuXFx0XFx0cmFuZEZsb2F0U3ByZWFkOiBmdW5jdGlvbiAoIHJhbmdlICkge1xcblxcblxcdFxcdFxcdHJldHVybiByYW5nZSAqICggMC41IC0gTWF0aC5yYW5kb20oKSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGVnVG9SYWQ6IGZ1bmN0aW9uICggZGVncmVlcyApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZGVncmVlcyAqIF9NYXRoLkRFRzJSQUQ7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyYWRUb0RlZzogZnVuY3Rpb24gKCByYWRpYW5zICkge1xcblxcblxcdFxcdFxcdHJldHVybiByYWRpYW5zICogX01hdGguUkFEMkRFRztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGlzUG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gKCB2YWx1ZSAmICggdmFsdWUgLSAxICkgKSA9PT0gMCAmJiB2YWx1ZSAhPT0gMDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNlaWxQb3dlck9mVHdvOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHJldHVybiBNYXRoLnBvdyggMiwgTWF0aC5jZWlsKCBNYXRoLmxvZyggdmFsdWUgKSAvIE1hdGguTE4yICkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGZsb29yUG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5wb3coIDIsIE1hdGguZmxvb3IoIE1hdGgubG9nKCB2YWx1ZSApIC8gTWF0aC5MTjIgKSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cXG5cXHQgKiBAYXV0aG9yIGVncmFldGhlciAvIGh0dHA6Ly9lZ3JhZXRoZXIuY29tL1xcblxcdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBWZWN0b3IyKCB4LCB5ICkge1xcblxcblxcdFxcdHRoaXMueCA9IHggfHwgMDtcXG5cXHRcXHR0aGlzLnkgPSB5IHx8IDA7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBWZWN0b3IyLnByb3RvdHlwZSwge1xcblxcblxcdFxcdFxcXCJ3aWR0aFxcXCI6IHtcXG5cXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy54O1xcblxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMueCA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdFxcXCJoZWlnaHRcXFwiOiB7XFxuXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMueTtcXG5cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnkgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuYXNzaWduKCBWZWN0b3IyLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGlzVmVjdG9yMjogdHJ1ZSxcXG5cXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSB4O1xcblxcdFxcdFxcdHRoaXMueSA9IHk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IHNjYWxhcjtcXG5cXHRcXHRcXHR0aGlzLnkgPSBzY2FsYXI7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0geDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFk6IGZ1bmN0aW9uICggeSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnkgPSB5O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRzd2l0Y2ggKCBpbmRleCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcXG5cXHRcXHRcXHRcXHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcXG5cXG5cXHRcXHRcXHRzd2l0Y2ggKCBpbmRleCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIDA6IHJldHVybiB0aGlzLng7XFxuXFx0XFx0XFx0XFx0Y2FzZSAxOiByZXR1cm4gdGhpcy55O1xcblxcdFxcdFxcdFxcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gdi54O1xcblxcdFxcdFxcdHRoaXMueSA9IHYueTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xcblxcblxcdFxcdFxcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjI6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLnggKz0gdi54O1xcblxcdFxcdFxcdHRoaXMueSArPSB2Lnk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggKz0gcztcXG5cXHRcXHRcXHR0aGlzLnkgKz0gcztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFkZFZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBhLnggKyBiLng7XFxuXFx0XFx0XFx0dGhpcy55ID0gYS55ICsgYi55O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ICs9IHYueCAqIHM7XFxuXFx0XFx0XFx0dGhpcy55ICs9IHYueSAqIHM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy54IC09IHYueDtcXG5cXHRcXHRcXHR0aGlzLnkgLT0gdi55O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3ViU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54IC09IHM7XFxuXFx0XFx0XFx0dGhpcy55IC09IHM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzdWJWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gYS54IC0gYi54O1xcblxcdFxcdFxcdHRoaXMueSA9IGEueSAtIGIueTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG11bHRpcGx5OiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ICo9IHYueDtcXG5cXHRcXHRcXHR0aGlzLnkgKj0gdi55O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xcblxcblxcdFxcdFxcdHRoaXMueCAqPSBzY2FsYXI7XFxuXFx0XFx0XFx0dGhpcy55ICo9IHNjYWxhcjtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHRoaXMueCAvPSB2Lng7XFxuXFx0XFx0XFx0dGhpcy55IC89IHYueTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRpdmlkZVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubXVsdGlwbHlTY2FsYXIoIDEgLyBzY2FsYXIgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFwcGx5TWF0cml4MzogZnVuY3Rpb24gKCBtICkge1xcblxcblxcdFxcdFxcdHZhciB4ID0gdGhpcy54LCB5ID0gdGhpcy55O1xcblxcdFxcdFxcdHZhciBlID0gbS5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBlWyAwIF0gKiB4ICsgZVsgMyBdICogeSArIGVbIDYgXTtcXG5cXHRcXHRcXHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDcgXTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG1pbjogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IE1hdGgubWluKCB0aGlzLngsIHYueCApO1xcblxcdFxcdFxcdHRoaXMueSA9IE1hdGgubWluKCB0aGlzLnksIHYueSApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWF4OiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gTWF0aC5tYXgoIHRoaXMueCwgdi54ICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gTWF0aC5tYXgoIHRoaXMueSwgdi55ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbGFtcDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcXG5cXG5cXHRcXHRcXHQvLyBhc3N1bWVzIG1pbiA8IG1heCwgY29tcG9uZW50d2lzZVxcblxcblxcdFxcdFxcdHRoaXMueCA9IE1hdGgubWF4KCBtaW4ueCwgTWF0aC5taW4oIG1heC54LCB0aGlzLnggKSApO1xcblxcdFxcdFxcdHRoaXMueSA9IE1hdGgubWF4KCBtaW4ueSwgTWF0aC5taW4oIG1heC55LCB0aGlzLnkgKSApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xhbXBTY2FsYXI6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgbWluID0gbmV3IFZlY3RvcjIoKTtcXG5cXHRcXHRcXHR2YXIgbWF4ID0gbmV3IFZlY3RvcjIoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xcblxcblxcdFxcdFxcdFxcdG1pbi5zZXQoIG1pblZhbCwgbWluVmFsICk7XFxuXFx0XFx0XFx0XFx0bWF4LnNldCggbWF4VmFsLCBtYXhWYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRjbGFtcExlbmd0aDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIGxlbmd0aCB8fCAxICkubXVsdGlwbHlTY2FsYXIoIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGxlbmd0aCApICkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGZsb29yOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjZWlsOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcXG5cXHRcXHRcXHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cm91bmQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBNYXRoLnJvdW5kKCB0aGlzLnggKTtcXG5cXHRcXHRcXHR0aGlzLnkgPSBNYXRoLnJvdW5kKCB0aGlzLnkgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHJvdW5kVG9aZXJvOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gKCB0aGlzLnggPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueCApIDogTWF0aC5mbG9vciggdGhpcy54ICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gKCB0aGlzLnkgPCAwICkgPyBNYXRoLmNlaWwoIHRoaXMueSApIDogTWF0aC5mbG9vciggdGhpcy55ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRuZWdhdGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSAtIHRoaXMueDtcXG5cXHRcXHRcXHR0aGlzLnkgPSAtIHRoaXMueTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRvdDogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLnggKiB2LnggKyB0aGlzLnkgKiB2Lnk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG1hbmhhdHRhbkxlbmd0aDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgfHwgMSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YW5nbGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyBjb21wdXRlcyB0aGUgYW5nbGUgaW4gcmFkaWFucyB3aXRoIHJlc3BlY3QgdG8gdGhlIHBvc2l0aXZlIHgtYXhpc1xcblxcblxcdFxcdFxcdHZhciBhbmdsZSA9IE1hdGguYXRhbjIoIHRoaXMueSwgdGhpcy54ICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBhbmdsZSA8IDAgKSBhbmdsZSArPSAyICogTWF0aC5QSTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYW5nbGU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy5kaXN0YW5jZVRvU3F1YXJlZCggdiApICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXN0YW5jZVRvU3F1YXJlZDogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHZhciBkeCA9IHRoaXMueCAtIHYueCwgZHkgPSB0aGlzLnkgLSB2Lnk7XFxuXFx0XFx0XFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWFuaGF0dGFuRGlzdGFuY2VUbzogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHJldHVybiBNYXRoLmFicyggdGhpcy54IC0gdi54ICkgKyBNYXRoLmFicyggdGhpcy55IC0gdi55ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRMZW5ndGg6IGZ1bmN0aW9uICggbGVuZ3RoICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCBsZW5ndGggKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGxlcnA6IGZ1bmN0aW9uICggdiwgYWxwaGEgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ICs9ICggdi54IC0gdGhpcy54ICkgKiBhbHBoYTtcXG5cXHRcXHRcXHR0aGlzLnkgKz0gKCB2LnkgLSB0aGlzLnkgKSAqIGFscGhhO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bGVycFZlY3RvcnM6IGZ1bmN0aW9uICggdjEsIHYyLCBhbHBoYSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRlcXVhbHM6IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XFxuXFx0XFx0XFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xcblxcdFxcdFxcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xcblxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xcblxcblxcdFxcdFxcdHJldHVybiBhcnJheTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGZyb21CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdGlmICggb2Zmc2V0ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogb2Zmc2V0IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gYXR0cmlidXRlLmdldFgoIGluZGV4ICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gYXR0cmlidXRlLmdldFkoIGluZGV4ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyb3RhdGVBcm91bmQ6IGZ1bmN0aW9uICggY2VudGVyLCBhbmdsZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYyA9IE1hdGguY29zKCBhbmdsZSApLCBzID0gTWF0aC5zaW4oIGFuZ2xlICk7XFxuXFxuXFx0XFx0XFx0dmFyIHggPSB0aGlzLnggLSBjZW50ZXIueDtcXG5cXHRcXHRcXHR2YXIgeSA9IHRoaXMueSAtIGNlbnRlci55O1xcblxcblxcdFxcdFxcdHRoaXMueCA9IHggKiBjIC0geSAqIHMgKyBjZW50ZXIueDtcXG5cXHRcXHRcXHR0aGlzLnkgPSB4ICogcyArIHkgKiBjICsgY2VudGVyLnk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXFxuXFx0ICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cXG5cXHQgKiBAYXV0aG9yIGpvcmRpX3JvcyAvIGh0dHA6Ly9wbGF0dHNvZnQuY29tXFxuXFx0ICogQGF1dGhvciBEMXBsbzFkIC8gaHR0cDovL2dpdGh1Yi5jb20vRDFwbG8xZFxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cXG5cXHQgKiBAYXV0aG9yIHRpbWtuaXAgLyBodHRwOi8vd3d3LmZsb29ycGxhbm5lci5jb20vXFxuXFx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIE1hdHJpeDQoKSB7XFxuXFxuXFx0XFx0dGhpcy5lbGVtZW50cyA9IFtcXG5cXG5cXHRcXHRcXHQxLCAwLCAwLCAwLFxcblxcdFxcdFxcdDAsIDEsIDAsIDAsXFxuXFx0XFx0XFx0MCwgMCwgMSwgMCxcXG5cXHRcXHRcXHQwLCAwLCAwLCAxXFxuXFxuXFx0XFx0XTtcXG5cXG5cXHRcXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAwICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiB0aGUgY29uc3RydWN0b3Igbm8gbG9uZ2VyIHJlYWRzIGFyZ3VtZW50cy4gdXNlIC5zZXQoKSBpbnN0ZWFkLicgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIE1hdHJpeDQucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0aXNNYXRyaXg0OiB0cnVlLFxcblxcblxcdFxcdHNldDogZnVuY3Rpb24gKCBuMTEsIG4xMiwgbjEzLCBuMTQsIG4yMSwgbjIyLCBuMjMsIG4yNCwgbjMxLCBuMzIsIG4zMywgbjM0LCBuNDEsIG40MiwgbjQzLCBuNDQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR0ZVsgMCBdID0gbjExOyB0ZVsgNCBdID0gbjEyOyB0ZVsgOCBdID0gbjEzOyB0ZVsgMTIgXSA9IG4xNDtcXG5cXHRcXHRcXHR0ZVsgMSBdID0gbjIxOyB0ZVsgNSBdID0gbjIyOyB0ZVsgOSBdID0gbjIzOyB0ZVsgMTMgXSA9IG4yNDtcXG5cXHRcXHRcXHR0ZVsgMiBdID0gbjMxOyB0ZVsgNiBdID0gbjMyOyB0ZVsgMTAgXSA9IG4zMzsgdGVbIDE0IF0gPSBuMzQ7XFxuXFx0XFx0XFx0dGVbIDMgXSA9IG40MTsgdGVbIDcgXSA9IG40MjsgdGVbIDExIF0gPSBuNDM7IHRlWyAxNSBdID0gbjQ0O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0aWRlbnRpdHk6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnNldChcXG5cXG5cXHRcXHRcXHRcXHQxLCAwLCAwLCAwLFxcblxcdFxcdFxcdFxcdDAsIDEsIDAsIDAsXFxuXFx0XFx0XFx0XFx0MCwgMCwgMSwgMCxcXG5cXHRcXHRcXHRcXHQwLCAwLCAwLCAxXFxuXFxuXFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBNYXRyaXg0KCkuZnJvbUFycmF5KCB0aGlzLmVsZW1lbnRzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIG0gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXG5cXHRcXHRcXHR2YXIgbWUgPSBtLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHRlWyAwIF0gPSBtZVsgMCBdOyB0ZVsgMSBdID0gbWVbIDEgXTsgdGVbIDIgXSA9IG1lWyAyIF07IHRlWyAzIF0gPSBtZVsgMyBdO1xcblxcdFxcdFxcdHRlWyA0IF0gPSBtZVsgNCBdOyB0ZVsgNSBdID0gbWVbIDUgXTsgdGVbIDYgXSA9IG1lWyA2IF07IHRlWyA3IF0gPSBtZVsgNyBdO1xcblxcdFxcdFxcdHRlWyA4IF0gPSBtZVsgOCBdOyB0ZVsgOSBdID0gbWVbIDkgXTsgdGVbIDEwIF0gPSBtZVsgMTAgXTsgdGVbIDExIF0gPSBtZVsgMTEgXTtcXG5cXHRcXHRcXHR0ZVsgMTIgXSA9IG1lWyAxMiBdOyB0ZVsgMTMgXSA9IG1lWyAxMyBdOyB0ZVsgMTQgXSA9IG1lWyAxNCBdOyB0ZVsgMTUgXSA9IG1lWyAxNSBdO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weVBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cywgbWUgPSBtLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHRlWyAxMiBdID0gbWVbIDEyIF07XFxuXFx0XFx0XFx0dGVbIDEzIF0gPSBtZVsgMTMgXTtcXG5cXHRcXHRcXHR0ZVsgMTQgXSA9IG1lWyAxNCBdO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZXh0cmFjdEJhc2lzOiBmdW5jdGlvbiAoIHhBeGlzLCB5QXhpcywgekF4aXMgKSB7XFxuXFxuXFx0XFx0XFx0eEF4aXMuc2V0RnJvbU1hdHJpeENvbHVtbiggdGhpcywgMCApO1xcblxcdFxcdFxcdHlBeGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIHRoaXMsIDEgKTtcXG5cXHRcXHRcXHR6QXhpcy5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAyICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtYWtlQmFzaXM6IGZ1bmN0aW9uICggeEF4aXMsIHlBeGlzLCB6QXhpcyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnNldChcXG5cXHRcXHRcXHRcXHR4QXhpcy54LCB5QXhpcy54LCB6QXhpcy54LCAwLFxcblxcdFxcdFxcdFxcdHhBeGlzLnksIHlBeGlzLnksIHpBeGlzLnksIDAsXFxuXFx0XFx0XFx0XFx0eEF4aXMueiwgeUF4aXMueiwgekF4aXMueiwgMCxcXG5cXHRcXHRcXHRcXHQwLCAwLCAwLCAxXFxuXFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGV4dHJhY3RSb3RhdGlvbjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGV4dHJhY3RSb3RhdGlvbiggbSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcdFxcdFxcdFxcdHZhciBtZSA9IG0uZWxlbWVudHM7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHNjYWxlWCA9IDEgLyB2MS5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAwICkubGVuZ3RoKCk7XFxuXFx0XFx0XFx0XFx0dmFyIHNjYWxlWSA9IDEgLyB2MS5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAxICkubGVuZ3RoKCk7XFxuXFx0XFx0XFx0XFx0dmFyIHNjYWxlWiA9IDEgLyB2MS5zZXRGcm9tTWF0cml4Q29sdW1uKCBtLCAyICkubGVuZ3RoKCk7XFxuXFxuXFx0XFx0XFx0XFx0dGVbIDAgXSA9IG1lWyAwIF0gKiBzY2FsZVg7XFxuXFx0XFx0XFx0XFx0dGVbIDEgXSA9IG1lWyAxIF0gKiBzY2FsZVg7XFxuXFx0XFx0XFx0XFx0dGVbIDIgXSA9IG1lWyAyIF0gKiBzY2FsZVg7XFxuXFxuXFx0XFx0XFx0XFx0dGVbIDQgXSA9IG1lWyA0IF0gKiBzY2FsZVk7XFxuXFx0XFx0XFx0XFx0dGVbIDUgXSA9IG1lWyA1IF0gKiBzY2FsZVk7XFxuXFx0XFx0XFx0XFx0dGVbIDYgXSA9IG1lWyA2IF0gKiBzY2FsZVk7XFxuXFxuXFx0XFx0XFx0XFx0dGVbIDggXSA9IG1lWyA4IF0gKiBzY2FsZVo7XFxuXFx0XFx0XFx0XFx0dGVbIDkgXSA9IG1lWyA5IF0gKiBzY2FsZVo7XFxuXFx0XFx0XFx0XFx0dGVbIDEwIF0gPSBtZVsgMTAgXSAqIHNjYWxlWjtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRtYWtlUm90YXRpb25Gcm9tRXVsZXI6IGZ1bmN0aW9uICggZXVsZXIgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCAhICggZXVsZXIgJiYgZXVsZXIuaXNFdWxlciApICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAubWFrZVJvdGF0aW9uRnJvbUV1bGVyKCkgbm93IGV4cGVjdHMgYSBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR2YXIgeCA9IGV1bGVyLngsIHkgPSBldWxlci55LCB6ID0gZXVsZXIuejtcXG5cXHRcXHRcXHR2YXIgYSA9IE1hdGguY29zKCB4ICksIGIgPSBNYXRoLnNpbiggeCApO1xcblxcdFxcdFxcdHZhciBjID0gTWF0aC5jb3MoIHkgKSwgZCA9IE1hdGguc2luKCB5ICk7XFxuXFx0XFx0XFx0dmFyIGUgPSBNYXRoLmNvcyggeiApLCBmID0gTWF0aC5zaW4oIHogKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGV1bGVyLm9yZGVyID09PSAnWFlaJyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYWUgPSBhICogZSwgYWYgPSBhICogZiwgYmUgPSBiICogZSwgYmYgPSBiICogZjtcXG5cXG5cXHRcXHRcXHRcXHR0ZVsgMCBdID0gYyAqIGU7XFxuXFx0XFx0XFx0XFx0dGVbIDQgXSA9IC0gYyAqIGY7XFxuXFx0XFx0XFx0XFx0dGVbIDggXSA9IGQ7XFxuXFxuXFx0XFx0XFx0XFx0dGVbIDEgXSA9IGFmICsgYmUgKiBkO1xcblxcdFxcdFxcdFxcdHRlWyA1IF0gPSBhZSAtIGJmICogZDtcXG5cXHRcXHRcXHRcXHR0ZVsgOSBdID0gLSBiICogYztcXG5cXG5cXHRcXHRcXHRcXHR0ZVsgMiBdID0gYmYgLSBhZSAqIGQ7XFxuXFx0XFx0XFx0XFx0dGVbIDYgXSA9IGJlICsgYWYgKiBkO1xcblxcdFxcdFxcdFxcdHRlWyAxMCBdID0gYSAqIGM7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdZWFonICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xcblxcblxcdFxcdFxcdFxcdHRlWyAwIF0gPSBjZSArIGRmICogYjtcXG5cXHRcXHRcXHRcXHR0ZVsgNCBdID0gZGUgKiBiIC0gY2Y7XFxuXFx0XFx0XFx0XFx0dGVbIDggXSA9IGEgKiBkO1xcblxcblxcdFxcdFxcdFxcdHRlWyAxIF0gPSBhICogZjtcXG5cXHRcXHRcXHRcXHR0ZVsgNSBdID0gYSAqIGU7XFxuXFx0XFx0XFx0XFx0dGVbIDkgXSA9IC0gYjtcXG5cXG5cXHRcXHRcXHRcXHR0ZVsgMiBdID0gY2YgKiBiIC0gZGU7XFxuXFx0XFx0XFx0XFx0dGVbIDYgXSA9IGRmICsgY2UgKiBiO1xcblxcdFxcdFxcdFxcdHRlWyAxMCBdID0gYSAqIGM7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggZXVsZXIub3JkZXIgPT09ICdaWFknICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBjZSA9IGMgKiBlLCBjZiA9IGMgKiBmLCBkZSA9IGQgKiBlLCBkZiA9IGQgKiBmO1xcblxcblxcdFxcdFxcdFxcdHRlWyAwIF0gPSBjZSAtIGRmICogYjtcXG5cXHRcXHRcXHRcXHR0ZVsgNCBdID0gLSBhICogZjtcXG5cXHRcXHRcXHRcXHR0ZVsgOCBdID0gZGUgKyBjZiAqIGI7XFxuXFxuXFx0XFx0XFx0XFx0dGVbIDEgXSA9IGNmICsgZGUgKiBiO1xcblxcdFxcdFxcdFxcdHRlWyA1IF0gPSBhICogZTtcXG5cXHRcXHRcXHRcXHR0ZVsgOSBdID0gZGYgLSBjZSAqIGI7XFxuXFxuXFx0XFx0XFx0XFx0dGVbIDIgXSA9IC0gYSAqIGQ7XFxuXFx0XFx0XFx0XFx0dGVbIDYgXSA9IGI7XFxuXFx0XFx0XFx0XFx0dGVbIDEwIF0gPSBhICogYztcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1pZWCcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGFlID0gYSAqIGUsIGFmID0gYSAqIGYsIGJlID0gYiAqIGUsIGJmID0gYiAqIGY7XFxuXFxuXFx0XFx0XFx0XFx0dGVbIDAgXSA9IGMgKiBlO1xcblxcdFxcdFxcdFxcdHRlWyA0IF0gPSBiZSAqIGQgLSBhZjtcXG5cXHRcXHRcXHRcXHR0ZVsgOCBdID0gYWUgKiBkICsgYmY7XFxuXFxuXFx0XFx0XFx0XFx0dGVbIDEgXSA9IGMgKiBmO1xcblxcdFxcdFxcdFxcdHRlWyA1IF0gPSBiZiAqIGQgKyBhZTtcXG5cXHRcXHRcXHRcXHR0ZVsgOSBdID0gYWYgKiBkIC0gYmU7XFxuXFxuXFx0XFx0XFx0XFx0dGVbIDIgXSA9IC0gZDtcXG5cXHRcXHRcXHRcXHR0ZVsgNiBdID0gYiAqIGM7XFxuXFx0XFx0XFx0XFx0dGVbIDEwIF0gPSBhICogYztcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBldWxlci5vcmRlciA9PT0gJ1laWCcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGFjID0gYSAqIGMsIGFkID0gYSAqIGQsIGJjID0gYiAqIGMsIGJkID0gYiAqIGQ7XFxuXFxuXFx0XFx0XFx0XFx0dGVbIDAgXSA9IGMgKiBlO1xcblxcdFxcdFxcdFxcdHRlWyA0IF0gPSBiZCAtIGFjICogZjtcXG5cXHRcXHRcXHRcXHR0ZVsgOCBdID0gYmMgKiBmICsgYWQ7XFxuXFxuXFx0XFx0XFx0XFx0dGVbIDEgXSA9IGY7XFxuXFx0XFx0XFx0XFx0dGVbIDUgXSA9IGEgKiBlO1xcblxcdFxcdFxcdFxcdHRlWyA5IF0gPSAtIGIgKiBlO1xcblxcblxcdFxcdFxcdFxcdHRlWyAyIF0gPSAtIGQgKiBlO1xcblxcdFxcdFxcdFxcdHRlWyA2IF0gPSBhZCAqIGYgKyBiYztcXG5cXHRcXHRcXHRcXHR0ZVsgMTAgXSA9IGFjIC0gYmQgKiBmO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIGV1bGVyLm9yZGVyID09PSAnWFpZJyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYWMgPSBhICogYywgYWQgPSBhICogZCwgYmMgPSBiICogYywgYmQgPSBiICogZDtcXG5cXG5cXHRcXHRcXHRcXHR0ZVsgMCBdID0gYyAqIGU7XFxuXFx0XFx0XFx0XFx0dGVbIDQgXSA9IC0gZjtcXG5cXHRcXHRcXHRcXHR0ZVsgOCBdID0gZCAqIGU7XFxuXFxuXFx0XFx0XFx0XFx0dGVbIDEgXSA9IGFjICogZiArIGJkO1xcblxcdFxcdFxcdFxcdHRlWyA1IF0gPSBhICogZTtcXG5cXHRcXHRcXHRcXHR0ZVsgOSBdID0gYWQgKiBmIC0gYmM7XFxuXFxuXFx0XFx0XFx0XFx0dGVbIDIgXSA9IGJjICogZiAtIGFkO1xcblxcdFxcdFxcdFxcdHRlWyA2IF0gPSBiICogZTtcXG5cXHRcXHRcXHRcXHR0ZVsgMTAgXSA9IGJkICogZiArIGFjO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBsYXN0IGNvbHVtblxcblxcdFxcdFxcdHRlWyAzIF0gPSAwO1xcblxcdFxcdFxcdHRlWyA3IF0gPSAwO1xcblxcdFxcdFxcdHRlWyAxMSBdID0gMDtcXG5cXG5cXHRcXHRcXHQvLyBib3R0b20gcm93XFxuXFx0XFx0XFx0dGVbIDEyIF0gPSAwO1xcblxcdFxcdFxcdHRlWyAxMyBdID0gMDtcXG5cXHRcXHRcXHR0ZVsgMTQgXSA9IDA7XFxuXFx0XFx0XFx0dGVbIDE1IF0gPSAxO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHZhciB4ID0gcS5feCwgeSA9IHEuX3ksIHogPSBxLl96LCB3ID0gcS5fdztcXG5cXHRcXHRcXHR2YXIgeDIgPSB4ICsgeCwgeTIgPSB5ICsgeSwgejIgPSB6ICsgejtcXG5cXHRcXHRcXHR2YXIgeHggPSB4ICogeDIsIHh5ID0geCAqIHkyLCB4eiA9IHggKiB6MjtcXG5cXHRcXHRcXHR2YXIgeXkgPSB5ICogeTIsIHl6ID0geSAqIHoyLCB6eiA9IHogKiB6MjtcXG5cXHRcXHRcXHR2YXIgd3ggPSB3ICogeDIsIHd5ID0gdyAqIHkyLCB3eiA9IHcgKiB6MjtcXG5cXG5cXHRcXHRcXHR0ZVsgMCBdID0gMSAtICggeXkgKyB6eiApO1xcblxcdFxcdFxcdHRlWyA0IF0gPSB4eSAtIHd6O1xcblxcdFxcdFxcdHRlWyA4IF0gPSB4eiArIHd5O1xcblxcblxcdFxcdFxcdHRlWyAxIF0gPSB4eSArIHd6O1xcblxcdFxcdFxcdHRlWyA1IF0gPSAxIC0gKCB4eCArIHp6ICk7XFxuXFx0XFx0XFx0dGVbIDkgXSA9IHl6IC0gd3g7XFxuXFxuXFx0XFx0XFx0dGVbIDIgXSA9IHh6IC0gd3k7XFxuXFx0XFx0XFx0dGVbIDYgXSA9IHl6ICsgd3g7XFxuXFx0XFx0XFx0dGVbIDEwIF0gPSAxIC0gKCB4eCArIHl5ICk7XFxuXFxuXFx0XFx0XFx0Ly8gbGFzdCBjb2x1bW5cXG5cXHRcXHRcXHR0ZVsgMyBdID0gMDtcXG5cXHRcXHRcXHR0ZVsgNyBdID0gMDtcXG5cXHRcXHRcXHR0ZVsgMTEgXSA9IDA7XFxuXFxuXFx0XFx0XFx0Ly8gYm90dG9tIHJvd1xcblxcdFxcdFxcdHRlWyAxMiBdID0gMDtcXG5cXHRcXHRcXHR0ZVsgMTMgXSA9IDA7XFxuXFx0XFx0XFx0dGVbIDE0IF0gPSAwO1xcblxcdFxcdFxcdHRlWyAxNSBdID0gMTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGxvb2tBdDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB4ID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgeSA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIHogPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBsb29rQXQoIGV5ZSwgdGFyZ2V0LCB1cCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdFxcdHouc3ViVmVjdG9ycyggZXllLCB0YXJnZXQgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHoubGVuZ3RoU3EoKSA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBleWUgYW5kIHRhcmdldCBhcmUgaW4gdGhlIHNhbWUgcG9zaXRpb25cXG5cXG5cXHRcXHRcXHRcXHRcXHR6LnogPSAxO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR6Lm5vcm1hbGl6ZSgpO1xcblxcdFxcdFxcdFxcdHguY3Jvc3NWZWN0b3JzKCB1cCwgeiApO1xcblxcblxcdFxcdFxcdFxcdGlmICggeC5sZW5ndGhTcSgpID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHVwIGFuZCB6IGFyZSBwYXJhbGxlbFxcblxcblxcdFxcdFxcdFxcdFxcdGlmICggTWF0aC5hYnMoIHVwLnogKSA9PT0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR6LnggKz0gMC4wMDAxO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ei56ICs9IDAuMDAwMTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0ei5ub3JtYWxpemUoKTtcXG5cXHRcXHRcXHRcXHRcXHR4LmNyb3NzVmVjdG9ycyggdXAsIHogKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0eC5ub3JtYWxpemUoKTtcXG5cXHRcXHRcXHRcXHR5LmNyb3NzVmVjdG9ycyggeiwgeCApO1xcblxcblxcdFxcdFxcdFxcdHRlWyAwIF0gPSB4Lng7IHRlWyA0IF0gPSB5Lng7IHRlWyA4IF0gPSB6Lng7XFxuXFx0XFx0XFx0XFx0dGVbIDEgXSA9IHgueTsgdGVbIDUgXSA9IHkueTsgdGVbIDkgXSA9IHoueTtcXG5cXHRcXHRcXHRcXHR0ZVsgMiBdID0geC56OyB0ZVsgNiBdID0geS56OyB0ZVsgMTAgXSA9IHouejtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRtdWx0aXBseTogZnVuY3Rpb24gKCBtLCBuICkge1xcblxcblxcdFxcdFxcdGlmICggbiAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseSgpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLm11bHRpcGx5TWF0cmljZXMoIGEsIGIgKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5tdWx0aXBseU1hdHJpY2VzKCBtLCBuICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIHRoaXMsIG0gKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHByZW11bHRpcGx5OiBmdW5jdGlvbiAoIG0gKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bXVsdGlwbHlNYXRyaWNlczogZnVuY3Rpb24gKCBhLCBiICkge1xcblxcblxcdFxcdFxcdHZhciBhZSA9IGEuZWxlbWVudHM7XFxuXFx0XFx0XFx0dmFyIGJlID0gYi5lbGVtZW50cztcXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHZhciBhMTEgPSBhZVsgMCBdLCBhMTIgPSBhZVsgNCBdLCBhMTMgPSBhZVsgOCBdLCBhMTQgPSBhZVsgMTIgXTtcXG5cXHRcXHRcXHR2YXIgYTIxID0gYWVbIDEgXSwgYTIyID0gYWVbIDUgXSwgYTIzID0gYWVbIDkgXSwgYTI0ID0gYWVbIDEzIF07XFxuXFx0XFx0XFx0dmFyIGEzMSA9IGFlWyAyIF0sIGEzMiA9IGFlWyA2IF0sIGEzMyA9IGFlWyAxMCBdLCBhMzQgPSBhZVsgMTQgXTtcXG5cXHRcXHRcXHR2YXIgYTQxID0gYWVbIDMgXSwgYTQyID0gYWVbIDcgXSwgYTQzID0gYWVbIDExIF0sIGE0NCA9IGFlWyAxNSBdO1xcblxcblxcdFxcdFxcdHZhciBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgNCBdLCBiMTMgPSBiZVsgOCBdLCBiMTQgPSBiZVsgMTIgXTtcXG5cXHRcXHRcXHR2YXIgYjIxID0gYmVbIDEgXSwgYjIyID0gYmVbIDUgXSwgYjIzID0gYmVbIDkgXSwgYjI0ID0gYmVbIDEzIF07XFxuXFx0XFx0XFx0dmFyIGIzMSA9IGJlWyAyIF0sIGIzMiA9IGJlWyA2IF0sIGIzMyA9IGJlWyAxMCBdLCBiMzQgPSBiZVsgMTQgXTtcXG5cXHRcXHRcXHR2YXIgYjQxID0gYmVbIDMgXSwgYjQyID0gYmVbIDcgXSwgYjQzID0gYmVbIDExIF0sIGI0NCA9IGJlWyAxNSBdO1xcblxcblxcdFxcdFxcdHRlWyAwIF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzEgKyBhMTQgKiBiNDE7XFxuXFx0XFx0XFx0dGVbIDQgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMiArIGExNCAqIGI0MjtcXG5cXHRcXHRcXHR0ZVsgOCBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzICsgYTE0ICogYjQzO1xcblxcdFxcdFxcdHRlWyAxMiBdID0gYTExICogYjE0ICsgYTEyICogYjI0ICsgYTEzICogYjM0ICsgYTE0ICogYjQ0O1xcblxcblxcdFxcdFxcdHRlWyAxIF0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzEgKyBhMjQgKiBiNDE7XFxuXFx0XFx0XFx0dGVbIDUgXSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMiArIGEyNCAqIGI0MjtcXG5cXHRcXHRcXHR0ZVsgOSBdID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xcblxcdFxcdFxcdHRlWyAxMyBdID0gYTIxICogYjE0ICsgYTIyICogYjI0ICsgYTIzICogYjM0ICsgYTI0ICogYjQ0O1xcblxcblxcdFxcdFxcdHRlWyAyIF0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzEgKyBhMzQgKiBiNDE7XFxuXFx0XFx0XFx0dGVbIDYgXSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMiArIGEzNCAqIGI0MjtcXG5cXHRcXHRcXHR0ZVsgMTAgXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0MztcXG5cXHRcXHRcXHR0ZVsgMTQgXSA9IGEzMSAqIGIxNCArIGEzMiAqIGIyNCArIGEzMyAqIGIzNCArIGEzNCAqIGI0NDtcXG5cXG5cXHRcXHRcXHR0ZVsgMyBdID0gYTQxICogYjExICsgYTQyICogYjIxICsgYTQzICogYjMxICsgYTQ0ICogYjQxO1xcblxcdFxcdFxcdHRlWyA3IF0gPSBhNDEgKiBiMTIgKyBhNDIgKiBiMjIgKyBhNDMgKiBiMzIgKyBhNDQgKiBiNDI7XFxuXFx0XFx0XFx0dGVbIDExIF0gPSBhNDEgKiBiMTMgKyBhNDIgKiBiMjMgKyBhNDMgKiBiMzMgKyBhNDQgKiBiNDM7XFxuXFx0XFx0XFx0dGVbIDE1IF0gPSBhNDEgKiBiMTQgKyBhNDIgKiBiMjQgKyBhNDMgKiBiMzQgKyBhNDQgKiBiNDQ7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtdWx0aXBseVNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xcblxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxuXFxuXFx0XFx0XFx0dGVbIDAgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA4IF0gKj0gczsgdGVbIDEyIF0gKj0gcztcXG5cXHRcXHRcXHR0ZVsgMSBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDkgXSAqPSBzOyB0ZVsgMTMgXSAqPSBzO1xcblxcdFxcdFxcdHRlWyAyIF0gKj0gczsgdGVbIDYgXSAqPSBzOyB0ZVsgMTAgXSAqPSBzOyB0ZVsgMTQgXSAqPSBzO1xcblxcdFxcdFxcdHRlWyAzIF0gKj0gczsgdGVbIDcgXSAqPSBzOyB0ZVsgMTEgXSAqPSBzOyB0ZVsgMTUgXSAqPSBzO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YXBwbHlUb0J1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHYxLnggPSBhdHRyaWJ1dGUuZ2V0WCggaSApO1xcblxcdFxcdFxcdFxcdFxcdHYxLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaSApO1xcblxcdFxcdFxcdFxcdFxcdHYxLnogPSBhdHRyaWJ1dGUuZ2V0WiggaSApO1xcblxcblxcdFxcdFxcdFxcdFxcdHYxLmFwcGx5TWF0cml4NCggdGhpcyApO1xcblxcblxcdFxcdFxcdFxcdFxcdGF0dHJpYnV0ZS5zZXRYWVooIGksIHYxLngsIHYxLnksIHYxLnogKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGF0dHJpYnV0ZTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRkZXRlcm1pbmFudDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxuXFxuXFx0XFx0XFx0dmFyIG4xMSA9IHRlWyAwIF0sIG4xMiA9IHRlWyA0IF0sIG4xMyA9IHRlWyA4IF0sIG4xNCA9IHRlWyAxMiBdO1xcblxcdFxcdFxcdHZhciBuMjEgPSB0ZVsgMSBdLCBuMjIgPSB0ZVsgNSBdLCBuMjMgPSB0ZVsgOSBdLCBuMjQgPSB0ZVsgMTMgXTtcXG5cXHRcXHRcXHR2YXIgbjMxID0gdGVbIDIgXSwgbjMyID0gdGVbIDYgXSwgbjMzID0gdGVbIDEwIF0sIG4zNCA9IHRlWyAxNCBdO1xcblxcdFxcdFxcdHZhciBuNDEgPSB0ZVsgMyBdLCBuNDIgPSB0ZVsgNyBdLCBuNDMgPSB0ZVsgMTEgXSwgbjQ0ID0gdGVbIDE1IF07XFxuXFxuXFx0XFx0XFx0Ly9UT0RPOiBtYWtlIHRoaXMgbW9yZSBlZmZpY2llbnRcXG5cXHRcXHRcXHQvLyggYmFzZWQgb24gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9tYXRyaXgvZnVuY3Rpb25zL2ludmVyc2UvZm91ckQvaW5kZXguaHRtIClcXG5cXG5cXHRcXHRcXHRyZXR1cm4gKFxcblxcdFxcdFxcdFxcdG40MSAqIChcXG5cXHRcXHRcXHRcXHRcXHQrIG4xNCAqIG4yMyAqIG4zMlxcblxcdFxcdFxcdFxcdFxcdCAtIG4xMyAqIG4yNCAqIG4zMlxcblxcdFxcdFxcdFxcdFxcdCAtIG4xNCAqIG4yMiAqIG4zM1xcblxcdFxcdFxcdFxcdFxcdCArIG4xMiAqIG4yNCAqIG4zM1xcblxcdFxcdFxcdFxcdFxcdCArIG4xMyAqIG4yMiAqIG4zNFxcblxcdFxcdFxcdFxcdFxcdCAtIG4xMiAqIG4yMyAqIG4zNFxcblxcdFxcdFxcdFxcdCkgK1xcblxcdFxcdFxcdFxcdG40MiAqIChcXG5cXHRcXHRcXHRcXHRcXHQrIG4xMSAqIG4yMyAqIG4zNFxcblxcdFxcdFxcdFxcdFxcdCAtIG4xMSAqIG4yNCAqIG4zM1xcblxcdFxcdFxcdFxcdFxcdCArIG4xNCAqIG4yMSAqIG4zM1xcblxcdFxcdFxcdFxcdFxcdCAtIG4xMyAqIG4yMSAqIG4zNFxcblxcdFxcdFxcdFxcdFxcdCArIG4xMyAqIG4yNCAqIG4zMVxcblxcdFxcdFxcdFxcdFxcdCAtIG4xNCAqIG4yMyAqIG4zMVxcblxcdFxcdFxcdFxcdCkgK1xcblxcdFxcdFxcdFxcdG40MyAqIChcXG5cXHRcXHRcXHRcXHRcXHQrIG4xMSAqIG4yNCAqIG4zMlxcblxcdFxcdFxcdFxcdFxcdCAtIG4xMSAqIG4yMiAqIG4zNFxcblxcdFxcdFxcdFxcdFxcdCAtIG4xNCAqIG4yMSAqIG4zMlxcblxcdFxcdFxcdFxcdFxcdCArIG4xMiAqIG4yMSAqIG4zNFxcblxcdFxcdFxcdFxcdFxcdCArIG4xNCAqIG4yMiAqIG4zMVxcblxcdFxcdFxcdFxcdFxcdCAtIG4xMiAqIG4yNCAqIG4zMVxcblxcdFxcdFxcdFxcdCkgK1xcblxcdFxcdFxcdFxcdG40NCAqIChcXG5cXHRcXHRcXHRcXHRcXHQtIG4xMyAqIG4yMiAqIG4zMVxcblxcdFxcdFxcdFxcdFxcdCAtIG4xMSAqIG4yMyAqIG4zMlxcblxcdFxcdFxcdFxcdFxcdCArIG4xMSAqIG4yMiAqIG4zM1xcblxcdFxcdFxcdFxcdFxcdCArIG4xMyAqIG4yMSAqIG4zMlxcblxcdFxcdFxcdFxcdFxcdCAtIG4xMiAqIG4yMSAqIG4zM1xcblxcdFxcdFxcdFxcdFxcdCArIG4xMiAqIG4yMyAqIG4zMVxcblxcdFxcdFxcdFxcdClcXG5cXG5cXHRcXHRcXHQpO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dHJhbnNwb3NlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXG5cXHRcXHRcXHR2YXIgdG1wO1xcblxcblxcdFxcdFxcdHRtcCA9IHRlWyAxIF07IHRlWyAxIF0gPSB0ZVsgNCBdOyB0ZVsgNCBdID0gdG1wO1xcblxcdFxcdFxcdHRtcCA9IHRlWyAyIF07IHRlWyAyIF0gPSB0ZVsgOCBdOyB0ZVsgOCBdID0gdG1wO1xcblxcdFxcdFxcdHRtcCA9IHRlWyA2IF07IHRlWyA2IF0gPSB0ZVsgOSBdOyB0ZVsgOSBdID0gdG1wO1xcblxcblxcdFxcdFxcdHRtcCA9IHRlWyAzIF07IHRlWyAzIF0gPSB0ZVsgMTIgXTsgdGVbIDEyIF0gPSB0bXA7XFxuXFx0XFx0XFx0dG1wID0gdGVbIDcgXTsgdGVbIDcgXSA9IHRlWyAxMyBdOyB0ZVsgMTMgXSA9IHRtcDtcXG5cXHRcXHRcXHR0bXAgPSB0ZVsgMTEgXTsgdGVbIDExIF0gPSB0ZVsgMTQgXTsgdGVbIDE0IF0gPSB0bXA7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxuXFxuXFx0XFx0XFx0dGVbIDEyIF0gPSB2Lng7XFxuXFx0XFx0XFx0dGVbIDEzIF0gPSB2Lnk7XFxuXFx0XFx0XFx0dGVbIDE0IF0gPSB2Lno7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRJbnZlcnNlOiBmdW5jdGlvbiAoIG0sIHRocm93T25EZWdlbmVyYXRlICkge1xcblxcblxcdFxcdFxcdC8vIGJhc2VkIG9uIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvbWF0cml4L2Z1bmN0aW9ucy9pbnZlcnNlL2ZvdXJEL2luZGV4Lmh0bVxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHMsXFxuXFx0XFx0XFx0XFx0bWUgPSBtLmVsZW1lbnRzLFxcblxcblxcdFxcdFxcdFxcdG4xMSA9IG1lWyAwIF0sIG4yMSA9IG1lWyAxIF0sIG4zMSA9IG1lWyAyIF0sIG40MSA9IG1lWyAzIF0sXFxuXFx0XFx0XFx0XFx0bjEyID0gbWVbIDQgXSwgbjIyID0gbWVbIDUgXSwgbjMyID0gbWVbIDYgXSwgbjQyID0gbWVbIDcgXSxcXG5cXHRcXHRcXHRcXHRuMTMgPSBtZVsgOCBdLCBuMjMgPSBtZVsgOSBdLCBuMzMgPSBtZVsgMTAgXSwgbjQzID0gbWVbIDExIF0sXFxuXFx0XFx0XFx0XFx0bjE0ID0gbWVbIDEyIF0sIG4yNCA9IG1lWyAxMyBdLCBuMzQgPSBtZVsgMTQgXSwgbjQ0ID0gbWVbIDE1IF0sXFxuXFxuXFx0XFx0XFx0XFx0dDExID0gbjIzICogbjM0ICogbjQyIC0gbjI0ICogbjMzICogbjQyICsgbjI0ICogbjMyICogbjQzIC0gbjIyICogbjM0ICogbjQzIC0gbjIzICogbjMyICogbjQ0ICsgbjIyICogbjMzICogbjQ0LFxcblxcdFxcdFxcdFxcdHQxMiA9IG4xNCAqIG4zMyAqIG40MiAtIG4xMyAqIG4zNCAqIG40MiAtIG4xNCAqIG4zMiAqIG40MyArIG4xMiAqIG4zNCAqIG40MyArIG4xMyAqIG4zMiAqIG40NCAtIG4xMiAqIG4zMyAqIG40NCxcXG5cXHRcXHRcXHRcXHR0MTMgPSBuMTMgKiBuMjQgKiBuNDIgLSBuMTQgKiBuMjMgKiBuNDIgKyBuMTQgKiBuMjIgKiBuNDMgLSBuMTIgKiBuMjQgKiBuNDMgLSBuMTMgKiBuMjIgKiBuNDQgKyBuMTIgKiBuMjMgKiBuNDQsXFxuXFx0XFx0XFx0XFx0dDE0ID0gbjE0ICogbjIzICogbjMyIC0gbjEzICogbjI0ICogbjMyIC0gbjE0ICogbjIyICogbjMzICsgbjEyICogbjI0ICogbjMzICsgbjEzICogbjIyICogbjM0IC0gbjEyICogbjIzICogbjM0O1xcblxcblxcdFxcdFxcdHZhciBkZXQgPSBuMTEgKiB0MTEgKyBuMjEgKiB0MTIgKyBuMzEgKiB0MTMgKyBuNDEgKiB0MTQ7XFxuXFxuXFx0XFx0XFx0aWYgKCBkZXQgPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG1zZyA9IFxcXCJUSFJFRS5NYXRyaXg0OiAuZ2V0SW52ZXJzZSgpIGNhbid0IGludmVydCBtYXRyaXgsIGRldGVybWluYW50IGlzIDBcXFwiO1xcblxcblxcdFxcdFxcdFxcdGlmICggdGhyb3dPbkRlZ2VuZXJhdGUgPT09IHRydWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggbXNnICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmlkZW50aXR5KCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBkZXRJbnYgPSAxIC8gZGV0O1xcblxcblxcdFxcdFxcdHRlWyAwIF0gPSB0MTEgKiBkZXRJbnY7XFxuXFx0XFx0XFx0dGVbIDEgXSA9ICggbjI0ICogbjMzICogbjQxIC0gbjIzICogbjM0ICogbjQxIC0gbjI0ICogbjMxICogbjQzICsgbjIxICogbjM0ICogbjQzICsgbjIzICogbjMxICogbjQ0IC0gbjIxICogbjMzICogbjQ0ICkgKiBkZXRJbnY7XFxuXFx0XFx0XFx0dGVbIDIgXSA9ICggbjIyICogbjM0ICogbjQxIC0gbjI0ICogbjMyICogbjQxICsgbjI0ICogbjMxICogbjQyIC0gbjIxICogbjM0ICogbjQyIC0gbjIyICogbjMxICogbjQ0ICsgbjIxICogbjMyICogbjQ0ICkgKiBkZXRJbnY7XFxuXFx0XFx0XFx0dGVbIDMgXSA9ICggbjIzICogbjMyICogbjQxIC0gbjIyICogbjMzICogbjQxIC0gbjIzICogbjMxICogbjQyICsgbjIxICogbjMzICogbjQyICsgbjIyICogbjMxICogbjQzIC0gbjIxICogbjMyICogbjQzICkgKiBkZXRJbnY7XFxuXFxuXFx0XFx0XFx0dGVbIDQgXSA9IHQxMiAqIGRldEludjtcXG5cXHRcXHRcXHR0ZVsgNSBdID0gKCBuMTMgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzMgKiBuNDEgKyBuMTQgKiBuMzEgKiBuNDMgLSBuMTEgKiBuMzQgKiBuNDMgLSBuMTMgKiBuMzEgKiBuNDQgKyBuMTEgKiBuMzMgKiBuNDQgKSAqIGRldEludjtcXG5cXHRcXHRcXHR0ZVsgNiBdID0gKCBuMTQgKiBuMzIgKiBuNDEgLSBuMTIgKiBuMzQgKiBuNDEgLSBuMTQgKiBuMzEgKiBuNDIgKyBuMTEgKiBuMzQgKiBuNDIgKyBuMTIgKiBuMzEgKiBuNDQgLSBuMTEgKiBuMzIgKiBuNDQgKSAqIGRldEludjtcXG5cXHRcXHRcXHR0ZVsgNyBdID0gKCBuMTIgKiBuMzMgKiBuNDEgLSBuMTMgKiBuMzIgKiBuNDEgKyBuMTMgKiBuMzEgKiBuNDIgLSBuMTEgKiBuMzMgKiBuNDIgLSBuMTIgKiBuMzEgKiBuNDMgKyBuMTEgKiBuMzIgKiBuNDMgKSAqIGRldEludjtcXG5cXG5cXHRcXHRcXHR0ZVsgOCBdID0gdDEzICogZGV0SW52O1xcblxcdFxcdFxcdHRlWyA5IF0gPSAoIG4xNCAqIG4yMyAqIG40MSAtIG4xMyAqIG4yNCAqIG40MSAtIG4xNCAqIG4yMSAqIG40MyArIG4xMSAqIG4yNCAqIG40MyArIG4xMyAqIG4yMSAqIG40NCAtIG4xMSAqIG4yMyAqIG40NCApICogZGV0SW52O1xcblxcdFxcdFxcdHRlWyAxMCBdID0gKCBuMTIgKiBuMjQgKiBuNDEgLSBuMTQgKiBuMjIgKiBuNDEgKyBuMTQgKiBuMjEgKiBuNDIgLSBuMTEgKiBuMjQgKiBuNDIgLSBuMTIgKiBuMjEgKiBuNDQgKyBuMTEgKiBuMjIgKiBuNDQgKSAqIGRldEludjtcXG5cXHRcXHRcXHR0ZVsgMTEgXSA9ICggbjEzICogbjIyICogbjQxIC0gbjEyICogbjIzICogbjQxIC0gbjEzICogbjIxICogbjQyICsgbjExICogbjIzICogbjQyICsgbjEyICogbjIxICogbjQzIC0gbjExICogbjIyICogbjQzICkgKiBkZXRJbnY7XFxuXFxuXFx0XFx0XFx0dGVbIDEyIF0gPSB0MTQgKiBkZXRJbnY7XFxuXFx0XFx0XFx0dGVbIDEzIF0gPSAoIG4xMyAqIG4yNCAqIG4zMSAtIG4xNCAqIG4yMyAqIG4zMSArIG4xNCAqIG4yMSAqIG4zMyAtIG4xMSAqIG4yNCAqIG4zMyAtIG4xMyAqIG4yMSAqIG4zNCArIG4xMSAqIG4yMyAqIG4zNCApICogZGV0SW52O1xcblxcdFxcdFxcdHRlWyAxNCBdID0gKCBuMTQgKiBuMjIgKiBuMzEgLSBuMTIgKiBuMjQgKiBuMzEgLSBuMTQgKiBuMjEgKiBuMzIgKyBuMTEgKiBuMjQgKiBuMzIgKyBuMTIgKiBuMjEgKiBuMzQgLSBuMTEgKiBuMjIgKiBuMzQgKSAqIGRldEludjtcXG5cXHRcXHRcXHR0ZVsgMTUgXSA9ICggbjEyICogbjIzICogbjMxIC0gbjEzICogbjIyICogbjMxICsgbjEzICogbjIxICogbjMyIC0gbjExICogbjIzICogbjMyIC0gbjEyICogbjIxICogbjMzICsgbjExICogbjIyICogbjMzICkgKiBkZXRJbnY7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzY2FsZTogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxuXFx0XFx0XFx0dmFyIHggPSB2LngsIHkgPSB2LnksIHogPSB2Lno7XFxuXFxuXFx0XFx0XFx0dGVbIDAgXSAqPSB4OyB0ZVsgNCBdICo9IHk7IHRlWyA4IF0gKj0gejtcXG5cXHRcXHRcXHR0ZVsgMSBdICo9IHg7IHRlWyA1IF0gKj0geTsgdGVbIDkgXSAqPSB6O1xcblxcdFxcdFxcdHRlWyAyIF0gKj0geDsgdGVbIDYgXSAqPSB5OyB0ZVsgMTAgXSAqPSB6O1xcblxcdFxcdFxcdHRlWyAzIF0gKj0geDsgdGVbIDcgXSAqPSB5OyB0ZVsgMTEgXSAqPSB6O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0TWF4U2NhbGVPbkF4aXM6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHZhciBzY2FsZVhTcSA9IHRlWyAwIF0gKiB0ZVsgMCBdICsgdGVbIDEgXSAqIHRlWyAxIF0gKyB0ZVsgMiBdICogdGVbIDIgXTtcXG5cXHRcXHRcXHR2YXIgc2NhbGVZU3EgPSB0ZVsgNCBdICogdGVbIDQgXSArIHRlWyA1IF0gKiB0ZVsgNSBdICsgdGVbIDYgXSAqIHRlWyA2IF07XFxuXFx0XFx0XFx0dmFyIHNjYWxlWlNxID0gdGVbIDggXSAqIHRlWyA4IF0gKyB0ZVsgOSBdICogdGVbIDkgXSArIHRlWyAxMCBdICogdGVbIDEwIF07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGguc3FydCggTWF0aC5tYXgoIHNjYWxlWFNxLCBzY2FsZVlTcSwgc2NhbGVaU3EgKSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWFrZVRyYW5zbGF0aW9uOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5zZXQoXFxuXFxuXFx0XFx0XFx0XFx0MSwgMCwgMCwgeCxcXG5cXHRcXHRcXHRcXHQwLCAxLCAwLCB5LFxcblxcdFxcdFxcdFxcdDAsIDAsIDEsIHosXFxuXFx0XFx0XFx0XFx0MCwgMCwgMCwgMVxcblxcblxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtYWtlUm90YXRpb25YOiBmdW5jdGlvbiAoIHRoZXRhICkge1xcblxcblxcdFxcdFxcdHZhciBjID0gTWF0aC5jb3MoIHRoZXRhICksIHMgPSBNYXRoLnNpbiggdGhldGEgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnNldChcXG5cXG5cXHRcXHRcXHRcXHQxLCAwLCAwLCAwLFxcblxcdFxcdFxcdFxcdDAsIGMsIC0gcywgMCxcXG5cXHRcXHRcXHRcXHQwLCBzLCBjLCAwLFxcblxcdFxcdFxcdFxcdDAsIDAsIDAsIDFcXG5cXG5cXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWFrZVJvdGF0aW9uWTogZnVuY3Rpb24gKCB0aGV0YSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApLCBzID0gTWF0aC5zaW4oIHRoZXRhICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5zZXQoXFxuXFxuXFx0XFx0XFx0XFx0IGMsIDAsIHMsIDAsXFxuXFx0XFx0XFx0XFx0IDAsIDEsIDAsIDAsXFxuXFx0XFx0XFx0XFx0LSBzLCAwLCBjLCAwLFxcblxcdFxcdFxcdFxcdCAwLCAwLCAwLCAxXFxuXFxuXFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG1ha2VSb3RhdGlvblo6IGZ1bmN0aW9uICggdGhldGEgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGMgPSBNYXRoLmNvcyggdGhldGEgKSwgcyA9IE1hdGguc2luKCB0aGV0YSApO1xcblxcblxcdFxcdFxcdHRoaXMuc2V0KFxcblxcblxcdFxcdFxcdFxcdGMsIC0gcywgMCwgMCxcXG5cXHRcXHRcXHRcXHRzLCBjLCAwLCAwLFxcblxcdFxcdFxcdFxcdDAsIDAsIDEsIDAsXFxuXFx0XFx0XFx0XFx0MCwgMCwgMCwgMVxcblxcblxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtYWtlUm90YXRpb25BeGlzOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xcblxcblxcdFxcdFxcdC8vIEJhc2VkIG9uIGh0dHA6Ly93d3cuZ2FtZWRldi5uZXQvcmVmZXJlbmNlL2FydGljbGVzL2FydGljbGUxMTk5LmFzcFxcblxcblxcdFxcdFxcdHZhciBjID0gTWF0aC5jb3MoIGFuZ2xlICk7XFxuXFx0XFx0XFx0dmFyIHMgPSBNYXRoLnNpbiggYW5nbGUgKTtcXG5cXHRcXHRcXHR2YXIgdCA9IDEgLSBjO1xcblxcdFxcdFxcdHZhciB4ID0gYXhpcy54LCB5ID0gYXhpcy55LCB6ID0gYXhpcy56O1xcblxcdFxcdFxcdHZhciB0eCA9IHQgKiB4LCB0eSA9IHQgKiB5O1xcblxcblxcdFxcdFxcdHRoaXMuc2V0KFxcblxcblxcdFxcdFxcdFxcdHR4ICogeCArIGMsIHR4ICogeSAtIHMgKiB6LCB0eCAqIHogKyBzICogeSwgMCxcXG5cXHRcXHRcXHRcXHR0eCAqIHkgKyBzICogeiwgdHkgKiB5ICsgYywgdHkgKiB6IC0gcyAqIHgsIDAsXFxuXFx0XFx0XFx0XFx0dHggKiB6IC0gcyAqIHksIHR5ICogeiArIHMgKiB4LCB0ICogeiAqIHogKyBjLCAwLFxcblxcdFxcdFxcdFxcdDAsIDAsIDAsIDFcXG5cXG5cXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdCByZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG1ha2VTY2FsZTogZnVuY3Rpb24gKCB4LCB5LCB6ICkge1xcblxcblxcdFxcdFxcdHRoaXMuc2V0KFxcblxcblxcdFxcdFxcdFxcdHgsIDAsIDAsIDAsXFxuXFx0XFx0XFx0XFx0MCwgeSwgMCwgMCxcXG5cXHRcXHRcXHRcXHQwLCAwLCB6LCAwLFxcblxcdFxcdFxcdFxcdDAsIDAsIDAsIDFcXG5cXG5cXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWFrZVNoZWFyOiBmdW5jdGlvbiAoIHgsIHksIHogKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5zZXQoXFxuXFxuXFx0XFx0XFx0XFx0MSwgeSwgeiwgMCxcXG5cXHRcXHRcXHRcXHR4LCAxLCB6LCAwLFxcblxcdFxcdFxcdFxcdHgsIHksIDEsIDAsXFxuXFx0XFx0XFx0XFx0MCwgMCwgMCwgMVxcblxcblxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb21wb3NlOiBmdW5jdGlvbiAoIHBvc2l0aW9uLCBxdWF0ZXJuaW9uLCBzY2FsZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm1ha2VSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XFxuXFx0XFx0XFx0dGhpcy5zY2FsZSggc2NhbGUgKTtcXG5cXHRcXHRcXHR0aGlzLnNldFBvc2l0aW9uKCBwb3NpdGlvbiApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGVjb21wb3NlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGRlY29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHN4ID0gdmVjdG9yLnNldCggdGVbIDAgXSwgdGVbIDEgXSwgdGVbIDIgXSApLmxlbmd0aCgpO1xcblxcdFxcdFxcdFxcdHZhciBzeSA9IHZlY3Rvci5zZXQoIHRlWyA0IF0sIHRlWyA1IF0sIHRlWyA2IF0gKS5sZW5ndGgoKTtcXG5cXHRcXHRcXHRcXHR2YXIgc3ogPSB2ZWN0b3Iuc2V0KCB0ZVsgOCBdLCB0ZVsgOSBdLCB0ZVsgMTAgXSApLmxlbmd0aCgpO1xcblxcblxcdFxcdFxcdFxcdC8vIGlmIGRldGVybWluZSBpcyBuZWdhdGl2ZSwgd2UgbmVlZCB0byBpbnZlcnQgb25lIHNjYWxlXFxuXFx0XFx0XFx0XFx0dmFyIGRldCA9IHRoaXMuZGV0ZXJtaW5hbnQoKTtcXG5cXHRcXHRcXHRcXHRpZiAoIGRldCA8IDAgKSBzeCA9IC0gc3g7XFxuXFxuXFx0XFx0XFx0XFx0cG9zaXRpb24ueCA9IHRlWyAxMiBdO1xcblxcdFxcdFxcdFxcdHBvc2l0aW9uLnkgPSB0ZVsgMTMgXTtcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbi56ID0gdGVbIDE0IF07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gc2NhbGUgdGhlIHJvdGF0aW9uIHBhcnRcXG5cXHRcXHRcXHRcXHRtYXRyaXguY29weSggdGhpcyApO1xcblxcblxcdFxcdFxcdFxcdHZhciBpbnZTWCA9IDEgLyBzeDtcXG5cXHRcXHRcXHRcXHR2YXIgaW52U1kgPSAxIC8gc3k7XFxuXFx0XFx0XFx0XFx0dmFyIGludlNaID0gMSAvIHN6O1xcblxcblxcdFxcdFxcdFxcdG1hdHJpeC5lbGVtZW50c1sgMCBdICo9IGludlNYO1xcblxcdFxcdFxcdFxcdG1hdHJpeC5lbGVtZW50c1sgMSBdICo9IGludlNYO1xcblxcdFxcdFxcdFxcdG1hdHJpeC5lbGVtZW50c1sgMiBdICo9IGludlNYO1xcblxcblxcdFxcdFxcdFxcdG1hdHJpeC5lbGVtZW50c1sgNCBdICo9IGludlNZO1xcblxcdFxcdFxcdFxcdG1hdHJpeC5lbGVtZW50c1sgNSBdICo9IGludlNZO1xcblxcdFxcdFxcdFxcdG1hdHJpeC5lbGVtZW50c1sgNiBdICo9IGludlNZO1xcblxcblxcdFxcdFxcdFxcdG1hdHJpeC5lbGVtZW50c1sgOCBdICo9IGludlNaO1xcblxcdFxcdFxcdFxcdG1hdHJpeC5lbGVtZW50c1sgOSBdICo9IGludlNaO1xcblxcdFxcdFxcdFxcdG1hdHJpeC5lbGVtZW50c1sgMTAgXSAqPSBpbnZTWjtcXG5cXG5cXHRcXHRcXHRcXHRxdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeCggbWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0c2NhbGUueCA9IHN4O1xcblxcdFxcdFxcdFxcdHNjYWxlLnkgPSBzeTtcXG5cXHRcXHRcXHRcXHRzY2FsZS56ID0gc3o7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0bWFrZVBlcnNwZWN0aXZlOiBmdW5jdGlvbiAoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkge1xcblxcblxcdFxcdFxcdGlmICggZmFyID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm1ha2VQZXJzcGVjdGl2ZSgpIGhhcyBiZWVuIHJlZGVmaW5lZCBhbmQgaGFzIGEgbmV3IHNpZ25hdHVyZS4gUGxlYXNlIGNoZWNrIHRoZSBkb2NzLicgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXG5cXHRcXHRcXHR2YXIgeCA9IDIgKiBuZWFyIC8gKCByaWdodCAtIGxlZnQgKTtcXG5cXHRcXHRcXHR2YXIgeSA9IDIgKiBuZWFyIC8gKCB0b3AgLSBib3R0b20gKTtcXG5cXG5cXHRcXHRcXHR2YXIgYSA9ICggcmlnaHQgKyBsZWZ0ICkgLyAoIHJpZ2h0IC0gbGVmdCApO1xcblxcdFxcdFxcdHZhciBiID0gKCB0b3AgKyBib3R0b20gKSAvICggdG9wIC0gYm90dG9tICk7XFxuXFx0XFx0XFx0dmFyIGMgPSAtICggZmFyICsgbmVhciApIC8gKCBmYXIgLSBuZWFyICk7XFxuXFx0XFx0XFx0dmFyIGQgPSAtIDIgKiBmYXIgKiBuZWFyIC8gKCBmYXIgLSBuZWFyICk7XFxuXFxuXFx0XFx0XFx0dGVbIDAgXSA9IHg7XFx0dGVbIDQgXSA9IDA7XFx0dGVbIDggXSA9IGE7XFx0dGVbIDEyIF0gPSAwO1xcblxcdFxcdFxcdHRlWyAxIF0gPSAwO1xcdHRlWyA1IF0gPSB5O1xcdHRlWyA5IF0gPSBiO1xcdHRlWyAxMyBdID0gMDtcXG5cXHRcXHRcXHR0ZVsgMiBdID0gMDtcXHR0ZVsgNiBdID0gMDtcXHR0ZVsgMTAgXSA9IGM7XFx0dGVbIDE0IF0gPSBkO1xcblxcdFxcdFxcdHRlWyAzIF0gPSAwO1xcdHRlWyA3IF0gPSAwO1xcdHRlWyAxMSBdID0gLSAxO1xcdHRlWyAxNSBdID0gMDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG1ha2VPcnRob2dyYXBoaWM6IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIHRvcCwgYm90dG9tLCBuZWFyLCBmYXIgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXG5cXHRcXHRcXHR2YXIgdyA9IDEuMCAvICggcmlnaHQgLSBsZWZ0ICk7XFxuXFx0XFx0XFx0dmFyIGggPSAxLjAgLyAoIHRvcCAtIGJvdHRvbSApO1xcblxcdFxcdFxcdHZhciBwID0gMS4wIC8gKCBmYXIgLSBuZWFyICk7XFxuXFxuXFx0XFx0XFx0dmFyIHggPSAoIHJpZ2h0ICsgbGVmdCApICogdztcXG5cXHRcXHRcXHR2YXIgeSA9ICggdG9wICsgYm90dG9tICkgKiBoO1xcblxcdFxcdFxcdHZhciB6ID0gKCBmYXIgKyBuZWFyICkgKiBwO1xcblxcblxcdFxcdFxcdHRlWyAwIF0gPSAyICogdztcXHR0ZVsgNCBdID0gMDtcXHR0ZVsgOCBdID0gMDtcXHR0ZVsgMTIgXSA9IC0geDtcXG5cXHRcXHRcXHR0ZVsgMSBdID0gMDtcXHR0ZVsgNSBdID0gMiAqIGg7XFx0dGVbIDkgXSA9IDA7XFx0dGVbIDEzIF0gPSAtIHk7XFxuXFx0XFx0XFx0dGVbIDIgXSA9IDA7XFx0dGVbIDYgXSA9IDA7XFx0dGVbIDEwIF0gPSAtIDIgKiBwO1xcdHRlWyAxNCBdID0gLSB6O1xcblxcdFxcdFxcdHRlWyAzIF0gPSAwO1xcdHRlWyA3IF0gPSAwO1xcdHRlWyAxMSBdID0gMDtcXHR0ZVsgMTUgXSA9IDE7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRlcXVhbHM6IGZ1bmN0aW9uICggbWF0cml4ICkge1xcblxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxuXFx0XFx0XFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IDE2OyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggdGVbIGkgXSAhPT0gbWVbIGkgXSApIHJldHVybiBmYWxzZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCAxNjsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmVsZW1lbnRzWyBpIF0gPSBhcnJheVsgaSArIG9mZnNldCBdO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xcblxcdFxcdFxcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xcblxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxuXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCBdID0gdGVbIDAgXTtcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGVbIDEgXTtcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMiBdID0gdGVbIDIgXTtcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMyBdID0gdGVbIDMgXTtcXG5cXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgNCBdID0gdGVbIDQgXTtcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgNSBdID0gdGVbIDUgXTtcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgNiBdID0gdGVbIDYgXTtcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgNyBdID0gdGVbIDcgXTtcXG5cXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgOCBdID0gdGVbIDggXTtcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgOSBdID0gdGVbIDkgXTtcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMTAgXSA9IHRlWyAxMCBdO1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAxMSBdID0gdGVbIDExIF07XFxuXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDEyIF0gPSB0ZVsgMTIgXTtcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMTMgXSA9IHRlWyAxMyBdO1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAxNCBdID0gdGVbIDE0IF07XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDE1IF0gPSB0ZVsgMTUgXTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYXJyYXk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxuXFx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFF1YXRlcm5pb24oIHgsIHksIHosIHcgKSB7XFxuXFxuXFx0XFx0dGhpcy5feCA9IHggfHwgMDtcXG5cXHRcXHR0aGlzLl95ID0geSB8fCAwO1xcblxcdFxcdHRoaXMuX3ogPSB6IHx8IDA7XFxuXFx0XFx0dGhpcy5fdyA9ICggdyAhPT0gdW5kZWZpbmVkICkgPyB3IDogMTtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggUXVhdGVybmlvbiwge1xcblxcblxcdFxcdHNsZXJwOiBmdW5jdGlvbiAoIHFhLCBxYiwgcW0sIHQgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHFtLmNvcHkoIHFhICkuc2xlcnAoIHFiLCB0ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzbGVycEZsYXQ6IGZ1bmN0aW9uICggZHN0LCBkc3RPZmZzZXQsIHNyYzAsIHNyY09mZnNldDAsIHNyYzEsIHNyY09mZnNldDEsIHQgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gZnV6ei1mcmVlLCBhcnJheS1iYXNlZCBRdWF0ZXJuaW9uIFNMRVJQIG9wZXJhdGlvblxcblxcblxcdFxcdFxcdHZhciB4MCA9IHNyYzBbIHNyY09mZnNldDAgKyAwIF0sXFxuXFx0XFx0XFx0XFx0eTAgPSBzcmMwWyBzcmNPZmZzZXQwICsgMSBdLFxcblxcdFxcdFxcdFxcdHowID0gc3JjMFsgc3JjT2Zmc2V0MCArIDIgXSxcXG5cXHRcXHRcXHRcXHR3MCA9IHNyYzBbIHNyY09mZnNldDAgKyAzIF0sXFxuXFxuXFx0XFx0XFx0XFx0eDEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMCBdLFxcblxcdFxcdFxcdFxcdHkxID0gc3JjMVsgc3JjT2Zmc2V0MSArIDEgXSxcXG5cXHRcXHRcXHRcXHR6MSA9IHNyYzFbIHNyY09mZnNldDEgKyAyIF0sXFxuXFx0XFx0XFx0XFx0dzEgPSBzcmMxWyBzcmNPZmZzZXQxICsgMyBdO1xcblxcblxcdFxcdFxcdGlmICggdzAgIT09IHcxIHx8IHgwICE9PSB4MSB8fCB5MCAhPT0geTEgfHwgejAgIT09IHoxICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBzID0gMSAtIHQsXFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29zID0geDAgKiB4MSArIHkwICogeTEgKyB6MCAqIHoxICsgdzAgKiB3MSxcXG5cXG5cXHRcXHRcXHRcXHRcXHRkaXIgPSAoIGNvcyA+PSAwID8gMSA6IC0gMSApLFxcblxcdFxcdFxcdFxcdFxcdHNxclNpbiA9IDEgLSBjb3MgKiBjb3M7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU2tpcCB0aGUgU2xlcnAgZm9yIHRpbnkgc3RlcHMgdG8gYXZvaWQgbnVtZXJpYyBwcm9ibGVtczpcXG5cXHRcXHRcXHRcXHRpZiAoIHNxclNpbiA+IE51bWJlci5FUFNJTE9OICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBzaW4gPSBNYXRoLnNxcnQoIHNxclNpbiApLFxcblxcdFxcdFxcdFxcdFxcdFxcdGxlbiA9IE1hdGguYXRhbjIoIHNpbiwgY29zICogZGlyICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cyA9IE1hdGguc2luKCBzICogbGVuICkgLyBzaW47XFxuXFx0XFx0XFx0XFx0XFx0dCA9IE1hdGguc2luKCB0ICogbGVuICkgLyBzaW47XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciB0RGlyID0gdCAqIGRpcjtcXG5cXG5cXHRcXHRcXHRcXHR4MCA9IHgwICogcyArIHgxICogdERpcjtcXG5cXHRcXHRcXHRcXHR5MCA9IHkwICogcyArIHkxICogdERpcjtcXG5cXHRcXHRcXHRcXHR6MCA9IHowICogcyArIHoxICogdERpcjtcXG5cXHRcXHRcXHRcXHR3MCA9IHcwICogcyArIHcxICogdERpcjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBOb3JtYWxpemUgaW4gY2FzZSB3ZSBqdXN0IGRpZCBhIGxlcnA6XFxuXFx0XFx0XFx0XFx0aWYgKCBzID09PSAxIC0gdCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZiA9IDEgLyBNYXRoLnNxcnQoIHgwICogeDAgKyB5MCAqIHkwICsgejAgKiB6MCArIHcwICogdzAgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR4MCAqPSBmO1xcblxcdFxcdFxcdFxcdFxcdHkwICo9IGY7XFxuXFx0XFx0XFx0XFx0XFx0ejAgKj0gZjtcXG5cXHRcXHRcXHRcXHRcXHR3MCAqPSBmO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZHN0WyBkc3RPZmZzZXQgXSA9IHgwO1xcblxcdFxcdFxcdGRzdFsgZHN0T2Zmc2V0ICsgMSBdID0geTA7XFxuXFx0XFx0XFx0ZHN0WyBkc3RPZmZzZXQgKyAyIF0gPSB6MDtcXG5cXHRcXHRcXHRkc3RbIGRzdE9mZnNldCArIDMgXSA9IHcwO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFF1YXRlcm5pb24ucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0eDoge1xcblxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLl94O1xcblxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR5OiB7XFxuXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuX3k7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHo6IHtcXG5cXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5fejtcXG5cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dzoge1xcblxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLl93O1xcblxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX3cgPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuYXNzaWduKCBRdWF0ZXJuaW9uLnByb3RvdHlwZSwge1xcblxcblxcdFxcdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xcblxcblxcdFxcdFxcdHRoaXMuX3ggPSB4O1xcblxcdFxcdFxcdHRoaXMuX3kgPSB5O1xcblxcdFxcdFxcdHRoaXMuX3ogPSB6O1xcblxcdFxcdFxcdHRoaXMuX3cgPSB3O1xcblxcblxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3osIHRoaXMuX3cgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggcXVhdGVybmlvbiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLl94ID0gcXVhdGVybmlvbi54O1xcblxcdFxcdFxcdHRoaXMuX3kgPSBxdWF0ZXJuaW9uLnk7XFxuXFx0XFx0XFx0dGhpcy5feiA9IHF1YXRlcm5pb24uejtcXG5cXHRcXHRcXHR0aGlzLl93ID0gcXVhdGVybmlvbi53O1xcblxcblxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbUV1bGVyOiBmdW5jdGlvbiAoIGV1bGVyLCB1cGRhdGUgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCAhICggZXVsZXIgJiYgZXVsZXIuaXNFdWxlciApICkge1xcblxcblxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggJ1RIUkVFLlF1YXRlcm5pb246IC5zZXRGcm9tRXVsZXIoKSBub3cgZXhwZWN0cyBhbiBFdWxlciByb3RhdGlvbiByYXRoZXIgdGhhbiBhIFZlY3RvcjMgYW5kIG9yZGVyLicgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIHggPSBldWxlci5feCwgeSA9IGV1bGVyLl95LCB6ID0gZXVsZXIuX3osIG9yZGVyID0gZXVsZXIub3JkZXI7XFxuXFxuXFx0XFx0XFx0Ly8gaHR0cDovL3d3dy5tYXRod29ya3MuY29tL21hdGxhYmNlbnRyYWwvZmlsZWV4Y2hhbmdlL1xcblxcdFxcdFxcdC8vIFxcdDIwNjk2LWZ1bmN0aW9uLXRvLWNvbnZlcnQtYmV0d2Vlbi1kY20tZXVsZXItYW5nbGVzLXF1YXRlcm5pb25zLWFuZC1ldWxlci12ZWN0b3JzL1xcblxcdFxcdFxcdC8vXFx0Y29udGVudC9TcGluQ2FsYy5tXFxuXFxuXFx0XFx0XFx0dmFyIGNvcyA9IE1hdGguY29zO1xcblxcdFxcdFxcdHZhciBzaW4gPSBNYXRoLnNpbjtcXG5cXG5cXHRcXHRcXHR2YXIgYzEgPSBjb3MoIHggLyAyICk7XFxuXFx0XFx0XFx0dmFyIGMyID0gY29zKCB5IC8gMiApO1xcblxcdFxcdFxcdHZhciBjMyA9IGNvcyggeiAvIDIgKTtcXG5cXG5cXHRcXHRcXHR2YXIgczEgPSBzaW4oIHggLyAyICk7XFxuXFx0XFx0XFx0dmFyIHMyID0gc2luKCB5IC8gMiApO1xcblxcdFxcdFxcdHZhciBzMyA9IHNpbiggeiAvIDIgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcXG5cXHRcXHRcXHRcXHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVhaJyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcXG5cXHRcXHRcXHRcXHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWlhZJyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcXG5cXHRcXHRcXHRcXHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcXG5cXHRcXHRcXHRcXHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWVpYJyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgKyBzMSAqIGMyICogczM7XFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyAtIHMxICogczIgKiBjMztcXG5cXHRcXHRcXHRcXHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWFpZJyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0gczEgKiBjMiAqIGMzIC0gYzEgKiBzMiAqIHMzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSBjMSAqIHMyICogYzMgLSBzMSAqIGMyICogczM7XFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9IGMxICogYzIgKiBzMyArIHMxICogczIgKiBjMztcXG5cXHRcXHRcXHRcXHR0aGlzLl93ID0gYzEgKiBjMiAqIGMzICsgczEgKiBzMiAqIHMzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHVwZGF0ZSAhPT0gZmFsc2UgKSB0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZyb21BeGlzQW5nbGU6IGZ1bmN0aW9uICggYXhpcywgYW5nbGUgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL2FuZ2xlVG9RdWF0ZXJuaW9uL2luZGV4Lmh0bVxcblxcblxcdFxcdFxcdC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXFxuXFxuXFx0XFx0XFx0dmFyIGhhbGZBbmdsZSA9IGFuZ2xlIC8gMiwgcyA9IE1hdGguc2luKCBoYWxmQW5nbGUgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl94ID0gYXhpcy54ICogcztcXG5cXHRcXHRcXHR0aGlzLl95ID0gYXhpcy55ICogcztcXG5cXHRcXHRcXHR0aGlzLl96ID0gYXhpcy56ICogcztcXG5cXHRcXHRcXHR0aGlzLl93ID0gTWF0aC5jb3MoIGhhbGZBbmdsZSApO1xcblxcblxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XFxuXFxuXFx0XFx0XFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvUXVhdGVybmlvbi9pbmRleC5odG1cXG5cXG5cXHRcXHRcXHQvLyBhc3N1bWVzIHRoZSB1cHBlciAzeDMgb2YgbSBpcyBhIHB1cmUgcm90YXRpb24gbWF0cml4IChpLmUsIHVuc2NhbGVkKVxcblxcblxcdFxcdFxcdHZhciB0ZSA9IG0uZWxlbWVudHMsXFxuXFxuXFx0XFx0XFx0XFx0bTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXSxcXG5cXHRcXHRcXHRcXHRtMjEgPSB0ZVsgMSBdLCBtMjIgPSB0ZVsgNSBdLCBtMjMgPSB0ZVsgOSBdLFxcblxcdFxcdFxcdFxcdG0zMSA9IHRlWyAyIF0sIG0zMiA9IHRlWyA2IF0sIG0zMyA9IHRlWyAxMCBdLFxcblxcblxcdFxcdFxcdFxcdHRyYWNlID0gbTExICsgbTIyICsgbTMzLFxcblxcdFxcdFxcdFxcdHM7XFxuXFxuXFx0XFx0XFx0aWYgKCB0cmFjZSA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cyA9IDAuNSAvIE1hdGguc3FydCggdHJhY2UgKyAxLjAgKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl93ID0gMC4yNSAvIHM7XFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9ICggbTMyIC0gbTIzICkgKiBzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSAoIG0xMyAtIG0zMSApICogcztcXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gKCBtMjEgLSBtMTIgKSAqIHM7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggbTExID4gbTIyICYmIG0xMSA+IG0zMyApIHtcXG5cXG5cXHRcXHRcXHRcXHRzID0gMi4wICogTWF0aC5zcXJ0KCAxLjAgKyBtMTEgLSBtMjIgLSBtMzMgKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl93ID0gKCBtMzIgLSBtMjMgKSAvIHM7XFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9IDAuMjUgKiBzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSAoIG0xMiArIG0yMSApIC8gcztcXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gKCBtMTMgKyBtMzEgKSAvIHM7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggbTIyID4gbTMzICkge1xcblxcblxcdFxcdFxcdFxcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0yMiAtIG0xMSAtIG0zMyApO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX3cgPSAoIG0xMyAtIG0zMSApIC8gcztcXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0gKCBtMTIgKyBtMjEgKSAvIHM7XFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9IDAuMjUgKiBzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSAoIG0yMyArIG0zMiApIC8gcztcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHMgPSAyLjAgKiBNYXRoLnNxcnQoIDEuMCArIG0zMyAtIG0xMSAtIG0yMiApO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX3cgPSAoIG0yMSAtIG0xMiApIC8gcztcXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0gKCBtMTMgKyBtMzEgKSAvIHM7XFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9ICggbTIzICsgbTMyICkgLyBzO1xcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSAwLjI1ICogcztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tVW5pdFZlY3RvcnM6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyBhc3N1bWVzIGRpcmVjdGlvbiB2ZWN0b3JzIHZGcm9tIGFuZCB2VG8gYXJlIG5vcm1hbGl6ZWRcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciByO1xcblxcblxcdFxcdFxcdHZhciBFUFMgPSAwLjAwMDAwMTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbVVuaXRWZWN0b3JzKCB2RnJvbSwgdlRvICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRcXHRyID0gdkZyb20uZG90KCB2VG8gKSArIDE7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCByIDwgRVBTICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHIgPSAwO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggTWF0aC5hYnMoIHZGcm9tLnggKSA+IE1hdGguYWJzKCB2RnJvbS56ICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0djEuc2V0KCAtIHZGcm9tLnksIHZGcm9tLngsIDAgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHYxLnNldCggMCwgLSB2RnJvbS56LCB2RnJvbS55ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0djEuY3Jvc3NWZWN0b3JzKCB2RnJvbSwgdlRvICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSB2MS54O1xcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSB2MS55O1xcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSB2MS56O1xcblxcdFxcdFxcdFxcdHRoaXMuX3cgPSByO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLm5vcm1hbGl6ZSgpO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGludmVyc2U6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5jb25qdWdhdGUoKS5ub3JtYWxpemUoKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvbmp1Z2F0ZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMuX3ggKj0gLSAxO1xcblxcdFxcdFxcdHRoaXMuX3kgKj0gLSAxO1xcblxcdFxcdFxcdHRoaXMuX3ogKj0gLSAxO1xcblxcblxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX3ggKiB2Ll94ICsgdGhpcy5feSAqIHYuX3kgKyB0aGlzLl96ICogdi5feiArIHRoaXMuX3cgKiB2Ll93O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5feCAqIHRoaXMuX3ggKyB0aGlzLl95ICogdGhpcy5feSArIHRoaXMuX3ogKiB0aGlzLl96ICsgdGhpcy5fdyAqIHRoaXMuX3c7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLl94ICogdGhpcy5feCArIHRoaXMuX3kgKiB0aGlzLl95ICsgdGhpcy5feiAqIHRoaXMuX3ogKyB0aGlzLl93ICogdGhpcy5fdyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGwgPSB0aGlzLmxlbmd0aCgpO1xcblxcblxcdFxcdFxcdGlmICggbCA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0gMDtcXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0gMDtcXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gMDtcXG5cXHRcXHRcXHRcXHR0aGlzLl93ID0gMTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdGwgPSAxIC8gbDtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0gdGhpcy5feCAqIGw7XFxuXFx0XFx0XFx0XFx0dGhpcy5feSA9IHRoaXMuX3kgKiBsO1xcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSB0aGlzLl96ICogbDtcXG5cXHRcXHRcXHRcXHR0aGlzLl93ID0gdGhpcy5fdyAqIGw7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bXVsdGlwbHk6IGZ1bmN0aW9uICggcSwgcCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHAgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHkoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5tdWx0aXBseVF1YXRlcm5pb25zKCBhLCBiICkgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMubXVsdGlwbHlRdWF0ZXJuaW9ucyggcSwgcCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tdWx0aXBseVF1YXRlcm5pb25zKCB0aGlzLCBxICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwcmVtdWx0aXBseTogZnVuY3Rpb24gKCBxICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLm11bHRpcGx5UXVhdGVybmlvbnMoIHEsIHRoaXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG11bHRpcGx5UXVhdGVybmlvbnM6IGZ1bmN0aW9uICggYSwgYiApIHtcXG5cXG5cXHRcXHRcXHQvLyBmcm9tIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2FsZ2VicmEvcmVhbE5vcm1lZEFsZ2VicmEvcXVhdGVybmlvbnMvY29kZS9pbmRleC5odG1cXG5cXG5cXHRcXHRcXHR2YXIgcWF4ID0gYS5feCwgcWF5ID0gYS5feSwgcWF6ID0gYS5feiwgcWF3ID0gYS5fdztcXG5cXHRcXHRcXHR2YXIgcWJ4ID0gYi5feCwgcWJ5ID0gYi5feSwgcWJ6ID0gYi5feiwgcWJ3ID0gYi5fdztcXG5cXG5cXHRcXHRcXHR0aGlzLl94ID0gcWF4ICogcWJ3ICsgcWF3ICogcWJ4ICsgcWF5ICogcWJ6IC0gcWF6ICogcWJ5O1xcblxcdFxcdFxcdHRoaXMuX3kgPSBxYXkgKiBxYncgKyBxYXcgKiBxYnkgKyBxYXogKiBxYnggLSBxYXggKiBxYno7XFxuXFx0XFx0XFx0dGhpcy5feiA9IHFheiAqIHFidyArIHFhdyAqIHFieiArIHFheCAqIHFieSAtIHFheSAqIHFieDtcXG5cXHRcXHRcXHR0aGlzLl93ID0gcWF3ICogcWJ3IC0gcWF4ICogcWJ4IC0gcWF5ICogcWJ5IC0gcWF6ICogcWJ6O1xcblxcblxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2xlcnA6IGZ1bmN0aW9uICggcWIsIHQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0ID09PSAwICkgcmV0dXJuIHRoaXM7XFxuXFx0XFx0XFx0aWYgKCB0ID09PSAxICkgcmV0dXJuIHRoaXMuY29weSggcWIgKTtcXG5cXG5cXHRcXHRcXHR2YXIgeCA9IHRoaXMuX3gsIHkgPSB0aGlzLl95LCB6ID0gdGhpcy5feiwgdyA9IHRoaXMuX3c7XFxuXFxuXFx0XFx0XFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvYWxnZWJyYS9yZWFsTm9ybWVkQWxnZWJyYS9xdWF0ZXJuaW9ucy9zbGVycC9cXG5cXG5cXHRcXHRcXHR2YXIgY29zSGFsZlRoZXRhID0gdyAqIHFiLl93ICsgeCAqIHFiLl94ICsgeSAqIHFiLl95ICsgeiAqIHFiLl96O1xcblxcblxcdFxcdFxcdGlmICggY29zSGFsZlRoZXRhIDwgMCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl93ID0gLSBxYi5fdztcXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0gLSBxYi5feDtcXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0gLSBxYi5feTtcXG5cXHRcXHRcXHRcXHR0aGlzLl96ID0gLSBxYi5fejtcXG5cXG5cXHRcXHRcXHRcXHRjb3NIYWxmVGhldGEgPSAtIGNvc0hhbGZUaGV0YTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuY29weSggcWIgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBjb3NIYWxmVGhldGEgPj0gMS4wICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX3cgPSB3O1xcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSB4O1xcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSB5O1xcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSB6O1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgc2luSGFsZlRoZXRhID0gTWF0aC5zcXJ0KCAxLjAgLSBjb3NIYWxmVGhldGEgKiBjb3NIYWxmVGhldGEgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIE1hdGguYWJzKCBzaW5IYWxmVGhldGEgKSA8IDAuMDAxICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX3cgPSAwLjUgKiAoIHcgKyB0aGlzLl93ICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9IDAuNSAqICggeCArIHRoaXMuX3ggKTtcXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0gMC41ICogKCB5ICsgdGhpcy5feSApO1xcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSAwLjUgKiAoIHogKyB0aGlzLl96ICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBoYWxmVGhldGEgPSBNYXRoLmF0YW4yKCBzaW5IYWxmVGhldGEsIGNvc0hhbGZUaGV0YSApO1xcblxcdFxcdFxcdHZhciByYXRpb0EgPSBNYXRoLnNpbiggKCAxIC0gdCApICogaGFsZlRoZXRhICkgLyBzaW5IYWxmVGhldGEsXFxuXFx0XFx0XFx0XFx0cmF0aW9CID0gTWF0aC5zaW4oIHQgKiBoYWxmVGhldGEgKSAvIHNpbkhhbGZUaGV0YTtcXG5cXG5cXHRcXHRcXHR0aGlzLl93ID0gKCB3ICogcmF0aW9BICsgdGhpcy5fdyAqIHJhdGlvQiApO1xcblxcdFxcdFxcdHRoaXMuX3ggPSAoIHggKiByYXRpb0EgKyB0aGlzLl94ICogcmF0aW9CICk7XFxuXFx0XFx0XFx0dGhpcy5feSA9ICggeSAqIHJhdGlvQSArIHRoaXMuX3kgKiByYXRpb0IgKTtcXG5cXHRcXHRcXHR0aGlzLl96ID0gKCB6ICogcmF0aW9BICsgdGhpcy5feiAqIHJhdGlvQiApO1xcblxcblxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHF1YXRlcm5pb24gKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuICggcXVhdGVybmlvbi5feCA9PT0gdGhpcy5feCApICYmICggcXVhdGVybmlvbi5feSA9PT0gdGhpcy5feSApICYmICggcXVhdGVybmlvbi5feiA9PT0gdGhpcy5feiApICYmICggcXVhdGVybmlvbi5fdyA9PT0gdGhpcy5fdyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XFxuXFxuXFx0XFx0XFx0dGhpcy5feCA9IGFycmF5WyBvZmZzZXQgXTtcXG5cXHRcXHRcXHR0aGlzLl95ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcXG5cXHRcXHRcXHR0aGlzLl96ID0gYXJyYXlbIG9mZnNldCArIDIgXTtcXG5cXHRcXHRcXHR0aGlzLl93ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcXG5cXG5cXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xcblxcdFxcdFxcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xcblxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMuX3g7XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRoaXMuX3k7XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuX3o7XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMuX3c7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGFycmF5O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0b25DaGFuZ2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gY2FsbGJhY2s7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRvbkNoYW5nZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3Iga2lsZSAvIGh0dHA6Ly9raWxlLnN0cmF2YWdhbnphLm9yZy9cXG5cXHQgKiBAYXV0aG9yIHBoaWxvZ2IgLyBodHRwOi8vYmxvZy50aGVqaXQub3JnL1xcblxcdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXFxuXFx0ICogQGF1dGhvciBlZ3JhZXRoZXIgLyBodHRwOi8vZWdyYWV0aGVyLmNvbS9cXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBWZWN0b3IzKCB4LCB5LCB6ICkge1xcblxcblxcdFxcdHRoaXMueCA9IHggfHwgMDtcXG5cXHRcXHR0aGlzLnkgPSB5IHx8IDA7XFxuXFx0XFx0dGhpcy56ID0geiB8fCAwO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBWZWN0b3IzLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGlzVmVjdG9yMzogdHJ1ZSxcXG5cXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSB4O1xcblxcdFxcdFxcdHRoaXMueSA9IHk7XFxuXFx0XFx0XFx0dGhpcy56ID0gejtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gc2NhbGFyO1xcblxcdFxcdFxcdHRoaXMueSA9IHNjYWxhcjtcXG5cXHRcXHRcXHR0aGlzLnogPSBzY2FsYXI7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRYOiBmdW5jdGlvbiAoIHggKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0geDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFk6IGZ1bmN0aW9uICggeSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnkgPSB5O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0WjogZnVuY3Rpb24gKCB6ICkge1xcblxcblxcdFxcdFxcdHRoaXMueiA9IHo7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uICggaW5kZXgsIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHN3aXRjaCAoIGluZGV4ICkge1xcblxcblxcdFxcdFxcdFxcdGNhc2UgMDogdGhpcy54ID0gdmFsdWU7IGJyZWFrO1xcblxcdFxcdFxcdFxcdGNhc2UgMTogdGhpcy55ID0gdmFsdWU7IGJyZWFrO1xcblxcdFxcdFxcdFxcdGNhc2UgMjogdGhpcy56ID0gdmFsdWU7IGJyZWFrO1xcblxcdFxcdFxcdFxcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4ICkge1xcblxcblxcdFxcdFxcdHN3aXRjaCAoIGluZGV4ICkge1xcblxcblxcdFxcdFxcdFxcdGNhc2UgMDogcmV0dXJuIHRoaXMueDtcXG5cXHRcXHRcXHRcXHRjYXNlIDE6IHJldHVybiB0aGlzLnk7XFxuXFx0XFx0XFx0XFx0Y2FzZSAyOiByZXR1cm4gdGhpcy56O1xcblxcdFxcdFxcdFxcdGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvciggJ2luZGV4IGlzIG91dCBvZiByYW5nZTogJyArIGluZGV4ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMueCwgdGhpcy55LCB0aGlzLnogKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSB2Lng7XFxuXFx0XFx0XFx0dGhpcy55ID0gdi55O1xcblxcdFxcdFxcdHRoaXMueiA9IHYuejtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xcblxcblxcdFxcdFxcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLnggKz0gdi54O1xcblxcdFxcdFxcdHRoaXMueSArPSB2Lnk7XFxuXFx0XFx0XFx0dGhpcy56ICs9IHYuejtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFkZFNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xcblxcblxcdFxcdFxcdHRoaXMueCArPSBzO1xcblxcdFxcdFxcdHRoaXMueSArPSBzO1xcblxcdFxcdFxcdHRoaXMueiArPSBzO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YWRkVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IGEueCArIGIueDtcXG5cXHRcXHRcXHR0aGlzLnkgPSBhLnkgKyBiLnk7XFxuXFx0XFx0XFx0dGhpcy56ID0gYS56ICsgYi56O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ICs9IHYueCAqIHM7XFxuXFx0XFx0XFx0dGhpcy55ICs9IHYueSAqIHM7XFxuXFx0XFx0XFx0dGhpcy56ICs9IHYueiAqIHM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy54IC09IHYueDtcXG5cXHRcXHRcXHR0aGlzLnkgLT0gdi55O1xcblxcdFxcdFxcdHRoaXMueiAtPSB2Lno7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzdWJTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggLT0gcztcXG5cXHRcXHRcXHR0aGlzLnkgLT0gcztcXG5cXHRcXHRcXHR0aGlzLnogLT0gcztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHN1YlZlY3RvcnM6IGZ1bmN0aW9uICggYSwgYiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBhLnggLSBiLng7XFxuXFx0XFx0XFx0dGhpcy55ID0gYS55IC0gYi55O1xcblxcdFxcdFxcdHRoaXMueiA9IGEueiAtIGIuejtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG11bHRpcGx5OiBmdW5jdGlvbiAoIHYsIHcgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB3ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLm11bHRpcGx5KCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAubXVsdGlwbHlWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMubXVsdGlwbHlWZWN0b3JzKCB2LCB3ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMueCAqPSB2Lng7XFxuXFx0XFx0XFx0dGhpcy55ICo9IHYueTtcXG5cXHRcXHRcXHR0aGlzLnogKj0gdi56O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xcblxcblxcdFxcdFxcdHRoaXMueCAqPSBzY2FsYXI7XFxuXFx0XFx0XFx0dGhpcy55ICo9IHNjYWxhcjtcXG5cXHRcXHRcXHR0aGlzLnogKj0gc2NhbGFyO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bXVsdGlwbHlWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gYS54ICogYi54O1xcblxcdFxcdFxcdHRoaXMueSA9IGEueSAqIGIueTtcXG5cXHRcXHRcXHR0aGlzLnogPSBhLnogKiBiLno7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhcHBseUV1bGVyOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHF1YXRlcm5pb24gPSBuZXcgUXVhdGVybmlvbigpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBhcHBseUV1bGVyKCBldWxlciApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoICEgKCBldWxlciAmJiBldWxlci5pc0V1bGVyICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5hcHBseUV1bGVyKCkgbm93IGV4cGVjdHMgYW4gRXVsZXIgcm90YXRpb24gcmF0aGVyIHRoYW4gYSBWZWN0b3IzIGFuZCBvcmRlci4nICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbi5zZXRGcm9tRXVsZXIoIGV1bGVyICkgKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRhcHBseUF4aXNBbmdsZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlBeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmFwcGx5UXVhdGVybmlvbiggcXVhdGVybmlvbi5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0YXBwbHlNYXRyaXgzOiBmdW5jdGlvbiAoIG0gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XFxuXFx0XFx0XFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyAzIF0gKiB5ICsgZVsgNiBdICogejtcXG5cXHRcXHRcXHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNCBdICogeSArIGVbIDcgXSAqIHo7XFxuXFx0XFx0XFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDUgXSAqIHkgKyBlWyA4IF0gKiB6O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XFxuXFx0XFx0XFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHZhciB3ID0gMSAvICggZVsgMyBdICogeCArIGVbIDcgXSAqIHkgKyBlWyAxMSBdICogeiArIGVbIDE1IF0gKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSAoIGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKSAqIHc7XFxuXFx0XFx0XFx0dGhpcy55ID0gKCBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHogKyBlWyAxMyBdICkgKiB3O1xcblxcdFxcdFxcdHRoaXMueiA9ICggZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogeiArIGVbIDE0IF0gKSAqIHc7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhcHBseVF1YXRlcm5pb246IGZ1bmN0aW9uICggcSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgeCA9IHRoaXMueCwgeSA9IHRoaXMueSwgeiA9IHRoaXMuejtcXG5cXHRcXHRcXHR2YXIgcXggPSBxLngsIHF5ID0gcS55LCBxeiA9IHEueiwgcXcgPSBxLnc7XFxuXFxuXFx0XFx0XFx0Ly8gY2FsY3VsYXRlIHF1YXQgKiB2ZWN0b3JcXG5cXG5cXHRcXHRcXHR2YXIgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHk7XFxuXFx0XFx0XFx0dmFyIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6O1xcblxcdFxcdFxcdHZhciBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeDtcXG5cXHRcXHRcXHR2YXIgaXcgPSAtIHF4ICogeCAtIHF5ICogeSAtIHF6ICogejtcXG5cXG5cXHRcXHRcXHQvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gaXggKiBxdyArIGl3ICogLSBxeCArIGl5ICogLSBxeiAtIGl6ICogLSBxeTtcXG5cXHRcXHRcXHR0aGlzLnkgPSBpeSAqIHF3ICsgaXcgKiAtIHF5ICsgaXogKiAtIHF4IC0gaXggKiAtIHF6O1xcblxcdFxcdFxcdHRoaXMueiA9IGl6ICogcXcgKyBpdyAqIC0gcXogKyBpeCAqIC0gcXkgLSBpeSAqIC0gcXg7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwcm9qZWN0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHByb2plY3QoIGNhbWVyYSApIHtcXG5cXG5cXHRcXHRcXHRcXHRtYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLnByb2plY3Rpb25NYXRyaXgsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEubWF0cml4V29ybGQgKSApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmFwcGx5TWF0cml4NCggbWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0dW5wcm9qZWN0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHVucHJvamVjdCggY2FtZXJhICkge1xcblxcblxcdFxcdFxcdFxcdG1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBjYW1lcmEubWF0cml4V29ybGQsIG1hdHJpeC5nZXRJbnZlcnNlKCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHR0cmFuc2Zvcm1EaXJlY3Rpb246IGZ1bmN0aW9uICggbSApIHtcXG5cXG5cXHRcXHRcXHQvLyBpbnB1dDogVEhSRUUuTWF0cml4NCBhZmZpbmUgbWF0cml4XFxuXFx0XFx0XFx0Ly8gdmVjdG9yIGludGVycHJldGVkIGFzIGEgZGlyZWN0aW9uXFxuXFxuXFx0XFx0XFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLno7XFxuXFx0XFx0XFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogejtcXG5cXHRcXHRcXHR0aGlzLnkgPSBlWyAxIF0gKiB4ICsgZVsgNSBdICogeSArIGVbIDkgXSAqIHo7XFxuXFx0XFx0XFx0dGhpcy56ID0gZVsgMiBdICogeCArIGVbIDYgXSAqIHkgKyBlWyAxMCBdICogejtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRpdmlkZTogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHRoaXMueCAvPSB2Lng7XFxuXFx0XFx0XFx0dGhpcy55IC89IHYueTtcXG5cXHRcXHRcXHR0aGlzLnogLz0gdi56O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGl2aWRlU2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tdWx0aXBseVNjYWxhciggMSAvIHNjYWxhciApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XFxuXFx0XFx0XFx0dGhpcy56ID0gTWF0aC5taW4oIHRoaXMueiwgdi56ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtYXg6IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcXG5cXHRcXHRcXHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcXG5cXHRcXHRcXHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xcblxcblxcdFxcdFxcdC8vIGFzc3VtZXMgbWluIDwgbWF4LCBjb21wb25lbnR3aXNlXFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XFxuXFx0XFx0XFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbGFtcFNjYWxhcjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBtaW4gPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciBtYXggPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBjbGFtcFNjYWxhciggbWluVmFsLCBtYXhWYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bWluLnNldCggbWluVmFsLCBtaW5WYWwsIG1pblZhbCApO1xcblxcdFxcdFxcdFxcdG1heC5zZXQoIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRjbGFtcExlbmd0aDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIGxlbmd0aCB8fCAxICkubXVsdGlwbHlTY2FsYXIoIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGxlbmd0aCApICkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGZsb29yOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XFxuXFx0XFx0XFx0dGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjZWlsOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcXG5cXHRcXHRcXHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xcblxcdFxcdFxcdHRoaXMueiA9IE1hdGguY2VpbCggdGhpcy56ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyb3VuZDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IE1hdGgucm91bmQoIHRoaXMueCApO1xcblxcdFxcdFxcdHRoaXMueSA9IE1hdGgucm91bmQoIHRoaXMueSApO1xcblxcdFxcdFxcdHRoaXMueiA9IE1hdGgucm91bmQoIHRoaXMueiApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cm91bmRUb1plcm86IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSAoIHRoaXMueCA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy54ICkgOiBNYXRoLmZsb29yKCB0aGlzLnggKTtcXG5cXHRcXHRcXHR0aGlzLnkgPSAoIHRoaXMueSA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy55ICkgOiBNYXRoLmZsb29yKCB0aGlzLnkgKTtcXG5cXHRcXHRcXHR0aGlzLnogPSAoIHRoaXMueiA8IDAgKSA/IE1hdGguY2VpbCggdGhpcy56ICkgOiBNYXRoLmZsb29yKCB0aGlzLnogKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG5lZ2F0ZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IC0gdGhpcy54O1xcblxcdFxcdFxcdHRoaXMueSA9IC0gdGhpcy55O1xcblxcdFxcdFxcdHRoaXMueiA9IC0gdGhpcy56O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZG90OiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueSArIHRoaXMueiAqIHYuejtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIFRPRE8gbGVuZ3RoU3F1YXJlZD9cXG5cXG5cXHRcXHRsZW5ndGhTcTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLno7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRsZW5ndGg6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkgKyB0aGlzLnogKiB0aGlzLnogKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG1hbmhhdHRhbkxlbmd0aDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBNYXRoLmFicyggdGhpcy54ICkgKyBNYXRoLmFicyggdGhpcy55ICkgKyBNYXRoLmFicyggdGhpcy56ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIHRoaXMubGVuZ3RoKCkgfHwgMSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0TGVuZ3RoOiBmdW5jdGlvbiAoIGxlbmd0aCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5ub3JtYWxpemUoKS5tdWx0aXBseVNjYWxhciggbGVuZ3RoICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRsZXJwOiBmdW5jdGlvbiAoIHYsIGFscGhhICkge1xcblxcblxcdFxcdFxcdHRoaXMueCArPSAoIHYueCAtIHRoaXMueCApICogYWxwaGE7XFxuXFx0XFx0XFx0dGhpcy55ICs9ICggdi55IC0gdGhpcy55ICkgKiBhbHBoYTtcXG5cXHRcXHRcXHR0aGlzLnogKz0gKCB2LnogLSB0aGlzLnogKSAqIGFscGhhO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bGVycFZlY3RvcnM6IGZ1bmN0aW9uICggdjEsIHYyLCBhbHBoYSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjcm9zczogZnVuY3Rpb24gKCB2LCB3ICkge1xcblxcblxcdFxcdFxcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5jcm9zcygpIG5vdyBvbmx5IGFjY2VwdHMgb25lIGFyZ3VtZW50LiBVc2UgLmNyb3NzVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmNyb3NzVmVjdG9ycyggdiwgdyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5jcm9zc1ZlY3RvcnMoIHRoaXMsIHYgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNyb3NzVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xcblxcblxcdFxcdFxcdHZhciBheCA9IGEueCwgYXkgPSBhLnksIGF6ID0gYS56O1xcblxcdFxcdFxcdHZhciBieCA9IGIueCwgYnkgPSBiLnksIGJ6ID0gYi56O1xcblxcblxcdFxcdFxcdHRoaXMueCA9IGF5ICogYnogLSBheiAqIGJ5O1xcblxcdFxcdFxcdHRoaXMueSA9IGF6ICogYnggLSBheCAqIGJ6O1xcblxcdFxcdFxcdHRoaXMueiA9IGF4ICogYnkgLSBheSAqIGJ4O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cHJvamVjdE9uVmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcXG5cXG5cXHRcXHRcXHR2YXIgc2NhbGFyID0gdmVjdG9yLmRvdCggdGhpcyApIC8gdmVjdG9yLmxlbmd0aFNxKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuY29weSggdmVjdG9yICkubXVsdGlwbHlTY2FsYXIoIHNjYWxhciApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cHJvamVjdE9uUGxhbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBwcm9qZWN0T25QbGFuZSggcGxhbmVOb3JtYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0djEuY29weSggdGhpcyApLnByb2plY3RPblZlY3RvciggcGxhbmVOb3JtYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5zdWIoIHYxICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0cmVmbGVjdDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIHJlZmxlY3QgaW5jaWRlbnQgdmVjdG9yIG9mZiBwbGFuZSBvcnRob2dvbmFsIHRvIG5vcm1hbFxcblxcdFxcdFxcdC8vIG5vcm1hbCBpcyBhc3N1bWVkIHRvIGhhdmUgdW5pdCBsZW5ndGhcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiByZWZsZWN0KCBub3JtYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuc3ViKCB2MS5jb3B5KCBub3JtYWwgKS5tdWx0aXBseVNjYWxhciggMiAqIHRoaXMuZG90KCBub3JtYWwgKSApICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0YW5nbGVUbzogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHZhciB0aGV0YSA9IHRoaXMuZG90KCB2ICkgLyAoIE1hdGguc3FydCggdGhpcy5sZW5ndGhTcSgpICogdi5sZW5ndGhTcSgpICkgKTtcXG5cXG5cXHRcXHRcXHQvLyBjbGFtcCwgdG8gaGFuZGxlIG51bWVyaWNhbCBwcm9ibGVtc1xcblxcblxcdFxcdFxcdHJldHVybiBNYXRoLmFjb3MoIF9NYXRoLmNsYW1wKCB0aGV0YSwgLSAxLCAxICkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5zcXJ0KCB0aGlzLmRpc3RhbmNlVG9TcXVhcmVkKCB2ICkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRpc3RhbmNlVG9TcXVhcmVkOiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGR4ID0gdGhpcy54IC0gdi54LCBkeSA9IHRoaXMueSAtIHYueSwgZHogPSB0aGlzLnogLSB2Lno7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ICsgZHogKiBkejtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG1hbmhhdHRhbkRpc3RhbmNlVG86IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCAtIHYueCApICsgTWF0aC5hYnMoIHRoaXMueSAtIHYueSApICsgTWF0aC5hYnMoIHRoaXMueiAtIHYueiApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbVNwaGVyaWNhbDogZnVuY3Rpb24gKCBzICkge1xcblxcblxcdFxcdFxcdHZhciBzaW5QaGlSYWRpdXMgPSBNYXRoLnNpbiggcy5waGkgKSAqIHMucmFkaXVzO1xcblxcblxcdFxcdFxcdHRoaXMueCA9IHNpblBoaVJhZGl1cyAqIE1hdGguc2luKCBzLnRoZXRhICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gTWF0aC5jb3MoIHMucGhpICkgKiBzLnJhZGl1cztcXG5cXHRcXHRcXHR0aGlzLnogPSBzaW5QaGlSYWRpdXMgKiBNYXRoLmNvcyggcy50aGV0YSApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbUN5bGluZHJpY2FsOiBmdW5jdGlvbiAoIGMgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gYy5yYWRpdXMgKiBNYXRoLnNpbiggYy50aGV0YSApO1xcblxcdFxcdFxcdHRoaXMueSA9IGMueTtcXG5cXHRcXHRcXHR0aGlzLnogPSBjLnJhZGl1cyAqIE1hdGguY29zKCBjLnRoZXRhICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tTWF0cml4UG9zaXRpb246IGZ1bmN0aW9uICggbSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZSA9IG0uZWxlbWVudHM7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gZVsgMTIgXTtcXG5cXHRcXHRcXHR0aGlzLnkgPSBlWyAxMyBdO1xcblxcdFxcdFxcdHRoaXMueiA9IGVbIDE0IF07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tTWF0cml4U2NhbGU6IGZ1bmN0aW9uICggbSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgc3ggPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDAgKS5sZW5ndGgoKTtcXG5cXHRcXHRcXHR2YXIgc3kgPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDEgKS5sZW5ndGgoKTtcXG5cXHRcXHRcXHR2YXIgc3ogPSB0aGlzLnNldEZyb21NYXRyaXhDb2x1bW4oIG0sIDIgKS5sZW5ndGgoKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBzeDtcXG5cXHRcXHRcXHR0aGlzLnkgPSBzeTtcXG5cXHRcXHRcXHR0aGlzLnogPSBzejtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZyb21NYXRyaXhDb2x1bW46IGZ1bmN0aW9uICggbSwgaW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZnJvbUFycmF5KCBtLmVsZW1lbnRzLCBpbmRleCAqIDQgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGVxdWFsczogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdHJldHVybiAoICggdi54ID09PSB0aGlzLnggKSAmJiAoIHYueSA9PT0gdGhpcy55ICkgJiYgKCB2LnogPT09IHRoaXMueiApICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBhcnJheVsgb2Zmc2V0IF07XFxuXFx0XFx0XFx0dGhpcy55ID0gYXJyYXlbIG9mZnNldCArIDEgXTtcXG5cXHRcXHRcXHR0aGlzLnogPSBhcnJheVsgb2Zmc2V0ICsgMiBdO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dG9BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdGlmICggYXJyYXkgPT09IHVuZGVmaW5lZCApIGFycmF5ID0gW107XFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XFxuXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCBdID0gdGhpcy54O1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLnk7XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRoaXMuejtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYXJyYXk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmcm9tQnVmZmVyQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIG9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IG9mZnNldCBoYXMgYmVlbiByZW1vdmVkIGZyb20gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS4nICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xcblxcdFxcdFxcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xcblxcdFxcdFxcdHRoaXMueiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXG5cXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIE1hdHJpeDMoKSB7XFxuXFxuXFx0XFx0dGhpcy5lbGVtZW50cyA9IFtcXG5cXG5cXHRcXHRcXHQxLCAwLCAwLFxcblxcdFxcdFxcdDAsIDEsIDAsXFxuXFx0XFx0XFx0MCwgMCwgMVxcblxcblxcdFxcdF07XFxuXFxuXFx0XFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoID4gMCApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4MzogdGhlIGNvbnN0cnVjdG9yIG5vIGxvbmdlciByZWFkcyBhcmd1bWVudHMuIHVzZSAuc2V0KCkgaW5zdGVhZC4nICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBNYXRyaXgzLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGlzTWF0cml4MzogdHJ1ZSxcXG5cXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggbjExLCBuMTIsIG4xMywgbjIxLCBuMjIsIG4yMywgbjMxLCBuMzIsIG4zMyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHRlWyAwIF0gPSBuMTE7IHRlWyAxIF0gPSBuMjE7IHRlWyAyIF0gPSBuMzE7XFxuXFx0XFx0XFx0dGVbIDMgXSA9IG4xMjsgdGVbIDQgXSA9IG4yMjsgdGVbIDUgXSA9IG4zMjtcXG5cXHRcXHRcXHR0ZVsgNiBdID0gbjEzOyB0ZVsgNyBdID0gbjIzOyB0ZVsgOCBdID0gbjMzO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0aWRlbnRpdHk6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnNldChcXG5cXG5cXHRcXHRcXHRcXHQxLCAwLCAwLFxcblxcdFxcdFxcdFxcdDAsIDEsIDAsXFxuXFx0XFx0XFx0XFx0MCwgMCwgMVxcblxcblxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmZyb21BcnJheSggdGhpcy5lbGVtZW50cyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBtICkge1xcblxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxuXFx0XFx0XFx0dmFyIG1lID0gbS5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR0ZVsgMCBdID0gbWVbIDAgXTsgdGVbIDEgXSA9IG1lWyAxIF07IHRlWyAyIF0gPSBtZVsgMiBdO1xcblxcdFxcdFxcdHRlWyAzIF0gPSBtZVsgMyBdOyB0ZVsgNCBdID0gbWVbIDQgXTsgdGVbIDUgXSA9IG1lWyA1IF07XFxuXFx0XFx0XFx0dGVbIDYgXSA9IG1lWyA2IF07IHRlWyA3IF0gPSBtZVsgNyBdOyB0ZVsgOCBdID0gbWVbIDggXTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZyb21NYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG1lID0gbS5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR0aGlzLnNldChcXG5cXG5cXHRcXHRcXHRcXHRtZVsgMCBdLCBtZVsgNCBdLCBtZVsgOCBdLFxcblxcdFxcdFxcdFxcdG1lWyAxIF0sIG1lWyA1IF0sIG1lWyA5IF0sXFxuXFx0XFx0XFx0XFx0bWVbIDIgXSwgbWVbIDYgXSwgbWVbIDEwIF1cXG5cXG5cXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YXBwbHlUb0J1ZmZlckF0dHJpYnV0ZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhdHRyaWJ1dGUuY291bnQ7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHYxLnggPSBhdHRyaWJ1dGUuZ2V0WCggaSApO1xcblxcdFxcdFxcdFxcdFxcdHYxLnkgPSBhdHRyaWJ1dGUuZ2V0WSggaSApO1xcblxcdFxcdFxcdFxcdFxcdHYxLnogPSBhdHRyaWJ1dGUuZ2V0WiggaSApO1xcblxcblxcdFxcdFxcdFxcdFxcdHYxLmFwcGx5TWF0cml4MyggdGhpcyApO1xcblxcblxcdFxcdFxcdFxcdFxcdGF0dHJpYnV0ZS5zZXRYWVooIGksIHYxLngsIHYxLnksIHYxLnogKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGF0dHJpYnV0ZTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRtdWx0aXBseTogZnVuY3Rpb24gKCBtICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLm11bHRpcGx5TWF0cmljZXMoIHRoaXMsIG0gKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHByZW11bHRpcGx5OiBmdW5jdGlvbiAoIG0gKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubXVsdGlwbHlNYXRyaWNlcyggbSwgdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bXVsdGlwbHlNYXRyaWNlczogZnVuY3Rpb24gKCBhLCBiICkge1xcblxcblxcdFxcdFxcdHZhciBhZSA9IGEuZWxlbWVudHM7XFxuXFx0XFx0XFx0dmFyIGJlID0gYi5lbGVtZW50cztcXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHZhciBhMTEgPSBhZVsgMCBdLCBhMTIgPSBhZVsgMyBdLCBhMTMgPSBhZVsgNiBdO1xcblxcdFxcdFxcdHZhciBhMjEgPSBhZVsgMSBdLCBhMjIgPSBhZVsgNCBdLCBhMjMgPSBhZVsgNyBdO1xcblxcdFxcdFxcdHZhciBhMzEgPSBhZVsgMiBdLCBhMzIgPSBhZVsgNSBdLCBhMzMgPSBhZVsgOCBdO1xcblxcblxcdFxcdFxcdHZhciBiMTEgPSBiZVsgMCBdLCBiMTIgPSBiZVsgMyBdLCBiMTMgPSBiZVsgNiBdO1xcblxcdFxcdFxcdHZhciBiMjEgPSBiZVsgMSBdLCBiMjIgPSBiZVsgNCBdLCBiMjMgPSBiZVsgNyBdO1xcblxcdFxcdFxcdHZhciBiMzEgPSBiZVsgMiBdLCBiMzIgPSBiZVsgNSBdLCBiMzMgPSBiZVsgOCBdO1xcblxcblxcdFxcdFxcdHRlWyAwIF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzE7XFxuXFx0XFx0XFx0dGVbIDMgXSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMjtcXG5cXHRcXHRcXHR0ZVsgNiBdID0gYTExICogYjEzICsgYTEyICogYjIzICsgYTEzICogYjMzO1xcblxcblxcdFxcdFxcdHRlWyAxIF0gPSBhMjEgKiBiMTEgKyBhMjIgKiBiMjEgKyBhMjMgKiBiMzE7XFxuXFx0XFx0XFx0dGVbIDQgXSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMjtcXG5cXHRcXHRcXHR0ZVsgNyBdID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzO1xcblxcblxcdFxcdFxcdHRlWyAyIF0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzE7XFxuXFx0XFx0XFx0dGVbIDUgXSA9IGEzMSAqIGIxMiArIGEzMiAqIGIyMiArIGEzMyAqIGIzMjtcXG5cXHRcXHRcXHR0ZVsgOCBdID0gYTMxICogYjEzICsgYTMyICogYjIzICsgYTMzICogYjMzO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHRlWyAwIF0gKj0gczsgdGVbIDMgXSAqPSBzOyB0ZVsgNiBdICo9IHM7XFxuXFx0XFx0XFx0dGVbIDEgXSAqPSBzOyB0ZVsgNCBdICo9IHM7IHRlWyA3IF0gKj0gcztcXG5cXHRcXHRcXHR0ZVsgMiBdICo9IHM7IHRlWyA1IF0gKj0gczsgdGVbIDggXSAqPSBzO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHZhciBhID0gdGVbIDAgXSwgYiA9IHRlWyAxIF0sIGMgPSB0ZVsgMiBdLFxcblxcdFxcdFxcdFxcdGQgPSB0ZVsgMyBdLCBlID0gdGVbIDQgXSwgZiA9IHRlWyA1IF0sXFxuXFx0XFx0XFx0XFx0ZyA9IHRlWyA2IF0sIGggPSB0ZVsgNyBdLCBpID0gdGVbIDggXTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYSAqIGUgKiBpIC0gYSAqIGYgKiBoIC0gYiAqIGQgKiBpICsgYiAqIGYgKiBnICsgYyAqIGQgKiBoIC0gYyAqIGUgKiBnO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0SW52ZXJzZTogZnVuY3Rpb24gKCBtYXRyaXgsIHRocm93T25EZWdlbmVyYXRlICkge1xcblxcblxcdFxcdFxcdGlmICggbWF0cml4ICYmIG1hdHJpeC5pc01hdHJpeDQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggXFxcIlRIUkVFLk1hdHJpeDM6IC5nZXRJbnZlcnNlKCkgbm8gbG9uZ2VyIHRha2VzIGEgTWF0cml4NCBhcmd1bWVudC5cXFwiICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBtZSA9IG1hdHJpeC5lbGVtZW50cyxcXG5cXHRcXHRcXHRcXHR0ZSA9IHRoaXMuZWxlbWVudHMsXFxuXFxuXFx0XFx0XFx0XFx0bjExID0gbWVbIDAgXSwgbjIxID0gbWVbIDEgXSwgbjMxID0gbWVbIDIgXSxcXG5cXHRcXHRcXHRcXHRuMTIgPSBtZVsgMyBdLCBuMjIgPSBtZVsgNCBdLCBuMzIgPSBtZVsgNSBdLFxcblxcdFxcdFxcdFxcdG4xMyA9IG1lWyA2IF0sIG4yMyA9IG1lWyA3IF0sIG4zMyA9IG1lWyA4IF0sXFxuXFxuXFx0XFx0XFx0XFx0dDExID0gbjMzICogbjIyIC0gbjMyICogbjIzLFxcblxcdFxcdFxcdFxcdHQxMiA9IG4zMiAqIG4xMyAtIG4zMyAqIG4xMixcXG5cXHRcXHRcXHRcXHR0MTMgPSBuMjMgKiBuMTIgLSBuMjIgKiBuMTMsXFxuXFxuXFx0XFx0XFx0XFx0ZGV0ID0gbjExICogdDExICsgbjIxICogdDEyICsgbjMxICogdDEzO1xcblxcblxcdFxcdFxcdGlmICggZGV0ID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBtc2cgPSBcXFwiVEhSRUUuTWF0cml4MzogLmdldEludmVyc2UoKSBjYW4ndCBpbnZlcnQgbWF0cml4LCBkZXRlcm1pbmFudCBpcyAwXFxcIjtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRocm93T25EZWdlbmVyYXRlID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggbXNnICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oIG1zZyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5pZGVudGl0eSgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgZGV0SW52ID0gMSAvIGRldDtcXG5cXG5cXHRcXHRcXHR0ZVsgMCBdID0gdDExICogZGV0SW52O1xcblxcdFxcdFxcdHRlWyAxIF0gPSAoIG4zMSAqIG4yMyAtIG4zMyAqIG4yMSApICogZGV0SW52O1xcblxcdFxcdFxcdHRlWyAyIF0gPSAoIG4zMiAqIG4yMSAtIG4zMSAqIG4yMiApICogZGV0SW52O1xcblxcblxcdFxcdFxcdHRlWyAzIF0gPSB0MTIgKiBkZXRJbnY7XFxuXFx0XFx0XFx0dGVbIDQgXSA9ICggbjMzICogbjExIC0gbjMxICogbjEzICkgKiBkZXRJbnY7XFxuXFx0XFx0XFx0dGVbIDUgXSA9ICggbjMxICogbjEyIC0gbjMyICogbjExICkgKiBkZXRJbnY7XFxuXFxuXFx0XFx0XFx0dGVbIDYgXSA9IHQxMyAqIGRldEludjtcXG5cXHRcXHRcXHR0ZVsgNyBdID0gKCBuMjEgKiBuMTMgLSBuMjMgKiBuMTEgKSAqIGRldEludjtcXG5cXHRcXHRcXHR0ZVsgOCBdID0gKCBuMjIgKiBuMTEgLSBuMjEgKiBuMTIgKSAqIGRldEludjtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRyYW5zcG9zZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB0bXAsIG0gPSB0aGlzLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHRtcCA9IG1bIDEgXTsgbVsgMSBdID0gbVsgMyBdOyBtWyAzIF0gPSB0bXA7XFxuXFx0XFx0XFx0dG1wID0gbVsgMiBdOyBtWyAyIF0gPSBtWyA2IF07IG1bIDYgXSA9IHRtcDtcXG5cXHRcXHRcXHR0bXAgPSBtWyA1IF07IG1bIDUgXSA9IG1bIDcgXTsgbVsgNyBdID0gdG1wO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0Tm9ybWFsTWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeDQgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeDQoIG1hdHJpeDQgKS5nZXRJbnZlcnNlKCB0aGlzICkudHJhbnNwb3NlKCk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0cmFuc3Bvc2VJbnRvQXJyYXk6IGZ1bmN0aW9uICggciApIHtcXG5cXG5cXHRcXHRcXHR2YXIgbSA9IHRoaXMuZWxlbWVudHM7XFxuXFxuXFx0XFx0XFx0clsgMCBdID0gbVsgMCBdO1xcblxcdFxcdFxcdHJbIDEgXSA9IG1bIDMgXTtcXG5cXHRcXHRcXHRyWyAyIF0gPSBtWyA2IF07XFxuXFx0XFx0XFx0clsgMyBdID0gbVsgMSBdO1xcblxcdFxcdFxcdHJbIDQgXSA9IG1bIDQgXTtcXG5cXHRcXHRcXHRyWyA1IF0gPSBtWyA3IF07XFxuXFx0XFx0XFx0clsgNiBdID0gbVsgMiBdO1xcblxcdFxcdFxcdHJbIDcgXSA9IG1bIDUgXTtcXG5cXHRcXHRcXHRyWyA4IF0gPSBtWyA4IF07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRVdlRyYW5zZm9ybTogZnVuY3Rpb24gKCB0eCwgdHksIHN4LCBzeSwgcm90YXRpb24sIGN4LCBjeSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYyA9IE1hdGguY29zKCByb3RhdGlvbiApO1xcblxcdFxcdFxcdHZhciBzID0gTWF0aC5zaW4oIHJvdGF0aW9uICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5zZXQoXFxuXFx0XFx0XFx0XFx0c3ggKiBjLCBzeCAqIHMsIC0gc3ggKiAoIGMgKiBjeCArIHMgKiBjeSApICsgY3ggKyB0eCxcXG5cXHRcXHRcXHRcXHQtIHN5ICogcywgc3kgKiBjLCAtIHN5ICogKCAtIHMgKiBjeCArIGMgKiBjeSApICsgY3kgKyB0eSxcXG5cXHRcXHRcXHRcXHQwLCAwLCAxXFxuXFx0XFx0XFx0KTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNjYWxlOiBmdW5jdGlvbiAoIHN4LCBzeSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHRlWyAwIF0gKj0gc3g7IHRlWyAzIF0gKj0gc3g7IHRlWyA2IF0gKj0gc3g7XFxuXFx0XFx0XFx0dGVbIDEgXSAqPSBzeTsgdGVbIDQgXSAqPSBzeTsgdGVbIDcgXSAqPSBzeTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHJvdGF0ZTogZnVuY3Rpb24gKCB0aGV0YSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYyA9IE1hdGguY29zKCB0aGV0YSApO1xcblxcdFxcdFxcdHZhciBzID0gTWF0aC5zaW4oIHRoZXRhICk7XFxuXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR2YXIgYTExID0gdGVbIDAgXSwgYTEyID0gdGVbIDMgXSwgYTEzID0gdGVbIDYgXTtcXG5cXHRcXHRcXHR2YXIgYTIxID0gdGVbIDEgXSwgYTIyID0gdGVbIDQgXSwgYTIzID0gdGVbIDcgXTtcXG5cXG5cXHRcXHRcXHR0ZVsgMCBdID0gYyAqIGExMSArIHMgKiBhMjE7XFxuXFx0XFx0XFx0dGVbIDMgXSA9IGMgKiBhMTIgKyBzICogYTIyO1xcblxcdFxcdFxcdHRlWyA2IF0gPSBjICogYTEzICsgcyAqIGEyMztcXG5cXG5cXHRcXHRcXHR0ZVsgMSBdID0gLSBzICogYTExICsgYyAqIGEyMTtcXG5cXHRcXHRcXHR0ZVsgNCBdID0gLSBzICogYTEyICsgYyAqIGEyMjtcXG5cXHRcXHRcXHR0ZVsgNyBdID0gLSBzICogYTEzICsgYyAqIGEyMztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCB0eCwgdHkgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRlID0gdGhpcy5lbGVtZW50cztcXG5cXG5cXHRcXHRcXHR0ZVsgMCBdICs9IHR4ICogdGVbIDIgXTsgdGVbIDMgXSArPSB0eCAqIHRlWyA1IF07IHRlWyA2IF0gKz0gdHggKiB0ZVsgOCBdO1xcblxcdFxcdFxcdHRlWyAxIF0gKz0gdHkgKiB0ZVsgMiBdOyB0ZVsgNCBdICs9IHR5ICogdGVbIDUgXTsgdGVbIDcgXSArPSB0eSAqIHRlWyA4IF07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRlcXVhbHM6IGZ1bmN0aW9uICggbWF0cml4ICkge1xcblxcblxcdFxcdFxcdHZhciB0ZSA9IHRoaXMuZWxlbWVudHM7XFxuXFx0XFx0XFx0dmFyIG1lID0gbWF0cml4LmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IDk7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0ZVsgaSBdICE9PSBtZVsgaSBdICkgcmV0dXJuIGZhbHNlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IDk7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5lbGVtZW50c1sgaSBdID0gYXJyYXlbIGkgKyBvZmZzZXQgXTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcXG5cXHRcXHRcXHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHR2YXIgdGUgPSB0aGlzLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgXSA9IHRlWyAwIF07XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDEgXSA9IHRlWyAxIF07XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDIgXSA9IHRlWyAyIF07XFxuXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRlWyAzIF07XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDQgXSA9IHRlWyA0IF07XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDUgXSA9IHRlWyA1IF07XFxuXFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDYgXSA9IHRlWyA2IF07XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDcgXSA9IHRlWyA3IF07XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDggXSA9IHRlWyA4IF07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGFycmF5O1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqIEBhdXRob3Igc3ppbWVrIC8gaHR0cHM6Ly9naXRodWIuY29tL3N6aW1lay9cXG5cXHQgKi9cXG5cXG5cXHR2YXIgdGV4dHVyZUlkID0gMDtcXG5cXG5cXHRmdW5jdGlvbiBUZXh0dXJlKCBpbWFnZSwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyApIHtcXG5cXG5cXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IHRleHR1cmVJZCArKyB9ICk7XFxuXFxuXFx0XFx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XFxuXFxuXFx0XFx0dGhpcy5uYW1lID0gJyc7XFxuXFxuXFx0XFx0dGhpcy5pbWFnZSA9IGltYWdlICE9PSB1bmRlZmluZWQgPyBpbWFnZSA6IFRleHR1cmUuREVGQVVMVF9JTUFHRTtcXG5cXHRcXHR0aGlzLm1pcG1hcHMgPSBbXTtcXG5cXG5cXHRcXHR0aGlzLm1hcHBpbmcgPSBtYXBwaW5nICE9PSB1bmRlZmluZWQgPyBtYXBwaW5nIDogVGV4dHVyZS5ERUZBVUxUX01BUFBJTkc7XFxuXFxuXFx0XFx0dGhpcy53cmFwUyA9IHdyYXBTICE9PSB1bmRlZmluZWQgPyB3cmFwUyA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XFxuXFx0XFx0dGhpcy53cmFwVCA9IHdyYXBUICE9PSB1bmRlZmluZWQgPyB3cmFwVCA6IENsYW1wVG9FZGdlV3JhcHBpbmc7XFxuXFxuXFx0XFx0dGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1hZ0ZpbHRlciA6IExpbmVhckZpbHRlcjtcXG5cXHRcXHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogTGluZWFyTWlwTWFwTGluZWFyRmlsdGVyO1xcblxcblxcdFxcdHRoaXMuYW5pc290cm9weSA9IGFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCA/IGFuaXNvdHJvcHkgOiAxO1xcblxcblxcdFxcdHRoaXMuZm9ybWF0ID0gZm9ybWF0ICE9PSB1bmRlZmluZWQgPyBmb3JtYXQgOiBSR0JBRm9ybWF0O1xcblxcdFxcdHRoaXMudHlwZSA9IHR5cGUgIT09IHVuZGVmaW5lZCA/IHR5cGUgOiBVbnNpZ25lZEJ5dGVUeXBlO1xcblxcblxcdFxcdHRoaXMub2Zmc2V0ID0gbmV3IFZlY3RvcjIoIDAsIDAgKTtcXG5cXHRcXHR0aGlzLnJlcGVhdCA9IG5ldyBWZWN0b3IyKCAxLCAxICk7XFxuXFx0XFx0dGhpcy5jZW50ZXIgPSBuZXcgVmVjdG9yMiggMCwgMCApO1xcblxcdFxcdHRoaXMucm90YXRpb24gPSAwO1xcblxcblxcdFxcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XFxuXFx0XFx0dGhpcy5tYXRyaXggPSBuZXcgTWF0cml4MygpO1xcblxcblxcdFxcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gdHJ1ZTtcXG5cXHRcXHR0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLmZsaXBZID0gdHJ1ZTtcXG5cXHRcXHR0aGlzLnVucGFja0FsaWdubWVudCA9IDQ7XFx0Ly8gdmFsaWQgdmFsdWVzOiAxLCAyLCA0LCA4IChzZWUgaHR0cDovL3d3dy5raHJvbm9zLm9yZy9vcGVuZ2xlcy9zZGsvZG9jcy9tYW4veGh0bWwvZ2xQaXhlbFN0b3JlaS54bWwpXFxuXFxuXFx0XFx0Ly8gVmFsdWVzIG9mIGVuY29kaW5nICE9PSBUSFJFRS5MaW5lYXJFbmNvZGluZyBvbmx5IHN1cHBvcnRlZCBvbiBtYXAsIGVudk1hcCBhbmQgZW1pc3NpdmVNYXAuXFxuXFx0XFx0Ly9cXG5cXHRcXHQvLyBBbHNvIGNoYW5naW5nIHRoZSBlbmNvZGluZyBhZnRlciBhbHJlYWR5IHVzZWQgYnkgYSBNYXRlcmlhbCB3aWxsIG5vdCBhdXRvbWF0aWNhbGx5IG1ha2UgdGhlIE1hdGVyaWFsXFxuXFx0XFx0Ly8gdXBkYXRlLiAgWW91IG5lZWQgdG8gZXhwbGljaXRseSBjYWxsIE1hdGVyaWFsLm5lZWRzVXBkYXRlIHRvIHRyaWdnZXIgaXQgdG8gcmVjb21waWxlLlxcblxcdFxcdHRoaXMuZW5jb2RpbmcgPSBlbmNvZGluZyAhPT0gdW5kZWZpbmVkID8gZW5jb2RpbmcgOiBMaW5lYXJFbmNvZGluZztcXG5cXG5cXHRcXHR0aGlzLnZlcnNpb24gPSAwO1xcblxcdFxcdHRoaXMub25VcGRhdGUgPSBudWxsO1xcblxcblxcdH1cXG5cXG5cXHRUZXh0dXJlLkRFRkFVTFRfSU1BR0UgPSB1bmRlZmluZWQ7XFxuXFx0VGV4dHVyZS5ERUZBVUxUX01BUFBJTkcgPSBVVk1hcHBpbmc7XFxuXFxuXFx0VGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogVGV4dHVyZSxcXG5cXG5cXHRcXHRpc1RleHR1cmU6IHRydWUsXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcXG5cXG5cXHRcXHRcXHR0aGlzLmltYWdlID0gc291cmNlLmltYWdlO1xcblxcdFxcdFxcdHRoaXMubWlwbWFwcyA9IHNvdXJjZS5taXBtYXBzLnNsaWNlKCAwICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5tYXBwaW5nID0gc291cmNlLm1hcHBpbmc7XFxuXFxuXFx0XFx0XFx0dGhpcy53cmFwUyA9IHNvdXJjZS53cmFwUztcXG5cXHRcXHRcXHR0aGlzLndyYXBUID0gc291cmNlLndyYXBUO1xcblxcblxcdFxcdFxcdHRoaXMubWFnRmlsdGVyID0gc291cmNlLm1hZ0ZpbHRlcjtcXG5cXHRcXHRcXHR0aGlzLm1pbkZpbHRlciA9IHNvdXJjZS5taW5GaWx0ZXI7XFxuXFxuXFx0XFx0XFx0dGhpcy5hbmlzb3Ryb3B5ID0gc291cmNlLmFuaXNvdHJvcHk7XFxuXFxuXFx0XFx0XFx0dGhpcy5mb3JtYXQgPSBzb3VyY2UuZm9ybWF0O1xcblxcdFxcdFxcdHRoaXMudHlwZSA9IHNvdXJjZS50eXBlO1xcblxcblxcdFxcdFxcdHRoaXMub2Zmc2V0LmNvcHkoIHNvdXJjZS5vZmZzZXQgKTtcXG5cXHRcXHRcXHR0aGlzLnJlcGVhdC5jb3B5KCBzb3VyY2UucmVwZWF0ICk7XFxuXFx0XFx0XFx0dGhpcy5jZW50ZXIuY29weSggc291cmNlLmNlbnRlciApO1xcblxcdFxcdFxcdHRoaXMucm90YXRpb24gPSBzb3VyY2Uucm90YXRpb247XFxuXFxuXFx0XFx0XFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gc291cmNlLm1hdHJpeEF1dG9VcGRhdGU7XFxuXFx0XFx0XFx0dGhpcy5tYXRyaXguY29weSggc291cmNlLm1hdHJpeCApO1xcblxcblxcdFxcdFxcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzID0gc291cmNlLmdlbmVyYXRlTWlwbWFwcztcXG5cXHRcXHRcXHR0aGlzLnByZW11bHRpcGx5QWxwaGEgPSBzb3VyY2UucHJlbXVsdGlwbHlBbHBoYTtcXG5cXHRcXHRcXHR0aGlzLmZsaXBZID0gc291cmNlLmZsaXBZO1xcblxcdFxcdFxcdHRoaXMudW5wYWNrQWxpZ25tZW50ID0gc291cmNlLnVucGFja0FsaWdubWVudDtcXG5cXHRcXHRcXHR0aGlzLmVuY29kaW5nID0gc291cmNlLmVuY29kaW5nO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGlzUm9vdE9iamVjdCA9ICggbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJyApO1xcblxcblxcdFxcdFxcdGlmICggISBpc1Jvb3RPYmplY3QgJiYgbWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF0gIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gbWV0YS50ZXh0dXJlc1sgdGhpcy51dWlkIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGdldERhdGFVUkwoIGltYWdlICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBjYW52YXM7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpbWFnZSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNhbnZhcyA9IGltYWdlO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdjYW52YXMnICk7XFxuXFx0XFx0XFx0XFx0XFx0Y2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGg7XFxuXFx0XFx0XFx0XFx0XFx0Y2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBpbWFnZSBpbnN0YW5jZW9mIEltYWdlRGF0YSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjb250ZXh0LnB1dEltYWdlRGF0YSggaW1hZ2UsIDAsIDAgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBjYW52YXMud2lkdGggPiAyMDQ4IHx8IGNhbnZhcy5oZWlnaHQgPiAyMDQ4ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBjYW52YXMudG9EYXRhVVJMKCAnaW1hZ2UvanBlZycsIDAuNiApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoICdpbWFnZS9wbmcnICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgb3V0cHV0ID0ge1xcblxcdFxcdFxcdFxcdG1ldGFkYXRhOiB7XFxuXFx0XFx0XFx0XFx0XFx0dmVyc2lvbjogNC41LFxcblxcdFxcdFxcdFxcdFxcdHR5cGU6ICdUZXh0dXJlJyxcXG5cXHRcXHRcXHRcXHRcXHRnZW5lcmF0b3I6ICdUZXh0dXJlLnRvSlNPTidcXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdHV1aWQ6IHRoaXMudXVpZCxcXG5cXHRcXHRcXHRcXHRuYW1lOiB0aGlzLm5hbWUsXFxuXFxuXFx0XFx0XFx0XFx0bWFwcGluZzogdGhpcy5tYXBwaW5nLFxcblxcblxcdFxcdFxcdFxcdHJlcGVhdDogWyB0aGlzLnJlcGVhdC54LCB0aGlzLnJlcGVhdC55IF0sXFxuXFx0XFx0XFx0XFx0b2Zmc2V0OiBbIHRoaXMub2Zmc2V0LngsIHRoaXMub2Zmc2V0LnkgXSxcXG5cXHRcXHRcXHRcXHRjZW50ZXI6IFsgdGhpcy5jZW50ZXIueCwgdGhpcy5jZW50ZXIueSBdLFxcblxcdFxcdFxcdFxcdHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxcblxcblxcdFxcdFxcdFxcdHdyYXA6IFsgdGhpcy53cmFwUywgdGhpcy53cmFwVCBdLFxcblxcblxcdFxcdFxcdFxcdG1pbkZpbHRlcjogdGhpcy5taW5GaWx0ZXIsXFxuXFx0XFx0XFx0XFx0bWFnRmlsdGVyOiB0aGlzLm1hZ0ZpbHRlcixcXG5cXHRcXHRcXHRcXHRhbmlzb3Ryb3B5OiB0aGlzLmFuaXNvdHJvcHksXFxuXFxuXFx0XFx0XFx0XFx0ZmxpcFk6IHRoaXMuZmxpcFlcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5pbWFnZSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdC8vIFRPRE86IE1vdmUgdG8gVEhSRUUuSW1hZ2VcXG5cXG5cXHRcXHRcXHRcXHR2YXIgaW1hZ2UgPSB0aGlzLmltYWdlO1xcblxcblxcdFxcdFxcdFxcdGlmICggaW1hZ2UudXVpZCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGltYWdlLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTsgLy8gVUdIXFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggISBpc1Jvb3RPYmplY3QgJiYgbWV0YS5pbWFnZXNbIGltYWdlLnV1aWQgXSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG1ldGEuaW1hZ2VzWyBpbWFnZS51dWlkIF0gPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dXVpZDogaW1hZ2UudXVpZCxcXG5cXHRcXHRcXHRcXHRcXHRcXHR1cmw6IGdldERhdGFVUkwoIGltYWdlIClcXG5cXHRcXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRvdXRwdXQuaW1hZ2UgPSBpbWFnZS51dWlkO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoICEgaXNSb290T2JqZWN0ICkge1xcblxcblxcdFxcdFxcdFxcdG1ldGEudGV4dHVyZXNbIHRoaXMudXVpZCBdID0gb3V0cHV0O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gb3V0cHV0O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dHJhbnNmb3JtVXY6IGZ1bmN0aW9uICggdXYgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLm1hcHBpbmcgIT09IFVWTWFwcGluZyApIHJldHVybjtcXG5cXG5cXHRcXHRcXHR1di5hcHBseU1hdHJpeDMoIHRoaXMubWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0aWYgKCB1di54IDwgMCB8fCB1di54ID4gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRzd2l0Y2ggKCB0aGlzLndyYXBTICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgUmVwZWF0V3JhcHBpbmc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dXYueCA9IHV2LnggLSBNYXRoLmZsb29yKCB1di54ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSBDbGFtcFRvRWRnZVdyYXBwaW5nOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHV2LnggPSB1di54IDwgMCA/IDAgOiAxO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgTWlycm9yZWRSZXBlYXRXcmFwcGluZzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIE1hdGguYWJzKCBNYXRoLmZsb29yKCB1di54ICkgJSAyICkgPT09IDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dXYueCA9IE1hdGguY2VpbCggdXYueCApIC0gdXYueDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHV2LnggPSB1di54IC0gTWF0aC5mbG9vciggdXYueCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdXYueSA8IDAgfHwgdXYueSA+IDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c3dpdGNoICggdGhpcy53cmFwVCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlIFJlcGVhdFdyYXBwaW5nOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHV2LnkgPSB1di55IC0gTWF0aC5mbG9vciggdXYueSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgQ2xhbXBUb0VkZ2VXcmFwcGluZzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR1di55ID0gdXYueSA8IDAgPyAwIDogMTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlIE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBNYXRoLmFicyggTWF0aC5mbG9vciggdXYueSApICUgMiApID09PSAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHV2LnkgPSBNYXRoLmNlaWwoIHV2LnkgKSAtIHV2Lnk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR1di55ID0gdXYueSAtIE1hdGguZmxvb3IoIHV2LnkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuZmxpcFkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dXYueSA9IDEgLSB1di55O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggVGV4dHVyZS5wcm90b3R5cGUsIFxcXCJuZWVkc1VwZGF0ZVxcXCIsIHtcXG5cXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB2YWx1ZSA9PT0gdHJ1ZSApIHRoaXMudmVyc2lvbiArKztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3Igc3VwZXJlZ2diZXJ0IC8gaHR0cDovL3d3dy5wYXVsYnJ1bnQuY28udWsvXFxuXFx0ICogQGF1dGhvciBwaGlsb2diIC8gaHR0cDovL2Jsb2cudGhlaml0Lm9yZy9cXG5cXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xcblxcdCAqIEBhdXRob3IgZWdyYWV0aGVyIC8gaHR0cDovL2VncmFldGhlci5jb20vXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gVmVjdG9yNCggeCwgeSwgeiwgdyApIHtcXG5cXG5cXHRcXHR0aGlzLnggPSB4IHx8IDA7XFxuXFx0XFx0dGhpcy55ID0geSB8fCAwO1xcblxcdFxcdHRoaXMueiA9IHogfHwgMDtcXG5cXHRcXHR0aGlzLncgPSAoIHcgIT09IHVuZGVmaW5lZCApID8gdyA6IDE7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIFZlY3RvcjQucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0aXNWZWN0b3I0OiB0cnVlLFxcblxcblxcdFxcdHNldDogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IHg7XFxuXFx0XFx0XFx0dGhpcy55ID0geTtcXG5cXHRcXHRcXHR0aGlzLnogPSB6O1xcblxcdFxcdFxcdHRoaXMudyA9IHc7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IHNjYWxhcjtcXG5cXHRcXHRcXHR0aGlzLnkgPSBzY2FsYXI7XFxuXFx0XFx0XFx0dGhpcy56ID0gc2NhbGFyO1xcblxcdFxcdFxcdHRoaXMudyA9IHNjYWxhcjtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFg6IGZ1bmN0aW9uICggeCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSB4O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0WTogZnVuY3Rpb24gKCB5ICkge1xcblxcblxcdFxcdFxcdHRoaXMueSA9IHk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRaOiBmdW5jdGlvbiAoIHogKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy56ID0gejtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFc6IGZ1bmN0aW9uICggdyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLncgPSB3O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoIGluZGV4LCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRzd2l0Y2ggKCBpbmRleCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIDA6IHRoaXMueCA9IHZhbHVlOyBicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIDE6IHRoaXMueSA9IHZhbHVlOyBicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIDI6IHRoaXMueiA9IHZhbHVlOyBicmVhaztcXG5cXHRcXHRcXHRcXHRjYXNlIDM6IHRoaXMudyA9IHZhbHVlOyBicmVhaztcXG5cXHRcXHRcXHRcXHRkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoICdpbmRleCBpcyBvdXQgb2YgcmFuZ2U6ICcgKyBpbmRleCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldENvbXBvbmVudDogZnVuY3Rpb24gKCBpbmRleCApIHtcXG5cXG5cXHRcXHRcXHRzd2l0Y2ggKCBpbmRleCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIDA6IHJldHVybiB0aGlzLng7XFxuXFx0XFx0XFx0XFx0Y2FzZSAxOiByZXR1cm4gdGhpcy55O1xcblxcdFxcdFxcdFxcdGNhc2UgMjogcmV0dXJuIHRoaXMuejtcXG5cXHRcXHRcXHRcXHRjYXNlIDM6IHJldHVybiB0aGlzLnc7XFxuXFx0XFx0XFx0XFx0ZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCAnaW5kZXggaXMgb3V0IG9mIHJhbmdlOiAnICsgaW5kZXggKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gdi54O1xcblxcdFxcdFxcdHRoaXMueSA9IHYueTtcXG5cXHRcXHRcXHR0aGlzLnogPSB2Lno7XFxuXFx0XFx0XFx0dGhpcy53ID0gKCB2LncgIT09IHVuZGVmaW5lZCApID8gdi53IDogMTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFkZDogZnVuY3Rpb24gKCB2LCB3ICkge1xcblxcblxcdFxcdFxcdGlmICggdyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjQ6IC5hZGQoKSBub3cgb25seSBhY2NlcHRzIG9uZSBhcmd1bWVudC4gVXNlIC5hZGRWZWN0b3JzKCBhLCBiICkgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuYWRkVmVjdG9ycyggdiwgdyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLnggKz0gdi54O1xcblxcdFxcdFxcdHRoaXMueSArPSB2Lnk7XFxuXFx0XFx0XFx0dGhpcy56ICs9IHYuejtcXG5cXHRcXHRcXHR0aGlzLncgKz0gdi53O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YWRkU2NhbGFyOiBmdW5jdGlvbiAoIHMgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ICs9IHM7XFxuXFx0XFx0XFx0dGhpcy55ICs9IHM7XFxuXFx0XFx0XFx0dGhpcy56ICs9IHM7XFxuXFx0XFx0XFx0dGhpcy53ICs9IHM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhZGRWZWN0b3JzOiBmdW5jdGlvbiAoIGEsIGIgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gYS54ICsgYi54O1xcblxcdFxcdFxcdHRoaXMueSA9IGEueSArIGIueTtcXG5cXHRcXHRcXHR0aGlzLnogPSBhLnogKyBiLno7XFxuXFx0XFx0XFx0dGhpcy53ID0gYS53ICsgYi53O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YWRkU2NhbGVkVmVjdG9yOiBmdW5jdGlvbiAoIHYsIHMgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ICs9IHYueCAqIHM7XFxuXFx0XFx0XFx0dGhpcy55ICs9IHYueSAqIHM7XFxuXFx0XFx0XFx0dGhpcy56ICs9IHYueiAqIHM7XFxuXFx0XFx0XFx0dGhpcy53ICs9IHYudyAqIHM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzdWI6IGZ1bmN0aW9uICggdiwgdyApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHcgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3I0OiAuc3ViKCkgbm93IG9ubHkgYWNjZXB0cyBvbmUgYXJndW1lbnQuIFVzZSAuc3ViVmVjdG9ycyggYSwgYiApIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnN1YlZlY3RvcnMoIHYsIHcgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy54IC09IHYueDtcXG5cXHRcXHRcXHR0aGlzLnkgLT0gdi55O1xcblxcdFxcdFxcdHRoaXMueiAtPSB2Lno7XFxuXFx0XFx0XFx0dGhpcy53IC09IHYudztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHN1YlNjYWxhcjogZnVuY3Rpb24gKCBzICkge1xcblxcblxcdFxcdFxcdHRoaXMueCAtPSBzO1xcblxcdFxcdFxcdHRoaXMueSAtPSBzO1xcblxcdFxcdFxcdHRoaXMueiAtPSBzO1xcblxcdFxcdFxcdHRoaXMudyAtPSBzO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3ViVmVjdG9yczogZnVuY3Rpb24gKCBhLCBiICkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9IGEueCAtIGIueDtcXG5cXHRcXHRcXHR0aGlzLnkgPSBhLnkgLSBiLnk7XFxuXFx0XFx0XFx0dGhpcy56ID0gYS56IC0gYi56O1xcblxcdFxcdFxcdHRoaXMudyA9IGEudyAtIGIudztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG11bHRpcGx5U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggKj0gc2NhbGFyO1xcblxcdFxcdFxcdHRoaXMueSAqPSBzY2FsYXI7XFxuXFx0XFx0XFx0dGhpcy56ICo9IHNjYWxhcjtcXG5cXHRcXHRcXHR0aGlzLncgKj0gc2NhbGFyO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG0gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHggPSB0aGlzLngsIHkgPSB0aGlzLnksIHogPSB0aGlzLnosIHcgPSB0aGlzLnc7XFxuXFx0XFx0XFx0dmFyIGUgPSBtLmVsZW1lbnRzO1xcblxcblxcdFxcdFxcdHRoaXMueCA9IGVbIDAgXSAqIHggKyBlWyA0IF0gKiB5ICsgZVsgOCBdICogeiArIGVbIDEyIF0gKiB3O1xcblxcdFxcdFxcdHRoaXMueSA9IGVbIDEgXSAqIHggKyBlWyA1IF0gKiB5ICsgZVsgOSBdICogeiArIGVbIDEzIF0gKiB3O1xcblxcdFxcdFxcdHRoaXMueiA9IGVbIDIgXSAqIHggKyBlWyA2IF0gKiB5ICsgZVsgMTAgXSAqIHogKyBlWyAxNCBdICogdztcXG5cXHRcXHRcXHR0aGlzLncgPSBlWyAzIF0gKiB4ICsgZVsgNyBdICogeSArIGVbIDExIF0gKiB6ICsgZVsgMTUgXSAqIHc7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXZpZGVTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLm11bHRpcGx5U2NhbGFyKCAxIC8gc2NhbGFyICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRBeGlzQW5nbGVGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xcblxcblxcdFxcdFxcdC8vIGh0dHA6Ly93d3cuZXVjbGlkZWFuc3BhY2UuY29tL21hdGhzL2dlb21ldHJ5L3JvdGF0aW9ucy9jb252ZXJzaW9ucy9xdWF0ZXJuaW9uVG9BbmdsZS9pbmRleC5odG1cXG5cXG5cXHRcXHRcXHQvLyBxIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZFxcblxcblxcdFxcdFxcdHRoaXMudyA9IDIgKiBNYXRoLmFjb3MoIHEudyApO1xcblxcblxcdFxcdFxcdHZhciBzID0gTWF0aC5zcXJ0KCAxIC0gcS53ICogcS53ICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBzIDwgMC4wMDAxICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMueCA9IDE7XFxuXFx0XFx0XFx0XFx0dGhpcy55ID0gMDtcXG5cXHRcXHRcXHRcXHR0aGlzLnogPSAwO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy54ID0gcS54IC8gcztcXG5cXHRcXHRcXHRcXHR0aGlzLnkgPSBxLnkgLyBzO1xcblxcdFxcdFxcdFxcdHRoaXMueiA9IHEueiAvIHM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0QXhpc0FuZ2xlRnJvbVJvdGF0aW9uTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XFxuXFxuXFx0XFx0XFx0Ly8gaHR0cDovL3d3dy5ldWNsaWRlYW5zcGFjZS5jb20vbWF0aHMvZ2VvbWV0cnkvcm90YXRpb25zL2NvbnZlcnNpb25zL21hdHJpeFRvQW5nbGUvaW5kZXguaHRtXFxuXFxuXFx0XFx0XFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcXG5cXG5cXHRcXHRcXHR2YXIgYW5nbGUsIHgsIHksIHosXFx0XFx0Ly8gdmFyaWFibGVzIGZvciByZXN1bHRcXG5cXHRcXHRcXHRcXHRlcHNpbG9uID0gMC4wMSxcXHRcXHQvLyBtYXJnaW4gdG8gYWxsb3cgZm9yIHJvdW5kaW5nIGVycm9yc1xcblxcdFxcdFxcdFxcdGVwc2lsb24yID0gMC4xLFxcdFxcdC8vIG1hcmdpbiB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIDAgYW5kIDE4MCBkZWdyZWVzXFxuXFxuXFx0XFx0XFx0XFx0dGUgPSBtLmVsZW1lbnRzLFxcblxcblxcdFxcdFxcdFxcdG0xMSA9IHRlWyAwIF0sIG0xMiA9IHRlWyA0IF0sIG0xMyA9IHRlWyA4IF0sXFxuXFx0XFx0XFx0XFx0bTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXSxcXG5cXHRcXHRcXHRcXHRtMzEgPSB0ZVsgMiBdLCBtMzIgPSB0ZVsgNiBdLCBtMzMgPSB0ZVsgMTAgXTtcXG5cXG5cXHRcXHRcXHRpZiAoICggTWF0aC5hYnMoIG0xMiAtIG0yMSApIDwgZXBzaWxvbiApICYmXFxuXFx0XFx0XFx0ICAgICAoIE1hdGguYWJzKCBtMTMgLSBtMzEgKSA8IGVwc2lsb24gKSAmJlxcblxcdFxcdFxcdCAgICAgKCBNYXRoLmFicyggbTIzIC0gbTMyICkgPCBlcHNpbG9uICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gc2luZ3VsYXJpdHkgZm91bmRcXG5cXHRcXHRcXHRcXHQvLyBmaXJzdCBjaGVjayBmb3IgaWRlbnRpdHkgbWF0cml4IHdoaWNoIG11c3QgaGF2ZSArMSBmb3IgYWxsIHRlcm1zXFxuXFx0XFx0XFx0XFx0Ly8gaW4gbGVhZGluZyBkaWFnb25hbCBhbmQgemVybyBpbiBvdGhlciB0ZXJtc1xcblxcblxcdFxcdFxcdFxcdGlmICggKCBNYXRoLmFicyggbTEyICsgbTIxICkgPCBlcHNpbG9uMiApICYmXFxuXFx0XFx0XFx0XFx0ICAgICAoIE1hdGguYWJzKCBtMTMgKyBtMzEgKSA8IGVwc2lsb24yICkgJiZcXG5cXHRcXHRcXHRcXHQgICAgICggTWF0aC5hYnMoIG0yMyArIG0zMiApIDwgZXBzaWxvbjIgKSAmJlxcblxcdFxcdFxcdFxcdCAgICAgKCBNYXRoLmFicyggbTExICsgbTIyICsgbTMzIC0gMyApIDwgZXBzaWxvbjIgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyB0aGlzIHNpbmd1bGFyaXR5IGlzIGlkZW50aXR5IG1hdHJpeCBzbyBhbmdsZSA9IDBcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnNldCggMSwgMCwgMCwgMCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzOyAvLyB6ZXJvIGFuZ2xlLCBhcmJpdHJhcnkgYXhpc1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBvdGhlcndpc2UgdGhpcyBzaW5ndWxhcml0eSBpcyBhbmdsZSA9IDE4MFxcblxcblxcdFxcdFxcdFxcdGFuZ2xlID0gTWF0aC5QSTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgeHggPSAoIG0xMSArIDEgKSAvIDI7XFxuXFx0XFx0XFx0XFx0dmFyIHl5ID0gKCBtMjIgKyAxICkgLyAyO1xcblxcdFxcdFxcdFxcdHZhciB6eiA9ICggbTMzICsgMSApIC8gMjtcXG5cXHRcXHRcXHRcXHR2YXIgeHkgPSAoIG0xMiArIG0yMSApIC8gNDtcXG5cXHRcXHRcXHRcXHR2YXIgeHogPSAoIG0xMyArIG0zMSApIC8gNDtcXG5cXHRcXHRcXHRcXHR2YXIgeXogPSAoIG0yMyArIG0zMiApIC8gNDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoICggeHggPiB5eSApICYmICggeHggPiB6eiApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIG0xMSBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB4eCA8IGVwc2lsb24gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0eCA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0eSA9IDAuNzA3MTA2NzgxO1xcblxcdFxcdFxcdFxcdFxcdFxcdHogPSAwLjcwNzEwNjc4MTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHggPSBNYXRoLnNxcnQoIHh4ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0eSA9IHh5IC8geDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6ID0geHogLyB4O1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCB5eSA+IHp6ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIG0yMiBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtXFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB5eSA8IGVwc2lsb24gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0eCA9IDAuNzA3MTA2NzgxO1xcblxcdFxcdFxcdFxcdFxcdFxcdHkgPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdHogPSAwLjcwNzEwNjc4MTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHkgPSBNYXRoLnNxcnQoIHl5ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0eCA9IHh5IC8geTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR6ID0geXogLyB5O1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIG0zMyBpcyB0aGUgbGFyZ2VzdCBkaWFnb25hbCB0ZXJtIHNvIGJhc2UgcmVzdWx0IG9uIHRoaXNcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHp6IDwgZXBzaWxvbiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR4ID0gMC43MDcxMDY3ODE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0eSA9IDAuNzA3MTA2NzgxO1xcblxcdFxcdFxcdFxcdFxcdFxcdHogPSAwO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0eiA9IE1hdGguc3FydCggenogKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR4ID0geHogLyB6O1xcblxcdFxcdFxcdFxcdFxcdFxcdHkgPSB5eiAvIHo7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnNldCggeCwgeSwgeiwgYW5nbGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpczsgLy8gcmV0dXJuIDE4MCBkZWcgcm90YXRpb25cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gYXMgd2UgaGF2ZSByZWFjaGVkIGhlcmUgdGhlcmUgYXJlIG5vIHNpbmd1bGFyaXRpZXMgc28gd2UgY2FuIGhhbmRsZSBub3JtYWxseVxcblxcblxcdFxcdFxcdHZhciBzID0gTWF0aC5zcXJ0KCAoIG0zMiAtIG0yMyApICogKCBtMzIgLSBtMjMgKSArXFxuXFx0XFx0XFx0ICAgICAgICAgICAgICAgICAgICggbTEzIC0gbTMxICkgKiAoIG0xMyAtIG0zMSApICtcXG5cXHRcXHRcXHQgICAgICAgICAgICAgICAgICAgKCBtMjEgLSBtMTIgKSAqICggbTIxIC0gbTEyICkgKTsgLy8gdXNlZCB0byBub3JtYWxpemVcXG5cXG5cXHRcXHRcXHRpZiAoIE1hdGguYWJzKCBzICkgPCAwLjAwMSApIHMgPSAxO1xcblxcblxcdFxcdFxcdC8vIHByZXZlbnQgZGl2aWRlIGJ5IHplcm8sIHNob3VsZCBub3QgaGFwcGVuIGlmIG1hdHJpeCBpcyBvcnRob2dvbmFsIGFuZCBzaG91bGQgYmVcXG5cXHRcXHRcXHQvLyBjYXVnaHQgYnkgc2luZ3VsYXJpdHkgdGVzdCBhYm92ZSwgYnV0IEkndmUgbGVmdCBpdCBpbiBqdXN0IGluIGNhc2VcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSAoIG0zMiAtIG0yMyApIC8gcztcXG5cXHRcXHRcXHR0aGlzLnkgPSAoIG0xMyAtIG0zMSApIC8gcztcXG5cXHRcXHRcXHR0aGlzLnogPSAoIG0yMSAtIG0xMiApIC8gcztcXG5cXHRcXHRcXHR0aGlzLncgPSBNYXRoLmFjb3MoICggbTExICsgbTIyICsgbTMzIC0gMSApIC8gMiApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWluOiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gTWF0aC5taW4oIHRoaXMueCwgdi54ICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gTWF0aC5taW4oIHRoaXMueSwgdi55ICk7XFxuXFx0XFx0XFx0dGhpcy56ID0gTWF0aC5taW4oIHRoaXMueiwgdi56ICk7XFxuXFx0XFx0XFx0dGhpcy53ID0gTWF0aC5taW4oIHRoaXMudywgdi53ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtYXg6IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggPSBNYXRoLm1heCggdGhpcy54LCB2LnggKTtcXG5cXHRcXHRcXHR0aGlzLnkgPSBNYXRoLm1heCggdGhpcy55LCB2LnkgKTtcXG5cXHRcXHRcXHR0aGlzLnogPSBNYXRoLm1heCggdGhpcy56LCB2LnogKTtcXG5cXHRcXHRcXHR0aGlzLncgPSBNYXRoLm1heCggdGhpcy53LCB2LncgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsYW1wOiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xcblxcblxcdFxcdFxcdC8vIGFzc3VtZXMgbWluIDwgbWF4LCBjb21wb25lbnR3aXNlXFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gTWF0aC5tYXgoIG1pbi54LCBNYXRoLm1pbiggbWF4LngsIHRoaXMueCApICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gTWF0aC5tYXgoIG1pbi55LCBNYXRoLm1pbiggbWF4LnksIHRoaXMueSApICk7XFxuXFx0XFx0XFx0dGhpcy56ID0gTWF0aC5tYXgoIG1pbi56LCBNYXRoLm1pbiggbWF4LnosIHRoaXMueiApICk7XFxuXFx0XFx0XFx0dGhpcy53ID0gTWF0aC5tYXgoIG1pbi53LCBNYXRoLm1pbiggbWF4LncsIHRoaXMudyApICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbGFtcFNjYWxhcjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBtaW4sIG1heDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gY2xhbXBTY2FsYXIoIG1pblZhbCwgbWF4VmFsICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggbWluID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bWluID0gbmV3IFZlY3RvcjQoKTtcXG5cXHRcXHRcXHRcXHRcXHRtYXggPSBuZXcgVmVjdG9yNCgpO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRtaW4uc2V0KCBtaW5WYWwsIG1pblZhbCwgbWluVmFsLCBtaW5WYWwgKTtcXG5cXHRcXHRcXHRcXHRtYXguc2V0KCBtYXhWYWwsIG1heFZhbCwgbWF4VmFsLCBtYXhWYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5jbGFtcCggbWluLCBtYXggKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRjbGFtcExlbmd0aDogZnVuY3Rpb24gKCBtaW4sIG1heCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGgoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5kaXZpZGVTY2FsYXIoIGxlbmd0aCB8fCAxICkubXVsdGlwbHlTY2FsYXIoIE1hdGgubWF4KCBtaW4sIE1hdGgubWluKCBtYXgsIGxlbmd0aCApICkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGZsb29yOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gTWF0aC5mbG9vciggdGhpcy54ICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gTWF0aC5mbG9vciggdGhpcy55ICk7XFxuXFx0XFx0XFx0dGhpcy56ID0gTWF0aC5mbG9vciggdGhpcy56ICk7XFxuXFx0XFx0XFx0dGhpcy53ID0gTWF0aC5mbG9vciggdGhpcy53ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjZWlsOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gTWF0aC5jZWlsKCB0aGlzLnggKTtcXG5cXHRcXHRcXHR0aGlzLnkgPSBNYXRoLmNlaWwoIHRoaXMueSApO1xcblxcdFxcdFxcdHRoaXMueiA9IE1hdGguY2VpbCggdGhpcy56ICk7XFxuXFx0XFx0XFx0dGhpcy53ID0gTWF0aC5jZWlsKCB0aGlzLncgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHJvdW5kOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gTWF0aC5yb3VuZCggdGhpcy54ICk7XFxuXFx0XFx0XFx0dGhpcy55ID0gTWF0aC5yb3VuZCggdGhpcy55ICk7XFxuXFx0XFx0XFx0dGhpcy56ID0gTWF0aC5yb3VuZCggdGhpcy56ICk7XFxuXFx0XFx0XFx0dGhpcy53ID0gTWF0aC5yb3VuZCggdGhpcy53ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyb3VuZFRvWmVybzogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMueCA9ICggdGhpcy54IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnggKSA6IE1hdGguZmxvb3IoIHRoaXMueCApO1xcblxcdFxcdFxcdHRoaXMueSA9ICggdGhpcy55IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnkgKSA6IE1hdGguZmxvb3IoIHRoaXMueSApO1xcblxcdFxcdFxcdHRoaXMueiA9ICggdGhpcy56IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLnogKSA6IE1hdGguZmxvb3IoIHRoaXMueiApO1xcblxcdFxcdFxcdHRoaXMudyA9ICggdGhpcy53IDwgMCApID8gTWF0aC5jZWlsKCB0aGlzLncgKSA6IE1hdGguZmxvb3IoIHRoaXMudyApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy54ID0gLSB0aGlzLng7XFxuXFx0XFx0XFx0dGhpcy55ID0gLSB0aGlzLnk7XFxuXFx0XFx0XFx0dGhpcy56ID0gLSB0aGlzLno7XFxuXFx0XFx0XFx0dGhpcy53ID0gLSB0aGlzLnc7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkb3Q6IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55ICsgdGhpcy56ICogdi56ICsgdGhpcy53ICogdi53O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bGVuZ3RoU3E6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bGVuZ3RoOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIE1hdGguc3FydCggdGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55ICsgdGhpcy56ICogdGhpcy56ICsgdGhpcy53ICogdGhpcy53ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtYW5oYXR0YW5MZW5ndGg6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5hYnMoIHRoaXMueCApICsgTWF0aC5hYnMoIHRoaXMueSApICsgTWF0aC5hYnMoIHRoaXMueiApICsgTWF0aC5hYnMoIHRoaXMudyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZGl2aWRlU2NhbGFyKCB0aGlzLmxlbmd0aCgpIHx8IDEgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldExlbmd0aDogZnVuY3Rpb24gKCBsZW5ndGggKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIGxlbmd0aCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bGVycDogZnVuY3Rpb24gKCB2LCBhbHBoYSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnggKz0gKCB2LnggLSB0aGlzLnggKSAqIGFscGhhO1xcblxcdFxcdFxcdHRoaXMueSArPSAoIHYueSAtIHRoaXMueSApICogYWxwaGE7XFxuXFx0XFx0XFx0dGhpcy56ICs9ICggdi56IC0gdGhpcy56ICkgKiBhbHBoYTtcXG5cXHRcXHRcXHR0aGlzLncgKz0gKCB2LncgLSB0aGlzLncgKSAqIGFscGhhO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bGVycFZlY3RvcnM6IGZ1bmN0aW9uICggdjEsIHYyLCBhbHBoYSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5zdWJWZWN0b3JzKCB2MiwgdjEgKS5tdWx0aXBseVNjYWxhciggYWxwaGEgKS5hZGQoIHYxICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRlcXVhbHM6IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gKCAoIHYueCA9PT0gdGhpcy54ICkgJiYgKCB2LnkgPT09IHRoaXMueSApICYmICggdi56ID09PSB0aGlzLnogKSAmJiAoIHYudyA9PT0gdGhpcy53ICkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGZyb21BcnJheTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xcblxcblxcdFxcdFxcdHRoaXMueCA9IGFycmF5WyBvZmZzZXQgXTtcXG5cXHRcXHRcXHR0aGlzLnkgPSBhcnJheVsgb2Zmc2V0ICsgMSBdO1xcblxcdFxcdFxcdHRoaXMueiA9IGFycmF5WyBvZmZzZXQgKyAyIF07XFxuXFx0XFx0XFx0dGhpcy53ID0gYXJyYXlbIG9mZnNldCArIDMgXTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xcblxcdFxcdFxcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xcblxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMueDtcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy55O1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLno7XFxuXFx0XFx0XFx0YXJyYXlbIG9mZnNldCArIDMgXSA9IHRoaXMudztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYXJyYXk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmcm9tQnVmZmVyQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIG9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjQ6IG9mZnNldCBoYXMgYmVlbiByZW1vdmVkIGZyb20gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS4nICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMueCA9IGF0dHJpYnV0ZS5nZXRYKCBpbmRleCApO1xcblxcdFxcdFxcdHRoaXMueSA9IGF0dHJpYnV0ZS5nZXRZKCBpbmRleCApO1xcblxcdFxcdFxcdHRoaXMueiA9IGF0dHJpYnV0ZS5nZXRaKCBpbmRleCApO1xcblxcdFxcdFxcdHRoaXMudyA9IGF0dHJpYnV0ZS5nZXRXKCBpbmRleCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBzemltZWsgLyBodHRwczovL2dpdGh1Yi5jb20vc3ppbWVrL1xcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICogQGF1dGhvciBNYXJpdXMgS2ludGVsIC8gaHR0cHM6Ly9naXRodWIuY29tL2tpbnRlbFxcblxcdCAqL1xcblxcblxcdC8qXFxuXFx0IEluIG9wdGlvbnMsIHdlIGNhbiBzcGVjaWZ5OlxcblxcdCAqIFRleHR1cmUgcGFyYW1ldGVycyBmb3IgYW4gYXV0by1nZW5lcmF0ZWQgdGFyZ2V0IHRleHR1cmVcXG5cXHQgKiBkZXB0aEJ1ZmZlci9zdGVuY2lsQnVmZmVyOiBCb29sZWFucyB0byBpbmRpY2F0ZSBpZiB3ZSBzaG91bGQgZ2VuZXJhdGUgdGhlc2UgYnVmZmVyc1xcblxcdCovXFxuXFx0ZnVuY3Rpb24gV2ViR0xSZW5kZXJUYXJnZXQoIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKSB7XFxuXFxuXFx0XFx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XFxuXFxuXFx0XFx0dGhpcy53aWR0aCA9IHdpZHRoO1xcblxcdFxcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xcblxcblxcdFxcdHRoaXMuc2Npc3NvciA9IG5ldyBWZWN0b3I0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XFxuXFx0XFx0dGhpcy5zY2lzc29yVGVzdCA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMudmlld3BvcnQgPSBuZXcgVmVjdG9yNCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xcblxcblxcdFxcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcblxcdFxcdGlmICggb3B0aW9ucy5taW5GaWx0ZXIgPT09IHVuZGVmaW5lZCApIG9wdGlvbnMubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xcblxcblxcdFxcdHRoaXMudGV4dHVyZSA9IG5ldyBUZXh0dXJlKCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgb3B0aW9ucy53cmFwUywgb3B0aW9ucy53cmFwVCwgb3B0aW9ucy5tYWdGaWx0ZXIsIG9wdGlvbnMubWluRmlsdGVyLCBvcHRpb25zLmZvcm1hdCwgb3B0aW9ucy50eXBlLCBvcHRpb25zLmFuaXNvdHJvcHksIG9wdGlvbnMuZW5jb2RpbmcgKTtcXG5cXG5cXHRcXHR0aGlzLmRlcHRoQnVmZmVyID0gb3B0aW9ucy5kZXB0aEJ1ZmZlciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5kZXB0aEJ1ZmZlciA6IHRydWU7XFxuXFx0XFx0dGhpcy5zdGVuY2lsQnVmZmVyID0gb3B0aW9ucy5zdGVuY2lsQnVmZmVyICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZW5jaWxCdWZmZXIgOiB0cnVlO1xcblxcdFxcdHRoaXMuZGVwdGhUZXh0dXJlID0gb3B0aW9ucy5kZXB0aFRleHR1cmUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZGVwdGhUZXh0dXJlIDogbnVsbDtcXG5cXG5cXHR9XFxuXFxuXFx0V2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IFdlYkdMUmVuZGVyVGFyZ2V0LFxcblxcblxcdFxcdGlzV2ViR0xSZW5kZXJUYXJnZXQ6IHRydWUsXFxuXFxuXFx0XFx0c2V0U2l6ZTogZnVuY3Rpb24gKCB3aWR0aCwgaGVpZ2h0ICkge1xcblxcblxcdFxcdFxcdGlmICggdGhpcy53aWR0aCAhPT0gd2lkdGggfHwgdGhpcy5oZWlnaHQgIT09IGhlaWdodCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLndpZHRoID0gd2lkdGg7XFxuXFx0XFx0XFx0XFx0dGhpcy5oZWlnaHQgPSBoZWlnaHQ7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5kaXNwb3NlKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMudmlld3BvcnQuc2V0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XFxuXFx0XFx0XFx0dGhpcy5zY2lzc29yLnNldCggMCwgMCwgd2lkdGgsIGhlaWdodCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLndpZHRoID0gc291cmNlLndpZHRoO1xcblxcdFxcdFxcdHRoaXMuaGVpZ2h0ID0gc291cmNlLmhlaWdodDtcXG5cXG5cXHRcXHRcXHR0aGlzLnZpZXdwb3J0LmNvcHkoIHNvdXJjZS52aWV3cG9ydCApO1xcblxcblxcdFxcdFxcdHRoaXMudGV4dHVyZSA9IHNvdXJjZS50ZXh0dXJlLmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5kZXB0aEJ1ZmZlciA9IHNvdXJjZS5kZXB0aEJ1ZmZlcjtcXG5cXHRcXHRcXHR0aGlzLnN0ZW5jaWxCdWZmZXIgPSBzb3VyY2Uuc3RlbmNpbEJ1ZmZlcjtcXG5cXHRcXHRcXHR0aGlzLmRlcHRoVGV4dHVyZSA9IHNvdXJjZS5kZXB0aFRleHR1cmU7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gV2ViR0xSZW5kZXJUYXJnZXRDdWJlKCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zICkge1xcblxcblxcdFxcdFdlYkdMUmVuZGVyVGFyZ2V0LmNhbGwoIHRoaXMsIHdpZHRoLCBoZWlnaHQsIG9wdGlvbnMgKTtcXG5cXG5cXHRcXHR0aGlzLmFjdGl2ZUN1YmVGYWNlID0gMDsgLy8gUFggMCwgTlggMSwgUFkgMiwgTlkgMywgUFogNCwgTlogNVxcblxcdFxcdHRoaXMuYWN0aXZlTWlwTWFwTGV2ZWwgPSAwO1xcblxcblxcdH1cXG5cXG5cXHRXZWJHTFJlbmRlclRhcmdldEN1YmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggV2ViR0xSZW5kZXJUYXJnZXQucHJvdG90eXBlICk7XFxuXFx0V2ViR0xSZW5kZXJUYXJnZXRDdWJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdlYkdMUmVuZGVyVGFyZ2V0Q3ViZTtcXG5cXG5cXHRXZWJHTFJlbmRlclRhcmdldEN1YmUucHJvdG90eXBlLmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlID0gdHJ1ZTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIERhdGFUZXh0dXJlKCBkYXRhLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHksIGVuY29kaW5nICkge1xcblxcblxcdFxcdFRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyApO1xcblxcblxcdFxcdHRoaXMuaW1hZ2UgPSB7IGRhdGE6IGRhdGEsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcXG5cXG5cXHRcXHR0aGlzLm1hZ0ZpbHRlciA9IG1hZ0ZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWFnRmlsdGVyIDogTmVhcmVzdEZpbHRlcjtcXG5cXHRcXHR0aGlzLm1pbkZpbHRlciA9IG1pbkZpbHRlciAhPT0gdW5kZWZpbmVkID8gbWluRmlsdGVyIDogTmVhcmVzdEZpbHRlcjtcXG5cXG5cXHRcXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xcblxcdFxcdHRoaXMuZmxpcFkgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLnVucGFja0FsaWdubWVudCA9IDE7XFxuXFxuXFx0fVxcblxcblxcdERhdGFUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRleHR1cmUucHJvdG90eXBlICk7XFxuXFx0RGF0YVRleHR1cmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGF0YVRleHR1cmU7XFxuXFxuXFx0RGF0YVRleHR1cmUucHJvdG90eXBlLmlzRGF0YVRleHR1cmUgPSB0cnVlO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gQ3ViZVRleHR1cmUoIGltYWdlcywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyApIHtcXG5cXG5cXHRcXHRpbWFnZXMgPSBpbWFnZXMgIT09IHVuZGVmaW5lZCA/IGltYWdlcyA6IFtdO1xcblxcdFxcdG1hcHBpbmcgPSBtYXBwaW5nICE9PSB1bmRlZmluZWQgPyBtYXBwaW5nIDogQ3ViZVJlZmxlY3Rpb25NYXBwaW5nO1xcblxcblxcdFxcdFRleHR1cmUuY2FsbCggdGhpcywgaW1hZ2VzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHksIGVuY29kaW5nICk7XFxuXFxuXFx0XFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xcblxcblxcdH1cXG5cXG5cXHRDdWJlVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUZXh0dXJlLnByb3RvdHlwZSApO1xcblxcdEN1YmVUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1YmVUZXh0dXJlO1xcblxcblxcdEN1YmVUZXh0dXJlLnByb3RvdHlwZS5pc0N1YmVUZXh0dXJlID0gdHJ1ZTtcXG5cXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIEN1YmVUZXh0dXJlLnByb3RvdHlwZSwgJ2ltYWdlcycsIHtcXG5cXG5cXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5pbWFnZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmltYWdlID0gdmFsdWU7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxuXFx0ICpcXG5cXHQgKiBVbmlmb3JtcyBvZiBhIHByb2dyYW0uXFxuXFx0ICogVGhvc2UgZm9ybSBhIHRyZWUgc3RydWN0dXJlIHdpdGggYSBzcGVjaWFsIHRvcC1sZXZlbCBjb250YWluZXIgZm9yIHRoZSByb290LFxcblxcdCAqIHdoaWNoIHlvdSBnZXQgYnkgY2FsbGluZyAnbmV3IFdlYkdMVW5pZm9ybXMoIGdsLCBwcm9ncmFtLCByZW5kZXJlciApJy5cXG5cXHQgKlxcblxcdCAqXFxuXFx0ICogUHJvcGVydGllcyBvZiBpbm5lciBub2RlcyBpbmNsdWRpbmcgdGhlIHRvcC1sZXZlbCBjb250YWluZXI6XFxuXFx0ICpcXG5cXHQgKiAuc2VxIC0gYXJyYXkgb2YgbmVzdGVkIHVuaWZvcm1zXFxuXFx0ICogLm1hcCAtIG5lc3RlZCB1bmlmb3JtcyBieSBuYW1lXFxuXFx0ICpcXG5cXHQgKlxcblxcdCAqIE1ldGhvZHMgb2YgYWxsIG5vZGVzIGV4Y2VwdCB0aGUgdG9wLWxldmVsIGNvbnRhaW5lcjpcXG5cXHQgKlxcblxcdCAqIC5zZXRWYWx1ZSggZ2wsIHZhbHVlLCBbcmVuZGVyZXJdIClcXG5cXHQgKlxcblxcdCAqIFxcdFxcdHVwbG9hZHMgYSB1bmlmb3JtIHZhbHVlKHMpXFxuXFx0ICogIFxcdHRoZSAncmVuZGVyZXInIHBhcmFtZXRlciBpcyBuZWVkZWQgZm9yIHNhbXBsZXIgdW5pZm9ybXNcXG5cXHQgKlxcblxcdCAqXFxuXFx0ICogU3RhdGljIG1ldGhvZHMgb2YgdGhlIHRvcC1sZXZlbCBjb250YWluZXIgKHJlbmRlcmVyIGZhY3Rvcml6YXRpb25zKTpcXG5cXHQgKlxcblxcdCAqIC51cGxvYWQoIGdsLCBzZXEsIHZhbHVlcywgcmVuZGVyZXIgKVxcblxcdCAqXFxuXFx0ICogXFx0XFx0c2V0cyB1bmlmb3JtcyBpbiAnc2VxJyB0byAndmFsdWVzW2lkXS52YWx1ZSdcXG5cXHQgKlxcblxcdCAqIC5zZXFXaXRoVmFsdWUoIHNlcSwgdmFsdWVzICkgOiBmaWx0ZXJlZFNlcVxcblxcdCAqXFxuXFx0ICogXFx0XFx0ZmlsdGVycyAnc2VxJyBlbnRyaWVzIHdpdGggY29ycmVzcG9uZGluZyBlbnRyeSBpbiB2YWx1ZXNcXG5cXHQgKlxcblxcdCAqXFxuXFx0ICogTWV0aG9kcyBvZiB0aGUgdG9wLWxldmVsIGNvbnRhaW5lciAocmVuZGVyZXIgZmFjdG9yaXphdGlvbnMpOlxcblxcdCAqXFxuXFx0ICogLnNldFZhbHVlKCBnbCwgbmFtZSwgdmFsdWUgKVxcblxcdCAqXFxuXFx0ICogXFx0XFx0c2V0cyB1bmlmb3JtIHdpdGggIG5hbWUgJ25hbWUnIHRvICd2YWx1ZSdcXG5cXHQgKlxcblxcdCAqIC5zZXQoIGdsLCBvYmosIHByb3AgKVxcblxcdCAqXFxuXFx0ICogXFx0XFx0c2V0cyB1bmlmb3JtIGZyb20gb2JqZWN0IGFuZCBwcm9wZXJ0eSB3aXRoIHNhbWUgbmFtZSB0aGFuIHVuaWZvcm1cXG5cXHQgKlxcblxcdCAqIC5zZXRPcHRpb25hbCggZ2wsIG9iaiwgcHJvcCApXFxuXFx0ICpcXG5cXHQgKiBcXHRcXHRsaWtlIC5zZXQgZm9yIGFuIG9wdGlvbmFsIHByb3BlcnR5IG9mIHRoZSBvYmplY3RcXG5cXHQgKlxcblxcdCAqL1xcblxcblxcdHZhciBlbXB0eVRleHR1cmUgPSBuZXcgVGV4dHVyZSgpO1xcblxcdHZhciBlbXB0eUN1YmVUZXh0dXJlID0gbmV3IEN1YmVUZXh0dXJlKCk7XFxuXFxuXFx0Ly8gLS0tIEJhc2UgZm9yIGlubmVyIG5vZGVzIChpbmNsdWRpbmcgdGhlIHJvb3QpIC0tLVxcblxcblxcdGZ1bmN0aW9uIFVuaWZvcm1Db250YWluZXIoKSB7XFxuXFxuXFx0XFx0dGhpcy5zZXEgPSBbXTtcXG5cXHRcXHR0aGlzLm1hcCA9IHt9O1xcblxcblxcdH1cXG5cXG5cXHQvLyAtLS0gVXRpbGl0aWVzIC0tLVxcblxcblxcdC8vIEFycmF5IENhY2hlcyAocHJvdmlkZSB0eXBlZCBhcnJheXMgZm9yIHRlbXBvcmFyeSBieSBzaXplKVxcblxcblxcdHZhciBhcnJheUNhY2hlRjMyID0gW107XFxuXFx0dmFyIGFycmF5Q2FjaGVJMzIgPSBbXTtcXG5cXG5cXHQvLyBGbG9hdDMyQXJyYXkgY2FjaGVzIHVzZWQgZm9yIHVwbG9hZGluZyBNYXRyaXggdW5pZm9ybXNcXG5cXG5cXHR2YXIgbWF0NGFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggMTYgKTtcXG5cXHR2YXIgbWF0M2FycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggOSApO1xcblxcblxcdC8vIEZsYXR0ZW5pbmcgZm9yIGFycmF5cyBvZiB2ZWN0b3JzIGFuZCBtYXRyaWNlc1xcblxcblxcdGZ1bmN0aW9uIGZsYXR0ZW4oIGFycmF5LCBuQmxvY2tzLCBibG9ja1NpemUgKSB7XFxuXFxuXFx0XFx0dmFyIGZpcnN0RWxlbSA9IGFycmF5WyAwIF07XFxuXFxuXFx0XFx0aWYgKCBmaXJzdEVsZW0gPD0gMCB8fCBmaXJzdEVsZW0gPiAwICkgcmV0dXJuIGFycmF5O1xcblxcdFxcdC8vIHVub3B0aW1pemVkOiAhIGlzTmFOKCBmaXJzdEVsZW0gKVxcblxcdFxcdC8vIHNlZSBodHRwOi8vamFja3NvbmR1bnN0YW4uY29tL2FydGljbGVzLzk4M1xcblxcblxcdFxcdHZhciBuID0gbkJsb2NrcyAqIGJsb2NrU2l6ZSxcXG5cXHRcXHRcXHRyID0gYXJyYXlDYWNoZUYzMlsgbiBdO1xcblxcblxcdFxcdGlmICggciA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdHIgPSBuZXcgRmxvYXQzMkFycmF5KCBuICk7XFxuXFx0XFx0XFx0YXJyYXlDYWNoZUYzMlsgbiBdID0gcjtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBuQmxvY2tzICE9PSAwICkge1xcblxcblxcdFxcdFxcdGZpcnN0RWxlbS50b0FycmF5KCByLCAwICk7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAxLCBvZmZzZXQgPSAwOyBpICE9PSBuQmxvY2tzOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdG9mZnNldCArPSBibG9ja1NpemU7XFxuXFx0XFx0XFx0XFx0YXJyYXlbIGkgXS50b0FycmF5KCByLCBvZmZzZXQgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiByO1xcblxcblxcdH1cXG5cXG5cXHQvLyBUZXh0dXJlIHVuaXQgYWxsb2NhdGlvblxcblxcblxcdGZ1bmN0aW9uIGFsbG9jVGV4VW5pdHMoIHJlbmRlcmVyLCBuICkge1xcblxcblxcdFxcdHZhciByID0gYXJyYXlDYWNoZUkzMlsgbiBdO1xcblxcblxcdFxcdGlmICggciA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdHIgPSBuZXcgSW50MzJBcnJheSggbiApO1xcblxcdFxcdFxcdGFycmF5Q2FjaGVJMzJbIG4gXSA9IHI7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbjsgKysgaSApXFxuXFx0XFx0XFx0clsgaSBdID0gcmVuZGVyZXIuYWxsb2NUZXh0dXJlVW5pdCgpO1xcblxcblxcdFxcdHJldHVybiByO1xcblxcblxcdH1cXG5cXG5cXHQvLyAtLS0gU2V0dGVycyAtLS1cXG5cXG5cXHQvLyBOb3RlOiBEZWZpbmluZyB0aGVzZSBtZXRob2RzIGV4dGVybmFsbHksIGJlY2F1c2UgdGhleSBjb21lIGluIGEgYnVuY2hcXG5cXHQvLyBhbmQgdGhpcyB3YXkgdGhlaXIgbmFtZXMgbWluaWZ5LlxcblxcblxcdC8vIFNpbmdsZSBzY2FsYXJcXG5cXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZTFmKCBnbCwgdiApIHtcXG5cXG5cXHRcXHRnbC51bmlmb3JtMWYoIHRoaXMuYWRkciwgdiApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZTFpKCBnbCwgdiApIHtcXG5cXG5cXHRcXHRnbC51bmlmb3JtMWkoIHRoaXMuYWRkciwgdiApO1xcblxcblxcdH1cXG5cXG5cXHQvLyBTaW5nbGUgZmxvYXQgdmVjdG9yIChmcm9tIGZsYXQgYXJyYXkgb3IgVEhSRUUuVmVjdG9yTilcXG5cXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZTJmdiggZ2wsIHYgKSB7XFxuXFxuXFx0XFx0aWYgKCB2LnggPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRnbC51bmlmb3JtMmZ2KCB0aGlzLmFkZHIsIHYgKTtcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdGdsLnVuaWZvcm0yZiggdGhpcy5hZGRyLCB2LngsIHYueSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWUzZnYoIGdsLCB2ICkge1xcblxcblxcdFxcdGlmICggdi54ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0Z2wudW5pZm9ybTNmKCB0aGlzLmFkZHIsIHYueCwgdi55LCB2LnogKTtcXG5cXG5cXHRcXHR9IGVsc2UgaWYgKCB2LnIgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRnbC51bmlmb3JtM2YoIHRoaXMuYWRkciwgdi5yLCB2LmcsIHYuYiApO1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0Z2wudW5pZm9ybTNmdiggdGhpcy5hZGRyLCB2ICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZTRmdiggZ2wsIHYgKSB7XFxuXFxuXFx0XFx0aWYgKCB2LnggPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRnbC51bmlmb3JtNGZ2KCB0aGlzLmFkZHIsIHYgKTtcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdCBnbC51bmlmb3JtNGYoIHRoaXMuYWRkciwgdi54LCB2LnksIHYueiwgdi53ICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHQvLyBTaW5nbGUgbWF0cml4IChmcm9tIGZsYXQgYXJyYXkgb3IgTWF0cml4TilcXG5cXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZTJmbSggZ2wsIHYgKSB7XFxuXFxuXFx0XFx0Z2wudW5pZm9ybU1hdHJpeDJmdiggdGhpcy5hZGRyLCBmYWxzZSwgdi5lbGVtZW50cyB8fCB2ICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHNldFZhbHVlM2ZtKCBnbCwgdiApIHtcXG5cXG5cXHRcXHRpZiAoIHYuZWxlbWVudHMgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRnbC51bmlmb3JtTWF0cml4M2Z2KCB0aGlzLmFkZHIsIGZhbHNlLCB2ICk7XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRtYXQzYXJyYXkuc2V0KCB2LmVsZW1lbnRzICk7XFxuXFx0XFx0XFx0Z2wudW5pZm9ybU1hdHJpeDNmdiggdGhpcy5hZGRyLCBmYWxzZSwgbWF0M2FycmF5ICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZTRmbSggZ2wsIHYgKSB7XFxuXFxuXFx0XFx0aWYgKCB2LmVsZW1lbnRzID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdGhpcy5hZGRyLCBmYWxzZSwgdiApO1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0bWF0NGFycmF5LnNldCggdi5lbGVtZW50cyApO1xcblxcdFxcdFxcdGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHRoaXMuYWRkciwgZmFsc2UsIG1hdDRhcnJheSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0Ly8gU2luZ2xlIHRleHR1cmUgKDJEIC8gQ3ViZSlcXG5cXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZVQxKCBnbCwgdiwgcmVuZGVyZXIgKSB7XFxuXFxuXFx0XFx0dmFyIHVuaXQgPSByZW5kZXJlci5hbGxvY1RleHR1cmVVbml0KCk7XFxuXFx0XFx0Z2wudW5pZm9ybTFpKCB0aGlzLmFkZHIsIHVuaXQgKTtcXG5cXHRcXHRyZW5kZXJlci5zZXRUZXh0dXJlMkQoIHYgfHwgZW1wdHlUZXh0dXJlLCB1bml0ICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHNldFZhbHVlVDYoIGdsLCB2LCByZW5kZXJlciApIHtcXG5cXG5cXHRcXHR2YXIgdW5pdCA9IHJlbmRlcmVyLmFsbG9jVGV4dHVyZVVuaXQoKTtcXG5cXHRcXHRnbC51bmlmb3JtMWkoIHRoaXMuYWRkciwgdW5pdCApO1xcblxcdFxcdHJlbmRlcmVyLnNldFRleHR1cmVDdWJlKCB2IHx8IGVtcHR5Q3ViZVRleHR1cmUsIHVuaXQgKTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gSW50ZWdlciAvIEJvb2xlYW4gdmVjdG9ycyBvciBhcnJheXMgdGhlcmVvZiAoYWx3YXlzIGZsYXQgYXJyYXlzKVxcblxcblxcdGZ1bmN0aW9uIHNldFZhbHVlMml2KCBnbCwgdiApIHtcXG5cXG5cXHRcXHRnbC51bmlmb3JtMml2KCB0aGlzLmFkZHIsIHYgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWUzaXYoIGdsLCB2ICkge1xcblxcblxcdFxcdGdsLnVuaWZvcm0zaXYoIHRoaXMuYWRkciwgdiApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZTRpdiggZ2wsIHYgKSB7XFxuXFxuXFx0XFx0Z2wudW5pZm9ybTRpdiggdGhpcy5hZGRyLCB2ICk7XFxuXFxuXFx0fVxcblxcblxcdC8vIEhlbHBlciB0byBwaWNrIHRoZSByaWdodCBzZXR0ZXIgZm9yIHRoZSBzaW5ndWxhciBjYXNlXFxuXFxuXFx0ZnVuY3Rpb24gZ2V0U2luZ3VsYXJTZXR0ZXIoIHR5cGUgKSB7XFxuXFxuXFx0XFx0c3dpdGNoICggdHlwZSApIHtcXG5cXG5cXHRcXHRcXHRjYXNlIDB4MTQwNjogcmV0dXJuIHNldFZhbHVlMWY7IC8vIEZMT0FUXFxuXFx0XFx0XFx0Y2FzZSAweDhiNTA6IHJldHVybiBzZXRWYWx1ZTJmdjsgLy8gX1ZFQzJcXG5cXHRcXHRcXHRjYXNlIDB4OGI1MTogcmV0dXJuIHNldFZhbHVlM2Z2OyAvLyBfVkVDM1xcblxcdFxcdFxcdGNhc2UgMHg4YjUyOiByZXR1cm4gc2V0VmFsdWU0ZnY7IC8vIF9WRUM0XFxuXFxuXFx0XFx0XFx0Y2FzZSAweDhiNWE6IHJldHVybiBzZXRWYWx1ZTJmbTsgLy8gX01BVDJcXG5cXHRcXHRcXHRjYXNlIDB4OGI1YjogcmV0dXJuIHNldFZhbHVlM2ZtOyAvLyBfTUFUM1xcblxcdFxcdFxcdGNhc2UgMHg4YjVjOiByZXR1cm4gc2V0VmFsdWU0Zm07IC8vIF9NQVQ0XFxuXFxuXFx0XFx0XFx0Y2FzZSAweDhiNWU6IGNhc2UgMHg4ZDY2OiByZXR1cm4gc2V0VmFsdWVUMTsgLy8gU0FNUExFUl8yRCwgU0FNUExFUl9FWFRFUk5BTF9PRVNcXG5cXHRcXHRcXHRjYXNlIDB4OGI2MDogcmV0dXJuIHNldFZhbHVlVDY7IC8vIFNBTVBMRVJfQ1VCRVxcblxcblxcdFxcdFxcdGNhc2UgMHgxNDA0OiBjYXNlIDB4OGI1NjogcmV0dXJuIHNldFZhbHVlMWk7IC8vIElOVCwgQk9PTFxcblxcdFxcdFxcdGNhc2UgMHg4YjUzOiBjYXNlIDB4OGI1NzogcmV0dXJuIHNldFZhbHVlMml2OyAvLyBfVkVDMlxcblxcdFxcdFxcdGNhc2UgMHg4YjU0OiBjYXNlIDB4OGI1ODogcmV0dXJuIHNldFZhbHVlM2l2OyAvLyBfVkVDM1xcblxcdFxcdFxcdGNhc2UgMHg4YjU1OiBjYXNlIDB4OGI1OTogcmV0dXJuIHNldFZhbHVlNGl2OyAvLyBfVkVDNFxcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0Ly8gQXJyYXkgb2Ygc2NhbGFyc1xcblxcblxcdGZ1bmN0aW9uIHNldFZhbHVlMWZ2KCBnbCwgdiApIHtcXG5cXG5cXHRcXHRnbC51bmlmb3JtMWZ2KCB0aGlzLmFkZHIsIHYgKTtcXG5cXG5cXHR9XFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWUxaXYoIGdsLCB2ICkge1xcblxcblxcdFxcdGdsLnVuaWZvcm0xaXYoIHRoaXMuYWRkciwgdiApO1xcblxcblxcdH1cXG5cXG5cXHQvLyBBcnJheSBvZiB2ZWN0b3JzIChmbGF0IG9yIGZyb20gVEhSRUUgY2xhc3NlcylcXG5cXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZVYyYSggZ2wsIHYgKSB7XFxuXFxuXFx0XFx0Z2wudW5pZm9ybTJmdiggdGhpcy5hZGRyLCBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDIgKSApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZVYzYSggZ2wsIHYgKSB7XFxuXFxuXFx0XFx0Z2wudW5pZm9ybTNmdiggdGhpcy5hZGRyLCBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDMgKSApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZVY0YSggZ2wsIHYgKSB7XFxuXFxuXFx0XFx0Z2wudW5pZm9ybTRmdiggdGhpcy5hZGRyLCBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDQgKSApO1xcblxcblxcdH1cXG5cXG5cXHQvLyBBcnJheSBvZiBtYXRyaWNlcyAoZmxhdCBvciBmcm9tIFRIUkVFIGNsYXNlcylcXG5cXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZU0yYSggZ2wsIHYgKSB7XFxuXFxuXFx0XFx0Z2wudW5pZm9ybU1hdHJpeDJmdiggdGhpcy5hZGRyLCBmYWxzZSwgZmxhdHRlbiggdiwgdGhpcy5zaXplLCA0ICkgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gc2V0VmFsdWVNM2EoIGdsLCB2ICkge1xcblxcblxcdFxcdGdsLnVuaWZvcm1NYXRyaXgzZnYoIHRoaXMuYWRkciwgZmFsc2UsIGZsYXR0ZW4oIHYsIHRoaXMuc2l6ZSwgOSApICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHNldFZhbHVlTTRhKCBnbCwgdiApIHtcXG5cXG5cXHRcXHRnbC51bmlmb3JtTWF0cml4NGZ2KCB0aGlzLmFkZHIsIGZhbHNlLCBmbGF0dGVuKCB2LCB0aGlzLnNpemUsIDE2ICkgKTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gQXJyYXkgb2YgdGV4dHVyZXMgKDJEIC8gQ3ViZSlcXG5cXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZVQxYSggZ2wsIHYsIHJlbmRlcmVyICkge1xcblxcblxcdFxcdHZhciBuID0gdi5sZW5ndGgsXFxuXFx0XFx0XFx0dW5pdHMgPSBhbGxvY1RleFVuaXRzKCByZW5kZXJlciwgbiApO1xcblxcblxcdFxcdGdsLnVuaWZvcm0xaXYoIHRoaXMuYWRkciwgdW5pdHMgKTtcXG5cXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0cmVuZGVyZXIuc2V0VGV4dHVyZTJEKCB2WyBpIF0gfHwgZW1wdHlUZXh0dXJlLCB1bml0c1sgaSBdICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBzZXRWYWx1ZVQ2YSggZ2wsIHYsIHJlbmRlcmVyICkge1xcblxcblxcdFxcdHZhciBuID0gdi5sZW5ndGgsXFxuXFx0XFx0XFx0dW5pdHMgPSBhbGxvY1RleFVuaXRzKCByZW5kZXJlciwgbiApO1xcblxcblxcdFxcdGdsLnVuaWZvcm0xaXYoIHRoaXMuYWRkciwgdW5pdHMgKTtcXG5cXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0cmVuZGVyZXIuc2V0VGV4dHVyZUN1YmUoIHZbIGkgXSB8fCBlbXB0eUN1YmVUZXh0dXJlLCB1bml0c1sgaSBdICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHQvLyBIZWxwZXIgdG8gcGljayB0aGUgcmlnaHQgc2V0dGVyIGZvciBhIHB1cmUgKGJvdHRvbS1sZXZlbCkgYXJyYXlcXG5cXG5cXHRmdW5jdGlvbiBnZXRQdXJlQXJyYXlTZXR0ZXIoIHR5cGUgKSB7XFxuXFxuXFx0XFx0c3dpdGNoICggdHlwZSApIHtcXG5cXG5cXHRcXHRcXHRjYXNlIDB4MTQwNjogcmV0dXJuIHNldFZhbHVlMWZ2OyAvLyBGTE9BVFxcblxcdFxcdFxcdGNhc2UgMHg4YjUwOiByZXR1cm4gc2V0VmFsdWVWMmE7IC8vIF9WRUMyXFxuXFx0XFx0XFx0Y2FzZSAweDhiNTE6IHJldHVybiBzZXRWYWx1ZVYzYTsgLy8gX1ZFQzNcXG5cXHRcXHRcXHRjYXNlIDB4OGI1MjogcmV0dXJuIHNldFZhbHVlVjRhOyAvLyBfVkVDNFxcblxcblxcdFxcdFxcdGNhc2UgMHg4YjVhOiByZXR1cm4gc2V0VmFsdWVNMmE7IC8vIF9NQVQyXFxuXFx0XFx0XFx0Y2FzZSAweDhiNWI6IHJldHVybiBzZXRWYWx1ZU0zYTsgLy8gX01BVDNcXG5cXHRcXHRcXHRjYXNlIDB4OGI1YzogcmV0dXJuIHNldFZhbHVlTTRhOyAvLyBfTUFUNFxcblxcblxcdFxcdFxcdGNhc2UgMHg4YjVlOiByZXR1cm4gc2V0VmFsdWVUMWE7IC8vIFNBTVBMRVJfMkRcXG5cXHRcXHRcXHRjYXNlIDB4OGI2MDogcmV0dXJuIHNldFZhbHVlVDZhOyAvLyBTQU1QTEVSX0NVQkVcXG5cXG5cXHRcXHRcXHRjYXNlIDB4MTQwNDogY2FzZSAweDhiNTY6IHJldHVybiBzZXRWYWx1ZTFpdjsgLy8gSU5ULCBCT09MXFxuXFx0XFx0XFx0Y2FzZSAweDhiNTM6IGNhc2UgMHg4YjU3OiByZXR1cm4gc2V0VmFsdWUyaXY7IC8vIF9WRUMyXFxuXFx0XFx0XFx0Y2FzZSAweDhiNTQ6IGNhc2UgMHg4YjU4OiByZXR1cm4gc2V0VmFsdWUzaXY7IC8vIF9WRUMzXFxuXFx0XFx0XFx0Y2FzZSAweDhiNTU6IGNhc2UgMHg4YjU5OiByZXR1cm4gc2V0VmFsdWU0aXY7IC8vIF9WRUM0XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHQvLyAtLS0gVW5pZm9ybSBDbGFzc2VzIC0tLVxcblxcblxcdGZ1bmN0aW9uIFNpbmdsZVVuaWZvcm0oIGlkLCBhY3RpdmVJbmZvLCBhZGRyICkge1xcblxcblxcdFxcdHRoaXMuaWQgPSBpZDtcXG5cXHRcXHR0aGlzLmFkZHIgPSBhZGRyO1xcblxcdFxcdHRoaXMuc2V0VmFsdWUgPSBnZXRTaW5ndWxhclNldHRlciggYWN0aXZlSW5mby50eXBlICk7XFxuXFxuXFx0XFx0Ly8gdGhpcy5wYXRoID0gYWN0aXZlSW5mby5uYW1lOyAvLyBERUJVR1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBQdXJlQXJyYXlVbmlmb3JtKCBpZCwgYWN0aXZlSW5mbywgYWRkciApIHtcXG5cXG5cXHRcXHR0aGlzLmlkID0gaWQ7XFxuXFx0XFx0dGhpcy5hZGRyID0gYWRkcjtcXG5cXHRcXHR0aGlzLnNpemUgPSBhY3RpdmVJbmZvLnNpemU7XFxuXFx0XFx0dGhpcy5zZXRWYWx1ZSA9IGdldFB1cmVBcnJheVNldHRlciggYWN0aXZlSW5mby50eXBlICk7XFxuXFxuXFx0XFx0Ly8gdGhpcy5wYXRoID0gYWN0aXZlSW5mby5uYW1lOyAvLyBERUJVR1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBTdHJ1Y3R1cmVkVW5pZm9ybSggaWQgKSB7XFxuXFxuXFx0XFx0dGhpcy5pZCA9IGlkO1xcblxcblxcdFxcdFVuaWZvcm1Db250YWluZXIuY2FsbCggdGhpcyApOyAvLyBtaXgtaW5cXG5cXG5cXHR9XFxuXFxuXFx0U3RydWN0dXJlZFVuaWZvcm0ucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKCBnbCwgdmFsdWUgKSB7XFxuXFxuXFx0XFx0Ly8gTm90ZTogRG9uJ3QgbmVlZCBhbiBleHRyYSAncmVuZGVyZXInIHBhcmFtZXRlciwgc2luY2Ugc2FtcGxlcnNcXG5cXHRcXHQvLyBhcmUgbm90IGFsbG93ZWQgaW4gc3RydWN0dXJlZCB1bmlmb3Jtcy5cXG5cXG5cXHRcXHR2YXIgc2VxID0gdGhpcy5zZXE7XFxuXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gc2VxLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdSA9IHNlcVsgaSBdO1xcblxcdFxcdFxcdHUuc2V0VmFsdWUoIGdsLCB2YWx1ZVsgdS5pZCBdICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH07XFxuXFxuXFx0Ly8gLS0tIFRvcC1sZXZlbCAtLS1cXG5cXG5cXHQvLyBQYXJzZXIgLSBidWlsZHMgdXAgdGhlIHByb3BlcnR5IHRyZWUgZnJvbSB0aGUgcGF0aCBzdHJpbmdzXFxuXFxuXFx0dmFyIFJlUGF0aFBhcnQgPSAvKFtcXFxcd1xcXFxkX10rKShcXFxcXSk/KFxcXFxbfFxcXFwuKT8vZztcXG5cXG5cXHQvLyBleHRyYWN0c1xcblxcdC8vIFxcdC0gdGhlIGlkZW50aWZpZXIgKG1lbWJlciBuYW1lIG9yIGFycmF5IGluZGV4KVxcblxcdC8vICAtIGZvbGxvd2VkIGJ5IGFuIG9wdGlvbmFsIHJpZ2h0IGJyYWNrZXQgKGZvdW5kIHdoZW4gYXJyYXkgaW5kZXgpXFxuXFx0Ly8gIC0gZm9sbG93ZWQgYnkgYW4gb3B0aW9uYWwgbGVmdCBicmFja2V0IG9yIGRvdCAodHlwZSBvZiBzdWJzY3JpcHQpXFxuXFx0Ly9cXG5cXHQvLyBOb3RlOiBUaGVzZSBwb3J0aW9ucyBjYW4gYmUgcmVhZCBpbiBhIG5vbi1vdmVybGFwcGluZyBmYXNoaW9uIGFuZFxcblxcdC8vIGFsbG93IHN0cmFpZ2h0Zm9yd2FyZCBwYXJzaW5nIG9mIHRoZSBoaWVyYXJjaHkgdGhhdCBXZWJHTCBlbmNvZGVzXFxuXFx0Ly8gaW4gdGhlIHVuaWZvcm0gbmFtZXMuXFxuXFxuXFx0ZnVuY3Rpb24gYWRkVW5pZm9ybSggY29udGFpbmVyLCB1bmlmb3JtT2JqZWN0ICkge1xcblxcblxcdFxcdGNvbnRhaW5lci5zZXEucHVzaCggdW5pZm9ybU9iamVjdCApO1xcblxcdFxcdGNvbnRhaW5lci5tYXBbIHVuaWZvcm1PYmplY3QuaWQgXSA9IHVuaWZvcm1PYmplY3Q7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHBhcnNlVW5pZm9ybSggYWN0aXZlSW5mbywgYWRkciwgY29udGFpbmVyICkge1xcblxcblxcdFxcdHZhciBwYXRoID0gYWN0aXZlSW5mby5uYW1lLFxcblxcdFxcdFxcdHBhdGhMZW5ndGggPSBwYXRoLmxlbmd0aDtcXG5cXG5cXHRcXHQvLyByZXNldCBSZWdFeHAgb2JqZWN0LCBiZWNhdXNlIG9mIHRoZSBlYXJseSBleGl0IG9mIGEgcHJldmlvdXMgcnVuXFxuXFx0XFx0UmVQYXRoUGFydC5sYXN0SW5kZXggPSAwO1xcblxcblxcdFxcdGZvciAoIDsgOyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgbWF0Y2ggPSBSZVBhdGhQYXJ0LmV4ZWMoIHBhdGggKSxcXG5cXHRcXHRcXHRcXHRtYXRjaEVuZCA9IFJlUGF0aFBhcnQubGFzdEluZGV4LFxcblxcblxcdFxcdFxcdFxcdGlkID0gbWF0Y2hbIDEgXSxcXG5cXHRcXHRcXHRcXHRpZElzSW5kZXggPSBtYXRjaFsgMiBdID09PSAnXScsXFxuXFx0XFx0XFx0XFx0c3Vic2NyaXB0ID0gbWF0Y2hbIDMgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIGlkSXNJbmRleCApIGlkID0gaWQgfCAwOyAvLyBjb252ZXJ0IHRvIGludGVnZXJcXG5cXG5cXHRcXHRcXHRpZiAoIHN1YnNjcmlwdCA9PT0gdW5kZWZpbmVkIHx8IHN1YnNjcmlwdCA9PT0gJ1snICYmIG1hdGNoRW5kICsgMiA9PT0gcGF0aExlbmd0aCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBiYXJlIG5hbWUgb3IgXFxcInB1cmVcXFwiIGJvdHRvbS1sZXZlbCBhcnJheSBcXFwiWzBdXFxcIiBzdWZmaXhcXG5cXG5cXHRcXHRcXHRcXHRhZGRVbmlmb3JtKCBjb250YWluZXIsIHN1YnNjcmlwdCA9PT0gdW5kZWZpbmVkID9cXG5cXHRcXHRcXHRcXHRcXHRuZXcgU2luZ2xlVW5pZm9ybSggaWQsIGFjdGl2ZUluZm8sIGFkZHIgKSA6XFxuXFx0XFx0XFx0XFx0XFx0bmV3IFB1cmVBcnJheVVuaWZvcm0oIGlkLCBhY3RpdmVJbmZvLCBhZGRyICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdC8vIHN0ZXAgaW50byBpbm5lciBub2RlIC8gY3JlYXRlIGl0IGluIGNhc2UgaXQgZG9lc24ndCBleGlzdFxcblxcblxcdFxcdFxcdFxcdHZhciBtYXAgPSBjb250YWluZXIubWFwLCBuZXh0ID0gbWFwWyBpZCBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggbmV4dCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG5leHQgPSBuZXcgU3RydWN0dXJlZFVuaWZvcm0oIGlkICk7XFxuXFx0XFx0XFx0XFx0XFx0YWRkVW5pZm9ybSggY29udGFpbmVyLCBuZXh0ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGNvbnRhaW5lciA9IG5leHQ7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0Ly8gUm9vdCBDb250YWluZXJcXG5cXG5cXHRmdW5jdGlvbiBXZWJHTFVuaWZvcm1zKCBnbCwgcHJvZ3JhbSwgcmVuZGVyZXIgKSB7XFxuXFxuXFx0XFx0VW5pZm9ybUNvbnRhaW5lci5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xcblxcblxcdFxcdHZhciBuID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuQUNUSVZFX1VOSUZPUk1TICk7XFxuXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgaW5mbyA9IGdsLmdldEFjdGl2ZVVuaWZvcm0oIHByb2dyYW0sIGkgKSxcXG5cXHRcXHRcXHRcXHRwYXRoID0gaW5mby5uYW1lLFxcblxcdFxcdFxcdFxcdGFkZHIgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIHBhdGggKTtcXG5cXG5cXHRcXHRcXHRwYXJzZVVuaWZvcm0oIGluZm8sIGFkZHIsIHRoaXMgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdFdlYkdMVW5pZm9ybXMucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gKCBnbCwgbmFtZSwgdmFsdWUgKSB7XFxuXFxuXFx0XFx0dmFyIHUgPSB0aGlzLm1hcFsgbmFtZSBdO1xcblxcblxcdFxcdGlmICggdSAhPT0gdW5kZWZpbmVkICkgdS5zZXRWYWx1ZSggZ2wsIHZhbHVlLCB0aGlzLnJlbmRlcmVyICk7XFxuXFxuXFx0fTtcXG5cXG5cXHRXZWJHTFVuaWZvcm1zLnByb3RvdHlwZS5zZXRPcHRpb25hbCA9IGZ1bmN0aW9uICggZ2wsIG9iamVjdCwgbmFtZSApIHtcXG5cXG5cXHRcXHR2YXIgdiA9IG9iamVjdFsgbmFtZSBdO1xcblxcblxcdFxcdGlmICggdiAhPT0gdW5kZWZpbmVkICkgdGhpcy5zZXRWYWx1ZSggZ2wsIG5hbWUsIHYgKTtcXG5cXG5cXHR9O1xcblxcblxcblxcdC8vIFN0YXRpYyBpbnRlcmZhY2VcXG5cXG5cXHRXZWJHTFVuaWZvcm1zLnVwbG9hZCA9IGZ1bmN0aW9uICggZ2wsIHNlcSwgdmFsdWVzLCByZW5kZXJlciApIHtcXG5cXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcblxcblxcdFxcdFxcdHZhciB1ID0gc2VxWyBpIF0sXFxuXFx0XFx0XFx0XFx0diA9IHZhbHVlc1sgdS5pZCBdO1xcblxcblxcdFxcdFxcdGlmICggdi5uZWVkc1VwZGF0ZSAhPT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbm90ZTogYWx3YXlzIHVwZGF0aW5nIHdoZW4gLm5lZWRzVXBkYXRlIGlzIHVuZGVmaW5lZFxcblxcdFxcdFxcdFxcdHUuc2V0VmFsdWUoIGdsLCB2LnZhbHVlLCByZW5kZXJlciApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0fTtcXG5cXG5cXHRXZWJHTFVuaWZvcm1zLnNlcVdpdGhWYWx1ZSA9IGZ1bmN0aW9uICggc2VxLCB2YWx1ZXMgKSB7XFxuXFxuXFx0XFx0dmFyIHIgPSBbXTtcXG5cXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBzZXEubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcblxcblxcdFxcdFxcdHZhciB1ID0gc2VxWyBpIF07XFxuXFx0XFx0XFx0aWYgKCB1LmlkIGluIHZhbHVlcyApIHIucHVzaCggdSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gcjtcXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0dmFyIENvbG9yS2V5d29yZHMgPSB7ICdhbGljZWJsdWUnOiAweEYwRjhGRiwgJ2FudGlxdWV3aGl0ZSc6IDB4RkFFQkQ3LCAnYXF1YSc6IDB4MDBGRkZGLCAnYXF1YW1hcmluZSc6IDB4N0ZGRkQ0LCAnYXp1cmUnOiAweEYwRkZGRixcXG5cXHRcXHQnYmVpZ2UnOiAweEY1RjVEQywgJ2Jpc3F1ZSc6IDB4RkZFNEM0LCAnYmxhY2snOiAweDAwMDAwMCwgJ2JsYW5jaGVkYWxtb25kJzogMHhGRkVCQ0QsICdibHVlJzogMHgwMDAwRkYsICdibHVldmlvbGV0JzogMHg4QTJCRTIsXFxuXFx0XFx0J2Jyb3duJzogMHhBNTJBMkEsICdidXJseXdvb2QnOiAweERFQjg4NywgJ2NhZGV0Ymx1ZSc6IDB4NUY5RUEwLCAnY2hhcnRyZXVzZSc6IDB4N0ZGRjAwLCAnY2hvY29sYXRlJzogMHhEMjY5MUUsICdjb3JhbCc6IDB4RkY3RjUwLFxcblxcdFxcdCdjb3JuZmxvd2VyYmx1ZSc6IDB4NjQ5NUVELCAnY29ybnNpbGsnOiAweEZGRjhEQywgJ2NyaW1zb24nOiAweERDMTQzQywgJ2N5YW4nOiAweDAwRkZGRiwgJ2RhcmtibHVlJzogMHgwMDAwOEIsICdkYXJrY3lhbic6IDB4MDA4QjhCLFxcblxcdFxcdCdkYXJrZ29sZGVucm9kJzogMHhCODg2MEIsICdkYXJrZ3JheSc6IDB4QTlBOUE5LCAnZGFya2dyZWVuJzogMHgwMDY0MDAsICdkYXJrZ3JleSc6IDB4QTlBOUE5LCAnZGFya2toYWtpJzogMHhCREI3NkIsICdkYXJrbWFnZW50YSc6IDB4OEIwMDhCLFxcblxcdFxcdCdkYXJrb2xpdmVncmVlbic6IDB4NTU2QjJGLCAnZGFya29yYW5nZSc6IDB4RkY4QzAwLCAnZGFya29yY2hpZCc6IDB4OTkzMkNDLCAnZGFya3JlZCc6IDB4OEIwMDAwLCAnZGFya3NhbG1vbic6IDB4RTk5NjdBLCAnZGFya3NlYWdyZWVuJzogMHg4RkJDOEYsXFxuXFx0XFx0J2RhcmtzbGF0ZWJsdWUnOiAweDQ4M0Q4QiwgJ2RhcmtzbGF0ZWdyYXknOiAweDJGNEY0RiwgJ2RhcmtzbGF0ZWdyZXknOiAweDJGNEY0RiwgJ2Rhcmt0dXJxdW9pc2UnOiAweDAwQ0VEMSwgJ2Rhcmt2aW9sZXQnOiAweDk0MDBEMyxcXG5cXHRcXHQnZGVlcHBpbmsnOiAweEZGMTQ5MywgJ2RlZXBza3libHVlJzogMHgwMEJGRkYsICdkaW1ncmF5JzogMHg2OTY5NjksICdkaW1ncmV5JzogMHg2OTY5NjksICdkb2RnZXJibHVlJzogMHgxRTkwRkYsICdmaXJlYnJpY2snOiAweEIyMjIyMixcXG5cXHRcXHQnZmxvcmFsd2hpdGUnOiAweEZGRkFGMCwgJ2ZvcmVzdGdyZWVuJzogMHgyMjhCMjIsICdmdWNoc2lhJzogMHhGRjAwRkYsICdnYWluc2Jvcm8nOiAweERDRENEQywgJ2dob3N0d2hpdGUnOiAweEY4RjhGRiwgJ2dvbGQnOiAweEZGRDcwMCxcXG5cXHRcXHQnZ29sZGVucm9kJzogMHhEQUE1MjAsICdncmF5JzogMHg4MDgwODAsICdncmVlbic6IDB4MDA4MDAwLCAnZ3JlZW55ZWxsb3cnOiAweEFERkYyRiwgJ2dyZXknOiAweDgwODA4MCwgJ2hvbmV5ZGV3JzogMHhGMEZGRjAsICdob3RwaW5rJzogMHhGRjY5QjQsXFxuXFx0XFx0J2luZGlhbnJlZCc6IDB4Q0Q1QzVDLCAnaW5kaWdvJzogMHg0QjAwODIsICdpdm9yeSc6IDB4RkZGRkYwLCAna2hha2knOiAweEYwRTY4QywgJ2xhdmVuZGVyJzogMHhFNkU2RkEsICdsYXZlbmRlcmJsdXNoJzogMHhGRkYwRjUsICdsYXduZ3JlZW4nOiAweDdDRkMwMCxcXG5cXHRcXHQnbGVtb25jaGlmZm9uJzogMHhGRkZBQ0QsICdsaWdodGJsdWUnOiAweEFERDhFNiwgJ2xpZ2h0Y29yYWwnOiAweEYwODA4MCwgJ2xpZ2h0Y3lhbic6IDB4RTBGRkZGLCAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiAweEZBRkFEMiwgJ2xpZ2h0Z3JheSc6IDB4RDNEM0QzLFxcblxcdFxcdCdsaWdodGdyZWVuJzogMHg5MEVFOTAsICdsaWdodGdyZXknOiAweEQzRDNEMywgJ2xpZ2h0cGluayc6IDB4RkZCNkMxLCAnbGlnaHRzYWxtb24nOiAweEZGQTA3QSwgJ2xpZ2h0c2VhZ3JlZW4nOiAweDIwQjJBQSwgJ2xpZ2h0c2t5Ymx1ZSc6IDB4ODdDRUZBLFxcblxcdFxcdCdsaWdodHNsYXRlZ3JheSc6IDB4Nzc4ODk5LCAnbGlnaHRzbGF0ZWdyZXknOiAweDc3ODg5OSwgJ2xpZ2h0c3RlZWxibHVlJzogMHhCMEM0REUsICdsaWdodHllbGxvdyc6IDB4RkZGRkUwLCAnbGltZSc6IDB4MDBGRjAwLCAnbGltZWdyZWVuJzogMHgzMkNEMzIsXFxuXFx0XFx0J2xpbmVuJzogMHhGQUYwRTYsICdtYWdlbnRhJzogMHhGRjAwRkYsICdtYXJvb24nOiAweDgwMDAwMCwgJ21lZGl1bWFxdWFtYXJpbmUnOiAweDY2Q0RBQSwgJ21lZGl1bWJsdWUnOiAweDAwMDBDRCwgJ21lZGl1bW9yY2hpZCc6IDB4QkE1NUQzLFxcblxcdFxcdCdtZWRpdW1wdXJwbGUnOiAweDkzNzBEQiwgJ21lZGl1bXNlYWdyZWVuJzogMHgzQ0IzNzEsICdtZWRpdW1zbGF0ZWJsdWUnOiAweDdCNjhFRSwgJ21lZGl1bXNwcmluZ2dyZWVuJzogMHgwMEZBOUEsICdtZWRpdW10dXJxdW9pc2UnOiAweDQ4RDFDQyxcXG5cXHRcXHQnbWVkaXVtdmlvbGV0cmVkJzogMHhDNzE1ODUsICdtaWRuaWdodGJsdWUnOiAweDE5MTk3MCwgJ21pbnRjcmVhbSc6IDB4RjVGRkZBLCAnbWlzdHlyb3NlJzogMHhGRkU0RTEsICdtb2NjYXNpbic6IDB4RkZFNEI1LCAnbmF2YWpvd2hpdGUnOiAweEZGREVBRCxcXG5cXHRcXHQnbmF2eSc6IDB4MDAwMDgwLCAnb2xkbGFjZSc6IDB4RkRGNUU2LCAnb2xpdmUnOiAweDgwODAwMCwgJ29saXZlZHJhYic6IDB4NkI4RTIzLCAnb3JhbmdlJzogMHhGRkE1MDAsICdvcmFuZ2VyZWQnOiAweEZGNDUwMCwgJ29yY2hpZCc6IDB4REE3MEQ2LFxcblxcdFxcdCdwYWxlZ29sZGVucm9kJzogMHhFRUU4QUEsICdwYWxlZ3JlZW4nOiAweDk4RkI5OCwgJ3BhbGV0dXJxdW9pc2UnOiAweEFGRUVFRSwgJ3BhbGV2aW9sZXRyZWQnOiAweERCNzA5MywgJ3BhcGF5YXdoaXAnOiAweEZGRUZENSwgJ3BlYWNocHVmZic6IDB4RkZEQUI5LFxcblxcdFxcdCdwZXJ1JzogMHhDRDg1M0YsICdwaW5rJzogMHhGRkMwQ0IsICdwbHVtJzogMHhEREEwREQsICdwb3dkZXJibHVlJzogMHhCMEUwRTYsICdwdXJwbGUnOiAweDgwMDA4MCwgJ3JlYmVjY2FwdXJwbGUnOiAweDY2MzM5OSwgJ3JlZCc6IDB4RkYwMDAwLCAncm9zeWJyb3duJzogMHhCQzhGOEYsXFxuXFx0XFx0J3JveWFsYmx1ZSc6IDB4NDE2OUUxLCAnc2FkZGxlYnJvd24nOiAweDhCNDUxMywgJ3NhbG1vbic6IDB4RkE4MDcyLCAnc2FuZHlicm93bic6IDB4RjRBNDYwLCAnc2VhZ3JlZW4nOiAweDJFOEI1NywgJ3NlYXNoZWxsJzogMHhGRkY1RUUsXFxuXFx0XFx0J3NpZW5uYSc6IDB4QTA1MjJELCAnc2lsdmVyJzogMHhDMEMwQzAsICdza3libHVlJzogMHg4N0NFRUIsICdzbGF0ZWJsdWUnOiAweDZBNUFDRCwgJ3NsYXRlZ3JheSc6IDB4NzA4MDkwLCAnc2xhdGVncmV5JzogMHg3MDgwOTAsICdzbm93JzogMHhGRkZBRkEsXFxuXFx0XFx0J3NwcmluZ2dyZWVuJzogMHgwMEZGN0YsICdzdGVlbGJsdWUnOiAweDQ2ODJCNCwgJ3Rhbic6IDB4RDJCNDhDLCAndGVhbCc6IDB4MDA4MDgwLCAndGhpc3RsZSc6IDB4RDhCRkQ4LCAndG9tYXRvJzogMHhGRjYzNDcsICd0dXJxdW9pc2UnOiAweDQwRTBEMCxcXG5cXHRcXHQndmlvbGV0JzogMHhFRTgyRUUsICd3aGVhdCc6IDB4RjVERUIzLCAnd2hpdGUnOiAweEZGRkZGRiwgJ3doaXRlc21va2UnOiAweEY1RjVGNSwgJ3llbGxvdyc6IDB4RkZGRjAwLCAneWVsbG93Z3JlZW4nOiAweDlBQ0QzMiB9O1xcblxcblxcdGZ1bmN0aW9uIENvbG9yKCByLCBnLCBiICkge1xcblxcblxcdFxcdGlmICggZyA9PT0gdW5kZWZpbmVkICYmIGIgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHQvLyByIGlzIFRIUkVFLkNvbG9yLCBoZXggb3Igc3RyaW5nXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuc2V0KCByICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzLnNldFJHQiggciwgZywgYiApO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBDb2xvci5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRpc0NvbG9yOiB0cnVlLFxcblxcblxcdFxcdHI6IDEsIGc6IDEsIGI6IDEsXFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdGlmICggdmFsdWUgJiYgdmFsdWUuaXNDb2xvciApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmNvcHkoIHZhbHVlICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnNldEhleCggdmFsdWUgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuc2V0U3R5bGUoIHZhbHVlICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0U2NhbGFyOiBmdW5jdGlvbiAoIHNjYWxhciApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnIgPSBzY2FsYXI7XFxuXFx0XFx0XFx0dGhpcy5nID0gc2NhbGFyO1xcblxcdFxcdFxcdHRoaXMuYiA9IHNjYWxhcjtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEhleDogZnVuY3Rpb24gKCBoZXggKSB7XFxuXFxuXFx0XFx0XFx0aGV4ID0gTWF0aC5mbG9vciggaGV4ICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5yID0gKCBoZXggPj4gMTYgJiAyNTUgKSAvIDI1NTtcXG5cXHRcXHRcXHR0aGlzLmcgPSAoIGhleCA+PiA4ICYgMjU1ICkgLyAyNTU7XFxuXFx0XFx0XFx0dGhpcy5iID0gKCBoZXggJiAyNTUgKSAvIDI1NTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFJHQjogZnVuY3Rpb24gKCByLCBnLCBiICkge1xcblxcblxcdFxcdFxcdHRoaXMuciA9IHI7XFxuXFx0XFx0XFx0dGhpcy5nID0gZztcXG5cXHRcXHRcXHR0aGlzLmIgPSBiO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0SFNMOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gaHVlMnJnYiggcCwgcSwgdCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHQgPCAwICkgdCArPSAxO1xcblxcdFxcdFxcdFxcdGlmICggdCA+IDEgKSB0IC09IDE7XFxuXFx0XFx0XFx0XFx0aWYgKCB0IDwgMSAvIDYgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiB0O1xcblxcdFxcdFxcdFxcdGlmICggdCA8IDEgLyAyICkgcmV0dXJuIHE7XFxuXFx0XFx0XFx0XFx0aWYgKCB0IDwgMiAvIDMgKSByZXR1cm4gcCArICggcSAtIHAgKSAqIDYgKiAoIDIgLyAzIC0gdCApO1xcblxcdFxcdFxcdFxcdHJldHVybiBwO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gc2V0SFNMKCBoLCBzLCBsICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXFxuXFx0XFx0XFx0XFx0aCA9IF9NYXRoLmV1Y2xpZGVhbk1vZHVsbyggaCwgMSApO1xcblxcdFxcdFxcdFxcdHMgPSBfTWF0aC5jbGFtcCggcywgMCwgMSApO1xcblxcdFxcdFxcdFxcdGwgPSBfTWF0aC5jbGFtcCggbCwgMCwgMSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggcyA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnIgPSB0aGlzLmcgPSB0aGlzLmIgPSBsO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHAgPSBsIDw9IDAuNSA/IGwgKiAoIDEgKyBzICkgOiBsICsgcyAtICggbCAqIHMgKTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcSA9ICggMiAqIGwgKSAtIHA7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yID0gaHVlMnJnYiggcSwgcCwgaCArIDEgLyAzICk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5nID0gaHVlMnJnYiggcSwgcCwgaCApO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuYiA9IGh1ZTJyZ2IoIHEsIHAsIGggLSAxIC8gMyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRzZXRTdHlsZTogZnVuY3Rpb24gKCBzdHlsZSApIHtcXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBoYW5kbGVBbHBoYSggc3RyaW5nICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggc3RyaW5nID09PSB1bmRlZmluZWQgKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBwYXJzZUZsb2F0KCBzdHJpbmcgKSA8IDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IEFscGhhIGNvbXBvbmVudCBvZiAnICsgc3R5bGUgKyAnIHdpbGwgYmUgaWdub3JlZC4nICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXG5cXHRcXHRcXHR2YXIgbTtcXG5cXG5cXHRcXHRcXHRpZiAoIG0gPSAvXigoPzpyZ2J8aHNsKWE/KVxcXFwoXFxcXHMqKFteXFxcXCldKilcXFxcKS8uZXhlYyggc3R5bGUgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyByZ2IgLyBoc2xcXG5cXG5cXHRcXHRcXHRcXHR2YXIgY29sb3I7XFxuXFx0XFx0XFx0XFx0dmFyIG5hbWUgPSBtWyAxIF07XFxuXFx0XFx0XFx0XFx0dmFyIGNvbXBvbmVudHMgPSBtWyAyIF07XFxuXFxuXFx0XFx0XFx0XFx0c3dpdGNoICggbmFtZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdyZ2InOlxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ3JnYmEnOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggY29sb3IgPSAvXihcXFxcZCspXFxcXHMqLFxcXFxzKihcXFxcZCspXFxcXHMqLFxcXFxzKihcXFxcZCspXFxcXHMqKCxcXFxccyooWzAtOV0qXFxcXC4/WzAtOV0rKVxcXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHJnYigyNTUsMCwwKSByZ2JhKDI1NSwwLDAsMC41KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuciA9IE1hdGgubWluKCAyNTUsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAyNTU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5nID0gTWF0aC5taW4oIDI1NSwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDI1NTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmIgPSBNYXRoLm1pbiggMjU1LCBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSApIC8gMjU1O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGhhbmRsZUFscGhhKCBjb2xvclsgNSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggY29sb3IgPSAvXihcXFxcZCspXFxcXCVcXFxccyosXFxcXHMqKFxcXFxkKylcXFxcJVxcXFxzKixcXFxccyooXFxcXGQrKVxcXFwlXFxcXHMqKCxcXFxccyooWzAtOV0qXFxcXC4/WzAtOV0rKVxcXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHJnYigxMDAlLDAlLDAlKSByZ2JhKDEwMCUsMCUsMCUsMC41KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuciA9IE1hdGgubWluKCAxMDAsIHBhcnNlSW50KCBjb2xvclsgMSBdLCAxMCApICkgLyAxMDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5nID0gTWF0aC5taW4oIDEwMCwgcGFyc2VJbnQoIGNvbG9yWyAyIF0sIDEwICkgKSAvIDEwMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmIgPSBNYXRoLm1pbiggMTAwLCBwYXJzZUludCggY29sb3JbIDMgXSwgMTAgKSApIC8gMTAwO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGhhbmRsZUFscGhhKCBjb2xvclsgNSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ2hzbCc6XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnaHNsYSc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBjb2xvciA9IC9eKFswLTldKlxcXFwuP1swLTldKylcXFxccyosXFxcXHMqKFxcXFxkKylcXFxcJVxcXFxzKixcXFxccyooXFxcXGQrKVxcXFwlXFxcXHMqKCxcXFxccyooWzAtOV0qXFxcXC4/WzAtOV0rKVxcXFxzKik/JC8uZXhlYyggY29tcG9uZW50cyApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGhzbCgxMjAsNTAlLDUwJSkgaHNsYSgxMjAsNTAlLDUwJSwwLjUpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGggPSBwYXJzZUZsb2F0KCBjb2xvclsgMSBdICkgLyAzNjA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHMgPSBwYXJzZUludCggY29sb3JbIDIgXSwgMTAgKSAvIDEwMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgbCA9IHBhcnNlSW50KCBjb2xvclsgMyBdLCAxMCApIC8gMTAwO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGhhbmRsZUFscGhhKCBjb2xvclsgNSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuc2V0SFNMKCBoLCBzLCBsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBtID0gL15cXFxcIyhbQS1GYS1mMC05XSspJC8uZXhlYyggc3R5bGUgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBoZXggY29sb3JcXG5cXG5cXHRcXHRcXHRcXHR2YXIgaGV4ID0gbVsgMSBdO1xcblxcdFxcdFxcdFxcdHZhciBzaXplID0gaGV4Lmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHNpemUgPT09IDMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gI2ZmMFxcblxcdFxcdFxcdFxcdFxcdHRoaXMuciA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAwICkgKyBoZXguY2hhckF0KCAwICksIDE2ICkgLyAyNTU7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5nID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDEgKSArIGhleC5jaGFyQXQoIDEgKSwgMTYgKSAvIDI1NTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggMiApICsgaGV4LmNoYXJBdCggMiApLCAxNiApIC8gMjU1O1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIHNpemUgPT09IDYgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gI2ZmMDAwMFxcblxcdFxcdFxcdFxcdFxcdHRoaXMuciA9IHBhcnNlSW50KCBoZXguY2hhckF0KCAwICkgKyBoZXguY2hhckF0KCAxICksIDE2ICkgLyAyNTU7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5nID0gcGFyc2VJbnQoIGhleC5jaGFyQXQoIDIgKSArIGhleC5jaGFyQXQoIDMgKSwgMTYgKSAvIDI1NTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmIgPSBwYXJzZUludCggaGV4LmNoYXJBdCggNCApICsgaGV4LmNoYXJBdCggNSApLCAxNiApIC8gMjU1O1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBzdHlsZSAmJiBzdHlsZS5sZW5ndGggPiAwICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGNvbG9yIGtleXdvcmRzXFxuXFx0XFx0XFx0XFx0dmFyIGhleCA9IENvbG9yS2V5d29yZHNbIHN0eWxlIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBoZXggIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyByZWRcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnNldEhleCggaGV4ICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyB1bmtub3duIGNvbG9yXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ29sb3I6IFVua25vd24gY29sb3IgJyArIHN0eWxlICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLnIsIHRoaXMuZywgdGhpcy5iICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIGNvbG9yICkge1xcblxcblxcdFxcdFxcdHRoaXMuciA9IGNvbG9yLnI7XFxuXFx0XFx0XFx0dGhpcy5nID0gY29sb3IuZztcXG5cXHRcXHRcXHR0aGlzLmIgPSBjb2xvci5iO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weUdhbW1hVG9MaW5lYXI6IGZ1bmN0aW9uICggY29sb3IsIGdhbW1hRmFjdG9yICkge1xcblxcblxcdFxcdFxcdGlmICggZ2FtbWFGYWN0b3IgPT09IHVuZGVmaW5lZCApIGdhbW1hRmFjdG9yID0gMi4wO1xcblxcblxcdFxcdFxcdHRoaXMuciA9IE1hdGgucG93KCBjb2xvci5yLCBnYW1tYUZhY3RvciApO1xcblxcdFxcdFxcdHRoaXMuZyA9IE1hdGgucG93KCBjb2xvci5nLCBnYW1tYUZhY3RvciApO1xcblxcdFxcdFxcdHRoaXMuYiA9IE1hdGgucG93KCBjb2xvci5iLCBnYW1tYUZhY3RvciApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weUxpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICggY29sb3IsIGdhbW1hRmFjdG9yICkge1xcblxcblxcdFxcdFxcdGlmICggZ2FtbWFGYWN0b3IgPT09IHVuZGVmaW5lZCApIGdhbW1hRmFjdG9yID0gMi4wO1xcblxcblxcdFxcdFxcdHZhciBzYWZlSW52ZXJzZSA9ICggZ2FtbWFGYWN0b3IgPiAwICkgPyAoIDEuMCAvIGdhbW1hRmFjdG9yICkgOiAxLjA7XFxuXFxuXFx0XFx0XFx0dGhpcy5yID0gTWF0aC5wb3coIGNvbG9yLnIsIHNhZmVJbnZlcnNlICk7XFxuXFx0XFx0XFx0dGhpcy5nID0gTWF0aC5wb3coIGNvbG9yLmcsIHNhZmVJbnZlcnNlICk7XFxuXFx0XFx0XFx0dGhpcy5iID0gTWF0aC5wb3coIGNvbG9yLmIsIHNhZmVJbnZlcnNlICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb252ZXJ0R2FtbWFUb0xpbmVhcjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciByID0gdGhpcy5yLCBnID0gdGhpcy5nLCBiID0gdGhpcy5iO1xcblxcblxcdFxcdFxcdHRoaXMuciA9IHIgKiByO1xcblxcdFxcdFxcdHRoaXMuZyA9IGcgKiBnO1xcblxcdFxcdFxcdHRoaXMuYiA9IGIgKiBiO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29udmVydExpbmVhclRvR2FtbWE6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnIgPSBNYXRoLnNxcnQoIHRoaXMuciApO1xcblxcdFxcdFxcdHRoaXMuZyA9IE1hdGguc3FydCggdGhpcy5nICk7XFxuXFx0XFx0XFx0dGhpcy5iID0gTWF0aC5zcXJ0KCB0aGlzLmIgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldEhleDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiAoIHRoaXMuciAqIDI1NSApIDw8IDE2IF4gKCB0aGlzLmcgKiAyNTUgKSA8PCA4IF4gKCB0aGlzLmIgKiAyNTUgKSA8PCAwO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0SGV4U3RyaW5nOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuICggJzAwMDAwMCcgKyB0aGlzLmdldEhleCgpLnRvU3RyaW5nKCAxNiApICkuc2xpY2UoIC0gNiApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0SFNMOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdC8vIGgscyxsIHJhbmdlcyBhcmUgaW4gMC4wIC0gMS4wXFxuXFxuXFx0XFx0XFx0dmFyIGhzbCA9IG9wdGlvbmFsVGFyZ2V0IHx8IHsgaDogMCwgczogMCwgbDogMCB9O1xcblxcblxcdFxcdFxcdHZhciByID0gdGhpcy5yLCBnID0gdGhpcy5nLCBiID0gdGhpcy5iO1xcblxcblxcdFxcdFxcdHZhciBtYXggPSBNYXRoLm1heCggciwgZywgYiApO1xcblxcdFxcdFxcdHZhciBtaW4gPSBNYXRoLm1pbiggciwgZywgYiApO1xcblxcblxcdFxcdFxcdHZhciBodWUsIHNhdHVyYXRpb247XFxuXFx0XFx0XFx0dmFyIGxpZ2h0bmVzcyA9ICggbWluICsgbWF4ICkgLyAyLjA7XFxuXFxuXFx0XFx0XFx0aWYgKCBtaW4gPT09IG1heCApIHtcXG5cXG5cXHRcXHRcXHRcXHRodWUgPSAwO1xcblxcdFxcdFxcdFxcdHNhdHVyYXRpb24gPSAwO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGRlbHRhID0gbWF4IC0gbWluO1xcblxcblxcdFxcdFxcdFxcdHNhdHVyYXRpb24gPSBsaWdodG5lc3MgPD0gMC41ID8gZGVsdGEgLyAoIG1heCArIG1pbiApIDogZGVsdGEgLyAoIDIgLSBtYXggLSBtaW4gKTtcXG5cXG5cXHRcXHRcXHRcXHRzd2l0Y2ggKCBtYXggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSByOiBodWUgPSAoIGcgLSBiICkgLyBkZWx0YSArICggZyA8IGIgPyA2IDogMCApOyBicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRjYXNlIGc6IGh1ZSA9ICggYiAtIHIgKSAvIGRlbHRhICsgMjsgYnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSBiOiBodWUgPSAoIHIgLSBnICkgLyBkZWx0YSArIDQ7IGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRodWUgLz0gNjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aHNsLmggPSBodWU7XFxuXFx0XFx0XFx0aHNsLnMgPSBzYXR1cmF0aW9uO1xcblxcdFxcdFxcdGhzbC5sID0gbGlnaHRuZXNzO1xcblxcblxcdFxcdFxcdHJldHVybiBoc2w7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRTdHlsZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiAncmdiKCcgKyAoICggdGhpcy5yICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5nICogMjU1ICkgfCAwICkgKyAnLCcgKyAoICggdGhpcy5iICogMjU1ICkgfCAwICkgKyAnKSc7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRvZmZzZXRIU0w6IGZ1bmN0aW9uICggaCwgcywgbCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgaHNsID0gdGhpcy5nZXRIU0woKTtcXG5cXG5cXHRcXHRcXHRoc2wuaCArPSBoOyBoc2wucyArPSBzOyBoc2wubCArPSBsO1xcblxcblxcdFxcdFxcdHRoaXMuc2V0SFNMKCBoc2wuaCwgaHNsLnMsIGhzbC5sICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhZGQ6IGZ1bmN0aW9uICggY29sb3IgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5yICs9IGNvbG9yLnI7XFxuXFx0XFx0XFx0dGhpcy5nICs9IGNvbG9yLmc7XFxuXFx0XFx0XFx0dGhpcy5iICs9IGNvbG9yLmI7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhZGRDb2xvcnM6IGZ1bmN0aW9uICggY29sb3IxLCBjb2xvcjIgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5yID0gY29sb3IxLnIgKyBjb2xvcjIucjtcXG5cXHRcXHRcXHR0aGlzLmcgPSBjb2xvcjEuZyArIGNvbG9yMi5nO1xcblxcdFxcdFxcdHRoaXMuYiA9IGNvbG9yMS5iICsgY29sb3IyLmI7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhZGRTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnIgKz0gcztcXG5cXHRcXHRcXHR0aGlzLmcgKz0gcztcXG5cXHRcXHRcXHR0aGlzLmIgKz0gcztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHN1YjogZnVuY3Rpb24gKCBjb2xvciApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnIgPSBNYXRoLm1heCggMCwgdGhpcy5yIC0gY29sb3IuciApO1xcblxcdFxcdFxcdHRoaXMuZyA9IE1hdGgubWF4KCAwLCB0aGlzLmcgLSBjb2xvci5nICk7XFxuXFx0XFx0XFx0dGhpcy5iID0gTWF0aC5tYXgoIDAsIHRoaXMuYiAtIGNvbG9yLmIgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG11bHRpcGx5OiBmdW5jdGlvbiAoIGNvbG9yICkge1xcblxcblxcdFxcdFxcdHRoaXMuciAqPSBjb2xvci5yO1xcblxcdFxcdFxcdHRoaXMuZyAqPSBjb2xvci5nO1xcblxcdFxcdFxcdHRoaXMuYiAqPSBjb2xvci5iO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bXVsdGlwbHlTY2FsYXI6IGZ1bmN0aW9uICggcyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnIgKj0gcztcXG5cXHRcXHRcXHR0aGlzLmcgKj0gcztcXG5cXHRcXHRcXHR0aGlzLmIgKj0gcztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGxlcnA6IGZ1bmN0aW9uICggY29sb3IsIGFscGhhICkge1xcblxcblxcdFxcdFxcdHRoaXMuciArPSAoIGNvbG9yLnIgLSB0aGlzLnIgKSAqIGFscGhhO1xcblxcdFxcdFxcdHRoaXMuZyArPSAoIGNvbG9yLmcgLSB0aGlzLmcgKSAqIGFscGhhO1xcblxcdFxcdFxcdHRoaXMuYiArPSAoIGNvbG9yLmIgLSB0aGlzLmIgKSAqIGFscGhhO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZXF1YWxzOiBmdW5jdGlvbiAoIGMgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuICggYy5yID09PSB0aGlzLnIgKSAmJiAoIGMuZyA9PT0gdGhpcy5nICkgJiYgKCBjLmIgPT09IHRoaXMuYiApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBvZmZzZXQgPT09IHVuZGVmaW5lZCApIG9mZnNldCA9IDA7XFxuXFxuXFx0XFx0XFx0dGhpcy5yID0gYXJyYXlbIG9mZnNldCBdO1xcblxcdFxcdFxcdHRoaXMuZyA9IGFycmF5WyBvZmZzZXQgKyAxIF07XFxuXFx0XFx0XFx0dGhpcy5iID0gYXJyYXlbIG9mZnNldCArIDIgXTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRvQXJyYXk6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGFycmF5ID09PSB1bmRlZmluZWQgKSBhcnJheSA9IFtdO1xcblxcdFxcdFxcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xcblxcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgXSA9IHRoaXMucjtcXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsgMSBdID0gdGhpcy5nO1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLmI7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGFycmF5O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dG9KU09OOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0SGV4KCk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBVbmlmb3JtcyBsaWJyYXJ5IGZvciBzaGFyZWQgd2ViZ2wgc2hhZGVyc1xcblxcdCAqL1xcblxcblxcdHZhciBVbmlmb3Jtc0xpYiA9IHtcXG5cXG5cXHRcXHRjb21tb246IHtcXG5cXG5cXHRcXHRcXHRkaWZmdXNlOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4ZWVlZWVlICkgfSxcXG5cXHRcXHRcXHRvcGFjaXR5OiB7IHZhbHVlOiAxLjAgfSxcXG5cXG5cXHRcXHRcXHRtYXA6IHsgdmFsdWU6IG51bGwgfSxcXG5cXHRcXHRcXHR1dlRyYW5zZm9ybTogeyB2YWx1ZTogbmV3IE1hdHJpeDMoKSB9LFxcblxcblxcdFxcdFxcdGFscGhhTWFwOiB7IHZhbHVlOiBudWxsIH0sXFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzcGVjdWxhcm1hcDoge1xcblxcblxcdFxcdFxcdHNwZWN1bGFyTWFwOiB7IHZhbHVlOiBudWxsIH0sXFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRlbnZtYXA6IHtcXG5cXG5cXHRcXHRcXHRlbnZNYXA6IHsgdmFsdWU6IG51bGwgfSxcXG5cXHRcXHRcXHRmbGlwRW52TWFwOiB7IHZhbHVlOiAtIDEgfSxcXG5cXHRcXHRcXHRyZWZsZWN0aXZpdHk6IHsgdmFsdWU6IDEuMCB9LFxcblxcdFxcdFxcdHJlZnJhY3Rpb25SYXRpbzogeyB2YWx1ZTogMC45OCB9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhb21hcDoge1xcblxcblxcdFxcdFxcdGFvTWFwOiB7IHZhbHVlOiBudWxsIH0sXFxuXFx0XFx0XFx0YW9NYXBJbnRlbnNpdHk6IHsgdmFsdWU6IDEgfVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bGlnaHRtYXA6IHtcXG5cXG5cXHRcXHRcXHRsaWdodE1hcDogeyB2YWx1ZTogbnVsbCB9LFxcblxcdFxcdFxcdGxpZ2h0TWFwSW50ZW5zaXR5OiB7IHZhbHVlOiAxIH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGVtaXNzaXZlbWFwOiB7XFxuXFxuXFx0XFx0XFx0ZW1pc3NpdmVNYXA6IHsgdmFsdWU6IG51bGwgfVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YnVtcG1hcDoge1xcblxcblxcdFxcdFxcdGJ1bXBNYXA6IHsgdmFsdWU6IG51bGwgfSxcXG5cXHRcXHRcXHRidW1wU2NhbGU6IHsgdmFsdWU6IDEgfVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bm9ybWFsbWFwOiB7XFxuXFxuXFx0XFx0XFx0bm9ybWFsTWFwOiB7IHZhbHVlOiBudWxsIH0sXFxuXFx0XFx0XFx0bm9ybWFsU2NhbGU6IHsgdmFsdWU6IG5ldyBWZWN0b3IyKCAxLCAxICkgfVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGlzcGxhY2VtZW50bWFwOiB7XFxuXFxuXFx0XFx0XFx0ZGlzcGxhY2VtZW50TWFwOiB7IHZhbHVlOiBudWxsIH0sXFxuXFx0XFx0XFx0ZGlzcGxhY2VtZW50U2NhbGU6IHsgdmFsdWU6IDEgfSxcXG5cXHRcXHRcXHRkaXNwbGFjZW1lbnRCaWFzOiB7IHZhbHVlOiAwIH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHJvdWdobmVzc21hcDoge1xcblxcblxcdFxcdFxcdHJvdWdobmVzc01hcDogeyB2YWx1ZTogbnVsbCB9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtZXRhbG5lc3NtYXA6IHtcXG5cXG5cXHRcXHRcXHRtZXRhbG5lc3NNYXA6IHsgdmFsdWU6IG51bGwgfVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z3JhZGllbnRtYXA6IHtcXG5cXG5cXHRcXHRcXHRncmFkaWVudE1hcDogeyB2YWx1ZTogbnVsbCB9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmb2c6IHtcXG5cXG5cXHRcXHRcXHRmb2dEZW5zaXR5OiB7IHZhbHVlOiAwLjAwMDI1IH0sXFxuXFx0XFx0XFx0Zm9nTmVhcjogeyB2YWx1ZTogMSB9LFxcblxcdFxcdFxcdGZvZ0ZhcjogeyB2YWx1ZTogMjAwMCB9LFxcblxcdFxcdFxcdGZvZ0NvbG9yOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4ZmZmZmZmICkgfVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bGlnaHRzOiB7XFxuXFxuXFx0XFx0XFx0YW1iaWVudExpZ2h0Q29sb3I6IHsgdmFsdWU6IFtdIH0sXFxuXFxuXFx0XFx0XFx0ZGlyZWN0aW9uYWxMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XFxuXFx0XFx0XFx0XFx0ZGlyZWN0aW9uOiB7fSxcXG5cXHRcXHRcXHRcXHRjb2xvcjoge30sXFxuXFxuXFx0XFx0XFx0XFx0c2hhZG93OiB7fSxcXG5cXHRcXHRcXHRcXHRzaGFkb3dCaWFzOiB7fSxcXG5cXHRcXHRcXHRcXHRzaGFkb3dSYWRpdXM6IHt9LFxcblxcdFxcdFxcdFxcdHNoYWRvd01hcFNpemU6IHt9XFxuXFx0XFx0XFx0fSB9LFxcblxcblxcdFxcdFxcdGRpcmVjdGlvbmFsU2hhZG93TWFwOiB7IHZhbHVlOiBbXSB9LFxcblxcdFxcdFxcdGRpcmVjdGlvbmFsU2hhZG93TWF0cml4OiB7IHZhbHVlOiBbXSB9LFxcblxcblxcdFxcdFxcdHNwb3RMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XFxuXFx0XFx0XFx0XFx0Y29sb3I6IHt9LFxcblxcdFxcdFxcdFxcdHBvc2l0aW9uOiB7fSxcXG5cXHRcXHRcXHRcXHRkaXJlY3Rpb246IHt9LFxcblxcdFxcdFxcdFxcdGRpc3RhbmNlOiB7fSxcXG5cXHRcXHRcXHRcXHRjb25lQ29zOiB7fSxcXG5cXHRcXHRcXHRcXHRwZW51bWJyYUNvczoge30sXFxuXFx0XFx0XFx0XFx0ZGVjYXk6IHt9LFxcblxcblxcdFxcdFxcdFxcdHNoYWRvdzoge30sXFxuXFx0XFx0XFx0XFx0c2hhZG93Qmlhczoge30sXFxuXFx0XFx0XFx0XFx0c2hhZG93UmFkaXVzOiB7fSxcXG5cXHRcXHRcXHRcXHRzaGFkb3dNYXBTaXplOiB7fVxcblxcdFxcdFxcdH0gfSxcXG5cXG5cXHRcXHRcXHRzcG90U2hhZG93TWFwOiB7IHZhbHVlOiBbXSB9LFxcblxcdFxcdFxcdHNwb3RTaGFkb3dNYXRyaXg6IHsgdmFsdWU6IFtdIH0sXFxuXFxuXFx0XFx0XFx0cG9pbnRMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XFxuXFx0XFx0XFx0XFx0Y29sb3I6IHt9LFxcblxcdFxcdFxcdFxcdHBvc2l0aW9uOiB7fSxcXG5cXHRcXHRcXHRcXHRkZWNheToge30sXFxuXFx0XFx0XFx0XFx0ZGlzdGFuY2U6IHt9LFxcblxcblxcdFxcdFxcdFxcdHNoYWRvdzoge30sXFxuXFx0XFx0XFx0XFx0c2hhZG93Qmlhczoge30sXFxuXFx0XFx0XFx0XFx0c2hhZG93UmFkaXVzOiB7fSxcXG5cXHRcXHRcXHRcXHRzaGFkb3dNYXBTaXplOiB7fSxcXG5cXHRcXHRcXHRcXHRzaGFkb3dDYW1lcmFOZWFyOiB7fSxcXG5cXHRcXHRcXHRcXHRzaGFkb3dDYW1lcmFGYXI6IHt9XFxuXFx0XFx0XFx0fSB9LFxcblxcblxcdFxcdFxcdHBvaW50U2hhZG93TWFwOiB7IHZhbHVlOiBbXSB9LFxcblxcdFxcdFxcdHBvaW50U2hhZG93TWF0cml4OiB7IHZhbHVlOiBbXSB9LFxcblxcblxcdFxcdFxcdGhlbWlzcGhlcmVMaWdodHM6IHsgdmFsdWU6IFtdLCBwcm9wZXJ0aWVzOiB7XFxuXFx0XFx0XFx0XFx0ZGlyZWN0aW9uOiB7fSxcXG5cXHRcXHRcXHRcXHRza3lDb2xvcjoge30sXFxuXFx0XFx0XFx0XFx0Z3JvdW5kQ29sb3I6IHt9XFxuXFx0XFx0XFx0fSB9LFxcblxcblxcdFxcdFxcdC8vIFRPRE8gKGFiZWxuYXRpb24pOiBSZWN0QXJlYUxpZ2h0IEJSREYgZGF0YSBuZWVkcyB0byBiZSBtb3ZlZCBmcm9tIGV4YW1wbGUgdG8gbWFpbiBzcmNcXG5cXHRcXHRcXHRyZWN0QXJlYUxpZ2h0czogeyB2YWx1ZTogW10sIHByb3BlcnRpZXM6IHtcXG5cXHRcXHRcXHRcXHRjb2xvcjoge30sXFxuXFx0XFx0XFx0XFx0cG9zaXRpb246IHt9LFxcblxcdFxcdFxcdFxcdHdpZHRoOiB7fSxcXG5cXHRcXHRcXHRcXHRoZWlnaHQ6IHt9XFxuXFx0XFx0XFx0fSB9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwb2ludHM6IHtcXG5cXG5cXHRcXHRcXHRkaWZmdXNlOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4ZWVlZWVlICkgfSxcXG5cXHRcXHRcXHRvcGFjaXR5OiB7IHZhbHVlOiAxLjAgfSxcXG5cXHRcXHRcXHRzaXplOiB7IHZhbHVlOiAxLjAgfSxcXG5cXHRcXHRcXHRzY2FsZTogeyB2YWx1ZTogMS4wIH0sXFxuXFx0XFx0XFx0bWFwOiB7IHZhbHVlOiBudWxsIH0sXFxuXFx0XFx0XFx0dXZUcmFuc2Zvcm06IHsgdmFsdWU6IG5ldyBNYXRyaXgzKCkgfVxcblxcblxcdFxcdH1cXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIFVuaWZvcm0gVXRpbGl0aWVzXFxuXFx0ICovXFxuXFxuXFx0dmFyIFVuaWZvcm1zVXRpbHMgPSB7XFxuXFxuXFx0XFx0bWVyZ2U6IGZ1bmN0aW9uICggdW5pZm9ybXMgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG1lcmdlZCA9IHt9O1xcblxcblxcdFxcdFxcdGZvciAoIHZhciB1ID0gMDsgdSA8IHVuaWZvcm1zLmxlbmd0aDsgdSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdG1wID0gdGhpcy5jbG9uZSggdW5pZm9ybXNbIHUgXSApO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBwIGluIHRtcCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtZXJnZWRbIHAgXSA9IHRtcFsgcCBdO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG1lcmdlZDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoIHVuaWZvcm1zX3NyYyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdW5pZm9ybXNfZHN0ID0ge307XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIHUgaW4gdW5pZm9ybXNfc3JjICkge1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zX2RzdFsgdSBdID0ge307XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIHAgaW4gdW5pZm9ybXNfc3JjWyB1IF0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHBhcmFtZXRlcl9zcmMgPSB1bmlmb3Jtc19zcmNbIHUgXVsgcCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggcGFyYW1ldGVyX3NyYyAmJiAoIHBhcmFtZXRlcl9zcmMuaXNDb2xvciB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdHBhcmFtZXRlcl9zcmMuaXNNYXRyaXgzIHx8IHBhcmFtZXRlcl9zcmMuaXNNYXRyaXg0IHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0cGFyYW1ldGVyX3NyYy5pc1ZlY3RvcjIgfHwgcGFyYW1ldGVyX3NyYy5pc1ZlY3RvcjMgfHwgcGFyYW1ldGVyX3NyYy5pc1ZlY3RvcjQgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRwYXJhbWV0ZXJfc3JjLmlzVGV4dHVyZSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggcGFyYW1ldGVyX3NyYyApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zX2RzdFsgdSBdWyBwIF0gPSBwYXJhbWV0ZXJfc3JjLnNsaWNlKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3Jtc19kc3RbIHUgXVsgcCBdID0gcGFyYW1ldGVyX3NyYztcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdW5pZm9ybXNfZHN0O1xcblxcblxcdFxcdH1cXG5cXG5cXHR9O1xcblxcblxcdHZhciBhbHBoYW1hcF9mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX0FMUEhBTUFQXFxcXG5cXFxcdGRpZmZ1c2VDb2xvci5hICo9IHRleHR1cmUyRCggYWxwaGFNYXAsIHZVdiApLmc7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGFscGhhbWFwX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9BTFBIQU1BUFxcXFxuXFxcXHR1bmlmb3JtIHNhbXBsZXIyRCBhbHBoYU1hcDtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgYWxwaGF0ZXN0X2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBBTFBIQVRFU1RcXFxcblxcXFx0aWYgKCBkaWZmdXNlQ29sb3IuYSA8IEFMUEhBVEVTVCApIGRpc2NhcmQ7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGFvbWFwX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfQU9NQVBcXFxcblxcXFx0ZmxvYXQgYW1iaWVudE9jY2x1c2lvbiA9ICggdGV4dHVyZTJEKCBhb01hcCwgdlV2MiApLnIgLSAxLjAgKSAqIGFvTWFwSW50ZW5zaXR5ICsgMS4wO1xcXFxuXFxcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKj0gYW1iaWVudE9jY2x1c2lvbjtcXFxcblxcXFx0I2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBQSFlTSUNBTCApXFxcXG5cXFxcdFxcXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xcXFxuXFxcXHRcXFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0U3BlY3VsYXIgKj0gY29tcHV0ZVNwZWN1bGFyT2NjbHVzaW9uKCBkb3ROViwgYW1iaWVudE9jY2x1c2lvbiwgbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3MgKTtcXFxcblxcXFx0I2VuZGlmXFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGFvbWFwX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9BT01BUFxcXFxuXFxcXHR1bmlmb3JtIHNhbXBsZXIyRCBhb01hcDtcXFxcblxcXFx0dW5pZm9ybSBmbG9hdCBhb01hcEludGVuc2l0eTtcXFxcbiNlbmRpZlxcXCI7XFxuXFxuXFx0dmFyIGJlZ2luX3ZlcnRleCA9IFxcXCJcXFxcbnZlYzMgdHJhbnNmb3JtZWQgPSB2ZWMzKCBwb3NpdGlvbiApO1xcXFxuXFxcIjtcXG5cXG5cXHR2YXIgYmVnaW5ub3JtYWxfdmVydGV4ID0gXFxcIlxcXFxudmVjMyBvYmplY3ROb3JtYWwgPSB2ZWMzKCBub3JtYWwgKTtcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGJzZGZzID0gXFxcImZsb2F0IHB1bmN0dWFsTGlnaHRJbnRlbnNpdHlUb0lycmFkaWFuY2VGYWN0b3IoIGNvbnN0IGluIGZsb2F0IGxpZ2h0RGlzdGFuY2UsIGNvbnN0IGluIGZsb2F0IGN1dG9mZkRpc3RhbmNlLCBjb25zdCBpbiBmbG9hdCBkZWNheUV4cG9uZW50ICkge1xcXFxuXFxcXHRpZiggZGVjYXlFeHBvbmVudCA+IDAuMCApIHtcXFxcbiNpZiBkZWZpbmVkICggUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUUyApXFxcXG5cXFxcdFxcXFx0ZmxvYXQgZGlzdGFuY2VGYWxsb2ZmID0gMS4wIC8gbWF4KCBwb3coIGxpZ2h0RGlzdGFuY2UsIGRlY2F5RXhwb25lbnQgKSwgMC4wMSApO1xcXFxuXFxcXHRcXFxcdGZsb2F0IG1heERpc3RhbmNlQ3V0b2ZmRmFjdG9yID0gcG93Miggc2F0dXJhdGUoIDEuMCAtIHBvdzQoIGxpZ2h0RGlzdGFuY2UgLyBjdXRvZmZEaXN0YW5jZSApICkgKTtcXFxcblxcXFx0XFxcXHRyZXR1cm4gZGlzdGFuY2VGYWxsb2ZmICogbWF4RGlzdGFuY2VDdXRvZmZGYWN0b3I7XFxcXG4jZWxzZVxcXFxuXFxcXHRcXFxcdHJldHVybiBwb3coIHNhdHVyYXRlKCAtbGlnaHREaXN0YW5jZSAvIGN1dG9mZkRpc3RhbmNlICsgMS4wICksIGRlY2F5RXhwb25lbnQgKTtcXFxcbiNlbmRpZlxcXFxuXFxcXHR9XFxcXG5cXFxcdHJldHVybiAxLjA7XFxcXG59XFxcXG52ZWMzIEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBjb25zdCBpbiB2ZWMzIGRpZmZ1c2VDb2xvciApIHtcXFxcblxcXFx0cmV0dXJuIFJFQ0lQUk9DQUxfUEkgKiBkaWZmdXNlQ29sb3I7XFxcXG59XFxcXG52ZWMzIEZfU2NobGljayggY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCBkb3RMSCApIHtcXFxcblxcXFx0ZmxvYXQgZnJlc25lbCA9IGV4cDIoICggLTUuNTU0NzMgKiBkb3RMSCAtIDYuOTgzMTYgKSAqIGRvdExIICk7XFxcXG5cXFxcdHJldHVybiAoIDEuMCAtIHNwZWN1bGFyQ29sb3IgKSAqIGZyZXNuZWwgKyBzcGVjdWxhckNvbG9yO1xcXFxufVxcXFxuZmxvYXQgR19HR1hfU21pdGgoIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROTCwgY29uc3QgaW4gZmxvYXQgZG90TlYgKSB7XFxcXG5cXFxcdGZsb2F0IGEyID0gcG93MiggYWxwaGEgKTtcXFxcblxcXFx0ZmxvYXQgZ2wgPSBkb3ROTCArIHNxcnQoIGEyICsgKCAxLjAgLSBhMiApICogcG93MiggZG90TkwgKSApO1xcXFxuXFxcXHRmbG9hdCBndiA9IGRvdE5WICsgc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROViApICk7XFxcXG5cXFxcdHJldHVybiAxLjAgLyAoIGdsICogZ3YgKTtcXFxcbn1cXFxcbmZsb2F0IEdfR0dYX1NtaXRoQ29ycmVsYXRlZCggY29uc3QgaW4gZmxvYXQgYWxwaGEsIGNvbnN0IGluIGZsb2F0IGRvdE5MLCBjb25zdCBpbiBmbG9hdCBkb3ROViApIHtcXFxcblxcXFx0ZmxvYXQgYTIgPSBwb3cyKCBhbHBoYSApO1xcXFxuXFxcXHRmbG9hdCBndiA9IGRvdE5MICogc3FydCggYTIgKyAoIDEuMCAtIGEyICkgKiBwb3cyKCBkb3ROViApICk7XFxcXG5cXFxcdGZsb2F0IGdsID0gZG90TlYgKiBzcXJ0KCBhMiArICggMS4wIC0gYTIgKSAqIHBvdzIoIGRvdE5MICkgKTtcXFxcblxcXFx0cmV0dXJuIDAuNSAvIG1heCggZ3YgKyBnbCwgRVBTSUxPTiApO1xcXFxufVxcXFxuZmxvYXQgRF9HR1goIGNvbnN0IGluIGZsb2F0IGFscGhhLCBjb25zdCBpbiBmbG9hdCBkb3ROSCApIHtcXFxcblxcXFx0ZmxvYXQgYTIgPSBwb3cyKCBhbHBoYSApO1xcXFxuXFxcXHRmbG9hdCBkZW5vbSA9IHBvdzIoIGRvdE5IICkgKiAoIGEyIC0gMS4wICkgKyAxLjA7XFxcXG5cXFxcdHJldHVybiBSRUNJUFJPQ0FMX1BJICogYTIgLyBwb3cyKCBkZW5vbSApO1xcXFxufVxcXFxudmVjMyBCUkRGX1NwZWN1bGFyX0dHWCggY29uc3QgaW4gSW5jaWRlbnRMaWdodCBpbmNpZGVudExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiB2ZWMzIHNwZWN1bGFyQ29sb3IsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXFxcblxcXFx0ZmxvYXQgYWxwaGEgPSBwb3cyKCByb3VnaG5lc3MgKTtcXFxcblxcXFx0dmVjMyBoYWxmRGlyID0gbm9ybWFsaXplKCBpbmNpZGVudExpZ2h0LmRpcmVjdGlvbiArIGdlb21ldHJ5LnZpZXdEaXIgKTtcXFxcblxcXFx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uICkgKTtcXFxcblxcXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xcXFxuXFxcXHRmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgaGFsZkRpciApICk7XFxcXG5cXFxcdGZsb2F0IGRvdExIID0gc2F0dXJhdGUoIGRvdCggaW5jaWRlbnRMaWdodC5kaXJlY3Rpb24sIGhhbGZEaXIgKSApO1xcXFxuXFxcXHR2ZWMzIEYgPSBGX1NjaGxpY2soIHNwZWN1bGFyQ29sb3IsIGRvdExIICk7XFxcXG5cXFxcdGZsb2F0IEcgPSBHX0dHWF9TbWl0aENvcnJlbGF0ZWQoIGFscGhhLCBkb3ROTCwgZG90TlYgKTtcXFxcblxcXFx0ZmxvYXQgRCA9IERfR0dYKCBhbHBoYSwgZG90TkggKTtcXFxcblxcXFx0cmV0dXJuIEYgKiAoIEcgKiBEICk7XFxcXG59XFxcXG52ZWMyIExUQ19VdiggY29uc3QgaW4gdmVjMyBOLCBjb25zdCBpbiB2ZWMzIFYsIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcyApIHtcXFxcblxcXFx0Y29uc3QgZmxvYXQgTFVUX1NJWkUgID0gNjQuMDtcXFxcblxcXFx0Y29uc3QgZmxvYXQgTFVUX1NDQUxFID0gKCBMVVRfU0laRSAtIDEuMCApIC8gTFVUX1NJWkU7XFxcXG5cXFxcdGNvbnN0IGZsb2F0IExVVF9CSUFTICA9IDAuNSAvIExVVF9TSVpFO1xcXFxuXFxcXHRmbG9hdCB0aGV0YSA9IGFjb3MoIGRvdCggTiwgViApICk7XFxcXG5cXFxcdHZlYzIgdXYgPSB2ZWMyKFxcXFxuXFxcXHRcXFxcdHNxcnQoIHNhdHVyYXRlKCByb3VnaG5lc3MgKSApLFxcXFxuXFxcXHRcXFxcdHNhdHVyYXRlKCB0aGV0YSAvICggMC41ICogUEkgKSApICk7XFxcXG5cXFxcdHV2ID0gdXYgKiBMVVRfU0NBTEUgKyBMVVRfQklBUztcXFxcblxcXFx0cmV0dXJuIHV2O1xcXFxufVxcXFxuZmxvYXQgTFRDX0NsaXBwZWRTcGhlcmVGb3JtRmFjdG9yKCBjb25zdCBpbiB2ZWMzIGYgKSB7XFxcXG5cXFxcdGZsb2F0IGwgPSBsZW5ndGgoIGYgKTtcXFxcblxcXFx0cmV0dXJuIG1heCggKCBsICogbCArIGYueiApIC8gKCBsICsgMS4wICksIDAuMCApO1xcXFxufVxcXFxudmVjMyBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvbnN0IGluIHZlYzMgdjEsIGNvbnN0IGluIHZlYzMgdjIgKSB7XFxcXG5cXFxcdGZsb2F0IHggPSBkb3QoIHYxLCB2MiApO1xcXFxuXFxcXHRmbG9hdCB5ID0gYWJzKCB4ICk7XFxcXG5cXFxcdGZsb2F0IGEgPSAwLjg2MjY3ICsgKDAuNDk3ODggKyAwLjAxNDM2ICogeSApICogeTtcXFxcblxcXFx0ZmxvYXQgYiA9IDMuNDUwNjggKyAoNC4xODgxNCArIHkpICogeTtcXFxcblxcXFx0ZmxvYXQgdiA9IGEgLyBiO1xcXFxuXFxcXHRmbG9hdCB0aGV0YV9zaW50aGV0YSA9ICh4ID4gMC4wKSA/IHYgOiAwLjUgKiBpbnZlcnNlc3FydCggMS4wIC0geCAqIHggKSAtIHY7XFxcXG5cXFxcdHJldHVybiBjcm9zcyggdjEsIHYyICkgKiB0aGV0YV9zaW50aGV0YTtcXFxcbn1cXFxcbnZlYzMgTFRDX0V2YWx1YXRlKCBjb25zdCBpbiB2ZWMzIE4sIGNvbnN0IGluIHZlYzMgViwgY29uc3QgaW4gdmVjMyBQLCBjb25zdCBpbiBtYXQzIG1JbnYsIGNvbnN0IGluIHZlYzMgcmVjdENvb3Jkc1sgNCBdICkge1xcXFxuXFxcXHR2ZWMzIHYxID0gcmVjdENvb3Jkc1sgMSBdIC0gcmVjdENvb3Jkc1sgMCBdO1xcXFxuXFxcXHR2ZWMzIHYyID0gcmVjdENvb3Jkc1sgMyBdIC0gcmVjdENvb3Jkc1sgMCBdO1xcXFxuXFxcXHR2ZWMzIGxpZ2h0Tm9ybWFsID0gY3Jvc3MoIHYxLCB2MiApO1xcXFxuXFxcXHRpZiggZG90KCBsaWdodE5vcm1hbCwgUCAtIHJlY3RDb29yZHNbIDAgXSApIDwgMC4wICkgcmV0dXJuIHZlYzMoIDAuMCApO1xcXFxuXFxcXHR2ZWMzIFQxLCBUMjtcXFxcblxcXFx0VDEgPSBub3JtYWxpemUoIFYgLSBOICogZG90KCBWLCBOICkgKTtcXFxcblxcXFx0VDIgPSAtIGNyb3NzKCBOLCBUMSApO1xcXFxuXFxcXHRtYXQzIG1hdCA9IG1JbnYgKiB0cmFuc3Bvc2VNYXQzKCBtYXQzKCBUMSwgVDIsIE4gKSApO1xcXFxuXFxcXHR2ZWMzIGNvb3Jkc1sgNCBdO1xcXFxuXFxcXHRjb29yZHNbIDAgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMCBdIC0gUCApO1xcXFxuXFxcXHRjb29yZHNbIDEgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMSBdIC0gUCApO1xcXFxuXFxcXHRjb29yZHNbIDIgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMiBdIC0gUCApO1xcXFxuXFxcXHRjb29yZHNbIDMgXSA9IG1hdCAqICggcmVjdENvb3Jkc1sgMyBdIC0gUCApO1xcXFxuXFxcXHRjb29yZHNbIDAgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAwIF0gKTtcXFxcblxcXFx0Y29vcmRzWyAxIF0gPSBub3JtYWxpemUoIGNvb3Jkc1sgMSBdICk7XFxcXG5cXFxcdGNvb3Jkc1sgMiBdID0gbm9ybWFsaXplKCBjb29yZHNbIDIgXSApO1xcXFxuXFxcXHRjb29yZHNbIDMgXSA9IG5vcm1hbGl6ZSggY29vcmRzWyAzIF0gKTtcXFxcblxcXFx0dmVjMyB2ZWN0b3JGb3JtRmFjdG9yID0gdmVjMyggMC4wICk7XFxcXG5cXFxcdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDAgXSwgY29vcmRzWyAxIF0gKTtcXFxcblxcXFx0dmVjdG9yRm9ybUZhY3RvciArPSBMVENfRWRnZVZlY3RvckZvcm1GYWN0b3IoIGNvb3Jkc1sgMSBdLCBjb29yZHNbIDIgXSApO1xcXFxuXFxcXHR2ZWN0b3JGb3JtRmFjdG9yICs9IExUQ19FZGdlVmVjdG9yRm9ybUZhY3RvciggY29vcmRzWyAyIF0sIGNvb3Jkc1sgMyBdICk7XFxcXG5cXFxcdHZlY3RvckZvcm1GYWN0b3IgKz0gTFRDX0VkZ2VWZWN0b3JGb3JtRmFjdG9yKCBjb29yZHNbIDMgXSwgY29vcmRzWyAwIF0gKTtcXFxcblxcXFx0dmVjMyByZXN1bHQgPSB2ZWMzKCBMVENfQ2xpcHBlZFNwaGVyZUZvcm1GYWN0b3IoIHZlY3RvckZvcm1GYWN0b3IgKSApO1xcXFxuXFxcXHRyZXR1cm4gcmVzdWx0O1xcXFxufVxcXFxudmVjMyBCUkRGX1NwZWN1bGFyX0dHWF9FbnZpcm9ubWVudCggY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gdmVjMyBzcGVjdWxhckNvbG9yLCBjb25zdCBpbiBmbG9hdCByb3VnaG5lc3MgKSB7XFxcXG5cXFxcdGZsb2F0IGRvdE5WID0gc2F0dXJhdGUoIGRvdCggZ2VvbWV0cnkubm9ybWFsLCBnZW9tZXRyeS52aWV3RGlyICkgKTtcXFxcblxcXFx0Y29uc3QgdmVjNCBjMCA9IHZlYzQoIC0gMSwgLSAwLjAyNzUsIC0gMC41NzIsIDAuMDIyICk7XFxcXG5cXFxcdGNvbnN0IHZlYzQgYzEgPSB2ZWM0KCAxLCAwLjA0MjUsIDEuMDQsIC0gMC4wNCApO1xcXFxuXFxcXHR2ZWM0IHIgPSByb3VnaG5lc3MgKiBjMCArIGMxO1xcXFxuXFxcXHRmbG9hdCBhMDA0ID0gbWluKCByLnggKiByLngsIGV4cDIoIC0gOS4yOCAqIGRvdE5WICkgKSAqIHIueCArIHIueTtcXFxcblxcXFx0dmVjMiBBQiA9IHZlYzIoIC0xLjA0LCAxLjA0ICkgKiBhMDA0ICsgci56dztcXFxcblxcXFx0cmV0dXJuIHNwZWN1bGFyQ29sb3IgKiBBQi54ICsgQUIueTtcXFxcbn1cXFxcbmZsb2F0IEdfQmxpbm5QaG9uZ19JbXBsaWNpdCggKSB7XFxcXG5cXFxcdHJldHVybiAwLjI1O1xcXFxufVxcXFxuZmxvYXQgRF9CbGlublBob25nKCBjb25zdCBpbiBmbG9hdCBzaGluaW5lc3MsIGNvbnN0IGluIGZsb2F0IGRvdE5IICkge1xcXFxuXFxcXHRyZXR1cm4gUkVDSVBST0NBTF9QSSAqICggc2hpbmluZXNzICogMC41ICsgMS4wICkgKiBwb3coIGRvdE5ILCBzaGluaW5lc3MgKTtcXFxcbn1cXFxcbnZlYzMgQlJERl9TcGVjdWxhcl9CbGlublBob25nKCBjb25zdCBpbiBJbmNpZGVudExpZ2h0IGluY2lkZW50TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIHZlYzMgc3BlY3VsYXJDb2xvciwgY29uc3QgaW4gZmxvYXQgc2hpbmluZXNzICkge1xcXFxuXFxcXHR2ZWMzIGhhbGZEaXIgPSBub3JtYWxpemUoIGluY2lkZW50TGlnaHQuZGlyZWN0aW9uICsgZ2VvbWV0cnkudmlld0RpciApO1xcXFxuXFxcXHRmbG9hdCBkb3ROSCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgaGFsZkRpciApICk7XFxcXG5cXFxcdGZsb2F0IGRvdExIID0gc2F0dXJhdGUoIGRvdCggaW5jaWRlbnRMaWdodC5kaXJlY3Rpb24sIGhhbGZEaXIgKSApO1xcXFxuXFxcXHR2ZWMzIEYgPSBGX1NjaGxpY2soIHNwZWN1bGFyQ29sb3IsIGRvdExIICk7XFxcXG5cXFxcdGZsb2F0IEcgPSBHX0JsaW5uUGhvbmdfSW1wbGljaXQoICk7XFxcXG5cXFxcdGZsb2F0IEQgPSBEX0JsaW5uUGhvbmcoIHNoaW5pbmVzcywgZG90TkggKTtcXFxcblxcXFx0cmV0dXJuIEYgKiAoIEcgKiBEICk7XFxcXG59XFxcXG5mbG9hdCBHR1hSb3VnaG5lc3NUb0JsaW5uRXhwb25lbnQoIGNvbnN0IGluIGZsb2F0IGdneFJvdWdobmVzcyApIHtcXFxcblxcXFx0cmV0dXJuICggMi4wIC8gcG93MiggZ2d4Um91Z2huZXNzICsgMC4wMDAxICkgLSAyLjAgKTtcXFxcbn1cXFxcbmZsb2F0IEJsaW5uRXhwb25lbnRUb0dHWFJvdWdobmVzcyggY29uc3QgaW4gZmxvYXQgYmxpbm5FeHBvbmVudCApIHtcXFxcblxcXFx0cmV0dXJuIHNxcnQoIDIuMCAvICggYmxpbm5FeHBvbmVudCArIDIuMCApICk7XFxcXG59XFxcXG5cXFwiO1xcblxcblxcdHZhciBidW1wbWFwX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9CVU1QTUFQXFxcXG5cXFxcdHVuaWZvcm0gc2FtcGxlcjJEIGJ1bXBNYXA7XFxcXG5cXFxcdHVuaWZvcm0gZmxvYXQgYnVtcFNjYWxlO1xcXFxuXFxcXHR2ZWMyIGRIZHh5X2Z3ZCgpIHtcXFxcblxcXFx0XFxcXHR2ZWMyIGRTVGR4ID0gZEZkeCggdlV2ICk7XFxcXG5cXFxcdFxcXFx0dmVjMiBkU1RkeSA9IGRGZHkoIHZVdiApO1xcXFxuXFxcXHRcXFxcdGZsb2F0IEhsbCA9IGJ1bXBTY2FsZSAqIHRleHR1cmUyRCggYnVtcE1hcCwgdlV2ICkueDtcXFxcblxcXFx0XFxcXHRmbG9hdCBkQnggPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR4ICkueCAtIEhsbDtcXFxcblxcXFx0XFxcXHRmbG9hdCBkQnkgPSBidW1wU2NhbGUgKiB0ZXh0dXJlMkQoIGJ1bXBNYXAsIHZVdiArIGRTVGR5ICkueCAtIEhsbDtcXFxcblxcXFx0XFxcXHRyZXR1cm4gdmVjMiggZEJ4LCBkQnkgKTtcXFxcblxcXFx0fVxcXFxuXFxcXHR2ZWMzIHBlcnR1cmJOb3JtYWxBcmIoIHZlYzMgc3VyZl9wb3MsIHZlYzMgc3VyZl9ub3JtLCB2ZWMyIGRIZHh5ICkge1xcXFxuXFxcXHRcXFxcdHZlYzMgdlNpZ21hWCA9IHZlYzMoIGRGZHgoIHN1cmZfcG9zLnggKSwgZEZkeCggc3VyZl9wb3MueSApLCBkRmR4KCBzdXJmX3Bvcy56ICkgKTtcXFxcblxcXFx0XFxcXHR2ZWMzIHZTaWdtYVkgPSB2ZWMzKCBkRmR5KCBzdXJmX3Bvcy54ICksIGRGZHkoIHN1cmZfcG9zLnkgKSwgZEZkeSggc3VyZl9wb3MueiApICk7XFxcXG5cXFxcdFxcXFx0dmVjMyB2TiA9IHN1cmZfbm9ybTtcXFxcblxcXFx0XFxcXHR2ZWMzIFIxID0gY3Jvc3MoIHZTaWdtYVksIHZOICk7XFxcXG5cXFxcdFxcXFx0dmVjMyBSMiA9IGNyb3NzKCB2TiwgdlNpZ21hWCApO1xcXFxuXFxcXHRcXFxcdGZsb2F0IGZEZXQgPSBkb3QoIHZTaWdtYVgsIFIxICk7XFxcXG5cXFxcdFxcXFx0dmVjMyB2R3JhZCA9IHNpZ24oIGZEZXQgKSAqICggZEhkeHkueCAqIFIxICsgZEhkeHkueSAqIFIyICk7XFxcXG5cXFxcdFxcXFx0cmV0dXJuIG5vcm1hbGl6ZSggYWJzKCBmRGV0ICkgKiBzdXJmX25vcm0gLSB2R3JhZCApO1xcXFxuXFxcXHR9XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudCA9IFxcXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcXFxcblxcXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgVU5JT05fQ0xJUFBJTkdfUExBTkVTOyArKyBpICkge1xcXFxuXFxcXHRcXFxcdHZlYzQgcGxhbmUgPSBjbGlwcGluZ1BsYW5lc1sgaSBdO1xcXFxuXFxcXHRcXFxcdGlmICggZG90KCB2Vmlld1Bvc2l0aW9uLCBwbGFuZS54eXogKSA+IHBsYW5lLncgKSBkaXNjYXJkO1xcXFxuXFxcXHR9XFxcXG5cXFxcdFxcXFx0XFxcXG5cXFxcdCNpZiBVTklPTl9DTElQUElOR19QTEFORVMgPCBOVU1fQ0xJUFBJTkdfUExBTkVTXFxcXG5cXFxcdFxcXFx0Ym9vbCBjbGlwcGVkID0gdHJ1ZTtcXFxcblxcXFx0XFxcXHRmb3IgKCBpbnQgaSA9IFVOSU9OX0NMSVBQSU5HX1BMQU5FUzsgaSA8IE5VTV9DTElQUElOR19QTEFORVM7ICsrIGkgKSB7XFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWM0IHBsYW5lID0gY2xpcHBpbmdQbGFuZXNbIGkgXTtcXFxcblxcXFx0XFxcXHRcXFxcdGNsaXBwZWQgPSAoIGRvdCggdlZpZXdQb3NpdGlvbiwgcGxhbmUueHl6ICkgPiBwbGFuZS53ICkgJiYgY2xpcHBlZDtcXFxcblxcXFx0XFxcXHR9XFxcXG5cXFxcdFxcXFx0aWYgKCBjbGlwcGVkICkgZGlzY2FyZDtcXFxcblxcXFx0XFxcXG5cXFxcdCNlbmRpZlxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudCA9IFxcXCIjaWYgTlVNX0NMSVBQSU5HX1BMQU5FUyA+IDBcXFxcblxcXFx0I2lmICEgZGVmaW5lZCggUEhZU0lDQUwgKSAmJiAhIGRlZmluZWQoIFBIT05HIClcXFxcblxcXFx0XFxcXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdHVuaWZvcm0gdmVjNCBjbGlwcGluZ1BsYW5lc1sgTlVNX0NMSVBQSU5HX1BMQU5FUyBdO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXggPSBcXFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwICYmICEgZGVmaW5lZCggUEhZU0lDQUwgKSAmJiAhIGRlZmluZWQoIFBIT05HIClcXFxcblxcXFx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXggPSBcXFwiI2lmIE5VTV9DTElQUElOR19QTEFORVMgPiAwICYmICEgZGVmaW5lZCggUEhZU0lDQUwgKSAmJiAhIGRlZmluZWQoIFBIT05HIClcXFxcblxcXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGNvbG9yX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfQ09MT1JcXFxcblxcXFx0ZGlmZnVzZUNvbG9yLnJnYiAqPSB2Q29sb3I7XFxcXG4jZW5kaWZcXFwiO1xcblxcblxcdHZhciBjb2xvcl9wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfQ09MT1JcXFxcblxcXFx0dmFyeWluZyB2ZWMzIHZDb2xvcjtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgY29sb3JfcGFyc192ZXJ0ZXggPSBcXFwiI2lmZGVmIFVTRV9DT0xPUlxcXFxuXFxcXHR2YXJ5aW5nIHZlYzMgdkNvbG9yO1xcXFxuI2VuZGlmXFxcIjtcXG5cXG5cXHR2YXIgY29sb3JfdmVydGV4ID0gXFxcIiNpZmRlZiBVU0VfQ09MT1JcXFxcblxcXFx0dkNvbG9yLnh5eiA9IGNvbG9yLnh5ejtcXFxcbiNlbmRpZlxcXCI7XFxuXFxuXFx0dmFyIGNvbW1vbiA9IFxcXCIjZGVmaW5lIFBJIDMuMTQxNTkyNjUzNTlcXFxcbiNkZWZpbmUgUEkyIDYuMjgzMTg1MzA3MThcXFxcbiNkZWZpbmUgUElfSEFMRiAxLjU3MDc5NjMyNjc5NDlcXFxcbiNkZWZpbmUgUkVDSVBST0NBTF9QSSAwLjMxODMwOTg4NjE4XFxcXG4jZGVmaW5lIFJFQ0lQUk9DQUxfUEkyIDAuMTU5MTU0OTRcXFxcbiNkZWZpbmUgTE9HMiAxLjQ0MjY5NVxcXFxuI2RlZmluZSBFUFNJTE9OIDFlLTZcXFxcbiNkZWZpbmUgc2F0dXJhdGUoYSkgY2xhbXAoIGEsIDAuMCwgMS4wIClcXFxcbiNkZWZpbmUgd2hpdGVDb21wbGltZW50KGEpICggMS4wIC0gc2F0dXJhdGUoIGEgKSApXFxcXG5mbG9hdCBwb3cyKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4OyB9XFxcXG5mbG9hdCBwb3czKCBjb25zdCBpbiBmbG9hdCB4ICkgeyByZXR1cm4geCp4Kng7IH1cXFxcbmZsb2F0IHBvdzQoIGNvbnN0IGluIGZsb2F0IHggKSB7IGZsb2F0IHgyID0geCp4OyByZXR1cm4geDIqeDI7IH1cXFxcbmZsb2F0IGF2ZXJhZ2UoIGNvbnN0IGluIHZlYzMgY29sb3IgKSB7IHJldHVybiBkb3QoIGNvbG9yLCB2ZWMzKCAwLjMzMzMgKSApOyB9XFxcXG5oaWdocCBmbG9hdCByYW5kKCBjb25zdCBpbiB2ZWMyIHV2ICkge1xcXFxuXFxcXHRjb25zdCBoaWdocCBmbG9hdCBhID0gMTIuOTg5OCwgYiA9IDc4LjIzMywgYyA9IDQzNzU4LjU0NTM7XFxcXG5cXFxcdGhpZ2hwIGZsb2F0IGR0ID0gZG90KCB1di54eSwgdmVjMiggYSxiICkgKSwgc24gPSBtb2QoIGR0LCBQSSApO1xcXFxuXFxcXHRyZXR1cm4gZnJhY3Qoc2luKHNuKSAqIGMpO1xcXFxufVxcXFxuc3RydWN0IEluY2lkZW50TGlnaHQge1xcXFxuXFxcXHR2ZWMzIGNvbG9yO1xcXFxuXFxcXHR2ZWMzIGRpcmVjdGlvbjtcXFxcblxcXFx0Ym9vbCB2aXNpYmxlO1xcXFxufTtcXFxcbnN0cnVjdCBSZWZsZWN0ZWRMaWdodCB7XFxcXG5cXFxcdHZlYzMgZGlyZWN0RGlmZnVzZTtcXFxcblxcXFx0dmVjMyBkaXJlY3RTcGVjdWxhcjtcXFxcblxcXFx0dmVjMyBpbmRpcmVjdERpZmZ1c2U7XFxcXG5cXFxcdHZlYzMgaW5kaXJlY3RTcGVjdWxhcjtcXFxcbn07XFxcXG5zdHJ1Y3QgR2VvbWV0cmljQ29udGV4dCB7XFxcXG5cXFxcdHZlYzMgcG9zaXRpb247XFxcXG5cXFxcdHZlYzMgbm9ybWFsO1xcXFxuXFxcXHR2ZWMzIHZpZXdEaXI7XFxcXG59O1xcXFxudmVjMyB0cmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHtcXFxcblxcXFx0cmV0dXJuIG5vcm1hbGl6ZSggKCBtYXRyaXggKiB2ZWM0KCBkaXIsIDAuMCApICkueHl6ICk7XFxcXG59XFxcXG52ZWMzIGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIGluIHZlYzMgZGlyLCBpbiBtYXQ0IG1hdHJpeCApIHtcXFxcblxcXFx0cmV0dXJuIG5vcm1hbGl6ZSggKCB2ZWM0KCBkaXIsIDAuMCApICogbWF0cml4ICkueHl6ICk7XFxcXG59XFxcXG52ZWMzIHByb2plY3RPblBsYW5lKGluIHZlYzMgcG9pbnQsIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcXFxuXFxcXHRmbG9hdCBkaXN0YW5jZSA9IGRvdCggcGxhbmVOb3JtYWwsIHBvaW50IC0gcG9pbnRPblBsYW5lICk7XFxcXG5cXFxcdHJldHVybiAtIGRpc3RhbmNlICogcGxhbmVOb3JtYWwgKyBwb2ludDtcXFxcbn1cXFxcbmZsb2F0IHNpZGVPZlBsYW5lKCBpbiB2ZWMzIHBvaW50LCBpbiB2ZWMzIHBvaW50T25QbGFuZSwgaW4gdmVjMyBwbGFuZU5vcm1hbCApIHtcXFxcblxcXFx0cmV0dXJuIHNpZ24oIGRvdCggcG9pbnQgLSBwb2ludE9uUGxhbmUsIHBsYW5lTm9ybWFsICkgKTtcXFxcbn1cXFxcbnZlYzMgbGluZVBsYW5lSW50ZXJzZWN0KCBpbiB2ZWMzIHBvaW50T25MaW5lLCBpbiB2ZWMzIGxpbmVEaXJlY3Rpb24sIGluIHZlYzMgcG9pbnRPblBsYW5lLCBpbiB2ZWMzIHBsYW5lTm9ybWFsICkge1xcXFxuXFxcXHRyZXR1cm4gbGluZURpcmVjdGlvbiAqICggZG90KCBwbGFuZU5vcm1hbCwgcG9pbnRPblBsYW5lIC0gcG9pbnRPbkxpbmUgKSAvIGRvdCggcGxhbmVOb3JtYWwsIGxpbmVEaXJlY3Rpb24gKSApICsgcG9pbnRPbkxpbmU7XFxcXG59XFxcXG5tYXQzIHRyYW5zcG9zZU1hdDMoIGNvbnN0IGluIG1hdDMgbSApIHtcXFxcblxcXFx0bWF0MyB0bXA7XFxcXG5cXFxcdHRtcFsgMCBdID0gdmVjMyggbVsgMCBdLngsIG1bIDEgXS54LCBtWyAyIF0ueCApO1xcXFxuXFxcXHR0bXBbIDEgXSA9IHZlYzMoIG1bIDAgXS55LCBtWyAxIF0ueSwgbVsgMiBdLnkgKTtcXFxcblxcXFx0dG1wWyAyIF0gPSB2ZWMzKCBtWyAwIF0ueiwgbVsgMSBdLnosIG1bIDIgXS56ICk7XFxcXG5cXFxcdHJldHVybiB0bXA7XFxcXG59XFxcXG5mbG9hdCBsaW5lYXJUb1JlbGF0aXZlTHVtaW5hbmNlKCBjb25zdCBpbiB2ZWMzIGNvbG9yICkge1xcXFxuXFxcXHR2ZWMzIHdlaWdodHMgPSB2ZWMzKCAwLjIxMjYsIDAuNzE1MiwgMC4wNzIyICk7XFxcXG5cXFxcdHJldHVybiBkb3QoIHdlaWdodHMsIGNvbG9yLnJnYiApO1xcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgY3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFX1VWXFxcXG4jZGVmaW5lIGN1YmVVVl90ZXh0dXJlU2l6ZSAoMTAyNC4wKVxcXFxuaW50IGdldEZhY2VGcm9tRGlyZWN0aW9uKHZlYzMgZGlyZWN0aW9uKSB7XFxcXG5cXFxcdHZlYzMgYWJzRGlyZWN0aW9uID0gYWJzKGRpcmVjdGlvbik7XFxcXG5cXFxcdGludCBmYWNlID0gLTE7XFxcXG5cXFxcdGlmKCBhYnNEaXJlY3Rpb24ueCA+IGFic0RpcmVjdGlvbi56ICkge1xcXFxuXFxcXHRcXFxcdGlmKGFic0RpcmVjdGlvbi54ID4gYWJzRGlyZWN0aW9uLnkgKVxcXFxuXFxcXHRcXFxcdFxcXFx0ZmFjZSA9IGRpcmVjdGlvbi54ID4gMC4wID8gMCA6IDM7XFxcXG5cXFxcdFxcXFx0ZWxzZVxcXFxuXFxcXHRcXFxcdFxcXFx0ZmFjZSA9IGRpcmVjdGlvbi55ID4gMC4wID8gMSA6IDQ7XFxcXG5cXFxcdH1cXFxcblxcXFx0ZWxzZSB7XFxcXG5cXFxcdFxcXFx0aWYoYWJzRGlyZWN0aW9uLnogPiBhYnNEaXJlY3Rpb24ueSApXFxcXG5cXFxcdFxcXFx0XFxcXHRmYWNlID0gZGlyZWN0aW9uLnogPiAwLjAgPyAyIDogNTtcXFxcblxcXFx0XFxcXHRlbHNlXFxcXG5cXFxcdFxcXFx0XFxcXHRmYWNlID0gZGlyZWN0aW9uLnkgPiAwLjAgPyAxIDogNDtcXFxcblxcXFx0fVxcXFxuXFxcXHRyZXR1cm4gZmFjZTtcXFxcbn1cXFxcbiNkZWZpbmUgY3ViZVVWX21heExvZHMxICAobG9nMihjdWJlVVZfdGV4dHVyZVNpemUqMC4yNSkgLSAxLjApXFxcXG4jZGVmaW5lIGN1YmVVVl9yYW5nZUNsYW1wIChleHAyKCg2LjAgLSAxLjApICogMi4wKSlcXFxcbnZlYzIgTWlwTGV2ZWxJbmZvKCB2ZWMzIHZlYywgZmxvYXQgcm91Z2huZXNzTGV2ZWwsIGZsb2F0IHJvdWdobmVzcyApIHtcXFxcblxcXFx0ZmxvYXQgc2NhbGUgPSBleHAyKGN1YmVVVl9tYXhMb2RzMSAtIHJvdWdobmVzc0xldmVsKTtcXFxcblxcXFx0ZmxvYXQgZHhSb3VnaG5lc3MgPSBkRmR4KHJvdWdobmVzcyk7XFxcXG5cXFxcdGZsb2F0IGR5Um91Z2huZXNzID0gZEZkeShyb3VnaG5lc3MpO1xcXFxuXFxcXHR2ZWMzIGR4ID0gZEZkeCggdmVjICogc2NhbGUgKiBkeFJvdWdobmVzcyApO1xcXFxuXFxcXHR2ZWMzIGR5ID0gZEZkeSggdmVjICogc2NhbGUgKiBkeVJvdWdobmVzcyApO1xcXFxuXFxcXHRmbG9hdCBkID0gbWF4KCBkb3QoIGR4LCBkeCApLCBkb3QoIGR5LCBkeSApICk7XFxcXG5cXFxcdGQgPSBjbGFtcChkLCAxLjAsIGN1YmVVVl9yYW5nZUNsYW1wKTtcXFxcblxcXFx0ZmxvYXQgbWlwTGV2ZWwgPSAwLjUgKiBsb2cyKGQpO1xcXFxuXFxcXHRyZXR1cm4gdmVjMihmbG9vcihtaXBMZXZlbCksIGZyYWN0KG1pcExldmVsKSk7XFxcXG59XFxcXG4jZGVmaW5lIGN1YmVVVl9tYXhMb2RzMiAobG9nMihjdWJlVVZfdGV4dHVyZVNpemUqMC4yNSkgLSAyLjApXFxcXG4jZGVmaW5lIGN1YmVVVl9yY3BUZXh0dXJlU2l6ZSAoMS4wIC8gY3ViZVVWX3RleHR1cmVTaXplKVxcXFxudmVjMiBnZXRDdWJlVVYodmVjMyBkaXJlY3Rpb24sIGZsb2F0IHJvdWdobmVzc0xldmVsLCBmbG9hdCBtaXBMZXZlbCkge1xcXFxuXFxcXHRtaXBMZXZlbCA9IHJvdWdobmVzc0xldmVsID4gY3ViZVVWX21heExvZHMyIC0gMy4wID8gMC4wIDogbWlwTGV2ZWw7XFxcXG5cXFxcdGZsb2F0IGEgPSAxNi4wICogY3ViZVVWX3JjcFRleHR1cmVTaXplO1xcXFxuXFxcXHR2ZWMyIGV4cDJfcGFja2VkID0gZXhwMiggdmVjMiggcm91Z2huZXNzTGV2ZWwsIG1pcExldmVsICkgKTtcXFxcblxcXFx0dmVjMiByY3BfZXhwMl9wYWNrZWQgPSB2ZWMyKCAxLjAgKSAvIGV4cDJfcGFja2VkO1xcXFxuXFxcXHRmbG9hdCBwb3dTY2FsZSA9IGV4cDJfcGFja2VkLnggKiBleHAyX3BhY2tlZC55O1xcXFxuXFxcXHRmbG9hdCBzY2FsZSA9IHJjcF9leHAyX3BhY2tlZC54ICogcmNwX2V4cDJfcGFja2VkLnkgKiAwLjI1O1xcXFxuXFxcXHRmbG9hdCBtaXBPZmZzZXQgPSAwLjc1KigxLjAgLSByY3BfZXhwMl9wYWNrZWQueSkgKiByY3BfZXhwMl9wYWNrZWQueDtcXFxcblxcXFx0Ym9vbCBiUmVzID0gbWlwTGV2ZWwgPT0gMC4wO1xcXFxuXFxcXHRzY2FsZSA9ICBiUmVzICYmIChzY2FsZSA8IGEpID8gYSA6IHNjYWxlO1xcXFxuXFxcXHR2ZWMzIHI7XFxcXG5cXFxcdHZlYzIgb2Zmc2V0O1xcXFxuXFxcXHRpbnQgZmFjZSA9IGdldEZhY2VGcm9tRGlyZWN0aW9uKGRpcmVjdGlvbik7XFxcXG5cXFxcdGZsb2F0IHJjcFBvd1NjYWxlID0gMS4wIC8gcG93U2NhbGU7XFxcXG5cXFxcdGlmKCBmYWNlID09IDApIHtcXFxcblxcXFx0XFxcXHRyID0gdmVjMyhkaXJlY3Rpb24ueCwgLWRpcmVjdGlvbi56LCBkaXJlY3Rpb24ueSk7XFxcXG5cXFxcdFxcXFx0b2Zmc2V0ID0gdmVjMigwLjArbWlwT2Zmc2V0LDAuNzUgKiByY3BQb3dTY2FsZSk7XFxcXG5cXFxcdFxcXFx0b2Zmc2V0LnkgPSBiUmVzICYmIChvZmZzZXQueSA8IDIuMCphKSA/IGEgOiBvZmZzZXQueTtcXFxcblxcXFx0fVxcXFxuXFxcXHRlbHNlIGlmKCBmYWNlID09IDEpIHtcXFxcblxcXFx0XFxcXHRyID0gdmVjMyhkaXJlY3Rpb24ueSwgZGlyZWN0aW9uLngsIGRpcmVjdGlvbi56KTtcXFxcblxcXFx0XFxcXHRvZmZzZXQgPSB2ZWMyKHNjYWxlK21pcE9mZnNldCwgMC43NSAqIHJjcFBvd1NjYWxlKTtcXFxcblxcXFx0XFxcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gYSA6IG9mZnNldC55O1xcXFxuXFxcXHR9XFxcXG5cXFxcdGVsc2UgaWYoIGZhY2UgPT0gMikge1xcXFxuXFxcXHRcXFxcdHIgPSB2ZWMzKGRpcmVjdGlvbi56LCBkaXJlY3Rpb24ueCwgZGlyZWN0aW9uLnkpO1xcXFxuXFxcXHRcXFxcdG9mZnNldCA9IHZlYzIoMi4wKnNjYWxlK21pcE9mZnNldCwgMC43NSAqIHJjcFBvd1NjYWxlKTtcXFxcblxcXFx0XFxcXHRvZmZzZXQueSA9IGJSZXMgJiYgKG9mZnNldC55IDwgMi4wKmEpID8gYSA6IG9mZnNldC55O1xcXFxuXFxcXHR9XFxcXG5cXFxcdGVsc2UgaWYoIGZhY2UgPT0gMykge1xcXFxuXFxcXHRcXFxcdHIgPSB2ZWMzKGRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnkpO1xcXFxuXFxcXHRcXFxcdG9mZnNldCA9IHZlYzIoMC4wK21pcE9mZnNldCwwLjUgKiByY3BQb3dTY2FsZSk7XFxcXG5cXFxcdFxcXFx0b2Zmc2V0LnkgPSBiUmVzICYmIChvZmZzZXQueSA8IDIuMCphKSA/IDAuMCA6IG9mZnNldC55O1xcXFxuXFxcXHR9XFxcXG5cXFxcdGVsc2UgaWYoIGZhY2UgPT0gNCkge1xcXFxuXFxcXHRcXFxcdHIgPSB2ZWMzKGRpcmVjdGlvbi55LCBkaXJlY3Rpb24ueCwgLWRpcmVjdGlvbi56KTtcXFxcblxcXFx0XFxcXHRvZmZzZXQgPSB2ZWMyKHNjYWxlK21pcE9mZnNldCwgMC41ICogcmNwUG93U2NhbGUpO1xcXFxuXFxcXHRcXFxcdG9mZnNldC55ID0gYlJlcyAmJiAob2Zmc2V0LnkgPCAyLjAqYSkgPyAwLjAgOiBvZmZzZXQueTtcXFxcblxcXFx0fVxcXFxuXFxcXHRlbHNlIHtcXFxcblxcXFx0XFxcXHRyID0gdmVjMyhkaXJlY3Rpb24ueiwgLWRpcmVjdGlvbi54LCBkaXJlY3Rpb24ueSk7XFxcXG5cXFxcdFxcXFx0b2Zmc2V0ID0gdmVjMigyLjAqc2NhbGUrbWlwT2Zmc2V0LCAwLjUgKiByY3BQb3dTY2FsZSk7XFxcXG5cXFxcdFxcXFx0b2Zmc2V0LnkgPSBiUmVzICYmIChvZmZzZXQueSA8IDIuMCphKSA/IDAuMCA6IG9mZnNldC55O1xcXFxuXFxcXHR9XFxcXG5cXFxcdHIgPSBub3JtYWxpemUocik7XFxcXG5cXFxcdGZsb2F0IHRleGVsT2Zmc2V0ID0gMC41ICogY3ViZVVWX3JjcFRleHR1cmVTaXplO1xcXFxuXFxcXHR2ZWMyIHMgPSAoIHIueXogLyBhYnMoIHIueCApICsgdmVjMiggMS4wICkgKSAqIDAuNTtcXFxcblxcXFx0dmVjMiBiYXNlID0gb2Zmc2V0ICsgdmVjMiggdGV4ZWxPZmZzZXQgKTtcXFxcblxcXFx0cmV0dXJuIGJhc2UgKyBzICogKCBzY2FsZSAtIDIuMCAqIHRleGVsT2Zmc2V0ICk7XFxcXG59XFxcXG4jZGVmaW5lIGN1YmVVVl9tYXhMb2RzMyAobG9nMihjdWJlVVZfdGV4dHVyZVNpemUqMC4yNSkgLSAzLjApXFxcXG52ZWM0IHRleHR1cmVDdWJlVVYodmVjMyByZWZsZWN0ZWREaXJlY3Rpb24sIGZsb2F0IHJvdWdobmVzcyApIHtcXFxcblxcXFx0ZmxvYXQgcm91Z2huZXNzVmFsID0gcm91Z2huZXNzKiBjdWJlVVZfbWF4TG9kczM7XFxcXG5cXFxcdGZsb2F0IHIxID0gZmxvb3Iocm91Z2huZXNzVmFsKTtcXFxcblxcXFx0ZmxvYXQgcjIgPSByMSArIDEuMDtcXFxcblxcXFx0ZmxvYXQgdCA9IGZyYWN0KHJvdWdobmVzc1ZhbCk7XFxcXG5cXFxcdHZlYzIgbWlwSW5mbyA9IE1pcExldmVsSW5mbyhyZWZsZWN0ZWREaXJlY3Rpb24sIHIxLCByb3VnaG5lc3MpO1xcXFxuXFxcXHRmbG9hdCBzID0gbWlwSW5mby55O1xcXFxuXFxcXHRmbG9hdCBsZXZlbDAgPSBtaXBJbmZvLng7XFxcXG5cXFxcdGZsb2F0IGxldmVsMSA9IGxldmVsMCArIDEuMDtcXFxcblxcXFx0bGV2ZWwxID0gbGV2ZWwxID4gNS4wID8gNS4wIDogbGV2ZWwxO1xcXFxuXFxcXHRsZXZlbDAgKz0gbWluKCBmbG9vciggcyArIDAuNSApLCA1LjAgKTtcXFxcblxcXFx0dmVjMiB1dl8xMCA9IGdldEN1YmVVVihyZWZsZWN0ZWREaXJlY3Rpb24sIHIxLCBsZXZlbDApO1xcXFxuXFxcXHR2ZWM0IGNvbG9yMTAgPSBlbnZNYXBUZXhlbFRvTGluZWFyKHRleHR1cmUyRChlbnZNYXAsIHV2XzEwKSk7XFxcXG5cXFxcdHZlYzIgdXZfMjAgPSBnZXRDdWJlVVYocmVmbGVjdGVkRGlyZWN0aW9uLCByMiwgbGV2ZWwwKTtcXFxcblxcXFx0dmVjNCBjb2xvcjIwID0gZW52TWFwVGV4ZWxUb0xpbmVhcih0ZXh0dXJlMkQoZW52TWFwLCB1dl8yMCkpO1xcXFxuXFxcXHR2ZWM0IHJlc3VsdCA9IG1peChjb2xvcjEwLCBjb2xvcjIwLCB0KTtcXFxcblxcXFx0cmV0dXJuIHZlYzQocmVzdWx0LnJnYiwgMS4wKTtcXFxcbn1cXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgZGVmYXVsdG5vcm1hbF92ZXJ0ZXggPSBcXFwidmVjMyB0cmFuc2Zvcm1lZE5vcm1hbCA9IG5vcm1hbE1hdHJpeCAqIG9iamVjdE5vcm1hbDtcXFxcbiNpZmRlZiBGTElQX1NJREVEXFxcXG5cXFxcdHRyYW5zZm9ybWVkTm9ybWFsID0gLSB0cmFuc2Zvcm1lZE5vcm1hbDtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4ID0gXFxcIiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxcXG5cXFxcdHVuaWZvcm0gc2FtcGxlcjJEIGRpc3BsYWNlbWVudE1hcDtcXFxcblxcXFx0dW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRTY2FsZTtcXFxcblxcXFx0dW5pZm9ybSBmbG9hdCBkaXNwbGFjZW1lbnRCaWFzO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBkaXNwbGFjZW1lbnRtYXBfdmVydGV4ID0gXFxcIiNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxcXG5cXFxcdHRyYW5zZm9ybWVkICs9IG5vcm1hbGl6ZSggb2JqZWN0Tm9ybWFsICkgKiAoIHRleHR1cmUyRCggZGlzcGxhY2VtZW50TWFwLCB1diApLnggKiBkaXNwbGFjZW1lbnRTY2FsZSArIGRpc3BsYWNlbWVudEJpYXMgKTtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgZW1pc3NpdmVtYXBfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9FTUlTU0lWRU1BUFxcXFxuXFxcXHR2ZWM0IGVtaXNzaXZlQ29sb3IgPSB0ZXh0dXJlMkQoIGVtaXNzaXZlTWFwLCB2VXYgKTtcXFxcblxcXFx0ZW1pc3NpdmVDb2xvci5yZ2IgPSBlbWlzc2l2ZU1hcFRleGVsVG9MaW5lYXIoIGVtaXNzaXZlQ29sb3IgKS5yZ2I7XFxcXG5cXFxcdHRvdGFsRW1pc3NpdmVSYWRpYW5jZSAqPSBlbWlzc2l2ZUNvbG9yLnJnYjtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX0VNSVNTSVZFTUFQXFxcXG5cXFxcdHVuaWZvcm0gc2FtcGxlcjJEIGVtaXNzaXZlTWFwO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBlbmNvZGluZ3NfZnJhZ21lbnQgPSBcXFwiICBnbF9GcmFnQ29sb3IgPSBsaW5lYXJUb091dHB1dFRleGVsKCBnbF9GcmFnQ29sb3IgKTtcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGVuY29kaW5nc19wYXJzX2ZyYWdtZW50ID0gXFxcIlxcXFxudmVjNCBMaW5lYXJUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSApIHtcXFxcblxcXFx0cmV0dXJuIHZhbHVlO1xcXFxufVxcXFxudmVjNCBHYW1tYVRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBnYW1tYUZhY3RvciApIHtcXFxcblxcXFx0cmV0dXJuIHZlYzQoIHBvdyggdmFsdWUueHl6LCB2ZWMzKCBnYW1tYUZhY3RvciApICksIHZhbHVlLncgKTtcXFxcbn1cXFxcbnZlYzQgTGluZWFyVG9HYW1tYSggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgZ2FtbWFGYWN0b3IgKSB7XFxcXG5cXFxcdHJldHVybiB2ZWM0KCBwb3coIHZhbHVlLnh5eiwgdmVjMyggMS4wIC8gZ2FtbWFGYWN0b3IgKSApLCB2YWx1ZS53ICk7XFxcXG59XFxcXG52ZWM0IHNSR0JUb0xpbmVhciggaW4gdmVjNCB2YWx1ZSApIHtcXFxcblxcXFx0cmV0dXJuIHZlYzQoIG1peCggcG93KCB2YWx1ZS5yZ2IgKiAwLjk0Nzg2NzI5ODYgKyB2ZWMzKCAwLjA1MjEzMjcwMTQgKSwgdmVjMyggMi40ICkgKSwgdmFsdWUucmdiICogMC4wNzczOTkzODA4LCB2ZWMzKCBsZXNzVGhhbkVxdWFsKCB2YWx1ZS5yZ2IsIHZlYzMoIDAuMDQwNDUgKSApICkgKSwgdmFsdWUudyApO1xcXFxufVxcXFxudmVjNCBMaW5lYXJUb3NSR0IoIGluIHZlYzQgdmFsdWUgKSB7XFxcXG5cXFxcdHJldHVybiB2ZWM0KCBtaXgoIHBvdyggdmFsdWUucmdiLCB2ZWMzKCAwLjQxNjY2ICkgKSAqIDEuMDU1IC0gdmVjMyggMC4wNTUgKSwgdmFsdWUucmdiICogMTIuOTIsIHZlYzMoIGxlc3NUaGFuRXF1YWwoIHZhbHVlLnJnYiwgdmVjMyggMC4wMDMxMzA4ICkgKSApICksIHZhbHVlLncgKTtcXFxcbn1cXFxcbnZlYzQgUkdCRVRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlICkge1xcXFxuXFxcXHRyZXR1cm4gdmVjNCggdmFsdWUucmdiICogZXhwMiggdmFsdWUuYSAqIDI1NS4wIC0gMTI4LjAgKSwgMS4wICk7XFxcXG59XFxcXG52ZWM0IExpbmVhclRvUkdCRSggaW4gdmVjNCB2YWx1ZSApIHtcXFxcblxcXFx0ZmxvYXQgbWF4Q29tcG9uZW50ID0gbWF4KCBtYXgoIHZhbHVlLnIsIHZhbHVlLmcgKSwgdmFsdWUuYiApO1xcXFxuXFxcXHRmbG9hdCBmRXhwID0gY2xhbXAoIGNlaWwoIGxvZzIoIG1heENvbXBvbmVudCApICksIC0xMjguMCwgMTI3LjAgKTtcXFxcblxcXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAvIGV4cDIoIGZFeHAgKSwgKCBmRXhwICsgMTI4LjAgKSAvIDI1NS4wICk7XFxcXG59XFxcXG52ZWM0IFJHQk1Ub0xpbmVhciggaW4gdmVjNCB2YWx1ZSwgaW4gZmxvYXQgbWF4UmFuZ2UgKSB7XFxcXG5cXFxcdHJldHVybiB2ZWM0KCB2YWx1ZS54eXogKiB2YWx1ZS53ICogbWF4UmFuZ2UsIDEuMCApO1xcXFxufVxcXFxudmVjNCBMaW5lYXJUb1JHQk0oIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IG1heFJhbmdlICkge1xcXFxuXFxcXHRmbG9hdCBtYXhSR0IgPSBtYXgoIHZhbHVlLngsIG1heCggdmFsdWUuZywgdmFsdWUuYiApICk7XFxcXG5cXFxcdGZsb2F0IE0gICAgICA9IGNsYW1wKCBtYXhSR0IgLyBtYXhSYW5nZSwgMC4wLCAxLjAgKTtcXFxcblxcXFx0TSAgICAgICAgICAgID0gY2VpbCggTSAqIDI1NS4wICkgLyAyNTUuMDtcXFxcblxcXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAvICggTSAqIG1heFJhbmdlICksIE0gKTtcXFxcbn1cXFxcbnZlYzQgUkdCRFRvTGluZWFyKCBpbiB2ZWM0IHZhbHVlLCBpbiBmbG9hdCBtYXhSYW5nZSApIHtcXFxcblxcXFx0cmV0dXJuIHZlYzQoIHZhbHVlLnJnYiAqICggKCBtYXhSYW5nZSAvIDI1NS4wICkgLyB2YWx1ZS5hICksIDEuMCApO1xcXFxufVxcXFxudmVjNCBMaW5lYXJUb1JHQkQoIGluIHZlYzQgdmFsdWUsIGluIGZsb2F0IG1heFJhbmdlICkge1xcXFxuXFxcXHRmbG9hdCBtYXhSR0IgPSBtYXgoIHZhbHVlLngsIG1heCggdmFsdWUuZywgdmFsdWUuYiApICk7XFxcXG5cXFxcdGZsb2F0IEQgICAgICA9IG1heCggbWF4UmFuZ2UgLyBtYXhSR0IsIDEuMCApO1xcXFxuXFxcXHREICAgICAgICAgICAgPSBtaW4oIGZsb29yKCBEICkgLyAyNTUuMCwgMS4wICk7XFxcXG5cXFxcdHJldHVybiB2ZWM0KCB2YWx1ZS5yZ2IgKiAoIEQgKiAoIDI1NS4wIC8gbWF4UmFuZ2UgKSApLCBEICk7XFxcXG59XFxcXG5jb25zdCBtYXQzIGNMb2dMdXZNID0gbWF0MyggMC4yMjA5LCAwLjMzOTAsIDAuNDE4NCwgMC4xMTM4LCAwLjY3ODAsIDAuNzMxOSwgMC4wMTAyLCAwLjExMzAsIDAuMjk2OSApO1xcXFxudmVjNCBMaW5lYXJUb0xvZ0x1diggaW4gdmVjNCB2YWx1ZSApICB7XFxcXG5cXFxcdHZlYzMgWHBfWV9YWVpwID0gdmFsdWUucmdiICogY0xvZ0x1dk07XFxcXG5cXFxcdFhwX1lfWFlacCA9IG1heChYcF9ZX1hZWnAsIHZlYzMoMWUtNiwgMWUtNiwgMWUtNikpO1xcXFxuXFxcXHR2ZWM0IHZSZXN1bHQ7XFxcXG5cXFxcdHZSZXN1bHQueHkgPSBYcF9ZX1hZWnAueHkgLyBYcF9ZX1hZWnAuejtcXFxcblxcXFx0ZmxvYXQgTGUgPSAyLjAgKiBsb2cyKFhwX1lfWFlacC55KSArIDEyNy4wO1xcXFxuXFxcXHR2UmVzdWx0LncgPSBmcmFjdChMZSk7XFxcXG5cXFxcdHZSZXN1bHQueiA9IChMZSAtIChmbG9vcih2UmVzdWx0LncqMjU1LjApKS8yNTUuMCkvMjU1LjA7XFxcXG5cXFxcdHJldHVybiB2UmVzdWx0O1xcXFxufVxcXFxuY29uc3QgbWF0MyBjTG9nTHV2SW52ZXJzZU0gPSBtYXQzKCA2LjAwMTQsIC0yLjcwMDgsIC0xLjc5OTYsIC0xLjMzMjAsIDMuMTAyOSwgLTUuNzcyMSwgMC4zMDA4LCAtMS4wODgyLCA1LjYyNjggKTtcXFxcbnZlYzQgTG9nTHV2VG9MaW5lYXIoIGluIHZlYzQgdmFsdWUgKSB7XFxcXG5cXFxcdGZsb2F0IExlID0gdmFsdWUueiAqIDI1NS4wICsgdmFsdWUudztcXFxcblxcXFx0dmVjMyBYcF9ZX1hZWnA7XFxcXG5cXFxcdFhwX1lfWFlacC55ID0gZXhwMigoTGUgLSAxMjcuMCkgLyAyLjApO1xcXFxuXFxcXHRYcF9ZX1hZWnAueiA9IFhwX1lfWFlacC55IC8gdmFsdWUueTtcXFxcblxcXFx0WHBfWV9YWVpwLnggPSB2YWx1ZS54ICogWHBfWV9YWVpwLno7XFxcXG5cXFxcdHZlYzMgdlJHQiA9IFhwX1lfWFlacC5yZ2IgKiBjTG9nTHV2SW52ZXJzZU07XFxcXG5cXFxcdHJldHVybiB2ZWM0KCBtYXgodlJHQiwgMC4wKSwgMS4wICk7XFxcXG59XFxcXG5cXFwiO1xcblxcblxcdHZhciBlbnZtYXBfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9FTlZNQVBcXFxcblxcXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HIClcXFxcblxcXFx0XFxcXHR2ZWMzIGNhbWVyYVRvVmVydGV4ID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiAtIGNhbWVyYVBvc2l0aW9uICk7XFxcXG5cXFxcdFxcXFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIG5vcm1hbCwgdmlld01hdHJpeCApO1xcXFxuXFxcXHRcXFxcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZsZWN0KCBjYW1lcmFUb1ZlcnRleCwgd29ybGROb3JtYWwgKTtcXFxcblxcXFx0XFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdFxcXFx0dmVjMyByZWZsZWN0VmVjID0gcmVmcmFjdCggY2FtZXJhVG9WZXJ0ZXgsIHdvcmxkTm9ybWFsLCByZWZyYWN0aW9uUmF0aW8gKTtcXFxcblxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHR2ZWMzIHJlZmxlY3RWZWMgPSB2UmVmbGVjdDtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxcXG5cXFxcdFxcXFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmVDdWJlKCBlbnZNYXAsIHZlYzMoIGZsaXBFbnZNYXAgKiByZWZsZWN0VmVjLngsIHJlZmxlY3RWZWMueXogKSApO1xcXFxuXFxcXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9FUVVJUkVDIClcXFxcblxcXFx0XFxcXHR2ZWMyIHNhbXBsZVVWO1xcXFxuXFxcXHRcXFxcdHJlZmxlY3RWZWMgPSBub3JtYWxpemUoIHJlZmxlY3RWZWMgKTtcXFxcblxcXFx0XFxcXHRzYW1wbGVVVi55ID0gYXNpbiggY2xhbXAoIHJlZmxlY3RWZWMueSwgLSAxLjAsIDEuMCApICkgKiBSRUNJUFJPQ0FMX1BJICsgMC41O1xcXFxuXFxcXHRcXFxcdHNhbXBsZVVWLnggPSBhdGFuKCByZWZsZWN0VmVjLnosIHJlZmxlY3RWZWMueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxcXG5cXFxcdFxcXFx0dmVjNCBlbnZDb2xvciA9IHRleHR1cmUyRCggZW52TWFwLCBzYW1wbGVVViApO1xcXFxuXFxcXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfVFlQRV9TUEhFUkUgKVxcXFxuXFxcXHRcXFxcdHJlZmxlY3RWZWMgPSBub3JtYWxpemUoIHJlZmxlY3RWZWMgKTtcXFxcblxcXFx0XFxcXHR2ZWMzIHJlZmxlY3RWaWV3ID0gbm9ybWFsaXplKCAoIHZpZXdNYXRyaXggKiB2ZWM0KCByZWZsZWN0VmVjLCAwLjAgKSApLnh5eiArIHZlYzMoIDAuMCwgMC4wLCAxLjAgKSApO1xcXFxuXFxcXHRcXFxcdHZlYzQgZW52Q29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgcmVmbGVjdFZpZXcueHkgKiAwLjUgKyAwLjUgKTtcXFxcblxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHR2ZWM0IGVudkNvbG9yID0gdmVjNCggMC4wICk7XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHRlbnZDb2xvciA9IGVudk1hcFRleGVsVG9MaW5lYXIoIGVudkNvbG9yICk7XFxcXG5cXFxcdCNpZmRlZiBFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFlcXFxcblxcXFx0XFxcXHRvdXRnb2luZ0xpZ2h0ID0gbWl4KCBvdXRnb2luZ0xpZ2h0LCBvdXRnb2luZ0xpZ2h0ICogZW52Q29sb3IueHl6LCBzcGVjdWxhclN0cmVuZ3RoICogcmVmbGVjdGl2aXR5ICk7XFxcXG5cXFxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9CTEVORElOR19NSVggKVxcXFxuXFxcXHRcXFxcdG91dGdvaW5nTGlnaHQgPSBtaXgoIG91dGdvaW5nTGlnaHQsIGVudkNvbG9yLnh5eiwgc3BlY3VsYXJTdHJlbmd0aCAqIHJlZmxlY3Rpdml0eSApO1xcXFxuXFxcXHQjZWxpZiBkZWZpbmVkKCBFTlZNQVBfQkxFTkRJTkdfQUREIClcXFxcblxcXFx0XFxcXHRvdXRnb2luZ0xpZ2h0ICs9IGVudkNvbG9yLnh5eiAqIHNwZWN1bGFyU3RyZW5ndGggKiByZWZsZWN0aXZpdHk7XFxcXG5cXFxcdCNlbmRpZlxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBlbnZtYXBfcGFyc19mcmFnbWVudCA9IFxcXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQoIFBIWVNJQ0FMIClcXFxcblxcXFx0dW5pZm9ybSBmbG9hdCByZWZsZWN0aXZpdHk7XFxcXG5cXFxcdHVuaWZvcm0gZmxvYXQgZW52TWFwSW50ZW5zaXR5O1xcXFxuI2VuZGlmXFxcXG4jaWZkZWYgVVNFX0VOVk1BUFxcXFxuXFxcXHQjaWYgISBkZWZpbmVkKCBQSFlTSUNBTCApICYmICggZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKSApXFxcXG5cXFxcdFxcXFx0dmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXFxcblxcXFx0XFxcXHR1bmlmb3JtIHNhbXBsZXJDdWJlIGVudk1hcDtcXFxcblxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHR1bmlmb3JtIHNhbXBsZXIyRCBlbnZNYXA7XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHR1bmlmb3JtIGZsb2F0IGZsaXBFbnZNYXA7XFxcXG5cXFxcdCNpZiBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBQSE9ORyApIHx8IGRlZmluZWQoIFBIWVNJQ0FMIClcXFxcblxcXFx0XFxcXHR1bmlmb3JtIGZsb2F0IHJlZnJhY3Rpb25SYXRpbztcXFxcblxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHR2YXJ5aW5nIHZlYzMgdlJlZmxlY3Q7XFxcXG5cXFxcdCNlbmRpZlxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBlbnZtYXBfcGFyc192ZXJ0ZXggPSBcXFwiI2lmZGVmIFVTRV9FTlZNQVBcXFxcblxcXFx0I2lmIGRlZmluZWQoIFVTRV9CVU1QTUFQICkgfHwgZGVmaW5lZCggVVNFX05PUk1BTE1BUCApIHx8IGRlZmluZWQoIFBIT05HIClcXFxcblxcXFx0XFxcXHR2YXJ5aW5nIHZlYzMgdldvcmxkUG9zaXRpb247XFxcXG5cXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0dmFyeWluZyB2ZWMzIHZSZWZsZWN0O1xcXFxuXFxcXHRcXFxcdHVuaWZvcm0gZmxvYXQgcmVmcmFjdGlvblJhdGlvO1xcXFxuXFxcXHQjZW5kaWZcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgZW52bWFwX3ZlcnRleCA9IFxcXCIjaWZkZWYgVVNFX0VOVk1BUFxcXFxuXFxcXHQjaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggUEhPTkcgKVxcXFxuXFxcXHRcXFxcdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XFxcXG5cXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0dmVjMyBjYW1lcmFUb1ZlcnRleCA9IG5vcm1hbGl6ZSggd29ybGRQb3NpdGlvbi54eXogLSBjYW1lcmFQb3NpdGlvbiApO1xcXFxuXFxcXHRcXFxcdHZlYzMgd29ybGROb3JtYWwgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCB0cmFuc2Zvcm1lZE5vcm1hbCwgdmlld01hdHJpeCApO1xcXFxuXFxcXHRcXFxcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxcXG5cXFxcdFxcXFx0XFxcXHR2UmVmbGVjdCA9IHJlZmxlY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCApO1xcXFxuXFxcXHRcXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0XFxcXHR2UmVmbGVjdCA9IHJlZnJhY3QoIGNhbWVyYVRvVmVydGV4LCB3b3JsZE5vcm1hbCwgcmVmcmFjdGlvblJhdGlvICk7XFxcXG5cXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdCNlbmRpZlxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBmb2dfdmVydGV4ID0gXFxcIlxcXFxuI2lmZGVmIFVTRV9GT0dcXFxcbmZvZ0RlcHRoID0gLW12UG9zaXRpb24uejtcXFxcbiNlbmRpZlxcXCI7XFxuXFxuXFx0dmFyIGZvZ19wYXJzX3ZlcnRleCA9IFxcXCIjaWZkZWYgVVNFX0ZPR1xcXFxuICB2YXJ5aW5nIGZsb2F0IGZvZ0RlcHRoO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBmb2dfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9GT0dcXFxcblxcXFx0I2lmZGVmIEZPR19FWFAyXFxcXG5cXFxcdFxcXFx0ZmxvYXQgZm9nRmFjdG9yID0gd2hpdGVDb21wbGltZW50KCBleHAyKCAtIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5ICogZm9nRGVwdGggKiBmb2dEZXB0aCAqIExPRzIgKSApO1xcXFxuXFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdGZsb2F0IGZvZ0ZhY3RvciA9IHNtb290aHN0ZXAoIGZvZ05lYXIsIGZvZ0ZhciwgZm9nRGVwdGggKTtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdGdsX0ZyYWdDb2xvci5yZ2IgPSBtaXgoIGdsX0ZyYWdDb2xvci5yZ2IsIGZvZ0NvbG9yLCBmb2dGYWN0b3IgKTtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgZm9nX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9GT0dcXFxcblxcXFx0dW5pZm9ybSB2ZWMzIGZvZ0NvbG9yO1xcXFxuXFxcXHR2YXJ5aW5nIGZsb2F0IGZvZ0RlcHRoO1xcXFxuXFxcXHQjaWZkZWYgRk9HX0VYUDJcXFxcblxcXFx0XFxcXHR1bmlmb3JtIGZsb2F0IGZvZ0RlbnNpdHk7XFxcXG5cXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0dW5pZm9ybSBmbG9hdCBmb2dOZWFyO1xcXFxuXFxcXHRcXFxcdHVuaWZvcm0gZmxvYXQgZm9nRmFyO1xcXFxuXFxcXHQjZW5kaWZcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgZ3JhZGllbnRtYXBfcGFyc19mcmFnbWVudCA9IFxcXCIjaWZkZWYgVE9PTlxcXFxuXFxcXHR1bmlmb3JtIHNhbXBsZXIyRCBncmFkaWVudE1hcDtcXFxcblxcXFx0dmVjMyBnZXRHcmFkaWVudElycmFkaWFuY2UoIHZlYzMgbm9ybWFsLCB2ZWMzIGxpZ2h0RGlyZWN0aW9uICkge1xcXFxuXFxcXHRcXFxcdGZsb2F0IGRvdE5MID0gZG90KCBub3JtYWwsIGxpZ2h0RGlyZWN0aW9uICk7XFxcXG5cXFxcdFxcXFx0dmVjMiBjb29yZCA9IHZlYzIoIGRvdE5MICogMC41ICsgMC41LCAwLjAgKTtcXFxcblxcXFx0XFxcXHQjaWZkZWYgVVNFX0dSQURJRU5UTUFQXFxcXG5cXFxcdFxcXFx0XFxcXHRyZXR1cm4gdGV4dHVyZTJEKCBncmFkaWVudE1hcCwgY29vcmQgKS5yZ2I7XFxcXG5cXFxcdFxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHRcXFxcdHJldHVybiAoIGNvb3JkLnggPCAwLjcgKSA/IHZlYzMoIDAuNyApIDogdmVjMyggMS4wICk7XFxcXG5cXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdH1cXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbGlnaHRtYXBfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcXFxuXFxcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gUEkgKiB0ZXh0dXJlMkQoIGxpZ2h0TWFwLCB2VXYyICkueHl6ICogbGlnaHRNYXBJbnRlbnNpdHk7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9MSUdIVE1BUFxcXFxuXFxcXHR1bmlmb3JtIHNhbXBsZXIyRCBsaWdodE1hcDtcXFxcblxcXFx0dW5pZm9ybSBmbG9hdCBsaWdodE1hcEludGVuc2l0eTtcXFxcbiNlbmRpZlxcXCI7XFxuXFxuXFx0dmFyIGxpZ2h0c19sYW1iZXJ0X3ZlcnRleCA9IFxcXCJ2ZWMzIGRpZmZ1c2UgPSB2ZWMzKCAxLjAgKTtcXFxcbkdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnk7XFxcXG5nZW9tZXRyeS5wb3NpdGlvbiA9IG12UG9zaXRpb24ueHl6O1xcXFxuZ2VvbWV0cnkubm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcXFxuZ2VvbWV0cnkudmlld0RpciA9IG5vcm1hbGl6ZSggLW12UG9zaXRpb24ueHl6ICk7XFxcXG5HZW9tZXRyaWNDb250ZXh0IGJhY2tHZW9tZXRyeTtcXFxcbmJhY2tHZW9tZXRyeS5wb3NpdGlvbiA9IGdlb21ldHJ5LnBvc2l0aW9uO1xcXFxuYmFja0dlb21ldHJ5Lm5vcm1hbCA9IC1nZW9tZXRyeS5ub3JtYWw7XFxcXG5iYWNrR2VvbWV0cnkudmlld0RpciA9IGdlb21ldHJ5LnZpZXdEaXI7XFxcXG52TGlnaHRGcm9udCA9IHZlYzMoIDAuMCApO1xcXFxuI2lmZGVmIERPVUJMRV9TSURFRFxcXFxuXFxcXHR2TGlnaHRCYWNrID0gdmVjMyggMC4wICk7XFxcXG4jZW5kaWZcXFxcbkluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQ7XFxcXG5mbG9hdCBkb3ROTDtcXFxcbnZlYzMgZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcXFxuI2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxcXG5cXFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxcXG5cXFxcdFxcXFx0Z2V0UG9pbnREaXJlY3RMaWdodElycmFkaWFuY2UoIHBvaW50TGlnaHRzWyBpIF0sIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcXFxuXFxcXHRcXFxcdGRvdE5MID0gZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApO1xcXFxuXFxcXHRcXFxcdGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZSA9IFBJICogZGlyZWN0TGlnaHQuY29sb3I7XFxcXG5cXFxcdFxcXFx0dkxpZ2h0RnJvbnQgKz0gc2F0dXJhdGUoIGRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxcXG5cXFxcdFxcXFx0I2lmZGVmIERPVUJMRV9TSURFRFxcXFxuXFxcXHRcXFxcdFxcXFx0dkxpZ2h0QmFjayArPSBzYXR1cmF0ZSggLWRvdE5MICkgKiBkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2U7XFxcXG5cXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdH1cXFxcbiNlbmRpZlxcXFxuI2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXFxcblxcXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcXFxuXFxcXHRcXFxcdGdldFNwb3REaXJlY3RMaWdodElycmFkaWFuY2UoIHNwb3RMaWdodHNbIGkgXSwgZ2VvbWV0cnksIGRpcmVjdExpZ2h0ICk7XFxcXG5cXFxcdFxcXFx0ZG90TkwgPSBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICk7XFxcXG5cXFxcdFxcXFx0ZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlID0gUEkgKiBkaXJlY3RMaWdodC5jb2xvcjtcXFxcblxcXFx0XFxcXHR2TGlnaHRGcm9udCArPSBzYXR1cmF0ZSggZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXFxcblxcXFx0XFxcXHQjaWZkZWYgRE9VQkxFX1NJREVEXFxcXG5cXFxcdFxcXFx0XFxcXHR2TGlnaHRCYWNrICs9IHNhdHVyYXRlKCAtZG90TkwgKSAqIGRpcmVjdExpZ2h0Q29sb3JfRGlmZnVzZTtcXFxcblxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0fVxcXFxuI2VuZGlmXFxcXG4jaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxcXG5cXFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcXFxuXFxcXHRcXFxcdGdldERpcmVjdGlvbmFsRGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBkaXJlY3Rpb25hbExpZ2h0c1sgaSBdLCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXFxcblxcXFx0XFxcXHRkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBkaXJlY3RMaWdodC5kaXJlY3Rpb24gKTtcXFxcblxcXFx0XFxcXHRkaXJlY3RMaWdodENvbG9yX0RpZmZ1c2UgPSBQSSAqIGRpcmVjdExpZ2h0LmNvbG9yO1xcXFxuXFxcXHRcXFxcdHZMaWdodEZyb250ICs9IHNhdHVyYXRlKCBkb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcXFxuXFxcXHRcXFxcdCNpZmRlZiBET1VCTEVfU0lERURcXFxcblxcXFx0XFxcXHRcXFxcdHZMaWdodEJhY2sgKz0gc2F0dXJhdGUoIC1kb3ROTCApICogZGlyZWN0TGlnaHRDb2xvcl9EaWZmdXNlO1xcXFxuXFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHR9XFxcXG4jZW5kaWZcXFxcbiNpZiBOVU1fSEVNSV9MSUdIVFMgPiAwXFxcXG5cXFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9IRU1JX0xJR0hUUzsgaSArKyApIHtcXFxcblxcXFx0XFxcXHR2TGlnaHRGcm9udCArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGdlb21ldHJ5ICk7XFxcXG5cXFxcdFxcXFx0I2lmZGVmIERPVUJMRV9TSURFRFxcXFxuXFxcXHRcXFxcdFxcXFx0dkxpZ2h0QmFjayArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGJhY2tHZW9tZXRyeSApO1xcXFxuXFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHR9XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGxpZ2h0c19wYXJzID0gXFxcInVuaWZvcm0gdmVjMyBhbWJpZW50TGlnaHRDb2xvcjtcXFxcbnZlYzMgZ2V0QW1iaWVudExpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gdmVjMyBhbWJpZW50TGlnaHRDb2xvciApIHtcXFxcblxcXFx0dmVjMyBpcnJhZGlhbmNlID0gYW1iaWVudExpZ2h0Q29sb3I7XFxcXG5cXFxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcXFxuXFxcXHRcXFxcdGlycmFkaWFuY2UgKj0gUEk7XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHRyZXR1cm4gaXJyYWRpYW5jZTtcXFxcbn1cXFxcbiNpZiBOVU1fRElSX0xJR0hUUyA+IDBcXFxcblxcXFx0c3RydWN0IERpcmVjdGlvbmFsTGlnaHQge1xcXFxuXFxcXHRcXFxcdHZlYzMgZGlyZWN0aW9uO1xcXFxuXFxcXHRcXFxcdHZlYzMgY29sb3I7XFxcXG5cXFxcdFxcXFx0aW50IHNoYWRvdztcXFxcblxcXFx0XFxcXHRmbG9hdCBzaGFkb3dCaWFzO1xcXFxuXFxcXHRcXFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXFxcblxcXFx0XFxcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxcXG5cXFxcdH07XFxcXG5cXFxcdHVuaWZvcm0gRGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0c1sgTlVNX0RJUl9MSUdIVFMgXTtcXFxcblxcXFx0dm9pZCBnZXREaXJlY3Rpb25hbERpcmVjdExpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gRGlyZWN0aW9uYWxMaWdodCBkaXJlY3Rpb25hbExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBvdXQgSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCApIHtcXFxcblxcXFx0XFxcXHRkaXJlY3RMaWdodC5jb2xvciA9IGRpcmVjdGlvbmFsTGlnaHQuY29sb3I7XFxcXG5cXFxcdFxcXFx0ZGlyZWN0TGlnaHQuZGlyZWN0aW9uID0gZGlyZWN0aW9uYWxMaWdodC5kaXJlY3Rpb247XFxcXG5cXFxcdFxcXFx0ZGlyZWN0TGlnaHQudmlzaWJsZSA9IHRydWU7XFxcXG5cXFxcdH1cXFxcbiNlbmRpZlxcXFxuI2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxcXG5cXFxcdHN0cnVjdCBQb2ludExpZ2h0IHtcXFxcblxcXFx0XFxcXHR2ZWMzIHBvc2l0aW9uO1xcXFxuXFxcXHRcXFxcdHZlYzMgY29sb3I7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgZGlzdGFuY2U7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgZGVjYXk7XFxcXG5cXFxcdFxcXFx0aW50IHNoYWRvdztcXFxcblxcXFx0XFxcXHRmbG9hdCBzaGFkb3dCaWFzO1xcXFxuXFxcXHRcXFxcdGZsb2F0IHNoYWRvd1JhZGl1cztcXFxcblxcXFx0XFxcXHR2ZWMyIHNoYWRvd01hcFNpemU7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgc2hhZG93Q2FtZXJhTmVhcjtcXFxcblxcXFx0XFxcXHRmbG9hdCBzaGFkb3dDYW1lcmFGYXI7XFxcXG5cXFxcdH07XFxcXG5cXFxcdHVuaWZvcm0gUG9pbnRMaWdodCBwb2ludExpZ2h0c1sgTlVNX1BPSU5UX0xJR0hUUyBdO1xcXFxuXFxcXHR2b2lkIGdldFBvaW50RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBQb2ludExpZ2h0IHBvaW50TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIG91dCBJbmNpZGVudExpZ2h0IGRpcmVjdExpZ2h0ICkge1xcXFxuXFxcXHRcXFxcdHZlYzMgbFZlY3RvciA9IHBvaW50TGlnaHQucG9zaXRpb24gLSBnZW9tZXRyeS5wb3NpdGlvbjtcXFxcblxcXFx0XFxcXHRkaXJlY3RMaWdodC5kaXJlY3Rpb24gPSBub3JtYWxpemUoIGxWZWN0b3IgKTtcXFxcblxcXFx0XFxcXHRmbG9hdCBsaWdodERpc3RhbmNlID0gbGVuZ3RoKCBsVmVjdG9yICk7XFxcXG5cXFxcdFxcXFx0ZGlyZWN0TGlnaHQuY29sb3IgPSBwb2ludExpZ2h0LmNvbG9yO1xcXFxuXFxcXHRcXFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IHB1bmN0dWFsTGlnaHRJbnRlbnNpdHlUb0lycmFkaWFuY2VGYWN0b3IoIGxpZ2h0RGlzdGFuY2UsIHBvaW50TGlnaHQuZGlzdGFuY2UsIHBvaW50TGlnaHQuZGVjYXkgKTtcXFxcblxcXFx0XFxcXHRkaXJlY3RMaWdodC52aXNpYmxlID0gKCBkaXJlY3RMaWdodC5jb2xvciAhPSB2ZWMzKCAwLjAgKSApO1xcXFxuXFxcXHR9XFxcXG4jZW5kaWZcXFxcbiNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwXFxcXG5cXFxcdHN0cnVjdCBTcG90TGlnaHQge1xcXFxuXFxcXHRcXFxcdHZlYzMgcG9zaXRpb247XFxcXG5cXFxcdFxcXFx0dmVjMyBkaXJlY3Rpb247XFxcXG5cXFxcdFxcXFx0dmVjMyBjb2xvcjtcXFxcblxcXFx0XFxcXHRmbG9hdCBkaXN0YW5jZTtcXFxcblxcXFx0XFxcXHRmbG9hdCBkZWNheTtcXFxcblxcXFx0XFxcXHRmbG9hdCBjb25lQ29zO1xcXFxuXFxcXHRcXFxcdGZsb2F0IHBlbnVtYnJhQ29zO1xcXFxuXFxcXHRcXFxcdGludCBzaGFkb3c7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgc2hhZG93QmlhcztcXFxcblxcXFx0XFxcXHRmbG9hdCBzaGFkb3dSYWRpdXM7XFxcXG5cXFxcdFxcXFx0dmVjMiBzaGFkb3dNYXBTaXplO1xcXFxuXFxcXHR9O1xcXFxuXFxcXHR1bmlmb3JtIFNwb3RMaWdodCBzcG90TGlnaHRzWyBOVU1fU1BPVF9MSUdIVFMgXTtcXFxcblxcXFx0dm9pZCBnZXRTcG90RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBjb25zdCBpbiBTcG90TGlnaHQgc3BvdExpZ2h0LCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBvdXQgSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodCAgKSB7XFxcXG5cXFxcdFxcXFx0dmVjMyBsVmVjdG9yID0gc3BvdExpZ2h0LnBvc2l0aW9uIC0gZ2VvbWV0cnkucG9zaXRpb247XFxcXG5cXFxcdFxcXFx0ZGlyZWN0TGlnaHQuZGlyZWN0aW9uID0gbm9ybWFsaXplKCBsVmVjdG9yICk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgbGlnaHREaXN0YW5jZSA9IGxlbmd0aCggbFZlY3RvciApO1xcXFxuXFxcXHRcXFxcdGZsb2F0IGFuZ2xlQ29zID0gZG90KCBkaXJlY3RMaWdodC5kaXJlY3Rpb24sIHNwb3RMaWdodC5kaXJlY3Rpb24gKTtcXFxcblxcXFx0XFxcXHRpZiAoIGFuZ2xlQ29zID4gc3BvdExpZ2h0LmNvbmVDb3MgKSB7XFxcXG5cXFxcdFxcXFx0XFxcXHRmbG9hdCBzcG90RWZmZWN0ID0gc21vb3Roc3RlcCggc3BvdExpZ2h0LmNvbmVDb3MsIHNwb3RMaWdodC5wZW51bWJyYUNvcywgYW5nbGVDb3MgKTtcXFxcblxcXFx0XFxcXHRcXFxcdGRpcmVjdExpZ2h0LmNvbG9yID0gc3BvdExpZ2h0LmNvbG9yO1xcXFxuXFxcXHRcXFxcdFxcXFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gc3BvdEVmZmVjdCAqIHB1bmN0dWFsTGlnaHRJbnRlbnNpdHlUb0lycmFkaWFuY2VGYWN0b3IoIGxpZ2h0RGlzdGFuY2UsIHNwb3RMaWdodC5kaXN0YW5jZSwgc3BvdExpZ2h0LmRlY2F5ICk7XFxcXG5cXFxcdFxcXFx0XFxcXHRkaXJlY3RMaWdodC52aXNpYmxlID0gdHJ1ZTtcXFxcblxcXFx0XFxcXHR9IGVsc2Uge1xcXFxuXFxcXHRcXFxcdFxcXFx0ZGlyZWN0TGlnaHQuY29sb3IgPSB2ZWMzKCAwLjAgKTtcXFxcblxcXFx0XFxcXHRcXFxcdGRpcmVjdExpZ2h0LnZpc2libGUgPSBmYWxzZTtcXFxcblxcXFx0XFxcXHR9XFxcXG5cXFxcdH1cXFxcbiNlbmRpZlxcXFxuI2lmIE5VTV9SRUNUX0FSRUFfTElHSFRTID4gMFxcXFxuXFxcXHRzdHJ1Y3QgUmVjdEFyZWFMaWdodCB7XFxcXG5cXFxcdFxcXFx0dmVjMyBjb2xvcjtcXFxcblxcXFx0XFxcXHR2ZWMzIHBvc2l0aW9uO1xcXFxuXFxcXHRcXFxcdHZlYzMgaGFsZldpZHRoO1xcXFxuXFxcXHRcXFxcdHZlYzMgaGFsZkhlaWdodDtcXFxcblxcXFx0fTtcXFxcblxcXFx0dW5pZm9ybSBzYW1wbGVyMkQgbHRjTWF0O1xcXFx0dW5pZm9ybSBzYW1wbGVyMkQgbHRjTWFnO1xcXFxuXFxcXHR1bmlmb3JtIFJlY3RBcmVhTGlnaHQgcmVjdEFyZWFMaWdodHNbIE5VTV9SRUNUX0FSRUFfTElHSFRTIF07XFxcXG4jZW5kaWZcXFxcbiNpZiBOVU1fSEVNSV9MSUdIVFMgPiAwXFxcXG5cXFxcdHN0cnVjdCBIZW1pc3BoZXJlTGlnaHQge1xcXFxuXFxcXHRcXFxcdHZlYzMgZGlyZWN0aW9uO1xcXFxuXFxcXHRcXFxcdHZlYzMgc2t5Q29sb3I7XFxcXG5cXFxcdFxcXFx0dmVjMyBncm91bmRDb2xvcjtcXFxcblxcXFx0fTtcXFxcblxcXFx0dW5pZm9ybSBIZW1pc3BoZXJlTGlnaHQgaGVtaXNwaGVyZUxpZ2h0c1sgTlVNX0hFTUlfTElHSFRTIF07XFxcXG5cXFxcdHZlYzMgZ2V0SGVtaXNwaGVyZUxpZ2h0SXJyYWRpYW5jZSggY29uc3QgaW4gSGVtaXNwaGVyZUxpZ2h0IGhlbWlMaWdodCwgY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSApIHtcXFxcblxcXFx0XFxcXHRmbG9hdCBkb3ROTCA9IGRvdCggZ2VvbWV0cnkubm9ybWFsLCBoZW1pTGlnaHQuZGlyZWN0aW9uICk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgaGVtaURpZmZ1c2VXZWlnaHQgPSAwLjUgKiBkb3ROTCArIDAuNTtcXFxcblxcXFx0XFxcXHR2ZWMzIGlycmFkaWFuY2UgPSBtaXgoIGhlbWlMaWdodC5ncm91bmRDb2xvciwgaGVtaUxpZ2h0LnNreUNvbG9yLCBoZW1pRGlmZnVzZVdlaWdodCApO1xcXFxuXFxcXHRcXFxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcXFxuXFxcXHRcXFxcdFxcXFx0aXJyYWRpYW5jZSAqPSBQSTtcXFxcblxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0XFxcXHRyZXR1cm4gaXJyYWRpYW5jZTtcXFxcblxcXFx0fVxcXFxuI2VuZGlmXFxcXG4jaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFBIWVNJQ0FMIClcXFxcblxcXFx0dmVjMyBnZXRMaWdodFByb2JlSW5kaXJlY3RJcnJhZGlhbmNlKCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBpbnQgbWF4TUlQTGV2ZWwgKSB7XFxcXG5cXFxcdFxcXFx0dmVjMyB3b3JsZE5vcm1hbCA9IGludmVyc2VUcmFuc2Zvcm1EaXJlY3Rpb24oIGdlb21ldHJ5Lm5vcm1hbCwgdmlld01hdHJpeCApO1xcXFxuXFxcXHRcXFxcdCNpZmRlZiBFTlZNQVBfVFlQRV9DVUJFXFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWMzIHF1ZXJ5VmVjID0gdmVjMyggZmxpcEVudk1hcCAqIHdvcmxkTm9ybWFsLngsIHdvcmxkTm9ybWFsLnl6ICk7XFxcXG5cXFxcdFxcXFx0XFxcXHQjaWZkZWYgVEVYVFVSRV9MT0RfRVhUXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZUxvZEVYVCggZW52TWFwLCBxdWVyeVZlYywgZmxvYXQoIG1heE1JUExldmVsICkgKTtcXFxcblxcXFx0XFxcXHRcXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlQ3ViZSggZW52TWFwLCBxdWVyeVZlYywgZmxvYXQoIG1heE1JUExldmVsICkgKTtcXFxcblxcXFx0XFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHRcXFxcdFxcXFx0ZW52TWFwQ29sb3IucmdiID0gZW52TWFwVGV4ZWxUb0xpbmVhciggZW52TWFwQ29sb3IgKS5yZ2I7XFxcXG5cXFxcdFxcXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfQ1VCRV9VViApXFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWMzIHF1ZXJ5VmVjID0gdmVjMyggZmxpcEVudk1hcCAqIHdvcmxkTm9ybWFsLngsIHdvcmxkTm9ybWFsLnl6ICk7XFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVVViggcXVlcnlWZWMsIDEuMCApO1xcXFxuXFxcXHRcXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWM0IGVudk1hcENvbG9yID0gdmVjNCggMC4wICk7XFxcXG5cXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdFxcXFx0cmV0dXJuIFBJICogZW52TWFwQ29sb3IucmdiICogZW52TWFwSW50ZW5zaXR5O1xcXFxuXFxcXHR9XFxcXG5cXFxcdGZsb2F0IGdldFNwZWN1bGFyTUlQTGV2ZWwoIGNvbnN0IGluIGZsb2F0IGJsaW5uU2hpbmluZXNzRXhwb25lbnQsIGNvbnN0IGluIGludCBtYXhNSVBMZXZlbCApIHtcXFxcblxcXFx0XFxcXHRmbG9hdCBtYXhNSVBMZXZlbFNjYWxhciA9IGZsb2F0KCBtYXhNSVBMZXZlbCApO1xcXFxuXFxcXHRcXFxcdGZsb2F0IGRlc2lyZWRNSVBMZXZlbCA9IG1heE1JUExldmVsU2NhbGFyICsgMC43OTI0OCAtIDAuNSAqIGxvZzIoIHBvdzIoIGJsaW5uU2hpbmluZXNzRXhwb25lbnQgKSArIDEuMCApO1xcXFxuXFxcXHRcXFxcdHJldHVybiBjbGFtcCggZGVzaXJlZE1JUExldmVsLCAwLjAsIG1heE1JUExldmVsU2NhbGFyICk7XFxcXG5cXFxcdH1cXFxcblxcXFx0dmVjMyBnZXRMaWdodFByb2JlSW5kaXJlY3RSYWRpYW5jZSggY29uc3QgaW4gR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeSwgY29uc3QgaW4gZmxvYXQgYmxpbm5TaGluaW5lc3NFeHBvbmVudCwgY29uc3QgaW4gaW50IG1heE1JUExldmVsICkge1xcXFxuXFxcXHRcXFxcdCNpZmRlZiBFTlZNQVBfTU9ERV9SRUZMRUNUSU9OXFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWMzIHJlZmxlY3RWZWMgPSByZWZsZWN0KCAtZ2VvbWV0cnkudmlld0RpciwgZ2VvbWV0cnkubm9ybWFsICk7XFxcXG5cXFxcdFxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzMgcmVmbGVjdFZlYyA9IHJlZnJhY3QoIC1nZW9tZXRyeS52aWV3RGlyLCBnZW9tZXRyeS5ub3JtYWwsIHJlZnJhY3Rpb25SYXRpbyApO1xcXFxuXFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHRcXFxcdHJlZmxlY3RWZWMgPSBpbnZlcnNlVHJhbnNmb3JtRGlyZWN0aW9uKCByZWZsZWN0VmVjLCB2aWV3TWF0cml4ICk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgc3BlY3VsYXJNSVBMZXZlbCA9IGdldFNwZWN1bGFyTUlQTGV2ZWwoIGJsaW5uU2hpbmluZXNzRXhwb25lbnQsIG1heE1JUExldmVsICk7XFxcXG5cXFxcdFxcXFx0I2lmZGVmIEVOVk1BUF9UWVBFX0NVQkVcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzMgcXVlcnlSZWZsZWN0VmVjID0gdmVjMyggZmxpcEVudk1hcCAqIHJlZmxlY3RWZWMueCwgcmVmbGVjdFZlYy55eiApO1xcXFxuXFxcXHRcXFxcdFxcXFx0I2lmZGVmIFRFWFRVUkVfTE9EX0VYVFxcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVMb2RFWFQoIGVudk1hcCwgcXVlcnlSZWZsZWN0VmVjLCBzcGVjdWxhck1JUExldmVsICk7XFxcXG5cXFxcdFxcXFx0XFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmUoIGVudk1hcCwgcXVlcnlSZWZsZWN0VmVjLCBzcGVjdWxhck1JUExldmVsICk7XFxcXG5cXFxcdFxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0XFxcXHRcXFxcdGVudk1hcENvbG9yLnJnYiA9IGVudk1hcFRleGVsVG9MaW5lYXIoIGVudk1hcENvbG9yICkucmdiO1xcXFxuXFxcXHRcXFxcdCNlbGlmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKVxcXFxuXFxcXHRcXFxcdFxcXFx0dmVjMyBxdWVyeVJlZmxlY3RWZWMgPSB2ZWMzKCBmbGlwRW52TWFwICogcmVmbGVjdFZlYy54LCByZWZsZWN0VmVjLnl6ICk7XFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZUN1YmVVVihxdWVyeVJlZmxlY3RWZWMsIEJsaW5uRXhwb25lbnRUb0dHWFJvdWdobmVzcyhibGlublNoaW5pbmVzc0V4cG9uZW50KSk7XFxcXG5cXFxcdFxcXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfRVFVSVJFQyApXFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWMyIHNhbXBsZVVWO1xcXFxuXFxcXHRcXFxcdFxcXFx0c2FtcGxlVVYueSA9IGFzaW4oIGNsYW1wKCByZWZsZWN0VmVjLnksIC0gMS4wLCAxLjAgKSApICogUkVDSVBST0NBTF9QSSArIDAuNTtcXFxcblxcXFx0XFxcXHRcXFxcdHNhbXBsZVVWLnggPSBhdGFuKCByZWZsZWN0VmVjLnosIHJlZmxlY3RWZWMueCApICogUkVDSVBST0NBTF9QSTIgKyAwLjU7XFxcXG5cXFxcdFxcXFx0XFxcXHQjaWZkZWYgVEVYVFVSRV9MT0RfRVhUXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlMkRMb2RFWFQoIGVudk1hcCwgc2FtcGxlVVYsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXFxcblxcXFx0XFxcXHRcXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHZlYzQgZW52TWFwQ29sb3IgPSB0ZXh0dXJlMkQoIGVudk1hcCwgc2FtcGxlVVYsIHNwZWN1bGFyTUlQTGV2ZWwgKTtcXFxcblxcXFx0XFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHRcXFxcdFxcXFx0ZW52TWFwQ29sb3IucmdiID0gZW52TWFwVGV4ZWxUb0xpbmVhciggZW52TWFwQ29sb3IgKS5yZ2I7XFxcXG5cXFxcdFxcXFx0I2VsaWYgZGVmaW5lZCggRU5WTUFQX1RZUEVfU1BIRVJFIClcXFxcblxcXFx0XFxcXHRcXFxcdHZlYzMgcmVmbGVjdFZpZXcgPSBub3JtYWxpemUoICggdmlld01hdHJpeCAqIHZlYzQoIHJlZmxlY3RWZWMsIDAuMCApICkueHl6ICsgdmVjMyggMC4wLDAuMCwxLjAgKSApO1xcXFxuXFxcXHRcXFxcdFxcXFx0I2lmZGVmIFRFWFRVUkVfTE9EX0VYVFxcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZTJETG9kRVhUKCBlbnZNYXAsIHJlZmxlY3RWaWV3Lnh5ICogMC41ICsgMC41LCBzcGVjdWxhck1JUExldmVsICk7XFxcXG5cXFxcdFxcXFx0XFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR2ZWM0IGVudk1hcENvbG9yID0gdGV4dHVyZTJEKCBlbnZNYXAsIHJlZmxlY3RWaWV3Lnh5ICogMC41ICsgMC41LCBzcGVjdWxhck1JUExldmVsICk7XFxcXG5cXFxcdFxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0XFxcXHRcXFxcdGVudk1hcENvbG9yLnJnYiA9IGVudk1hcFRleGVsVG9MaW5lYXIoIGVudk1hcENvbG9yICkucmdiO1xcXFxuXFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHRcXFxcdHJldHVybiBlbnZNYXBDb2xvci5yZ2IgKiBlbnZNYXBJbnRlbnNpdHk7XFxcXG5cXFxcdH1cXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbGlnaHRzX3Bob25nX2ZyYWdtZW50ID0gXFxcIkJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbDtcXFxcbm1hdGVyaWFsLmRpZmZ1c2VDb2xvciA9IGRpZmZ1c2VDb2xvci5yZ2I7XFxcXG5tYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gc3BlY3VsYXI7XFxcXG5tYXRlcmlhbC5zcGVjdWxhclNoaW5pbmVzcyA9IHNoaW5pbmVzcztcXFxcbm1hdGVyaWFsLnNwZWN1bGFyU3RyZW5ndGggPSBzcGVjdWxhclN0cmVuZ3RoO1xcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQgPSBcXFwidmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxcXG5cXFxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcXFxuI2VuZGlmXFxcXG5zdHJ1Y3QgQmxpbm5QaG9uZ01hdGVyaWFsIHtcXFxcblxcXFx0dmVjM1xcXFx0ZGlmZnVzZUNvbG9yO1xcXFxuXFxcXHR2ZWMzXFxcXHRzcGVjdWxhckNvbG9yO1xcXFxuXFxcXHRmbG9hdFxcXFx0c3BlY3VsYXJTaGluaW5lc3M7XFxcXG5cXFxcdGZsb2F0XFxcXHRzcGVjdWxhclN0cmVuZ3RoO1xcXFxufTtcXFxcbnZvaWQgUkVfRGlyZWN0X0JsaW5uUGhvbmcoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIEJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxcXG5cXFxcdCNpZmRlZiBUT09OXFxcXG5cXFxcdFxcXFx0dmVjMyBpcnJhZGlhbmNlID0gZ2V0R3JhZGllbnRJcnJhZGlhbmNlKCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICogZGlyZWN0TGlnaHQuY29sb3I7XFxcXG5cXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0ZmxvYXQgZG90TkwgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGRpcmVjdExpZ2h0LmRpcmVjdGlvbiApICk7XFxcXG5cXFxcdFxcXFx0dmVjMyBpcnJhZGlhbmNlID0gZG90TkwgKiBkaXJlY3RMaWdodC5jb2xvcjtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcXFxuXFxcXHRcXFxcdGlycmFkaWFuY2UgKj0gUEk7XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0RpZmZ1c2VfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxcXG5cXFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGlycmFkaWFuY2UgKiBCUkRGX1NwZWN1bGFyX0JsaW5uUGhvbmcoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwuc3BlY3VsYXJDb2xvciwgbWF0ZXJpYWwuc3BlY3VsYXJTaGluaW5lc3MgKSAqIG1hdGVyaWFsLnNwZWN1bGFyU3RyZW5ndGg7XFxcXG59XFxcXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9CbGlublBob25nKCBjb25zdCBpbiB2ZWMzIGlycmFkaWFuY2UsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIEJsaW5uUGhvbmdNYXRlcmlhbCBtYXRlcmlhbCwgaW5vdXQgUmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgKSB7XFxcXG5cXFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSArPSBpcnJhZGlhbmNlICogQlJERl9EaWZmdXNlX0xhbWJlcnQoIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciApO1xcXFxufVxcXFxuI2RlZmluZSBSRV9EaXJlY3RcXFxcdFxcXFx0XFxcXHRcXFxcdFJFX0RpcmVjdF9CbGlublBob25nXFxcXG4jZGVmaW5lIFJFX0luZGlyZWN0RGlmZnVzZVxcXFx0XFxcXHRSRV9JbmRpcmVjdERpZmZ1c2VfQmxpbm5QaG9uZ1xcXFxuI2RlZmluZSBNYXRlcmlhbF9MaWdodFByb2JlTE9EKCBtYXRlcmlhbCApXFxcXHQoMClcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudCA9IFxcXCJQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsO1xcXFxubWF0ZXJpYWwuZGlmZnVzZUNvbG9yID0gZGlmZnVzZUNvbG9yLnJnYiAqICggMS4wIC0gbWV0YWxuZXNzRmFjdG9yICk7XFxcXG5tYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyA9IGNsYW1wKCByb3VnaG5lc3NGYWN0b3IsIDAuMDQsIDEuMCApO1xcXFxuI2lmZGVmIFNUQU5EQVJEXFxcXG5cXFxcdG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IgPSBtaXgoIHZlYzMoIERFRkFVTFRfU1BFQ1VMQVJfQ09FRkZJQ0lFTlQgKSwgZGlmZnVzZUNvbG9yLnJnYiwgbWV0YWxuZXNzRmFjdG9yICk7XFxcXG4jZWxzZVxcXFxuXFxcXHRtYXRlcmlhbC5zcGVjdWxhckNvbG9yID0gbWl4KCB2ZWMzKCBNQVhJTVVNX1NQRUNVTEFSX0NPRUZGSUNJRU5UICogcG93MiggcmVmbGVjdGl2aXR5ICkgKSwgZGlmZnVzZUNvbG9yLnJnYiwgbWV0YWxuZXNzRmFjdG9yICk7XFxcXG5cXFxcdG1hdGVyaWFsLmNsZWFyQ29hdCA9IHNhdHVyYXRlKCBjbGVhckNvYXQgKTtcXFxcdG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcyA9IGNsYW1wKCBjbGVhckNvYXRSb3VnaG5lc3MsIDAuMDQsIDEuMCApO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudCA9IFxcXCJzdHJ1Y3QgUGh5c2ljYWxNYXRlcmlhbCB7XFxcXG5cXFxcdHZlYzNcXFxcdGRpZmZ1c2VDb2xvcjtcXFxcblxcXFx0ZmxvYXRcXFxcdHNwZWN1bGFyUm91Z2huZXNzO1xcXFxuXFxcXHR2ZWMzXFxcXHRzcGVjdWxhckNvbG9yO1xcXFxuXFxcXHQjaWZuZGVmIFNUQU5EQVJEXFxcXG5cXFxcdFxcXFx0ZmxvYXQgY2xlYXJDb2F0O1xcXFxuXFxcXHRcXFxcdGZsb2F0IGNsZWFyQ29hdFJvdWdobmVzcztcXFxcblxcXFx0I2VuZGlmXFxcXG59O1xcXFxuI2RlZmluZSBNQVhJTVVNX1NQRUNVTEFSX0NPRUZGSUNJRU5UIDAuMTZcXFxcbiNkZWZpbmUgREVGQVVMVF9TUEVDVUxBUl9DT0VGRklDSUVOVCAwLjA0XFxcXG5mbG9hdCBjbGVhckNvYXRESFJBcHByb3goIGNvbnN0IGluIGZsb2F0IHJvdWdobmVzcywgY29uc3QgaW4gZmxvYXQgZG90TkwgKSB7XFxcXG5cXFxcdHJldHVybiBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UICsgKCAxLjAgLSBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UICkgKiAoIHBvdyggMS4wIC0gZG90TkwsIDUuMCApICogcG93KCAxLjAgLSByb3VnaG5lc3MsIDIuMCApICk7XFxcXG59XFxcXG4jaWYgTlVNX1JFQ1RfQVJFQV9MSUdIVFMgPiAwXFxcXG5cXFxcdHZvaWQgUkVfRGlyZWN0X1JlY3RBcmVhX1BoeXNpY2FsKCBjb25zdCBpbiBSZWN0QXJlYUxpZ2h0IHJlY3RBcmVhTGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcXFxuXFxcXHRcXFxcdHZlYzMgbm9ybWFsID0gZ2VvbWV0cnkubm9ybWFsO1xcXFxuXFxcXHRcXFxcdHZlYzMgdmlld0RpciA9IGdlb21ldHJ5LnZpZXdEaXI7XFxcXG5cXFxcdFxcXFx0dmVjMyBwb3NpdGlvbiA9IGdlb21ldHJ5LnBvc2l0aW9uO1xcXFxuXFxcXHRcXFxcdHZlYzMgbGlnaHRQb3MgPSByZWN0QXJlYUxpZ2h0LnBvc2l0aW9uO1xcXFxuXFxcXHRcXFxcdHZlYzMgaGFsZldpZHRoID0gcmVjdEFyZWFMaWdodC5oYWxmV2lkdGg7XFxcXG5cXFxcdFxcXFx0dmVjMyBoYWxmSGVpZ2h0ID0gcmVjdEFyZWFMaWdodC5oYWxmSGVpZ2h0O1xcXFxuXFxcXHRcXFxcdHZlYzMgbGlnaHRDb2xvciA9IHJlY3RBcmVhTGlnaHQuY29sb3I7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgcm91Z2huZXNzID0gbWF0ZXJpYWwuc3BlY3VsYXJSb3VnaG5lc3M7XFxcXG5cXFxcdFxcXFx0dmVjMyByZWN0Q29vcmRzWyA0IF07XFxcXG5cXFxcdFxcXFx0cmVjdENvb3Jkc1sgMCBdID0gbGlnaHRQb3MgLSBoYWxmV2lkdGggLSBoYWxmSGVpZ2h0O1xcXFx0XFxcXHRyZWN0Q29vcmRzWyAxIF0gPSBsaWdodFBvcyArIGhhbGZXaWR0aCAtIGhhbGZIZWlnaHQ7XFxcXG5cXFxcdFxcXFx0cmVjdENvb3Jkc1sgMiBdID0gbGlnaHRQb3MgKyBoYWxmV2lkdGggKyBoYWxmSGVpZ2h0O1xcXFxuXFxcXHRcXFxcdHJlY3RDb29yZHNbIDMgXSA9IGxpZ2h0UG9zIC0gaGFsZldpZHRoICsgaGFsZkhlaWdodDtcXFxcblxcXFx0XFxcXHR2ZWMyIHV2ID0gTFRDX1V2KCBub3JtYWwsIHZpZXdEaXIsIHJvdWdobmVzcyApO1xcXFxuXFxcXHRcXFxcdGZsb2F0IG5vcm0gPSB0ZXh0dXJlMkQoIGx0Y01hZywgdXYgKS5hO1xcXFxuXFxcXHRcXFxcdHZlYzQgdCA9IHRleHR1cmUyRCggbHRjTWF0LCB1diApO1xcXFxuXFxcXHRcXFxcdG1hdDMgbUludiA9IG1hdDMoXFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWMzKCAgIDEsICAgMCwgdC55ICksXFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWMzKCAgIDAsIHQueiwgICAwICksXFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWMzKCB0LncsICAgMCwgdC54IClcXFxcblxcXFx0XFxcXHQpO1xcXFxuXFxcXHRcXFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdFNwZWN1bGFyICs9IGxpZ2h0Q29sb3IgKiBtYXRlcmlhbC5zcGVjdWxhckNvbG9yICogbm9ybSAqIExUQ19FdmFsdWF0ZSggbm9ybWFsLCB2aWV3RGlyLCBwb3NpdGlvbiwgbUludiwgcmVjdENvb3JkcyApO1xcXFxuXFxcXHRcXFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gbGlnaHRDb2xvciAqIG1hdGVyaWFsLmRpZmZ1c2VDb2xvciAqIExUQ19FdmFsdWF0ZSggbm9ybWFsLCB2aWV3RGlyLCBwb3NpdGlvbiwgbWF0MyggMSApLCByZWN0Q29vcmRzICk7XFxcXG5cXFxcdH1cXFxcbiNlbmRpZlxcXFxudm9pZCBSRV9EaXJlY3RfUGh5c2ljYWwoIGNvbnN0IGluIEluY2lkZW50TGlnaHQgZGlyZWN0TGlnaHQsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcXFxuXFxcXHRmbG9hdCBkb3ROTCA9IHNhdHVyYXRlKCBkb3QoIGdlb21ldHJ5Lm5vcm1hbCwgZGlyZWN0TGlnaHQuZGlyZWN0aW9uICkgKTtcXFxcblxcXFx0dmVjMyBpcnJhZGlhbmNlID0gZG90TkwgKiBkaXJlY3RMaWdodC5jb2xvcjtcXFxcblxcXFx0I2lmbmRlZiBQSFlTSUNBTExZX0NPUlJFQ1RfTElHSFRTXFxcXG5cXFxcdFxcXFx0aXJyYWRpYW5jZSAqPSBQSTtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpZm5kZWYgU1RBTkRBUkRcXFxcblxcXFx0XFxcXHRmbG9hdCBjbGVhckNvYXRESFIgPSBtYXRlcmlhbC5jbGVhckNvYXQgKiBjbGVhckNvYXRESFJBcHByb3goIG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcywgZG90TkwgKTtcXFxcblxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHRmbG9hdCBjbGVhckNvYXRESFIgPSAwLjA7XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSAoIDEuMCAtIGNsZWFyQ29hdERIUiApICogaXJyYWRpYW5jZSAqIEJSREZfU3BlY3VsYXJfR0dYKCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzICk7XFxcXG5cXFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKz0gKCAxLjAgLSBjbGVhckNvYXRESFIgKSAqIGlycmFkaWFuY2UgKiBCUkRGX0RpZmZ1c2VfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxcXG5cXFxcdCNpZm5kZWYgU1RBTkRBUkRcXFxcblxcXFx0XFxcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3RTcGVjdWxhciArPSBpcnJhZGlhbmNlICogbWF0ZXJpYWwuY2xlYXJDb2F0ICogQlJERl9TcGVjdWxhcl9HR1goIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgdmVjMyggREVGQVVMVF9TUEVDVUxBUl9DT0VGRklDSUVOVCApLCBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3MgKTtcXFxcblxcXFx0I2VuZGlmXFxcXG59XFxcXG52b2lkIFJFX0luZGlyZWN0RGlmZnVzZV9QaHlzaWNhbCggY29uc3QgaW4gdmVjMyBpcnJhZGlhbmNlLCBjb25zdCBpbiBHZW9tZXRyaWNDb250ZXh0IGdlb21ldHJ5LCBjb25zdCBpbiBQaHlzaWNhbE1hdGVyaWFsIG1hdGVyaWFsLCBpbm91dCBSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCApIHtcXFxcblxcXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IGlycmFkaWFuY2UgKiBCUkRGX0RpZmZ1c2VfTGFtYmVydCggbWF0ZXJpYWwuZGlmZnVzZUNvbG9yICk7XFxcXG59XFxcXG52b2lkIFJFX0luZGlyZWN0U3BlY3VsYXJfUGh5c2ljYWwoIGNvbnN0IGluIHZlYzMgcmFkaWFuY2UsIGNvbnN0IGluIHZlYzMgY2xlYXJDb2F0UmFkaWFuY2UsIGNvbnN0IGluIEdlb21ldHJpY0NvbnRleHQgZ2VvbWV0cnksIGNvbnN0IGluIFBoeXNpY2FsTWF0ZXJpYWwgbWF0ZXJpYWwsIGlub3V0IFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ICkge1xcXFxuXFxcXHQjaWZuZGVmIFNUQU5EQVJEXFxcXG5cXFxcdFxcXFx0ZmxvYXQgZG90TlYgPSBzYXR1cmF0ZSggZG90KCBnZW9tZXRyeS5ub3JtYWwsIGdlb21ldHJ5LnZpZXdEaXIgKSApO1xcXFxuXFxcXHRcXFxcdGZsb2F0IGRvdE5MID0gZG90TlY7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgY2xlYXJDb2F0REhSID0gbWF0ZXJpYWwuY2xlYXJDb2F0ICogY2xlYXJDb2F0REhSQXBwcm94KCBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3MsIGRvdE5MICk7XFxcXG5cXFxcdCNlbHNlXFxcXG5cXFxcdFxcXFx0ZmxvYXQgY2xlYXJDb2F0REhSID0gMC4wO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3RTcGVjdWxhciArPSAoIDEuMCAtIGNsZWFyQ29hdERIUiApICogcmFkaWFuY2UgKiBCUkRGX1NwZWN1bGFyX0dHWF9FbnZpcm9ubWVudCggZ2VvbWV0cnksIG1hdGVyaWFsLnNwZWN1bGFyQ29sb3IsIG1hdGVyaWFsLnNwZWN1bGFyUm91Z2huZXNzICk7XFxcXG5cXFxcdCNpZm5kZWYgU1RBTkRBUkRcXFxcblxcXFx0XFxcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICs9IGNsZWFyQ29hdFJhZGlhbmNlICogbWF0ZXJpYWwuY2xlYXJDb2F0ICogQlJERl9TcGVjdWxhcl9HR1hfRW52aXJvbm1lbnQoIGdlb21ldHJ5LCB2ZWMzKCBERUZBVUxUX1NQRUNVTEFSX0NPRUZGSUNJRU5UICksIG1hdGVyaWFsLmNsZWFyQ29hdFJvdWdobmVzcyApO1xcXFxuXFxcXHQjZW5kaWZcXFxcbn1cXFxcbiNkZWZpbmUgUkVfRGlyZWN0XFxcXHRcXFxcdFxcXFx0XFxcXHRSRV9EaXJlY3RfUGh5c2ljYWxcXFxcbiNkZWZpbmUgUkVfRGlyZWN0X1JlY3RBcmVhXFxcXHRcXFxcdFJFX0RpcmVjdF9SZWN0QXJlYV9QaHlzaWNhbFxcXFxuI2RlZmluZSBSRV9JbmRpcmVjdERpZmZ1c2VcXFxcdFxcXFx0UkVfSW5kaXJlY3REaWZmdXNlX1BoeXNpY2FsXFxcXG4jZGVmaW5lIFJFX0luZGlyZWN0U3BlY3VsYXJcXFxcdFxcXFx0UkVfSW5kaXJlY3RTcGVjdWxhcl9QaHlzaWNhbFxcXFxuI2RlZmluZSBNYXRlcmlhbF9CbGlublNoaW5pbmVzc0V4cG9uZW50KCBtYXRlcmlhbCApICAgR0dYUm91Z2huZXNzVG9CbGlubkV4cG9uZW50KCBtYXRlcmlhbC5zcGVjdWxhclJvdWdobmVzcyApXFxcXG4jZGVmaW5lIE1hdGVyaWFsX0NsZWFyQ29hdF9CbGlublNoaW5pbmVzc0V4cG9uZW50KCBtYXRlcmlhbCApICAgR0dYUm91Z2huZXNzVG9CbGlubkV4cG9uZW50KCBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3MgKVxcXFxuZmxvYXQgY29tcHV0ZVNwZWN1bGFyT2NjbHVzaW9uKCBjb25zdCBpbiBmbG9hdCBkb3ROViwgY29uc3QgaW4gZmxvYXQgYW1iaWVudE9jY2x1c2lvbiwgY29uc3QgaW4gZmxvYXQgcm91Z2huZXNzICkge1xcXFxuXFxcXHRyZXR1cm4gc2F0dXJhdGUoIHBvdyggZG90TlYgKyBhbWJpZW50T2NjbHVzaW9uLCBleHAyKCAtIDE2LjAgKiByb3VnaG5lc3MgLSAxLjAgKSApIC0gMS4wICsgYW1iaWVudE9jY2x1c2lvbiApO1xcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbGlnaHRzX3RlbXBsYXRlID0gXFxcIlxcXFxuR2VvbWV0cmljQ29udGV4dCBnZW9tZXRyeTtcXFxcbmdlb21ldHJ5LnBvc2l0aW9uID0gLSB2Vmlld1Bvc2l0aW9uO1xcXFxuZ2VvbWV0cnkubm9ybWFsID0gbm9ybWFsO1xcXFxuZ2VvbWV0cnkudmlld0RpciA9IG5vcm1hbGl6ZSggdlZpZXdQb3NpdGlvbiApO1xcXFxuSW5jaWRlbnRMaWdodCBkaXJlY3RMaWdodDtcXFxcbiNpZiAoIE5VTV9QT0lOVF9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0IClcXFxcblxcXFx0UG9pbnRMaWdodCBwb2ludExpZ2h0O1xcXFxuXFxcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcXFxuXFxcXHRcXFxcdHBvaW50TGlnaHQgPSBwb2ludExpZ2h0c1sgaSBdO1xcXFxuXFxcXHRcXFxcdGdldFBvaW50RGlyZWN0TGlnaHRJcnJhZGlhbmNlKCBwb2ludExpZ2h0LCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXFxcblxcXFx0XFxcXHQjaWZkZWYgVVNFX1NIQURPV01BUFxcXFxuXFxcXHRcXFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGFsbCggYnZlYzIoIHBvaW50TGlnaHQuc2hhZG93LCBkaXJlY3RMaWdodC52aXNpYmxlICkgKSA/IGdldFBvaW50U2hhZG93KCBwb2ludFNoYWRvd01hcFsgaSBdLCBwb2ludExpZ2h0LnNoYWRvd01hcFNpemUsIHBvaW50TGlnaHQuc2hhZG93QmlhcywgcG9pbnRMaWdodC5zaGFkb3dSYWRpdXMsIHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0sIHBvaW50TGlnaHQuc2hhZG93Q2FtZXJhTmVhciwgcG9pbnRMaWdodC5zaGFkb3dDYW1lcmFGYXIgKSA6IDEuMDtcXFxcblxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0XFxcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxcXG5cXFxcdH1cXFxcbiNlbmRpZlxcXFxuI2lmICggTlVNX1NQT1RfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxcXG5cXFxcdFNwb3RMaWdodCBzcG90TGlnaHQ7XFxcXG5cXFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9TUE9UX0xJR0hUUzsgaSArKyApIHtcXFxcblxcXFx0XFxcXHRzcG90TGlnaHQgPSBzcG90TGlnaHRzWyBpIF07XFxcXG5cXFxcdFxcXFx0Z2V0U3BvdERpcmVjdExpZ2h0SXJyYWRpYW5jZSggc3BvdExpZ2h0LCBnZW9tZXRyeSwgZGlyZWN0TGlnaHQgKTtcXFxcblxcXFx0XFxcXHQjaWZkZWYgVVNFX1NIQURPV01BUFxcXFxuXFxcXHRcXFxcdGRpcmVjdExpZ2h0LmNvbG9yICo9IGFsbCggYnZlYzIoIHNwb3RMaWdodC5zaGFkb3csIGRpcmVjdExpZ2h0LnZpc2libGUgKSApID8gZ2V0U2hhZG93KCBzcG90U2hhZG93TWFwWyBpIF0sIHNwb3RMaWdodC5zaGFkb3dNYXBTaXplLCBzcG90TGlnaHQuc2hhZG93Qmlhcywgc3BvdExpZ2h0LnNoYWRvd1JhZGl1cywgdlNwb3RTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxcXG5cXFxcdFxcXFx0I2VuZGlmXFxcXG5cXFxcdFxcXFx0UkVfRGlyZWN0KCBkaXJlY3RMaWdodCwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcXFxuXFxcXHR9XFxcXG4jZW5kaWZcXFxcbiNpZiAoIE5VTV9ESVJfTElHSFRTID4gMCApICYmIGRlZmluZWQoIFJFX0RpcmVjdCApXFxcXG5cXFxcdERpcmVjdGlvbmFsTGlnaHQgZGlyZWN0aW9uYWxMaWdodDtcXFxcblxcXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0RJUl9MSUdIVFM7IGkgKysgKSB7XFxcXG5cXFxcdFxcXFx0ZGlyZWN0aW9uYWxMaWdodCA9IGRpcmVjdGlvbmFsTGlnaHRzWyBpIF07XFxcXG5cXFxcdFxcXFx0Z2V0RGlyZWN0aW9uYWxEaXJlY3RMaWdodElycmFkaWFuY2UoIGRpcmVjdGlvbmFsTGlnaHQsIGdlb21ldHJ5LCBkaXJlY3RMaWdodCApO1xcXFxuXFxcXHRcXFxcdCNpZmRlZiBVU0VfU0hBRE9XTUFQXFxcXG5cXFxcdFxcXFx0ZGlyZWN0TGlnaHQuY29sb3IgKj0gYWxsKCBidmVjMiggZGlyZWN0aW9uYWxMaWdodC5zaGFkb3csIGRpcmVjdExpZ2h0LnZpc2libGUgKSApID8gZ2V0U2hhZG93KCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgaSBdLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd01hcFNpemUsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93QmlhcywgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dSYWRpdXMsIHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXFxcblxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0XFxcXHRSRV9EaXJlY3QoIGRpcmVjdExpZ2h0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIHJlZmxlY3RlZExpZ2h0ICk7XFxcXG5cXFxcdH1cXFxcbiNlbmRpZlxcXFxuI2lmICggTlVNX1JFQ1RfQVJFQV9MSUdIVFMgPiAwICkgJiYgZGVmaW5lZCggUkVfRGlyZWN0X1JlY3RBcmVhIClcXFxcblxcXFx0UmVjdEFyZWFMaWdodCByZWN0QXJlYUxpZ2h0O1xcXFxuXFxcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUkVDVF9BUkVBX0xJR0hUUzsgaSArKyApIHtcXFxcblxcXFx0XFxcXHRyZWN0QXJlYUxpZ2h0ID0gcmVjdEFyZWFMaWdodHNbIGkgXTtcXFxcblxcXFx0XFxcXHRSRV9EaXJlY3RfUmVjdEFyZWEoIHJlY3RBcmVhTGlnaHQsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcmVmbGVjdGVkTGlnaHQgKTtcXFxcblxcXFx0fVxcXFxuI2VuZGlmXFxcXG4jaWYgZGVmaW5lZCggUkVfSW5kaXJlY3REaWZmdXNlIClcXFxcblxcXFx0dmVjMyBpcnJhZGlhbmNlID0gZ2V0QW1iaWVudExpZ2h0SXJyYWRpYW5jZSggYW1iaWVudExpZ2h0Q29sb3IgKTtcXFxcblxcXFx0I2lmZGVmIFVTRV9MSUdIVE1BUFxcXFxuXFxcXHRcXFxcdHZlYzMgbGlnaHRNYXBJcnJhZGlhbmNlID0gdGV4dHVyZTJEKCBsaWdodE1hcCwgdlV2MiApLnh5eiAqIGxpZ2h0TWFwSW50ZW5zaXR5O1xcXFxuXFxcXHRcXFxcdCNpZm5kZWYgUEhZU0lDQUxMWV9DT1JSRUNUX0xJR0hUU1xcXFxuXFxcXHRcXFxcdFxcXFx0bGlnaHRNYXBJcnJhZGlhbmNlICo9IFBJO1xcXFxuXFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHRcXFxcdGlycmFkaWFuY2UgKz0gbGlnaHRNYXBJcnJhZGlhbmNlO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2lmICggTlVNX0hFTUlfTElHSFRTID4gMCApXFxcXG5cXFxcdFxcXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX0hFTUlfTElHSFRTOyBpICsrICkge1xcXFxuXFxcXHRcXFxcdFxcXFx0aXJyYWRpYW5jZSArPSBnZXRIZW1pc3BoZXJlTGlnaHRJcnJhZGlhbmNlKCBoZW1pc3BoZXJlTGlnaHRzWyBpIF0sIGdlb21ldHJ5ICk7XFxcXG5cXFxcdFxcXFx0fVxcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2lmIGRlZmluZWQoIFVTRV9FTlZNQVAgKSAmJiBkZWZpbmVkKCBQSFlTSUNBTCApICYmIGRlZmluZWQoIEVOVk1BUF9UWVBFX0NVQkVfVVYgKVxcXFxuXFxcXHRcXFxcdGlycmFkaWFuY2UgKz0gZ2V0TGlnaHRQcm9iZUluZGlyZWN0SXJyYWRpYW5jZSggZ2VvbWV0cnksIDggKTtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdFJFX0luZGlyZWN0RGlmZnVzZSggaXJyYWRpYW5jZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcXFxuI2VuZGlmXFxcXG4jaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApICYmIGRlZmluZWQoIFJFX0luZGlyZWN0U3BlY3VsYXIgKVxcXFxuXFxcXHR2ZWMzIHJhZGlhbmNlID0gZ2V0TGlnaHRQcm9iZUluZGlyZWN0UmFkaWFuY2UoIGdlb21ldHJ5LCBNYXRlcmlhbF9CbGlublNoaW5pbmVzc0V4cG9uZW50KCBtYXRlcmlhbCApLCA4ICk7XFxcXG5cXFxcdCNpZm5kZWYgU1RBTkRBUkRcXFxcblxcXFx0XFxcXHR2ZWMzIGNsZWFyQ29hdFJhZGlhbmNlID0gZ2V0TGlnaHRQcm9iZUluZGlyZWN0UmFkaWFuY2UoIGdlb21ldHJ5LCBNYXRlcmlhbF9DbGVhckNvYXRfQmxpbm5TaGluaW5lc3NFeHBvbmVudCggbWF0ZXJpYWwgKSwgOCApO1xcXFxuXFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdHZlYzMgY2xlYXJDb2F0UmFkaWFuY2UgPSB2ZWMzKCAwLjAgKTtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdFJFX0luZGlyZWN0U3BlY3VsYXIoIHJhZGlhbmNlLCBjbGVhckNvYXRSYWRpYW5jZSwgZ2VvbWV0cnksIG1hdGVyaWFsLCByZWZsZWN0ZWRMaWdodCApO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBsb2dkZXB0aGJ1Zl9mcmFnbWVudCA9IFxcXCIjaWYgZGVmaW5lZCggVVNFX0xPR0RFUFRIQlVGICkgJiYgZGVmaW5lZCggVVNFX0xPR0RFUFRIQlVGX0VYVCApXFxcXG5cXFxcdGdsX0ZyYWdEZXB0aEVYVCA9IGxvZzIoIHZGcmFnRGVwdGggKSAqIGxvZ0RlcHRoQnVmRkMgKiAwLjU7XFxcXG4jZW5kaWZcXFwiO1xcblxcblxcdHZhciBsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXFxcblxcXFx0dW5pZm9ybSBmbG9hdCBsb2dEZXB0aEJ1ZkZDO1xcXFxuXFxcXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcXFxuXFxcXHRcXFxcdHZhcnlpbmcgZmxvYXQgdkZyYWdEZXB0aDtcXFxcblxcXFx0I2VuZGlmXFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4ID0gXFxcIiNpZmRlZiBVU0VfTE9HREVQVEhCVUZcXFxcblxcXFx0I2lmZGVmIFVTRV9MT0dERVBUSEJVRl9FWFRcXFxcblxcXFx0XFxcXHR2YXJ5aW5nIGZsb2F0IHZGcmFnRGVwdGg7XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHR1bmlmb3JtIGZsb2F0IGxvZ0RlcHRoQnVmRkM7XFxcXG4jZW5kaWZcXFwiO1xcblxcblxcdHZhciBsb2dkZXB0aGJ1Zl92ZXJ0ZXggPSBcXFwiI2lmZGVmIFVTRV9MT0dERVBUSEJVRlxcXFxuXFxcXHQjaWZkZWYgVVNFX0xPR0RFUFRIQlVGX0VYVFxcXFxuXFxcXHRcXFxcdHZGcmFnRGVwdGggPSAxLjAgKyBnbF9Qb3NpdGlvbi53O1xcXFxuXFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdGdsX1Bvc2l0aW9uLnogPSBsb2cyKCBtYXgoIEVQU0lMT04sIGdsX1Bvc2l0aW9uLncgKyAxLjAgKSApICogbG9nRGVwdGhCdWZGQyAtIDEuMDtcXFxcblxcXFx0XFxcXHRnbF9Qb3NpdGlvbi56ICo9IGdsX1Bvc2l0aW9uLnc7XFxcXG5cXFxcdCNlbmRpZlxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBtYXBfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9NQVBcXFxcblxcXFx0dmVjNCB0ZXhlbENvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVdiApO1xcXFxuXFxcXHR0ZXhlbENvbG9yID0gbWFwVGV4ZWxUb0xpbmVhciggdGV4ZWxDb2xvciApO1xcXFxuXFxcXHRkaWZmdXNlQ29sb3IgKj0gdGV4ZWxDb2xvcjtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbWFwX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9NQVBcXFxcblxcXFx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBtYXBfcGFydGljbGVfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9NQVBcXFxcblxcXFx0dmVjMiB1diA9ICggdXZUcmFuc2Zvcm0gKiB2ZWMzKCBnbF9Qb2ludENvb3JkLngsIDEuMCAtIGdsX1BvaW50Q29vcmQueSwgMSApICkueHk7XFxcXG5cXFxcdHZlYzQgbWFwVGV4ZWwgPSB0ZXh0dXJlMkQoIG1hcCwgdXYgKTtcXFxcblxcXFx0ZGlmZnVzZUNvbG9yICo9IG1hcFRleGVsVG9MaW5lYXIoIG1hcFRleGVsICk7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfTUFQXFxcXG5cXFxcdHVuaWZvcm0gbWF0MyB1dlRyYW5zZm9ybTtcXFxcblxcXFx0dW5pZm9ybSBzYW1wbGVyMkQgbWFwO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBtZXRhbG5lc3NtYXBfZnJhZ21lbnQgPSBcXFwiZmxvYXQgbWV0YWxuZXNzRmFjdG9yID0gbWV0YWxuZXNzO1xcXFxuI2lmZGVmIFVTRV9NRVRBTE5FU1NNQVBcXFxcblxcXFx0dmVjNCB0ZXhlbE1ldGFsbmVzcyA9IHRleHR1cmUyRCggbWV0YWxuZXNzTWFwLCB2VXYgKTtcXFxcblxcXFx0bWV0YWxuZXNzRmFjdG9yICo9IHRleGVsTWV0YWxuZXNzLmI7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIG1ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfTUVUQUxORVNTTUFQXFxcXG5cXFxcdHVuaWZvcm0gc2FtcGxlcjJEIG1ldGFsbmVzc01hcDtcXFxcbiNlbmRpZlxcXCI7XFxuXFxuXFx0dmFyIG1vcnBobm9ybWFsX3ZlcnRleCA9IFxcXCIjaWZkZWYgVVNFX01PUlBITk9STUFMU1xcXFxuXFxcXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDAgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMCBdO1xcXFxuXFxcXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDEgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcXFxuXFxcXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDIgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMiBdO1xcXFxuXFxcXHRvYmplY3ROb3JtYWwgKz0gKCBtb3JwaE5vcm1hbDMgLSBub3JtYWwgKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMyBdO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBtb3JwaHRhcmdldF9wYXJzX3ZlcnRleCA9IFxcXCIjaWZkZWYgVVNFX01PUlBIVEFSR0VUU1xcXFxuXFxcXHQjaWZuZGVmIFVTRV9NT1JQSE5PUk1BTFNcXFxcblxcXFx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDggXTtcXFxcblxcXFx0I2Vsc2VcXFxcblxcXFx0dW5pZm9ybSBmbG9hdCBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTtcXFxcblxcXFx0I2VuZGlmXFxcXG4jZW5kaWZcXFwiO1xcblxcblxcdHZhciBtb3JwaHRhcmdldF92ZXJ0ZXggPSBcXFwiI2lmZGVmIFVTRV9NT1JQSFRBUkdFVFNcXFxcblxcXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDAgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAwIF07XFxcXG5cXFxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQxIC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgMSBdO1xcXFxuXFxcXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0MiAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDIgXTtcXFxcblxcXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDMgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyAzIF07XFxcXG5cXFxcdCNpZm5kZWYgVVNFX01PUlBITk9STUFMU1xcXFxuXFxcXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0NCAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDQgXTtcXFxcblxcXFx0dHJhbnNmb3JtZWQgKz0gKCBtb3JwaFRhcmdldDUgLSBwb3NpdGlvbiApICogbW9ycGhUYXJnZXRJbmZsdWVuY2VzWyA1IF07XFxcXG5cXFxcdHRyYW5zZm9ybWVkICs9ICggbW9ycGhUYXJnZXQ2IC0gcG9zaXRpb24gKSAqIG1vcnBoVGFyZ2V0SW5mbHVlbmNlc1sgNiBdO1xcXFxuXFxcXHR0cmFuc2Zvcm1lZCArPSAoIG1vcnBoVGFyZ2V0NyAtIHBvc2l0aW9uICkgKiBtb3JwaFRhcmdldEluZmx1ZW5jZXNbIDcgXTtcXFxcblxcXFx0I2VuZGlmXFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIG5vcm1hbF9mcmFnbWVudCA9IFxcXCIjaWZkZWYgRkxBVF9TSEFERURcXFxcblxcXFx0dmVjMyBmZHggPSB2ZWMzKCBkRmR4KCB2Vmlld1Bvc2l0aW9uLnggKSwgZEZkeCggdlZpZXdQb3NpdGlvbi55ICksIGRGZHgoIHZWaWV3UG9zaXRpb24ueiApICk7XFxcXG5cXFxcdHZlYzMgZmR5ID0gdmVjMyggZEZkeSggdlZpZXdQb3NpdGlvbi54ICksIGRGZHkoIHZWaWV3UG9zaXRpb24ueSApLCBkRmR5KCB2Vmlld1Bvc2l0aW9uLnogKSApO1xcXFxuXFxcXHR2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSggY3Jvc3MoIGZkeCwgZmR5ICkgKTtcXFxcbiNlbHNlXFxcXG5cXFxcdHZlYzMgbm9ybWFsID0gbm9ybWFsaXplKCB2Tm9ybWFsICk7XFxcXG5cXFxcdCNpZmRlZiBET1VCTEVfU0lERURcXFxcblxcXFx0XFxcXHRub3JtYWwgPSBub3JtYWwgKiAoIGZsb2F0KCBnbF9Gcm9udEZhY2luZyApICogMi4wIC0gMS4wICk7XFxcXG5cXFxcdCNlbmRpZlxcXFxuI2VuZGlmXFxcXG4jaWZkZWYgVVNFX05PUk1BTE1BUFxcXFxuXFxcXHRub3JtYWwgPSBwZXJ0dXJiTm9ybWFsMkFyYiggLXZWaWV3UG9zaXRpb24sIG5vcm1hbCApO1xcXFxuI2VsaWYgZGVmaW5lZCggVVNFX0JVTVBNQVAgKVxcXFxuXFxcXHRub3JtYWwgPSBwZXJ0dXJiTm9ybWFsQXJiKCAtdlZpZXdQb3NpdGlvbiwgbm9ybWFsLCBkSGR4eV9md2QoKSApO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBub3JtYWxtYXBfcGFyc19mcmFnbWVudCA9IFxcXCIjaWZkZWYgVVNFX05PUk1BTE1BUFxcXFxuXFxcXHR1bmlmb3JtIHNhbXBsZXIyRCBub3JtYWxNYXA7XFxcXG5cXFxcdHVuaWZvcm0gdmVjMiBub3JtYWxTY2FsZTtcXFxcblxcXFx0dmVjMyBwZXJ0dXJiTm9ybWFsMkFyYiggdmVjMyBleWVfcG9zLCB2ZWMzIHN1cmZfbm9ybSApIHtcXFxcblxcXFx0XFxcXHR2ZWMzIHEwID0gdmVjMyggZEZkeCggZXllX3Bvcy54ICksIGRGZHgoIGV5ZV9wb3MueSApLCBkRmR4KCBleWVfcG9zLnogKSApO1xcXFxuXFxcXHRcXFxcdHZlYzMgcTEgPSB2ZWMzKCBkRmR5KCBleWVfcG9zLnggKSwgZEZkeSggZXllX3Bvcy55ICksIGRGZHkoIGV5ZV9wb3MueiApICk7XFxcXG5cXFxcdFxcXFx0dmVjMiBzdDAgPSBkRmR4KCB2VXYuc3QgKTtcXFxcblxcXFx0XFxcXHR2ZWMyIHN0MSA9IGRGZHkoIHZVdi5zdCApO1xcXFxuXFxcXHRcXFxcdHZlYzMgUyA9IG5vcm1hbGl6ZSggcTAgKiBzdDEudCAtIHExICogc3QwLnQgKTtcXFxcblxcXFx0XFxcXHR2ZWMzIFQgPSBub3JtYWxpemUoIC1xMCAqIHN0MS5zICsgcTEgKiBzdDAucyApO1xcXFxuXFxcXHRcXFxcdHZlYzMgTiA9IG5vcm1hbGl6ZSggc3VyZl9ub3JtICk7XFxcXG5cXFxcdFxcXFx0dmVjMyBtYXBOID0gdGV4dHVyZTJEKCBub3JtYWxNYXAsIHZVdiApLnh5eiAqIDIuMCAtIDEuMDtcXFxcblxcXFx0XFxcXHRtYXBOLnh5ID0gbm9ybWFsU2NhbGUgKiBtYXBOLnh5O1xcXFxuXFxcXHRcXFxcdG1hdDMgdHNuID0gbWF0MyggUywgVCwgTiApO1xcXFxuXFxcXHRcXFxcdHJldHVybiBub3JtYWxpemUoIHRzbiAqIG1hcE4gKTtcXFxcblxcXFx0fVxcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBwYWNraW5nID0gXFxcInZlYzMgcGFja05vcm1hbFRvUkdCKCBjb25zdCBpbiB2ZWMzIG5vcm1hbCApIHtcXFxcblxcXFx0cmV0dXJuIG5vcm1hbGl6ZSggbm9ybWFsICkgKiAwLjUgKyAwLjU7XFxcXG59XFxcXG52ZWMzIHVucGFja1JHQlRvTm9ybWFsKCBjb25zdCBpbiB2ZWMzIHJnYiApIHtcXFxcblxcXFx0cmV0dXJuIDIuMCAqIHJnYi54eXogLSAxLjA7XFxcXG59XFxcXG5jb25zdCBmbG9hdCBQYWNrVXBzY2FsZSA9IDI1Ni4gLyAyNTUuO2NvbnN0IGZsb2F0IFVucGFja0Rvd25zY2FsZSA9IDI1NS4gLyAyNTYuO1xcXFxuY29uc3QgdmVjMyBQYWNrRmFjdG9ycyA9IHZlYzMoIDI1Ni4gKiAyNTYuICogMjU2LiwgMjU2LiAqIDI1Ni4sICAyNTYuICk7XFxcXG5jb25zdCB2ZWM0IFVucGFja0ZhY3RvcnMgPSBVbnBhY2tEb3duc2NhbGUgLyB2ZWM0KCBQYWNrRmFjdG9ycywgMS4gKTtcXFxcbmNvbnN0IGZsb2F0IFNoaWZ0UmlnaHQ4ID0gMS4gLyAyNTYuO1xcXFxudmVjNCBwYWNrRGVwdGhUb1JHQkEoIGNvbnN0IGluIGZsb2F0IHYgKSB7XFxcXG5cXFxcdHZlYzQgciA9IHZlYzQoIGZyYWN0KCB2ICogUGFja0ZhY3RvcnMgKSwgdiApO1xcXFxuXFxcXHRyLnl6dyAtPSByLnh5eiAqIFNoaWZ0UmlnaHQ4O1xcXFx0cmV0dXJuIHIgKiBQYWNrVXBzY2FsZTtcXFxcbn1cXFxcbmZsb2F0IHVucGFja1JHQkFUb0RlcHRoKCBjb25zdCBpbiB2ZWM0IHYgKSB7XFxcXG5cXFxcdHJldHVybiBkb3QoIHYsIFVucGFja0ZhY3RvcnMgKTtcXFxcbn1cXFxcbmZsb2F0IHZpZXdaVG9PcnRob2dyYXBoaWNEZXB0aCggY29uc3QgaW4gZmxvYXQgdmlld1osIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXFxcblxcXFx0cmV0dXJuICggdmlld1ogKyBuZWFyICkgLyAoIG5lYXIgLSBmYXIgKTtcXFxcbn1cXFxcbmZsb2F0IG9ydGhvZ3JhcGhpY0RlcHRoVG9WaWV3WiggY29uc3QgaW4gZmxvYXQgbGluZWFyQ2xpcFosIGNvbnN0IGluIGZsb2F0IG5lYXIsIGNvbnN0IGluIGZsb2F0IGZhciApIHtcXFxcblxcXFx0cmV0dXJuIGxpbmVhckNsaXBaICogKCBuZWFyIC0gZmFyICkgLSBuZWFyO1xcXFxufVxcXFxuZmxvYXQgdmlld1pUb1BlcnNwZWN0aXZlRGVwdGgoIGNvbnN0IGluIGZsb2F0IHZpZXdaLCBjb25zdCBpbiBmbG9hdCBuZWFyLCBjb25zdCBpbiBmbG9hdCBmYXIgKSB7XFxcXG5cXFxcdHJldHVybiAoKCBuZWFyICsgdmlld1ogKSAqIGZhciApIC8gKCggZmFyIC0gbmVhciApICogdmlld1ogKTtcXFxcbn1cXFxcbmZsb2F0IHBlcnNwZWN0aXZlRGVwdGhUb1ZpZXdaKCBjb25zdCBpbiBmbG9hdCBpbnZDbGlwWiwgY29uc3QgaW4gZmxvYXQgbmVhciwgY29uc3QgaW4gZmxvYXQgZmFyICkge1xcXFxuXFxcXHRyZXR1cm4gKCBuZWFyICogZmFyICkgLyAoICggZmFyIC0gbmVhciApICogaW52Q2xpcFogLSBmYXIgKTtcXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFBSRU1VTFRJUExJRURfQUxQSEFcXFxcblxcXFx0Z2xfRnJhZ0NvbG9yLnJnYiAqPSBnbF9GcmFnQ29sb3IuYTtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgcHJvamVjdF92ZXJ0ZXggPSBcXFwidmVjNCBtdlBvc2l0aW9uID0gbW9kZWxWaWV3TWF0cml4ICogdmVjNCggdHJhbnNmb3JtZWQsIDEuMCApO1xcXFxuZ2xfUG9zaXRpb24gPSBwcm9qZWN0aW9uTWF0cml4ICogbXZQb3NpdGlvbjtcXFxcblxcXCI7XFxuXFxuXFx0dmFyIGRpdGhlcmluZ19mcmFnbWVudCA9IFxcXCIjaWYgZGVmaW5lZCggRElUSEVSSU5HIClcXFxcbiAgZ2xfRnJhZ0NvbG9yLnJnYiA9IGRpdGhlcmluZyggZ2xfRnJhZ0NvbG9yLnJnYiApO1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBkaXRoZXJpbmdfcGFyc19mcmFnbWVudCA9IFxcXCIjaWYgZGVmaW5lZCggRElUSEVSSU5HIClcXFxcblxcXFx0dmVjMyBkaXRoZXJpbmcoIHZlYzMgY29sb3IgKSB7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgZ3JpZF9wb3NpdGlvbiA9IHJhbmQoIGdsX0ZyYWdDb29yZC54eSApO1xcXFxuXFxcXHRcXFxcdHZlYzMgZGl0aGVyX3NoaWZ0X1JHQiA9IHZlYzMoIDAuMjUgLyAyNTUuMCwgLTAuMjUgLyAyNTUuMCwgMC4yNSAvIDI1NS4wICk7XFxcXG5cXFxcdFxcXFx0ZGl0aGVyX3NoaWZ0X1JHQiA9IG1peCggMi4wICogZGl0aGVyX3NoaWZ0X1JHQiwgLTIuMCAqIGRpdGhlcl9zaGlmdF9SR0IsIGdyaWRfcG9zaXRpb24gKTtcXFxcblxcXFx0XFxcXHRyZXR1cm4gY29sb3IgKyBkaXRoZXJfc2hpZnRfUkdCO1xcXFxuXFxcXHR9XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIHJvdWdobmVzc21hcF9mcmFnbWVudCA9IFxcXCJmbG9hdCByb3VnaG5lc3NGYWN0b3IgPSByb3VnaG5lc3M7XFxcXG4jaWZkZWYgVVNFX1JPVUdITkVTU01BUFxcXFxuXFxcXHR2ZWM0IHRleGVsUm91Z2huZXNzID0gdGV4dHVyZTJEKCByb3VnaG5lc3NNYXAsIHZVdiApO1xcXFxuXFxcXHRyb3VnaG5lc3NGYWN0b3IgKj0gdGV4ZWxSb3VnaG5lc3MuZztcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgcm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9ST1VHSE5FU1NNQVBcXFxcblxcXFx0dW5pZm9ybSBzYW1wbGVyMkQgcm91Z2huZXNzTWFwO1xcXFxuI2VuZGlmXFxcIjtcXG5cXG5cXHR2YXIgc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmZGVmIFVTRV9TSEFET1dNQVBcXFxcblxcXFx0I2lmIE5VTV9ESVJfTElHSFRTID4gMFxcXFxuXFxcXHRcXFxcdHVuaWZvcm0gc2FtcGxlcjJEIGRpcmVjdGlvbmFsU2hhZG93TWFwWyBOVU1fRElSX0xJR0hUUyBdO1xcXFxuXFxcXHRcXFxcdHZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVFMgXTtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwXFxcXG5cXFxcdFxcXFx0dW5pZm9ybSBzYW1wbGVyMkQgc3BvdFNoYWRvd01hcFsgTlVNX1NQT1RfTElHSFRTIF07XFxcXG5cXFxcdFxcXFx0dmFyeWluZyB2ZWM0IHZTcG90U2hhZG93Q29vcmRbIE5VTV9TUE9UX0xJR0hUUyBdO1xcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2lmIE5VTV9QT0lOVF9MSUdIVFMgPiAwXFxcXG5cXFxcdFxcXFx0dW5pZm9ybSBzYW1wbGVyMkQgcG9pbnRTaGFkb3dNYXBbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXFxcblxcXFx0XFxcXHR2YXJ5aW5nIHZlYzQgdlBvaW50U2hhZG93Q29vcmRbIE5VTV9QT0lOVF9MSUdIVFMgXTtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdGZsb2F0IHRleHR1cmUyRENvbXBhcmUoIHNhbXBsZXIyRCBkZXB0aHMsIHZlYzIgdXYsIGZsb2F0IGNvbXBhcmUgKSB7XFxcXG5cXFxcdFxcXFx0cmV0dXJuIHN0ZXAoIGNvbXBhcmUsIHVucGFja1JHQkFUb0RlcHRoKCB0ZXh0dXJlMkQoIGRlcHRocywgdXYgKSApICk7XFxcXG5cXFxcdH1cXFxcblxcXFx0ZmxvYXQgdGV4dHVyZTJEU2hhZG93TGVycCggc2FtcGxlcjJEIGRlcHRocywgdmVjMiBzaXplLCB2ZWMyIHV2LCBmbG9hdCBjb21wYXJlICkge1xcXFxuXFxcXHRcXFxcdGNvbnN0IHZlYzIgb2Zmc2V0ID0gdmVjMiggMC4wLCAxLjAgKTtcXFxcblxcXFx0XFxcXHR2ZWMyIHRleGVsU2l6ZSA9IHZlYzIoIDEuMCApIC8gc2l6ZTtcXFxcblxcXFx0XFxcXHR2ZWMyIGNlbnRyb2lkVVYgPSBmbG9vciggdXYgKiBzaXplICsgMC41ICkgLyBzaXplO1xcXFxuXFxcXHRcXFxcdGZsb2F0IGxiID0gdGV4dHVyZTJEQ29tcGFyZSggZGVwdGhzLCBjZW50cm9pZFVWICsgdGV4ZWxTaXplICogb2Zmc2V0Lnh4LCBjb21wYXJlICk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgbHQgPSB0ZXh0dXJlMkRDb21wYXJlKCBkZXB0aHMsIGNlbnRyb2lkVVYgKyB0ZXhlbFNpemUgKiBvZmZzZXQueHksIGNvbXBhcmUgKTtcXFxcblxcXFx0XFxcXHRmbG9hdCByYiA9IHRleHR1cmUyRENvbXBhcmUoIGRlcHRocywgY2VudHJvaWRVViArIHRleGVsU2l6ZSAqIG9mZnNldC55eCwgY29tcGFyZSApO1xcXFxuXFxcXHRcXFxcdGZsb2F0IHJ0ID0gdGV4dHVyZTJEQ29tcGFyZSggZGVwdGhzLCBjZW50cm9pZFVWICsgdGV4ZWxTaXplICogb2Zmc2V0Lnl5LCBjb21wYXJlICk7XFxcXG5cXFxcdFxcXFx0dmVjMiBmID0gZnJhY3QoIHV2ICogc2l6ZSArIDAuNSApO1xcXFxuXFxcXHRcXFxcdGZsb2F0IGEgPSBtaXgoIGxiLCBsdCwgZi55ICk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgYiA9IG1peCggcmIsIHJ0LCBmLnkgKTtcXFxcblxcXFx0XFxcXHRmbG9hdCBjID0gbWl4KCBhLCBiLCBmLnggKTtcXFxcblxcXFx0XFxcXHRyZXR1cm4gYztcXFxcblxcXFx0fVxcXFxuXFxcXHRmbG9hdCBnZXRTaGFkb3coIHNhbXBsZXIyRCBzaGFkb3dNYXAsIHZlYzIgc2hhZG93TWFwU2l6ZSwgZmxvYXQgc2hhZG93QmlhcywgZmxvYXQgc2hhZG93UmFkaXVzLCB2ZWM0IHNoYWRvd0Nvb3JkICkge1xcXFxuXFxcXHRcXFxcdGZsb2F0IHNoYWRvdyA9IDEuMDtcXFxcblxcXFx0XFxcXHRzaGFkb3dDb29yZC54eXogLz0gc2hhZG93Q29vcmQudztcXFxcblxcXFx0XFxcXHRzaGFkb3dDb29yZC56ICs9IHNoYWRvd0JpYXM7XFxcXG5cXFxcdFxcXFx0YnZlYzQgaW5GcnVzdHVtVmVjID0gYnZlYzQgKCBzaGFkb3dDb29yZC54ID49IDAuMCwgc2hhZG93Q29vcmQueCA8PSAxLjAsIHNoYWRvd0Nvb3JkLnkgPj0gMC4wLCBzaGFkb3dDb29yZC55IDw9IDEuMCApO1xcXFxuXFxcXHRcXFxcdGJvb2wgaW5GcnVzdHVtID0gYWxsKCBpbkZydXN0dW1WZWMgKTtcXFxcblxcXFx0XFxcXHRidmVjMiBmcnVzdHVtVGVzdFZlYyA9IGJ2ZWMyKCBpbkZydXN0dW0sIHNoYWRvd0Nvb3JkLnogPD0gMS4wICk7XFxcXG5cXFxcdFxcXFx0Ym9vbCBmcnVzdHVtVGVzdCA9IGFsbCggZnJ1c3R1bVRlc3RWZWMgKTtcXFxcblxcXFx0XFxcXHRpZiAoIGZydXN0dW1UZXN0ICkge1xcXFxuXFxcXHRcXFxcdCNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKVxcXFxuXFxcXHRcXFxcdFxcXFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNoYWRvd01hcFNpemU7XFxcXG5cXFxcdFxcXFx0XFxcXHRmbG9hdCBkeDAgPSAtIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcXFxuXFxcXHRcXFxcdFxcXFx0ZmxvYXQgZHkwID0gLSB0ZXhlbFNpemUueSAqIHNoYWRvd1JhZGl1cztcXFxcblxcXFx0XFxcXHRcXFxcdGZsb2F0IGR4MSA9ICsgdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7XFxcXG5cXFxcdFxcXFx0XFxcXHRmbG9hdCBkeTEgPSArIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcXFxuXFxcXHRcXFxcdFxcXFx0c2hhZG93ID0gKFxcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkxICksIHNoYWRvd0Nvb3JkLnogKVxcXFxuXFxcXHRcXFxcdFxcXFx0KSAqICggMS4wIC8gOS4wICk7XFxcXG5cXFxcdFxcXFx0I2VsaWYgZGVmaW5lZCggU0hBRE9XTUFQX1RZUEVfUENGX1NPRlQgKVxcXFxuXFxcXHRcXFxcdFxcXFx0dmVjMiB0ZXhlbFNpemUgPSB2ZWMyKCAxLjAgKSAvIHNoYWRvd01hcFNpemU7XFxcXG5cXFxcdFxcXFx0XFxcXHRmbG9hdCBkeDAgPSAtIHRleGVsU2l6ZS54ICogc2hhZG93UmFkaXVzO1xcXFxuXFxcXHRcXFxcdFxcXFx0ZmxvYXQgZHkwID0gLSB0ZXhlbFNpemUueSAqIHNoYWRvd1JhZGl1cztcXFxcblxcXFx0XFxcXHRcXFxcdGZsb2F0IGR4MSA9ICsgdGV4ZWxTaXplLnggKiBzaGFkb3dSYWRpdXM7XFxcXG5cXFxcdFxcXFx0XFxcXHRmbG9hdCBkeTEgPSArIHRleGVsU2l6ZS55ICogc2hhZG93UmFkaXVzO1xcXFxuXFxcXHRcXFxcdFxcXFx0c2hhZG93ID0gKFxcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCBkeTAgKSwgc2hhZG93Q29vcmQueiApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIDAuMCwgZHkwICksIHNoYWRvd0Nvb3JkLnogKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDEsIGR5MCApLCBzaGFkb3dDb29yZC56ICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggZHgwLCAwLjAgKSwgc2hhZG93Q29vcmQueiApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSwgc2hhZG93Q29vcmQueiApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgMC4wICksIHNoYWRvd0Nvb3JkLnogKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRFNoYWRvd0xlcnAoIHNoYWRvd01hcCwgc2hhZG93TWFwU2l6ZSwgc2hhZG93Q29vcmQueHkgKyB2ZWMyKCBkeDAsIGR5MSApLCBzaGFkb3dDb29yZC56ICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRTaGFkb3dMZXJwKCBzaGFkb3dNYXAsIHNoYWRvd01hcFNpemUsIHNoYWRvd0Nvb3JkLnh5ICsgdmVjMiggMC4wLCBkeTEgKSwgc2hhZG93Q29vcmQueiApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEU2hhZG93TGVycCggc2hhZG93TWFwLCBzaGFkb3dNYXBTaXplLCBzaGFkb3dDb29yZC54eSArIHZlYzIoIGR4MSwgZHkxICksIHNoYWRvd0Nvb3JkLnogKVxcXFxuXFxcXHRcXFxcdFxcXFx0KSAqICggMS4wIC8gOS4wICk7XFxcXG5cXFxcdFxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHRcXFxcdHNoYWRvdyA9IHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgc2hhZG93Q29vcmQueHksIHNoYWRvd0Nvb3JkLnogKTtcXFxcblxcXFx0XFxcXHQjZW5kaWZcXFxcblxcXFx0XFxcXHR9XFxcXG5cXFxcdFxcXFx0cmV0dXJuIHNoYWRvdztcXFxcblxcXFx0fVxcXFxuXFxcXHR2ZWMyIGN1YmVUb1VWKCB2ZWMzIHYsIGZsb2F0IHRleGVsU2l6ZVkgKSB7XFxcXG5cXFxcdFxcXFx0dmVjMyBhYnNWID0gYWJzKCB2ICk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgc2NhbGVUb0N1YmUgPSAxLjAgLyBtYXgoIGFic1YueCwgbWF4KCBhYnNWLnksIGFic1YueiApICk7XFxcXG5cXFxcdFxcXFx0YWJzViAqPSBzY2FsZVRvQ3ViZTtcXFxcblxcXFx0XFxcXHR2ICo9IHNjYWxlVG9DdWJlICogKCAxLjAgLSAyLjAgKiB0ZXhlbFNpemVZICk7XFxcXG5cXFxcdFxcXFx0dmVjMiBwbGFuYXIgPSB2Lnh5O1xcXFxuXFxcXHRcXFxcdGZsb2F0IGFsbW9zdEFUZXhlbCA9IDEuNSAqIHRleGVsU2l6ZVk7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgYWxtb3N0T25lID0gMS4wIC0gYWxtb3N0QVRleGVsO1xcXFxuXFxcXHRcXFxcdGlmICggYWJzVi56ID49IGFsbW9zdE9uZSApIHtcXFxcblxcXFx0XFxcXHRcXFxcdGlmICggdi56ID4gMC4wIClcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0cGxhbmFyLnggPSA0LjAgLSB2Lng7XFxcXG5cXFxcdFxcXFx0fSBlbHNlIGlmICggYWJzVi54ID49IGFsbW9zdE9uZSApIHtcXFxcblxcXFx0XFxcXHRcXFxcdGZsb2F0IHNpZ25YID0gc2lnbiggdi54ICk7XFxcXG5cXFxcdFxcXFx0XFxcXHRwbGFuYXIueCA9IHYueiAqIHNpZ25YICsgMi4wICogc2lnblg7XFxcXG5cXFxcdFxcXFx0fSBlbHNlIGlmICggYWJzVi55ID49IGFsbW9zdE9uZSApIHtcXFxcblxcXFx0XFxcXHRcXFxcdGZsb2F0IHNpZ25ZID0gc2lnbiggdi55ICk7XFxcXG5cXFxcdFxcXFx0XFxcXHRwbGFuYXIueCA9IHYueCArIDIuMCAqIHNpZ25ZICsgMi4wO1xcXFxuXFxcXHRcXFxcdFxcXFx0cGxhbmFyLnkgPSB2LnogKiBzaWduWSAtIDIuMDtcXFxcblxcXFx0XFxcXHR9XFxcXG5cXFxcdFxcXFx0cmV0dXJuIHZlYzIoIDAuMTI1LCAwLjI1ICkgKiBwbGFuYXIgKyB2ZWMyKCAwLjM3NSwgMC43NSApO1xcXFxuXFxcXHR9XFxcXG5cXFxcdGZsb2F0IGdldFBvaW50U2hhZG93KCBzYW1wbGVyMkQgc2hhZG93TWFwLCB2ZWMyIHNoYWRvd01hcFNpemUsIGZsb2F0IHNoYWRvd0JpYXMsIGZsb2F0IHNoYWRvd1JhZGl1cywgdmVjNCBzaGFkb3dDb29yZCwgZmxvYXQgc2hhZG93Q2FtZXJhTmVhciwgZmxvYXQgc2hhZG93Q2FtZXJhRmFyICkge1xcXFxuXFxcXHRcXFxcdHZlYzIgdGV4ZWxTaXplID0gdmVjMiggMS4wICkgLyAoIHNoYWRvd01hcFNpemUgKiB2ZWMyKCA0LjAsIDIuMCApICk7XFxcXG5cXFxcdFxcXFx0dmVjMyBsaWdodFRvUG9zaXRpb24gPSBzaGFkb3dDb29yZC54eXo7XFxcXG5cXFxcdFxcXFx0ZmxvYXQgZHAgPSAoIGxlbmd0aCggbGlnaHRUb1Bvc2l0aW9uICkgLSBzaGFkb3dDYW1lcmFOZWFyICkgLyAoIHNoYWRvd0NhbWVyYUZhciAtIHNoYWRvd0NhbWVyYU5lYXIgKTtcXFxcdFxcXFx0ZHAgKz0gc2hhZG93QmlhcztcXFxcblxcXFx0XFxcXHR2ZWMzIGJkM0QgPSBub3JtYWxpemUoIGxpZ2h0VG9Qb3NpdGlvbiApO1xcXFxuXFxcXHRcXFxcdCNpZiBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0YgKSB8fCBkZWZpbmVkKCBTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCApXFxcXG5cXFxcdFxcXFx0XFxcXHR2ZWMyIG9mZnNldCA9IHZlYzIoIC0gMSwgMSApICogc2hhZG93UmFkaXVzICogdGV4ZWxTaXplLnk7XFxcXG5cXFxcdFxcXFx0XFxcXHRyZXR1cm4gKFxcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh5eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXl5LCB0ZXhlbFNpemUueSApLCBkcCApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eXgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl5eCwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnh4eSwgdGV4ZWxTaXplLnkgKSwgZHAgKSArXFxcXG5cXFxcdFxcXFx0XFxcXHRcXFxcdHRleHR1cmUyRENvbXBhcmUoIHNoYWRvd01hcCwgY3ViZVRvVVYoIGJkM0QgKyBvZmZzZXQueXh5LCB0ZXhlbFNpemUueSApLCBkcCApICtcXFxcblxcXFx0XFxcXHRcXFxcdFxcXFx0dGV4dHVyZTJEQ29tcGFyZSggc2hhZG93TWFwLCBjdWJlVG9VViggYmQzRCArIG9mZnNldC54eHgsIHRleGVsU2l6ZS55ICksIGRwICkgK1xcXFxuXFxcXHRcXFxcdFxcXFx0XFxcXHR0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNEICsgb2Zmc2V0Lnl4eCwgdGV4ZWxTaXplLnkgKSwgZHAgKVxcXFxuXFxcXHRcXFxcdFxcXFx0KSAqICggMS4wIC8gOS4wICk7XFxcXG5cXFxcdFxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHRcXFxcdHJldHVybiB0ZXh0dXJlMkRDb21wYXJlKCBzaGFkb3dNYXAsIGN1YmVUb1VWKCBiZDNELCB0ZXhlbFNpemUueSApLCBkcCApO1xcXFxuXFxcXHRcXFxcdCNlbmRpZlxcXFxuXFxcXHR9XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIHNoYWRvd21hcF9wYXJzX3ZlcnRleCA9IFxcXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcXFxuXFxcXHQjaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxcXG5cXFxcdFxcXFx0dW5pZm9ybSBtYXQ0IGRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBOVU1fRElSX0xJR0hUUyBdO1xcXFxuXFxcXHRcXFxcdHZhcnlpbmcgdmVjNCB2RGlyZWN0aW9uYWxTaGFkb3dDb29yZFsgTlVNX0RJUl9MSUdIVFMgXTtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpZiBOVU1fU1BPVF9MSUdIVFMgPiAwXFxcXG5cXFxcdFxcXFx0dW5pZm9ybSBtYXQ0IHNwb3RTaGFkb3dNYXRyaXhbIE5VTV9TUE9UX0xJR0hUUyBdO1xcXFxuXFxcXHRcXFxcdHZhcnlpbmcgdmVjNCB2U3BvdFNoYWRvd0Nvb3JkWyBOVU1fU1BPVF9MSUdIVFMgXTtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcXFxuXFxcXHRcXFxcdHVuaWZvcm0gbWF0NCBwb2ludFNoYWRvd01hdHJpeFsgTlVNX1BPSU5UX0xJR0hUUyBdO1xcXFxuXFxcXHRcXFxcdHZhcnlpbmcgdmVjNCB2UG9pbnRTaGFkb3dDb29yZFsgTlVNX1BPSU5UX0xJR0hUUyBdO1xcXFxuXFxcXHQjZW5kaWZcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgc2hhZG93bWFwX3ZlcnRleCA9IFxcXCIjaWZkZWYgVVNFX1NIQURPV01BUFxcXFxuXFxcXHQjaWYgTlVNX0RJUl9MSUdIVFMgPiAwXFxcXG5cXFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcXFxuXFxcXHRcXFxcdHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gPSBkaXJlY3Rpb25hbFNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXFxcblxcXFx0fVxcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXFxcblxcXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcXFxuXFxcXHRcXFxcdHZTcG90U2hhZG93Q29vcmRbIGkgXSA9IHNwb3RTaGFkb3dNYXRyaXhbIGkgXSAqIHdvcmxkUG9zaXRpb247XFxcXG5cXFxcdH1cXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcXFxuXFxcXHRmb3IgKCBpbnQgaSA9IDA7IGkgPCBOVU1fUE9JTlRfTElHSFRTOyBpICsrICkge1xcXFxuXFxcXHRcXFxcdHZQb2ludFNoYWRvd0Nvb3JkWyBpIF0gPSBwb2ludFNoYWRvd01hdHJpeFsgaSBdICogd29ybGRQb3NpdGlvbjtcXFxcblxcXFx0fVxcXFxuXFxcXHQjZW5kaWZcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgc2hhZG93bWFza19wYXJzX2ZyYWdtZW50ID0gXFxcImZsb2F0IGdldFNoYWRvd01hc2soKSB7XFxcXG5cXFxcdGZsb2F0IHNoYWRvdyA9IDEuMDtcXFxcblxcXFx0I2lmZGVmIFVTRV9TSEFET1dNQVBcXFxcblxcXFx0I2lmIE5VTV9ESVJfTElHSFRTID4gMFxcXFxuXFxcXHREaXJlY3Rpb25hbExpZ2h0IGRpcmVjdGlvbmFsTGlnaHQ7XFxcXG5cXFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9ESVJfTElHSFRTOyBpICsrICkge1xcXFxuXFxcXHRcXFxcdGRpcmVjdGlvbmFsTGlnaHQgPSBkaXJlY3Rpb25hbExpZ2h0c1sgaSBdO1xcXFxuXFxcXHRcXFxcdHNoYWRvdyAqPSBib29sKCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvdyApID8gZ2V0U2hhZG93KCBkaXJlY3Rpb25hbFNoYWRvd01hcFsgaSBdLCBkaXJlY3Rpb25hbExpZ2h0LnNoYWRvd01hcFNpemUsIGRpcmVjdGlvbmFsTGlnaHQuc2hhZG93QmlhcywgZGlyZWN0aW9uYWxMaWdodC5zaGFkb3dSYWRpdXMsIHZEaXJlY3Rpb25hbFNoYWRvd0Nvb3JkWyBpIF0gKSA6IDEuMDtcXFxcblxcXFx0fVxcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2lmIE5VTV9TUE9UX0xJR0hUUyA+IDBcXFxcblxcXFx0U3BvdExpZ2h0IHNwb3RMaWdodDtcXFxcblxcXFx0Zm9yICggaW50IGkgPSAwOyBpIDwgTlVNX1NQT1RfTElHSFRTOyBpICsrICkge1xcXFxuXFxcXHRcXFxcdHNwb3RMaWdodCA9IHNwb3RMaWdodHNbIGkgXTtcXFxcblxcXFx0XFxcXHRzaGFkb3cgKj0gYm9vbCggc3BvdExpZ2h0LnNoYWRvdyApID8gZ2V0U2hhZG93KCBzcG90U2hhZG93TWFwWyBpIF0sIHNwb3RMaWdodC5zaGFkb3dNYXBTaXplLCBzcG90TGlnaHQuc2hhZG93Qmlhcywgc3BvdExpZ2h0LnNoYWRvd1JhZGl1cywgdlNwb3RTaGFkb3dDb29yZFsgaSBdICkgOiAxLjA7XFxcXG5cXFxcdH1cXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpZiBOVU1fUE9JTlRfTElHSFRTID4gMFxcXFxuXFxcXHRQb2ludExpZ2h0IHBvaW50TGlnaHQ7XFxcXG5cXFxcdGZvciAoIGludCBpID0gMDsgaSA8IE5VTV9QT0lOVF9MSUdIVFM7IGkgKysgKSB7XFxcXG5cXFxcdFxcXFx0cG9pbnRMaWdodCA9IHBvaW50TGlnaHRzWyBpIF07XFxcXG5cXFxcdFxcXFx0c2hhZG93ICo9IGJvb2woIHBvaW50TGlnaHQuc2hhZG93ICkgPyBnZXRQb2ludFNoYWRvdyggcG9pbnRTaGFkb3dNYXBbIGkgXSwgcG9pbnRMaWdodC5zaGFkb3dNYXBTaXplLCBwb2ludExpZ2h0LnNoYWRvd0JpYXMsIHBvaW50TGlnaHQuc2hhZG93UmFkaXVzLCB2UG9pbnRTaGFkb3dDb29yZFsgaSBdLCBwb2ludExpZ2h0LnNoYWRvd0NhbWVyYU5lYXIsIHBvaW50TGlnaHQuc2hhZG93Q2FtZXJhRmFyICkgOiAxLjA7XFxcXG5cXFxcdH1cXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHRyZXR1cm4gc2hhZG93O1xcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgc2tpbmJhc2VfdmVydGV4ID0gXFxcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXFxcblxcXFx0bWF0NCBib25lTWF0WCA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC54ICk7XFxcXG5cXFxcdG1hdDQgYm9uZU1hdFkgPSBnZXRCb25lTWF0cml4KCBza2luSW5kZXgueSApO1xcXFxuXFxcXHRtYXQ0IGJvbmVNYXRaID0gZ2V0Qm9uZU1hdHJpeCggc2tpbkluZGV4LnogKTtcXFxcblxcXFx0bWF0NCBib25lTWF0VyA9IGdldEJvbmVNYXRyaXgoIHNraW5JbmRleC53ICk7XFxcXG4jZW5kaWZcXFwiO1xcblxcblxcdHZhciBza2lubmluZ19wYXJzX3ZlcnRleCA9IFxcXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxcXG5cXFxcdHVuaWZvcm0gbWF0NCBiaW5kTWF0cml4O1xcXFxuXFxcXHR1bmlmb3JtIG1hdDQgYmluZE1hdHJpeEludmVyc2U7XFxcXG5cXFxcdCNpZmRlZiBCT05FX1RFWFRVUkVcXFxcblxcXFx0XFxcXHR1bmlmb3JtIHNhbXBsZXIyRCBib25lVGV4dHVyZTtcXFxcblxcXFx0XFxcXHR1bmlmb3JtIGludCBib25lVGV4dHVyZVNpemU7XFxcXG5cXFxcdFxcXFx0bWF0NCBnZXRCb25lTWF0cml4KCBjb25zdCBpbiBmbG9hdCBpICkge1xcXFxuXFxcXHRcXFxcdFxcXFx0ZmxvYXQgaiA9IGkgKiA0LjA7XFxcXG5cXFxcdFxcXFx0XFxcXHRmbG9hdCB4ID0gbW9kKCBqLCBmbG9hdCggYm9uZVRleHR1cmVTaXplICkgKTtcXFxcblxcXFx0XFxcXHRcXFxcdGZsb2F0IHkgPSBmbG9vciggaiAvIGZsb2F0KCBib25lVGV4dHVyZVNpemUgKSApO1xcXFxuXFxcXHRcXFxcdFxcXFx0ZmxvYXQgZHggPSAxLjAgLyBmbG9hdCggYm9uZVRleHR1cmVTaXplICk7XFxcXG5cXFxcdFxcXFx0XFxcXHRmbG9hdCBkeSA9IDEuMCAvIGZsb2F0KCBib25lVGV4dHVyZVNpemUgKTtcXFxcblxcXFx0XFxcXHRcXFxcdHkgPSBkeSAqICggeSArIDAuNSApO1xcXFxuXFxcXHRcXFxcdFxcXFx0dmVjNCB2MSA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMC41ICksIHkgKSApO1xcXFxuXFxcXHRcXFxcdFxcXFx0dmVjNCB2MiA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMS41ICksIHkgKSApO1xcXFxuXFxcXHRcXFxcdFxcXFx0dmVjNCB2MyA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMi41ICksIHkgKSApO1xcXFxuXFxcXHRcXFxcdFxcXFx0dmVjNCB2NCA9IHRleHR1cmUyRCggYm9uZVRleHR1cmUsIHZlYzIoIGR4ICogKCB4ICsgMy41ICksIHkgKSApO1xcXFxuXFxcXHRcXFxcdFxcXFx0bWF0NCBib25lID0gbWF0NCggdjEsIHYyLCB2MywgdjQgKTtcXFxcblxcXFx0XFxcXHRcXFxcdHJldHVybiBib25lO1xcXFxuXFxcXHRcXFxcdH1cXFxcblxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHR1bmlmb3JtIG1hdDQgYm9uZU1hdHJpY2VzWyBNQVhfQk9ORVMgXTtcXFxcblxcXFx0XFxcXHRtYXQ0IGdldEJvbmVNYXRyaXgoIGNvbnN0IGluIGZsb2F0IGkgKSB7XFxcXG5cXFxcdFxcXFx0XFxcXHRtYXQ0IGJvbmUgPSBib25lTWF0cmljZXNbIGludChpKSBdO1xcXFxuXFxcXHRcXFxcdFxcXFx0cmV0dXJuIGJvbmU7XFxcXG5cXFxcdFxcXFx0fVxcXFxuXFxcXHQjZW5kaWZcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgc2tpbm5pbmdfdmVydGV4ID0gXFxcIiNpZmRlZiBVU0VfU0tJTk5JTkdcXFxcblxcXFx0dmVjNCBza2luVmVydGV4ID0gYmluZE1hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXFxcblxcXFx0dmVjNCBza2lubmVkID0gdmVjNCggMC4wICk7XFxcXG5cXFxcdHNraW5uZWQgKz0gYm9uZU1hdFggKiBza2luVmVydGV4ICogc2tpbldlaWdodC54O1xcXFxuXFxcXHRza2lubmVkICs9IGJvbmVNYXRZICogc2tpblZlcnRleCAqIHNraW5XZWlnaHQueTtcXFxcblxcXFx0c2tpbm5lZCArPSBib25lTWF0WiAqIHNraW5WZXJ0ZXggKiBza2luV2VpZ2h0Lno7XFxcXG5cXFxcdHNraW5uZWQgKz0gYm9uZU1hdFcgKiBza2luVmVydGV4ICogc2tpbldlaWdodC53O1xcXFxuXFxcXHR0cmFuc2Zvcm1lZCA9ICggYmluZE1hdHJpeEludmVyc2UgKiBza2lubmVkICkueHl6O1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBza2lubm9ybWFsX3ZlcnRleCA9IFxcXCIjaWZkZWYgVVNFX1NLSU5OSU5HXFxcXG5cXFxcdG1hdDQgc2tpbk1hdHJpeCA9IG1hdDQoIDAuMCApO1xcXFxuXFxcXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueCAqIGJvbmVNYXRYO1xcXFxuXFxcXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueSAqIGJvbmVNYXRZO1xcXFxuXFxcXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQueiAqIGJvbmVNYXRaO1xcXFxuXFxcXHRza2luTWF0cml4ICs9IHNraW5XZWlnaHQudyAqIGJvbmVNYXRXO1xcXFxuXFxcXHRza2luTWF0cml4ICA9IGJpbmRNYXRyaXhJbnZlcnNlICogc2tpbk1hdHJpeCAqIGJpbmRNYXRyaXg7XFxcXG5cXFxcdG9iamVjdE5vcm1hbCA9IHZlYzQoIHNraW5NYXRyaXggKiB2ZWM0KCBvYmplY3ROb3JtYWwsIDAuMCApICkueHl6O1xcXFxuI2VuZGlmXFxcXG5cXFwiO1xcblxcblxcdHZhciBzcGVjdWxhcm1hcF9mcmFnbWVudCA9IFxcXCJmbG9hdCBzcGVjdWxhclN0cmVuZ3RoO1xcXFxuI2lmZGVmIFVTRV9TUEVDVUxBUk1BUFxcXFxuXFxcXHR2ZWM0IHRleGVsU3BlY3VsYXIgPSB0ZXh0dXJlMkQoIHNwZWN1bGFyTWFwLCB2VXYgKTtcXFxcblxcXFx0c3BlY3VsYXJTdHJlbmd0aCA9IHRleGVsU3BlY3VsYXIucjtcXFxcbiNlbHNlXFxcXG5cXFxcdHNwZWN1bGFyU3RyZW5ndGggPSAxLjA7XFxcXG4jZW5kaWZcXFwiO1xcblxcblxcdHZhciBzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZmRlZiBVU0VfU1BFQ1VMQVJNQVBcXFxcblxcXFx0dW5pZm9ybSBzYW1wbGVyMkQgc3BlY3VsYXJNYXA7XFxcXG4jZW5kaWZcXFwiO1xcblxcblxcdHZhciB0b25lbWFwcGluZ19mcmFnbWVudCA9IFxcXCIjaWYgZGVmaW5lZCggVE9ORV9NQVBQSU5HIClcXFxcbiAgZ2xfRnJhZ0NvbG9yLnJnYiA9IHRvbmVNYXBwaW5nKCBnbF9GcmFnQ29sb3IucmdiICk7XFxcXG4jZW5kaWZcXFxcblxcXCI7XFxuXFxuXFx0dmFyIHRvbmVtYXBwaW5nX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmbmRlZiBzYXR1cmF0ZVxcXFxuXFxcXHQjZGVmaW5lIHNhdHVyYXRlKGEpIGNsYW1wKCBhLCAwLjAsIDEuMCApXFxcXG4jZW5kaWZcXFxcbnVuaWZvcm0gZmxvYXQgdG9uZU1hcHBpbmdFeHBvc3VyZTtcXFxcbnVuaWZvcm0gZmxvYXQgdG9uZU1hcHBpbmdXaGl0ZVBvaW50O1xcXFxudmVjMyBMaW5lYXJUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXFxcblxcXFx0cmV0dXJuIHRvbmVNYXBwaW5nRXhwb3N1cmUgKiBjb2xvcjtcXFxcbn1cXFxcbnZlYzMgUmVpbmhhcmRUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXFxcblxcXFx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcXFxcblxcXFx0cmV0dXJuIHNhdHVyYXRlKCBjb2xvciAvICggdmVjMyggMS4wICkgKyBjb2xvciApICk7XFxcXG59XFxcXG4jZGVmaW5lIFVuY2hhcnRlZDJIZWxwZXIoIHggKSBtYXgoICggKCB4ICogKCAwLjE1ICogeCArIDAuMTAgKiAwLjUwICkgKyAwLjIwICogMC4wMiApIC8gKCB4ICogKCAwLjE1ICogeCArIDAuNTAgKSArIDAuMjAgKiAwLjMwICkgKSAtIDAuMDIgLyAwLjMwLCB2ZWMzKCAwLjAgKSApXFxcXG52ZWMzIFVuY2hhcnRlZDJUb25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXFxcblxcXFx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcXFxcblxcXFx0cmV0dXJuIHNhdHVyYXRlKCBVbmNoYXJ0ZWQySGVscGVyKCBjb2xvciApIC8gVW5jaGFydGVkMkhlbHBlciggdmVjMyggdG9uZU1hcHBpbmdXaGl0ZVBvaW50ICkgKSApO1xcXFxufVxcXFxudmVjMyBPcHRpbWl6ZWRDaW5lb25Ub25lTWFwcGluZyggdmVjMyBjb2xvciApIHtcXFxcblxcXFx0Y29sb3IgKj0gdG9uZU1hcHBpbmdFeHBvc3VyZTtcXFxcblxcXFx0Y29sb3IgPSBtYXgoIHZlYzMoIDAuMCApLCBjb2xvciAtIDAuMDA0ICk7XFxcXG5cXFxcdHJldHVybiBwb3coICggY29sb3IgKiAoIDYuMiAqIGNvbG9yICsgMC41ICkgKSAvICggY29sb3IgKiAoIDYuMiAqIGNvbG9yICsgMS43ICkgKyAwLjA2ICksIHZlYzMoIDIuMiApICk7XFxcXG59XFxcXG5cXFwiO1xcblxcblxcdHZhciB1dl9wYXJzX2ZyYWdtZW50ID0gXFxcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQICkgfHwgZGVmaW5lZCggVVNFX1JPVUdITkVTU01BUCApIHx8IGRlZmluZWQoIFVTRV9NRVRBTE5FU1NNQVAgKVxcXFxuXFxcXHR2YXJ5aW5nIHZlYzIgdlV2O1xcXFxuI2VuZGlmXFxcIjtcXG5cXG5cXHR2YXIgdXZfcGFyc192ZXJ0ZXggPSBcXFwiI2lmIGRlZmluZWQoIFVTRV9NQVAgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKSB8fCBkZWZpbmVkKCBVU0VfU1BFQ1VMQVJNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQUxQSEFNQVAgKSB8fCBkZWZpbmVkKCBVU0VfRU1JU1NJVkVNQVAgKSB8fCBkZWZpbmVkKCBVU0VfUk9VR0hORVNTTUFQICkgfHwgZGVmaW5lZCggVVNFX01FVEFMTkVTU01BUCApXFxcXG5cXFxcdHZhcnlpbmcgdmVjMiB2VXY7XFxcXG5cXFxcdHVuaWZvcm0gbWF0MyB1dlRyYW5zZm9ybTtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgdXZfdmVydGV4ID0gXFxcIiNpZiBkZWZpbmVkKCBVU0VfTUFQICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQICkgfHwgZGVmaW5lZCggVVNFX1NQRUNVTEFSTUFQICkgfHwgZGVmaW5lZCggVVNFX0FMUEhBTUFQICkgfHwgZGVmaW5lZCggVVNFX0VNSVNTSVZFTUFQICkgfHwgZGVmaW5lZCggVVNFX1JPVUdITkVTU01BUCApIHx8IGRlZmluZWQoIFVTRV9NRVRBTE5FU1NNQVAgKVxcXFxuXFxcXHR2VXYgPSAoIHV2VHJhbnNmb3JtICogdmVjMyggdXYsIDEgKSApLnh5O1xcXFxuI2VuZGlmXFxcIjtcXG5cXG5cXHR2YXIgdXYyX3BhcnNfZnJhZ21lbnQgPSBcXFwiI2lmIGRlZmluZWQoIFVTRV9MSUdIVE1BUCApIHx8IGRlZmluZWQoIFVTRV9BT01BUCApXFxcXG5cXFxcdHZhcnlpbmcgdmVjMiB2VXYyO1xcXFxuI2VuZGlmXFxcIjtcXG5cXG5cXHR2YXIgdXYyX3BhcnNfdmVydGV4ID0gXFxcIiNpZiBkZWZpbmVkKCBVU0VfTElHSFRNQVAgKSB8fCBkZWZpbmVkKCBVU0VfQU9NQVAgKVxcXFxuXFxcXHRhdHRyaWJ1dGUgdmVjMiB1djI7XFxcXG5cXFxcdHZhcnlpbmcgdmVjMiB2VXYyO1xcXFxuI2VuZGlmXFxcIjtcXG5cXG5cXHR2YXIgdXYyX3ZlcnRleCA9IFxcXCIjaWYgZGVmaW5lZCggVVNFX0xJR0hUTUFQICkgfHwgZGVmaW5lZCggVVNFX0FPTUFQIClcXFxcblxcXFx0dlV2MiA9IHV2MjtcXFxcbiNlbmRpZlxcXCI7XFxuXFxuXFx0dmFyIHdvcmxkcG9zX3ZlcnRleCA9IFxcXCIjaWYgZGVmaW5lZCggVVNFX0VOVk1BUCApIHx8IGRlZmluZWQoIERJU1RBTkNFICkgfHwgZGVmaW5lZCAoIFVTRV9TSEFET1dNQVAgKVxcXFxuXFxcXHR2ZWM0IHdvcmxkUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQoIHRyYW5zZm9ybWVkLCAxLjAgKTtcXFxcbiNlbmRpZlxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgY3ViZV9mcmFnID0gXFxcInVuaWZvcm0gc2FtcGxlckN1YmUgdEN1YmU7XFxcXG51bmlmb3JtIGZsb2F0IHRGbGlwO1xcXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcXFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlQ3ViZSggdEN1YmUsIHZlYzMoIHRGbGlwICogdldvcmxkUG9zaXRpb24ueCwgdldvcmxkUG9zaXRpb24ueXogKSApO1xcXFxuXFxcXHRnbF9GcmFnQ29sb3IuYSAqPSBvcGFjaXR5O1xcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgY3ViZV92ZXJ0ID0gXFxcInZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXFxcbiNpbmNsdWRlIDxjb21tb24+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdHZXb3JsZFBvc2l0aW9uID0gdHJhbnNmb3JtRGlyZWN0aW9uKCBwb3NpdGlvbiwgbW9kZWxNYXRyaXggKTtcXFxcblxcXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcXFxuXFxcXHRnbF9Qb3NpdGlvbi56ID0gZ2xfUG9zaXRpb24udztcXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIGRlcHRoX2ZyYWcgPSBcXFwiI2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMFxcXFxuXFxcXHR1bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxcXG4jZW5kaWZcXFxcbiNpbmNsdWRlIDxjb21tb24+XFxcXG4jaW5jbHVkZSA8cGFja2luZz5cXFxcbiNpbmNsdWRlIDx1dl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPG1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGFscGhhbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXFxcblxcXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCAxLjAgKTtcXFxcblxcXFx0I2lmIERFUFRIX1BBQ0tJTkcgPT0gMzIwMFxcXFxuXFxcXHRcXFxcdGRpZmZ1c2VDb2xvci5hID0gb3BhY2l0eTtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcXFxuXFxcXHQjaWYgREVQVEhfUEFDS0lORyA9PSAzMjAwXFxcXG5cXFxcdFxcXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggdmVjMyggZ2xfRnJhZ0Nvb3JkLnogKSwgb3BhY2l0eSApO1xcXFxuXFxcXHQjZWxpZiBERVBUSF9QQUNLSU5HID09IDMyMDFcXFxcblxcXFx0XFxcXHRnbF9GcmFnQ29sb3IgPSBwYWNrRGVwdGhUb1JHQkEoIGdsX0ZyYWdDb29yZC56ICk7XFxcXG5cXFxcdCNlbmRpZlxcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgZGVwdGhfdmVydCA9IFxcXCIjaW5jbHVkZSA8Y29tbW9uPlxcXFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxcXG5cXFxcdCNpZmRlZiBVU0VfRElTUExBQ0VNRU5UTUFQXFxcXG5cXFxcdFxcXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0XFxcXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcXFxuXFxcXHRcXFxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgZGlzdGFuY2VSR0JBX2ZyYWcgPSBcXFwiI2RlZmluZSBESVNUQU5DRVxcXFxudW5pZm9ybSB2ZWMzIHJlZmVyZW5jZVBvc2l0aW9uO1xcXFxudW5pZm9ybSBmbG9hdCBuZWFyRGlzdGFuY2U7XFxcXG51bmlmb3JtIGZsb2F0IGZhckRpc3RhbmNlO1xcXFxudmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcXFxuI2luY2x1ZGUgPGNvbW1vbj5cXFxcbiNpbmNsdWRlIDxwYWNraW5nPlxcXFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXFxcbnZvaWQgbWFpbiAoKSB7XFxcXG5cXFxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxcXG5cXFxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggMS4wICk7XFxcXG5cXFxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXFxcblxcXFx0ZmxvYXQgZGlzdCA9IGxlbmd0aCggdldvcmxkUG9zaXRpb24gLSByZWZlcmVuY2VQb3NpdGlvbiApO1xcXFxuXFxcXHRkaXN0ID0gKCBkaXN0IC0gbmVhckRpc3RhbmNlICkgLyAoIGZhckRpc3RhbmNlIC0gbmVhckRpc3RhbmNlICk7XFxcXG5cXFxcdGRpc3QgPSBzYXR1cmF0ZSggZGlzdCApO1xcXFxuXFxcXHRnbF9GcmFnQ29sb3IgPSBwYWNrRGVwdGhUb1JHQkEoIGRpc3QgKTtcXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIGRpc3RhbmNlUkdCQV92ZXJ0ID0gXFxcIiNkZWZpbmUgRElTVEFOQ0VcXFxcbnZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXFxcbiNpbmNsdWRlIDxjb21tb24+XFxcXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXFxcblxcXFx0I2lmZGVmIFVTRV9ESVNQTEFDRU1FTlRNQVBcXFxcblxcXFx0XFxcXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcXFxuXFxcXHRcXFxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdFxcXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxcXG5cXFxcdHZXb3JsZFBvc2l0aW9uID0gd29ybGRQb3NpdGlvbi54eXo7XFxcXG59XFxcXG5cXFwiO1xcblxcblxcdHZhciBlcXVpcmVjdF9mcmFnID0gXFxcInVuaWZvcm0gc2FtcGxlcjJEIHRFcXVpcmVjdDtcXFxcbnZhcnlpbmcgdmVjMyB2V29ybGRQb3NpdGlvbjtcXFxcbiNpbmNsdWRlIDxjb21tb24+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdHZlYzMgZGlyZWN0aW9uID0gbm9ybWFsaXplKCB2V29ybGRQb3NpdGlvbiApO1xcXFxuXFxcXHR2ZWMyIHNhbXBsZVVWO1xcXFxuXFxcXHRzYW1wbGVVVi55ID0gYXNpbiggY2xhbXAoIGRpcmVjdGlvbi55LCAtIDEuMCwgMS4wICkgKSAqIFJFQ0lQUk9DQUxfUEkgKyAwLjU7XFxcXG5cXFxcdHNhbXBsZVVWLnggPSBhdGFuKCBkaXJlY3Rpb24ueiwgZGlyZWN0aW9uLnggKSAqIFJFQ0lQUk9DQUxfUEkyICsgMC41O1xcXFxuXFxcXHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQoIHRFcXVpcmVjdCwgc2FtcGxlVVYgKTtcXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIGVxdWlyZWN0X3ZlcnQgPSBcXFwidmFyeWluZyB2ZWMzIHZXb3JsZFBvc2l0aW9uO1xcXFxuI2luY2x1ZGUgPGNvbW1vbj5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0dldvcmxkUG9zaXRpb24gPSB0cmFuc2Zvcm1EaXJlY3Rpb24oIHBvc2l0aW9uLCBtb2RlbE1hdHJpeCApO1xcXFxuXFxcXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxcXG59XFxcXG5cXFwiO1xcblxcblxcdHZhciBsaW5lZGFzaGVkX2ZyYWcgPSBcXFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxcXG51bmlmb3JtIGZsb2F0IGRhc2hTaXplO1xcXFxudW5pZm9ybSBmbG9hdCB0b3RhbFNpemU7XFxcXG52YXJ5aW5nIGZsb2F0IHZMaW5lRGlzdGFuY2U7XFxcXG4jaW5jbHVkZSA8Y29tbW9uPlxcXFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXFxcblxcXFx0aWYgKCBtb2QoIHZMaW5lRGlzdGFuY2UsIHRvdGFsU2l6ZSApID4gZGFzaFNpemUgKSB7XFxcXG5cXFxcdFxcXFx0ZGlzY2FyZDtcXFxcblxcXFx0fVxcXFxuXFxcXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXFxcblxcXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxcXG5cXFxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcXFxuXFxcXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcXFxcblxcXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcXFxcblxcXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIGxpbmVkYXNoZWRfdmVydCA9IFxcXCJ1bmlmb3JtIGZsb2F0IHNjYWxlO1xcXFxuYXR0cmlidXRlIGZsb2F0IGxpbmVEaXN0YW5jZTtcXFxcbnZhcnlpbmcgZmxvYXQgdkxpbmVEaXN0YW5jZTtcXFxcbiNpbmNsdWRlIDxjb21tb24+XFxcXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXFxcblxcXFx0dkxpbmVEaXN0YW5jZSA9IHNjYWxlICogbGluZURpc3RhbmNlO1xcXFxuXFxcXHR2ZWM0IG12UG9zaXRpb24gPSBtb2RlbFZpZXdNYXRyaXggKiB2ZWM0KCBwb3NpdGlvbiwgMS4wICk7XFxcXG5cXFxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247XFxcXG5cXFxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIG1lc2hiYXNpY19mcmFnID0gXFxcInVuaWZvcm0gdmVjMyBkaWZmdXNlO1xcXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcXFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcXFxuXFxcXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXFxcbiNlbmRpZlxcXFxuI2luY2x1ZGUgPGNvbW1vbj5cXFxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8Zm9nX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcXFxuXFxcXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXFxcblxcXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxcXFxuXFxcXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xcXFxuXFxcXHQjaWZkZWYgVVNFX0xJR0hUTUFQXFxcXG5cXFxcdFxcXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICs9IHRleHR1cmUyRCggbGlnaHRNYXAsIHZVdjIgKS54eXogKiBsaWdodE1hcEludGVuc2l0eTtcXFxcblxcXFx0I2Vsc2VcXFxcblxcXFx0XFxcXHRyZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2UgKz0gdmVjMyggMS4wICk7XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaW5jbHVkZSA8YW9tYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSAqPSBkaWZmdXNlQ29sb3IucmdiO1xcXFxuXFxcXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdERpZmZ1c2U7XFxcXG5cXFxcdCNpbmNsdWRlIDxlbnZtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIG91dGdvaW5nTGlnaHQsIGRpZmZ1c2VDb2xvci5hICk7XFxcXG5cXFxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxcXG59XFxcXG5cXFwiO1xcblxcblxcdHZhciBtZXNoYmFzaWNfdmVydCA9IFxcXCIjaW5jbHVkZSA8Y29tbW9uPlxcXFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxcXG5cXFxcdCNpZmRlZiBVU0VfRU5WTUFQXFxcXG5cXFxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcXFxuXFxcXHQjZW5kaWZcXFxcblxcXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGVudm1hcF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxmb2dfdmVydGV4PlxcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbWVzaGxhbWJlcnRfZnJhZyA9IFxcXCJ1bmlmb3JtIHZlYzMgZGlmZnVzZTtcXFxcbnVuaWZvcm0gdmVjMyBlbWlzc2l2ZTtcXFxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXFxcbnZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcXFxcbiNpZmRlZiBET1VCTEVfU0lERURcXFxcblxcXFx0dmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XFxcXG4jZW5kaWZcXFxcbiNpbmNsdWRlIDxjb21tb24+XFxcXG4jaW5jbHVkZSA8cGFja2luZz5cXFxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxic2Rmcz5cXFxcbiNpbmNsdWRlIDxsaWdodHNfcGFycz5cXFxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8c3BlY3VsYXJtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcXFxuXFxcXHR2ZWM0IGRpZmZ1c2VDb2xvciA9IHZlYzQoIGRpZmZ1c2UsIG9wYWNpdHkgKTtcXFxcblxcXFx0UmVmbGVjdGVkTGlnaHQgcmVmbGVjdGVkTGlnaHQgPSBSZWZsZWN0ZWRMaWdodCggdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICkgKTtcXFxcblxcXFx0dmVjMyB0b3RhbEVtaXNzaXZlUmFkaWFuY2UgPSBlbWlzc2l2ZTtcXFxcblxcXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8bWFwX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8Y29sb3JfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxhbHBoYW1hcF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGFscGhhdGVzdF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPHNwZWN1bGFybWFwX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZW1pc3NpdmVtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdHJlZmxlY3RlZExpZ2h0LmluZGlyZWN0RGlmZnVzZSA9IGdldEFtYmllbnRMaWdodElycmFkaWFuY2UoIGFtYmllbnRMaWdodENvbG9yICk7XFxcXG5cXFxcdCNpbmNsdWRlIDxsaWdodG1hcF9mcmFnbWVudD5cXFxcblxcXFx0cmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICo9IEJSREZfRGlmZnVzZV9MYW1iZXJ0KCBkaWZmdXNlQ29sb3IucmdiICk7XFxcXG5cXFxcdCNpZmRlZiBET1VCTEVfU0lERURcXFxcblxcXFx0XFxcXHRyZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlID0gKCBnbF9Gcm9udEZhY2luZyApID8gdkxpZ2h0RnJvbnQgOiB2TGlnaHRCYWNrO1xcXFxuXFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgPSB2TGlnaHRGcm9udDtcXFxcblxcXFx0I2VuZGlmXFxcXG5cXFxcdHJlZmxlY3RlZExpZ2h0LmRpcmVjdERpZmZ1c2UgKj0gQlJERl9EaWZmdXNlX0xhbWJlcnQoIGRpZmZ1c2VDb2xvci5yZ2IgKSAqIGdldFNoYWRvd01hc2soKTtcXFxcblxcXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcXFxuXFxcXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlO1xcXFxuXFxcXHQjaW5jbHVkZSA8ZW52bWFwX2ZyYWdtZW50PlxcXFxuXFxcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcXFxuXFxcXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50PlxcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbWVzaGxhbWJlcnRfdmVydCA9IFxcXCIjZGVmaW5lIExBTUJFUlRcXFxcbnZhcnlpbmcgdmVjMyB2TGlnaHRGcm9udDtcXFxcbiNpZmRlZiBET1VCTEVfU0lERURcXFxcblxcXFx0dmFyeWluZyB2ZWMzIHZMaWdodEJhY2s7XFxcXG4jZW5kaWZcXFxcbiNpbmNsdWRlIDxjb21tb24+XFxcXG4jaW5jbHVkZSA8dXZfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8dXYyX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxic2Rmcz5cXFxcbiNpbmNsdWRlIDxsaWdodHNfcGFycz5cXFxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxmb2dfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8c2hhZG93bWFwX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleD5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0I2luY2x1ZGUgPHV2X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHV2Ml92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxjb2xvcl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGxpZ2h0c19sYW1iZXJ0X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxmb2dfdmVydGV4PlxcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbWVzaHBob25nX2ZyYWcgPSBcXFwiI2RlZmluZSBQSE9OR1xcXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxcXG51bmlmb3JtIHZlYzMgc3BlY3VsYXI7XFxcXG51bmlmb3JtIGZsb2F0IHNoaW5pbmVzcztcXFxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXFxcbiNpbmNsdWRlIDxjb21tb24+XFxcXG4jaW5jbHVkZSA8cGFja2luZz5cXFxcbiNpbmNsdWRlIDxkaXRoZXJpbmdfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxjb2xvcl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPHV2X3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8dXYyX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8YWxwaGFtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxhb21hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGxpZ2h0bWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8ZW1pc3NpdmVtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxlbnZtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGJzZGZzPlxcXFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzPlxcXFxuI2luY2x1ZGUgPGxpZ2h0c19waG9uZ19wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGJ1bXBtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxub3JtYWxtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdCNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQ+XFxcXG5cXFxcdHZlYzQgZGlmZnVzZUNvbG9yID0gdmVjNCggZGlmZnVzZSwgb3BhY2l0eSApO1xcXFxuXFxcXHRSZWZsZWN0ZWRMaWdodCByZWZsZWN0ZWRMaWdodCA9IFJlZmxlY3RlZExpZ2h0KCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSApO1xcXFxuXFxcXHR2ZWMzIHRvdGFsRW1pc3NpdmVSYWRpYW5jZSA9IGVtaXNzaXZlO1xcXFxuXFxcXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxjb2xvcl9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGFscGhhbWFwX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8c3BlY3VsYXJtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGxpZ2h0c19waG9uZ19mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGxpZ2h0c190ZW1wbGF0ZT5cXFxcblxcXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcXFxuXFxcXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlO1xcXFxuXFxcXHQjaW5jbHVkZSA8ZW52bWFwX2ZyYWdtZW50PlxcXFxuXFxcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcXFxuXFxcXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50PlxcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbWVzaHBob25nX3ZlcnQgPSBcXFwiI2RlZmluZSBQSE9OR1xcXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxcXG5cXFxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcXFxuI2VuZGlmXFxcXG4jaW5jbHVkZSA8Y29tbW9uPlxcXFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8ZW52bWFwX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxtb3JwaHRhcmdldF9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxza2lubmluZ19wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHQjaW5jbHVkZSA8dXZfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8dXYyX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGNvbG9yX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGJlZ2lubm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPG1vcnBobm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNraW5iYXNlX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNraW5ub3JtYWxfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZGVmYXVsdG5vcm1hbF92ZXJ0ZXg+XFxcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxcXG5cXFxcdHZOb3JtYWwgPSBub3JtYWxpemUoIHRyYW5zZm9ybWVkTm9ybWFsICk7XFxcXG4jZW5kaWZcXFxcblxcXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPG1vcnBodGFyZ2V0X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNraW5uaW5nX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGRpc3BsYWNlbWVudG1hcF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxwcm9qZWN0X3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg+XFxcXG5cXFxcdHZWaWV3UG9zaXRpb24gPSAtIG12UG9zaXRpb24ueHl6O1xcXFxuXFxcXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZW52bWFwX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxmb2dfdmVydGV4PlxcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbWVzaHBoeXNpY2FsX2ZyYWcgPSBcXFwiI2RlZmluZSBQSFlTSUNBTFxcXFxudW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxcXG51bmlmb3JtIHZlYzMgZW1pc3NpdmU7XFxcXG51bmlmb3JtIGZsb2F0IHJvdWdobmVzcztcXFxcbnVuaWZvcm0gZmxvYXQgbWV0YWxuZXNzO1xcXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcXFxuI2lmbmRlZiBTVEFOREFSRFxcXFxuXFxcXHR1bmlmb3JtIGZsb2F0IGNsZWFyQ29hdDtcXFxcblxcXFx0dW5pZm9ybSBmbG9hdCBjbGVhckNvYXRSb3VnaG5lc3M7XFxcXG4jZW5kaWZcXFxcbnZhcnlpbmcgdmVjMyB2Vmlld1Bvc2l0aW9uO1xcXFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcXFxuXFxcXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXFxcbiNlbmRpZlxcXFxuI2luY2x1ZGUgPGNvbW1vbj5cXFxcbiNpbmNsdWRlIDxwYWNraW5nPlxcXFxuI2luY2x1ZGUgPGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDx1djJfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxhbHBoYW1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGFvbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bGlnaHRtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGVudm1hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGJzZGZzPlxcXFxuI2luY2x1ZGUgPGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxsaWdodHNfcGFycz5cXFxcbiNpbmNsdWRlIDxsaWdodHNfcGh5c2ljYWxfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8cm91Z2huZXNzbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bWV0YWxuZXNzbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc19mcmFnbWVudD5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0I2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19mcmFnbWVudD5cXFxcblxcXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxcXG5cXFxcdFJlZmxlY3RlZExpZ2h0IHJlZmxlY3RlZExpZ2h0ID0gUmVmbGVjdGVkTGlnaHQoIHZlYzMoIDAuMCApLCB2ZWMzKCAwLjAgKSwgdmVjMyggMC4wICksIHZlYzMoIDAuMCApICk7XFxcXG5cXFxcdHZlYzMgdG90YWxFbWlzc2l2ZVJhZGlhbmNlID0gZW1pc3NpdmU7XFxcXG5cXFxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPG1hcF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8YWxwaGFtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxhbHBoYXRlc3RfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxyb3VnaG5lc3NtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxtZXRhbG5lc3NtYXBfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxub3JtYWxfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxlbWlzc2l2ZW1hcF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGxpZ2h0c19waHlzaWNhbF9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGxpZ2h0c190ZW1wbGF0ZT5cXFxcblxcXFx0I2luY2x1ZGUgPGFvbWFwX2ZyYWdtZW50PlxcXFxuXFxcXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSByZWZsZWN0ZWRMaWdodC5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuaW5kaXJlY3REaWZmdXNlICsgcmVmbGVjdGVkTGlnaHQuZGlyZWN0U3BlY3VsYXIgKyByZWZsZWN0ZWRMaWdodC5pbmRpcmVjdFNwZWN1bGFyICsgdG90YWxFbWlzc2l2ZVJhZGlhbmNlO1xcXFxuXFxcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBvdXRnb2luZ0xpZ2h0LCBkaWZmdXNlQ29sb3IuYSApO1xcXFxuXFxcXHQjaW5jbHVkZSA8dG9uZW1hcHBpbmdfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxlbmNvZGluZ3NfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDxwcmVtdWx0aXBsaWVkX2FscGhhX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZGl0aGVyaW5nX2ZyYWdtZW50PlxcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgbWVzaHBoeXNpY2FsX3ZlcnQgPSBcXFwiI2RlZmluZSBQSFlTSUNBTFxcXFxudmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxcXG4jaWZuZGVmIEZMQVRfU0hBREVEXFxcXG5cXFxcdHZhcnlpbmcgdmVjMyB2Tm9ybWFsO1xcXFxuI2VuZGlmXFxcXG4jaW5jbHVkZSA8Y29tbW9uPlxcXFxuI2luY2x1ZGUgPHV2X3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPHV2Ml9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8Y29sb3JfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPG1vcnBodGFyZ2V0X3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPHNraW5uaW5nX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxjbGlwcGluZ19wbGFuZXNfcGFyc192ZXJ0ZXg+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDx1djJfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8YmVnaW5ub3JtYWxfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8bW9ycGhub3JtYWxfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2tpbmJhc2VfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2tpbm5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxkZWZhdWx0bm9ybWFsX3ZlcnRleD5cXFxcbiNpZm5kZWYgRkxBVF9TSEFERURcXFxcblxcXFx0dk5vcm1hbCA9IG5vcm1hbGl6ZSggdHJhbnNmb3JtZWROb3JtYWwgKTtcXFxcbiNlbmRpZlxcXFxuXFxcXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8bW9ycGh0YXJnZXRfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2tpbm5pbmdfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8ZGlzcGxhY2VtZW50bWFwX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXFxcblxcXFx0dlZpZXdQb3NpdGlvbiA9IC0gbXZQb3NpdGlvbi54eXo7XFxcXG5cXFxcdCNpbmNsdWRlIDx3b3JsZHBvc192ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxzaGFkb3dtYXBfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8Zm9nX3ZlcnRleD5cXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIG5vcm1hbF9mcmFnID0gXFxcIiNkZWZpbmUgTk9STUFMXFxcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxcXG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKVxcXFxuXFxcXHR2YXJ5aW5nIHZlYzMgdlZpZXdQb3NpdGlvbjtcXFxcbiNlbmRpZlxcXFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcXFxuXFxcXHR2YXJ5aW5nIHZlYzMgdk5vcm1hbDtcXFxcbiNlbmRpZlxcXFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxcXG4jaW5jbHVkZSA8dXZfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxidW1wbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ+XFxcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc19mcmFnbWVudD5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0I2luY2x1ZGUgPGxvZ2RlcHRoYnVmX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8bm9ybWFsX2ZyYWdtZW50PlxcXFxuXFxcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCBwYWNrTm9ybWFsVG9SR0IoIG5vcm1hbCApLCBvcGFjaXR5ICk7XFxcXG59XFxcXG5cXFwiO1xcblxcblxcdHZhciBub3JtYWxfdmVydCA9IFxcXCIjZGVmaW5lIE5PUk1BTFxcXFxuI2lmIGRlZmluZWQoIEZMQVRfU0hBREVEICkgfHwgZGVmaW5lZCggVVNFX0JVTVBNQVAgKSB8fCBkZWZpbmVkKCBVU0VfTk9STUFMTUFQIClcXFxcblxcXFx0dmFyeWluZyB2ZWMzIHZWaWV3UG9zaXRpb247XFxcXG4jZW5kaWZcXFxcbiNpZm5kZWYgRkxBVF9TSEFERURcXFxcblxcXFx0dmFyeWluZyB2ZWMzIHZOb3JtYWw7XFxcXG4jZW5kaWZcXFxcbiNpbmNsdWRlIDx1dl9wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8bW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8c2tpbm5pbmdfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxcXG52b2lkIG1haW4oKSB7XFxcXG5cXFxcdCNpbmNsdWRlIDx1dl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxiZWdpbm5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxtb3JwaG5vcm1hbF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxza2luYmFzZV92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxza2lubm9ybWFsX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGRlZmF1bHRub3JtYWxfdmVydGV4PlxcXFxuI2lmbmRlZiBGTEFUX1NIQURFRFxcXFxuXFxcXHR2Tm9ybWFsID0gbm9ybWFsaXplKCB0cmFuc2Zvcm1lZE5vcm1hbCApO1xcXFxuI2VuZGlmXFxcXG5cXFxcdCNpbmNsdWRlIDxiZWdpbl92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxtb3JwaHRhcmdldF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxza2lubmluZ192ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxkaXNwbGFjZW1lbnRtYXBfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl92ZXJ0ZXg+XFxcXG4jaWYgZGVmaW5lZCggRkxBVF9TSEFERUQgKSB8fCBkZWZpbmVkKCBVU0VfQlVNUE1BUCApIHx8IGRlZmluZWQoIFVTRV9OT1JNQUxNQVAgKVxcXFxuXFxcXHR2Vmlld1Bvc2l0aW9uID0gLSBtdlBvc2l0aW9uLnh5ejtcXFxcbiNlbmRpZlxcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgcG9pbnRzX2ZyYWcgPSBcXFwidW5pZm9ybSB2ZWMzIGRpZmZ1c2U7XFxcXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxcXG4jaW5jbHVkZSA8Y29tbW9uPlxcXFxuI2luY2x1ZGUgPHBhY2tpbmc+XFxcXG4jaW5jbHVkZSA8Y29sb3JfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxtYXBfcGFydGljbGVfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxmb2dfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc19mcmFnbWVudD5cXFxcbiNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50PlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50PlxcXFxuXFxcXHR2ZWMzIG91dGdvaW5nTGlnaHQgPSB2ZWMzKCAwLjAgKTtcXFxcblxcXFx0dmVjNCBkaWZmdXNlQ29sb3IgPSB2ZWM0KCBkaWZmdXNlLCBvcGFjaXR5ICk7XFxcXG5cXFxcdCNpbmNsdWRlIDxsb2dkZXB0aGJ1Zl9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPG1hcF9wYXJ0aWNsZV9mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGNvbG9yX2ZyYWdtZW50PlxcXFxuXFxcXHQjaW5jbHVkZSA8YWxwaGF0ZXN0X2ZyYWdtZW50PlxcXFxuXFxcXHRvdXRnb2luZ0xpZ2h0ID0gZGlmZnVzZUNvbG9yLnJnYjtcXFxcblxcXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggb3V0Z29pbmdMaWdodCwgZGlmZnVzZUNvbG9yLmEgKTtcXFxcblxcXFx0I2luY2x1ZGUgPHByZW11bHRpcGxpZWRfYWxwaGFfZnJhZ21lbnQ+XFxcXG5cXFxcdCNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGVuY29kaW5nc19mcmFnbWVudD5cXFxcblxcXFx0I2luY2x1ZGUgPGZvZ19mcmFnbWVudD5cXFxcbn1cXFxcblxcXCI7XFxuXFxuXFx0dmFyIHBvaW50c192ZXJ0ID0gXFxcInVuaWZvcm0gZmxvYXQgc2l6ZTtcXFxcbnVuaWZvcm0gZmxvYXQgc2NhbGU7XFxcXG4jaW5jbHVkZSA8Y29tbW9uPlxcXFxuI2luY2x1ZGUgPGNvbG9yX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPGZvZ19wYXJzX3ZlcnRleD5cXFxcbiNpbmNsdWRlIDxzaGFkb3dtYXBfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8bG9nZGVwdGhidWZfcGFyc192ZXJ0ZXg+XFxcXG4jaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4PlxcXFxudm9pZCBtYWluKCkge1xcXFxuXFxcXHQjaW5jbHVkZSA8Y29sb3JfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8YmVnaW5fdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8cHJvamVjdF92ZXJ0ZXg+XFxcXG5cXFxcdCNpZmRlZiBVU0VfU0laRUFUVEVOVUFUSU9OXFxcXG5cXFxcdFxcXFx0Z2xfUG9pbnRTaXplID0gc2l6ZSAqICggc2NhbGUgLyAtIG12UG9zaXRpb24ueiApO1xcXFxuXFxcXHQjZWxzZVxcXFxuXFxcXHRcXFxcdGdsX1BvaW50U2l6ZSA9IHNpemU7XFxcXG5cXFxcdCNlbmRpZlxcXFxuXFxcXHQjaW5jbHVkZSA8bG9nZGVwdGhidWZfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8Y2xpcHBpbmdfcGxhbmVzX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHdvcmxkcG9zX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHNoYWRvd21hcF92ZXJ0ZXg+XFxcXG5cXFxcdCNpbmNsdWRlIDxmb2dfdmVydGV4PlxcXFxufVxcXFxuXFxcIjtcXG5cXG5cXHR2YXIgc2hhZG93X2ZyYWcgPSBcXFwidW5pZm9ybSB2ZWMzIGNvbG9yO1xcXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcXFxuI2luY2x1ZGUgPGNvbW1vbj5cXFxcbiNpbmNsdWRlIDxwYWNraW5nPlxcXFxuI2luY2x1ZGUgPGZvZ19wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPGJzZGZzPlxcXFxuI2luY2x1ZGUgPGxpZ2h0c19wYXJzPlxcXFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX2ZyYWdtZW50PlxcXFxuI2luY2x1ZGUgPHNoYWRvd21hc2tfcGFyc19mcmFnbWVudD5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggY29sb3IsIG9wYWNpdHkgKiAoIDEuMCAtIGdldFNoYWRvd01hc2soKSApICk7XFxcXG5cXFxcdCNpbmNsdWRlIDxmb2dfZnJhZ21lbnQ+XFxcXG59XFxcXG5cXFwiO1xcblxcblxcdHZhciBzaGFkb3dfdmVydCA9IFxcXCIjaW5jbHVkZSA8Zm9nX3BhcnNfdmVydGV4PlxcXFxuI2luY2x1ZGUgPHNoYWRvd21hcF9wYXJzX3ZlcnRleD5cXFxcbnZvaWQgbWFpbigpIHtcXFxcblxcXFx0I2luY2x1ZGUgPGJlZ2luX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPHByb2plY3RfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8d29ybGRwb3NfdmVydGV4PlxcXFxuXFxcXHQjaW5jbHVkZSA8c2hhZG93bWFwX3ZlcnRleD5cXFxcblxcXFx0I2luY2x1ZGUgPGZvZ192ZXJ0ZXg+XFxcXG59XFxcXG5cXFwiO1xcblxcblxcdHZhciBTaGFkZXJDaHVuayA9IHtcXG5cXHRcXHRhbHBoYW1hcF9mcmFnbWVudDogYWxwaGFtYXBfZnJhZ21lbnQsXFxuXFx0XFx0YWxwaGFtYXBfcGFyc19mcmFnbWVudDogYWxwaGFtYXBfcGFyc19mcmFnbWVudCxcXG5cXHRcXHRhbHBoYXRlc3RfZnJhZ21lbnQ6IGFscGhhdGVzdF9mcmFnbWVudCxcXG5cXHRcXHRhb21hcF9mcmFnbWVudDogYW9tYXBfZnJhZ21lbnQsXFxuXFx0XFx0YW9tYXBfcGFyc19mcmFnbWVudDogYW9tYXBfcGFyc19mcmFnbWVudCxcXG5cXHRcXHRiZWdpbl92ZXJ0ZXg6IGJlZ2luX3ZlcnRleCxcXG5cXHRcXHRiZWdpbm5vcm1hbF92ZXJ0ZXg6IGJlZ2lubm9ybWFsX3ZlcnRleCxcXG5cXHRcXHRic2RmczogYnNkZnMsXFxuXFx0XFx0YnVtcG1hcF9wYXJzX2ZyYWdtZW50OiBidW1wbWFwX3BhcnNfZnJhZ21lbnQsXFxuXFx0XFx0Y2xpcHBpbmdfcGxhbmVzX2ZyYWdtZW50OiBjbGlwcGluZ19wbGFuZXNfZnJhZ21lbnQsXFxuXFx0XFx0Y2xpcHBpbmdfcGxhbmVzX3BhcnNfZnJhZ21lbnQ6IGNsaXBwaW5nX3BsYW5lc19wYXJzX2ZyYWdtZW50LFxcblxcdFxcdGNsaXBwaW5nX3BsYW5lc19wYXJzX3ZlcnRleDogY2xpcHBpbmdfcGxhbmVzX3BhcnNfdmVydGV4LFxcblxcdFxcdGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXg6IGNsaXBwaW5nX3BsYW5lc192ZXJ0ZXgsXFxuXFx0XFx0Y29sb3JfZnJhZ21lbnQ6IGNvbG9yX2ZyYWdtZW50LFxcblxcdFxcdGNvbG9yX3BhcnNfZnJhZ21lbnQ6IGNvbG9yX3BhcnNfZnJhZ21lbnQsXFxuXFx0XFx0Y29sb3JfcGFyc192ZXJ0ZXg6IGNvbG9yX3BhcnNfdmVydGV4LFxcblxcdFxcdGNvbG9yX3ZlcnRleDogY29sb3JfdmVydGV4LFxcblxcdFxcdGNvbW1vbjogY29tbW9uLFxcblxcdFxcdGN1YmVfdXZfcmVmbGVjdGlvbl9mcmFnbWVudDogY3ViZV91dl9yZWZsZWN0aW9uX2ZyYWdtZW50LFxcblxcdFxcdGRlZmF1bHRub3JtYWxfdmVydGV4OiBkZWZhdWx0bm9ybWFsX3ZlcnRleCxcXG5cXHRcXHRkaXNwbGFjZW1lbnRtYXBfcGFyc192ZXJ0ZXg6IGRpc3BsYWNlbWVudG1hcF9wYXJzX3ZlcnRleCxcXG5cXHRcXHRkaXNwbGFjZW1lbnRtYXBfdmVydGV4OiBkaXNwbGFjZW1lbnRtYXBfdmVydGV4LFxcblxcdFxcdGVtaXNzaXZlbWFwX2ZyYWdtZW50OiBlbWlzc2l2ZW1hcF9mcmFnbWVudCxcXG5cXHRcXHRlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50OiBlbWlzc2l2ZW1hcF9wYXJzX2ZyYWdtZW50LFxcblxcdFxcdGVuY29kaW5nc19mcmFnbWVudDogZW5jb2RpbmdzX2ZyYWdtZW50LFxcblxcdFxcdGVuY29kaW5nc19wYXJzX2ZyYWdtZW50OiBlbmNvZGluZ3NfcGFyc19mcmFnbWVudCxcXG5cXHRcXHRlbnZtYXBfZnJhZ21lbnQ6IGVudm1hcF9mcmFnbWVudCxcXG5cXHRcXHRlbnZtYXBfcGFyc19mcmFnbWVudDogZW52bWFwX3BhcnNfZnJhZ21lbnQsXFxuXFx0XFx0ZW52bWFwX3BhcnNfdmVydGV4OiBlbnZtYXBfcGFyc192ZXJ0ZXgsXFxuXFx0XFx0ZW52bWFwX3ZlcnRleDogZW52bWFwX3ZlcnRleCxcXG5cXHRcXHRmb2dfdmVydGV4OiBmb2dfdmVydGV4LFxcblxcdFxcdGZvZ19wYXJzX3ZlcnRleDogZm9nX3BhcnNfdmVydGV4LFxcblxcdFxcdGZvZ19mcmFnbWVudDogZm9nX2ZyYWdtZW50LFxcblxcdFxcdGZvZ19wYXJzX2ZyYWdtZW50OiBmb2dfcGFyc19mcmFnbWVudCxcXG5cXHRcXHRncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50OiBncmFkaWVudG1hcF9wYXJzX2ZyYWdtZW50LFxcblxcdFxcdGxpZ2h0bWFwX2ZyYWdtZW50OiBsaWdodG1hcF9mcmFnbWVudCxcXG5cXHRcXHRsaWdodG1hcF9wYXJzX2ZyYWdtZW50OiBsaWdodG1hcF9wYXJzX2ZyYWdtZW50LFxcblxcdFxcdGxpZ2h0c19sYW1iZXJ0X3ZlcnRleDogbGlnaHRzX2xhbWJlcnRfdmVydGV4LFxcblxcdFxcdGxpZ2h0c19wYXJzOiBsaWdodHNfcGFycyxcXG5cXHRcXHRsaWdodHNfcGhvbmdfZnJhZ21lbnQ6IGxpZ2h0c19waG9uZ19mcmFnbWVudCxcXG5cXHRcXHRsaWdodHNfcGhvbmdfcGFyc19mcmFnbWVudDogbGlnaHRzX3Bob25nX3BhcnNfZnJhZ21lbnQsXFxuXFx0XFx0bGlnaHRzX3BoeXNpY2FsX2ZyYWdtZW50OiBsaWdodHNfcGh5c2ljYWxfZnJhZ21lbnQsXFxuXFx0XFx0bGlnaHRzX3BoeXNpY2FsX3BhcnNfZnJhZ21lbnQ6IGxpZ2h0c19waHlzaWNhbF9wYXJzX2ZyYWdtZW50LFxcblxcdFxcdGxpZ2h0c190ZW1wbGF0ZTogbGlnaHRzX3RlbXBsYXRlLFxcblxcdFxcdGxvZ2RlcHRoYnVmX2ZyYWdtZW50OiBsb2dkZXB0aGJ1Zl9mcmFnbWVudCxcXG5cXHRcXHRsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50OiBsb2dkZXB0aGJ1Zl9wYXJzX2ZyYWdtZW50LFxcblxcdFxcdGxvZ2RlcHRoYnVmX3BhcnNfdmVydGV4OiBsb2dkZXB0aGJ1Zl9wYXJzX3ZlcnRleCxcXG5cXHRcXHRsb2dkZXB0aGJ1Zl92ZXJ0ZXg6IGxvZ2RlcHRoYnVmX3ZlcnRleCxcXG5cXHRcXHRtYXBfZnJhZ21lbnQ6IG1hcF9mcmFnbWVudCxcXG5cXHRcXHRtYXBfcGFyc19mcmFnbWVudDogbWFwX3BhcnNfZnJhZ21lbnQsXFxuXFx0XFx0bWFwX3BhcnRpY2xlX2ZyYWdtZW50OiBtYXBfcGFydGljbGVfZnJhZ21lbnQsXFxuXFx0XFx0bWFwX3BhcnRpY2xlX3BhcnNfZnJhZ21lbnQ6IG1hcF9wYXJ0aWNsZV9wYXJzX2ZyYWdtZW50LFxcblxcdFxcdG1ldGFsbmVzc21hcF9mcmFnbWVudDogbWV0YWxuZXNzbWFwX2ZyYWdtZW50LFxcblxcdFxcdG1ldGFsbmVzc21hcF9wYXJzX2ZyYWdtZW50OiBtZXRhbG5lc3NtYXBfcGFyc19mcmFnbWVudCxcXG5cXHRcXHRtb3JwaG5vcm1hbF92ZXJ0ZXg6IG1vcnBobm9ybWFsX3ZlcnRleCxcXG5cXHRcXHRtb3JwaHRhcmdldF9wYXJzX3ZlcnRleDogbW9ycGh0YXJnZXRfcGFyc192ZXJ0ZXgsXFxuXFx0XFx0bW9ycGh0YXJnZXRfdmVydGV4OiBtb3JwaHRhcmdldF92ZXJ0ZXgsXFxuXFx0XFx0bm9ybWFsX2ZyYWdtZW50OiBub3JtYWxfZnJhZ21lbnQsXFxuXFx0XFx0bm9ybWFsbWFwX3BhcnNfZnJhZ21lbnQ6IG5vcm1hbG1hcF9wYXJzX2ZyYWdtZW50LFxcblxcdFxcdHBhY2tpbmc6IHBhY2tpbmcsXFxuXFx0XFx0cHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudDogcHJlbXVsdGlwbGllZF9hbHBoYV9mcmFnbWVudCxcXG5cXHRcXHRwcm9qZWN0X3ZlcnRleDogcHJvamVjdF92ZXJ0ZXgsXFxuXFx0XFx0ZGl0aGVyaW5nX2ZyYWdtZW50OiBkaXRoZXJpbmdfZnJhZ21lbnQsXFxuXFx0XFx0ZGl0aGVyaW5nX3BhcnNfZnJhZ21lbnQ6IGRpdGhlcmluZ19wYXJzX2ZyYWdtZW50LFxcblxcdFxcdHJvdWdobmVzc21hcF9mcmFnbWVudDogcm91Z2huZXNzbWFwX2ZyYWdtZW50LFxcblxcdFxcdHJvdWdobmVzc21hcF9wYXJzX2ZyYWdtZW50OiByb3VnaG5lc3NtYXBfcGFyc19mcmFnbWVudCxcXG5cXHRcXHRzaGFkb3dtYXBfcGFyc19mcmFnbWVudDogc2hhZG93bWFwX3BhcnNfZnJhZ21lbnQsXFxuXFx0XFx0c2hhZG93bWFwX3BhcnNfdmVydGV4OiBzaGFkb3dtYXBfcGFyc192ZXJ0ZXgsXFxuXFx0XFx0c2hhZG93bWFwX3ZlcnRleDogc2hhZG93bWFwX3ZlcnRleCxcXG5cXHRcXHRzaGFkb3dtYXNrX3BhcnNfZnJhZ21lbnQ6IHNoYWRvd21hc2tfcGFyc19mcmFnbWVudCxcXG5cXHRcXHRza2luYmFzZV92ZXJ0ZXg6IHNraW5iYXNlX3ZlcnRleCxcXG5cXHRcXHRza2lubmluZ19wYXJzX3ZlcnRleDogc2tpbm5pbmdfcGFyc192ZXJ0ZXgsXFxuXFx0XFx0c2tpbm5pbmdfdmVydGV4OiBza2lubmluZ192ZXJ0ZXgsXFxuXFx0XFx0c2tpbm5vcm1hbF92ZXJ0ZXg6IHNraW5ub3JtYWxfdmVydGV4LFxcblxcdFxcdHNwZWN1bGFybWFwX2ZyYWdtZW50OiBzcGVjdWxhcm1hcF9mcmFnbWVudCxcXG5cXHRcXHRzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50OiBzcGVjdWxhcm1hcF9wYXJzX2ZyYWdtZW50LFxcblxcdFxcdHRvbmVtYXBwaW5nX2ZyYWdtZW50OiB0b25lbWFwcGluZ19mcmFnbWVudCxcXG5cXHRcXHR0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50OiB0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50LFxcblxcdFxcdHV2X3BhcnNfZnJhZ21lbnQ6IHV2X3BhcnNfZnJhZ21lbnQsXFxuXFx0XFx0dXZfcGFyc192ZXJ0ZXg6IHV2X3BhcnNfdmVydGV4LFxcblxcdFxcdHV2X3ZlcnRleDogdXZfdmVydGV4LFxcblxcdFxcdHV2Ml9wYXJzX2ZyYWdtZW50OiB1djJfcGFyc19mcmFnbWVudCxcXG5cXHRcXHR1djJfcGFyc192ZXJ0ZXg6IHV2Ml9wYXJzX3ZlcnRleCxcXG5cXHRcXHR1djJfdmVydGV4OiB1djJfdmVydGV4LFxcblxcdFxcdHdvcmxkcG9zX3ZlcnRleDogd29ybGRwb3NfdmVydGV4LFxcblxcblxcdFxcdGN1YmVfZnJhZzogY3ViZV9mcmFnLFxcblxcdFxcdGN1YmVfdmVydDogY3ViZV92ZXJ0LFxcblxcdFxcdGRlcHRoX2ZyYWc6IGRlcHRoX2ZyYWcsXFxuXFx0XFx0ZGVwdGhfdmVydDogZGVwdGhfdmVydCxcXG5cXHRcXHRkaXN0YW5jZVJHQkFfZnJhZzogZGlzdGFuY2VSR0JBX2ZyYWcsXFxuXFx0XFx0ZGlzdGFuY2VSR0JBX3ZlcnQ6IGRpc3RhbmNlUkdCQV92ZXJ0LFxcblxcdFxcdGVxdWlyZWN0X2ZyYWc6IGVxdWlyZWN0X2ZyYWcsXFxuXFx0XFx0ZXF1aXJlY3RfdmVydDogZXF1aXJlY3RfdmVydCxcXG5cXHRcXHRsaW5lZGFzaGVkX2ZyYWc6IGxpbmVkYXNoZWRfZnJhZyxcXG5cXHRcXHRsaW5lZGFzaGVkX3ZlcnQ6IGxpbmVkYXNoZWRfdmVydCxcXG5cXHRcXHRtZXNoYmFzaWNfZnJhZzogbWVzaGJhc2ljX2ZyYWcsXFxuXFx0XFx0bWVzaGJhc2ljX3ZlcnQ6IG1lc2hiYXNpY192ZXJ0LFxcblxcdFxcdG1lc2hsYW1iZXJ0X2ZyYWc6IG1lc2hsYW1iZXJ0X2ZyYWcsXFxuXFx0XFx0bWVzaGxhbWJlcnRfdmVydDogbWVzaGxhbWJlcnRfdmVydCxcXG5cXHRcXHRtZXNocGhvbmdfZnJhZzogbWVzaHBob25nX2ZyYWcsXFxuXFx0XFx0bWVzaHBob25nX3ZlcnQ6IG1lc2hwaG9uZ192ZXJ0LFxcblxcdFxcdG1lc2hwaHlzaWNhbF9mcmFnOiBtZXNocGh5c2ljYWxfZnJhZyxcXG5cXHRcXHRtZXNocGh5c2ljYWxfdmVydDogbWVzaHBoeXNpY2FsX3ZlcnQsXFxuXFx0XFx0bm9ybWFsX2ZyYWc6IG5vcm1hbF9mcmFnLFxcblxcdFxcdG5vcm1hbF92ZXJ0OiBub3JtYWxfdmVydCxcXG5cXHRcXHRwb2ludHNfZnJhZzogcG9pbnRzX2ZyYWcsXFxuXFx0XFx0cG9pbnRzX3ZlcnQ6IHBvaW50c192ZXJ0LFxcblxcdFxcdHNoYWRvd19mcmFnOiBzaGFkb3dfZnJhZyxcXG5cXHRcXHRzaGFkb3dfdmVydDogc2hhZG93X3ZlcnRcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xcblxcdCAqL1xcblxcblxcdHZhciBTaGFkZXJMaWIgPSB7XFxuXFxuXFx0XFx0YmFzaWM6IHtcXG5cXG5cXHRcXHRcXHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5tZXJnZSggW1xcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmNvbW1vbixcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5zcGVjdWxhcm1hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5lbnZtYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuYW9tYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIubGlnaHRtYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZm9nXFxuXFx0XFx0XFx0XSApLFxcblxcblxcdFxcdFxcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaGJhc2ljX3ZlcnQsXFxuXFx0XFx0XFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hiYXNpY19mcmFnXFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRsYW1iZXJ0OiB7XFxuXFxuXFx0XFx0XFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5jb21tb24sXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuc3BlY3VsYXJtYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZW52bWFwLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmFvbWFwLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmxpZ2h0bWFwLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmVtaXNzaXZlbWFwLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmZvZyxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5saWdodHMsXFxuXFx0XFx0XFx0XFx0e1xcblxcdFxcdFxcdFxcdFxcdGVtaXNzaXZlOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4MDAwMDAwICkgfVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRdICksXFxuXFxuXFx0XFx0XFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobGFtYmVydF92ZXJ0LFxcblxcdFxcdFxcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNobGFtYmVydF9mcmFnXFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwaG9uZzoge1xcblxcblxcdFxcdFxcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuY29tbW9uLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLnNwZWN1bGFybWFwLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmVudm1hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5hb21hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5saWdodG1hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5lbWlzc2l2ZW1hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5idW1wbWFwLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLm5vcm1hbG1hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZ3JhZGllbnRtYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZm9nLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmxpZ2h0cyxcXG5cXHRcXHRcXHRcXHR7XFxuXFx0XFx0XFx0XFx0XFx0ZW1pc3NpdmU6IHsgdmFsdWU6IG5ldyBDb2xvciggMHgwMDAwMDAgKSB9LFxcblxcdFxcdFxcdFxcdFxcdHNwZWN1bGFyOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4MTExMTExICkgfSxcXG5cXHRcXHRcXHRcXHRcXHRzaGluaW5lc3M6IHsgdmFsdWU6IDMwIH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XSApLFxcblxcblxcdFxcdFxcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBob25nX3ZlcnQsXFxuXFx0XFx0XFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaG9uZ19mcmFnXFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzdGFuZGFyZDoge1xcblxcblxcdFxcdFxcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuY29tbW9uLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmVudm1hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5hb21hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5saWdodG1hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5lbWlzc2l2ZW1hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5idW1wbWFwLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLm5vcm1hbG1hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5kaXNwbGFjZW1lbnRtYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIucm91Z2huZXNzbWFwLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLm1ldGFsbmVzc21hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5mb2csXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIubGlnaHRzLFxcblxcdFxcdFxcdFxcdHtcXG5cXHRcXHRcXHRcXHRcXHRlbWlzc2l2ZTogeyB2YWx1ZTogbmV3IENvbG9yKCAweDAwMDAwMCApIH0sXFxuXFx0XFx0XFx0XFx0XFx0cm91Z2huZXNzOiB7IHZhbHVlOiAwLjUgfSxcXG5cXHRcXHRcXHRcXHRcXHRtZXRhbG5lc3M6IHsgdmFsdWU6IDAuNSB9LFxcblxcdFxcdFxcdFxcdFxcdGVudk1hcEludGVuc2l0eTogeyB2YWx1ZTogMSB9IC8vIHRlbXBvcmFyeVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRdICksXFxuXFxuXFx0XFx0XFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGh5c2ljYWxfdmVydCxcXG5cXHRcXHRcXHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubWVzaHBoeXNpY2FsX2ZyYWdcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHBvaW50czoge1xcblxcblxcdFxcdFxcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLm1lcmdlKCBbXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIucG9pbnRzLFxcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmZvZ1xcblxcdFxcdFxcdF0gKSxcXG5cXG5cXHRcXHRcXHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLnBvaW50c192ZXJ0LFxcblxcdFxcdFxcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5wb2ludHNfZnJhZ1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGFzaGVkOiB7XFxuXFxuXFx0XFx0XFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5jb21tb24sXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZm9nLFxcblxcdFxcdFxcdFxcdHtcXG5cXHRcXHRcXHRcXHRcXHRzY2FsZTogeyB2YWx1ZTogMSB9LFxcblxcdFxcdFxcdFxcdFxcdGRhc2hTaXplOiB7IHZhbHVlOiAxIH0sXFxuXFx0XFx0XFx0XFx0XFx0dG90YWxTaXplOiB7IHZhbHVlOiAyIH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XSApLFxcblxcblxcdFxcdFxcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsubGluZWRhc2hlZF92ZXJ0LFxcblxcdFxcdFxcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5saW5lZGFzaGVkX2ZyYWdcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRlcHRoOiB7XFxuXFxuXFx0XFx0XFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5jb21tb24sXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwXFxuXFx0XFx0XFx0XSApLFxcblxcblxcdFxcdFxcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuZGVwdGhfdmVydCxcXG5cXHRcXHRcXHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuZGVwdGhfZnJhZ1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bm9ybWFsOiB7XFxuXFxuXFx0XFx0XFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5jb21tb24sXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuYnVtcG1hcCxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5ub3JtYWxtYXAsXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLFxcblxcdFxcdFxcdFxcdHtcXG5cXHRcXHRcXHRcXHRcXHRvcGFjaXR5OiB7IHZhbHVlOiAxLjAgfVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRdICksXFxuXFxuXFx0XFx0XFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5ub3JtYWxfdmVydCxcXG5cXHRcXHRcXHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsubm9ybWFsX2ZyYWdcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG5cXHRcXHQvL1xcdEN1YmUgbWFwIHNoYWRlclxcblxcdFxcdCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXFxuXFxuXFx0XFx0Y3ViZToge1xcblxcblxcdFxcdFxcdHVuaWZvcm1zOiB7XFxuXFx0XFx0XFx0XFx0dEN1YmU6IHsgdmFsdWU6IG51bGwgfSxcXG5cXHRcXHRcXHRcXHR0RmxpcDogeyB2YWx1ZTogLSAxIH0sXFxuXFx0XFx0XFx0XFx0b3BhY2l0eTogeyB2YWx1ZTogMS4wIH1cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuY3ViZV92ZXJ0LFxcblxcdFxcdFxcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5jdWJlX2ZyYWdcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGVxdWlyZWN0OiB7XFxuXFxuXFx0XFx0XFx0dW5pZm9ybXM6IHtcXG5cXHRcXHRcXHRcXHR0RXF1aXJlY3Q6IHsgdmFsdWU6IG51bGwgfSxcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuZXF1aXJlY3RfdmVydCxcXG5cXHRcXHRcXHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuZXF1aXJlY3RfZnJhZ1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGlzdGFuY2VSR0JBOiB7XFxuXFxuXFx0XFx0XFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5jb21tb24sXFxuXFx0XFx0XFx0XFx0VW5pZm9ybXNMaWIuZGlzcGxhY2VtZW50bWFwLFxcblxcdFxcdFxcdFxcdHtcXG5cXHRcXHRcXHRcXHRcXHRyZWZlcmVuY2VQb3NpdGlvbjogeyB2YWx1ZTogbmV3IFZlY3RvcjMoKSB9LFxcblxcdFxcdFxcdFxcdFxcdG5lYXJEaXN0YW5jZTogeyB2YWx1ZTogMSB9LFxcblxcdFxcdFxcdFxcdFxcdGZhckRpc3RhbmNlOiB7IHZhbHVlOiAxMDAwIH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XSApLFxcblxcblxcdFxcdFxcdHZlcnRleFNoYWRlcjogU2hhZGVyQ2h1bmsuZGlzdGFuY2VSR0JBX3ZlcnQsXFxuXFx0XFx0XFx0ZnJhZ21lbnRTaGFkZXI6IFNoYWRlckNodW5rLmRpc3RhbmNlUkdCQV9mcmFnXFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzaGFkb3c6IHtcXG5cXG5cXHRcXHRcXHR1bmlmb3JtczogVW5pZm9ybXNVdGlscy5tZXJnZSggW1xcblxcdFxcdFxcdFxcdFVuaWZvcm1zTGliLmxpZ2h0cyxcXG5cXHRcXHRcXHRcXHRVbmlmb3Jtc0xpYi5mb2csXFxuXFx0XFx0XFx0XFx0e1xcblxcdFxcdFxcdFxcdFxcdGNvbG9yOiB7IHZhbHVlOiBuZXcgQ29sb3IoIDB4MDAwMDAgKSB9LFxcblxcdFxcdFxcdFxcdFxcdG9wYWNpdHk6IHsgdmFsdWU6IDEuMCB9XFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRdICksXFxuXFxuXFx0XFx0XFx0dmVydGV4U2hhZGVyOiBTaGFkZXJDaHVuay5zaGFkb3dfdmVydCxcXG5cXHRcXHRcXHRmcmFnbWVudFNoYWRlcjogU2hhZGVyQ2h1bmsuc2hhZG93X2ZyYWdcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fTtcXG5cXG5cXHRTaGFkZXJMaWIucGh5c2ljYWwgPSB7XFxuXFxuXFx0XFx0dW5pZm9ybXM6IFVuaWZvcm1zVXRpbHMubWVyZ2UoIFtcXG5cXHRcXHRcXHRTaGFkZXJMaWIuc3RhbmRhcmQudW5pZm9ybXMsXFxuXFx0XFx0XFx0e1xcblxcdFxcdFxcdFxcdGNsZWFyQ29hdDogeyB2YWx1ZTogMCB9LFxcblxcdFxcdFxcdFxcdGNsZWFyQ29hdFJvdWdobmVzczogeyB2YWx1ZTogMCB9XFxuXFx0XFx0XFx0fVxcblxcdFxcdF0gKSxcXG5cXG5cXHRcXHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckNodW5rLm1lc2hwaHlzaWNhbF92ZXJ0LFxcblxcdFxcdGZyYWdtZW50U2hhZGVyOiBTaGFkZXJDaHVuay5tZXNocGh5c2ljYWxfZnJhZ1xcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEJveDIoIG1pbiwgbWF4ICkge1xcblxcblxcdFxcdHRoaXMubWluID0gKCBtaW4gIT09IHVuZGVmaW5lZCApID8gbWluIDogbmV3IFZlY3RvcjIoICsgSW5maW5pdHksICsgSW5maW5pdHkgKTtcXG5cXHRcXHR0aGlzLm1heCA9ICggbWF4ICE9PSB1bmRlZmluZWQgKSA/IG1heCA6IG5ldyBWZWN0b3IyKCAtIEluZmluaXR5LCAtIEluZmluaXR5ICk7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIEJveDIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xcblxcblxcdFxcdFxcdHRoaXMubWluLmNvcHkoIG1pbiApO1xcblxcdFxcdFxcdHRoaXMubWF4LmNvcHkoIG1heCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5tYWtlRW1wdHkoKTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tQ2VudGVyQW5kU2l6ZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IyKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHNldEZyb21DZW50ZXJBbmRTaXplKCBjZW50ZXIsIHNpemUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGhhbGZTaXplID0gdjEuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5tYXguY29weSggY2VudGVyICkuYWRkKCBoYWxmU2l6ZSApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBib3ggKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5taW4uY29weSggYm94Lm1pbiApO1xcblxcdFxcdFxcdHRoaXMubWF4LmNvcHkoIGJveC5tYXggKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG1ha2VFbXB0eTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMubWluLnggPSB0aGlzLm1pbi55ID0gKyBJbmZpbml0eTtcXG5cXHRcXHRcXHR0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IC0gSW5maW5pdHk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpc0VtcHR5OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Ly8gdGhpcyBpcyBhIG1vcmUgcm9idXN0IGNoZWNrIGZvciBlbXB0eSB0aGFuICggdm9sdW1lIDw9IDAgKSBiZWNhdXNlIHZvbHVtZSBjYW4gZ2V0IHBvc2l0aXZlIHdpdGggdHdvIG5lZ2F0aXZlIGF4ZXNcXG5cXG5cXHRcXHRcXHRyZXR1cm4gKCB0aGlzLm1heC54IDwgdGhpcy5taW4ueCApIHx8ICggdGhpcy5tYXgueSA8IHRoaXMubWluLnkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldENlbnRlcjogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyByZXN1bHQuc2V0KCAwLCAwICkgOiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5taW4sIHRoaXMubWF4ICkubXVsdGlwbHlTY2FsYXIoIDAuNSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0U2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyByZXN1bHQuc2V0KCAwLCAwICkgOiByZXN1bHQuc3ViVmVjdG9ycyggdGhpcy5tYXgsIHRoaXMubWluICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRleHBhbmRCeVBvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xcblxcblxcdFxcdFxcdHRoaXMubWluLm1pbiggcG9pbnQgKTtcXG5cXHRcXHRcXHR0aGlzLm1heC5tYXgoIHBvaW50ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRleHBhbmRCeVZlY3RvcjogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5taW4uc3ViKCB2ZWN0b3IgKTtcXG5cXHRcXHRcXHR0aGlzLm1heC5hZGQoIHZlY3RvciApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZXhwYW5kQnlTY2FsYXI6IGZ1bmN0aW9uICggc2NhbGFyICkge1xcblxcblxcdFxcdFxcdHRoaXMubWluLmFkZFNjYWxhciggLSBzY2FsYXIgKTtcXG5cXHRcXHRcXHR0aGlzLm1heC5hZGRTY2FsYXIoIHNjYWxhciApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcG9pbnQueCA8IHRoaXMubWluLnggfHwgcG9pbnQueCA+IHRoaXMubWF4LnggfHxcXG5cXHRcXHRcXHRcXHRwb2ludC55IDwgdGhpcy5taW4ueSB8fCBwb2ludC55ID4gdGhpcy5tYXgueSA/IGZhbHNlIDogdHJ1ZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvbnRhaW5zQm94OiBmdW5jdGlvbiAoIGJveCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5taW4ueCA8PSBib3gubWluLnggJiYgYm94Lm1heC54IDw9IHRoaXMubWF4LnggJiZcXG5cXHRcXHRcXHRcXHR0aGlzLm1pbi55IDw9IGJveC5taW4ueSAmJiBib3gubWF4LnkgPD0gdGhpcy5tYXgueTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcXG5cXHRcXHRcXHQvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxcblxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xcblxcblxcdFxcdFxcdHJldHVybiByZXN1bHQuc2V0KFxcblxcdFxcdFxcdFxcdCggcG9pbnQueCAtIHRoaXMubWluLnggKSAvICggdGhpcy5tYXgueCAtIHRoaXMubWluLnggKSxcXG5cXHRcXHRcXHRcXHQoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55IClcXG5cXHRcXHRcXHQpO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCBib3ggKSB7XFxuXFxuXFx0XFx0XFx0Ly8gdXNpbmcgNCBzcGxpdHRpbmcgcGxhbmVzIHRvIHJ1bGUgb3V0IGludGVyc2VjdGlvbnNcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYm94Lm1heC54IDwgdGhpcy5taW4ueCB8fCBib3gubWluLnggPiB0aGlzLm1heC54IHx8XFxuXFx0XFx0XFx0XFx0Ym94Lm1heC55IDwgdGhpcy5taW4ueSB8fCBib3gubWluLnkgPiB0aGlzLm1heC55ID8gZmFsc2UgOiB0cnVlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xhbXBQb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5jb3B5KCBwb2ludCApLmNsYW1wKCB0aGlzLm1pbiwgdGhpcy5tYXggKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IyKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGNsYW1wZWRQb2ludCA9IHYxLmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xcblxcdFxcdFxcdFxcdHJldHVybiBjbGFtcGVkUG9pbnQuc3ViKCBwb2ludCApLmxlbmd0aCgpO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGludGVyc2VjdDogZnVuY3Rpb24gKCBib3ggKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5taW4ubWF4KCBib3gubWluICk7XFxuXFx0XFx0XFx0dGhpcy5tYXgubWluKCBib3gubWF4ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR1bmlvbjogZnVuY3Rpb24gKCBib3ggKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5taW4ubWluKCBib3gubWluICk7XFxuXFx0XFx0XFx0dGhpcy5tYXgubWF4KCBib3gubWF4ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICggb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdHRoaXMubWluLmFkZCggb2Zmc2V0ICk7XFxuXFx0XFx0XFx0dGhpcy5tYXguYWRkKCBvZmZzZXQgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGVxdWFsczogZnVuY3Rpb24gKCBib3ggKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGJveC5taW4uZXF1YWxzKCB0aGlzLm1pbiApICYmIGJveC5tYXguZXF1YWxzKCB0aGlzLm1heCApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFdlYkdMRmxhcmVSZW5kZXJlciggcmVuZGVyZXIsIGdsLCBzdGF0ZSwgdGV4dHVyZXMsIGNhcGFiaWxpdGllcyApIHtcXG5cXG5cXHRcXHR2YXIgdmVydGV4QnVmZmVyLCBlbGVtZW50QnVmZmVyO1xcblxcdFxcdHZhciBzaGFkZXIsIHByb2dyYW0sIGF0dHJpYnV0ZXMsIHVuaWZvcm1zO1xcblxcblxcdFxcdHZhciB0ZW1wVGV4dHVyZSwgb2NjbHVzaW9uVGV4dHVyZTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBpbml0KCkge1xcblxcblxcdFxcdFxcdHZhciB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoIFtcXG5cXHRcXHRcXHRcXHQtIDEsIC0gMSwgMCwgMCxcXG5cXHRcXHRcXHRcXHQgIDEsIC0gMSwgMSwgMCxcXG5cXHRcXHRcXHRcXHQgIDEsIDEsIDEsIDEsXFxuXFx0XFx0XFx0XFx0LSAxLCAxLCAwLCAxXFxuXFx0XFx0XFx0XSApO1xcblxcblxcdFxcdFxcdHZhciBmYWNlcyA9IG5ldyBVaW50MTZBcnJheSggW1xcblxcdFxcdFxcdFxcdDAsIDEsIDIsXFxuXFx0XFx0XFx0XFx0MCwgMiwgM1xcblxcdFxcdFxcdF0gKTtcXG5cXG5cXHRcXHRcXHQvLyBidWZmZXJzXFxuXFxuXFx0XFx0XFx0dmVydGV4QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XFxuXFx0XFx0XFx0ZWxlbWVudEJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xcblxcblxcdFxcdFxcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XFxuXFx0XFx0XFx0Z2wuYnVmZmVyRGF0YSggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcXG5cXG5cXHRcXHRcXHRnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xcblxcdFxcdFxcdGdsLmJ1ZmZlckRhdGEoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBmYWNlcywgZ2wuU1RBVElDX0RSQVcgKTtcXG5cXG5cXHRcXHRcXHQvLyB0ZXh0dXJlc1xcblxcblxcdFxcdFxcdHRlbXBUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xcblxcdFxcdFxcdG9jY2x1c2lvblRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XFxuXFxuXFx0XFx0XFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIHRlbXBUZXh0dXJlICk7XFxuXFx0XFx0XFx0Z2wudGV4SW1hZ2UyRCggZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCLCAxNiwgMTYsIDAsIGdsLlJHQiwgZ2wuVU5TSUdORURfQllURSwgbnVsbCApO1xcblxcdFxcdFxcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XFxuXFx0XFx0XFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UgKTtcXG5cXHRcXHRcXHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QgKTtcXG5cXHRcXHRcXHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcXG5cXG5cXHRcXHRcXHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgb2NjbHVzaW9uVGV4dHVyZSApO1xcblxcdFxcdFxcdGdsLnRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIDE2LCAxNiwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCApO1xcblxcdFxcdFxcdGdsLnRleFBhcmFtZXRlcmkoIGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFICk7XFxuXFx0XFx0XFx0Z2wudGV4UGFyYW1ldGVyaSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UgKTtcXG5cXHRcXHRcXHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QgKTtcXG5cXHRcXHRcXHRnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QgKTtcXG5cXG5cXHRcXHRcXHRzaGFkZXIgPSB7XFxuXFxuXFx0XFx0XFx0XFx0dmVydGV4U2hhZGVyOiBbXFxuXFxuXFx0XFx0XFx0XFx0XFx0J3VuaWZvcm0gbG93cCBpbnQgcmVuZGVyVHlwZTsnLFxcblxcblxcdFxcdFxcdFxcdFxcdCd1bmlmb3JtIHZlYzMgc2NyZWVuUG9zaXRpb247JyxcXG5cXHRcXHRcXHRcXHRcXHQndW5pZm9ybSB2ZWMyIHNjYWxlOycsXFxuXFx0XFx0XFx0XFx0XFx0J3VuaWZvcm0gZmxvYXQgcm90YXRpb247JyxcXG5cXG5cXHRcXHRcXHRcXHRcXHQndW5pZm9ybSBzYW1wbGVyMkQgb2NjbHVzaW9uTWFwOycsXFxuXFxuXFx0XFx0XFx0XFx0XFx0J2F0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uOycsXFxuXFx0XFx0XFx0XFx0XFx0J2F0dHJpYnV0ZSB2ZWMyIHV2OycsXFxuXFxuXFx0XFx0XFx0XFx0XFx0J3ZhcnlpbmcgdmVjMiB2VVY7JyxcXG5cXHRcXHRcXHRcXHRcXHQndmFyeWluZyBmbG9hdCB2VmlzaWJpbGl0eTsnLFxcblxcblxcdFxcdFxcdFxcdFxcdCd2b2lkIG1haW4oKSB7JyxcXG5cXG5cXHRcXHRcXHRcXHRcXHQnXFx0dlVWID0gdXY7JyxcXG5cXG5cXHRcXHRcXHRcXHRcXHQnXFx0dmVjMiBwb3MgPSBwb3NpdGlvbjsnLFxcblxcblxcdFxcdFxcdFxcdFxcdCdcXHRpZiAoIHJlbmRlclR5cGUgPT0gMiApIHsnLFxcblxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHR2ZWM0IHZpc2liaWxpdHkgPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjEgKSApOycsXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdHZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuNSwgMC4xICkgKTsnLFxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHR2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjksIDAuMSApICk7JyxcXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0dmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC45LCAwLjUgKSApOycsXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdHZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuOSwgMC45ICkgKTsnLFxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHR2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuOSApICk7JyxcXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0dmlzaWJpbGl0eSArPSB0ZXh0dXJlMkQoIG9jY2x1c2lvbk1hcCwgdmVjMiggMC4xLCAwLjkgKSApOycsXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdHZpc2liaWxpdHkgKz0gdGV4dHVyZTJEKCBvY2NsdXNpb25NYXAsIHZlYzIoIDAuMSwgMC41ICkgKTsnLFxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHR2aXNpYmlsaXR5ICs9IHRleHR1cmUyRCggb2NjbHVzaW9uTWFwLCB2ZWMyKCAwLjUsIDAuNSApICk7JyxcXG5cXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0dlZpc2liaWxpdHkgPSAgICAgICAgdmlzaWJpbGl0eS5yIC8gOS4wOycsXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdHZWaXNpYmlsaXR5ICo9IDEuMCAtIHZpc2liaWxpdHkuZyAvIDkuMDsnLFxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHR2VmlzaWJpbGl0eSAqPSAgICAgICB2aXNpYmlsaXR5LmIgLyA5LjA7JyxcXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0dlZpc2liaWxpdHkgKj0gMS4wIC0gdmlzaWJpbGl0eS5hIC8gOS4wOycsXFxuXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdHBvcy54ID0gY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIHBvc2l0aW9uLnk7JyxcXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0cG9zLnkgPSBzaW4oIHJvdGF0aW9uICkgKiBwb3NpdGlvbi54ICsgY29zKCByb3RhdGlvbiApICogcG9zaXRpb24ueTsnLFxcblxcblxcdFxcdFxcdFxcdFxcdCdcXHR9JyxcXG5cXG5cXHRcXHRcXHRcXHRcXHQnXFx0Z2xfUG9zaXRpb24gPSB2ZWM0KCAoIHBvcyAqIHNjYWxlICsgc2NyZWVuUG9zaXRpb24ueHkgKS54eSwgc2NyZWVuUG9zaXRpb24ueiwgMS4wICk7JyxcXG5cXG5cXHRcXHRcXHRcXHRcXHQnfSdcXG5cXG5cXHRcXHRcXHRcXHRdLmpvaW4oICdcXFxcbicgKSxcXG5cXG5cXHRcXHRcXHRcXHRmcmFnbWVudFNoYWRlcjogW1xcblxcblxcdFxcdFxcdFxcdFxcdCd1bmlmb3JtIGxvd3AgaW50IHJlbmRlclR5cGU7JyxcXG5cXG5cXHRcXHRcXHRcXHRcXHQndW5pZm9ybSBzYW1wbGVyMkQgbWFwOycsXFxuXFx0XFx0XFx0XFx0XFx0J3VuaWZvcm0gZmxvYXQgb3BhY2l0eTsnLFxcblxcdFxcdFxcdFxcdFxcdCd1bmlmb3JtIHZlYzMgY29sb3I7JyxcXG5cXG5cXHRcXHRcXHRcXHRcXHQndmFyeWluZyB2ZWMyIHZVVjsnLFxcblxcdFxcdFxcdFxcdFxcdCd2YXJ5aW5nIGZsb2F0IHZWaXNpYmlsaXR5OycsXFxuXFxuXFx0XFx0XFx0XFx0XFx0J3ZvaWQgbWFpbigpIHsnLFxcblxcblxcdFxcdFxcdFxcdFxcdC8vIHBpbmsgc3F1YXJlXFxuXFxuXFx0XFx0XFx0XFx0XFx0J1xcdGlmICggcmVuZGVyVHlwZSA9PSAwICkgeycsXFxuXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdGdsX0ZyYWdDb2xvciA9IHZlYzQoIDEuMCwgMC4wLCAxLjAsIDAuMCApOycsXFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gcmVzdG9yZVxcblxcblxcdFxcdFxcdFxcdFxcdCdcXHR9IGVsc2UgaWYgKCByZW5kZXJUeXBlID09IDEgKSB7JyxcXG5cXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0Z2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKCBtYXAsIHZVViApOycsXFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZmxhcmVcXG5cXG5cXHRcXHRcXHRcXHRcXHQnXFx0fSBlbHNlIHsnLFxcblxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHR2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7JyxcXG5cXHRcXHRcXHRcXHRcXHQnXFx0XFx0dGV4dHVyZS5hICo9IG9wYWNpdHkgKiB2VmlzaWJpbGl0eTsnLFxcblxcdFxcdFxcdFxcdFxcdCdcXHRcXHRnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlOycsXFxuXFx0XFx0XFx0XFx0XFx0J1xcdFxcdGdsX0ZyYWdDb2xvci5yZ2IgKj0gY29sb3I7JyxcXG5cXG5cXHRcXHRcXHRcXHRcXHQnXFx0fScsXFxuXFxuXFx0XFx0XFx0XFx0XFx0J30nXFxuXFxuXFx0XFx0XFx0XFx0XS5qb2luKCAnXFxcXG4nIClcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKCBzaGFkZXIgKTtcXG5cXG5cXHRcXHRcXHRhdHRyaWJ1dGVzID0ge1xcblxcdFxcdFxcdFxcdHZlcnRleDogZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sICdwb3NpdGlvbicgKSxcXG5cXHRcXHRcXHRcXHR1djogZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sICd1dicgKVxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0dW5pZm9ybXMgPSB7XFxuXFx0XFx0XFx0XFx0cmVuZGVyVHlwZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAncmVuZGVyVHlwZScgKSxcXG5cXHRcXHRcXHRcXHRtYXA6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21hcCcgKSxcXG5cXHRcXHRcXHRcXHRvY2NsdXNpb25NYXA6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ29jY2x1c2lvbk1hcCcgKSxcXG5cXHRcXHRcXHRcXHRvcGFjaXR5OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdvcGFjaXR5JyApLFxcblxcdFxcdFxcdFxcdGNvbG9yOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdjb2xvcicgKSxcXG5cXHRcXHRcXHRcXHRzY2FsZTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnc2NhbGUnICksXFxuXFx0XFx0XFx0XFx0cm90YXRpb246IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3JvdGF0aW9uJyApLFxcblxcdFxcdFxcdFxcdHNjcmVlblBvc2l0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdzY3JlZW5Qb3NpdGlvbicgKVxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8qXFxuXFx0XFx0ICogUmVuZGVyIGxlbnMgZmxhcmVzXFxuXFx0XFx0ICogTWV0aG9kOiByZW5kZXJzIDE2eDE2IDB4ZmYwMGZmLWNvbG9yZWQgcG9pbnRzIHNjYXR0ZXJlZCBvdmVyIHRoZSBsaWdodCBzb3VyY2UgYXJlYSxcXG5cXHRcXHQgKiAgICAgICAgIHJlYWRzIHRoZXNlIGJhY2sgYW5kIGNhbGN1bGF0ZXMgb2NjbHVzaW9uLlxcblxcdFxcdCAqL1xcblxcblxcdFxcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBmbGFyZXMsIHNjZW5lLCBjYW1lcmEsIHZpZXdwb3J0ICkge1xcblxcblxcdFxcdFxcdGlmICggZmxhcmVzLmxlbmd0aCA9PT0gMCApIHJldHVybjtcXG5cXG5cXHRcXHRcXHR2YXIgdGVtcFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHR2YXIgaW52QXNwZWN0ID0gdmlld3BvcnQudyAvIHZpZXdwb3J0LnosXFxuXFx0XFx0XFx0XFx0aGFsZlZpZXdwb3J0V2lkdGggPSB2aWV3cG9ydC56ICogMC41LFxcblxcdFxcdFxcdFxcdGhhbGZWaWV3cG9ydEhlaWdodCA9IHZpZXdwb3J0LncgKiAwLjU7XFxuXFxuXFx0XFx0XFx0dmFyIHNpemUgPSAxNiAvIHZpZXdwb3J0LncsXFxuXFx0XFx0XFx0XFx0c2NhbGUgPSBuZXcgVmVjdG9yMiggc2l6ZSAqIGludkFzcGVjdCwgc2l6ZSApO1xcblxcblxcdFxcdFxcdHZhciBzY3JlZW5Qb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCAxLCAxLCAwICksXFxuXFx0XFx0XFx0XFx0c2NyZWVuUG9zaXRpb25QaXhlbHMgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xcblxcblxcdFxcdFxcdHZhciB2YWxpZEFyZWEgPSBuZXcgQm94MigpO1xcblxcblxcdFxcdFxcdHZhbGlkQXJlYS5taW4uc2V0KCB2aWV3cG9ydC54LCB2aWV3cG9ydC55ICk7XFxuXFx0XFx0XFx0dmFsaWRBcmVhLm1heC5zZXQoIHZpZXdwb3J0LnggKyAoIHZpZXdwb3J0LnogLSAxNiApLCB2aWV3cG9ydC55ICsgKCB2aWV3cG9ydC53IC0gMTYgKSApO1xcblxcblxcdFxcdFxcdGlmICggcHJvZ3JhbSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGluaXQoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0c3RhdGUudXNlUHJvZ3JhbSggcHJvZ3JhbSApO1xcblxcblxcdFxcdFxcdHN0YXRlLmluaXRBdHRyaWJ1dGVzKCk7XFxuXFx0XFx0XFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGVzLnZlcnRleCApO1xcblxcdFxcdFxcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xcblxcdFxcdFxcdHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XFxuXFxuXFx0XFx0XFx0Ly8gbG9vcCB0aHJvdWdoIGFsbCBsZW5zIGZsYXJlcyB0byB1cGRhdGUgdGhlaXIgb2NjbHVzaW9uIGFuZCBwb3NpdGlvbnNcXG5cXHRcXHRcXHQvLyBzZXR1cCBnbCBhbmQgY29tbW9uIHVzZWQgYXR0cmlicy91bmlmb3Jtc1xcblxcblxcdFxcdFxcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMub2NjbHVzaW9uTWFwLCAwICk7XFxuXFx0XFx0XFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5tYXAsIDEgKTtcXG5cXG5cXHRcXHRcXHRnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlciApO1xcblxcdFxcdFxcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudmVydGV4LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIgKiA4LCAwICk7XFxuXFx0XFx0XFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy51diwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgOCApO1xcblxcblxcdFxcdFxcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XFxuXFxuXFx0XFx0XFx0c3RhdGUuZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XFxuXFx0XFx0XFx0c3RhdGUuYnVmZmVycy5kZXB0aC5zZXRNYXNrKCBmYWxzZSApO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGZsYXJlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHNpemUgPSAxNiAvIHZpZXdwb3J0Lnc7XFxuXFx0XFx0XFx0XFx0c2NhbGUuc2V0KCBzaXplICogaW52QXNwZWN0LCBzaXplICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gY2FsYyBvYmplY3Qgc2NyZWVuIHBvc2l0aW9uXFxuXFxuXFx0XFx0XFx0XFx0dmFyIGZsYXJlID0gZmxhcmVzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0dGVtcFBvc2l0aW9uLnNldCggZmxhcmUubWF0cml4V29ybGQuZWxlbWVudHNbIDEyIF0sIGZsYXJlLm1hdHJpeFdvcmxkLmVsZW1lbnRzWyAxMyBdLCBmbGFyZS5tYXRyaXhXb3JsZC5lbGVtZW50c1sgMTQgXSApO1xcblxcblxcdFxcdFxcdFxcdHRlbXBQb3NpdGlvbi5hcHBseU1hdHJpeDQoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcXG5cXHRcXHRcXHRcXHR0ZW1wUG9zaXRpb24uYXBwbHlNYXRyaXg0KCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xcblxcblxcdFxcdFxcdFxcdC8vIHNldHVwIGFycmF5cyBmb3IgZ2wgcHJvZ3JhbXNcXG5cXG5cXHRcXHRcXHRcXHRzY3JlZW5Qb3NpdGlvbi5jb3B5KCB0ZW1wUG9zaXRpb24gKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBjb29yZGluYXRlIG9mIHRoZSBsb3dlciBsZWZ0IGNvcm5lciBvZiB0aGUgcGl4ZWxzIHRvIGNvcHlcXG5cXG5cXHRcXHRcXHRcXHRzY3JlZW5Qb3NpdGlvblBpeGVscy54ID0gdmlld3BvcnQueCArICggc2NyZWVuUG9zaXRpb24ueCAqIGhhbGZWaWV3cG9ydFdpZHRoICkgKyBoYWxmVmlld3BvcnRXaWR0aCAtIDg7XFxuXFx0XFx0XFx0XFx0c2NyZWVuUG9zaXRpb25QaXhlbHMueSA9IHZpZXdwb3J0LnkgKyAoIHNjcmVlblBvc2l0aW9uLnkgKiBoYWxmVmlld3BvcnRIZWlnaHQgKSArIGhhbGZWaWV3cG9ydEhlaWdodCAtIDg7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gc2NyZWVuIGN1bGxcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHZhbGlkQXJlYS5jb250YWluc1BvaW50KCBzY3JlZW5Qb3NpdGlvblBpeGVscyApID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHNhdmUgY3VycmVudCBSR0IgdG8gdGVtcCB0ZXh0dXJlXFxuXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTAgKTtcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgbnVsbCApO1xcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUxICk7XFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIHRlbXBUZXh0dXJlICk7XFxuXFx0XFx0XFx0XFx0XFx0Z2wuY29weVRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQiwgc2NyZWVuUG9zaXRpb25QaXhlbHMueCwgc2NyZWVuUG9zaXRpb25QaXhlbHMueSwgMTYsIDE2LCAwICk7XFxuXFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gcmVuZGVyIHBpbmsgcXVhZFxcblxcblxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMCApO1xcblxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0yZiggdW5pZm9ybXMuc2NhbGUsIHNjYWxlLngsIHNjYWxlLnkgKTtcXG5cXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLnNjcmVlblBvc2l0aW9uLCBzY3JlZW5Qb3NpdGlvbi54LCBzY3JlZW5Qb3NpdGlvbi55LCBzY3JlZW5Qb3NpdGlvbi56ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuZGlzYWJsZSggZ2wuQkxFTkQgKTtcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5lbmFibGUoIGdsLkRFUFRIX1RFU1QgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcXG5cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBjb3B5IHJlc3VsdCB0byBvY2NsdXNpb25NYXBcXG5cXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBnbC5URVhUVVJFMCApO1xcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmJpbmRUZXh0dXJlKCBnbC5URVhUVVJFXzJELCBvY2NsdXNpb25UZXh0dXJlICk7XFxuXFx0XFx0XFx0XFx0XFx0Z2wuY29weVRleEltYWdlMkQoIGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLngsIHNjcmVlblBvc2l0aW9uUGl4ZWxzLnksIDE2LCAxNiwgMCApO1xcblxcblxcblxcdFxcdFxcdFxcdFxcdC8vIHJlc3RvcmUgZ3JhcGhpY3NcXG5cXG5cXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLnJlbmRlclR5cGUsIDEgKTtcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5kaXNhYmxlKCBnbC5ERVBUSF9URVNUICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggZ2wuVEVYVFVSRTEgKTtcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5iaW5kVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgdGVtcFRleHR1cmUgKTtcXG5cXHRcXHRcXHRcXHRcXHRnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKTtcXG5cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyB1cGRhdGUgb2JqZWN0IHBvc2l0aW9uc1xcblxcblxcdFxcdFxcdFxcdFxcdGZsYXJlLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHNjcmVlblBvc2l0aW9uICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBmbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmbGFyZS5jdXN0b21VcGRhdGVDYWxsYmFjayggZmxhcmUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZsYXJlLnVwZGF0ZUxlbnNGbGFyZXMoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gcmVuZGVyIGZsYXJlc1xcblxcblxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMucmVuZGVyVHlwZSwgMiApO1xcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmVuYWJsZSggZ2wuQkxFTkQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gZmxhcmUubGVuc0ZsYXJlcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgc3ByaXRlID0gZmxhcmUubGVuc0ZsYXJlc1sgaiBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggc3ByaXRlLm9wYWNpdHkgPiAwLjAwMSAmJiBzcHJpdGUuc2NhbGUgPiAwLjAwMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzY3JlZW5Qb3NpdGlvbi54ID0gc3ByaXRlLng7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2NyZWVuUG9zaXRpb24ueSA9IHNwcml0ZS55O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNjcmVlblBvc2l0aW9uLnogPSBzcHJpdGUuejtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzaXplID0gc3ByaXRlLnNpemUgKiBzcHJpdGUuc2NhbGUgLyB2aWV3cG9ydC53O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNjYWxlLnggPSBzaXplICogaW52QXNwZWN0O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNjYWxlLnkgPSBzaXplO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuc2NyZWVuUG9zaXRpb24sIHNjcmVlblBvc2l0aW9uLngsIHNjcmVlblBvc2l0aW9uLnksIHNjcmVlblBvc2l0aW9uLnogKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZS54LCBzY2FsZS55ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5yb3RhdGlvbiwgc3ByaXRlLnJvdGF0aW9uICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5vcGFjaXR5LCBzcHJpdGUub3BhY2l0eSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuY29sb3IsIHNwcml0ZS5jb2xvci5yLCBzcHJpdGUuY29sb3IuZywgc3ByaXRlLmNvbG9yLmIgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzdGF0ZS5zZXRCbGVuZGluZyggc3ByaXRlLmJsZW5kaW5nLCBzcHJpdGUuYmxlbmRFcXVhdGlvbiwgc3ByaXRlLmJsZW5kU3JjLCBzcHJpdGUuYmxlbmREc3QgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkQoIHNwcml0ZS50ZXh0dXJlLCAxICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuZHJhd0VsZW1lbnRzKCBnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHJlc3RvcmUgZ2xcXG5cXG5cXHRcXHRcXHRzdGF0ZS5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xcblxcdFxcdFxcdHN0YXRlLmVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xcblxcdFxcdFxcdHN0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0TWFzayggdHJ1ZSApO1xcblxcblxcdFxcdFxcdHN0YXRlLnJlc2V0KCk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBjcmVhdGVQcm9ncmFtKCBzaGFkZXIgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XFxuXFxuXFx0XFx0XFx0dmFyIGZyYWdtZW50U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5GUkFHTUVOVF9TSEFERVIgKTtcXG5cXHRcXHRcXHR2YXIgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCBnbC5WRVJURVhfU0hBREVSICk7XFxuXFxuXFx0XFx0XFx0dmFyIHByZWZpeCA9ICdwcmVjaXNpb24gJyArIGNhcGFiaWxpdGllcy5wcmVjaXNpb24gKyAnIGZsb2F0O1xcXFxuJztcXG5cXG5cXHRcXHRcXHRnbC5zaGFkZXJTb3VyY2UoIGZyYWdtZW50U2hhZGVyLCBwcmVmaXggKyBzaGFkZXIuZnJhZ21lbnRTaGFkZXIgKTtcXG5cXHRcXHRcXHRnbC5zaGFkZXJTb3VyY2UoIHZlcnRleFNoYWRlciwgcHJlZml4ICsgc2hhZGVyLnZlcnRleFNoYWRlciApO1xcblxcblxcdFxcdFxcdGdsLmNvbXBpbGVTaGFkZXIoIGZyYWdtZW50U2hhZGVyICk7XFxuXFx0XFx0XFx0Z2wuY29tcGlsZVNoYWRlciggdmVydGV4U2hhZGVyICk7XFxuXFxuXFx0XFx0XFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcmFnbWVudFNoYWRlciApO1xcblxcdFxcdFxcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XFxuXFxuXFx0XFx0XFx0Z2wubGlua1Byb2dyYW0oIHByb2dyYW0gKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcHJvZ3JhbTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gQ2FudmFzVGV4dHVyZSggY2FudmFzLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XFxuXFxuXFx0XFx0VGV4dHVyZS5jYWxsKCB0aGlzLCBjYW52YXMsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGZvcm1hdCwgdHlwZSwgYW5pc290cm9weSApO1xcblxcblxcdFxcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdH1cXG5cXG5cXHRDYW52YXNUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRleHR1cmUucHJvdG90eXBlICk7XFxuXFx0Q2FudmFzVGV4dHVyZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW52YXNUZXh0dXJlO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBXZWJHTFNwcml0ZVJlbmRlcmVyKCByZW5kZXJlciwgZ2wsIHN0YXRlLCB0ZXh0dXJlcywgY2FwYWJpbGl0aWVzICkge1xcblxcblxcdFxcdHZhciB2ZXJ0ZXhCdWZmZXIsIGVsZW1lbnRCdWZmZXI7XFxuXFx0XFx0dmFyIHByb2dyYW0sIGF0dHJpYnV0ZXMsIHVuaWZvcm1zO1xcblxcblxcdFxcdHZhciB0ZXh0dXJlO1xcblxcblxcdFxcdC8vIGRlY29tcG9zZSBtYXRyaXhXb3JsZFxcblxcblxcdFxcdHZhciBzcHJpdGVQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dmFyIHNwcml0ZVJvdGF0aW9uID0gbmV3IFF1YXRlcm5pb24oKTtcXG5cXHRcXHR2YXIgc3ByaXRlU2NhbGUgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdGZ1bmN0aW9uIGluaXQoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSggW1xcblxcdFxcdFxcdFxcdC0gMC41LCAtIDAuNSwgMCwgMCxcXG5cXHRcXHRcXHRcXHQgIDAuNSwgLSAwLjUsIDEsIDAsXFxuXFx0XFx0XFx0XFx0ICAwLjUsIDAuNSwgMSwgMSxcXG5cXHRcXHRcXHRcXHQtIDAuNSwgMC41LCAwLCAxXFxuXFx0XFx0XFx0XSApO1xcblxcblxcdFxcdFxcdHZhciBmYWNlcyA9IG5ldyBVaW50MTZBcnJheSggW1xcblxcdFxcdFxcdFxcdDAsIDEsIDIsXFxuXFx0XFx0XFx0XFx0MCwgMiwgM1xcblxcdFxcdFxcdF0gKTtcXG5cXG5cXHRcXHRcXHR2ZXJ0ZXhCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcXG5cXHRcXHRcXHRlbGVtZW50QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XFxuXFxuXFx0XFx0XFx0Z2wuYmluZEJ1ZmZlciggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIgKTtcXG5cXHRcXHRcXHRnbC5idWZmZXJEYXRhKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xcblxcblxcdFxcdFxcdGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBlbGVtZW50QnVmZmVyICk7XFxuXFx0XFx0XFx0Z2wuYnVmZmVyRGF0YSggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIGZhY2VzLCBnbC5TVEFUSUNfRFJBVyApO1xcblxcblxcdFxcdFxcdHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKCk7XFxuXFxuXFx0XFx0XFx0YXR0cmlidXRlcyA9IHtcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbjogZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sICdwb3NpdGlvbicgKSxcXG5cXHRcXHRcXHRcXHR1djogZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sICd1dicgKVxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0dW5pZm9ybXMgPSB7XFxuXFx0XFx0XFx0XFx0dXZPZmZzZXQ6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2T2Zmc2V0JyApLFxcblxcdFxcdFxcdFxcdHV2U2NhbGU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3V2U2NhbGUnICksXFxuXFxuXFx0XFx0XFx0XFx0cm90YXRpb246IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ3JvdGF0aW9uJyApLFxcblxcdFxcdFxcdFxcdHNjYWxlOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdzY2FsZScgKSxcXG5cXG5cXHRcXHRcXHRcXHRjb2xvcjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnY29sb3InICksXFxuXFx0XFx0XFx0XFx0bWFwOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdtYXAnICksXFxuXFx0XFx0XFx0XFx0b3BhY2l0eTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnb3BhY2l0eScgKSxcXG5cXG5cXHRcXHRcXHRcXHRtb2RlbFZpZXdNYXRyaXg6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ21vZGVsVmlld01hdHJpeCcgKSxcXG5cXHRcXHRcXHRcXHRwcm9qZWN0aW9uTWF0cml4OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdwcm9qZWN0aW9uTWF0cml4JyApLFxcblxcblxcdFxcdFxcdFxcdGZvZ1R5cGU6IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2ZvZ1R5cGUnICksXFxuXFx0XFx0XFx0XFx0Zm9nRGVuc2l0eTogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nRGVuc2l0eScgKSxcXG5cXHRcXHRcXHRcXHRmb2dOZWFyOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dOZWFyJyApLFxcblxcdFxcdFxcdFxcdGZvZ0ZhcjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nRmFyJyApLFxcblxcdFxcdFxcdFxcdGZvZ0NvbG9yOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdmb2dDb2xvcicgKSxcXG5cXHRcXHRcXHRcXHRmb2dEZXB0aDogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnZm9nRGVwdGgnICksXFxuXFxuXFx0XFx0XFx0XFx0YWxwaGFUZXN0OiBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdhbHBoYVRlc3QnIClcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2NhbnZhcycgKTtcXG5cXHRcXHRcXHRjYW52YXMud2lkdGggPSA4O1xcblxcdFxcdFxcdGNhbnZhcy5oZWlnaHQgPSA4O1xcblxcblxcdFxcdFxcdHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoICcyZCcgKTtcXG5cXHRcXHRcXHRjb250ZXh0LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XFxuXFx0XFx0XFx0Y29udGV4dC5maWxsUmVjdCggMCwgMCwgOCwgOCApO1xcblxcblxcdFxcdFxcdHRleHR1cmUgPSBuZXcgQ2FudmFzVGV4dHVyZSggY2FudmFzICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCBzcHJpdGVzLCBzY2VuZSwgY2FtZXJhICkge1xcblxcblxcdFxcdFxcdGlmICggc3ByaXRlcy5sZW5ndGggPT09IDAgKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0Ly8gc2V0dXAgZ2xcXG5cXG5cXHRcXHRcXHRpZiAoIHByb2dyYW0gPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpbml0KCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHN0YXRlLnVzZVByb2dyYW0oIHByb2dyYW0gKTtcXG5cXG5cXHRcXHRcXHRzdGF0ZS5pbml0QXR0cmlidXRlcygpO1xcblxcdFxcdFxcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy5wb3NpdGlvbiApO1xcblxcdFxcdFxcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZSggYXR0cmlidXRlcy51diApO1xcblxcdFxcdFxcdHN0YXRlLmRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzKCk7XFxuXFxuXFx0XFx0XFx0c3RhdGUuZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XFxuXFx0XFx0XFx0c3RhdGUuZW5hYmxlKCBnbC5CTEVORCApO1xcblxcblxcdFxcdFxcdGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyICk7XFxuXFx0XFx0XFx0Z2wudmVydGV4QXR0cmliUG9pbnRlciggYXR0cmlidXRlcy5wb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAyICogOCwgMCApO1xcblxcdFxcdFxcdGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoIGF0dHJpYnV0ZXMudXYsIDIsIGdsLkZMT0FULCBmYWxzZSwgMiAqIDgsIDggKTtcXG5cXG5cXHRcXHRcXHRnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgZWxlbWVudEJ1ZmZlciApO1xcblxcblxcdFxcdFxcdGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHVuaWZvcm1zLnByb2plY3Rpb25NYXRyaXgsIGZhbHNlLCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeC5lbGVtZW50cyApO1xcblxcblxcdFxcdFxcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwICk7XFxuXFx0XFx0XFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5tYXAsIDAgKTtcXG5cXG5cXHRcXHRcXHR2YXIgb2xkRm9nVHlwZSA9IDA7XFxuXFx0XFx0XFx0dmFyIHNjZW5lRm9nVHlwZSA9IDA7XFxuXFx0XFx0XFx0dmFyIGZvZyA9IHNjZW5lLmZvZztcXG5cXG5cXHRcXHRcXHRpZiAoIGZvZyApIHtcXG5cXG5cXHRcXHRcXHRcXHRnbC51bmlmb3JtM2YoIHVuaWZvcm1zLmZvZ0NvbG9yLCBmb2cuY29sb3IuciwgZm9nLmNvbG9yLmcsIGZvZy5jb2xvci5iICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBmb2cuaXNGb2cgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTFmKCB1bmlmb3Jtcy5mb2dOZWFyLCBmb2cubmVhciApO1xcblxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nRmFyLCBmb2cuZmFyICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTFpKCB1bmlmb3Jtcy5mb2dUeXBlLCAxICk7XFxuXFx0XFx0XFx0XFx0XFx0b2xkRm9nVHlwZSA9IDE7XFxuXFx0XFx0XFx0XFx0XFx0c2NlbmVGb2dUeXBlID0gMTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBmb2cuaXNGb2dFeHAyICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMuZm9nRGVuc2l0eSwgZm9nLmRlbnNpdHkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIDIgKTtcXG5cXHRcXHRcXHRcXHRcXHRvbGRGb2dUeXBlID0gMjtcXG5cXHRcXHRcXHRcXHRcXHRzY2VuZUZvZ1R5cGUgPSAyO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdGdsLnVuaWZvcm0xaSggdW5pZm9ybXMuZm9nVHlwZSwgMCApO1xcblxcdFxcdFxcdFxcdG9sZEZvZ1R5cGUgPSAwO1xcblxcdFxcdFxcdFxcdHNjZW5lRm9nVHlwZSA9IDA7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcblxcdFxcdFxcdC8vIHVwZGF0ZSBwb3NpdGlvbnMgYW5kIHNvcnRcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzcHJpdGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHNwcml0ZSA9IHNwcml0ZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRzcHJpdGUubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIHNwcml0ZS5tYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdFxcdHNwcml0ZS56ID0gLSBzcHJpdGUubW9kZWxWaWV3TWF0cml4LmVsZW1lbnRzWyAxNCBdO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRzcHJpdGVzLnNvcnQoIHBhaW50ZXJTb3J0U3RhYmxlICk7XFxuXFxuXFx0XFx0XFx0Ly8gcmVuZGVyIGFsbCBzcHJpdGVzXFxuXFxuXFx0XFx0XFx0dmFyIHNjYWxlID0gW107XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc3ByaXRlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBzcHJpdGUgPSBzcHJpdGVzWyBpIF07XFxuXFx0XFx0XFx0XFx0dmFyIG1hdGVyaWFsID0gc3ByaXRlLm1hdGVyaWFsO1xcblxcblxcdFxcdFxcdFxcdGlmICggbWF0ZXJpYWwudmlzaWJsZSA9PT0gZmFsc2UgKSBjb250aW51ZTtcXG5cXG5cXHRcXHRcXHRcXHRzcHJpdGUub25CZWZvcmVSZW5kZXIoIHJlbmRlcmVyLCBzY2VuZSwgY2FtZXJhLCB1bmRlZmluZWQsIG1hdGVyaWFsLCB1bmRlZmluZWQgKTtcXG5cXG5cXHRcXHRcXHRcXHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLmFscGhhVGVzdCwgbWF0ZXJpYWwuYWxwaGFUZXN0ICk7XFxuXFx0XFx0XFx0XFx0Z2wudW5pZm9ybU1hdHJpeDRmdiggdW5pZm9ybXMubW9kZWxWaWV3TWF0cml4LCBmYWxzZSwgc3ByaXRlLm1vZGVsVmlld01hdHJpeC5lbGVtZW50cyApO1xcblxcblxcdFxcdFxcdFxcdHNwcml0ZS5tYXRyaXhXb3JsZC5kZWNvbXBvc2UoIHNwcml0ZVBvc2l0aW9uLCBzcHJpdGVSb3RhdGlvbiwgc3ByaXRlU2NhbGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRzY2FsZVsgMCBdID0gc3ByaXRlU2NhbGUueDtcXG5cXHRcXHRcXHRcXHRzY2FsZVsgMSBdID0gc3ByaXRlU2NhbGUueTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZm9nVHlwZSA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBzY2VuZS5mb2cgJiYgbWF0ZXJpYWwuZm9nICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGZvZ1R5cGUgPSBzY2VuZUZvZ1R5cGU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggb2xkRm9nVHlwZSAhPT0gZm9nVHlwZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtMWkoIHVuaWZvcm1zLmZvZ1R5cGUsIGZvZ1R5cGUgKTtcXG5cXHRcXHRcXHRcXHRcXHRvbGRGb2dUeXBlID0gZm9nVHlwZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5tYXAgIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dk9mZnNldCwgbWF0ZXJpYWwubWFwLm9mZnNldC54LCBtYXRlcmlhbC5tYXAub2Zmc2V0LnkgKTtcXG5cXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2U2NhbGUsIG1hdGVyaWFsLm1hcC5yZXBlYXQueCwgbWF0ZXJpYWwubWFwLnJlcGVhdC55ICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRnbC51bmlmb3JtMmYoIHVuaWZvcm1zLnV2T2Zmc2V0LCAwLCAwICk7XFxuXFx0XFx0XFx0XFx0XFx0Z2wudW5pZm9ybTJmKCB1bmlmb3Jtcy51dlNjYWxlLCAxLCAxICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGdsLnVuaWZvcm0xZiggdW5pZm9ybXMub3BhY2l0eSwgbWF0ZXJpYWwub3BhY2l0eSApO1xcblxcdFxcdFxcdFxcdGdsLnVuaWZvcm0zZiggdW5pZm9ybXMuY29sb3IsIG1hdGVyaWFsLmNvbG9yLnIsIG1hdGVyaWFsLmNvbG9yLmcsIG1hdGVyaWFsLmNvbG9yLmIgKTtcXG5cXG5cXHRcXHRcXHRcXHRnbC51bmlmb3JtMWYoIHVuaWZvcm1zLnJvdGF0aW9uLCBtYXRlcmlhbC5yb3RhdGlvbiApO1xcblxcdFxcdFxcdFxcdGdsLnVuaWZvcm0yZnYoIHVuaWZvcm1zLnNjYWxlLCBzY2FsZSApO1xcblxcblxcdFxcdFxcdFxcdHN0YXRlLnNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0LCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uQWxwaGEsIG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEsIG1hdGVyaWFsLmJsZW5kRHN0QWxwaGEsIG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSApO1xcblxcdFxcdFxcdFxcdHN0YXRlLmJ1ZmZlcnMuZGVwdGguc2V0VGVzdCggbWF0ZXJpYWwuZGVwdGhUZXN0ICk7XFxuXFx0XFx0XFx0XFx0c3RhdGUuYnVmZmVycy5kZXB0aC5zZXRNYXNrKCBtYXRlcmlhbC5kZXB0aFdyaXRlICk7XFxuXFx0XFx0XFx0XFx0c3RhdGUuYnVmZmVycy5jb2xvci5zZXRNYXNrKCBtYXRlcmlhbC5jb2xvcldyaXRlICk7XFxuXFxuXFx0XFx0XFx0XFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEKCBtYXRlcmlhbC5tYXAgfHwgdGV4dHVyZSwgMCApO1xcblxcblxcdFxcdFxcdFxcdGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApO1xcblxcblxcdFxcdFxcdFxcdHNwcml0ZS5vbkFmdGVyUmVuZGVyKCByZW5kZXJlciwgc2NlbmUsIGNhbWVyYSwgdW5kZWZpbmVkLCBtYXRlcmlhbCwgdW5kZWZpbmVkICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHJlc3RvcmUgZ2xcXG5cXG5cXHRcXHRcXHRzdGF0ZS5lbmFibGUoIGdsLkNVTExfRkFDRSApO1xcblxcblxcdFxcdFxcdHN0YXRlLnJlc2V0KCk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBjcmVhdGVQcm9ncmFtKCkge1xcblxcblxcdFxcdFxcdHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xcblxcblxcdFxcdFxcdHZhciB2ZXJ0ZXhTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLlZFUlRFWF9TSEFERVIgKTtcXG5cXHRcXHRcXHR2YXIgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoIGdsLkZSQUdNRU5UX1NIQURFUiApO1xcblxcblxcdFxcdFxcdGdsLnNoYWRlclNvdXJjZSggdmVydGV4U2hhZGVyLCBbXFxuXFxuXFx0XFx0XFx0XFx0J3ByZWNpc2lvbiAnICsgY2FwYWJpbGl0aWVzLnByZWNpc2lvbiArICcgZmxvYXQ7JyxcXG5cXG5cXHRcXHRcXHRcXHQnI2RlZmluZSBTSEFERVJfTkFNRSAnICsgJ1Nwcml0ZU1hdGVyaWFsJyxcXG5cXG5cXHRcXHRcXHRcXHQndW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDsnLFxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsnLFxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIGZsb2F0IHJvdGF0aW9uOycsXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gdmVjMiBzY2FsZTsnLFxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIHZlYzIgdXZPZmZzZXQ7JyxcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSB2ZWMyIHV2U2NhbGU7JyxcXG5cXG5cXHRcXHRcXHRcXHQnYXR0cmlidXRlIHZlYzIgcG9zaXRpb247JyxcXG5cXHRcXHRcXHRcXHQnYXR0cmlidXRlIHZlYzIgdXY7JyxcXG5cXG5cXHRcXHRcXHRcXHQndmFyeWluZyB2ZWMyIHZVVjsnLFxcblxcdFxcdFxcdFxcdCd2YXJ5aW5nIGZsb2F0IGZvZ0RlcHRoOycsXFxuXFxuXFx0XFx0XFx0XFx0J3ZvaWQgbWFpbigpIHsnLFxcblxcblxcdFxcdFxcdFxcdCdcXHR2VVYgPSB1dk9mZnNldCArIHV2ICogdXZTY2FsZTsnLFxcblxcblxcdFxcdFxcdFxcdCdcXHR2ZWMyIGFsaWduZWRQb3NpdGlvbiA9IHBvc2l0aW9uICogc2NhbGU7JyxcXG5cXG5cXHRcXHRcXHRcXHQnXFx0dmVjMiByb3RhdGVkUG9zaXRpb247JyxcXG5cXHRcXHRcXHRcXHQnXFx0cm90YXRlZFBvc2l0aW9uLnggPSBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueCAtIHNpbiggcm90YXRpb24gKSAqIGFsaWduZWRQb3NpdGlvbi55OycsXFxuXFx0XFx0XFx0XFx0J1xcdHJvdGF0ZWRQb3NpdGlvbi55ID0gc2luKCByb3RhdGlvbiApICogYWxpZ25lZFBvc2l0aW9uLnggKyBjb3MoIHJvdGF0aW9uICkgKiBhbGlnbmVkUG9zaXRpb24ueTsnLFxcblxcblxcdFxcdFxcdFxcdCdcXHR2ZWM0IG12UG9zaXRpb247JyxcXG5cXG5cXHRcXHRcXHRcXHQnXFx0bXZQb3NpdGlvbiA9IG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIDAuMCwgMC4wLCAwLjAsIDEuMCApOycsXFxuXFx0XFx0XFx0XFx0J1xcdG12UG9zaXRpb24ueHkgKz0gcm90YXRlZFBvc2l0aW9uOycsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG12UG9zaXRpb247JyxcXG5cXG5cXHRcXHRcXHRcXHQnXFx0Zm9nRGVwdGggPSAtIG12UG9zaXRpb24uejsnLFxcblxcblxcdFxcdFxcdFxcdCd9J1xcblxcblxcdFxcdFxcdF0uam9pbiggJ1xcXFxuJyApICk7XFxuXFxuXFx0XFx0XFx0Z2wuc2hhZGVyU291cmNlKCBmcmFnbWVudFNoYWRlciwgW1xcblxcblxcdFxcdFxcdFxcdCdwcmVjaXNpb24gJyArIGNhcGFiaWxpdGllcy5wcmVjaXNpb24gKyAnIGZsb2F0OycsXFxuXFxuXFx0XFx0XFx0XFx0JyNkZWZpbmUgU0hBREVSX05BTUUgJyArICdTcHJpdGVNYXRlcmlhbCcsXFxuXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gdmVjMyBjb2xvcjsnLFxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIHNhbXBsZXIyRCBtYXA7JyxcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSBmbG9hdCBvcGFjaXR5OycsXFxuXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gaW50IGZvZ1R5cGU7JyxcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSB2ZWMzIGZvZ0NvbG9yOycsXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gZmxvYXQgZm9nRGVuc2l0eTsnLFxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIGZsb2F0IGZvZ05lYXI7JyxcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSBmbG9hdCBmb2dGYXI7JyxcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSBmbG9hdCBhbHBoYVRlc3Q7JyxcXG5cXG5cXHRcXHRcXHRcXHQndmFyeWluZyB2ZWMyIHZVVjsnLFxcblxcdFxcdFxcdFxcdCd2YXJ5aW5nIGZsb2F0IGZvZ0RlcHRoOycsXFxuXFxuXFx0XFx0XFx0XFx0J3ZvaWQgbWFpbigpIHsnLFxcblxcblxcdFxcdFxcdFxcdCdcXHR2ZWM0IHRleHR1cmUgPSB0ZXh0dXJlMkQoIG1hcCwgdlVWICk7JyxcXG5cXG5cXHRcXHRcXHRcXHQnXFx0Z2xfRnJhZ0NvbG9yID0gdmVjNCggY29sb3IgKiB0ZXh0dXJlLnh5eiwgdGV4dHVyZS5hICogb3BhY2l0eSApOycsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdGlmICggZ2xfRnJhZ0NvbG9yLmEgPCBhbHBoYVRlc3QgKSBkaXNjYXJkOycsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdGlmICggZm9nVHlwZSA+IDAgKSB7JyxcXG5cXG5cXHRcXHRcXHRcXHQnXFx0XFx0ZmxvYXQgZm9nRmFjdG9yID0gMC4wOycsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdFxcdGlmICggZm9nVHlwZSA9PSAxICkgeycsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdFxcdFxcdGZvZ0ZhY3RvciA9IHNtb290aHN0ZXAoIGZvZ05lYXIsIGZvZ0ZhciwgZm9nRGVwdGggKTsnLFxcblxcblxcdFxcdFxcdFxcdCdcXHRcXHR9IGVsc2UgeycsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdFxcdFxcdGNvbnN0IGZsb2F0IExPRzIgPSAxLjQ0MjY5NTsnLFxcblxcdFxcdFxcdFxcdCdcXHRcXHRcXHRmb2dGYWN0b3IgPSBleHAyKCAtIGZvZ0RlbnNpdHkgKiBmb2dEZW5zaXR5ICogZm9nRGVwdGggKiBmb2dEZXB0aCAqIExPRzIgKTsnLFxcblxcdFxcdFxcdFxcdCdcXHRcXHRcXHRmb2dGYWN0b3IgPSAxLjAgLSBjbGFtcCggZm9nRmFjdG9yLCAwLjAsIDEuMCApOycsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdFxcdH0nLFxcblxcblxcdFxcdFxcdFxcdCdcXHRcXHRnbF9GcmFnQ29sb3IucmdiID0gbWl4KCBnbF9GcmFnQ29sb3IucmdiLCBmb2dDb2xvciwgZm9nRmFjdG9yICk7JyxcXG5cXG5cXHRcXHRcXHRcXHQnXFx0fScsXFxuXFxuXFx0XFx0XFx0XFx0J30nXFxuXFxuXFx0XFx0XFx0XS5qb2luKCAnXFxcXG4nICkgKTtcXG5cXG5cXHRcXHRcXHRnbC5jb21waWxlU2hhZGVyKCB2ZXJ0ZXhTaGFkZXIgKTtcXG5cXHRcXHRcXHRnbC5jb21waWxlU2hhZGVyKCBmcmFnbWVudFNoYWRlciApO1xcblxcblxcdFxcdFxcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdmVydGV4U2hhZGVyICk7XFxuXFx0XFx0XFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcmFnbWVudFNoYWRlciApO1xcblxcblxcdFxcdFxcdGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHByb2dyYW07XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHBhaW50ZXJTb3J0U3RhYmxlKCBhLCBiICkge1xcblxcblxcdFxcdFxcdGlmICggYS5yZW5kZXJPcmRlciAhPT0gYi5yZW5kZXJPcmRlciApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gYS5yZW5kZXJPcmRlciAtIGIucmVuZGVyT3JkZXI7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggYS56ICE9PSBiLnogKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGIueiAtIGEuejtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBiLmlkIC0gYS5pZDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICovXFxuXFxuXFx0dmFyIG1hdGVyaWFsSWQgPSAwO1xcblxcblxcdGZ1bmN0aW9uIE1hdGVyaWFsKCkge1xcblxcblxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogbWF0ZXJpYWxJZCArKyB9ICk7XFxuXFxuXFx0XFx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XFxuXFxuXFx0XFx0dGhpcy5uYW1lID0gJyc7XFxuXFx0XFx0dGhpcy50eXBlID0gJ01hdGVyaWFsJztcXG5cXG5cXHRcXHR0aGlzLmZvZyA9IHRydWU7XFxuXFx0XFx0dGhpcy5saWdodHMgPSB0cnVlO1xcblxcblxcdFxcdHRoaXMuYmxlbmRpbmcgPSBOb3JtYWxCbGVuZGluZztcXG5cXHRcXHR0aGlzLnNpZGUgPSBGcm9udFNpZGU7XFxuXFx0XFx0dGhpcy5mbGF0U2hhZGluZyA9IGZhbHNlO1xcblxcdFxcdHRoaXMudmVydGV4Q29sb3JzID0gTm9Db2xvcnM7IC8vIFRIUkVFLk5vQ29sb3JzLCBUSFJFRS5WZXJ0ZXhDb2xvcnMsIFRIUkVFLkZhY2VDb2xvcnNcXG5cXG5cXHRcXHR0aGlzLm9wYWNpdHkgPSAxO1xcblxcdFxcdHRoaXMudHJhbnNwYXJlbnQgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLmJsZW5kU3JjID0gU3JjQWxwaGFGYWN0b3I7XFxuXFx0XFx0dGhpcy5ibGVuZERzdCA9IE9uZU1pbnVzU3JjQWxwaGFGYWN0b3I7XFxuXFx0XFx0dGhpcy5ibGVuZEVxdWF0aW9uID0gQWRkRXF1YXRpb247XFxuXFx0XFx0dGhpcy5ibGVuZFNyY0FscGhhID0gbnVsbDtcXG5cXHRcXHR0aGlzLmJsZW5kRHN0QWxwaGEgPSBudWxsO1xcblxcdFxcdHRoaXMuYmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLmRlcHRoRnVuYyA9IExlc3NFcXVhbERlcHRoO1xcblxcdFxcdHRoaXMuZGVwdGhUZXN0ID0gdHJ1ZTtcXG5cXHRcXHR0aGlzLmRlcHRoV3JpdGUgPSB0cnVlO1xcblxcblxcdFxcdHRoaXMuY2xpcHBpbmdQbGFuZXMgPSBudWxsO1xcblxcdFxcdHRoaXMuY2xpcEludGVyc2VjdGlvbiA9IGZhbHNlO1xcblxcdFxcdHRoaXMuY2xpcFNoYWRvd3MgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLmNvbG9yV3JpdGUgPSB0cnVlO1xcblxcblxcdFxcdHRoaXMucHJlY2lzaW9uID0gbnVsbDsgLy8gb3ZlcnJpZGUgdGhlIHJlbmRlcmVyJ3MgZGVmYXVsdCBwcmVjaXNpb24gZm9yIHRoaXMgbWF0ZXJpYWxcXG5cXG5cXHRcXHR0aGlzLnBvbHlnb25PZmZzZXQgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLnBvbHlnb25PZmZzZXRGYWN0b3IgPSAwO1xcblxcdFxcdHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gMDtcXG5cXG5cXHRcXHR0aGlzLmRpdGhlcmluZyA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMuYWxwaGFUZXN0ID0gMDtcXG5cXHRcXHR0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMub3ZlcmRyYXcgPSAwOyAvLyBPdmVyZHJhd24gcGl4ZWxzICh0eXBpY2FsbHkgYmV0d2VlbiAwIGFuZCAxKSBmb3IgZml4aW5nIGFudGlhbGlhc2luZyBnYXBzIGluIENhbnZhc1JlbmRlcmVyXFxuXFxuXFx0XFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcXG5cXG5cXHRcXHR0aGlzLnVzZXJEYXRhID0ge307XFxuXFxuXFx0XFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0fVxcblxcblxcdE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBNYXRlcmlhbCxcXG5cXG5cXHRcXHRpc01hdGVyaWFsOiB0cnVlLFxcblxcblxcdFxcdG9uQmVmb3JlQ29tcGlsZTogZnVuY3Rpb24gKCkge30sXFxuXFxuXFx0XFx0c2V0VmFsdWVzOiBmdW5jdGlvbiAoIHZhbHVlcyApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHZhbHVlcyA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBrZXkgaW4gdmFsdWVzICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBuZXdWYWx1ZSA9IHZhbHVlc1sga2V5IF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggXFxcIlRIUkVFLk1hdGVyaWFsOiAnXFxcIiArIGtleSArIFxcXCInIHBhcmFtZXRlciBpcyB1bmRlZmluZWQuXFxcIiApO1xcblxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBmb3IgYmFja3dhcmQgY29tcGF0YWJpbGl0eSBpZiBzaGFkaW5nIGlzIHNldCBpbiB0aGUgY29uc3RydWN0b3JcXG5cXHRcXHRcXHRcXHRpZiAoIGtleSA9PT0gJ3NoYWRpbmcnICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLicgKyB0aGlzLnR5cGUgKyAnOiAuc2hhZGluZyBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdGhlIGJvb2xlYW4gLmZsYXRTaGFkaW5nIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZmxhdFNoYWRpbmcgPSAoIG5ld1ZhbHVlID09PSBGbGF0U2hhZGluZyApID8gdHJ1ZSA6IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgY3VycmVudFZhbHVlID0gdGhpc1sga2V5IF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBjdXJyZW50VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oIFxcXCJUSFJFRS5cXFwiICsgdGhpcy50eXBlICsgXFxcIjogJ1xcXCIgKyBrZXkgKyBcXFwiJyBpcyBub3QgYSBwcm9wZXJ0eSBvZiB0aGlzIG1hdGVyaWFsLlxcXCIgKTtcXG5cXHRcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBjdXJyZW50VmFsdWUgJiYgY3VycmVudFZhbHVlLmlzQ29sb3IgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudFZhbHVlLnNldCggbmV3VmFsdWUgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCAoIGN1cnJlbnRWYWx1ZSAmJiBjdXJyZW50VmFsdWUuaXNWZWN0b3IzICkgJiYgKCBuZXdWYWx1ZSAmJiBuZXdWYWx1ZS5pc1ZlY3RvcjMgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50VmFsdWUuY29weSggbmV3VmFsdWUgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBrZXkgPT09ICdvdmVyZHJhdycgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZW5zdXJlIG92ZXJkcmF3IGlzIGJhY2t3YXJkcy1jb21wYXRpYmxlIHdpdGggbGVnYWN5IGJvb2xlYW4gdHlwZVxcblxcdFxcdFxcdFxcdFxcdHRoaXNbIGtleSBdID0gTnVtYmVyKCBuZXdWYWx1ZSApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpc1sga2V5IF0gPSBuZXdWYWx1ZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGlzUm9vdCA9ICggbWV0YSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBtZXRhID09PSAnc3RyaW5nJyApO1xcblxcblxcdFxcdFxcdGlmICggaXNSb290ICkge1xcblxcblxcdFxcdFxcdFxcdG1ldGEgPSB7XFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZXM6IHt9LFxcblxcdFxcdFxcdFxcdFxcdGltYWdlczoge31cXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgZGF0YSA9IHtcXG5cXHRcXHRcXHRcXHRtZXRhZGF0YToge1xcblxcdFxcdFxcdFxcdFxcdHZlcnNpb246IDQuNSxcXG5cXHRcXHRcXHRcXHRcXHR0eXBlOiAnTWF0ZXJpYWwnLFxcblxcdFxcdFxcdFxcdFxcdGdlbmVyYXRvcjogJ01hdGVyaWFsLnRvSlNPTidcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHQvLyBzdGFuZGFyZCBNYXRlcmlhbCBzZXJpYWxpemF0aW9uXFxuXFx0XFx0XFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xcblxcdFxcdFxcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmNvbG9yICYmIHRoaXMuY29sb3IuaXNDb2xvciApIGRhdGEuY29sb3IgPSB0aGlzLmNvbG9yLmdldEhleCgpO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5yb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEucm91Z2huZXNzID0gdGhpcy5yb3VnaG5lc3M7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLm1ldGFsbmVzcyAhPT0gdW5kZWZpbmVkICkgZGF0YS5tZXRhbG5lc3MgPSB0aGlzLm1ldGFsbmVzcztcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuZW1pc3NpdmUgJiYgdGhpcy5lbWlzc2l2ZS5pc0NvbG9yICkgZGF0YS5lbWlzc2l2ZSA9IHRoaXMuZW1pc3NpdmUuZ2V0SGV4KCk7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ICE9PSAxICkgZGF0YS5lbWlzc2l2ZUludGVuc2l0eSA9IHRoaXMuZW1pc3NpdmVJbnRlbnNpdHk7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnNwZWN1bGFyICYmIHRoaXMuc3BlY3VsYXIuaXNDb2xvciApIGRhdGEuc3BlY3VsYXIgPSB0aGlzLnNwZWN1bGFyLmdldEhleCgpO1xcblxcdFxcdFxcdGlmICggdGhpcy5zaGluaW5lc3MgIT09IHVuZGVmaW5lZCApIGRhdGEuc2hpbmluZXNzID0gdGhpcy5zaGluaW5lc3M7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLmNsZWFyQ29hdCAhPT0gdW5kZWZpbmVkICkgZGF0YS5jbGVhckNvYXQgPSB0aGlzLmNsZWFyQ29hdDtcXG5cXHRcXHRcXHRpZiAoIHRoaXMuY2xlYXJDb2F0Um91Z2huZXNzICE9PSB1bmRlZmluZWQgKSBkYXRhLmNsZWFyQ29hdFJvdWdobmVzcyA9IHRoaXMuY2xlYXJDb2F0Um91Z2huZXNzO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5tYXAgJiYgdGhpcy5tYXAuaXNUZXh0dXJlICkgZGF0YS5tYXAgPSB0aGlzLm1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xcblxcdFxcdFxcdGlmICggdGhpcy5hbHBoYU1hcCAmJiB0aGlzLmFscGhhTWFwLmlzVGV4dHVyZSApIGRhdGEuYWxwaGFNYXAgPSB0aGlzLmFscGhhTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLmxpZ2h0TWFwICYmIHRoaXMubGlnaHRNYXAuaXNUZXh0dXJlICkgZGF0YS5saWdodE1hcCA9IHRoaXMubGlnaHRNYXAudG9KU09OKCBtZXRhICkudXVpZDtcXG5cXHRcXHRcXHRpZiAoIHRoaXMuYnVtcE1hcCAmJiB0aGlzLmJ1bXBNYXAuaXNUZXh0dXJlICkge1xcblxcblxcdFxcdFxcdFxcdGRhdGEuYnVtcE1hcCA9IHRoaXMuYnVtcE1hcC50b0pTT04oIG1ldGEgKS51dWlkO1xcblxcdFxcdFxcdFxcdGRhdGEuYnVtcFNjYWxlID0gdGhpcy5idW1wU2NhbGU7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICggdGhpcy5ub3JtYWxNYXAgJiYgdGhpcy5ub3JtYWxNYXAuaXNUZXh0dXJlICkge1xcblxcblxcdFxcdFxcdFxcdGRhdGEubm9ybWFsTWFwID0gdGhpcy5ub3JtYWxNYXAudG9KU09OKCBtZXRhICkudXVpZDtcXG5cXHRcXHRcXHRcXHRkYXRhLm5vcm1hbFNjYWxlID0gdGhpcy5ub3JtYWxTY2FsZS50b0FycmF5KCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICggdGhpcy5kaXNwbGFjZW1lbnRNYXAgJiYgdGhpcy5kaXNwbGFjZW1lbnRNYXAuaXNUZXh0dXJlICkge1xcblxcblxcdFxcdFxcdFxcdGRhdGEuZGlzcGxhY2VtZW50TWFwID0gdGhpcy5kaXNwbGFjZW1lbnRNYXAudG9KU09OKCBtZXRhICkudXVpZDtcXG5cXHRcXHRcXHRcXHRkYXRhLmRpc3BsYWNlbWVudFNjYWxlID0gdGhpcy5kaXNwbGFjZW1lbnRTY2FsZTtcXG5cXHRcXHRcXHRcXHRkYXRhLmRpc3BsYWNlbWVudEJpYXMgPSB0aGlzLmRpc3BsYWNlbWVudEJpYXM7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICggdGhpcy5yb3VnaG5lc3NNYXAgJiYgdGhpcy5yb3VnaG5lc3NNYXAuaXNUZXh0dXJlICkgZGF0YS5yb3VnaG5lc3NNYXAgPSB0aGlzLnJvdWdobmVzc01hcC50b0pTT04oIG1ldGEgKS51dWlkO1xcblxcdFxcdFxcdGlmICggdGhpcy5tZXRhbG5lc3NNYXAgJiYgdGhpcy5tZXRhbG5lc3NNYXAuaXNUZXh0dXJlICkgZGF0YS5tZXRhbG5lc3NNYXAgPSB0aGlzLm1ldGFsbmVzc01hcC50b0pTT04oIG1ldGEgKS51dWlkO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5lbWlzc2l2ZU1hcCAmJiB0aGlzLmVtaXNzaXZlTWFwLmlzVGV4dHVyZSApIGRhdGEuZW1pc3NpdmVNYXAgPSB0aGlzLmVtaXNzaXZlTWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLnNwZWN1bGFyTWFwICYmIHRoaXMuc3BlY3VsYXJNYXAuaXNUZXh0dXJlICkgZGF0YS5zcGVjdWxhck1hcCA9IHRoaXMuc3BlY3VsYXJNYXAudG9KU09OKCBtZXRhICkudXVpZDtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuZW52TWFwICYmIHRoaXMuZW52TWFwLmlzVGV4dHVyZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRkYXRhLmVudk1hcCA9IHRoaXMuZW52TWFwLnRvSlNPTiggbWV0YSApLnV1aWQ7XFxuXFx0XFx0XFx0XFx0ZGF0YS5yZWZsZWN0aXZpdHkgPSB0aGlzLnJlZmxlY3Rpdml0eTsgLy8gU2NhbGUgYmVoaW5kIGVudk1hcFxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuZ3JhZGllbnRNYXAgJiYgdGhpcy5ncmFkaWVudE1hcC5pc1RleHR1cmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZGF0YS5ncmFkaWVudE1hcCA9IHRoaXMuZ3JhZGllbnRNYXAudG9KU09OKCBtZXRhICkudXVpZDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnNpemUgIT09IHVuZGVmaW5lZCApIGRhdGEuc2l6ZSA9IHRoaXMuc2l6ZTtcXG5cXHRcXHRcXHRpZiAoIHRoaXMuc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgKSBkYXRhLnNpemVBdHRlbnVhdGlvbiA9IHRoaXMuc2l6ZUF0dGVudWF0aW9uO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5ibGVuZGluZyAhPT0gTm9ybWFsQmxlbmRpbmcgKSBkYXRhLmJsZW5kaW5nID0gdGhpcy5ibGVuZGluZztcXG5cXHRcXHRcXHRpZiAoIHRoaXMuZmxhdFNoYWRpbmcgPT09IHRydWUgKSBkYXRhLmZsYXRTaGFkaW5nID0gdGhpcy5mbGF0U2hhZGluZztcXG5cXHRcXHRcXHRpZiAoIHRoaXMuc2lkZSAhPT0gRnJvbnRTaWRlICkgZGF0YS5zaWRlID0gdGhpcy5zaWRlO1xcblxcdFxcdFxcdGlmICggdGhpcy52ZXJ0ZXhDb2xvcnMgIT09IE5vQ29sb3JzICkgZGF0YS52ZXJ0ZXhDb2xvcnMgPSB0aGlzLnZlcnRleENvbG9ycztcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMub3BhY2l0eSA8IDEgKSBkYXRhLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLnRyYW5zcGFyZW50ID09PSB0cnVlICkgZGF0YS50cmFuc3BhcmVudCA9IHRoaXMudHJhbnNwYXJlbnQ7XFxuXFxuXFx0XFx0XFx0ZGF0YS5kZXB0aEZ1bmMgPSB0aGlzLmRlcHRoRnVuYztcXG5cXHRcXHRcXHRkYXRhLmRlcHRoVGVzdCA9IHRoaXMuZGVwdGhUZXN0O1xcblxcdFxcdFxcdGRhdGEuZGVwdGhXcml0ZSA9IHRoaXMuZGVwdGhXcml0ZTtcXG5cXG5cXHRcXHRcXHQvLyByb3RhdGlvbiAoU3ByaXRlTWF0ZXJpYWwpXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnJvdGF0aW9uICE9PSAwICkgZGF0YS5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmxpbmV3aWR0aCAhPT0gMSApIGRhdGEubGluZXdpZHRoID0gdGhpcy5saW5ld2lkdGg7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLmRhc2hTaXplICE9PSB1bmRlZmluZWQgKSBkYXRhLmRhc2hTaXplID0gdGhpcy5kYXNoU2l6ZTtcXG5cXHRcXHRcXHRpZiAoIHRoaXMuZ2FwU2l6ZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5nYXBTaXplID0gdGhpcy5nYXBTaXplO1xcblxcdFxcdFxcdGlmICggdGhpcy5zY2FsZSAhPT0gdW5kZWZpbmVkICkgZGF0YS5zY2FsZSA9IHRoaXMuc2NhbGU7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmRpdGhlcmluZyA9PT0gdHJ1ZSApIGRhdGEuZGl0aGVyaW5nID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuYWxwaGFUZXN0ID4gMCApIGRhdGEuYWxwaGFUZXN0ID0gdGhpcy5hbHBoYVRlc3Q7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLnByZW11bHRpcGxpZWRBbHBoYSA9PT0gdHJ1ZSApIGRhdGEucHJlbXVsdGlwbGllZEFscGhhID0gdGhpcy5wcmVtdWx0aXBsaWVkQWxwaGE7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLndpcmVmcmFtZSA9PT0gdHJ1ZSApIGRhdGEud2lyZWZyYW1lID0gdGhpcy53aXJlZnJhbWU7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA+IDEgKSBkYXRhLndpcmVmcmFtZUxpbmV3aWR0aCA9IHRoaXMud2lyZWZyYW1lTGluZXdpZHRoO1xcblxcdFxcdFxcdGlmICggdGhpcy53aXJlZnJhbWVMaW5lY2FwICE9PSAncm91bmQnICkgZGF0YS53aXJlZnJhbWVMaW5lY2FwID0gdGhpcy53aXJlZnJhbWVMaW5lY2FwO1xcblxcdFxcdFxcdGlmICggdGhpcy53aXJlZnJhbWVMaW5lam9pbiAhPT0gJ3JvdW5kJyApIGRhdGEud2lyZWZyYW1lTGluZWpvaW4gPSB0aGlzLndpcmVmcmFtZUxpbmVqb2luO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5tb3JwaFRhcmdldHMgPT09IHRydWUgKSBkYXRhLm1vcnBoVGFyZ2V0cyA9IHRydWU7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLnNraW5uaW5nID09PSB0cnVlICkgZGF0YS5za2lubmluZyA9IHRydWU7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgZGF0YS52aXNpYmxlID0gZmFsc2U7XFxuXFx0XFx0XFx0aWYgKCBKU09OLnN0cmluZ2lmeSggdGhpcy51c2VyRGF0YSApICE9PSAne30nICkgZGF0YS51c2VyRGF0YSA9IHRoaXMudXNlckRhdGE7XFxuXFxuXFx0XFx0XFx0Ly8gVE9ETzogQ29waWVkIGZyb20gT2JqZWN0M0QudG9KU09OXFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gZXh0cmFjdEZyb21DYWNoZSggY2FjaGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHZhbHVlcyA9IFtdO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBrZXkgaW4gY2FjaGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGRhdGEgPSBjYWNoZVsga2V5IF07XFxuXFx0XFx0XFx0XFx0XFx0ZGVsZXRlIGRhdGEubWV0YWRhdGE7XFxuXFx0XFx0XFx0XFx0XFx0dmFsdWVzLnB1c2goIGRhdGEgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHZhbHVlcztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBpc1Jvb3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xcblxcdFxcdFxcdFxcdHZhciBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmltYWdlcyApO1xcblxcblxcdFxcdFxcdFxcdGlmICggdGV4dHVyZXMubGVuZ3RoID4gMCApIGRhdGEudGV4dHVyZXMgPSB0ZXh0dXJlcztcXG5cXHRcXHRcXHRcXHRpZiAoIGltYWdlcy5sZW5ndGggPiAwICkgZGF0YS5pbWFnZXMgPSBpbWFnZXM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBkYXRhO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcXG5cXG5cXHRcXHRcXHR0aGlzLmZvZyA9IHNvdXJjZS5mb2c7XFxuXFx0XFx0XFx0dGhpcy5saWdodHMgPSBzb3VyY2UubGlnaHRzO1xcblxcblxcdFxcdFxcdHRoaXMuYmxlbmRpbmcgPSBzb3VyY2UuYmxlbmRpbmc7XFxuXFx0XFx0XFx0dGhpcy5zaWRlID0gc291cmNlLnNpZGU7XFxuXFx0XFx0XFx0dGhpcy5mbGF0U2hhZGluZyA9IHNvdXJjZS5mbGF0U2hhZGluZztcXG5cXHRcXHRcXHR0aGlzLnZlcnRleENvbG9ycyA9IHNvdXJjZS52ZXJ0ZXhDb2xvcnM7XFxuXFxuXFx0XFx0XFx0dGhpcy5vcGFjaXR5ID0gc291cmNlLm9wYWNpdHk7XFxuXFx0XFx0XFx0dGhpcy50cmFuc3BhcmVudCA9IHNvdXJjZS50cmFuc3BhcmVudDtcXG5cXG5cXHRcXHRcXHR0aGlzLmJsZW5kU3JjID0gc291cmNlLmJsZW5kU3JjO1xcblxcdFxcdFxcdHRoaXMuYmxlbmREc3QgPSBzb3VyY2UuYmxlbmREc3Q7XFxuXFx0XFx0XFx0dGhpcy5ibGVuZEVxdWF0aW9uID0gc291cmNlLmJsZW5kRXF1YXRpb247XFxuXFx0XFx0XFx0dGhpcy5ibGVuZFNyY0FscGhhID0gc291cmNlLmJsZW5kU3JjQWxwaGE7XFxuXFx0XFx0XFx0dGhpcy5ibGVuZERzdEFscGhhID0gc291cmNlLmJsZW5kRHN0QWxwaGE7XFxuXFx0XFx0XFx0dGhpcy5ibGVuZEVxdWF0aW9uQWxwaGEgPSBzb3VyY2UuYmxlbmRFcXVhdGlvbkFscGhhO1xcblxcblxcdFxcdFxcdHRoaXMuZGVwdGhGdW5jID0gc291cmNlLmRlcHRoRnVuYztcXG5cXHRcXHRcXHR0aGlzLmRlcHRoVGVzdCA9IHNvdXJjZS5kZXB0aFRlc3Q7XFxuXFx0XFx0XFx0dGhpcy5kZXB0aFdyaXRlID0gc291cmNlLmRlcHRoV3JpdGU7XFxuXFxuXFx0XFx0XFx0dGhpcy5jb2xvcldyaXRlID0gc291cmNlLmNvbG9yV3JpdGU7XFxuXFxuXFx0XFx0XFx0dGhpcy5wcmVjaXNpb24gPSBzb3VyY2UucHJlY2lzaW9uO1xcblxcblxcdFxcdFxcdHRoaXMucG9seWdvbk9mZnNldCA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0O1xcblxcdFxcdFxcdHRoaXMucG9seWdvbk9mZnNldEZhY3RvciA9IHNvdXJjZS5wb2x5Z29uT2Zmc2V0RmFjdG9yO1xcblxcdFxcdFxcdHRoaXMucG9seWdvbk9mZnNldFVuaXRzID0gc291cmNlLnBvbHlnb25PZmZzZXRVbml0cztcXG5cXG5cXHRcXHRcXHR0aGlzLmRpdGhlcmluZyA9IHNvdXJjZS5kaXRoZXJpbmc7XFxuXFxuXFx0XFx0XFx0dGhpcy5hbHBoYVRlc3QgPSBzb3VyY2UuYWxwaGFUZXN0O1xcblxcdFxcdFxcdHRoaXMucHJlbXVsdGlwbGllZEFscGhhID0gc291cmNlLnByZW11bHRpcGxpZWRBbHBoYTtcXG5cXG5cXHRcXHRcXHR0aGlzLm92ZXJkcmF3ID0gc291cmNlLm92ZXJkcmF3O1xcblxcblxcdFxcdFxcdHRoaXMudmlzaWJsZSA9IHNvdXJjZS52aXNpYmxlO1xcblxcdFxcdFxcdHRoaXMudXNlckRhdGEgPSBKU09OLnBhcnNlKCBKU09OLnN0cmluZ2lmeSggc291cmNlLnVzZXJEYXRhICkgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmNsaXBTaGFkb3dzID0gc291cmNlLmNsaXBTaGFkb3dzO1xcblxcdFxcdFxcdHRoaXMuY2xpcEludGVyc2VjdGlvbiA9IHNvdXJjZS5jbGlwSW50ZXJzZWN0aW9uO1xcblxcblxcdFxcdFxcdHZhciBzcmNQbGFuZXMgPSBzb3VyY2UuY2xpcHBpbmdQbGFuZXMsXFxuXFx0XFx0XFx0XFx0ZHN0UGxhbmVzID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRpZiAoIHNyY1BsYW5lcyAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbiA9IHNyY1BsYW5lcy5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0ZHN0UGxhbmVzID0gbmV3IEFycmF5KCBuICk7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuOyArKyBpIClcXG5cXHRcXHRcXHRcXHRcXHRkc3RQbGFuZXNbIGkgXSA9IHNyY1BsYW5lc1sgaSBdLmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuY2xpcHBpbmdQbGFuZXMgPSBkc3RQbGFuZXM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHBzOi8vY2xhcmEuaW9cXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXG5cXHQgKlxcblxcdCAqIHBhcmFtZXRlcnMgPSB7XFxuXFx0ICpcXG5cXHQgKiAgb3BhY2l0eTogPGZsb2F0PixcXG5cXHQgKlxcblxcdCAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICpcXG5cXHQgKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICpcXG5cXHQgKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqICBkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0PixcXG5cXHQgKiAgZGlzcGxhY2VtZW50QmlhczogPGZsb2F0PixcXG5cXHQgKlxcblxcdCAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcXG5cXHQgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+XFxuXFx0ICogfVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIE1lc2hEZXB0aE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnTWVzaERlcHRoTWF0ZXJpYWwnO1xcblxcblxcdFxcdHRoaXMuZGVwdGhQYWNraW5nID0gQmFzaWNEZXB0aFBhY2tpbmc7XFxuXFxuXFx0XFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xcblxcdFxcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XFxuXFxuXFx0XFx0dGhpcy5tYXAgPSBudWxsO1xcblxcblxcdFxcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xcblxcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xcblxcblxcdFxcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xcblxcblxcdFxcdHRoaXMuZm9nID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5saWdodHMgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xcblxcblxcdH1cXG5cXG5cXHRNZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcXG5cXHRNZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoRGVwdGhNYXRlcmlhbDtcXG5cXG5cXHRNZXNoRGVwdGhNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoRGVwdGhNYXRlcmlhbCA9IHRydWU7XFxuXFxuXFx0TWVzaERlcHRoTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHR0aGlzLmRlcHRoUGFja2luZyA9IHNvdXJjZS5kZXB0aFBhY2tpbmc7XFxuXFxuXFx0XFx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcXG5cXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XFxuXFxuXFx0XFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xcblxcblxcdFxcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XFxuXFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XFxuXFxuXFx0XFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcblxcdCAqXFxuXFx0ICogcGFyYW1ldGVycyA9IHtcXG5cXHQgKlxcblxcdCAqICByZWZlcmVuY2VQb3NpdGlvbjogPGZsb2F0PixcXG5cXHQgKiAgbmVhckRpc3RhbmNlOiA8ZmxvYXQ+LFxcblxcdCAqICBmYXJEaXN0YW5jZTogPGZsb2F0PixcXG5cXHQgKlxcblxcdCAqICBza2lubmluZzogPGJvb2w+LFxcblxcdCAqICBtb3JwaFRhcmdldHM6IDxib29sPixcXG5cXHQgKlxcblxcdCAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICpcXG5cXHQgKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICpcXG5cXHQgKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqICBkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0PixcXG5cXHQgKiAgZGlzcGxhY2VtZW50QmlhczogPGZsb2F0PlxcblxcdCAqXFxuXFx0ICogfVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIE1lc2hEaXN0YW5jZU1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnTWVzaERpc3RhbmNlTWF0ZXJpYWwnO1xcblxcblxcdFxcdHRoaXMucmVmZXJlbmNlUG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHRoaXMubmVhckRpc3RhbmNlID0gMTtcXG5cXHRcXHR0aGlzLmZhckRpc3RhbmNlID0gMTAwMDtcXG5cXG5cXHRcXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLm1hcCA9IG51bGw7XFxuXFxuXFx0XFx0dGhpcy5hbHBoYU1hcCA9IG51bGw7XFxuXFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBudWxsO1xcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSAxO1xcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IDA7XFxuXFxuXFx0XFx0dGhpcy5mb2cgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XFxuXFxuXFx0fVxcblxcblxcdE1lc2hEaXN0YW5jZU1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xcblxcdE1lc2hEaXN0YW5jZU1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hEaXN0YW5jZU1hdGVyaWFsO1xcblxcblxcdE1lc2hEaXN0YW5jZU1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hEaXN0YW5jZU1hdGVyaWFsID0gdHJ1ZTtcXG5cXG5cXHRNZXNoRGlzdGFuY2VNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdHRoaXMucmVmZXJlbmNlUG9zaXRpb24uY29weSggc291cmNlLnJlZmVyZW5jZVBvc2l0aW9uICk7XFxuXFx0XFx0dGhpcy5uZWFyRGlzdGFuY2UgPSBzb3VyY2UubmVhckRpc3RhbmNlO1xcblxcdFxcdHRoaXMuZmFyRGlzdGFuY2UgPSBzb3VyY2UuZmFyRGlzdGFuY2U7XFxuXFxuXFx0XFx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcXG5cXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XFxuXFxuXFx0XFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xcblxcblxcdFxcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XFxuXFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRNYXAgPSBzb3VyY2UuZGlzcGxhY2VtZW50TWFwO1xcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50U2NhbGUgPSBzb3VyY2UuZGlzcGxhY2VtZW50U2NhbGU7XFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gc291cmNlLmRpc3BsYWNlbWVudEJpYXM7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gQm94MyggbWluLCBtYXggKSB7XFxuXFxuXFx0XFx0dGhpcy5taW4gPSAoIG1pbiAhPT0gdW5kZWZpbmVkICkgPyBtaW4gOiBuZXcgVmVjdG9yMyggKyBJbmZpbml0eSwgKyBJbmZpbml0eSwgKyBJbmZpbml0eSApO1xcblxcdFxcdHRoaXMubWF4ID0gKCBtYXggIT09IHVuZGVmaW5lZCApID8gbWF4IDogbmV3IFZlY3RvcjMoIC0gSW5maW5pdHksIC0gSW5maW5pdHksIC0gSW5maW5pdHkgKTtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggQm94My5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRpc0JveDM6IHRydWUsXFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIG1pbiwgbWF4ICkge1xcblxcblxcdFxcdFxcdHRoaXMubWluLmNvcHkoIG1pbiApO1xcblxcdFxcdFxcdHRoaXMubWF4LmNvcHkoIG1heCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xcblxcblxcdFxcdFxcdHZhciBtaW5YID0gKyBJbmZpbml0eTtcXG5cXHRcXHRcXHR2YXIgbWluWSA9ICsgSW5maW5pdHk7XFxuXFx0XFx0XFx0dmFyIG1pblogPSArIEluZmluaXR5O1xcblxcblxcdFxcdFxcdHZhciBtYXhYID0gLSBJbmZpbml0eTtcXG5cXHRcXHRcXHR2YXIgbWF4WSA9IC0gSW5maW5pdHk7XFxuXFx0XFx0XFx0dmFyIG1heFogPSAtIEluZmluaXR5O1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgeCA9IGFycmF5WyBpIF07XFxuXFx0XFx0XFx0XFx0dmFyIHkgPSBhcnJheVsgaSArIDEgXTtcXG5cXHRcXHRcXHRcXHR2YXIgeiA9IGFycmF5WyBpICsgMiBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggeCA8IG1pblggKSBtaW5YID0geDtcXG5cXHRcXHRcXHRcXHRpZiAoIHkgPCBtaW5ZICkgbWluWSA9IHk7XFxuXFx0XFx0XFx0XFx0aWYgKCB6IDwgbWluWiApIG1pblogPSB6O1xcblxcblxcdFxcdFxcdFxcdGlmICggeCA+IG1heFggKSBtYXhYID0geDtcXG5cXHRcXHRcXHRcXHRpZiAoIHkgPiBtYXhZICkgbWF4WSA9IHk7XFxuXFx0XFx0XFx0XFx0aWYgKCB6ID4gbWF4WiApIG1heFogPSB6O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLm1pbi5zZXQoIG1pblgsIG1pblksIG1pblogKTtcXG5cXHRcXHRcXHR0aGlzLm1heC5zZXQoIG1heFgsIG1heFksIG1heFogKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZyb21CdWZmZXJBdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlICkge1xcblxcblxcdFxcdFxcdHZhciBtaW5YID0gKyBJbmZpbml0eTtcXG5cXHRcXHRcXHR2YXIgbWluWSA9ICsgSW5maW5pdHk7XFxuXFx0XFx0XFx0dmFyIG1pblogPSArIEluZmluaXR5O1xcblxcblxcdFxcdFxcdHZhciBtYXhYID0gLSBJbmZpbml0eTtcXG5cXHRcXHRcXHR2YXIgbWF4WSA9IC0gSW5maW5pdHk7XFxuXFx0XFx0XFx0dmFyIG1heFogPSAtIEluZmluaXR5O1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGF0dHJpYnV0ZS5jb3VudDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHggPSBhdHRyaWJ1dGUuZ2V0WCggaSApO1xcblxcdFxcdFxcdFxcdHZhciB5ID0gYXR0cmlidXRlLmdldFkoIGkgKTtcXG5cXHRcXHRcXHRcXHR2YXIgeiA9IGF0dHJpYnV0ZS5nZXRaKCBpICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB4IDwgbWluWCApIG1pblggPSB4O1xcblxcdFxcdFxcdFxcdGlmICggeSA8IG1pblkgKSBtaW5ZID0geTtcXG5cXHRcXHRcXHRcXHRpZiAoIHogPCBtaW5aICkgbWluWiA9IHo7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB4ID4gbWF4WCApIG1heFggPSB4O1xcblxcdFxcdFxcdFxcdGlmICggeSA+IG1heFkgKSBtYXhZID0geTtcXG5cXHRcXHRcXHRcXHRpZiAoIHogPiBtYXhaICkgbWF4WiA9IHo7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMubWluLnNldCggbWluWCwgbWluWSwgbWluWiApO1xcblxcdFxcdFxcdHRoaXMubWF4LnNldCggbWF4WCwgbWF4WSwgbWF4WiApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbVBvaW50czogZnVuY3Rpb24gKCBwb2ludHMgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5tYWtlRW1wdHkoKTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuZXhwYW5kQnlQb2ludCggcG9pbnRzWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tQ2VudGVyQW5kU2l6ZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHNldEZyb21DZW50ZXJBbmRTaXplKCBjZW50ZXIsIHNpemUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGhhbGZTaXplID0gdjEuY29weSggc2l6ZSApLm11bHRpcGx5U2NhbGFyKCAwLjUgKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLm1pbi5jb3B5KCBjZW50ZXIgKS5zdWIoIGhhbGZTaXplICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5tYXguY29weSggY2VudGVyICkuYWRkKCBoYWxmU2l6ZSApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdHNldEZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xcblxcblxcdFxcdFxcdHRoaXMubWFrZUVtcHR5KCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZXhwYW5kQnlPYmplY3QoIG9iamVjdCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIGJveCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm1pbi5jb3B5KCBib3gubWluICk7XFxuXFx0XFx0XFx0dGhpcy5tYXguY29weSggYm94Lm1heCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bWFrZUVtcHR5OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5taW4ueCA9IHRoaXMubWluLnkgPSB0aGlzLm1pbi56ID0gKyBJbmZpbml0eTtcXG5cXHRcXHRcXHR0aGlzLm1heC54ID0gdGhpcy5tYXgueSA9IHRoaXMubWF4LnogPSAtIEluZmluaXR5O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0aXNFbXB0eTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIHRoaXMgaXMgYSBtb3JlIHJvYnVzdCBjaGVjayBmb3IgZW1wdHkgdGhhbiAoIHZvbHVtZSA8PSAwICkgYmVjYXVzZSB2b2x1bWUgY2FuIGdldCBwb3NpdGl2ZSB3aXRoIHR3byBuZWdhdGl2ZSBheGVzXFxuXFxuXFx0XFx0XFx0cmV0dXJuICggdGhpcy5tYXgueCA8IHRoaXMubWluLnggKSB8fCAoIHRoaXMubWF4LnkgPCB0aGlzLm1pbi55ICkgfHwgKCB0aGlzLm1heC56IDwgdGhpcy5taW4ueiApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHJlc3VsdC5zZXQoIDAsIDAsIDAgKSA6IHJlc3VsdC5hZGRWZWN0b3JzKCB0aGlzLm1pbiwgdGhpcy5tYXggKS5tdWx0aXBseVNjYWxhciggMC41ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRTaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmlzRW1wdHkoKSA/IHJlc3VsdC5zZXQoIDAsIDAsIDAgKSA6IHJlc3VsdC5zdWJWZWN0b3JzKCB0aGlzLm1heCwgdGhpcy5taW4gKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGV4cGFuZEJ5UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5taW4ubWluKCBwb2ludCApO1xcblxcdFxcdFxcdHRoaXMubWF4Lm1heCggcG9pbnQgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGV4cGFuZEJ5VmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm1pbi5zdWIoIHZlY3RvciApO1xcblxcdFxcdFxcdHRoaXMubWF4LmFkZCggdmVjdG9yICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRleHBhbmRCeVNjYWxhcjogZnVuY3Rpb24gKCBzY2FsYXIgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5taW4uYWRkU2NhbGFyKCAtIHNjYWxhciApO1xcblxcdFxcdFxcdHRoaXMubWF4LmFkZFNjYWxhciggc2NhbGFyICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRleHBhbmRCeU9iamVjdDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIENvbXB1dGVzIHRoZSB3b3JsZC1heGlzLWFsaWduZWQgYm91bmRpbmcgYm94IG9mIGFuIG9iamVjdCAoaW5jbHVkaW5nIGl0cyBjaGlsZHJlbiksXFxuXFx0XFx0XFx0Ly8gYWNjb3VudGluZyBmb3IgYm90aCB0aGUgb2JqZWN0J3MsIGFuZCBjaGlsZHJlbidzLCB3b3JsZCB0cmFuc2Zvcm1zXFxuXFxuXFx0XFx0XFx0dmFyIHNjb3BlLCBpLCBsO1xcblxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gdHJhdmVyc2UoIG5vZGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gbm9kZS5nZW9tZXRyeTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIGkgPSAwLCBsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2MS5jb3B5KCB2ZXJ0aWNlc1sgaSBdICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0djEuYXBwbHlNYXRyaXg0KCBub2RlLm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2NvcGUuZXhwYW5kQnlQb2ludCggdjEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgYXR0cmlidXRlID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIGkgPSAwLCBsID0gYXR0cmlidXRlLmNvdW50OyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2MS5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGkgKS5hcHBseU1hdHJpeDQoIG5vZGUubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzY29wZS5leHBhbmRCeVBvaW50KCB2MSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGV4cGFuZEJ5T2JqZWN0KCBvYmplY3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c2NvcGUgPSB0aGlzO1xcblxcblxcdFxcdFxcdFxcdG9iamVjdC51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xcblxcblxcdFxcdFxcdFxcdG9iamVjdC50cmF2ZXJzZSggdHJhdmVyc2UgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRjb250YWluc1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xcblxcblxcdFxcdFxcdHJldHVybiBwb2ludC54IDwgdGhpcy5taW4ueCB8fCBwb2ludC54ID4gdGhpcy5tYXgueCB8fFxcblxcdFxcdFxcdFxcdHBvaW50LnkgPCB0aGlzLm1pbi55IHx8IHBvaW50LnkgPiB0aGlzLm1heC55IHx8XFxuXFx0XFx0XFx0XFx0cG9pbnQueiA8IHRoaXMubWluLnogfHwgcG9pbnQueiA+IHRoaXMubWF4LnogPyBmYWxzZSA6IHRydWU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb250YWluc0JveDogZnVuY3Rpb24gKCBib3ggKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubWluLnggPD0gYm94Lm1pbi54ICYmIGJveC5tYXgueCA8PSB0aGlzLm1heC54ICYmXFxuXFx0XFx0XFx0XFx0dGhpcy5taW4ueSA8PSBib3gubWluLnkgJiYgYm94Lm1heC55IDw9IHRoaXMubWF4LnkgJiZcXG5cXHRcXHRcXHRcXHR0aGlzLm1pbi56IDw9IGJveC5taW4ueiAmJiBib3gubWF4LnogPD0gdGhpcy5tYXguejtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldFBhcmFtZXRlcjogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gVGhpcyBjYW4gcG90ZW50aWFsbHkgaGF2ZSBhIGRpdmlkZSBieSB6ZXJvIGlmIHRoZSBib3hcXG5cXHRcXHRcXHQvLyBoYXMgYSBzaXplIGRpbWVuc2lvbiBvZiAwLlxcblxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiByZXN1bHQuc2V0KFxcblxcdFxcdFxcdFxcdCggcG9pbnQueCAtIHRoaXMubWluLnggKSAvICggdGhpcy5tYXgueCAtIHRoaXMubWluLnggKSxcXG5cXHRcXHRcXHRcXHQoIHBvaW50LnkgLSB0aGlzLm1pbi55ICkgLyAoIHRoaXMubWF4LnkgLSB0aGlzLm1pbi55ICksXFxuXFx0XFx0XFx0XFx0KCBwb2ludC56IC0gdGhpcy5taW4ueiApIC8gKCB0aGlzLm1heC56IC0gdGhpcy5taW4ueiApXFxuXFx0XFx0XFx0KTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xcblxcblxcdFxcdFxcdC8vIHVzaW5nIDYgc3BsaXR0aW5nIHBsYW5lcyB0byBydWxlIG91dCBpbnRlcnNlY3Rpb25zLlxcblxcdFxcdFxcdHJldHVybiBib3gubWF4LnggPCB0aGlzLm1pbi54IHx8IGJveC5taW4ueCA+IHRoaXMubWF4LnggfHxcXG5cXHRcXHRcXHRcXHRib3gubWF4LnkgPCB0aGlzLm1pbi55IHx8IGJveC5taW4ueSA+IHRoaXMubWF4LnkgfHxcXG5cXHRcXHRcXHRcXHRib3gubWF4LnogPCB0aGlzLm1pbi56IHx8IGJveC5taW4ueiA+IHRoaXMubWF4LnogPyBmYWxzZSA6IHRydWU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpbnRlcnNlY3RzU3BoZXJlOiAoIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgY2xvc2VzdFBvaW50ID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkge1xcblxcblxcdFxcdFxcdFxcdC8vIEZpbmQgdGhlIHBvaW50IG9uIHRoZSBBQUJCIGNsb3Nlc3QgdG8gdGhlIHNwaGVyZSBjZW50ZXIuXFxuXFx0XFx0XFx0XFx0dGhpcy5jbGFtcFBvaW50KCBzcGhlcmUuY2VudGVyLCBjbG9zZXN0UG9pbnQgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBJZiB0aGF0IHBvaW50IGlzIGluc2lkZSB0aGUgc3BoZXJlLCB0aGUgQUFCQiBhbmQgc3BoZXJlIGludGVyc2VjdC5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gY2xvc2VzdFBvaW50LmRpc3RhbmNlVG9TcXVhcmVkKCBzcGhlcmUuY2VudGVyICkgPD0gKCBzcGhlcmUucmFkaXVzICogc3BoZXJlLnJhZGl1cyApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSApKCksXFxuXFxuXFx0XFx0aW50ZXJzZWN0c1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xcblxcblxcdFxcdFxcdC8vIFdlIGNvbXB1dGUgdGhlIG1pbmltdW0gYW5kIG1heGltdW0gZG90IHByb2R1Y3QgdmFsdWVzLiBJZiB0aG9zZSB2YWx1ZXNcXG5cXHRcXHRcXHQvLyBhcmUgb24gdGhlIHNhbWUgc2lkZSAoYmFjayBvciBmcm9udCkgb2YgdGhlIHBsYW5lLCB0aGVuIHRoZXJlIGlzIG5vIGludGVyc2VjdGlvbi5cXG5cXG5cXHRcXHRcXHR2YXIgbWluLCBtYXg7XFxuXFxuXFx0XFx0XFx0aWYgKCBwbGFuZS5ub3JtYWwueCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bWluID0gcGxhbmUubm9ybWFsLnggKiB0aGlzLm1pbi54O1xcblxcdFxcdFxcdFxcdG1heCA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdG1pbiA9IHBsYW5lLm5vcm1hbC54ICogdGhpcy5tYXgueDtcXG5cXHRcXHRcXHRcXHRtYXggPSBwbGFuZS5ub3JtYWwueCAqIHRoaXMubWluLng7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggcGxhbmUubm9ybWFsLnkgPiAwICkge1xcblxcblxcdFxcdFxcdFxcdG1pbiArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWluLnk7XFxuXFx0XFx0XFx0XFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5tYXgueTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdG1pbiArPSBwbGFuZS5ub3JtYWwueSAqIHRoaXMubWF4Lnk7XFxuXFx0XFx0XFx0XFx0bWF4ICs9IHBsYW5lLm5vcm1hbC55ICogdGhpcy5taW4ueTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBwbGFuZS5ub3JtYWwueiA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5taW4uejtcXG5cXHRcXHRcXHRcXHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1heC56O1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0bWluICs9IHBsYW5lLm5vcm1hbC56ICogdGhpcy5tYXguejtcXG5cXHRcXHRcXHRcXHRtYXggKz0gcGxhbmUubm9ybWFsLnogKiB0aGlzLm1pbi56O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gKCBtaW4gPD0gcGxhbmUuY29uc3RhbnQgJiYgbWF4ID49IHBsYW5lLmNvbnN0YW50ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0LmNvcHkoIHBvaW50ICkuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgY2xhbXBlZFBvaW50ID0gdjEuY29weSggcG9pbnQgKS5jbGFtcCggdGhpcy5taW4sIHRoaXMubWF4ICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNsYW1wZWRQb2ludC5zdWIoIHBvaW50ICkubGVuZ3RoKCk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0Z2V0Qm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBnZXRCb3VuZGluZ1NwaGVyZSggb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBTcGhlcmUoKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmdldENlbnRlciggcmVzdWx0LmNlbnRlciApO1xcblxcblxcdFxcdFxcdFxcdHJlc3VsdC5yYWRpdXMgPSB0aGlzLmdldFNpemUoIHYxICkubGVuZ3RoKCkgKiAwLjU7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uICggYm94ICkge1xcblxcblxcdFxcdFxcdHRoaXMubWluLm1heCggYm94Lm1pbiApO1xcblxcdFxcdFxcdHRoaXMubWF4Lm1pbiggYm94Lm1heCApO1xcblxcblxcdFxcdFxcdC8vIGVuc3VyZSB0aGF0IGlmIHRoZXJlIGlzIG5vIG92ZXJsYXAsIHRoZSByZXN1bHQgaXMgZnVsbHkgZW1wdHksIG5vdCBzbGlnaHRseSBlbXB0eSB3aXRoIG5vbi1pbmYvK2luZiB2YWx1ZXMgdGhhdCB3aWxsIGNhdXNlIHN1YnNlcXVlbmNlIGludGVyc2VjdHMgdG8gZXJyb25lb3VzbHkgcmV0dXJuIHZhbGlkIHZhbHVlcy5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuaXNFbXB0eSgpICkgdGhpcy5tYWtlRW1wdHkoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHVuaW9uOiBmdW5jdGlvbiAoIGJveCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm1pbi5taW4oIGJveC5taW4gKTtcXG5cXHRcXHRcXHR0aGlzLm1heC5tYXgoIGJveC5tYXggKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFwcGx5TWF0cml4NDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBwb2ludHMgPSBbXFxuXFx0XFx0XFx0XFx0bmV3IFZlY3RvcjMoKSxcXG5cXHRcXHRcXHRcXHRuZXcgVmVjdG9yMygpLFxcblxcdFxcdFxcdFxcdG5ldyBWZWN0b3IzKCksXFxuXFx0XFx0XFx0XFx0bmV3IFZlY3RvcjMoKSxcXG5cXHRcXHRcXHRcXHRuZXcgVmVjdG9yMygpLFxcblxcdFxcdFxcdFxcdG5ldyBWZWN0b3IzKCksXFxuXFx0XFx0XFx0XFx0bmV3IFZlY3RvcjMoKSxcXG5cXHRcXHRcXHRcXHRuZXcgVmVjdG9yMygpXFxuXFx0XFx0XFx0XTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gYXBwbHlNYXRyaXg0KCBtYXRyaXggKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdHJhbnNmb3JtIG9mIGVtcHR5IGJveCBpcyBhbiBlbXB0eSBib3guXFxuXFx0XFx0XFx0XFx0aWYgKCB0aGlzLmlzRW1wdHkoKSApIHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdFxcdC8vIE5PVEU6IEkgYW0gdXNpbmcgYSBiaW5hcnkgcGF0dGVybiB0byBzcGVjaWZ5IGFsbCAyXjMgY29tYmluYXRpb25zIGJlbG93XFxuXFx0XFx0XFx0XFx0cG9pbnRzWyAwIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAwXFxuXFx0XFx0XFx0XFx0cG9pbnRzWyAxIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDAxXFxuXFx0XFx0XFx0XFx0cG9pbnRzWyAyIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDEwXFxuXFx0XFx0XFx0XFx0cG9pbnRzWyAzIF0uc2V0KCB0aGlzLm1pbi54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMDExXFxuXFx0XFx0XFx0XFx0cG9pbnRzWyA0IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAwXFxuXFx0XFx0XFx0XFx0cG9pbnRzWyA1IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1pbi55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTAxXFxuXFx0XFx0XFx0XFx0cG9pbnRzWyA2IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1pbi56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTsgLy8gMTEwXFxuXFx0XFx0XFx0XFx0cG9pbnRzWyA3IF0uc2V0KCB0aGlzLm1heC54LCB0aGlzLm1heC55LCB0aGlzLm1heC56ICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcXHQvLyAxMTFcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnNldEZyb21Qb2ludHMoIHBvaW50cyApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5taW4uYWRkKCBvZmZzZXQgKTtcXG5cXHRcXHRcXHR0aGlzLm1heC5hZGQoIG9mZnNldCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZXF1YWxzOiBmdW5jdGlvbiAoIGJveCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYm94Lm1pbi5lcXVhbHMoIHRoaXMubWluICkgJiYgYm94Lm1heC5lcXVhbHMoIHRoaXMubWF4ICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBTcGhlcmUoIGNlbnRlciwgcmFkaXVzICkge1xcblxcblxcdFxcdHRoaXMuY2VudGVyID0gKCBjZW50ZXIgIT09IHVuZGVmaW5lZCApID8gY2VudGVyIDogbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR0aGlzLnJhZGl1cyA9ICggcmFkaXVzICE9PSB1bmRlZmluZWQgKSA/IHJhZGl1cyA6IDA7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIFNwaGVyZS5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggY2VudGVyLCByYWRpdXMgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jZW50ZXIuY29weSggY2VudGVyICk7XFxuXFx0XFx0XFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tUG9pbnRzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGJveCA9IG5ldyBCb3gzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHNldEZyb21Qb2ludHMoIHBvaW50cywgb3B0aW9uYWxDZW50ZXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGNlbnRlciA9IHRoaXMuY2VudGVyO1xcblxcblxcdFxcdFxcdFxcdGlmICggb3B0aW9uYWxDZW50ZXIgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjZW50ZXIuY29weSggb3B0aW9uYWxDZW50ZXIgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdGJveC5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKS5nZXRDZW50ZXIoIGNlbnRlciApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgbWF4UmFkaXVzU3EgPSAwO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bWF4UmFkaXVzU3EgPSBNYXRoLm1heCggbWF4UmFkaXVzU3EsIGNlbnRlci5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnRzWyBpIF0gKSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnJhZGl1cyA9IE1hdGguc3FydCggbWF4UmFkaXVzU3EgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc3BoZXJlICkge1xcblxcblxcdFxcdFxcdHRoaXMuY2VudGVyLmNvcHkoIHNwaGVyZS5jZW50ZXIgKTtcXG5cXHRcXHRcXHR0aGlzLnJhZGl1cyA9IHNwaGVyZS5yYWRpdXM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRlbXB0eTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiAoIHRoaXMucmFkaXVzIDw9IDAgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuICggcG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCB0aGlzLnJhZGl1cyAqIHRoaXMucmFkaXVzICkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRpc3RhbmNlVG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gKCBwb2ludC5kaXN0YW5jZVRvKCB0aGlzLmNlbnRlciApIC0gdGhpcy5yYWRpdXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xcblxcblxcdFxcdFxcdHZhciByYWRpdXNTdW0gPSB0aGlzLnJhZGl1cyArIHNwaGVyZS5yYWRpdXM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuY2VudGVyICkgPD0gKCByYWRpdXNTdW0gKiByYWRpdXNTdW0gKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICggYm94ICkge1xcblxcblxcdFxcdFxcdHJldHVybiBib3guaW50ZXJzZWN0c1NwaGVyZSggdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0aW50ZXJzZWN0c1BsYW5lOiBmdW5jdGlvbiAoIHBsYW5lICkge1xcblxcblxcdFxcdFxcdHJldHVybiBNYXRoLmFicyggcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLmNlbnRlciApICkgPD0gdGhpcy5yYWRpdXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbGFtcFBvaW50OiBmdW5jdGlvbiAoIHBvaW50LCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZGVsdGFMZW5ndGhTcSA9IHRoaXMuY2VudGVyLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xcblxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJlc3VsdC5jb3B5KCBwb2ludCApO1xcblxcblxcdFxcdFxcdGlmICggZGVsdGFMZW5ndGhTcSA+ICggdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cyApICkge1xcblxcblxcdFxcdFxcdFxcdHJlc3VsdC5zdWIoIHRoaXMuY2VudGVyICkubm9ybWFsaXplKCk7XFxuXFx0XFx0XFx0XFx0cmVzdWx0Lm11bHRpcGx5U2NhbGFyKCB0aGlzLnJhZGl1cyApLmFkZCggdGhpcy5jZW50ZXIgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldEJvdW5kaW5nQm94OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHZhciBib3ggPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgQm94MygpO1xcblxcblxcdFxcdFxcdGJveC5zZXQoIHRoaXMuY2VudGVyLCB0aGlzLmNlbnRlciApO1xcblxcdFxcdFxcdGJveC5leHBhbmRCeVNjYWxhciggdGhpcy5yYWRpdXMgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYm94O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmNlbnRlci5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xcblxcdFxcdFxcdHRoaXMucmFkaXVzID0gdGhpcy5yYWRpdXMgKiBtYXRyaXguZ2V0TWF4U2NhbGVPbkF4aXMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jZW50ZXIuYWRkKCBvZmZzZXQgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGVxdWFsczogZnVuY3Rpb24gKCBzcGhlcmUgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHNwaGVyZS5jZW50ZXIuZXF1YWxzKCB0aGlzLmNlbnRlciApICYmICggc3BoZXJlLnJhZGl1cyA9PT0gdGhpcy5yYWRpdXMgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBQbGFuZSggbm9ybWFsLCBjb25zdGFudCApIHtcXG5cXG5cXHRcXHQvLyBub3JtYWwgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXFxuXFxuXFx0XFx0dGhpcy5ub3JtYWwgPSAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkgPyBub3JtYWwgOiBuZXcgVmVjdG9yMyggMSwgMCwgMCApO1xcblxcdFxcdHRoaXMuY29uc3RhbnQgPSAoIGNvbnN0YW50ICE9PSB1bmRlZmluZWQgKSA/IGNvbnN0YW50IDogMDtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggUGxhbmUucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIG5vcm1hbCwgY29uc3RhbnQgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5ub3JtYWwuY29weSggbm9ybWFsICk7XFxuXFx0XFx0XFx0dGhpcy5jb25zdGFudCA9IGNvbnN0YW50O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0Q29tcG9uZW50czogZnVuY3Rpb24gKCB4LCB5LCB6LCB3ICkge1xcblxcblxcdFxcdFxcdHRoaXMubm9ybWFsLnNldCggeCwgeSwgeiApO1xcblxcdFxcdFxcdHRoaXMuY29uc3RhbnQgPSB3O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQ6IGZ1bmN0aW9uICggbm9ybWFsLCBwb2ludCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm5vcm1hbC5jb3B5KCBub3JtYWwgKTtcXG5cXHRcXHRcXHR0aGlzLmNvbnN0YW50ID0gLSBwb2ludC5kb3QoIHRoaXMubm9ybWFsICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tQ29wbGFuYXJQb2ludHM6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHNldEZyb21Db3BsYW5hclBvaW50cyggYSwgYiwgYyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbm9ybWFsID0gdjEuc3ViVmVjdG9ycyggYywgYiApLmNyb3NzKCB2Mi5zdWJWZWN0b3JzKCBhLCBiICkgKS5ub3JtYWxpemUoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBROiBzaG91bGQgYW4gZXJyb3IgYmUgdGhyb3duIGlmIG5vcm1hbCBpcyB6ZXJvIChlLmcuIGRlZ2VuZXJhdGUgcGxhbmUpP1xcblxcblxcdFxcdFxcdFxcdHRoaXMuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIG5vcm1hbCwgYSApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBwbGFuZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm5vcm1hbC5jb3B5KCBwbGFuZS5ub3JtYWwgKTtcXG5cXHRcXHRcXHR0aGlzLmNvbnN0YW50ID0gcGxhbmUuY29uc3RhbnQ7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRub3JtYWxpemU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyBOb3RlOiB3aWxsIGxlYWQgdG8gYSBkaXZpZGUgYnkgemVybyBpZiB0aGUgcGxhbmUgaXMgaW52YWxpZC5cXG5cXG5cXHRcXHRcXHR2YXIgaW52ZXJzZU5vcm1hbExlbmd0aCA9IDEuMCAvIHRoaXMubm9ybWFsLmxlbmd0aCgpO1xcblxcdFxcdFxcdHRoaXMubm9ybWFsLm11bHRpcGx5U2NhbGFyKCBpbnZlcnNlTm9ybWFsTGVuZ3RoICk7XFxuXFx0XFx0XFx0dGhpcy5jb25zdGFudCAqPSBpbnZlcnNlTm9ybWFsTGVuZ3RoO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bmVnYXRlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jb25zdGFudCAqPSAtIDE7XFxuXFx0XFx0XFx0dGhpcy5ub3JtYWwubmVnYXRlKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXN0YW5jZVRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubm9ybWFsLmRvdCggcG9pbnQgKSArIHRoaXMuY29uc3RhbnQ7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXN0YW5jZVRvU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIHNwaGVyZS5jZW50ZXIgKSAtIHNwaGVyZS5yYWRpdXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwcm9qZWN0UG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggLSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSApLmFkZCggcG9pbnQgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGludGVyc2VjdExpbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RMaW5lKCBsaW5lLCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZGlyZWN0aW9uID0gbGluZS5kZWx0YSggdjEgKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZGVub21pbmF0b3IgPSB0aGlzLm5vcm1hbC5kb3QoIGRpcmVjdGlvbiApO1xcblxcblxcdFxcdFxcdFxcdGlmICggZGVub21pbmF0b3IgPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbGluZSBpcyBjb3BsYW5hciwgcmV0dXJuIG9yaWdpblxcblxcdFxcdFxcdFxcdFxcdGlmICggdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuc3RhcnQgKSA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0LmNvcHkoIGxpbmUuc3RhcnQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVW5zdXJlIGlmIHRoaXMgaXMgdGhlIGNvcnJlY3QgbWV0aG9kIHRvIGhhbmRsZSB0aGlzIGNhc2UuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHVuZGVmaW5lZDtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHQgPSAtICggbGluZS5zdGFydC5kb3QoIHRoaXMubm9ybWFsICkgKyB0aGlzLmNvbnN0YW50ICkgLyBkZW5vbWluYXRvcjtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHQgPCAwIHx8IHQgPiAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQuY29weSggZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIGxpbmUuc3RhcnQgKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRpbnRlcnNlY3RzTGluZTogZnVuY3Rpb24gKCBsaW5lICkge1xcblxcblxcdFxcdFxcdC8vIE5vdGU6IHRoaXMgdGVzdHMgaWYgYSBsaW5lIGludGVyc2VjdHMgdGhlIHBsYW5lLCBub3Qgd2hldGhlciBpdCAob3IgaXRzIGVuZC1wb2ludHMpIGFyZSBjb3BsYW5hciB3aXRoIGl0LlxcblxcblxcdFxcdFxcdHZhciBzdGFydFNpZ24gPSB0aGlzLmRpc3RhbmNlVG9Qb2ludCggbGluZS5zdGFydCApO1xcblxcdFxcdFxcdHZhciBlbmRTaWduID0gdGhpcy5kaXN0YW5jZVRvUG9pbnQoIGxpbmUuZW5kICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuICggc3RhcnRTaWduIDwgMCAmJiBlbmRTaWduID4gMCApIHx8ICggZW5kU2lnbiA8IDAgJiYgc3RhcnRTaWduID4gMCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0aW50ZXJzZWN0c0JveDogZnVuY3Rpb24gKCBib3ggKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGJveC5pbnRlcnNlY3RzUGxhbmUoIHRoaXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xcblxcblxcdFxcdFxcdHJldHVybiBzcGhlcmUuaW50ZXJzZWN0c1BsYW5lKCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3BsYW5hclBvaW50OiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiByZXN1bHQuY29weSggdGhpcy5ub3JtYWwgKS5tdWx0aXBseVNjYWxhciggLSB0aGlzLmNvbnN0YW50ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciBtMSA9IG5ldyBNYXRyaXgzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGFwcGx5TWF0cml4NCggbWF0cml4LCBvcHRpb25hbE5vcm1hbE1hdHJpeCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbm9ybWFsTWF0cml4ID0gb3B0aW9uYWxOb3JtYWxNYXRyaXggfHwgbTEuZ2V0Tm9ybWFsTWF0cml4KCBtYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcmVmZXJlbmNlUG9pbnQgPSB0aGlzLmNvcGxhbmFyUG9pbnQoIHYxICkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbm9ybWFsID0gdGhpcy5ub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmNvbnN0YW50ID0gLSByZWZlcmVuY2VQb2ludC5kb3QoIG5vcm1hbCApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jb25zdGFudCAtPSBvZmZzZXQuZG90KCB0aGlzLm5vcm1hbCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZXF1YWxzOiBmdW5jdGlvbiAoIHBsYW5lICkge1xcblxcblxcdFxcdFxcdHJldHVybiBwbGFuZS5ub3JtYWwuZXF1YWxzKCB0aGlzLm5vcm1hbCApICYmICggcGxhbmUuY29uc3RhbnQgPT09IHRoaXMuY29uc3RhbnQgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gRnJ1c3R1bSggcDAsIHAxLCBwMiwgcDMsIHA0LCBwNSApIHtcXG5cXG5cXHRcXHR0aGlzLnBsYW5lcyA9IFtcXG5cXG5cXHRcXHRcXHQoIHAwICE9PSB1bmRlZmluZWQgKSA/IHAwIDogbmV3IFBsYW5lKCksXFxuXFx0XFx0XFx0KCBwMSAhPT0gdW5kZWZpbmVkICkgPyBwMSA6IG5ldyBQbGFuZSgpLFxcblxcdFxcdFxcdCggcDIgIT09IHVuZGVmaW5lZCApID8gcDIgOiBuZXcgUGxhbmUoKSxcXG5cXHRcXHRcXHQoIHAzICE9PSB1bmRlZmluZWQgKSA/IHAzIDogbmV3IFBsYW5lKCksXFxuXFx0XFx0XFx0KCBwNCAhPT0gdW5kZWZpbmVkICkgPyBwNCA6IG5ldyBQbGFuZSgpLFxcblxcdFxcdFxcdCggcDUgIT09IHVuZGVmaW5lZCApID8gcDUgOiBuZXcgUGxhbmUoKVxcblxcblxcdFxcdF07XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIEZydXN0dW0ucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIHAwLCBwMSwgcDIsIHAzLCBwNCwgcDUgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xcblxcblxcdFxcdFxcdHBsYW5lc1sgMCBdLmNvcHkoIHAwICk7XFxuXFx0XFx0XFx0cGxhbmVzWyAxIF0uY29weSggcDEgKTtcXG5cXHRcXHRcXHRwbGFuZXNbIDIgXS5jb3B5KCBwMiApO1xcblxcdFxcdFxcdHBsYW5lc1sgMyBdLmNvcHkoIHAzICk7XFxuXFx0XFx0XFx0cGxhbmVzWyA0IF0uY29weSggcDQgKTtcXG5cXHRcXHRcXHRwbGFuZXNbIDUgXS5jb3B5KCBwNSApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIGZydXN0dW0gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHBsYW5lcyA9IHRoaXMucGxhbmVzO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cGxhbmVzWyBpIF0uY29weSggZnJ1c3R1bS5wbGFuZXNbIGkgXSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XFxuXFx0XFx0XFx0dmFyIG1lID0gbS5lbGVtZW50cztcXG5cXHRcXHRcXHR2YXIgbWUwID0gbWVbIDAgXSwgbWUxID0gbWVbIDEgXSwgbWUyID0gbWVbIDIgXSwgbWUzID0gbWVbIDMgXTtcXG5cXHRcXHRcXHR2YXIgbWU0ID0gbWVbIDQgXSwgbWU1ID0gbWVbIDUgXSwgbWU2ID0gbWVbIDYgXSwgbWU3ID0gbWVbIDcgXTtcXG5cXHRcXHRcXHR2YXIgbWU4ID0gbWVbIDggXSwgbWU5ID0gbWVbIDkgXSwgbWUxMCA9IG1lWyAxMCBdLCBtZTExID0gbWVbIDExIF07XFxuXFx0XFx0XFx0dmFyIG1lMTIgPSBtZVsgMTIgXSwgbWUxMyA9IG1lWyAxMyBdLCBtZTE0ID0gbWVbIDE0IF0sIG1lMTUgPSBtZVsgMTUgXTtcXG5cXG5cXHRcXHRcXHRwbGFuZXNbIDAgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTAsIG1lNyAtIG1lNCwgbWUxMSAtIG1lOCwgbWUxNSAtIG1lMTIgKS5ub3JtYWxpemUoKTtcXG5cXHRcXHRcXHRwbGFuZXNbIDEgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTAsIG1lNyArIG1lNCwgbWUxMSArIG1lOCwgbWUxNSArIG1lMTIgKS5ub3JtYWxpemUoKTtcXG5cXHRcXHRcXHRwbGFuZXNbIDIgXS5zZXRDb21wb25lbnRzKCBtZTMgKyBtZTEsIG1lNyArIG1lNSwgbWUxMSArIG1lOSwgbWUxNSArIG1lMTMgKS5ub3JtYWxpemUoKTtcXG5cXHRcXHRcXHRwbGFuZXNbIDMgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTEsIG1lNyAtIG1lNSwgbWUxMSAtIG1lOSwgbWUxNSAtIG1lMTMgKS5ub3JtYWxpemUoKTtcXG5cXHRcXHRcXHRwbGFuZXNbIDQgXS5zZXRDb21wb25lbnRzKCBtZTMgLSBtZTIsIG1lNyAtIG1lNiwgbWUxMSAtIG1lMTAsIG1lMTUgLSBtZTE0ICkubm9ybWFsaXplKCk7XFxuXFx0XFx0XFx0cGxhbmVzWyA1IF0uc2V0Q29tcG9uZW50cyggbWUzICsgbWUyLCBtZTcgKyBtZTYsIG1lMTEgKyBtZTEwLCBtZTE1ICsgbWUxNCApLm5vcm1hbGl6ZSgpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0aW50ZXJzZWN0c09iamVjdDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdHNPYmplY3QoIG9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApXFxuXFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XFxuXFxuXFx0XFx0XFx0XFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlIClcXG5cXHRcXHRcXHRcXHRcXHQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRpbnRlcnNlY3RzU3ByaXRlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c1Nwcml0ZSggc3ByaXRlICkge1xcblxcblxcdFxcdFxcdFxcdHNwaGVyZS5jZW50ZXIuc2V0KCAwLCAwLCAwICk7XFxuXFx0XFx0XFx0XFx0c3BoZXJlLnJhZGl1cyA9IDAuNzA3MTA2NzgxMTg2NTQ3NjtcXG5cXHRcXHRcXHRcXHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBzcHJpdGUubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRpbnRlcnNlY3RzU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XFxuXFx0XFx0XFx0dmFyIGNlbnRlciA9IHNwaGVyZS5jZW50ZXI7XFxuXFx0XFx0XFx0dmFyIG5lZ1JhZGl1cyA9IC0gc3BoZXJlLnJhZGl1cztcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBkaXN0YW5jZSA9IHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggY2VudGVyICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBkaXN0YW5jZSA8IG5lZ1JhZGl1cyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGludGVyc2VjdHNCb3g6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgcDEgPSBuZXcgVmVjdG9yMygpLFxcblxcdFxcdFxcdFxcdHAyID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c0JveCggYm94ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBwbGFuZXMgPSB0aGlzLnBsYW5lcztcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBwbGFuZSA9IHBsYW5lc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdHAxLnggPSBwbGFuZS5ub3JtYWwueCA+IDAgPyBib3gubWluLnggOiBib3gubWF4Lng7XFxuXFx0XFx0XFx0XFx0XFx0cDIueCA9IHBsYW5lLm5vcm1hbC54ID4gMCA/IGJveC5tYXgueCA6IGJveC5taW4ueDtcXG5cXHRcXHRcXHRcXHRcXHRwMS55ID0gcGxhbmUubm9ybWFsLnkgPiAwID8gYm94Lm1pbi55IDogYm94Lm1heC55O1xcblxcdFxcdFxcdFxcdFxcdHAyLnkgPSBwbGFuZS5ub3JtYWwueSA+IDAgPyBib3gubWF4LnkgOiBib3gubWluLnk7XFxuXFx0XFx0XFx0XFx0XFx0cDEueiA9IHBsYW5lLm5vcm1hbC56ID4gMCA/IGJveC5taW4ueiA6IGJveC5tYXguejtcXG5cXHRcXHRcXHRcXHRcXHRwMi56ID0gcGxhbmUubm9ybWFsLnogPiAwID8gYm94Lm1heC56IDogYm94Lm1pbi56O1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBkMSA9IHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggcDEgKTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZDIgPSBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHAyICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaWYgYm90aCBvdXRzaWRlIHBsYW5lLCBubyBpbnRlcnNlY3Rpb25cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGQxIDwgMCAmJiBkMiA8IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcGxhbmVzID0gdGhpcy5wbGFuZXM7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHBsYW5lc1sgaSBdLmRpc3RhbmNlVG9Qb2ludCggcG9pbnQgKSA8IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gV2ViR0xTaGFkb3dNYXAoIF9yZW5kZXJlciwgX29iamVjdHMsIG1heFRleHR1cmVTaXplICkge1xcblxcblxcdFxcdHZhciBfZnJ1c3R1bSA9IG5ldyBGcnVzdHVtKCksXFxuXFx0XFx0XFx0X3Byb2pTY3JlZW5NYXRyaXggPSBuZXcgTWF0cml4NCgpLFxcblxcblxcdFxcdFxcdF9zaGFkb3dNYXBTaXplID0gbmV3IFZlY3RvcjIoKSxcXG5cXHRcXHRcXHRfbWF4U2hhZG93TWFwU2l6ZSA9IG5ldyBWZWN0b3IyKCBtYXhUZXh0dXJlU2l6ZSwgbWF4VGV4dHVyZVNpemUgKSxcXG5cXG5cXHRcXHRcXHRfbG9va1RhcmdldCA9IG5ldyBWZWN0b3IzKCksXFxuXFx0XFx0XFx0X2xpZ2h0UG9zaXRpb25Xb3JsZCA9IG5ldyBWZWN0b3IzKCksXFxuXFxuXFx0XFx0XFx0X01vcnBoaW5nRmxhZyA9IDEsXFxuXFx0XFx0XFx0X1NraW5uaW5nRmxhZyA9IDIsXFxuXFxuXFx0XFx0XFx0X051bWJlck9mTWF0ZXJpYWxWYXJpYW50cyA9ICggX01vcnBoaW5nRmxhZyB8IF9Ta2lubmluZ0ZsYWcgKSArIDEsXFxuXFxuXFx0XFx0XFx0X2RlcHRoTWF0ZXJpYWxzID0gbmV3IEFycmF5KCBfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzICksXFxuXFx0XFx0XFx0X2Rpc3RhbmNlTWF0ZXJpYWxzID0gbmV3IEFycmF5KCBfTnVtYmVyT2ZNYXRlcmlhbFZhcmlhbnRzICksXFxuXFxuXFx0XFx0XFx0X21hdGVyaWFsQ2FjaGUgPSB7fTtcXG5cXG5cXHRcXHR2YXIgY3ViZURpcmVjdGlvbnMgPSBbXFxuXFx0XFx0XFx0bmV3IFZlY3RvcjMoIDEsIDAsIDAgKSwgbmV3IFZlY3RvcjMoIC0gMSwgMCwgMCApLCBuZXcgVmVjdG9yMyggMCwgMCwgMSApLFxcblxcdFxcdFxcdG5ldyBWZWN0b3IzKCAwLCAwLCAtIDEgKSwgbmV3IFZlY3RvcjMoIDAsIDEsIDAgKSwgbmV3IFZlY3RvcjMoIDAsIC0gMSwgMCApXFxuXFx0XFx0XTtcXG5cXG5cXHRcXHR2YXIgY3ViZVVwcyA9IFtcXG5cXHRcXHRcXHRuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMSwgMCApLCBuZXcgVmVjdG9yMyggMCwgMSwgMCApLFxcblxcdFxcdFxcdG5ldyBWZWN0b3IzKCAwLCAxLCAwICksIG5ldyBWZWN0b3IzKCAwLCAwLCAxICksXFx0bmV3IFZlY3RvcjMoIDAsIDAsIC0gMSApXFxuXFx0XFx0XTtcXG5cXG5cXHRcXHR2YXIgY3ViZTJEVmlld1BvcnRzID0gW1xcblxcdFxcdFxcdG5ldyBWZWN0b3I0KCksIG5ldyBWZWN0b3I0KCksIG5ldyBWZWN0b3I0KCksXFxuXFx0XFx0XFx0bmV3IFZlY3RvcjQoKSwgbmV3IFZlY3RvcjQoKSwgbmV3IFZlY3RvcjQoKVxcblxcdFxcdF07XFxuXFxuXFx0XFx0Ly8gaW5pdFxcblxcblxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gX051bWJlck9mTWF0ZXJpYWxWYXJpYW50czsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdXNlTW9ycGhpbmcgPSAoIGkgJiBfTW9ycGhpbmdGbGFnICkgIT09IDA7XFxuXFx0XFx0XFx0dmFyIHVzZVNraW5uaW5nID0gKCBpICYgX1NraW5uaW5nRmxhZyApICE9PSAwO1xcblxcblxcdFxcdFxcdHZhciBkZXB0aE1hdGVyaWFsID0gbmV3IE1lc2hEZXB0aE1hdGVyaWFsKCB7XFxuXFxuXFx0XFx0XFx0XFx0ZGVwdGhQYWNraW5nOiBSR0JBRGVwdGhQYWNraW5nLFxcblxcblxcdFxcdFxcdFxcdG1vcnBoVGFyZ2V0czogdXNlTW9ycGhpbmcsXFxuXFx0XFx0XFx0XFx0c2tpbm5pbmc6IHVzZVNraW5uaW5nXFxuXFxuXFx0XFx0XFx0fSApO1xcblxcblxcdFxcdFxcdF9kZXB0aE1hdGVyaWFsc1sgaSBdID0gZGVwdGhNYXRlcmlhbDtcXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdHZhciBkaXN0YW5jZU1hdGVyaWFsID0gbmV3IE1lc2hEaXN0YW5jZU1hdGVyaWFsKCB7XFxuXFxuXFx0XFx0XFx0XFx0bW9ycGhUYXJnZXRzOiB1c2VNb3JwaGluZyxcXG5cXHRcXHRcXHRcXHRza2lubmluZzogdXNlU2tpbm5pbmdcXG5cXG5cXHRcXHRcXHR9ICk7XFxuXFxuXFx0XFx0XFx0X2Rpc3RhbmNlTWF0ZXJpYWxzWyBpIF0gPSBkaXN0YW5jZU1hdGVyaWFsO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvL1xcblxcblxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxuXFxuXFx0XFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XFxuXFxuXFx0XFx0dGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTtcXG5cXHRcXHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gUENGU2hhZG93TWFwO1xcblxcblxcdFxcdHRoaXMucmVuZGVyUmV2ZXJzZVNpZGVkID0gdHJ1ZTtcXG5cXHRcXHR0aGlzLnJlbmRlclNpbmdsZVNpZGVkID0gdHJ1ZTtcXG5cXG5cXHRcXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggbGlnaHRzLCBzY2VuZSwgY2FtZXJhICkge1xcblxcblxcdFxcdFxcdGlmICggc2NvcGUuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XFxuXFx0XFx0XFx0aWYgKCBzY29wZS5hdXRvVXBkYXRlID09PSBmYWxzZSAmJiBzY29wZS5uZWVkc1VwZGF0ZSA9PT0gZmFsc2UgKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0aWYgKCBsaWdodHMubGVuZ3RoID09PSAwICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdC8vIFRPRE8gQ2xlYW4gdXAgKG5lZWRlZCBpbiBjYXNlIG9mIGNvbnRleHRsb3N0KVxcblxcdFxcdFxcdHZhciBfZ2wgPSBfcmVuZGVyZXIuY29udGV4dDtcXG5cXHRcXHRcXHR2YXIgX3N0YXRlID0gX3JlbmRlcmVyLnN0YXRlO1xcblxcblxcdFxcdFxcdC8vIFNldCBHTCBzdGF0ZSBmb3IgZGVwdGggbWFwLlxcblxcdFxcdFxcdF9zdGF0ZS5kaXNhYmxlKCBfZ2wuQkxFTkQgKTtcXG5cXHRcXHRcXHRfc3RhdGUuYnVmZmVycy5jb2xvci5zZXRDbGVhciggMSwgMSwgMSwgMSApO1xcblxcdFxcdFxcdF9zdGF0ZS5idWZmZXJzLmRlcHRoLnNldFRlc3QoIHRydWUgKTtcXG5cXHRcXHRcXHRfc3RhdGUuc2V0U2Npc3NvclRlc3QoIGZhbHNlICk7XFxuXFxuXFx0XFx0XFx0Ly8gcmVuZGVyIGRlcHRoIG1hcFxcblxcblxcdFxcdFxcdHZhciBmYWNlQ291bnQ7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGxpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbGlnaHQgPSBsaWdodHNbIGkgXTtcXG5cXHRcXHRcXHRcXHR2YXIgc2hhZG93ID0gbGlnaHQuc2hhZG93O1xcblxcdFxcdFxcdFxcdHZhciBpc1BvaW50TGlnaHQgPSBsaWdodCAmJiBsaWdodC5pc1BvaW50TGlnaHQ7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBzaGFkb3cgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFNoYWRvd01hcDonLCBsaWdodCwgJ2hhcyBubyBzaGFkb3cuJyApO1xcblxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgc2hhZG93Q2FtZXJhID0gc2hhZG93LmNhbWVyYTtcXG5cXG5cXHRcXHRcXHRcXHRfc2hhZG93TWFwU2l6ZS5jb3B5KCBzaGFkb3cubWFwU2l6ZSApO1xcblxcdFxcdFxcdFxcdF9zaGFkb3dNYXBTaXplLm1pbiggX21heFNoYWRvd01hcFNpemUgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGlzUG9pbnRMaWdodCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdnBXaWR0aCA9IF9zaGFkb3dNYXBTaXplLng7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHZwSGVpZ2h0ID0gX3NoYWRvd01hcFNpemUueTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBUaGVzZSB2aWV3cG9ydHMgbWFwIGEgY3ViZS1tYXAgb250byBhIDJEIHRleHR1cmUgd2l0aCB0aGVcXG5cXHRcXHRcXHRcXHRcXHQvLyBmb2xsb3dpbmcgb3JpZW50YXRpb246XFxuXFx0XFx0XFx0XFx0XFx0Ly9cXG5cXHRcXHRcXHRcXHRcXHQvLyAgeHpYWlxcblxcdFxcdFxcdFxcdFxcdC8vICAgeSBZXFxuXFx0XFx0XFx0XFx0XFx0Ly9cXG5cXHRcXHRcXHRcXHRcXHQvLyBYIC0gUG9zaXRpdmUgeCBkaXJlY3Rpb25cXG5cXHRcXHRcXHRcXHRcXHQvLyB4IC0gTmVnYXRpdmUgeCBkaXJlY3Rpb25cXG5cXHRcXHRcXHRcXHRcXHQvLyBZIC0gUG9zaXRpdmUgeSBkaXJlY3Rpb25cXG5cXHRcXHRcXHRcXHRcXHQvLyB5IC0gTmVnYXRpdmUgeSBkaXJlY3Rpb25cXG5cXHRcXHRcXHRcXHRcXHQvLyBaIC0gUG9zaXRpdmUgeiBkaXJlY3Rpb25cXG5cXHRcXHRcXHRcXHRcXHQvLyB6IC0gTmVnYXRpdmUgeiBkaXJlY3Rpb25cXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBwb3NpdGl2ZSBYXFxuXFx0XFx0XFx0XFx0XFx0Y3ViZTJEVmlld1BvcnRzWyAwIF0uc2V0KCB2cFdpZHRoICogMiwgdnBIZWlnaHQsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gbmVnYXRpdmUgWFxcblxcdFxcdFxcdFxcdFxcdGN1YmUyRFZpZXdQb3J0c1sgMSBdLnNldCggMCwgdnBIZWlnaHQsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gcG9zaXRpdmUgWlxcblxcdFxcdFxcdFxcdFxcdGN1YmUyRFZpZXdQb3J0c1sgMiBdLnNldCggdnBXaWR0aCAqIDMsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xcblxcdFxcdFxcdFxcdFxcdC8vIG5lZ2F0aXZlIFpcXG5cXHRcXHRcXHRcXHRcXHRjdWJlMkRWaWV3UG9ydHNbIDMgXS5zZXQoIHZwV2lkdGgsIHZwSGVpZ2h0LCB2cFdpZHRoLCB2cEhlaWdodCApO1xcblxcdFxcdFxcdFxcdFxcdC8vIHBvc2l0aXZlIFlcXG5cXHRcXHRcXHRcXHRcXHRjdWJlMkRWaWV3UG9ydHNbIDQgXS5zZXQoIHZwV2lkdGggKiAzLCAwLCB2cFdpZHRoLCB2cEhlaWdodCApO1xcblxcdFxcdFxcdFxcdFxcdC8vIG5lZ2F0aXZlIFlcXG5cXHRcXHRcXHRcXHRcXHRjdWJlMkRWaWV3UG9ydHNbIDUgXS5zZXQoIHZwV2lkdGgsIDAsIHZwV2lkdGgsIHZwSGVpZ2h0ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0X3NoYWRvd01hcFNpemUueCAqPSA0LjA7XFxuXFx0XFx0XFx0XFx0XFx0X3NoYWRvd01hcFNpemUueSAqPSAyLjA7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggc2hhZG93Lm1hcCA9PT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgcGFycyA9IHsgbWluRmlsdGVyOiBOZWFyZXN0RmlsdGVyLCBtYWdGaWx0ZXI6IE5lYXJlc3RGaWx0ZXIsIGZvcm1hdDogUkdCQUZvcm1hdCB9O1xcblxcblxcdFxcdFxcdFxcdFxcdHNoYWRvdy5tYXAgPSBuZXcgV2ViR0xSZW5kZXJUYXJnZXQoIF9zaGFkb3dNYXBTaXplLngsIF9zaGFkb3dNYXBTaXplLnksIHBhcnMgKTtcXG5cXHRcXHRcXHRcXHRcXHRzaGFkb3cubWFwLnRleHR1cmUubmFtZSA9IGxpZ2h0Lm5hbWUgKyBcXFwiLnNoYWRvd01hcFxcXCI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2hhZG93Q2FtZXJhLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBzaGFkb3cuaXNTcG90TGlnaHRTaGFkb3cgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2hhZG93LnVwZGF0ZSggbGlnaHQgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHNoYWRvd01hcCA9IHNoYWRvdy5tYXA7XFxuXFx0XFx0XFx0XFx0dmFyIHNoYWRvd01hdHJpeCA9IHNoYWRvdy5tYXRyaXg7XFxuXFxuXFx0XFx0XFx0XFx0X2xpZ2h0UG9zaXRpb25Xb3JsZC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XFxuXFx0XFx0XFx0XFx0c2hhZG93Q2FtZXJhLnBvc2l0aW9uLmNvcHkoIF9saWdodFBvc2l0aW9uV29ybGQgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGlzUG9pbnRMaWdodCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmYWNlQ291bnQgPSA2O1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGZvciBwb2ludCBsaWdodHMgd2Ugc2V0IHRoZSBzaGFkb3cgbWF0cml4IHRvIGJlIGEgdHJhbnNsYXRpb24tb25seSBtYXRyaXhcXG5cXHRcXHRcXHRcXHRcXHQvLyBlcXVhbCB0byBpbnZlcnNlIG9mIHRoZSBsaWdodCdzIHBvc2l0aW9uXFxuXFxuXFx0XFx0XFx0XFx0XFx0c2hhZG93TWF0cml4Lm1ha2VUcmFuc2xhdGlvbiggLSBfbGlnaHRQb3NpdGlvbldvcmxkLngsIC0gX2xpZ2h0UG9zaXRpb25Xb3JsZC55LCAtIF9saWdodFBvc2l0aW9uV29ybGQueiApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZUNvdW50ID0gMTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRfbG9va1RhcmdldC5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdFxcdFxcdHNoYWRvd0NhbWVyYS5sb29rQXQoIF9sb29rVGFyZ2V0ICk7XFxuXFx0XFx0XFx0XFx0XFx0c2hhZG93Q2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gY29tcHV0ZSBzaGFkb3cgbWF0cml4XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2hhZG93TWF0cml4LnNldChcXG5cXHRcXHRcXHRcXHRcXHRcXHQwLjUsIDAuMCwgMC4wLCAwLjUsXFxuXFx0XFx0XFx0XFx0XFx0XFx0MC4wLCAwLjUsIDAuMCwgMC41LFxcblxcdFxcdFxcdFxcdFxcdFxcdDAuMCwgMC4wLCAwLjUsIDAuNSxcXG5cXHRcXHRcXHRcXHRcXHRcXHQwLjAsIDAuMCwgMC4wLCAxLjBcXG5cXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdFxcdHNoYWRvd01hdHJpeC5tdWx0aXBseSggc2hhZG93Q2FtZXJhLnByb2plY3Rpb25NYXRyaXggKTtcXG5cXHRcXHRcXHRcXHRcXHRzaGFkb3dNYXRyaXgubXVsdGlwbHkoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0X3JlbmRlcmVyLnNldFJlbmRlclRhcmdldCggc2hhZG93TWFwICk7XFxuXFx0XFx0XFx0XFx0X3JlbmRlcmVyLmNsZWFyKCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gcmVuZGVyIHNoYWRvdyBtYXAgZm9yIGVhY2ggY3ViZSBmYWNlIChpZiBvbW5pLWRpcmVjdGlvbmFsKSBvclxcblxcdFxcdFxcdFxcdC8vIHJ1biBhIHNpbmdsZSBwYXNzIGlmIG5vdFxcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBmYWNlID0gMDsgZmFjZSA8IGZhY2VDb3VudDsgZmFjZSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGlzUG9pbnRMaWdodCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRfbG9va1RhcmdldC5jb3B5KCBzaGFkb3dDYW1lcmEucG9zaXRpb24gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRfbG9va1RhcmdldC5hZGQoIGN1YmVEaXJlY3Rpb25zWyBmYWNlIF0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3dDYW1lcmEudXAuY29weSggY3ViZVVwc1sgZmFjZSBdICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93Q2FtZXJhLmxvb2tBdCggX2xvb2tUYXJnZXQgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3dDYW1lcmEudXBkYXRlTWF0cml4V29ybGQoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgdnBEaW1lbnNpb25zID0gY3ViZTJEVmlld1BvcnRzWyBmYWNlIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0X3N0YXRlLnZpZXdwb3J0KCB2cERpbWVuc2lvbnMgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdXBkYXRlIGNhbWVyYSBtYXRyaWNlcyBhbmQgZnJ1c3R1bVxcblxcblxcdFxcdFxcdFxcdFxcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBzaGFkb3dDYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XFxuXFx0XFx0XFx0XFx0XFx0X2ZydXN0dW0uc2V0RnJvbU1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBzZXQgb2JqZWN0IG1hdHJpY2VzICYgZnJ1c3R1bSBjdWxsaW5nXFxuXFxuXFx0XFx0XFx0XFx0XFx0cmVuZGVyT2JqZWN0KCBzY2VuZSwgY2FtZXJhLCBzaGFkb3dDYW1lcmEsIGlzUG9pbnRMaWdodCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0c2NvcGUubmVlZHNVcGRhdGUgPSBmYWxzZTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdGZ1bmN0aW9uIGdldERlcHRoTWF0ZXJpYWwoIG9iamVjdCwgbWF0ZXJpYWwsIGlzUG9pbnRMaWdodCwgbGlnaHRQb3NpdGlvbldvcmxkLCBzaGFkb3dDYW1lcmFOZWFyLCBzaGFkb3dDYW1lcmFGYXIgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gb2JqZWN0Lmdlb21ldHJ5O1xcblxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBudWxsO1xcblxcblxcdFxcdFxcdHZhciBtYXRlcmlhbFZhcmlhbnRzID0gX2RlcHRoTWF0ZXJpYWxzO1xcblxcdFxcdFxcdHZhciBjdXN0b21NYXRlcmlhbCA9IG9iamVjdC5jdXN0b21EZXB0aE1hdGVyaWFsO1xcblxcblxcdFxcdFxcdGlmICggaXNQb2ludExpZ2h0ICkge1xcblxcblxcdFxcdFxcdFxcdG1hdGVyaWFsVmFyaWFudHMgPSBfZGlzdGFuY2VNYXRlcmlhbHM7XFxuXFx0XFx0XFx0XFx0Y3VzdG9tTWF0ZXJpYWwgPSBvYmplY3QuY3VzdG9tRGlzdGFuY2VNYXRlcmlhbDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCAhIGN1c3RvbU1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB1c2VNb3JwaGluZyA9IGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdGlmICggbWF0ZXJpYWwubW9ycGhUYXJnZXRzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR1c2VNb3JwaGluZyA9IGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcyAmJiBnZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb24gJiYgZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uLmxlbmd0aCA+IDA7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR1c2VNb3JwaGluZyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyAmJiBnZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoID4gMDtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggb2JqZWN0LmlzU2tpbm5lZE1lc2ggJiYgbWF0ZXJpYWwuc2tpbm5pbmcgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMU2hhZG93TWFwOiBUSFJFRS5Ta2lubmVkTWVzaCB3aXRoIG1hdGVyaWFsLnNraW5uaW5nIHNldCB0byBmYWxzZTonLCBvYmplY3QgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHVzZVNraW5uaW5nID0gb2JqZWN0LmlzU2tpbm5lZE1lc2ggJiYgbWF0ZXJpYWwuc2tpbm5pbmc7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHZhcmlhbnRJbmRleCA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB1c2VNb3JwaGluZyApIHZhcmlhbnRJbmRleCB8PSBfTW9ycGhpbmdGbGFnO1xcblxcdFxcdFxcdFxcdGlmICggdXNlU2tpbm5pbmcgKSB2YXJpYW50SW5kZXggfD0gX1NraW5uaW5nRmxhZztcXG5cXG5cXHRcXHRcXHRcXHRyZXN1bHQgPSBtYXRlcmlhbFZhcmlhbnRzWyB2YXJpYW50SW5kZXggXTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHJlc3VsdCA9IGN1c3RvbU1hdGVyaWFsO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIF9yZW5kZXJlci5sb2NhbENsaXBwaW5nRW5hYmxlZCAmJlxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLmNsaXBTaGFkb3dzID09PSB0cnVlICYmXFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwuY2xpcHBpbmdQbGFuZXMubGVuZ3RoICE9PSAwICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGluIHRoaXMgY2FzZSB3ZSBuZWVkIGEgdW5pcXVlIG1hdGVyaWFsIGluc3RhbmNlIHJlZmxlY3RpbmcgdGhlXFxuXFx0XFx0XFx0XFx0Ly8gYXBwcm9wcmlhdGUgc3RhdGVcXG5cXG5cXHRcXHRcXHRcXHR2YXIga2V5QSA9IHJlc3VsdC51dWlkLCBrZXlCID0gbWF0ZXJpYWwudXVpZDtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbWF0ZXJpYWxzRm9yVmFyaWFudCA9IF9tYXRlcmlhbENhY2hlWyBrZXlBIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtYXRlcmlhbHNGb3JWYXJpYW50ID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWxzRm9yVmFyaWFudCA9IHt9O1xcblxcdFxcdFxcdFxcdFxcdF9tYXRlcmlhbENhY2hlWyBrZXlBIF0gPSBtYXRlcmlhbHNGb3JWYXJpYW50O1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgY2FjaGVkTWF0ZXJpYWwgPSBtYXRlcmlhbHNGb3JWYXJpYW50WyBrZXlCIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBjYWNoZWRNYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNhY2hlZE1hdGVyaWFsID0gcmVzdWx0LmNsb25lKCk7XFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWxzRm9yVmFyaWFudFsga2V5QiBdID0gY2FjaGVkTWF0ZXJpYWw7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJlc3VsdCA9IGNhY2hlZE1hdGVyaWFsO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXN1bHQudmlzaWJsZSA9IG1hdGVyaWFsLnZpc2libGU7XFxuXFx0XFx0XFx0cmVzdWx0LndpcmVmcmFtZSA9IG1hdGVyaWFsLndpcmVmcmFtZTtcXG5cXG5cXHRcXHRcXHR2YXIgc2lkZSA9IG1hdGVyaWFsLnNpZGU7XFxuXFxuXFx0XFx0XFx0aWYgKCBzY29wZS5yZW5kZXJTaW5nbGVTaWRlZCAmJiBzaWRlID09IERvdWJsZVNpZGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c2lkZSA9IEZyb250U2lkZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBzY29wZS5yZW5kZXJSZXZlcnNlU2lkZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBzaWRlID09PSBGcm9udFNpZGUgKSBzaWRlID0gQmFja1NpZGU7XFxuXFx0XFx0XFx0XFx0ZWxzZSBpZiAoIHNpZGUgPT09IEJhY2tTaWRlICkgc2lkZSA9IEZyb250U2lkZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmVzdWx0LnNpZGUgPSBzaWRlO1xcblxcblxcdFxcdFxcdHJlc3VsdC5jbGlwU2hhZG93cyA9IG1hdGVyaWFsLmNsaXBTaGFkb3dzO1xcblxcdFxcdFxcdHJlc3VsdC5jbGlwcGluZ1BsYW5lcyA9IG1hdGVyaWFsLmNsaXBwaW5nUGxhbmVzO1xcblxcdFxcdFxcdHJlc3VsdC5jbGlwSW50ZXJzZWN0aW9uID0gbWF0ZXJpYWwuY2xpcEludGVyc2VjdGlvbjtcXG5cXG5cXHRcXHRcXHRyZXN1bHQud2lyZWZyYW1lTGluZXdpZHRoID0gbWF0ZXJpYWwud2lyZWZyYW1lTGluZXdpZHRoO1xcblxcdFxcdFxcdHJlc3VsdC5saW5ld2lkdGggPSBtYXRlcmlhbC5saW5ld2lkdGg7XFxuXFxuXFx0XFx0XFx0aWYgKCBpc1BvaW50TGlnaHQgJiYgcmVzdWx0LmlzTWVzaERpc3RhbmNlTWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmVzdWx0LnJlZmVyZW5jZVBvc2l0aW9uLmNvcHkoIGxpZ2h0UG9zaXRpb25Xb3JsZCApO1xcblxcdFxcdFxcdFxcdHJlc3VsdC5uZWFyRGlzdGFuY2UgPSBzaGFkb3dDYW1lcmFOZWFyO1xcblxcdFxcdFxcdFxcdHJlc3VsdC5mYXJEaXN0YW5jZSA9IHNoYWRvd0NhbWVyYUZhcjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVuZGVyT2JqZWN0KCBvYmplY3QsIGNhbWVyYSwgc2hhZG93Q2FtZXJhLCBpc1BvaW50TGlnaHQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBvYmplY3QudmlzaWJsZSA9PT0gZmFsc2UgKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0dmFyIHZpc2libGUgPSBvYmplY3QubGF5ZXJzLnRlc3QoIGNhbWVyYS5sYXllcnMgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHZpc2libGUgJiYgKCBvYmplY3QuaXNNZXNoIHx8IG9iamVjdC5pc0xpbmUgfHwgb2JqZWN0LmlzUG9pbnRzICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBvYmplY3QuY2FzdFNoYWRvdyAmJiAoICEgb2JqZWN0LmZydXN0dW1DdWxsZWQgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c09iamVjdCggb2JqZWN0ICkgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRvYmplY3QubW9kZWxWaWV3TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIHNoYWRvd0NhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IF9vYmplY3RzLnVwZGF0ZSggb2JqZWN0ICk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1hdGVyaWFsID0gb2JqZWN0Lm1hdGVyaWFsO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggbWF0ZXJpYWwgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBrID0gMCwga2wgPSBncm91cHMubGVuZ3RoOyBrIDwga2w7IGsgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBrIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFsgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZ3JvdXBNYXRlcmlhbCAmJiBncm91cE1hdGVyaWFsLnZpc2libGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGRlcHRoTWF0ZXJpYWwgPSBnZXREZXB0aE1hdGVyaWFsKCBvYmplY3QsIGdyb3VwTWF0ZXJpYWwsIGlzUG9pbnRMaWdodCwgX2xpZ2h0UG9zaXRpb25Xb3JsZCwgc2hhZG93Q2FtZXJhLm5lYXIsIHNoYWRvd0NhbWVyYS5mYXIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRfcmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBzaGFkb3dDYW1lcmEsIG51bGwsIGdlb21ldHJ5LCBkZXB0aE1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC52aXNpYmxlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBkZXB0aE1hdGVyaWFsID0gZ2V0RGVwdGhNYXRlcmlhbCggb2JqZWN0LCBtYXRlcmlhbCwgaXNQb2ludExpZ2h0LCBfbGlnaHRQb3NpdGlvbldvcmxkLCBzaGFkb3dDYW1lcmEubmVhciwgc2hhZG93Q2FtZXJhLmZhciApO1xcblxcdFxcdFxcdFxcdFxcdFxcdF9yZW5kZXJlci5yZW5kZXJCdWZmZXJEaXJlY3QoIHNoYWRvd0NhbWVyYSwgbnVsbCwgZ2VvbWV0cnksIGRlcHRoTWF0ZXJpYWwsIG9iamVjdCwgbnVsbCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBjaGlsZHJlbiA9IG9iamVjdC5jaGlsZHJlbjtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHJlbmRlck9iamVjdCggY2hpbGRyZW5bIGkgXSwgY2FtZXJhLCBzaGFkb3dDYW1lcmEsIGlzUG9pbnRMaWdodCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gV2ViR0xBdHRyaWJ1dGVzKCBnbCApIHtcXG5cXG5cXHRcXHR2YXIgYnVmZmVycyA9IHt9O1xcblxcblxcdFxcdGZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciggYXR0cmlidXRlLCBidWZmZXJUeXBlICkge1xcblxcblxcdFxcdFxcdHZhciBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcXG5cXHRcXHRcXHR2YXIgdXNhZ2UgPSBhdHRyaWJ1dGUuZHluYW1pYyA/IGdsLkRZTkFNSUNfRFJBVyA6IGdsLlNUQVRJQ19EUkFXO1xcblxcblxcdFxcdFxcdHZhciBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcXG5cXG5cXHRcXHRcXHRnbC5iaW5kQnVmZmVyKCBidWZmZXJUeXBlLCBidWZmZXIgKTtcXG5cXHRcXHRcXHRnbC5idWZmZXJEYXRhKCBidWZmZXJUeXBlLCBhcnJheSwgdXNhZ2UgKTtcXG5cXG5cXHRcXHRcXHRhdHRyaWJ1dGUub25VcGxvYWRDYWxsYmFjaygpO1xcblxcblxcdFxcdFxcdHZhciB0eXBlID0gZ2wuRkxPQVQ7XFxuXFxuXFx0XFx0XFx0aWYgKCBhcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0eXBlID0gZ2wuRkxPQVQ7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBGbG9hdDY0QXJyYXkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xBdHRyaWJ1dGVzOiBVbnN1cHBvcnRlZCBkYXRhIGJ1ZmZlciBmb3JtYXQ6IEZsb2F0NjRBcnJheS4nICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0eXBlID0gZ2wuVU5TSUdORURfU0hPUlQ7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBJbnQxNkFycmF5ICkge1xcblxcblxcdFxcdFxcdFxcdHR5cGUgPSBnbC5TSE9SVDtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBhcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5ICkge1xcblxcblxcdFxcdFxcdFxcdHR5cGUgPSBnbC5VTlNJR05FRF9JTlQ7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBJbnQzMkFycmF5ICkge1xcblxcblxcdFxcdFxcdFxcdHR5cGUgPSBnbC5JTlQ7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dHlwZSA9IGdsLkJZVEU7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggYXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5ICkge1xcblxcblxcdFxcdFxcdFxcdHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdGJ1ZmZlcjogYnVmZmVyLFxcblxcdFxcdFxcdFxcdHR5cGU6IHR5cGUsXFxuXFx0XFx0XFx0XFx0Ynl0ZXNQZXJFbGVtZW50OiBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcXG5cXHRcXHRcXHRcXHR2ZXJzaW9uOiBhdHRyaWJ1dGUudmVyc2lvblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHVwZGF0ZUJ1ZmZlciggYnVmZmVyLCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGFycmF5ID0gYXR0cmlidXRlLmFycmF5O1xcblxcdFxcdFxcdHZhciB1cGRhdGVSYW5nZSA9IGF0dHJpYnV0ZS51cGRhdGVSYW5nZTtcXG5cXG5cXHRcXHRcXHRnbC5iaW5kQnVmZmVyKCBidWZmZXJUeXBlLCBidWZmZXIgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGF0dHJpYnV0ZS5keW5hbWljID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRnbC5idWZmZXJEYXRhKCBidWZmZXJUeXBlLCBhcnJheSwgZ2wuU1RBVElDX0RSQVcgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCB1cGRhdGVSYW5nZS5jb3VudCA9PT0gLSAxICkge1xcblxcblxcdFxcdFxcdFxcdC8vIE5vdCB1c2luZyB1cGRhdGUgcmFuZ2VzXFxuXFxuXFx0XFx0XFx0XFx0Z2wuYnVmZmVyU3ViRGF0YSggYnVmZmVyVHlwZSwgMCwgYXJyYXkgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCB1cGRhdGVSYW5nZS5jb3VudCA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xPYmplY3RzLnVwZGF0ZUJ1ZmZlcjogZHluYW1pYyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUgbWFya2VkIGFzIG5lZWRzVXBkYXRlIGJ1dCB1cGRhdGVSYW5nZS5jb3VudCBpcyAwLCBlbnN1cmUgeW91IGFyZSB1c2luZyBzZXQgbWV0aG9kcyBvciB1cGRhdGluZyBtYW51YWxseS4nICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRnbC5idWZmZXJTdWJEYXRhKCBidWZmZXJUeXBlLCB1cGRhdGVSYW5nZS5vZmZzZXQgKiBhcnJheS5CWVRFU19QRVJfRUxFTUVOVCxcXG5cXHRcXHRcXHRcXHRcXHRhcnJheS5zdWJhcnJheSggdXBkYXRlUmFuZ2Uub2Zmc2V0LCB1cGRhdGVSYW5nZS5vZmZzZXQgKyB1cGRhdGVSYW5nZS5jb3VudCApICk7XFxuXFxuXFx0XFx0XFx0XFx0dXBkYXRlUmFuZ2UuY291bnQgPSAtIDE7IC8vIHJlc2V0IHJhbmdlXFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvL1xcblxcblxcdFxcdGZ1bmN0aW9uIGdldCggYXR0cmlidXRlICkge1xcblxcblxcdFxcdFxcdGlmICggYXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGUuZGF0YTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYnVmZmVyc1sgYXR0cmlidXRlLnV1aWQgXTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVtb3ZlKCBhdHRyaWJ1dGUgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZS5kYXRhO1xcblxcblxcdFxcdFxcdHZhciBkYXRhID0gYnVmZmVyc1sgYXR0cmlidXRlLnV1aWQgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIGRhdGEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Z2wuZGVsZXRlQnVmZmVyKCBkYXRhLmJ1ZmZlciApO1xcblxcblxcdFxcdFxcdFxcdGRlbGV0ZSBidWZmZXJzWyBhdHRyaWJ1dGUudXVpZCBdO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gdXBkYXRlKCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZS5kYXRhO1xcblxcblxcdFxcdFxcdHZhciBkYXRhID0gYnVmZmVyc1sgYXR0cmlidXRlLnV1aWQgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIGRhdGEgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRidWZmZXJzWyBhdHRyaWJ1dGUudXVpZCBdID0gY3JlYXRlQnVmZmVyKCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBkYXRhLnZlcnNpb24gPCBhdHRyaWJ1dGUudmVyc2lvbiApIHtcXG5cXG5cXHRcXHRcXHRcXHR1cGRhdGVCdWZmZXIoIGRhdGEuYnVmZmVyLCBhdHRyaWJ1dGUsIGJ1ZmZlclR5cGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRkYXRhLnZlcnNpb24gPSBhdHRyaWJ1dGUudmVyc2lvbjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB7XFxuXFxuXFx0XFx0XFx0Z2V0OiBnZXQsXFxuXFx0XFx0XFx0cmVtb3ZlOiByZW1vdmUsXFxuXFx0XFx0XFx0dXBkYXRlOiB1cGRhdGVcXG5cXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcblxcdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBFdWxlciggeCwgeSwgeiwgb3JkZXIgKSB7XFxuXFxuXFx0XFx0dGhpcy5feCA9IHggfHwgMDtcXG5cXHRcXHR0aGlzLl95ID0geSB8fCAwO1xcblxcdFxcdHRoaXMuX3ogPSB6IHx8IDA7XFxuXFx0XFx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCBFdWxlci5EZWZhdWx0T3JkZXI7XFxuXFxuXFx0fVxcblxcblxcdEV1bGVyLlJvdGF0aW9uT3JkZXJzID0gWyAnWFlaJywgJ1laWCcsICdaWFknLCAnWFpZJywgJ1lYWicsICdaWVgnIF07XFxuXFxuXFx0RXVsZXIuRGVmYXVsdE9yZGVyID0gJ1hZWic7XFxuXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEV1bGVyLnByb3RvdHlwZSwge1xcblxcblxcdFxcdHg6IHtcXG5cXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5feDtcXG5cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl94ID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0eToge1xcblxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLl95O1xcblxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX3kgPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR6OiB7XFxuXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuX3o7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdHRoaXMub25DaGFuZ2VDYWxsYmFjaygpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG9yZGVyOiB7XFxuXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuX29yZGVyO1xcblxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX29yZGVyID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggRXVsZXIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0aXNFdWxlcjogdHJ1ZSxcXG5cXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggeCwgeSwgeiwgb3JkZXIgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5feCA9IHg7XFxuXFx0XFx0XFx0dGhpcy5feSA9IHk7XFxuXFx0XFx0XFx0dGhpcy5feiA9IHo7XFxuXFx0XFx0XFx0dGhpcy5fb3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcXG5cXG5cXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96LCB0aGlzLl9vcmRlciApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBldWxlciApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLl94ID0gZXVsZXIuX3g7XFxuXFx0XFx0XFx0dGhpcy5feSA9IGV1bGVyLl95O1xcblxcdFxcdFxcdHRoaXMuX3ogPSBldWxlci5fejtcXG5cXHRcXHRcXHR0aGlzLl9vcmRlciA9IGV1bGVyLl9vcmRlcjtcXG5cXG5cXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2soKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCBtLCBvcmRlciwgdXBkYXRlICkge1xcblxcblxcdFxcdFxcdHZhciBjbGFtcCA9IF9NYXRoLmNsYW1wO1xcblxcblxcdFxcdFxcdC8vIGFzc3VtZXMgdGhlIHVwcGVyIDN4MyBvZiBtIGlzIGEgcHVyZSByb3RhdGlvbiBtYXRyaXggKGkuZSwgdW5zY2FsZWQpXFxuXFxuXFx0XFx0XFx0dmFyIHRlID0gbS5lbGVtZW50cztcXG5cXHRcXHRcXHR2YXIgbTExID0gdGVbIDAgXSwgbTEyID0gdGVbIDQgXSwgbTEzID0gdGVbIDggXTtcXG5cXHRcXHRcXHR2YXIgbTIxID0gdGVbIDEgXSwgbTIyID0gdGVbIDUgXSwgbTIzID0gdGVbIDkgXTtcXG5cXHRcXHRcXHR2YXIgbTMxID0gdGVbIDIgXSwgbTMyID0gdGVbIDYgXSwgbTMzID0gdGVbIDEwIF07XFxuXFxuXFx0XFx0XFx0b3JkZXIgPSBvcmRlciB8fCB0aGlzLl9vcmRlcjtcXG5cXG5cXHRcXHRcXHRpZiAoIG9yZGVyID09PSAnWFlaJyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0gTWF0aC5hc2luKCBjbGFtcCggbTEzLCAtIDEsIDEgKSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggTWF0aC5hYnMoIG0xMyApIDwgMC45OTk5OSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl94ID0gTWF0aC5hdGFuMiggLSBtMjMsIG0zMyApO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCAtIG0xMiwgbTExICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl96ID0gMDtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWFonICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX3ggPSBNYXRoLmFzaW4oIC0gY2xhbXAoIG0yMywgLSAxLCAxICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIE1hdGguYWJzKCBtMjMgKSA8IDAuOTk5OTkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIG0xMywgbTMzICk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTIyICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl95ID0gTWF0aC5hdGFuMiggLSBtMzEsIG0xMSApO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3ogPSAwO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1pYWScgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5feCA9IE1hdGguYXNpbiggY2xhbXAoIG0zMiwgLSAxLCAxICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIE1hdGguYWJzKCBtMzIgKSA8IDAuOTk5OTkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMzMgKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl96ID0gTWF0aC5hdGFuMiggLSBtMTIsIG0yMiApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feSA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIG0yMSwgbTExICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG9yZGVyID09PSAnWllYJyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl95ID0gTWF0aC5hc2luKCAtIGNsYW1wKCBtMzEsIC0gMSwgMSApICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBNYXRoLmFicyggbTMxICkgPCAwLjk5OTk5ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCBtMzIsIG0zMyApO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3ogPSBNYXRoLmF0YW4yKCBtMjEsIG0xMSApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feCA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feiA9IE1hdGguYXRhbjIoIC0gbTEyLCBtMjIgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggb3JkZXIgPT09ICdZWlgnICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX3ogPSBNYXRoLmFzaW4oIGNsYW1wKCBtMjEsIC0gMSwgMSApICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBNYXRoLmFicyggbTIxICkgPCAwLjk5OTk5ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTIyICk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feSA9IE1hdGguYXRhbjIoIC0gbTMxLCBtMTEgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3ggPSAwO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3kgPSBNYXRoLmF0YW4yKCBtMTMsIG0zMyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBvcmRlciA9PT0gJ1haWScgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5feiA9IE1hdGguYXNpbiggLSBjbGFtcCggbTEyLCAtIDEsIDEgKSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggTWF0aC5hYnMoIG0xMiApIDwgMC45OTk5OSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl94ID0gTWF0aC5hdGFuMiggbTMyLCBtMjIgKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl95ID0gTWF0aC5hdGFuMiggbTEzLCBtMTEgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3ggPSBNYXRoLmF0YW4yKCAtIG0yMywgbTMzICk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5feSA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRXVsZXI6IC5zZXRGcm9tUm90YXRpb25NYXRyaXgoKSBnaXZlbiB1bnN1cHBvcnRlZCBvcmRlcjogJyArIG9yZGVyICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX29yZGVyID0gb3JkZXI7XFxuXFxuXFx0XFx0XFx0aWYgKCB1cGRhdGUgIT09IGZhbHNlICkgdGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBzZXRGcm9tUXVhdGVybmlvbiggcSwgb3JkZXIsIHVwZGF0ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRtYXRyaXgubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG1hdHJpeCwgb3JkZXIsIHVwZGF0ZSApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdHNldEZyb21WZWN0b3IzOiBmdW5jdGlvbiAoIHYsIG9yZGVyICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLnNldCggdi54LCB2LnksIHYueiwgb3JkZXIgfHwgdGhpcy5fb3JkZXIgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHJlb3JkZXI6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyBXQVJOSU5HOiB0aGlzIGRpc2NhcmRzIHJldm9sdXRpb24gaW5mb3JtYXRpb24gLWJob3VzdG9uXFxuXFxuXFx0XFx0XFx0dmFyIHEgPSBuZXcgUXVhdGVybmlvbigpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiByZW9yZGVyKCBuZXdPcmRlciApIHtcXG5cXG5cXHRcXHRcXHRcXHRxLnNldEZyb21FdWxlciggdGhpcyApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnNldEZyb21RdWF0ZXJuaW9uKCBxLCBuZXdPcmRlciApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGVxdWFsczogZnVuY3Rpb24gKCBldWxlciApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gKCBldWxlci5feCA9PT0gdGhpcy5feCApICYmICggZXVsZXIuX3kgPT09IHRoaXMuX3kgKSAmJiAoIGV1bGVyLl96ID09PSB0aGlzLl96ICkgJiYgKCBldWxlci5fb3JkZXIgPT09IHRoaXMuX29yZGVyICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmcm9tQXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5feCA9IGFycmF5WyAwIF07XFxuXFx0XFx0XFx0dGhpcy5feSA9IGFycmF5WyAxIF07XFxuXFx0XFx0XFx0dGhpcy5feiA9IGFycmF5WyAyIF07XFxuXFx0XFx0XFx0aWYgKCBhcnJheVsgMyBdICE9PSB1bmRlZmluZWQgKSB0aGlzLl9vcmRlciA9IGFycmF5WyAzIF07XFxuXFxuXFx0XFx0XFx0dGhpcy5vbkNoYW5nZUNhbGxiYWNrKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0FycmF5OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBhcnJheSA9PT0gdW5kZWZpbmVkICkgYXJyYXkgPSBbXTtcXG5cXHRcXHRcXHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHRhcnJheVsgb2Zmc2V0IF0gPSB0aGlzLl94O1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAxIF0gPSB0aGlzLl95O1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAyIF0gPSB0aGlzLl96O1xcblxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKyAzIF0gPSB0aGlzLl9vcmRlcjtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYXJyYXk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b1ZlY3RvcjM6IGZ1bmN0aW9uICggb3B0aW9uYWxSZXN1bHQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBvcHRpb25hbFJlc3VsdCApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gb3B0aW9uYWxSZXN1bHQuc2V0KCB0aGlzLl94LCB0aGlzLl95LCB0aGlzLl96ICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gbmV3IFZlY3RvcjMoIHRoaXMuX3gsIHRoaXMuX3ksIHRoaXMuX3ogKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRvbkNoYW5nZTogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm9uQ2hhbmdlQ2FsbGJhY2sgPSBjYWxsYmFjaztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG9uQ2hhbmdlQ2FsbGJhY2s6IGZ1bmN0aW9uICgpIHt9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gTGF5ZXJzKCkge1xcblxcblxcdFxcdHRoaXMubWFzayA9IDEgfCAwO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBMYXllcnMucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5tYXNrID0gMSA8PCBjaGFubmVsIHwgMDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGVuYWJsZTogZnVuY3Rpb24gKCBjaGFubmVsICkge1xcblxcblxcdFxcdFxcdHRoaXMubWFzayB8PSAxIDw8IGNoYW5uZWwgfCAwO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dG9nZ2xlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5tYXNrIF49IDEgPDwgY2hhbm5lbCB8IDA7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXNhYmxlOiBmdW5jdGlvbiAoIGNoYW5uZWwgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5tYXNrICY9IH4gKCAxIDw8IGNoYW5uZWwgfCAwICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0ZXN0OiBmdW5jdGlvbiAoIGxheWVycyApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gKCB0aGlzLm1hc2sgJiBsYXllcnMubWFzayApICE9PSAwO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxuXFx0ICogQGF1dGhvciBlbGVwaGFudGF0d29yayAvIHd3dy5lbGVwaGFudGF0d29yay5jaFxcblxcdCAqL1xcblxcblxcdHZhciBvYmplY3QzRElkID0gMDtcXG5cXG5cXHRmdW5jdGlvbiBPYmplY3QzRCgpIHtcXG5cXG5cXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMsICdpZCcsIHsgdmFsdWU6IG9iamVjdDNESWQgKysgfSApO1xcblxcblxcdFxcdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xcblxcblxcdFxcdHRoaXMubmFtZSA9ICcnO1xcblxcdFxcdHRoaXMudHlwZSA9ICdPYmplY3QzRCc7XFxuXFxuXFx0XFx0dGhpcy5wYXJlbnQgPSBudWxsO1xcblxcdFxcdHRoaXMuY2hpbGRyZW4gPSBbXTtcXG5cXG5cXHRcXHR0aGlzLnVwID0gT2JqZWN0M0QuRGVmYXVsdFVwLmNsb25lKCk7XFxuXFxuXFx0XFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR2YXIgcm90YXRpb24gPSBuZXcgRXVsZXIoKTtcXG5cXHRcXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XFxuXFx0XFx0dmFyIHNjYWxlID0gbmV3IFZlY3RvcjMoIDEsIDEsIDEgKTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBvblJvdGF0aW9uQ2hhbmdlKCkge1xcblxcblxcdFxcdFxcdHF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCByb3RhdGlvbiwgZmFsc2UgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gb25RdWF0ZXJuaW9uQ2hhbmdlKCkge1xcblxcblxcdFxcdFxcdHJvdGF0aW9uLnNldEZyb21RdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uLCB1bmRlZmluZWQsIGZhbHNlICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJvdGF0aW9uLm9uQ2hhbmdlKCBvblJvdGF0aW9uQ2hhbmdlICk7XFxuXFx0XFx0cXVhdGVybmlvbi5vbkNoYW5nZSggb25RdWF0ZXJuaW9uQ2hhbmdlICk7XFxuXFxuXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIHRoaXMsIHtcXG5cXHRcXHRcXHRwb3NpdGlvbjoge1xcblxcdFxcdFxcdFxcdGVudW1lcmFibGU6IHRydWUsXFxuXFx0XFx0XFx0XFx0dmFsdWU6IHBvc2l0aW9uXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRyb3RhdGlvbjoge1xcblxcdFxcdFxcdFxcdGVudW1lcmFibGU6IHRydWUsXFxuXFx0XFx0XFx0XFx0dmFsdWU6IHJvdGF0aW9uXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRxdWF0ZXJuaW9uOiB7XFxuXFx0XFx0XFx0XFx0ZW51bWVyYWJsZTogdHJ1ZSxcXG5cXHRcXHRcXHRcXHR2YWx1ZTogcXVhdGVybmlvblxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2NhbGU6IHtcXG5cXHRcXHRcXHRcXHRlbnVtZXJhYmxlOiB0cnVlLFxcblxcdFxcdFxcdFxcdHZhbHVlOiBzY2FsZVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0bW9kZWxWaWV3TWF0cml4OiB7XFxuXFx0XFx0XFx0XFx0dmFsdWU6IG5ldyBNYXRyaXg0KClcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdG5vcm1hbE1hdHJpeDoge1xcblxcdFxcdFxcdFxcdHZhbHVlOiBuZXcgTWF0cml4MygpXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXG5cXHRcXHR0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XFxuXFx0XFx0dGhpcy5tYXRyaXhXb3JsZCA9IG5ldyBNYXRyaXg0KCk7XFxuXFxuXFx0XFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gT2JqZWN0M0QuRGVmYXVsdE1hdHJpeEF1dG9VcGRhdGU7XFxuXFx0XFx0dGhpcy5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gZmFsc2U7XFxuXFxuXFx0XFx0dGhpcy5sYXllcnMgPSBuZXcgTGF5ZXJzKCk7XFxuXFx0XFx0dGhpcy52aXNpYmxlID0gdHJ1ZTtcXG5cXG5cXHRcXHR0aGlzLmNhc3RTaGFkb3cgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLnJlY2VpdmVTaGFkb3cgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLmZydXN0dW1DdWxsZWQgPSB0cnVlO1xcblxcdFxcdHRoaXMucmVuZGVyT3JkZXIgPSAwO1xcblxcblxcdFxcdHRoaXMudXNlckRhdGEgPSB7fTtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0M0QuRGVmYXVsdFVwID0gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcXG5cXHRPYmplY3QzRC5EZWZhdWx0TWF0cml4QXV0b1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0T2JqZWN0M0QucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggRXZlbnREaXNwYXRjaGVyLnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IE9iamVjdDNELFxcblxcblxcdFxcdGlzT2JqZWN0M0Q6IHRydWUsXFxuXFxuXFx0XFx0b25CZWZvcmVSZW5kZXI6IGZ1bmN0aW9uICgpIHt9LFxcblxcdFxcdG9uQWZ0ZXJSZW5kZXI6IGZ1bmN0aW9uICgpIHt9LFxcblxcblxcdFxcdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXgsIHRoaXMubWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5tYXRyaXguZGVjb21wb3NlKCB0aGlzLnBvc2l0aW9uLCB0aGlzLnF1YXRlcm5pb24sIHRoaXMuc2NhbGUgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFwcGx5UXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xcblxcblxcdFxcdFxcdHRoaXMucXVhdGVybmlvbi5wcmVtdWx0aXBseSggcSApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0Um90YXRpb25Gcm9tQXhpc0FuZ2xlOiBmdW5jdGlvbiAoIGF4aXMsIGFuZ2xlICkge1xcblxcblxcdFxcdFxcdC8vIGFzc3VtZXMgYXhpcyBpcyBub3JtYWxpemVkXFxuXFxuXFx0XFx0XFx0dGhpcy5xdWF0ZXJuaW9uLnNldEZyb21BeGlzQW5nbGUoIGF4aXMsIGFuZ2xlICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRSb3RhdGlvbkZyb21FdWxlcjogZnVuY3Rpb24gKCBldWxlciApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUV1bGVyKCBldWxlciwgdHJ1ZSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0Um90YXRpb25Gcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XFxuXFxuXFx0XFx0XFx0Ly8gYXNzdW1lcyB0aGUgdXBwZXIgM3gzIG9mIG0gaXMgYSBwdXJlIHJvdGF0aW9uIG1hdHJpeCAoaS5lLCB1bnNjYWxlZClcXG5cXG5cXHRcXHRcXHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbVJvdGF0aW9uTWF0cml4KCBtICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoIHEgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gYXNzdW1lcyBxIGlzIG5vcm1hbGl6ZWRcXG5cXG5cXHRcXHRcXHR0aGlzLnF1YXRlcm5pb24uY29weSggcSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cm90YXRlT25BeGlzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Ly8gcm90YXRlIG9iamVjdCBvbiBheGlzIGluIG9iamVjdCBzcGFjZVxcblxcdFxcdFxcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXFxuXFxuXFx0XFx0XFx0dmFyIHExID0gbmV3IFF1YXRlcm5pb24oKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlT25BeGlzKCBheGlzLCBhbmdsZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRxMS5zZXRGcm9tQXhpc0FuZ2xlKCBheGlzLCBhbmdsZSApO1xcblxcblxcdFxcdFxcdFxcdHRoaXMucXVhdGVybmlvbi5tdWx0aXBseSggcTEgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRyb3RhdGVPbldvcmxkQXhpczogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIHJvdGF0ZSBvYmplY3Qgb24gYXhpcyBpbiB3b3JsZCBzcGFjZVxcblxcdFxcdFxcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXFxuXFx0XFx0XFx0Ly8gbWV0aG9kIGFzc3VtZXMgbm8gcm90YXRlZCBwYXJlbnRcXG5cXG5cXHRcXHRcXHR2YXIgcTEgPSBuZXcgUXVhdGVybmlvbigpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiByb3RhdGVPbldvcmxkQXhpcyggYXhpcywgYW5nbGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cTEuc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgYW5nbGUgKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnF1YXRlcm5pb24ucHJlbXVsdGlwbHkoIHExICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0cm90YXRlWDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAxLCAwLCAwICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVgoIGFuZ2xlICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggdjEsIGFuZ2xlICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0cm90YXRlWTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAwLCAxLCAwICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVkoIGFuZ2xlICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggdjEsIGFuZ2xlICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0cm90YXRlWjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCAwLCAwLCAxICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVooIGFuZ2xlICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnJvdGF0ZU9uQXhpcyggdjEsIGFuZ2xlICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0dHJhbnNsYXRlT25BeGlzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Ly8gdHJhbnNsYXRlIG9iamVjdCBieSBkaXN0YW5jZSBhbG9uZyBheGlzIGluIG9iamVjdCBzcGFjZVxcblxcdFxcdFxcdC8vIGF4aXMgaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkXFxuXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2MS5jb3B5KCBheGlzICkuYXBwbHlRdWF0ZXJuaW9uKCB0aGlzLnF1YXRlcm5pb24gKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnBvc2l0aW9uLmFkZCggdjEubXVsdGlwbHlTY2FsYXIoIGRpc3RhbmNlICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHR0cmFuc2xhdGVYOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDEsIDAsIDAgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlWCggZGlzdGFuY2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHR0cmFuc2xhdGVZOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDAsIDEsIDAgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlWSggZGlzdGFuY2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHR0cmFuc2xhdGVaOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoIDAsIDAsIDEgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gdHJhbnNsYXRlWiggZGlzdGFuY2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMudHJhbnNsYXRlT25BeGlzKCB2MSwgZGlzdGFuY2UgKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRsb2NhbFRvV29ybGQ6IGZ1bmN0aW9uICggdmVjdG9yICkge1xcblxcblxcdFxcdFxcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR3b3JsZFRvTG9jYWw6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgbTEgPSBuZXcgTWF0cml4NCgpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiB3b3JsZFRvTG9jYWwoIHZlY3RvciApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggbTEuZ2V0SW52ZXJzZSggdGhpcy5tYXRyaXhXb3JsZCApICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0bG9va0F0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Ly8gVGhpcyBtZXRob2QgZG9lcyBub3Qgc3VwcG9ydCBvYmplY3RzIHdpdGggcm90YXRlZCBhbmQvb3IgdHJhbnNsYXRlZCBwYXJlbnQocylcXG5cXG5cXHRcXHRcXHR2YXIgbTEgPSBuZXcgTWF0cml4NCgpO1xcblxcdFxcdFxcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBsb29rQXQoIHgsIHksIHogKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB4LmlzVmVjdG9yMyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZWN0b3IuY29weSggeCApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVjdG9yLnNldCggeCwgeSwgeiApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRoaXMuaXNDYW1lcmEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bTEubG9va0F0KCB0aGlzLnBvc2l0aW9uLCB2ZWN0b3IsIHRoaXMudXAgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdG0xLmxvb2tBdCggdmVjdG9yLCB0aGlzLnBvc2l0aW9uLCB0aGlzLnVwICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRoaXMucXVhdGVybmlvbi5zZXRGcm9tUm90YXRpb25NYXRyaXgoIG0xICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0YWRkOiBmdW5jdGlvbiAoIG9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggPiAxICkge1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5hZGQoIGFyZ3VtZW50c1sgaSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG9iamVjdCA9PT0gdGhpcyApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCBcXFwiVEhSRUUuT2JqZWN0M0QuYWRkOiBvYmplY3QgY2FuJ3QgYmUgYWRkZWQgYXMgYSBjaGlsZCBvZiBpdHNlbGYuXFxcIiwgb2JqZWN0ICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggKCBvYmplY3QgJiYgb2JqZWN0LmlzT2JqZWN0M0QgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG9iamVjdC5wYXJlbnQgIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0b2JqZWN0LnBhcmVudC5yZW1vdmUoIG9iamVjdCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRvYmplY3QucGFyZW50ID0gdGhpcztcXG5cXHRcXHRcXHRcXHRvYmplY3QuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnYWRkZWQnIH0gKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmNoaWxkcmVuLnB1c2goIG9iamVjdCApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggXFxcIlRIUkVFLk9iamVjdDNELmFkZDogb2JqZWN0IG5vdCBhbiBpbnN0YW5jZSBvZiBUSFJFRS5PYmplY3QzRC5cXFwiLCBvYmplY3QgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZW1vdmU6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xcblxcblxcdFxcdFxcdGlmICggYXJndW1lbnRzLmxlbmd0aCA+IDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnJlbW92ZSggYXJndW1lbnRzWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBpbmRleCA9IHRoaXMuY2hpbGRyZW4uaW5kZXhPZiggb2JqZWN0ICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBpbmRleCAhPT0gLSAxICkge1xcblxcblxcdFxcdFxcdFxcdG9iamVjdC5wYXJlbnQgPSBudWxsO1xcblxcblxcdFxcdFxcdFxcdG9iamVjdC5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdyZW1vdmVkJyB9ICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5jaGlsZHJlbi5zcGxpY2UoIGluZGV4LCAxICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0T2JqZWN0QnlJZDogZnVuY3Rpb24gKCBpZCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeVByb3BlcnR5KCAnaWQnLCBpZCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0T2JqZWN0QnlOYW1lOiBmdW5jdGlvbiAoIG5hbWUgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0T2JqZWN0QnlQcm9wZXJ0eSggJ25hbWUnLCBuYW1lICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRPYmplY3RCeVByb3BlcnR5OiBmdW5jdGlvbiAoIG5hbWUsIHZhbHVlICkge1xcblxcblxcdFxcdFxcdGlmICggdGhpc1sgbmFtZSBdID09PSB2YWx1ZSApIHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuWyBpIF07XFxuXFx0XFx0XFx0XFx0dmFyIG9iamVjdCA9IGNoaWxkLmdldE9iamVjdEJ5UHJvcGVydHkoIG5hbWUsIHZhbHVlICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gb2JqZWN0O1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHVuZGVmaW5lZDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldFdvcmxkUG9zaXRpb246IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xcblxcblxcdFxcdFxcdHJldHVybiByZXN1bHQuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRXb3JsZFF1YXRlcm5pb246IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciBzY2FsZSA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGdldFdvcmxkUXVhdGVybmlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBRdWF0ZXJuaW9uKCk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy51cGRhdGVNYXRyaXhXb3JsZCggdHJ1ZSApO1xcblxcblxcdFxcdFxcdFxcdHRoaXMubWF0cml4V29ybGQuZGVjb21wb3NlKCBwb3NpdGlvbiwgcmVzdWx0LCBzY2FsZSApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0Z2V0V29ybGRSb3RhdGlvbjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gZ2V0V29ybGRSb3RhdGlvbiggb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBFdWxlcigpO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuZ2V0V29ybGRRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5zZXRGcm9tUXVhdGVybmlvbiggcXVhdGVybmlvbiwgdGhpcy5yb3RhdGlvbi5vcmRlciwgZmFsc2UgKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRnZXRXb3JsZFNjYWxlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGdldFdvcmxkU2NhbGUoIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdFxcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHJlc3VsdCApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0Z2V0V29ybGREaXJlY3Rpb246IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGdldFdvcmxkRGlyZWN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAxICkuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0cmF5Y2FzdDogZnVuY3Rpb24gKCkge30sXFxuXFxuXFx0XFx0dHJhdmVyc2U6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XFxuXFxuXFx0XFx0XFx0Y2FsbGJhY2soIHRoaXMgKTtcXG5cXG5cXHRcXHRcXHR2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y2hpbGRyZW5bIGkgXS50cmF2ZXJzZSggY2FsbGJhY2sgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0cmF2ZXJzZVZpc2libGU6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdGNhbGxiYWNrKCB0aGlzICk7XFxuXFxuXFx0XFx0XFx0dmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGNoaWxkcmVuWyBpIF0udHJhdmVyc2VWaXNpYmxlKCBjYWxsYmFjayApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRyYXZlcnNlQW5jZXN0b3JzOiBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xcblxcblxcdFxcdFxcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudDtcXG5cXG5cXHRcXHRcXHRpZiAoIHBhcmVudCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjYWxsYmFjayggcGFyZW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0cGFyZW50LnRyYXZlcnNlQW5jZXN0b3JzKCBjYWxsYmFjayApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHVwZGF0ZU1hdHJpeDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMubWF0cml4LmNvbXBvc2UoIHRoaXMucG9zaXRpb24sIHRoaXMucXVhdGVybmlvbiwgdGhpcy5zY2FsZSApO1xcblxcblxcdFxcdFxcdHRoaXMubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR1cGRhdGVNYXRyaXhXb3JsZDogZnVuY3Rpb24gKCBmb3JjZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMubWF0cml4QXV0b1VwZGF0ZSApIHRoaXMudXBkYXRlTWF0cml4KCk7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgfHwgZm9yY2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0aGlzLnBhcmVudCA9PT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLm1hdHJpeFdvcmxkLmNvcHkoIHRoaXMubWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLm1hdHJpeFdvcmxkLm11bHRpcGx5TWF0cmljZXMoIHRoaXMucGFyZW50Lm1hdHJpeFdvcmxkLCB0aGlzLm1hdHJpeCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRcXHRmb3JjZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHVwZGF0ZSBjaGlsZHJlblxcblxcblxcdFxcdFxcdHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRjaGlsZHJlblsgaSBdLnVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xcblxcblxcdFxcdFxcdC8vIG1ldGEgaXMgYSBzdHJpbmcgd2hlbiBjYWxsZWQgZnJvbSBKU09OLnN0cmluZ2lmeVxcblxcdFxcdFxcdHZhciBpc1Jvb3RPYmplY3QgPSAoIG1ldGEgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgbWV0YSA9PT0gJ3N0cmluZycgKTtcXG5cXG5cXHRcXHRcXHR2YXIgb3V0cHV0ID0ge307XFxuXFxuXFx0XFx0XFx0Ly8gbWV0YSBpcyBhIGhhc2ggdXNlZCB0byBjb2xsZWN0IGdlb21ldHJpZXMsIG1hdGVyaWFscy5cXG5cXHRcXHRcXHQvLyBub3QgcHJvdmlkaW5nIGl0IGltcGxpZXMgdGhhdCB0aGlzIGlzIHRoZSByb290IG9iamVjdFxcblxcdFxcdFxcdC8vIGJlaW5nIHNlcmlhbGl6ZWQuXFxuXFx0XFx0XFx0aWYgKCBpc1Jvb3RPYmplY3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gaW5pdGlhbGl6ZSBtZXRhIG9ialxcblxcdFxcdFxcdFxcdG1ldGEgPSB7XFxuXFx0XFx0XFx0XFx0XFx0Z2VvbWV0cmllczoge30sXFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWxzOiB7fSxcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlczoge30sXFxuXFx0XFx0XFx0XFx0XFx0aW1hZ2VzOiB7fSxcXG5cXHRcXHRcXHRcXHRcXHRzaGFwZXM6IHt9XFxuXFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRcXHRvdXRwdXQubWV0YWRhdGEgPSB7XFxuXFx0XFx0XFx0XFx0XFx0dmVyc2lvbjogNC41LFxcblxcdFxcdFxcdFxcdFxcdHR5cGU6ICdPYmplY3QnLFxcblxcdFxcdFxcdFxcdFxcdGdlbmVyYXRvcjogJ09iamVjdDNELnRvSlNPTidcXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBzdGFuZGFyZCBPYmplY3QzRCBzZXJpYWxpemF0aW9uXFxuXFxuXFx0XFx0XFx0dmFyIG9iamVjdCA9IHt9O1xcblxcblxcdFxcdFxcdG9iamVjdC51dWlkID0gdGhpcy51dWlkO1xcblxcdFxcdFxcdG9iamVjdC50eXBlID0gdGhpcy50eXBlO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5uYW1lICE9PSAnJyApIG9iamVjdC5uYW1lID0gdGhpcy5uYW1lO1xcblxcdFxcdFxcdGlmICggdGhpcy5jYXN0U2hhZG93ID09PSB0cnVlICkgb2JqZWN0LmNhc3RTaGFkb3cgPSB0cnVlO1xcblxcdFxcdFxcdGlmICggdGhpcy5yZWNlaXZlU2hhZG93ID09PSB0cnVlICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSB0cnVlO1xcblxcdFxcdFxcdGlmICggdGhpcy52aXNpYmxlID09PSBmYWxzZSApIG9iamVjdC52aXNpYmxlID0gZmFsc2U7XFxuXFx0XFx0XFx0aWYgKCBKU09OLnN0cmluZ2lmeSggdGhpcy51c2VyRGF0YSApICE9PSAne30nICkgb2JqZWN0LnVzZXJEYXRhID0gdGhpcy51c2VyRGF0YTtcXG5cXG5cXHRcXHRcXHRvYmplY3QubWF0cml4ID0gdGhpcy5tYXRyaXgudG9BcnJheSgpO1xcblxcblxcdFxcdFxcdC8vXFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gc2VyaWFsaXplKCBsaWJyYXJ5LCBlbGVtZW50ICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggbGlicmFyeVsgZWxlbWVudC51dWlkIF0gPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRsaWJyYXJ5WyBlbGVtZW50LnV1aWQgXSA9IGVsZW1lbnQudG9KU09OKCBtZXRhICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiBlbGVtZW50LnV1aWQ7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdGhpcy5nZW9tZXRyeSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdG9iamVjdC5nZW9tZXRyeSA9IHNlcmlhbGl6ZSggbWV0YS5nZW9tZXRyaWVzLCB0aGlzLmdlb21ldHJ5ICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHBhcmFtZXRlcnMgPSB0aGlzLmdlb21ldHJ5LnBhcmFtZXRlcnM7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgJiYgcGFyYW1ldGVycy5zaGFwZXMgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgc2hhcGVzID0gcGFyYW1ldGVycy5zaGFwZXM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzaGFwZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgc2hhcGUgPSBzaGFwZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzZXJpYWxpemUoIG1ldGEuc2hhcGVzLCBzaGFwZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHNlcmlhbGl6ZSggbWV0YS5zaGFwZXMsIHNoYXBlcyApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdGhpcy5tYXRlcmlhbCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggdGhpcy5tYXRlcmlhbCApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB1dWlkcyA9IFtdO1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMubWF0ZXJpYWwubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR1dWlkcy5wdXNoKCBzZXJpYWxpemUoIG1ldGEubWF0ZXJpYWxzLCB0aGlzLm1hdGVyaWFsWyBpIF0gKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRvYmplY3QubWF0ZXJpYWwgPSB1dWlkcztcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdG9iamVjdC5tYXRlcmlhbCA9IHNlcmlhbGl6ZSggbWV0YS5tYXRlcmlhbHMsIHRoaXMubWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vXFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0b2JqZWN0LmNoaWxkcmVuID0gW107XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0b2JqZWN0LmNoaWxkcmVuLnB1c2goIHRoaXMuY2hpbGRyZW5bIGkgXS50b0pTT04oIG1ldGEgKS5vYmplY3QgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggaXNSb290T2JqZWN0ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBnZW9tZXRyaWVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS5nZW9tZXRyaWVzICk7XFxuXFx0XFx0XFx0XFx0dmFyIG1hdGVyaWFscyA9IGV4dHJhY3RGcm9tQ2FjaGUoIG1ldGEubWF0ZXJpYWxzICk7XFxuXFx0XFx0XFx0XFx0dmFyIHRleHR1cmVzID0gZXh0cmFjdEZyb21DYWNoZSggbWV0YS50ZXh0dXJlcyApO1xcblxcdFxcdFxcdFxcdHZhciBpbWFnZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLmltYWdlcyApO1xcblxcdFxcdFxcdFxcdHZhciBzaGFwZXMgPSBleHRyYWN0RnJvbUNhY2hlKCBtZXRhLnNoYXBlcyApO1xcblxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cmllcy5sZW5ndGggPiAwICkgb3V0cHV0Lmdlb21ldHJpZXMgPSBnZW9tZXRyaWVzO1xcblxcdFxcdFxcdFxcdGlmICggbWF0ZXJpYWxzLmxlbmd0aCA+IDAgKSBvdXRwdXQubWF0ZXJpYWxzID0gbWF0ZXJpYWxzO1xcblxcdFxcdFxcdFxcdGlmICggdGV4dHVyZXMubGVuZ3RoID4gMCApIG91dHB1dC50ZXh0dXJlcyA9IHRleHR1cmVzO1xcblxcdFxcdFxcdFxcdGlmICggaW1hZ2VzLmxlbmd0aCA+IDAgKSBvdXRwdXQuaW1hZ2VzID0gaW1hZ2VzO1xcblxcdFxcdFxcdFxcdGlmICggc2hhcGVzLmxlbmd0aCA+IDAgKSBvdXRwdXQuc2hhcGVzID0gc2hhcGVzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRvdXRwdXQub2JqZWN0ID0gb2JqZWN0O1xcblxcblxcdFxcdFxcdHJldHVybiBvdXRwdXQ7XFxuXFxuXFx0XFx0XFx0Ly8gZXh0cmFjdCBkYXRhIGZyb20gdGhlIGNhY2hlIGhhc2hcXG5cXHRcXHRcXHQvLyByZW1vdmUgbWV0YWRhdGEgb24gZWFjaCBpdGVtXFxuXFx0XFx0XFx0Ly8gYW5kIHJldHVybiBhcyBhcnJheVxcblxcdFxcdFxcdGZ1bmN0aW9uIGV4dHJhY3RGcm9tQ2FjaGUoIGNhY2hlICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB2YWx1ZXMgPSBbXTtcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIga2V5IGluIGNhY2hlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBkYXRhID0gY2FjaGVbIGtleSBdO1xcblxcdFxcdFxcdFxcdFxcdGRlbGV0ZSBkYXRhLm1ldGFkYXRhO1xcblxcdFxcdFxcdFxcdFxcdHZhbHVlcy5wdXNoKCBkYXRhICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiB2YWx1ZXM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICggcmVjdXJzaXZlICkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMsIHJlY3Vyc2l2ZSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHJlY3Vyc2l2ZSA9PT0gdW5kZWZpbmVkICkgcmVjdXJzaXZlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcXG5cXG5cXHRcXHRcXHR0aGlzLnVwLmNvcHkoIHNvdXJjZS51cCApO1xcblxcblxcdFxcdFxcdHRoaXMucG9zaXRpb24uY29weSggc291cmNlLnBvc2l0aW9uICk7XFxuXFx0XFx0XFx0dGhpcy5xdWF0ZXJuaW9uLmNvcHkoIHNvdXJjZS5xdWF0ZXJuaW9uICk7XFxuXFx0XFx0XFx0dGhpcy5zY2FsZS5jb3B5KCBzb3VyY2Uuc2NhbGUgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLm1hdHJpeC5jb3B5KCBzb3VyY2UubWF0cml4ICk7XFxuXFx0XFx0XFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5KCBzb3VyY2UubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLm1hdHJpeEF1dG9VcGRhdGUgPSBzb3VyY2UubWF0cml4QXV0b1VwZGF0ZTtcXG5cXHRcXHRcXHR0aGlzLm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSBzb3VyY2UubWF0cml4V29ybGROZWVkc1VwZGF0ZTtcXG5cXG5cXHRcXHRcXHR0aGlzLmxheWVycy5tYXNrID0gc291cmNlLmxheWVycy5tYXNrO1xcblxcdFxcdFxcdHRoaXMudmlzaWJsZSA9IHNvdXJjZS52aXNpYmxlO1xcblxcblxcdFxcdFxcdHRoaXMuY2FzdFNoYWRvdyA9IHNvdXJjZS5jYXN0U2hhZG93O1xcblxcdFxcdFxcdHRoaXMucmVjZWl2ZVNoYWRvdyA9IHNvdXJjZS5yZWNlaXZlU2hhZG93O1xcblxcblxcdFxcdFxcdHRoaXMuZnJ1c3R1bUN1bGxlZCA9IHNvdXJjZS5mcnVzdHVtQ3VsbGVkO1xcblxcdFxcdFxcdHRoaXMucmVuZGVyT3JkZXIgPSBzb3VyY2UucmVuZGVyT3JkZXI7XFxuXFxuXFx0XFx0XFx0dGhpcy51c2VyRGF0YSA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBzb3VyY2UudXNlckRhdGEgKSApO1xcblxcblxcdFxcdFxcdGlmICggcmVjdXJzaXZlID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IHNvdXJjZS5jaGlsZHJlbi5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNoaWxkID0gc291cmNlLmNoaWxkcmVuWyBpIF07XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5hZGQoIGNoaWxkLmNsb25lKCkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcblxcdCovXFxuXFxuXFx0ZnVuY3Rpb24gQ2FtZXJhKCkge1xcblxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnQ2FtZXJhJztcXG5cXG5cXHRcXHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZSA9IG5ldyBNYXRyaXg0KCk7XFxuXFx0XFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcXG5cXG5cXHR9XFxuXFxuXFx0Q2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IENhbWVyYSxcXG5cXG5cXHRcXHRpc0NhbWVyYTogdHJ1ZSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSwgcmVjdXJzaXZlICkge1xcblxcblxcdFxcdFxcdE9iamVjdDNELnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSwgcmVjdXJzaXZlICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5tYXRyaXhXb3JsZEludmVyc2UuY29weSggc291cmNlLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xcblxcdFxcdFxcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBzb3VyY2UucHJvamVjdGlvbk1hdHJpeCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0V29ybGREaXJlY3Rpb246IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgcXVhdGVybmlvbiA9IG5ldyBRdWF0ZXJuaW9uKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGdldFdvcmxkRGlyZWN0aW9uKCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmdldFdvcmxkUXVhdGVybmlvbiggcXVhdGVybmlvbiApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQuc2V0KCAwLCAwLCAtIDEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHR1cGRhdGVNYXRyaXhXb3JsZDogZnVuY3Rpb24gKCBmb3JjZSApIHtcXG5cXG5cXHRcXHRcXHRPYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLm1hdHJpeFdvcmxkSW52ZXJzZS5nZXRJbnZlcnNlKCB0aGlzLm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICogQGF1dGhvciBhcm9zZSAvIGh0dHA6Ly9naXRodWIuY29tL2Fyb3NlXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gT3J0aG9ncmFwaGljQ2FtZXJhKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApIHtcXG5cXG5cXHRcXHRDYW1lcmEuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdPcnRob2dyYXBoaWNDYW1lcmEnO1xcblxcblxcdFxcdHRoaXMuem9vbSA9IDE7XFxuXFx0XFx0dGhpcy52aWV3ID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLmxlZnQgPSBsZWZ0O1xcblxcdFxcdHRoaXMucmlnaHQgPSByaWdodDtcXG5cXHRcXHR0aGlzLnRvcCA9IHRvcDtcXG5cXHRcXHR0aGlzLmJvdHRvbSA9IGJvdHRvbTtcXG5cXG5cXHRcXHR0aGlzLm5lYXIgPSAoIG5lYXIgIT09IHVuZGVmaW5lZCApID8gbmVhciA6IDAuMTtcXG5cXHRcXHR0aGlzLmZhciA9ICggZmFyICE9PSB1bmRlZmluZWQgKSA/IGZhciA6IDIwMDA7XFxuXFxuXFx0XFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XFxuXFxuXFx0fVxcblxcblxcdE9ydGhvZ3JhcGhpY0NhbWVyYS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBDYW1lcmEucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogT3J0aG9ncmFwaGljQ2FtZXJhLFxcblxcblxcdFxcdGlzT3J0aG9ncmFwaGljQ2FtZXJhOiB0cnVlLFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlLCByZWN1cnNpdmUgKSB7XFxuXFxuXFx0XFx0XFx0Q2FtZXJhLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSwgcmVjdXJzaXZlICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5sZWZ0ID0gc291cmNlLmxlZnQ7XFxuXFx0XFx0XFx0dGhpcy5yaWdodCA9IHNvdXJjZS5yaWdodDtcXG5cXHRcXHRcXHR0aGlzLnRvcCA9IHNvdXJjZS50b3A7XFxuXFx0XFx0XFx0dGhpcy5ib3R0b20gPSBzb3VyY2UuYm90dG9tO1xcblxcdFxcdFxcdHRoaXMubmVhciA9IHNvdXJjZS5uZWFyO1xcblxcdFxcdFxcdHRoaXMuZmFyID0gc291cmNlLmZhcjtcXG5cXG5cXHRcXHRcXHR0aGlzLnpvb20gPSBzb3VyY2Uuem9vbTtcXG5cXHRcXHRcXHR0aGlzLnZpZXcgPSBzb3VyY2UudmlldyA9PT0gbnVsbCA/IG51bGwgOiBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLnZpZXcgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFZpZXdPZmZzZXQ6IGZ1bmN0aW9uICggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xcblxcblxcdFxcdFxcdGlmICggdGhpcy52aWV3ID09PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMudmlldyA9IHtcXG5cXHRcXHRcXHRcXHRcXHRlbmFibGVkOiB0cnVlLFxcblxcdFxcdFxcdFxcdFxcdGZ1bGxXaWR0aDogMSxcXG5cXHRcXHRcXHRcXHRcXHRmdWxsSGVpZ2h0OiAxLFxcblxcdFxcdFxcdFxcdFxcdG9mZnNldFg6IDAsXFxuXFx0XFx0XFx0XFx0XFx0b2Zmc2V0WTogMCxcXG5cXHRcXHRcXHRcXHRcXHR3aWR0aDogMSxcXG5cXHRcXHRcXHRcXHRcXHRoZWlnaHQ6IDFcXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLnZpZXcuZW5hYmxlZCA9IHRydWU7XFxuXFx0XFx0XFx0dGhpcy52aWV3LmZ1bGxXaWR0aCA9IGZ1bGxXaWR0aDtcXG5cXHRcXHRcXHR0aGlzLnZpZXcuZnVsbEhlaWdodCA9IGZ1bGxIZWlnaHQ7XFxuXFx0XFx0XFx0dGhpcy52aWV3Lm9mZnNldFggPSB4O1xcblxcdFxcdFxcdHRoaXMudmlldy5vZmZzZXRZID0geTtcXG5cXHRcXHRcXHR0aGlzLnZpZXcud2lkdGggPSB3aWR0aDtcXG5cXHRcXHRcXHR0aGlzLnZpZXcuaGVpZ2h0ID0gaGVpZ2h0O1xcblxcblxcdFxcdFxcdHRoaXMudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xlYXJWaWV3T2Zmc2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy52aWV3LmVuYWJsZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR1cGRhdGVQcm9qZWN0aW9uTWF0cml4OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGR4ID0gKCB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0ICkgLyAoIDIgKiB0aGlzLnpvb20gKTtcXG5cXHRcXHRcXHR2YXIgZHkgPSAoIHRoaXMudG9wIC0gdGhpcy5ib3R0b20gKSAvICggMiAqIHRoaXMuem9vbSApO1xcblxcdFxcdFxcdHZhciBjeCA9ICggdGhpcy5yaWdodCArIHRoaXMubGVmdCApIC8gMjtcXG5cXHRcXHRcXHR2YXIgY3kgPSAoIHRoaXMudG9wICsgdGhpcy5ib3R0b20gKSAvIDI7XFxuXFxuXFx0XFx0XFx0dmFyIGxlZnQgPSBjeCAtIGR4O1xcblxcdFxcdFxcdHZhciByaWdodCA9IGN4ICsgZHg7XFxuXFx0XFx0XFx0dmFyIHRvcCA9IGN5ICsgZHk7XFxuXFx0XFx0XFx0dmFyIGJvdHRvbSA9IGN5IC0gZHk7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgJiYgdGhpcy52aWV3LmVuYWJsZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHpvb21XID0gdGhpcy56b29tIC8gKCB0aGlzLnZpZXcud2lkdGggLyB0aGlzLnZpZXcuZnVsbFdpZHRoICk7XFxuXFx0XFx0XFx0XFx0dmFyIHpvb21IID0gdGhpcy56b29tIC8gKCB0aGlzLnZpZXcuaGVpZ2h0IC8gdGhpcy52aWV3LmZ1bGxIZWlnaHQgKTtcXG5cXHRcXHRcXHRcXHR2YXIgc2NhbGVXID0gKCB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0ICkgLyB0aGlzLnZpZXcud2lkdGg7XFxuXFx0XFx0XFx0XFx0dmFyIHNjYWxlSCA9ICggdGhpcy50b3AgLSB0aGlzLmJvdHRvbSApIC8gdGhpcy52aWV3LmhlaWdodDtcXG5cXG5cXHRcXHRcXHRcXHRsZWZ0ICs9IHNjYWxlVyAqICggdGhpcy52aWV3Lm9mZnNldFggLyB6b29tVyApO1xcblxcdFxcdFxcdFxcdHJpZ2h0ID0gbGVmdCArIHNjYWxlVyAqICggdGhpcy52aWV3LndpZHRoIC8gem9vbVcgKTtcXG5cXHRcXHRcXHRcXHR0b3AgLT0gc2NhbGVIICogKCB0aGlzLnZpZXcub2Zmc2V0WSAvIHpvb21IICk7XFxuXFx0XFx0XFx0XFx0Ym90dG9tID0gdG9wIC0gc2NhbGVIICogKCB0aGlzLnZpZXcuaGVpZ2h0IC8gem9vbUggKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5wcm9qZWN0aW9uTWF0cml4Lm1ha2VPcnRob2dyYXBoaWMoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGRhdGEgPSBPYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcXG5cXG5cXHRcXHRcXHRkYXRhLm9iamVjdC56b29tID0gdGhpcy56b29tO1xcblxcdFxcdFxcdGRhdGEub2JqZWN0LmxlZnQgPSB0aGlzLmxlZnQ7XFxuXFx0XFx0XFx0ZGF0YS5vYmplY3QucmlnaHQgPSB0aGlzLnJpZ2h0O1xcblxcdFxcdFxcdGRhdGEub2JqZWN0LnRvcCA9IHRoaXMudG9wO1xcblxcdFxcdFxcdGRhdGEub2JqZWN0LmJvdHRvbSA9IHRoaXMuYm90dG9tO1xcblxcdFxcdFxcdGRhdGEub2JqZWN0Lm5lYXIgPSB0aGlzLm5lYXI7XFxuXFx0XFx0XFx0ZGF0YS5vYmplY3QuZmFyID0gdGhpcy5mYXI7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgKSBkYXRhLm9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbigge30sIHRoaXMudmlldyApO1xcblxcblxcdFxcdFxcdHJldHVybiBkYXRhO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEZhY2UzKCBhLCBiLCBjLCBub3JtYWwsIGNvbG9yLCBtYXRlcmlhbEluZGV4ICkge1xcblxcblxcdFxcdHRoaXMuYSA9IGE7XFxuXFx0XFx0dGhpcy5iID0gYjtcXG5cXHRcXHR0aGlzLmMgPSBjO1xcblxcblxcdFxcdHRoaXMubm9ybWFsID0gKCBub3JtYWwgJiYgbm9ybWFsLmlzVmVjdG9yMyApID8gbm9ybWFsIDogbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR0aGlzLnZlcnRleE5vcm1hbHMgPSBBcnJheS5pc0FycmF5KCBub3JtYWwgKSA/IG5vcm1hbCA6IFtdO1xcblxcblxcdFxcdHRoaXMuY29sb3IgPSAoIGNvbG9yICYmIGNvbG9yLmlzQ29sb3IgKSA/IGNvbG9yIDogbmV3IENvbG9yKCk7XFxuXFx0XFx0dGhpcy52ZXJ0ZXhDb2xvcnMgPSBBcnJheS5pc0FycmF5KCBjb2xvciApID8gY29sb3IgOiBbXTtcXG5cXG5cXHRcXHR0aGlzLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4ICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbEluZGV4IDogMDtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggRmFjZTMucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmEgPSBzb3VyY2UuYTtcXG5cXHRcXHRcXHR0aGlzLmIgPSBzb3VyY2UuYjtcXG5cXHRcXHRcXHR0aGlzLmMgPSBzb3VyY2UuYztcXG5cXG5cXHRcXHRcXHR0aGlzLm5vcm1hbC5jb3B5KCBzb3VyY2Uubm9ybWFsICk7XFxuXFx0XFx0XFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLm1hdGVyaWFsSW5kZXggPSBzb3VyY2UubWF0ZXJpYWxJbmRleDtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gc291cmNlLnZlcnRleE5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy52ZXJ0ZXhOb3JtYWxzWyBpIF0gPSBzb3VyY2UudmVydGV4Tm9ybWFsc1sgaSBdLmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBzb3VyY2UudmVydGV4Q29sb3JzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMudmVydGV4Q29sb3JzWyBpIF0gPSBzb3VyY2UudmVydGV4Q29sb3JzWyBpIF0uY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3Iga2lsZSAvIGh0dHA6Ly9raWxlLnN0cmF2YWdhbnphLm9yZy9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXFxuXFx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xcblxcdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cXG5cXHQgKi9cXG5cXG5cXHR2YXIgZ2VvbWV0cnlJZCA9IDA7IC8vIEdlb21ldHJ5IHVzZXMgZXZlbiBudW1iZXJzIGFzIElkXFxuXFxuXFx0ZnVuY3Rpb24gR2VvbWV0cnkoKSB7XFxuXFxuXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAnaWQnLCB7IHZhbHVlOiBnZW9tZXRyeUlkICs9IDIgfSApO1xcblxcblxcdFxcdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xcblxcblxcdFxcdHRoaXMubmFtZSA9ICcnO1xcblxcdFxcdHRoaXMudHlwZSA9ICdHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy52ZXJ0aWNlcyA9IFtdO1xcblxcdFxcdHRoaXMuY29sb3JzID0gW107XFxuXFx0XFx0dGhpcy5mYWNlcyA9IFtdO1xcblxcdFxcdHRoaXMuZmFjZVZlcnRleFV2cyA9IFtbXV07XFxuXFxuXFx0XFx0dGhpcy5tb3JwaFRhcmdldHMgPSBbXTtcXG5cXHRcXHR0aGlzLm1vcnBoTm9ybWFscyA9IFtdO1xcblxcblxcdFxcdHRoaXMuc2tpbldlaWdodHMgPSBbXTtcXG5cXHRcXHR0aGlzLnNraW5JbmRpY2VzID0gW107XFxuXFxuXFx0XFx0dGhpcy5saW5lRGlzdGFuY2VzID0gW107XFxuXFxuXFx0XFx0dGhpcy5ib3VuZGluZ0JveCA9IG51bGw7XFxuXFx0XFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG51bGw7XFxuXFxuXFx0XFx0Ly8gdXBkYXRlIGZsYWdzXFxuXFxuXFx0XFx0dGhpcy5lbGVtZW50c05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcblxcdFxcdHRoaXMudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcblxcdFxcdHRoaXMubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5ncm91cHNOZWVkVXBkYXRlID0gZmFsc2U7XFxuXFxuXFx0fVxcblxcblxcdEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBHZW9tZXRyeSxcXG5cXG5cXHRcXHRpc0dlb21ldHJ5OiB0cnVlLFxcblxcblxcdFxcdGFwcGx5TWF0cml4OiBmdW5jdGlvbiAoIG1hdHJpeCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgbm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XFxuXFx0XFx0XFx0XFx0dmVydGV4LmFwcGx5TWF0cml4NCggbWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xcblxcdFxcdFxcdFxcdGZhY2Uubm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmYWNlLnZlcnRleE5vcm1hbHNbIGogXS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdGhpcy5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHRydWU7XFxuXFx0XFx0XFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyb3RhdGVYOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB4LWF4aXNcXG5cXG5cXHRcXHRcXHR2YXIgbTEgPSBuZXcgTWF0cml4NCgpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiByb3RhdGVYKCBhbmdsZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRtMS5tYWtlUm90YXRpb25YKCBhbmdsZSApO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0cm90YXRlWTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeS1heGlzXFxuXFxuXFx0XFx0XFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bTEubWFrZVJvdGF0aW9uWSggYW5nbGUgKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHotYXhpc1xcblxcblxcdFxcdFxcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVooIGFuZ2xlICkge1xcblxcblxcdFxcdFxcdFxcdG0xLm1ha2VSb3RhdGlvblooIGFuZ2xlICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyB0cmFuc2xhdGUgZ2VvbWV0cnlcXG5cXG5cXHRcXHRcXHR2YXIgbTEgPSBuZXcgTWF0cml4NCgpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGUoIHgsIHksIHogKSB7XFxuXFxuXFx0XFx0XFx0XFx0bTEubWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRzY2FsZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIHNjYWxlIGdlb21ldHJ5XFxuXFxuXFx0XFx0XFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gc2NhbGUoIHgsIHksIHogKSB7XFxuXFxuXFx0XFx0XFx0XFx0bTEubWFrZVNjYWxlKCB4LCB5LCB6ICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgb2JqID0gbmV3IE9iamVjdDNEKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggdmVjdG9yICkge1xcblxcblxcdFxcdFxcdFxcdG9iai5sb29rQXQoIHZlY3RvciApO1xcblxcblxcdFxcdFxcdFxcdG9iai51cGRhdGVNYXRyaXgoKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmFwcGx5TWF0cml4KCBvYmoubWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0ZnJvbUJ1ZmZlckdlb21ldHJ5OiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxuXFxuXFx0XFx0XFx0dmFyIGluZGljZXMgPSBnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCA/IGdlb21ldHJ5LmluZGV4LmFycmF5IDogdW5kZWZpbmVkO1xcblxcdFxcdFxcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcXG5cXG5cXHRcXHRcXHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcXG5cXHRcXHRcXHR2YXIgbm9ybWFscyA9IGF0dHJpYnV0ZXMubm9ybWFsICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLm5vcm1hbC5hcnJheSA6IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHR2YXIgY29sb3JzID0gYXR0cmlidXRlcy5jb2xvciAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy5jb2xvci5hcnJheSA6IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHR2YXIgdXZzID0gYXR0cmlidXRlcy51diAhPT0gdW5kZWZpbmVkID8gYXR0cmlidXRlcy51di5hcnJheSA6IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHR2YXIgdXZzMiA9IGF0dHJpYnV0ZXMudXYyICE9PSB1bmRlZmluZWQgPyBhdHRyaWJ1dGVzLnV2Mi5hcnJheSA6IHVuZGVmaW5lZDtcXG5cXG5cXHRcXHRcXHRpZiAoIHV2czIgIT09IHVuZGVmaW5lZCApIHRoaXMuZmFjZVZlcnRleFV2c1sgMSBdID0gW107XFxuXFxuXFx0XFx0XFx0dmFyIHRlbXBOb3JtYWxzID0gW107XFxuXFx0XFx0XFx0dmFyIHRlbXBVVnMgPSBbXTtcXG5cXHRcXHRcXHR2YXIgdGVtcFVWczIgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSArPSAzLCBqICs9IDIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c2NvcGUudmVydGljZXMucHVzaCggbmV3IFZlY3RvcjMoIHBvc2l0aW9uc1sgaSBdLCBwb3NpdGlvbnNbIGkgKyAxIF0sIHBvc2l0aW9uc1sgaSArIDIgXSApICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBub3JtYWxzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGVtcE5vcm1hbHMucHVzaCggbmV3IFZlY3RvcjMoIG5vcm1hbHNbIGkgXSwgbm9ybWFsc1sgaSArIDEgXSwgbm9ybWFsc1sgaSArIDIgXSApICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggY29sb3JzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2NvcGUuY29sb3JzLnB1c2goIG5ldyBDb2xvciggY29sb3JzWyBpIF0sIGNvbG9yc1sgaSArIDEgXSwgY29sb3JzWyBpICsgMiBdICkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB1dnMgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0ZW1wVVZzLnB1c2goIG5ldyBWZWN0b3IyKCB1dnNbIGogXSwgdXZzWyBqICsgMSBdICkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB1dnMyICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGVtcFVWczIucHVzaCggbmV3IFZlY3RvcjIoIHV2czJbIGogXSwgdXZzMlsgaiArIDEgXSApICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBhZGRGYWNlKCBhLCBiLCBjLCBtYXRlcmlhbEluZGV4ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB2ZXJ0ZXhOb3JtYWxzID0gbm9ybWFscyAhPT0gdW5kZWZpbmVkID8gWyB0ZW1wTm9ybWFsc1sgYSBdLmNsb25lKCksIHRlbXBOb3JtYWxzWyBiIF0uY2xvbmUoKSwgdGVtcE5vcm1hbHNbIGMgXS5jbG9uZSgpIF0gOiBbXTtcXG5cXHRcXHRcXHRcXHR2YXIgdmVydGV4Q29sb3JzID0gY29sb3JzICE9PSB1bmRlZmluZWQgPyBbIHNjb3BlLmNvbG9yc1sgYSBdLmNsb25lKCksIHNjb3BlLmNvbG9yc1sgYiBdLmNsb25lKCksIHNjb3BlLmNvbG9yc1sgYyBdLmNsb25lKCkgXSA6IFtdO1xcblxcblxcdFxcdFxcdFxcdHZhciBmYWNlID0gbmV3IEZhY2UzKCBhLCBiLCBjLCB2ZXJ0ZXhOb3JtYWxzLCB2ZXJ0ZXhDb2xvcnMsIG1hdGVyaWFsSW5kZXggKTtcXG5cXG5cXHRcXHRcXHRcXHRzY29wZS5mYWNlcy5wdXNoKCBmYWNlICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB1dnMgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzY29wZS5mYWNlVmVydGV4VXZzWyAwIF0ucHVzaCggWyB0ZW1wVVZzWyBhIF0uY2xvbmUoKSwgdGVtcFVWc1sgYiBdLmNsb25lKCksIHRlbXBVVnNbIGMgXS5jbG9uZSgpIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB1dnMyICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2NvcGUuZmFjZVZlcnRleFV2c1sgMSBdLnB1c2goIFsgdGVtcFVWczJbIGEgXS5jbG9uZSgpLCB0ZW1wVVZzMlsgYiBdLmNsb25lKCksIHRlbXBVVnMyWyBjIF0uY2xvbmUoKSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xcblxcblxcdFxcdFxcdGlmICggZ3JvdXBzLmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZ3JvdXBzLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgc3RhcnQgPSBncm91cC5zdGFydDtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgY291bnQgPSBncm91cC5jb3VudDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IHN0YXJ0LCBqbCA9IHN0YXJ0ICsgY291bnQ7IGogPCBqbDsgaiArPSAzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaW5kaWNlcyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGFkZEZhY2UoIGluZGljZXNbIGogXSwgaW5kaWNlc1sgaiArIDEgXSwgaW5kaWNlc1sgaiArIDIgXSwgZ3JvdXAubWF0ZXJpYWxJbmRleCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YWRkRmFjZSggaiwgaiArIDEsIGogKyAyLCBncm91cC5tYXRlcmlhbEluZGV4ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGluZGljZXMgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSArPSAzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGFkZEZhY2UoIGluZGljZXNbIGkgXSwgaW5kaWNlc1sgaSArIDEgXSwgaW5kaWNlc1sgaSArIDIgXSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGggLyAzOyBpICs9IDMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YWRkRmFjZSggaSwgaSArIDEsIGkgKyAyICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nQm94ICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYm91bmRpbmdCb3ggPSBnZW9tZXRyeS5ib3VuZGluZ0JveC5jbG9uZSgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZS5jbG9uZSgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNlbnRlcjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMuY29tcHV0ZUJvdW5kaW5nQm94KCk7XFxuXFxuXFx0XFx0XFx0dmFyIG9mZnNldCA9IHRoaXMuYm91bmRpbmdCb3guZ2V0Q2VudGVyKCkubmVnYXRlKCk7XFxuXFxuXFx0XFx0XFx0dGhpcy50cmFuc2xhdGUoIG9mZnNldC54LCBvZmZzZXQueSwgb2Zmc2V0LnogKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gb2Zmc2V0O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bm9ybWFsaXplOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcXG5cXG5cXHRcXHRcXHR2YXIgY2VudGVyID0gdGhpcy5ib3VuZGluZ1NwaGVyZS5jZW50ZXI7XFxuXFx0XFx0XFx0dmFyIHJhZGl1cyA9IHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzO1xcblxcblxcdFxcdFxcdHZhciBzID0gcmFkaXVzID09PSAwID8gMSA6IDEuMCAvIHJhZGl1cztcXG5cXG5cXHRcXHRcXHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcXG5cXHRcXHRcXHRtYXRyaXguc2V0KFxcblxcdFxcdFxcdFxcdHMsIDAsIDAsIC0gcyAqIGNlbnRlci54LFxcblxcdFxcdFxcdFxcdDAsIHMsIDAsIC0gcyAqIGNlbnRlci55LFxcblxcdFxcdFxcdFxcdDAsIDAsIHMsIC0gcyAqIGNlbnRlci56LFxcblxcdFxcdFxcdFxcdDAsIDAsIDAsIDFcXG5cXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdHRoaXMuYXBwbHlNYXRyaXgoIG1hdHJpeCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29tcHV0ZUZhY2VOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGNiID0gbmV3IFZlY3RvcjMoKSwgYWIgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xcblxcblxcdFxcdFxcdFxcdHZhciB2QSA9IHRoaXMudmVydGljZXNbIGZhY2UuYSBdO1xcblxcdFxcdFxcdFxcdHZhciB2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xcblxcdFxcdFxcdFxcdHZhciB2QyA9IHRoaXMudmVydGljZXNbIGZhY2UuYyBdO1xcblxcblxcdFxcdFxcdFxcdGNiLnN1YlZlY3RvcnMoIHZDLCB2QiApO1xcblxcdFxcdFxcdFxcdGFiLnN1YlZlY3RvcnMoIHZBLCB2QiApO1xcblxcdFxcdFxcdFxcdGNiLmNyb3NzKCBhYiApO1xcblxcblxcdFxcdFxcdFxcdGNiLm5vcm1hbGl6ZSgpO1xcblxcblxcdFxcdFxcdFxcdGZhY2Uubm9ybWFsLmNvcHkoIGNiICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICggYXJlYVdlaWdodGVkICkge1xcblxcblxcdFxcdFxcdGlmICggYXJlYVdlaWdodGVkID09PSB1bmRlZmluZWQgKSBhcmVhV2VpZ2h0ZWQgPSB0cnVlO1xcblxcblxcdFxcdFxcdHZhciB2LCB2bCwgZiwgZmwsIGZhY2UsIHZlcnRpY2VzO1xcblxcblxcdFxcdFxcdHZlcnRpY2VzID0gbmV3IEFycmF5KCB0aGlzLnZlcnRpY2VzLmxlbmd0aCApO1xcblxcblxcdFxcdFxcdGZvciAoIHYgPSAwLCB2bCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmVydGljZXNbIHYgXSA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggYXJlYVdlaWdodGVkICkge1xcblxcblxcdFxcdFxcdFxcdC8vIHZlcnRleCBub3JtYWxzIHdlaWdodGVkIGJ5IHRyaWFuZ2xlIGFyZWFzXFxuXFx0XFx0XFx0XFx0Ly8gaHR0cDovL3d3dy5pcXVpbGV6bGVzLm9yZy93d3cvYXJ0aWNsZXMvbm9ybWFscy9ub3JtYWxzLmh0bVxcblxcblxcdFxcdFxcdFxcdHZhciB2QSwgdkIsIHZDO1xcblxcdFxcdFxcdFxcdHZhciBjYiA9IG5ldyBWZWN0b3IzKCksIGFiID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0dkEgPSB0aGlzLnZlcnRpY2VzWyBmYWNlLmEgXTtcXG5cXHRcXHRcXHRcXHRcXHR2QiA9IHRoaXMudmVydGljZXNbIGZhY2UuYiBdO1xcblxcdFxcdFxcdFxcdFxcdHZDID0gdGhpcy52ZXJ0aWNlc1sgZmFjZS5jIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2Iuc3ViVmVjdG9ycyggdkMsIHZCICk7XFxuXFx0XFx0XFx0XFx0XFx0YWIuc3ViVmVjdG9ycyggdkEsIHZCICk7XFxuXFx0XFx0XFx0XFx0XFx0Y2IuY3Jvc3MoIGFiICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVydGljZXNbIGZhY2UuYSBdLmFkZCggY2IgKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0aWNlc1sgZmFjZS5iIF0uYWRkKCBjYiApO1xcblxcdFxcdFxcdFxcdFxcdHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGNiICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVydGljZXNbIGZhY2UuYSBdLmFkZCggZmFjZS5ub3JtYWwgKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0aWNlc1sgZmFjZS5iIF0uYWRkKCBmYWNlLm5vcm1hbCApO1xcblxcdFxcdFxcdFxcdFxcdHZlcnRpY2VzWyBmYWNlLmMgXS5hZGQoIGZhY2Uubm9ybWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmb3IgKCB2ID0gMCwgdmwgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aDsgdiA8IHZsOyB2ICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZlcnRpY2VzWyB2IF0ubm9ybWFsaXplKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHZlcnRleE5vcm1hbHMubGVuZ3RoID09PSAzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZlcnRleE5vcm1hbHNbIDAgXS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5hIF0gKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhOb3JtYWxzWyAxIF0uY29weSggdmVydGljZXNbIGZhY2UuYiBdICk7XFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4Tm9ybWFsc1sgMiBdLmNvcHkoIHZlcnRpY2VzWyBmYWNlLmMgXSApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4Tm9ybWFsc1sgMCBdID0gdmVydGljZXNbIGZhY2UuYSBdLmNsb25lKCk7XFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4Tm9ybWFsc1sgMSBdID0gdmVydGljZXNbIGZhY2UuYiBdLmNsb25lKCk7XFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4Tm9ybWFsc1sgMiBdID0gdmVydGljZXNbIGZhY2UuYyBdLmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuZmFjZXMubGVuZ3RoID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb21wdXRlRmxhdFZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgZiwgZmwsIGZhY2U7XFxuXFxuXFx0XFx0XFx0dGhpcy5jb21wdXRlRmFjZU5vcm1hbHMoKTtcXG5cXG5cXHRcXHRcXHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xcblxcblxcdFxcdFxcdFxcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB2ZXJ0ZXhOb3JtYWxzLmxlbmd0aCA9PT0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhOb3JtYWxzWyAwIF0uY29weSggZmFjZS5ub3JtYWwgKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhOb3JtYWxzWyAxIF0uY29weSggZmFjZS5ub3JtYWwgKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhOb3JtYWxzWyAyIF0uY29weSggZmFjZS5ub3JtYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHZlcnRleE5vcm1hbHNbIDAgXSA9IGZhY2Uubm9ybWFsLmNsb25lKCk7XFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4Tm9ybWFsc1sgMSBdID0gZmFjZS5ub3JtYWwuY2xvbmUoKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhOb3JtYWxzWyAyIF0gPSBmYWNlLm5vcm1hbC5jbG9uZSgpO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmZhY2VzLmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29tcHV0ZU1vcnBoTm9ybWFsczogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBpLCBpbCwgZiwgZmwsIGZhY2U7XFxuXFxuXFx0XFx0XFx0Ly8gc2F2ZSBvcmlnaW5hbCBub3JtYWxzXFxuXFx0XFx0XFx0Ly8gLSBjcmVhdGUgdGVtcCB2YXJpYWJsZXMgb24gZmlyc3QgYWNjZXNzXFxuXFx0XFx0XFx0Ly8gICBvdGhlcndpc2UganVzdCBjb3B5IChmb3IgZmFzdGVyIHJlcGVhdGVkIGNhbGxzKVxcblxcblxcdFxcdFxcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGYgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoICEgZmFjZS5fX29yaWdpbmFsRmFjZU5vcm1hbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsID0gZmFjZS5ub3JtYWwuY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdGZhY2UuX19vcmlnaW5hbEZhY2VOb3JtYWwuY29weSggZmFjZS5ub3JtYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAhIGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHMgKSBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzID0gW107XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggISBmYWNlLl9fb3JpZ2luYWxWZXJ0ZXhOb3JtYWxzWyBpIF0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmFjZS5fX29yaWdpbmFsVmVydGV4Tm9ybWFsc1sgaSBdID0gZmFjZS52ZXJ0ZXhOb3JtYWxzWyBpIF0uY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHNbIGkgXS5jb3B5KCBmYWNlLnZlcnRleE5vcm1hbHNbIGkgXSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHVzZSB0ZW1wIGdlb21ldHJ5IHRvIGNvbXB1dGUgZmFjZSBhbmQgdmVydGV4IG5vcm1hbHMgZm9yIGVhY2ggbW9ycGhcXG5cXG5cXHRcXHRcXHR2YXIgdG1wR2VvID0gbmV3IEdlb21ldHJ5KCk7XFxuXFx0XFx0XFx0dG1wR2VvLmZhY2VzID0gdGhpcy5mYWNlcztcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLm1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBjcmVhdGUgb24gZmlyc3QgYWNjZXNzXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAhIHRoaXMubW9ycGhOb3JtYWxzWyBpIF0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5tb3JwaE5vcm1hbHNbIGkgXSA9IHt9O1xcblxcdFxcdFxcdFxcdFxcdHRoaXMubW9ycGhOb3JtYWxzWyBpIF0uZmFjZU5vcm1hbHMgPSBbXTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHMgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZHN0Tm9ybWFsc0ZhY2UgPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzO1xcblxcdFxcdFxcdFxcdFxcdHZhciBkc3ROb3JtYWxzVmVydGV4ID0gdGhpcy5tb3JwaE5vcm1hbHNbIGkgXS52ZXJ0ZXhOb3JtYWxzO1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBmYWNlTm9ybWFsLCB2ZXJ0ZXhOb3JtYWxzO1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIGYgPSAwLCBmbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBmIDwgZmw7IGYgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmFjZU5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmVydGV4Tm9ybWFscyA9IHsgYTogbmV3IFZlY3RvcjMoKSwgYjogbmV3IFZlY3RvcjMoKSwgYzogbmV3IFZlY3RvcjMoKSB9O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGRzdE5vcm1hbHNGYWNlLnB1c2goIGZhY2VOb3JtYWwgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkc3ROb3JtYWxzVmVydGV4LnB1c2goIHZlcnRleE5vcm1hbHMgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciBtb3JwaE5vcm1hbHMgPSB0aGlzLm1vcnBoTm9ybWFsc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdC8vIHNldCB2ZXJ0aWNlcyB0byBtb3JwaCB0YXJnZXRcXG5cXG5cXHRcXHRcXHRcXHR0bXBHZW8udmVydGljZXMgPSB0aGlzLm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzO1xcblxcblxcdFxcdFxcdFxcdC8vIGNvbXB1dGUgbW9ycGggbm9ybWFsc1xcblxcblxcdFxcdFxcdFxcdHRtcEdlby5jb21wdXRlRmFjZU5vcm1hbHMoKTtcXG5cXHRcXHRcXHRcXHR0bXBHZW8uY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBzdG9yZSBtb3JwaCBub3JtYWxzXFxuXFxuXFx0XFx0XFx0XFx0dmFyIGZhY2VOb3JtYWwsIHZlcnRleE5vcm1hbHM7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggZiA9IDAsIGZsID0gdGhpcy5mYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmYWNlID0gdGhpcy5mYWNlc1sgZiBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGZhY2VOb3JtYWwgPSBtb3JwaE5vcm1hbHMuZmFjZU5vcm1hbHNbIGYgXTtcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhOb3JtYWxzID0gbW9ycGhOb3JtYWxzLnZlcnRleE5vcm1hbHNbIGYgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmYWNlTm9ybWFsLmNvcHkoIGZhY2Uubm9ybWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4Tm9ybWFscy5hLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMCBdICk7XFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4Tm9ybWFscy5iLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMSBdICk7XFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4Tm9ybWFscy5jLmNvcHkoIGZhY2UudmVydGV4Tm9ybWFsc1sgMiBdICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyByZXN0b3JlIG9yaWdpbmFsIG5vcm1hbHNcXG5cXG5cXHRcXHRcXHRmb3IgKCBmID0gMCwgZmwgPSB0aGlzLmZhY2VzLmxlbmd0aDsgZiA8IGZsOyBmICsrICkge1xcblxcblxcdFxcdFxcdFxcdGZhY2UgPSB0aGlzLmZhY2VzWyBmIF07XFxuXFxuXFx0XFx0XFx0XFx0ZmFjZS5ub3JtYWwgPSBmYWNlLl9fb3JpZ2luYWxGYWNlTm9ybWFsO1xcblxcdFxcdFxcdFxcdGZhY2UudmVydGV4Tm9ybWFscyA9IGZhY2UuX19vcmlnaW5hbFZlcnRleE5vcm1hbHM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29tcHV0ZUxpbmVEaXN0YW5jZXM6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgZCA9IDA7XFxuXFx0XFx0XFx0dmFyIHZlcnRpY2VzID0gdGhpcy52ZXJ0aWNlcztcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gdmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRkICs9IHZlcnRpY2VzWyBpIF0uZGlzdGFuY2VUbyggdmVydGljZXNbIGkgLSAxIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5saW5lRGlzdGFuY2VzWyBpIF0gPSBkO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvbXB1dGVCb3VuZGluZ0JveDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5ib3VuZGluZ0JveCA9PT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmJvdW5kaW5nQm94ID0gbmV3IEJveDMoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tUG9pbnRzKCB0aGlzLnZlcnRpY2VzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb21wdXRlQm91bmRpbmdTcGhlcmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IG5ldyBTcGhlcmUoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5ib3VuZGluZ1NwaGVyZS5zZXRGcm9tUG9pbnRzKCB0aGlzLnZlcnRpY2VzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtZXJnZTogZnVuY3Rpb24gKCBnZW9tZXRyeSwgbWF0cml4LCBtYXRlcmlhbEluZGV4T2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdGlmICggISAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkdlb21ldHJ5LicsIGdlb21ldHJ5ICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgbm9ybWFsTWF0cml4LFxcblxcdFxcdFxcdFxcdHZlcnRleE9mZnNldCA9IHRoaXMudmVydGljZXMubGVuZ3RoLFxcblxcdFxcdFxcdFxcdHZlcnRpY2VzMSA9IHRoaXMudmVydGljZXMsXFxuXFx0XFx0XFx0XFx0dmVydGljZXMyID0gZ2VvbWV0cnkudmVydGljZXMsXFxuXFx0XFx0XFx0XFx0ZmFjZXMxID0gdGhpcy5mYWNlcyxcXG5cXHRcXHRcXHRcXHRmYWNlczIgPSBnZW9tZXRyeS5mYWNlcyxcXG5cXHRcXHRcXHRcXHR1dnMxID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF0sXFxuXFx0XFx0XFx0XFx0dXZzMiA9IGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIDAgXSxcXG5cXHRcXHRcXHRcXHRjb2xvcnMxID0gdGhpcy5jb2xvcnMsXFxuXFx0XFx0XFx0XFx0Y29sb3JzMiA9IGdlb21ldHJ5LmNvbG9ycztcXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsSW5kZXhPZmZzZXQgPT09IHVuZGVmaW5lZCApIG1hdGVyaWFsSW5kZXhPZmZzZXQgPSAwO1xcblxcblxcdFxcdFxcdGlmICggbWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bm9ybWFsTWF0cml4ID0gbmV3IE1hdHJpeDMoKS5nZXROb3JtYWxNYXRyaXgoIG1hdHJpeCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyB2ZXJ0aWNlc1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSB2ZXJ0aWNlczIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHZlcnRleCA9IHZlcnRpY2VzMlsgaSBdO1xcblxcblxcdFxcdFxcdFxcdHZhciB2ZXJ0ZXhDb3B5ID0gdmVydGV4LmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtYXRyaXggIT09IHVuZGVmaW5lZCApIHZlcnRleENvcHkuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlczEucHVzaCggdmVydGV4Q29weSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBjb2xvcnNcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY29sb3JzMi5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb2xvcnMxLnB1c2goIGNvbG9yczJbIGkgXS5jbG9uZSgpICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGZhY2VzXFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gZmFjZXMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBmYWNlID0gZmFjZXMyWyBpIF0sIGZhY2VDb3B5LCBub3JtYWwsIGNvbG9yLFxcblxcdFxcdFxcdFxcdFxcdGZhY2VWZXJ0ZXhOb3JtYWxzID0gZmFjZS52ZXJ0ZXhOb3JtYWxzLFxcblxcdFxcdFxcdFxcdFxcdGZhY2VWZXJ0ZXhDb2xvcnMgPSBmYWNlLnZlcnRleENvbG9ycztcXG5cXG5cXHRcXHRcXHRcXHRmYWNlQ29weSA9IG5ldyBGYWNlMyggZmFjZS5hICsgdmVydGV4T2Zmc2V0LCBmYWNlLmIgKyB2ZXJ0ZXhPZmZzZXQsIGZhY2UuYyArIHZlcnRleE9mZnNldCApO1xcblxcdFxcdFxcdFxcdGZhY2VDb3B5Lm5vcm1hbC5jb3B5KCBmYWNlLm5vcm1hbCApO1xcblxcblxcdFxcdFxcdFxcdGlmICggbm9ybWFsTWF0cml4ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZUNvcHkubm9ybWFsLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRub3JtYWwgPSBmYWNlVmVydGV4Tm9ybWFsc1sgaiBdLmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBub3JtYWxNYXRyaXggIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRub3JtYWwuYXBwbHlNYXRyaXgzKCBub3JtYWxNYXRyaXggKS5ub3JtYWxpemUoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZUNvcHkudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0ZmFjZUNvcHkuY29sb3IuY29weSggZmFjZS5jb2xvciApO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMCwgamwgPSBmYWNlVmVydGV4Q29sb3JzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbG9yID0gZmFjZVZlcnRleENvbG9yc1sgaiBdO1xcblxcdFxcdFxcdFxcdFxcdGZhY2VDb3B5LnZlcnRleENvbG9ycy5wdXNoKCBjb2xvci5jbG9uZSgpICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGZhY2VDb3B5Lm1hdGVyaWFsSW5kZXggPSBmYWNlLm1hdGVyaWFsSW5kZXggKyBtYXRlcmlhbEluZGV4T2Zmc2V0O1xcblxcblxcdFxcdFxcdFxcdGZhY2VzMS5wdXNoKCBmYWNlQ29weSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyB1dnNcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSB1dnMyLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB1diA9IHV2czJbIGkgXSwgdXZDb3B5ID0gW107XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB1diA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gdXYubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dXZDb3B5LnB1c2goIHV2WyBqIF0uY2xvbmUoKSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR1dnMxLnB1c2goIHV2Q29weSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG1lcmdlTWVzaDogZnVuY3Rpb24gKCBtZXNoICkge1xcblxcblxcdFxcdFxcdGlmICggISAoIG1lc2ggJiYgbWVzaC5pc01lc2ggKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuR2VvbWV0cnkubWVyZ2VNZXNoKCk6IG1lc2ggbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLk1lc2guJywgbWVzaCApO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0bWVzaC5tYXRyaXhBdXRvVXBkYXRlICYmIG1lc2gudXBkYXRlTWF0cml4KCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5tZXJnZSggbWVzaC5nZW9tZXRyeSwgbWVzaC5tYXRyaXggKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qXFxuXFx0XFx0ICogQ2hlY2tzIGZvciBkdXBsaWNhdGUgdmVydGljZXMgd2l0aCBoYXNobWFwLlxcblxcdFxcdCAqIER1cGxpY2F0ZWQgdmVydGljZXMgYXJlIHJlbW92ZWRcXG5cXHRcXHQgKiBhbmQgZmFjZXMnIHZlcnRpY2VzIGFyZSB1cGRhdGVkLlxcblxcdFxcdCAqL1xcblxcblxcdFxcdG1lcmdlVmVydGljZXM6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdmVydGljZXNNYXAgPSB7fTsgLy8gSGFzaG1hcCBmb3IgbG9va2luZyB1cCB2ZXJ0aWNlcyBieSBwb3NpdGlvbiBjb29yZGluYXRlcyAoYW5kIG1ha2luZyBzdXJlIHRoZXkgYXJlIHVuaXF1ZSlcXG5cXHRcXHRcXHR2YXIgdW5pcXVlID0gW10sIGNoYW5nZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHR2YXIgdiwga2V5O1xcblxcdFxcdFxcdHZhciBwcmVjaXNpb25Qb2ludHMgPSA0OyAvLyBudW1iZXIgb2YgZGVjaW1hbCBwb2ludHMsIGUuZy4gNCBmb3IgZXBzaWxvbiBvZiAwLjAwMDFcXG5cXHRcXHRcXHR2YXIgcHJlY2lzaW9uID0gTWF0aC5wb3coIDEwLCBwcmVjaXNpb25Qb2ludHMgKTtcXG5cXHRcXHRcXHR2YXIgaSwgaWwsIGZhY2U7XFxuXFx0XFx0XFx0dmFyIGluZGljZXMsIGosIGpsO1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMudmVydGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0diA9IHRoaXMudmVydGljZXNbIGkgXTtcXG5cXHRcXHRcXHRcXHRrZXkgPSBNYXRoLnJvdW5kKCB2LnggKiBwcmVjaXNpb24gKSArICdfJyArIE1hdGgucm91bmQoIHYueSAqIHByZWNpc2lvbiApICsgJ18nICsgTWF0aC5yb3VuZCggdi56ICogcHJlY2lzaW9uICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB2ZXJ0aWNlc01hcFsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0aWNlc01hcFsga2V5IF0gPSBpO1xcblxcdFxcdFxcdFxcdFxcdHVuaXF1ZS5wdXNoKCB0aGlzLnZlcnRpY2VzWyBpIF0gKTtcXG5cXHRcXHRcXHRcXHRcXHRjaGFuZ2VzWyBpIF0gPSB1bmlxdWUubGVuZ3RoIC0gMTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vY29uc29sZS5sb2coJ0R1cGxpY2F0ZSB2ZXJ0ZXggZm91bmQuICcsIGksICcgY291bGQgYmUgdXNpbmcgJywgdmVydGljZXNNYXBba2V5XSk7XFxuXFx0XFx0XFx0XFx0XFx0Y2hhbmdlc1sgaSBdID0gY2hhbmdlc1sgdmVydGljZXNNYXBbIGtleSBdIF07XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXG5cXHRcXHRcXHQvLyBpZiBmYWNlcyBhcmUgY29tcGxldGVseSBkZWdlbmVyYXRlIGFmdGVyIG1lcmdpbmcgdmVydGljZXMsIHdlXFxuXFx0XFx0XFx0Ly8gaGF2ZSB0byByZW1vdmUgdGhlbSBmcm9tIHRoZSBnZW9tZXRyeS5cXG5cXHRcXHRcXHR2YXIgZmFjZUluZGljZXNUb1JlbW92ZSA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IHRoaXMuZmFjZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZmFjZSA9IHRoaXMuZmFjZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRmYWNlLmEgPSBjaGFuZ2VzWyBmYWNlLmEgXTtcXG5cXHRcXHRcXHRcXHRmYWNlLmIgPSBjaGFuZ2VzWyBmYWNlLmIgXTtcXG5cXHRcXHRcXHRcXHRmYWNlLmMgPSBjaGFuZ2VzWyBmYWNlLmMgXTtcXG5cXG5cXHRcXHRcXHRcXHRpbmRpY2VzID0gWyBmYWNlLmEsIGZhY2UuYiwgZmFjZS5jIF07XFxuXFxuXFx0XFx0XFx0XFx0Ly8gaWYgYW55IGR1cGxpY2F0ZSB2ZXJ0aWNlcyBhcmUgZm91bmQgaW4gYSBGYWNlM1xcblxcdFxcdFxcdFxcdC8vIHdlIGhhdmUgdG8gcmVtb3ZlIHRoZSBmYWNlIGFzIG5vdGhpbmcgY2FuIGJlIHNhdmVkXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIG4gPSAwOyBuIDwgMzsgbiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGluZGljZXNbIG4gXSA9PT0gaW5kaWNlc1sgKCBuICsgMSApICUgMyBdICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZhY2VJbmRpY2VzVG9SZW1vdmUucHVzaCggaSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZvciAoIGkgPSBmYWNlSW5kaWNlc1RvUmVtb3ZlLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtLSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgaWR4ID0gZmFjZUluZGljZXNUb1JlbW92ZVsgaSBdO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuZmFjZXMuc3BsaWNlKCBpZHgsIDEgKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBqID0gMCwgamwgPSB0aGlzLmZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5mYWNlVmVydGV4VXZzWyBqIF0uc3BsaWNlKCBpZHgsIDEgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIFVzZSB1bmlxdWUgc2V0IG9mIHZlcnRpY2VzXFxuXFxuXFx0XFx0XFx0dmFyIGRpZmYgPSB0aGlzLnZlcnRpY2VzLmxlbmd0aCAtIHVuaXF1ZS5sZW5ndGg7XFxuXFx0XFx0XFx0dGhpcy52ZXJ0aWNlcyA9IHVuaXF1ZTtcXG5cXHRcXHRcXHRyZXR1cm4gZGlmZjtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xcblxcblxcdFxcdFxcdHRoaXMudmVydGljZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcG9pbnQgPSBwb2ludHNbIGkgXTtcXG5cXHRcXHRcXHRcXHR0aGlzLnZlcnRpY2VzLnB1c2goIG5ldyBWZWN0b3IzKCBwb2ludC54LCBwb2ludC55LCBwb2ludC56IHx8IDAgKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNvcnRGYWNlc0J5TWF0ZXJpYWxJbmRleDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBmYWNlcyA9IHRoaXMuZmFjZXM7XFxuXFx0XFx0XFx0dmFyIGxlbmd0aCA9IGZhY2VzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHQvLyB0YWcgZmFjZXNcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZmFjZXNbIGkgXS5faWQgPSBpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBzb3J0IGZhY2VzXFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gbWF0ZXJpYWxJbmRleFNvcnQoIGEsIGIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGEubWF0ZXJpYWxJbmRleCAtIGIubWF0ZXJpYWxJbmRleDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZmFjZXMuc29ydCggbWF0ZXJpYWxJbmRleFNvcnQgKTtcXG5cXG5cXHRcXHRcXHQvLyBzb3J0IHV2c1xcblxcblxcdFxcdFxcdHZhciB1dnMxID0gdGhpcy5mYWNlVmVydGV4VXZzWyAwIF07XFxuXFx0XFx0XFx0dmFyIHV2czIgPSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDEgXTtcXG5cXG5cXHRcXHRcXHR2YXIgbmV3VXZzMSwgbmV3VXZzMjtcXG5cXG5cXHRcXHRcXHRpZiAoIHV2czEgJiYgdXZzMS5sZW5ndGggPT09IGxlbmd0aCApIG5ld1V2czEgPSBbXTtcXG5cXHRcXHRcXHRpZiAoIHV2czIgJiYgdXZzMi5sZW5ndGggPT09IGxlbmd0aCApIG5ld1V2czIgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGlkID0gZmFjZXNbIGkgXS5faWQ7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBuZXdVdnMxICkgbmV3VXZzMS5wdXNoKCB1dnMxWyBpZCBdICk7XFxuXFx0XFx0XFx0XFx0aWYgKCBuZXdVdnMyICkgbmV3VXZzMi5wdXNoKCB1dnMyWyBpZCBdICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggbmV3VXZzMSApIHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdID0gbmV3VXZzMTtcXG5cXHRcXHRcXHRpZiAoIG5ld1V2czIgKSB0aGlzLmZhY2VWZXJ0ZXhVdnNbIDEgXSA9IG5ld1V2czI7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgZGF0YSA9IHtcXG5cXHRcXHRcXHRcXHRtZXRhZGF0YToge1xcblxcdFxcdFxcdFxcdFxcdHZlcnNpb246IDQuNSxcXG5cXHRcXHRcXHRcXHRcXHR0eXBlOiAnR2VvbWV0cnknLFxcblxcdFxcdFxcdFxcdFxcdGdlbmVyYXRvcjogJ0dlb21ldHJ5LnRvSlNPTidcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHQvLyBzdGFuZGFyZCBHZW9tZXRyeSBzZXJpYWxpemF0aW9uXFxuXFxuXFx0XFx0XFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xcblxcdFxcdFxcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcXG5cXHRcXHRcXHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwYXJhbWV0ZXJzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgZGF0YVsga2V5IF0gPSBwYXJhbWV0ZXJzWyBrZXkgXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMudmVydGljZXMubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB2ZXJ0ZXggPSB0aGlzLnZlcnRpY2VzWyBpIF07XFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgZmFjZXMgPSBbXTtcXG5cXHRcXHRcXHR2YXIgbm9ybWFscyA9IFtdO1xcblxcdFxcdFxcdHZhciBub3JtYWxzSGFzaCA9IHt9O1xcblxcdFxcdFxcdHZhciBjb2xvcnMgPSBbXTtcXG5cXHRcXHRcXHR2YXIgY29sb3JzSGFzaCA9IHt9O1xcblxcdFxcdFxcdHZhciB1dnMgPSBbXTtcXG5cXHRcXHRcXHR2YXIgdXZzSGFzaCA9IHt9O1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMuZmFjZXMubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBmYWNlID0gdGhpcy5mYWNlc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdHZhciBoYXNNYXRlcmlhbCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0dmFyIGhhc0ZhY2VVdiA9IGZhbHNlOyAvLyBkZXByZWNhdGVkXFxuXFx0XFx0XFx0XFx0dmFyIGhhc0ZhY2VWZXJ0ZXhVdiA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF0gIT09IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHRcXHR2YXIgaGFzRmFjZU5vcm1hbCA9IGZhY2Uubm9ybWFsLmxlbmd0aCgpID4gMDtcXG5cXHRcXHRcXHRcXHR2YXIgaGFzRmFjZVZlcnRleE5vcm1hbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGggPiAwO1xcblxcdFxcdFxcdFxcdHZhciBoYXNGYWNlQ29sb3IgPSBmYWNlLmNvbG9yLnIgIT09IDEgfHwgZmFjZS5jb2xvci5nICE9PSAxIHx8IGZhY2UuY29sb3IuYiAhPT0gMTtcXG5cXHRcXHRcXHRcXHR2YXIgaGFzRmFjZVZlcnRleENvbG9yID0gZmFjZS52ZXJ0ZXhDb2xvcnMubGVuZ3RoID4gMDtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZmFjZVR5cGUgPSAwO1xcblxcblxcdFxcdFxcdFxcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgMCwgMCApOyAvLyBpc1F1YWRcXG5cXHRcXHRcXHRcXHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDEsIGhhc01hdGVyaWFsICk7XFxuXFx0XFx0XFx0XFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCAyLCBoYXNGYWNlVXYgKTtcXG5cXHRcXHRcXHRcXHRmYWNlVHlwZSA9IHNldEJpdCggZmFjZVR5cGUsIDMsIGhhc0ZhY2VWZXJ0ZXhVdiApO1xcblxcdFxcdFxcdFxcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNCwgaGFzRmFjZU5vcm1hbCApO1xcblxcdFxcdFxcdFxcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNSwgaGFzRmFjZVZlcnRleE5vcm1hbCApO1xcblxcdFxcdFxcdFxcdGZhY2VUeXBlID0gc2V0Qml0KCBmYWNlVHlwZSwgNiwgaGFzRmFjZUNvbG9yICk7XFxuXFx0XFx0XFx0XFx0ZmFjZVR5cGUgPSBzZXRCaXQoIGZhY2VUeXBlLCA3LCBoYXNGYWNlVmVydGV4Q29sb3IgKTtcXG5cXG5cXHRcXHRcXHRcXHRmYWNlcy5wdXNoKCBmYWNlVHlwZSApO1xcblxcdFxcdFxcdFxcdGZhY2VzLnB1c2goIGZhY2UuYSwgZmFjZS5iLCBmYWNlLmMgKTtcXG5cXHRcXHRcXHRcXHRmYWNlcy5wdXNoKCBmYWNlLm1hdGVyaWFsSW5kZXggKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZmFjZVZlcnRleFV2cyA9IHRoaXMuZmFjZVZlcnRleFV2c1sgMCBdWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZXMucHVzaChcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAwIF0gKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAxIF0gKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZXRVdkluZGV4KCBmYWNlVmVydGV4VXZzWyAyIF0gKVxcblxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggaGFzRmFjZU5vcm1hbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmYWNlcy5wdXNoKCBnZXROb3JtYWxJbmRleCggZmFjZS5ub3JtYWwgKSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHZlcnRleE5vcm1hbHMgPSBmYWNlLnZlcnRleE5vcm1hbHM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZXMucHVzaChcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZXROb3JtYWxJbmRleCggdmVydGV4Tm9ybWFsc1sgMCBdICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2V0Tm9ybWFsSW5kZXgoIHZlcnRleE5vcm1hbHNbIDEgXSApLFxcblxcdFxcdFxcdFxcdFxcdFxcdGdldE5vcm1hbEluZGV4KCB2ZXJ0ZXhOb3JtYWxzWyAyIF0gKVxcblxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggaGFzRmFjZUNvbG9yICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGZhY2VzLnB1c2goIGdldENvbG9ySW5kZXgoIGZhY2UuY29sb3IgKSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGhhc0ZhY2VWZXJ0ZXhDb2xvciApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdmVydGV4Q29sb3JzID0gZmFjZS52ZXJ0ZXhDb2xvcnM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZXMucHVzaChcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZXRDb2xvckluZGV4KCB2ZXJ0ZXhDb2xvcnNbIDAgXSApLFxcblxcdFxcdFxcdFxcdFxcdFxcdGdldENvbG9ySW5kZXgoIHZlcnRleENvbG9yc1sgMSBdICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2V0Q29sb3JJbmRleCggdmVydGV4Q29sb3JzWyAyIF0gKVxcblxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBzZXRCaXQoIHZhbHVlLCBwb3NpdGlvbiwgZW5hYmxlZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gZW5hYmxlZCA/IHZhbHVlIHwgKCAxIDw8IHBvc2l0aW9uICkgOiB2YWx1ZSAmICggfiAoIDEgPDwgcG9zaXRpb24gKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBnZXROb3JtYWxJbmRleCggbm9ybWFsICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBoYXNoID0gbm9ybWFsLngudG9TdHJpbmcoKSArIG5vcm1hbC55LnRvU3RyaW5nKCkgKyBub3JtYWwuei50b1N0cmluZygpO1xcblxcblxcdFxcdFxcdFxcdGlmICggbm9ybWFsc0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBub3JtYWxzSGFzaFsgaGFzaCBdO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRub3JtYWxzSGFzaFsgaGFzaCBdID0gbm9ybWFscy5sZW5ndGggLyAzO1xcblxcdFxcdFxcdFxcdG5vcm1hbHMucHVzaCggbm9ybWFsLngsIG5vcm1hbC55LCBub3JtYWwueiApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBub3JtYWxzSGFzaFsgaGFzaCBdO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBnZXRDb2xvckluZGV4KCBjb2xvciApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgaGFzaCA9IGNvbG9yLnIudG9TdHJpbmcoKSArIGNvbG9yLmcudG9TdHJpbmcoKSArIGNvbG9yLmIudG9TdHJpbmcoKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGNvbG9yc0hhc2hbIGhhc2ggXSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBjb2xvcnNIYXNoWyBoYXNoIF07XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGNvbG9yc0hhc2hbIGhhc2ggXSA9IGNvbG9ycy5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0Y29sb3JzLnB1c2goIGNvbG9yLmdldEhleCgpICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNvbG9yc0hhc2hbIGhhc2ggXTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gZ2V0VXZJbmRleCggdXYgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGhhc2ggPSB1di54LnRvU3RyaW5nKCkgKyB1di55LnRvU3RyaW5nKCk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB1dnNIYXNoWyBoYXNoIF0gIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdXZzSGFzaFsgaGFzaCBdO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR1dnNIYXNoWyBoYXNoIF0gPSB1dnMubGVuZ3RoIC8gMjtcXG5cXHRcXHRcXHRcXHR1dnMucHVzaCggdXYueCwgdXYueSApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB1dnNIYXNoWyBoYXNoIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGRhdGEuZGF0YSA9IHt9O1xcblxcblxcdFxcdFxcdGRhdGEuZGF0YS52ZXJ0aWNlcyA9IHZlcnRpY2VzO1xcblxcdFxcdFxcdGRhdGEuZGF0YS5ub3JtYWxzID0gbm9ybWFscztcXG5cXHRcXHRcXHRpZiAoIGNvbG9ycy5sZW5ndGggPiAwICkgZGF0YS5kYXRhLmNvbG9ycyA9IGNvbG9ycztcXG5cXHRcXHRcXHRpZiAoIHV2cy5sZW5ndGggPiAwICkgZGF0YS5kYXRhLnV2cyA9IFsgdXZzIF07IC8vIHRlbXBvcmFsIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcXG5cXHRcXHRcXHRkYXRhLmRhdGEuZmFjZXMgPSBmYWNlcztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZGF0YTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0LypcXG5cXHRcXHRcXHQgLy8gSGFuZGxlIHByaW1pdGl2ZXNcXG5cXG5cXHRcXHRcXHQgdmFyIHBhcmFtZXRlcnMgPSB0aGlzLnBhcmFtZXRlcnM7XFxuXFxuXFx0XFx0XFx0IGlmICggcGFyYW1ldGVycyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdCB2YXIgdmFsdWVzID0gW107XFxuXFxuXFx0XFx0XFx0IGZvciAoIHZhciBrZXkgaW4gcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHRcXHQgdmFsdWVzLnB1c2goIHBhcmFtZXRlcnNbIGtleSBdICk7XFxuXFxuXFx0XFx0XFx0IH1cXG5cXG5cXHRcXHRcXHQgdmFyIGdlb21ldHJ5ID0gT2JqZWN0LmNyZWF0ZSggdGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgKTtcXG5cXHRcXHRcXHQgdGhpcy5jb25zdHJ1Y3Rvci5hcHBseSggZ2VvbWV0cnksIHZhbHVlcyApO1xcblxcdFxcdFxcdCByZXR1cm4gZ2VvbWV0cnk7XFxuXFxuXFx0XFx0XFx0IH1cXG5cXG5cXHRcXHRcXHQgcmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcblxcdFxcdFxcdCAqL1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgR2VvbWV0cnkoKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgaSwgaWwsIGosIGpsLCBrLCBrbDtcXG5cXG5cXHRcXHRcXHQvLyByZXNldFxcblxcblxcdFxcdFxcdHRoaXMudmVydGljZXMgPSBbXTtcXG5cXHRcXHRcXHR0aGlzLmNvbG9ycyA9IFtdO1xcblxcdFxcdFxcdHRoaXMuZmFjZXMgPSBbXTtcXG5cXHRcXHRcXHR0aGlzLmZhY2VWZXJ0ZXhVdnMgPSBbW11dO1xcblxcdFxcdFxcdHRoaXMubW9ycGhUYXJnZXRzID0gW107XFxuXFx0XFx0XFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBbXTtcXG5cXHRcXHRcXHR0aGlzLnNraW5XZWlnaHRzID0gW107XFxuXFx0XFx0XFx0dGhpcy5za2luSW5kaWNlcyA9IFtdO1xcblxcdFxcdFxcdHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xcblxcdFxcdFxcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xcblxcdFxcdFxcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xcblxcblxcdFxcdFxcdC8vIG5hbWVcXG5cXG5cXHRcXHRcXHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcXG5cXG5cXHRcXHRcXHQvLyB2ZXJ0aWNlc1xcblxcblxcdFxcdFxcdHZhciB2ZXJ0aWNlcyA9IHNvdXJjZS52ZXJ0aWNlcztcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRpY2VzWyBpIF0uY2xvbmUoKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBjb2xvcnNcXG5cXG5cXHRcXHRcXHR2YXIgY29sb3JzID0gc291cmNlLmNvbG9ycztcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSBjb2xvcnMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5jb2xvcnMucHVzaCggY29sb3JzWyBpIF0uY2xvbmUoKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBmYWNlc1xcblxcblxcdFxcdFxcdHZhciBmYWNlcyA9IHNvdXJjZS5mYWNlcztcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSBmYWNlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmZhY2VzLnB1c2goIGZhY2VzWyBpIF0uY2xvbmUoKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBmYWNlIHZlcnRleCB1dnNcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSBzb3VyY2UuZmFjZVZlcnRleFV2cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZmFjZVZlcnRleFV2cyA9IHNvdXJjZS5mYWNlVmVydGV4VXZzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0aGlzLmZhY2VWZXJ0ZXhVdnNbIGkgXSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuZmFjZVZlcnRleFV2c1sgaSBdID0gW107XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGZvciAoIGogPSAwLCBqbCA9IGZhY2VWZXJ0ZXhVdnMubGVuZ3RoOyBqIDwgamw7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHV2cyA9IGZhY2VWZXJ0ZXhVdnNbIGogXSwgdXZzQ29weSA9IFtdO1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIGsgPSAwLCBrbCA9IHV2cy5sZW5ndGg7IGsgPCBrbDsgayArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgdXYgPSB1dnNbIGsgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR1dnNDb3B5LnB1c2goIHV2LmNsb25lKCkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5mYWNlVmVydGV4VXZzWyBpIF0ucHVzaCggdXZzQ29weSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gbW9ycGggdGFyZ2V0c1xcblxcblxcdFxcdFxcdHZhciBtb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbW9ycGhUYXJnZXQgPSB7fTtcXG5cXHRcXHRcXHRcXHRtb3JwaFRhcmdldC5uYW1lID0gbW9ycGhUYXJnZXRzWyBpIF0ubmFtZTtcXG5cXG5cXHRcXHRcXHRcXHQvLyB2ZXJ0aWNlc1xcblxcblxcdFxcdFxcdFxcdGlmICggbW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXMgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtb3JwaFRhcmdldC52ZXJ0aWNlcyA9IFtdO1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIGogPSAwLCBqbCA9IG1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdG1vcnBoVGFyZ2V0LnZlcnRpY2VzLnB1c2goIG1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzWyBqIF0uY2xvbmUoKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbm9ybWFsc1xcblxcblxcdFxcdFxcdFxcdGlmICggbW9ycGhUYXJnZXRzWyBpIF0ubm9ybWFscyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG1vcnBoVGFyZ2V0Lm5vcm1hbHMgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCBqID0gMCwgamwgPSBtb3JwaFRhcmdldHNbIGkgXS5ub3JtYWxzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdG1vcnBoVGFyZ2V0Lm5vcm1hbHMucHVzaCggbW9ycGhUYXJnZXRzWyBpIF0ubm9ybWFsc1sgaiBdLmNsb25lKCkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRoaXMubW9ycGhUYXJnZXRzLnB1c2goIG1vcnBoVGFyZ2V0ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIG1vcnBoIG5vcm1hbHNcXG5cXG5cXHRcXHRcXHR2YXIgbW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSBtb3JwaE5vcm1hbHMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG1vcnBoTm9ybWFsID0ge307XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdmVydGV4IG5vcm1hbHNcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG1vcnBoTm9ybWFsc1sgaSBdLnZlcnRleE5vcm1hbHMgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtb3JwaE5vcm1hbC52ZXJ0ZXhOb3JtYWxzID0gW107XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggaiA9IDAsIGpsID0gbW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgc3JjVmVydGV4Tm9ybWFsID0gbW9ycGhOb3JtYWxzWyBpIF0udmVydGV4Tm9ybWFsc1sgaiBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBkZXN0VmVydGV4Tm9ybWFsID0ge307XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGVzdFZlcnRleE5vcm1hbC5hID0gc3JjVmVydGV4Tm9ybWFsLmEuY2xvbmUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRkZXN0VmVydGV4Tm9ybWFsLmIgPSBzcmNWZXJ0ZXhOb3JtYWwuYi5jbG9uZSgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGRlc3RWZXJ0ZXhOb3JtYWwuYyA9IHNyY1ZlcnRleE5vcm1hbC5jLmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bW9ycGhOb3JtYWwudmVydGV4Tm9ybWFscy5wdXNoKCBkZXN0VmVydGV4Tm9ybWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBmYWNlIG5vcm1hbHNcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG1vcnBoTm9ybWFsc1sgaSBdLmZhY2VOb3JtYWxzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bW9ycGhOb3JtYWwuZmFjZU5vcm1hbHMgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCBqID0gMCwgamwgPSBtb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRtb3JwaE5vcm1hbC5mYWNlTm9ybWFscy5wdXNoKCBtb3JwaE5vcm1hbHNbIGkgXS5mYWNlTm9ybWFsc1sgaiBdLmNsb25lKCkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRoaXMubW9ycGhOb3JtYWxzLnB1c2goIG1vcnBoTm9ybWFsICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHNraW4gd2VpZ2h0c1xcblxcblxcdFxcdFxcdHZhciBza2luV2VpZ2h0cyA9IHNvdXJjZS5za2luV2VpZ2h0cztcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSBza2luV2VpZ2h0cy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnNraW5XZWlnaHRzLnB1c2goIHNraW5XZWlnaHRzWyBpIF0uY2xvbmUoKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBza2luIGluZGljZXNcXG5cXG5cXHRcXHRcXHR2YXIgc2tpbkluZGljZXMgPSBzb3VyY2Uuc2tpbkluZGljZXM7XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gc2tpbkluZGljZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5za2luSW5kaWNlcy5wdXNoKCBza2luSW5kaWNlc1sgaSBdLmNsb25lKCkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gbGluZSBkaXN0YW5jZXNcXG5cXG5cXHRcXHRcXHR2YXIgbGluZURpc3RhbmNlcyA9IHNvdXJjZS5saW5lRGlzdGFuY2VzO1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IGxpbmVEaXN0YW5jZXMubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5saW5lRGlzdGFuY2VzLnB1c2goIGxpbmVEaXN0YW5jZXNbIGkgXSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBib3VuZGluZyBib3hcXG5cXG5cXHRcXHRcXHR2YXIgYm91bmRpbmdCb3ggPSBzb3VyY2UuYm91bmRpbmdCb3g7XFxuXFxuXFx0XFx0XFx0aWYgKCBib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmJvdW5kaW5nQm94ID0gYm91bmRpbmdCb3guY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gYm91bmRpbmcgc3BoZXJlXFxuXFxuXFx0XFx0XFx0dmFyIGJvdW5kaW5nU3BoZXJlID0gc291cmNlLmJvdW5kaW5nU3BoZXJlO1xcblxcblxcdFxcdFxcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5ib3VuZGluZ1NwaGVyZSA9IGJvdW5kaW5nU3BoZXJlLmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHVwZGF0ZSBmbGFnc1xcblxcblxcdFxcdFxcdHRoaXMuZWxlbWVudHNOZWVkVXBkYXRlID0gc291cmNlLmVsZW1lbnRzTmVlZFVwZGF0ZTtcXG5cXHRcXHRcXHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IHNvdXJjZS52ZXJ0aWNlc05lZWRVcGRhdGU7XFxuXFx0XFx0XFx0dGhpcy51dnNOZWVkVXBkYXRlID0gc291cmNlLnV2c05lZWRVcGRhdGU7XFxuXFx0XFx0XFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IHNvdXJjZS5ub3JtYWxzTmVlZFVwZGF0ZTtcXG5cXHRcXHRcXHR0aGlzLmNvbG9yc05lZWRVcGRhdGUgPSBzb3VyY2UuY29sb3JzTmVlZFVwZGF0ZTtcXG5cXHRcXHRcXHR0aGlzLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlID0gc291cmNlLmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlO1xcblxcdFxcdFxcdHRoaXMuZ3JvdXBzTmVlZFVwZGF0ZSA9IHNvdXJjZS5ncm91cHNOZWVkVXBkYXRlO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGlzcG9zZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMuZGlzcGF0Y2hFdmVudCggeyB0eXBlOiAnZGlzcG9zZScgfSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcXG5cXG5cXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIGFycmF5ICkgKSB7XFxuXFxuXFx0XFx0XFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogYXJyYXkgc2hvdWxkIGJlIGEgVHlwZWQgQXJyYXkuJyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcXG5cXHRcXHR0aGlzLm5hbWUgPSAnJztcXG5cXG5cXHRcXHR0aGlzLmFycmF5ID0gYXJyYXk7XFxuXFx0XFx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xcblxcdFxcdHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gaXRlbVNpemUgOiAwO1xcblxcdFxcdHRoaXMubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQgPT09IHRydWU7XFxuXFxuXFx0XFx0dGhpcy5keW5hbWljID0gZmFsc2U7XFxuXFx0XFx0dGhpcy51cGRhdGVSYW5nZSA9IHsgb2Zmc2V0OiAwLCBjb3VudDogLSAxIH07XFxuXFxuXFx0XFx0dGhpcy5vblVwbG9hZENhbGxiYWNrID0gZnVuY3Rpb24gKCkge307XFxuXFxuXFx0XFx0dGhpcy52ZXJzaW9uID0gMDtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLCAnbmVlZHNVcGRhdGUnLCB7XFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdGlmICggdmFsdWUgPT09IHRydWUgKSB0aGlzLnZlcnNpb24gKys7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuYXNzaWduKCBCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0aXNCdWZmZXJBdHRyaWJ1dGU6IHRydWUsXFxuXFxuXFx0XFx0c2V0QXJyYXk6IGZ1bmN0aW9uICggYXJyYXkgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCBhcnJheSApICkge1xcblxcblxcdFxcdFxcdFxcdHRocm93IG5ldyBUeXBlRXJyb3IoICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGU6IGFycmF5IHNob3VsZCBiZSBhIFR5cGVkIEFycmF5LicgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5jb3VudCA9IGFycmF5ICE9PSB1bmRlZmluZWQgPyBhcnJheS5sZW5ndGggLyB0aGlzLml0ZW1TaXplIDogMDtcXG5cXHRcXHRcXHR0aGlzLmFycmF5ID0gYXJyYXk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXREeW5hbWljOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMuZHluYW1pYyA9IHZhbHVlO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5hcnJheSA9IG5ldyBzb3VyY2UuYXJyYXkuY29uc3RydWN0b3IoIHNvdXJjZS5hcnJheSApO1xcblxcdFxcdFxcdHRoaXMuaXRlbVNpemUgPSBzb3VyY2UuaXRlbVNpemU7XFxuXFx0XFx0XFx0dGhpcy5jb3VudCA9IHNvdXJjZS5jb3VudDtcXG5cXHRcXHRcXHR0aGlzLm5vcm1hbGl6ZWQgPSBzb3VyY2Uubm9ybWFsaXplZDtcXG5cXG5cXHRcXHRcXHR0aGlzLmR5bmFtaWMgPSBzb3VyY2UuZHluYW1pYztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHlBdDogZnVuY3Rpb24gKCBpbmRleDEsIGF0dHJpYnV0ZSwgaW5kZXgyICkge1xcblxcblxcdFxcdFxcdGluZGV4MSAqPSB0aGlzLml0ZW1TaXplO1xcblxcdFxcdFxcdGluZGV4MiAqPSBhdHRyaWJ1dGUuaXRlbVNpemU7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5pdGVtU2l6ZTsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5hcnJheVsgaW5kZXgxICsgaSBdID0gYXR0cmlidXRlLmFycmF5WyBpbmRleDIgKyBpIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weUFycmF5OiBmdW5jdGlvbiAoIGFycmF5ICkge1xcblxcblxcdFxcdFxcdHRoaXMuYXJyYXkuc2V0KCBhcnJheSApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weUNvbG9yc0FycmF5OiBmdW5jdGlvbiAoIGNvbG9ycyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYXJyYXkgPSB0aGlzLmFycmF5LCBvZmZzZXQgPSAwO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGNvbG9ycy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBjb2xvciA9IGNvbG9yc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggY29sb3IgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJBdHRyaWJ1dGUuY29weUNvbG9yc0FycmF5KCk6IGNvbG9yIGlzIHVuZGVmaW5lZCcsIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHRjb2xvciA9IG5ldyBDb2xvcigpO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBjb2xvci5yO1xcblxcdFxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKysgXSA9IGNvbG9yLmc7XFxuXFx0XFx0XFx0XFx0YXJyYXlbIG9mZnNldCArKyBdID0gY29sb3IuYjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5SW5kaWNlc0FycmF5OiBmdW5jdGlvbiAoIGluZGljZXMgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGluZGV4ID0gaW5kaWNlc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKysgXSA9IGluZGV4LmE7XFxuXFx0XFx0XFx0XFx0YXJyYXlbIG9mZnNldCArKyBdID0gaW5kZXguYjtcXG5cXHRcXHRcXHRcXHRhcnJheVsgb2Zmc2V0ICsrIF0gPSBpbmRleC5jO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHlWZWN0b3Iyc0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yMnNBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xcblxcdFxcdFxcdFxcdFxcdHZlY3RvciA9IG5ldyBWZWN0b3IyKCk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xcblxcdFxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci55O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHlWZWN0b3Izc0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xcblxcdFxcdFxcdFxcdFxcdHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xcblxcdFxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci55O1xcblxcdFxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci56O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHlWZWN0b3I0c0FycmF5OiBmdW5jdGlvbiAoIHZlY3RvcnMgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGFycmF5ID0gdGhpcy5hcnJheSwgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZWN0b3JzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHZlY3RvciA9IHZlY3RvcnNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHZlY3RvciA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZS5jb3B5VmVjdG9yNHNBcnJheSgpOiB2ZWN0b3IgaXMgdW5kZWZpbmVkJywgaSApO1xcblxcdFxcdFxcdFxcdFxcdHZlY3RvciA9IG5ldyBWZWN0b3I0KCk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci54O1xcblxcdFxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci55O1xcblxcdFxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci56O1xcblxcdFxcdFxcdFxcdGFycmF5WyBvZmZzZXQgKysgXSA9IHZlY3Rvci53O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdGlmICggb2Zmc2V0ID09PSB1bmRlZmluZWQgKSBvZmZzZXQgPSAwO1xcblxcblxcdFxcdFxcdHRoaXMuYXJyYXkuc2V0KCB2YWx1ZSwgb2Zmc2V0ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRYOiBmdW5jdGlvbiAoIGluZGV4ICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgXTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFg6IGZ1bmN0aW9uICggaW5kZXgsIHggKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplIF0gPSB4O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0WTogZnVuY3Rpb24gKCBpbmRleCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMSBdO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0WTogZnVuY3Rpb24gKCBpbmRleCwgeSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAxIF0gPSB5O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0WjogZnVuY3Rpb24gKCBpbmRleCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMiBdO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0WjogZnVuY3Rpb24gKCBpbmRleCwgeiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAyIF0gPSB6O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0VzogZnVuY3Rpb24gKCBpbmRleCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5hcnJheVsgaW5kZXggKiB0aGlzLml0ZW1TaXplICsgMyBdO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0VzogZnVuY3Rpb24gKCBpbmRleCwgdyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmFycmF5WyBpbmRleCAqIHRoaXMuaXRlbVNpemUgKyAzIF0gPSB3O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0WFk6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHkgKSB7XFxuXFxuXFx0XFx0XFx0aW5kZXggKj0gdGhpcy5pdGVtU2l6ZTtcXG5cXG5cXHRcXHRcXHR0aGlzLmFycmF5WyBpbmRleCArIDAgXSA9IHg7XFxuXFx0XFx0XFx0dGhpcy5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0WFlaOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6ICkge1xcblxcblxcdFxcdFxcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XFxuXFxuXFx0XFx0XFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xcblxcdFxcdFxcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcXG5cXHRcXHRcXHR0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRYWVpXOiBmdW5jdGlvbiAoIGluZGV4LCB4LCB5LCB6LCB3ICkge1xcblxcblxcdFxcdFxcdGluZGV4ICo9IHRoaXMuaXRlbVNpemU7XFxuXFxuXFx0XFx0XFx0dGhpcy5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xcblxcdFxcdFxcdHRoaXMuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcXG5cXHRcXHRcXHR0aGlzLmFycmF5WyBpbmRleCArIDIgXSA9IHo7XFxuXFx0XFx0XFx0dGhpcy5hcnJheVsgaW5kZXggKyAzIF0gPSB3O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0b25VcGxvYWQ6IGZ1bmN0aW9uICggY2FsbGJhY2sgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5vblVwbG9hZENhbGxiYWNrID0gY2FsbGJhY2s7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5hcnJheSwgdGhpcy5pdGVtU2l6ZSApLmNvcHkoIHRoaXMgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8vXFxuXFxuXFx0ZnVuY3Rpb24gSW50OEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xcblxcblxcdFxcdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgSW50OEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xcblxcblxcdH1cXG5cXG5cXHRJbnQ4QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcXG5cXHRJbnQ4QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEludDhCdWZmZXJBdHRyaWJ1dGU7XFxuXFxuXFxuXFx0ZnVuY3Rpb24gVWludDhCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcXG5cXG5cXHRcXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IFVpbnQ4QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XFxuXFxuXFx0fVxcblxcblxcdFVpbnQ4QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcXG5cXHRVaW50OEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVaW50OEJ1ZmZlckF0dHJpYnV0ZTtcXG5cXG5cXG5cXHRmdW5jdGlvbiBVaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcXG5cXG5cXHRcXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xcblxcblxcdH1cXG5cXG5cXHRVaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xcblxcdFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVaW50OENsYW1wZWRCdWZmZXJBdHRyaWJ1dGU7XFxuXFxuXFxuXFx0ZnVuY3Rpb24gSW50MTZCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcXG5cXG5cXHRcXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IEludDE2QXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XFxuXFxuXFx0fVxcblxcblxcdEludDE2QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcXG5cXHRJbnQxNkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnQxNkJ1ZmZlckF0dHJpYnV0ZTtcXG5cXG5cXG5cXHRmdW5jdGlvbiBVaW50MTZCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcXG5cXG5cXHRcXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IFVpbnQxNkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xcblxcblxcdH1cXG5cXG5cXHRVaW50MTZCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xcblxcdFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVaW50MTZCdWZmZXJBdHRyaWJ1dGU7XFxuXFxuXFxuXFx0ZnVuY3Rpb24gSW50MzJCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcXG5cXG5cXHRcXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IEludDMyQXJyYXkoIGFycmF5ICksIGl0ZW1TaXplLCBub3JtYWxpemVkICk7XFxuXFxuXFx0fVxcblxcblxcdEludDMyQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcXG5cXHRJbnQzMkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbnQzMkJ1ZmZlckF0dHJpYnV0ZTtcXG5cXG5cXG5cXHRmdW5jdGlvbiBVaW50MzJCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApIHtcXG5cXG5cXHRcXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgbmV3IFVpbnQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xcblxcblxcdH1cXG5cXG5cXHRVaW50MzJCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApO1xcblxcdFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVaW50MzJCdWZmZXJBdHRyaWJ1dGU7XFxuXFxuXFxuXFx0ZnVuY3Rpb24gRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xcblxcblxcdFxcdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgRmxvYXQzMkFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xcblxcblxcdH1cXG5cXG5cXHRGbG9hdDMyQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcXG5cXHRGbG9hdDMyQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGU7XFxuXFxuXFxuXFx0ZnVuY3Rpb24gRmxvYXQ2NEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplLCBub3JtYWxpemVkICkge1xcblxcblxcdFxcdEJ1ZmZlckF0dHJpYnV0ZS5jYWxsKCB0aGlzLCBuZXcgRmxvYXQ2NEFycmF5KCBhcnJheSApLCBpdGVtU2l6ZSwgbm9ybWFsaXplZCApO1xcblxcblxcdH1cXG5cXG5cXHRGbG9hdDY0QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUgKTtcXG5cXHRGbG9hdDY0QnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEZsb2F0NjRCdWZmZXJBdHRyaWJ1dGU7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBEaXJlY3RHZW9tZXRyeSgpIHtcXG5cXG5cXHRcXHR0aGlzLmluZGljZXMgPSBbXTtcXG5cXHRcXHR0aGlzLnZlcnRpY2VzID0gW107XFxuXFx0XFx0dGhpcy5ub3JtYWxzID0gW107XFxuXFx0XFx0dGhpcy5jb2xvcnMgPSBbXTtcXG5cXHRcXHR0aGlzLnV2cyA9IFtdO1xcblxcdFxcdHRoaXMudXZzMiA9IFtdO1xcblxcblxcdFxcdHRoaXMuZ3JvdXBzID0gW107XFxuXFxuXFx0XFx0dGhpcy5tb3JwaFRhcmdldHMgPSB7fTtcXG5cXG5cXHRcXHR0aGlzLnNraW5XZWlnaHRzID0gW107XFxuXFx0XFx0dGhpcy5za2luSW5kaWNlcyA9IFtdO1xcblxcblxcdFxcdC8vIHRoaXMubGluZURpc3RhbmNlcyA9IFtdO1xcblxcblxcdFxcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xcblxcdFxcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xcblxcblxcdFxcdC8vIHVwZGF0ZSBmbGFnc1xcblxcblxcdFxcdHRoaXMudmVydGljZXNOZWVkVXBkYXRlID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcblxcdFxcdHRoaXMuY29sb3JzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcblxcdFxcdHRoaXMudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcblxcdFxcdHRoaXMuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBEaXJlY3RHZW9tZXRyeS5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRjb21wdXRlR3JvdXBzOiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdHZhciBncm91cDtcXG5cXHRcXHRcXHR2YXIgZ3JvdXBzID0gW107XFxuXFx0XFx0XFx0dmFyIG1hdGVyaWFsSW5kZXggPSB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0XFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBtYXRlcmlhbHNcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGZhY2UubWF0ZXJpYWxJbmRleCAhPT0gbWF0ZXJpYWxJbmRleCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbEluZGV4ID0gZmFjZS5tYXRlcmlhbEluZGV4O1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZ3JvdXAgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRncm91cC5jb3VudCA9ICggaSAqIDMgKSAtIGdyb3VwLnN0YXJ0O1xcblxcdFxcdFxcdFxcdFxcdFxcdGdyb3Vwcy5wdXNoKCBncm91cCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRncm91cCA9IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzdGFydDogaSAqIDMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWxJbmRleDogbWF0ZXJpYWxJbmRleFxcblxcdFxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGdyb3VwICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Z3JvdXAuY291bnQgPSAoIGkgKiAzICkgLSBncm91cC5zdGFydDtcXG5cXHRcXHRcXHRcXHRncm91cHMucHVzaCggZ3JvdXAgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5ncm91cHMgPSBncm91cHM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmcm9tR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkuZmFjZXM7XFxuXFx0XFx0XFx0dmFyIHZlcnRpY2VzID0gZ2VvbWV0cnkudmVydGljZXM7XFxuXFx0XFx0XFx0dmFyIGZhY2VWZXJ0ZXhVdnMgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzO1xcblxcblxcdFxcdFxcdHZhciBoYXNGYWNlVmVydGV4VXYgPSBmYWNlVmVydGV4VXZzWyAwIF0gJiYgZmFjZVZlcnRleFV2c1sgMCBdLmxlbmd0aCA+IDA7XFxuXFx0XFx0XFx0dmFyIGhhc0ZhY2VWZXJ0ZXhVdjIgPSBmYWNlVmVydGV4VXZzWyAxIF0gJiYgZmFjZVZlcnRleFV2c1sgMSBdLmxlbmd0aCA+IDA7XFxuXFxuXFx0XFx0XFx0Ly8gbW9ycGhzXFxuXFxuXFx0XFx0XFx0dmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcXG5cXHRcXHRcXHR2YXIgbW9ycGhUYXJnZXRzTGVuZ3RoID0gbW9ycGhUYXJnZXRzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHR2YXIgbW9ycGhUYXJnZXRzUG9zaXRpb247XFxuXFxuXFx0XFx0XFx0aWYgKCBtb3JwaFRhcmdldHNMZW5ndGggPiAwICkge1xcblxcblxcdFxcdFxcdFxcdG1vcnBoVGFyZ2V0c1Bvc2l0aW9uID0gW107XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbW9ycGhUYXJnZXRzTGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG1vcnBoVGFyZ2V0c1Bvc2l0aW9uWyBpIF0gPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5tb3JwaFRhcmdldHMucG9zaXRpb24gPSBtb3JwaFRhcmdldHNQb3NpdGlvbjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIG1vcnBoTm9ybWFscyA9IGdlb21ldHJ5Lm1vcnBoTm9ybWFscztcXG5cXHRcXHRcXHR2YXIgbW9ycGhOb3JtYWxzTGVuZ3RoID0gbW9ycGhOb3JtYWxzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHR2YXIgbW9ycGhUYXJnZXRzTm9ybWFsO1xcblxcblxcdFxcdFxcdGlmICggbW9ycGhOb3JtYWxzTGVuZ3RoID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRtb3JwaFRhcmdldHNOb3JtYWwgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBtb3JwaE5vcm1hbHNMZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bW9ycGhUYXJnZXRzTm9ybWFsWyBpIF0gPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5tb3JwaFRhcmdldHMubm9ybWFsID0gbW9ycGhUYXJnZXRzTm9ybWFsO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBza2luc1xcblxcblxcdFxcdFxcdHZhciBza2luSW5kaWNlcyA9IGdlb21ldHJ5LnNraW5JbmRpY2VzO1xcblxcdFxcdFxcdHZhciBza2luV2VpZ2h0cyA9IGdlb21ldHJ5LnNraW5XZWlnaHRzO1xcblxcblxcdFxcdFxcdHZhciBoYXNTa2luSW5kaWNlcyA9IHNraW5JbmRpY2VzLmxlbmd0aCA9PT0gdmVydGljZXMubGVuZ3RoO1xcblxcdFxcdFxcdHZhciBoYXNTa2luV2VpZ2h0cyA9IHNraW5XZWlnaHRzLmxlbmd0aCA9PT0gdmVydGljZXMubGVuZ3RoO1xcblxcblxcdFxcdFxcdC8vXFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZmFjZXMubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnZlcnRpY2VzLnB1c2goIHZlcnRpY2VzWyBmYWNlLmEgXSwgdmVydGljZXNbIGZhY2UuYiBdLCB2ZXJ0aWNlc1sgZmFjZS5jIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdmVydGV4Tm9ybWFscyA9IGZhY2UudmVydGV4Tm9ybWFscztcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHZlcnRleE5vcm1hbHMubGVuZ3RoID09PSAzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMubm9ybWFscy5wdXNoKCB2ZXJ0ZXhOb3JtYWxzWyAwIF0sIHZlcnRleE5vcm1hbHNbIDEgXSwgdmVydGV4Tm9ybWFsc1sgMiBdICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgbm9ybWFsID0gZmFjZS5ub3JtYWw7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5ub3JtYWxzLnB1c2goIG5vcm1hbCwgbm9ybWFsLCBub3JtYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHZlcnRleENvbG9ycyA9IGZhY2UudmVydGV4Q29sb3JzO1xcblxcblxcdFxcdFxcdFxcdGlmICggdmVydGV4Q29sb3JzLmxlbmd0aCA9PT0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmNvbG9ycy5wdXNoKCB2ZXJ0ZXhDb2xvcnNbIDAgXSwgdmVydGV4Q29sb3JzWyAxIF0sIHZlcnRleENvbG9yc1sgMiBdICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgY29sb3IgPSBmYWNlLmNvbG9yO1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuY29sb3JzLnB1c2goIGNvbG9yLCBjb2xvciwgY29sb3IgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBoYXNGYWNlVmVydGV4VXYgPT09IHRydWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHZlcnRleFV2cyA9IGZhY2VWZXJ0ZXhVdnNbIDAgXVsgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdmVydGV4VXZzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy51dnMucHVzaCggdmVydGV4VXZzWyAwIF0sIHZlcnRleFV2c1sgMSBdLCB2ZXJ0ZXhVdnNbIDIgXSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRGlyZWN0R2VvbWV0cnkuZnJvbUdlb21ldHJ5KCk6IFVuZGVmaW5lZCB2ZXJ0ZXhVdiAnLCBpICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy51dnMucHVzaCggbmV3IFZlY3RvcjIoKSwgbmV3IFZlY3RvcjIoKSwgbmV3IFZlY3RvcjIoKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBoYXNGYWNlVmVydGV4VXYyID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB2ZXJ0ZXhVdnMgPSBmYWNlVmVydGV4VXZzWyAxIF1bIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHZlcnRleFV2cyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMudXZzMi5wdXNoKCB2ZXJ0ZXhVdnNbIDAgXSwgdmVydGV4VXZzWyAxIF0sIHZlcnRleFV2c1sgMiBdICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5EaXJlY3RHZW9tZXRyeS5mcm9tR2VvbWV0cnkoKTogVW5kZWZpbmVkIHZlcnRleFV2MiAnLCBpICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy51dnMyLnB1c2goIG5ldyBWZWN0b3IyKCksIG5ldyBWZWN0b3IyKCksIG5ldyBWZWN0b3IyKCkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIG1vcnBoc1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMDsgaiA8IG1vcnBoVGFyZ2V0c0xlbmd0aDsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgbW9ycGhUYXJnZXQgPSBtb3JwaFRhcmdldHNbIGogXS52ZXJ0aWNlcztcXG5cXG5cXHRcXHRcXHRcXHRcXHRtb3JwaFRhcmdldHNQb3NpdGlvblsgaiBdLnB1c2goIG1vcnBoVGFyZ2V0WyBmYWNlLmEgXSwgbW9ycGhUYXJnZXRbIGZhY2UuYiBdLCBtb3JwaFRhcmdldFsgZmFjZS5jIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwOyBqIDwgbW9ycGhOb3JtYWxzTGVuZ3RoOyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBtb3JwaE5vcm1hbCA9IG1vcnBoTm9ybWFsc1sgaiBdLnZlcnRleE5vcm1hbHNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtb3JwaFRhcmdldHNOb3JtYWxbIGogXS5wdXNoKCBtb3JwaE5vcm1hbC5hLCBtb3JwaE5vcm1hbC5iLCBtb3JwaE5vcm1hbC5jICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIHNraW5zXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBoYXNTa2luSW5kaWNlcyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnNraW5JbmRpY2VzLnB1c2goIHNraW5JbmRpY2VzWyBmYWNlLmEgXSwgc2tpbkluZGljZXNbIGZhY2UuYiBdLCBza2luSW5kaWNlc1sgZmFjZS5jIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBoYXNTa2luV2VpZ2h0cyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnNraW5XZWlnaHRzLnB1c2goIHNraW5XZWlnaHRzWyBmYWNlLmEgXSwgc2tpbldlaWdodHNbIGZhY2UuYiBdLCBza2luV2VpZ2h0c1sgZmFjZS5jIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuY29tcHV0ZUdyb3VwcyggZ2VvbWV0cnkgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZTtcXG5cXHRcXHRcXHR0aGlzLm5vcm1hbHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGU7XFxuXFx0XFx0XFx0dGhpcy5jb2xvcnNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuY29sb3JzTmVlZFVwZGF0ZTtcXG5cXHRcXHRcXHR0aGlzLnV2c05lZWRVcGRhdGUgPSBnZW9tZXRyeS51dnNOZWVkVXBkYXRlO1xcblxcdFxcdFxcdHRoaXMuZ3JvdXBzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGU7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIGFycmF5TWF4KCBhcnJheSApIHtcXG5cXG5cXHRcXHRpZiAoIGFycmF5Lmxlbmd0aCA9PT0gMCApIHJldHVybiAtIEluZmluaXR5O1xcblxcblxcdFxcdHZhciBtYXggPSBhcnJheVsgMCBdO1xcblxcblxcdFxcdGZvciAoIHZhciBpID0gMSwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBhcnJheVsgaSBdID4gbWF4ICkgbWF4ID0gYXJyYXlbIGkgXTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIG1heDtcXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdHZhciBidWZmZXJHZW9tZXRyeUlkID0gMTsgLy8gQnVmZmVyR2VvbWV0cnkgdXNlcyBvZGQgbnVtYmVycyBhcyBJZFxcblxcblxcdGZ1bmN0aW9uIEJ1ZmZlckdlb21ldHJ5KCkge1xcblxcblxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ2lkJywgeyB2YWx1ZTogYnVmZmVyR2VvbWV0cnlJZCArPSAyIH0gKTtcXG5cXG5cXHRcXHR0aGlzLnV1aWQgPSBfTWF0aC5nZW5lcmF0ZVVVSUQoKTtcXG5cXG5cXHRcXHR0aGlzLm5hbWUgPSAnJztcXG5cXHRcXHR0aGlzLnR5cGUgPSAnQnVmZmVyR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMuaW5kZXggPSBudWxsO1xcblxcdFxcdHRoaXMuYXR0cmlidXRlcyA9IHt9O1xcblxcblxcdFxcdHRoaXMubW9ycGhBdHRyaWJ1dGVzID0ge307XFxuXFxuXFx0XFx0dGhpcy5ncm91cHMgPSBbXTtcXG5cXG5cXHRcXHR0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDtcXG5cXHRcXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLmRyYXdSYW5nZSA9IHsgc3RhcnQ6IDAsIGNvdW50OiBJbmZpbml0eSB9O1xcblxcblxcdH1cXG5cXG5cXHRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBFdmVudERpc3BhdGNoZXIucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogQnVmZmVyR2VvbWV0cnksXFxuXFxuXFx0XFx0aXNCdWZmZXJHZW9tZXRyeTogdHJ1ZSxcXG5cXG5cXHRcXHRnZXRJbmRleDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmluZGV4O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0SW5kZXg6IGZ1bmN0aW9uICggaW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCBpbmRleCApICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuaW5kZXggPSBuZXcgKCBhcnJheU1heCggaW5kZXggKSA+IDY1NTM1ID8gVWludDMyQnVmZmVyQXR0cmlidXRlIDogVWludDE2QnVmZmVyQXR0cmlidXRlICkoIGluZGV4LCAxICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmluZGV4ID0gaW5kZXg7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YWRkQXR0cmlidXRlOiBmdW5jdGlvbiAoIG5hbWUsIGF0dHJpYnV0ZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoICEgKCBhdHRyaWJ1dGUgJiYgYXR0cmlidXRlLmlzQnVmZmVyQXR0cmlidXRlICkgJiYgISAoIGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkQXR0cmlidXRlKCkgbm93IGV4cGVjdHMgKCBuYW1lLCBhdHRyaWJ1dGUgKS4nICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoIG5hbWUsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGFyZ3VtZW50c1sgMSBdLCBhcmd1bWVudHNbIDIgXSApICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG5hbWUgPT09ICdpbmRleCcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuYWRkQXR0cmlidXRlOiBVc2UgLnNldEluZGV4KCkgZm9yIGluZGV4IGF0dHJpYnV0ZS4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5zZXRJbmRleCggYXR0cmlidXRlICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXSA9IGF0dHJpYnV0ZTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldEF0dHJpYnV0ZTogZnVuY3Rpb24gKCBuYW1lICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHJlbW92ZUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBuYW1lICkge1xcblxcblxcdFxcdFxcdGRlbGV0ZSB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFkZEdyb3VwOiBmdW5jdGlvbiAoIHN0YXJ0LCBjb3VudCwgbWF0ZXJpYWxJbmRleCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmdyb3Vwcy5wdXNoKCB7XFxuXFxuXFx0XFx0XFx0XFx0c3RhcnQ6IHN0YXJ0LFxcblxcdFxcdFxcdFxcdGNvdW50OiBjb3VudCxcXG5cXHRcXHRcXHRcXHRtYXRlcmlhbEluZGV4OiBtYXRlcmlhbEluZGV4ICE9PSB1bmRlZmluZWQgPyBtYXRlcmlhbEluZGV4IDogMFxcblxcblxcdFxcdFxcdH0gKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsZWFyR3JvdXBzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5ncm91cHMgPSBbXTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldERyYXdSYW5nZTogZnVuY3Rpb24gKCBzdGFydCwgY291bnQgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5kcmF3UmFuZ2Uuc3RhcnQgPSBzdGFydDtcXG5cXHRcXHRcXHR0aGlzLmRyYXdSYW5nZS5jb3VudCA9IGNvdW50O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YXBwbHlNYXRyaXg6IGZ1bmN0aW9uICggbWF0cml4ICkge1xcblxcblxcdFxcdFxcdHZhciBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcXG5cXG5cXHRcXHRcXHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bWF0cml4LmFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uICk7XFxuXFx0XFx0XFx0XFx0cG9zaXRpb24ubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgbm9ybWFsID0gdGhpcy5hdHRyaWJ1dGVzLm5vcm1hbDtcXG5cXG5cXHRcXHRcXHRpZiAoIG5vcm1hbCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLmdldE5vcm1hbE1hdHJpeCggbWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0bm9ybWFsTWF0cml4LmFwcGx5VG9CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbCApO1xcblxcdFxcdFxcdFxcdG5vcm1hbC5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdGhpcy5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyb3RhdGVYOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Ly8gcm90YXRlIGdlb21ldHJ5IGFyb3VuZCB3b3JsZCB4LWF4aXNcXG5cXG5cXHRcXHRcXHR2YXIgbTEgPSBuZXcgTWF0cml4NCgpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiByb3RhdGVYKCBhbmdsZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRtMS5tYWtlUm90YXRpb25YKCBhbmdsZSApO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYXBwbHlNYXRyaXgoIG0xICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0cm90YXRlWTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIHJvdGF0ZSBnZW9tZXRyeSBhcm91bmQgd29ybGQgeS1heGlzXFxuXFxuXFx0XFx0XFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcm90YXRlWSggYW5nbGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bTEubWFrZVJvdGF0aW9uWSggYW5nbGUgKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmFwcGx5TWF0cml4KCBtMSApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdHJvdGF0ZVo6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyByb3RhdGUgZ2VvbWV0cnkgYXJvdW5kIHdvcmxkIHotYXhpc1xcblxcblxcdFxcdFxcdHZhciBtMSA9IG5ldyBNYXRyaXg0KCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHJvdGF0ZVooIGFuZ2xlICkge1xcblxcblxcdFxcdFxcdFxcdG0xLm1ha2VSb3RhdGlvblooIGFuZ2xlICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHR0cmFuc2xhdGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyB0cmFuc2xhdGUgZ2VvbWV0cnlcXG5cXG5cXHRcXHRcXHR2YXIgbTEgPSBuZXcgTWF0cml4NCgpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiB0cmFuc2xhdGUoIHgsIHksIHogKSB7XFxuXFxuXFx0XFx0XFx0XFx0bTEubWFrZVRyYW5zbGF0aW9uKCB4LCB5LCB6ICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRzY2FsZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIHNjYWxlIGdlb21ldHJ5XFxuXFxuXFx0XFx0XFx0dmFyIG0xID0gbmV3IE1hdHJpeDQoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gc2NhbGUoIHgsIHksIHogKSB7XFxuXFxuXFx0XFx0XFx0XFx0bTEubWFrZVNjYWxlKCB4LCB5LCB6ICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5hcHBseU1hdHJpeCggbTEgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRsb29rQXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgb2JqID0gbmV3IE9iamVjdDNEKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGxvb2tBdCggdmVjdG9yICkge1xcblxcblxcdFxcdFxcdFxcdG9iai5sb29rQXQoIHZlY3RvciApO1xcblxcblxcdFxcdFxcdFxcdG9iai51cGRhdGVNYXRyaXgoKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmFwcGx5TWF0cml4KCBvYmoubWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0Y2VudGVyOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKTtcXG5cXG5cXHRcXHRcXHR2YXIgb2Zmc2V0ID0gdGhpcy5ib3VuZGluZ0JveC5nZXRDZW50ZXIoKS5uZWdhdGUoKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnRyYW5zbGF0ZSggb2Zmc2V0LngsIG9mZnNldC55LCBvZmZzZXQueiApO1xcblxcblxcdFxcdFxcdHJldHVybiBvZmZzZXQ7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tT2JqZWN0OiBmdW5jdGlvbiAoIG9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHQvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LnNldEZyb21PYmplY3QoKS4gQ29udmVydGluZycsIG9iamVjdCwgdGhpcyApO1xcblxcblxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcXG5cXG5cXHRcXHRcXHRpZiAoIG9iamVjdC5pc1BvaW50cyB8fCBvYmplY3QuaXNMaW5lICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICogMywgMyApO1xcblxcdFxcdFxcdFxcdHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkuY29sb3JzLmxlbmd0aCAqIDMsIDMgKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgcG9zaXRpb25zLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS52ZXJ0aWNlcyApICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIGNvbG9ycy5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICYmIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXMubGVuZ3RoID09PSBnZW9tZXRyeS52ZXJ0aWNlcy5sZW5ndGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGxpbmVEaXN0YW5jZXMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkubGluZURpc3RhbmNlcy5sZW5ndGgsIDEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ2xpbmVEaXN0YW5jZScsIGxpbmVEaXN0YW5jZXMuY29weUFycmF5KCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTWVzaCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5mcm9tR2VvbWV0cnkoIGdlb21ldHJ5ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xcblxcblxcdFxcdFxcdHZhciBwb3NpdGlvbiA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBwb2ludCA9IHBvaW50c1sgaSBdO1xcblxcdFxcdFxcdFxcdHBvc2l0aW9uLnB1c2goIHBvaW50LngsIHBvaW50LnksIHBvaW50LnogfHwgMCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCAzICkgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHVwZGF0ZUZyb21PYmplY3Q6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xcblxcblxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IG9iamVjdC5nZW9tZXRyeTtcXG5cXG5cXHRcXHRcXHRpZiAoIG9iamVjdC5pc01lc2ggKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGRpcmVjdCA9IGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5lbGVtZW50c05lZWRVcGRhdGUgPT09IHRydWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZGlyZWN0ID0gdW5kZWZpbmVkO1xcblxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5LmVsZW1lbnRzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGRpcmVjdCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0ZGlyZWN0LnZlcnRpY2VzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LnZlcnRpY2VzTmVlZFVwZGF0ZTtcXG5cXHRcXHRcXHRcXHRkaXJlY3Qubm9ybWFsc05lZWRVcGRhdGUgPSBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZTtcXG5cXHRcXHRcXHRcXHRkaXJlY3QuY29sb3JzTmVlZFVwZGF0ZSA9IGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGU7XFxuXFx0XFx0XFx0XFx0ZGlyZWN0LnV2c05lZWRVcGRhdGUgPSBnZW9tZXRyeS51dnNOZWVkVXBkYXRlO1xcblxcdFxcdFxcdFxcdGRpcmVjdC5ncm91cHNOZWVkVXBkYXRlID0gZ2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZTtcXG5cXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS51dnNOZWVkVXBkYXRlID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkuZ3JvdXBzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdGdlb21ldHJ5ID0gZGlyZWN0O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgYXR0cmlidXRlO1xcblxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkudmVydGljZXNOZWVkVXBkYXRlID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGF0dHJpYnV0ZS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKTtcXG5cXHRcXHRcXHRcXHRcXHRhdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS52ZXJ0aWNlc05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5ub3JtYWxzTmVlZFVwZGF0ZSA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xcblxcblxcdFxcdFxcdFxcdGlmICggYXR0cmlidXRlICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBnZW9tZXRyeS5ub3JtYWxzICk7XFxuXFx0XFx0XFx0XFx0XFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkubm9ybWFsc05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5jb2xvcnNOZWVkVXBkYXRlID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5jb2xvcjtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGF0dHJpYnV0ZS5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApO1xcblxcdFxcdFxcdFxcdFxcdGF0dHJpYnV0ZS5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGdlb21ldHJ5LmNvbG9yc05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS51dnNOZWVkVXBkYXRlICkge1xcblxcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy51djtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGF0dHJpYnV0ZS5jb3B5VmVjdG9yMnNBcnJheSggZ2VvbWV0cnkudXZzICk7XFxuXFx0XFx0XFx0XFx0XFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkudXZzTmVlZFVwZGF0ZSA9IGZhbHNlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmxpbmVEaXN0YW5jZXNOZWVkVXBkYXRlICkge1xcblxcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlcy5saW5lRGlzdGFuY2U7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBhdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRhdHRyaWJ1dGUuY29weUFycmF5KCBnZW9tZXRyeS5saW5lRGlzdGFuY2VzICk7XFxuXFx0XFx0XFx0XFx0XFx0YXR0cmlidXRlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkubGluZURpc3RhbmNlc05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5ncm91cHNOZWVkVXBkYXRlICkge1xcblxcblxcdFxcdFxcdFxcdGdlb21ldHJ5LmNvbXB1dGVHcm91cHMoIG9iamVjdC5nZW9tZXRyeSApO1xcblxcdFxcdFxcdFxcdHRoaXMuZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xcblxcblxcdFxcdFxcdFxcdGdlb21ldHJ5Lmdyb3Vwc05lZWRVcGRhdGUgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmcm9tR2VvbWV0cnk6IGZ1bmN0aW9uICggZ2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0Z2VvbWV0cnkuX19kaXJlY3RHZW9tZXRyeSA9IG5ldyBEaXJlY3RHZW9tZXRyeSgpLmZyb21HZW9tZXRyeSggZ2VvbWV0cnkgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5mcm9tRGlyZWN0R2VvbWV0cnkoIGdlb21ldHJ5Ll9fZGlyZWN0R2VvbWV0cnkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGZyb21EaXJlY3RHZW9tZXRyeTogZnVuY3Rpb24gKCBnZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICogMyApO1xcblxcdFxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKS5jb3B5VmVjdG9yM3NBcnJheSggZ2VvbWV0cnkudmVydGljZXMgKSApO1xcblxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggPiAwICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBub3JtYWxzID0gbmV3IEZsb2F0MzJBcnJheSggZ2VvbWV0cnkubm9ybWFscy5sZW5ndGggKiAzICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkuY29weVZlY3RvcjNzQXJyYXkoIGdlb21ldHJ5Lm5vcm1hbHMgKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmNvbG9ycy5sZW5ndGggPiAwICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBjb2xvcnMgPSBuZXcgRmxvYXQzMkFycmF5KCBnZW9tZXRyeS5jb2xvcnMubGVuZ3RoICogMyApO1xcblxcdFxcdFxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKS5jb3B5Q29sb3JzQXJyYXkoIGdlb21ldHJ5LmNvbG9ycyApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkudXZzLmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHV2cyA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnV2cy5sZW5ndGggKiAyICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMgKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5LnV2czIubGVuZ3RoID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdXZzMiA9IG5ldyBGbG9hdDMyQXJyYXkoIGdlb21ldHJ5LnV2czIubGVuZ3RoICogMiApO1xcblxcdFxcdFxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYyJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggdXZzMiwgMiApLmNvcHlWZWN0b3Iyc0FycmF5KCBnZW9tZXRyeS51dnMyICkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5pbmRpY2VzLmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIFR5cGVBcnJheSA9IGFycmF5TWF4KCBnZW9tZXRyeS5pbmRpY2VzICkgPiA2NTUzNSA/IFVpbnQzMkFycmF5IDogVWludDE2QXJyYXk7XFxuXFx0XFx0XFx0XFx0dmFyIGluZGljZXMgPSBuZXcgVHlwZUFycmF5KCBnZW9tZXRyeS5pbmRpY2VzLmxlbmd0aCAqIDMgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnNldEluZGV4KCBuZXcgQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkuY29weUluZGljZXNBcnJheSggZ2VvbWV0cnkuaW5kaWNlcyApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGdyb3Vwc1xcblxcblxcdFxcdFxcdHRoaXMuZ3JvdXBzID0gZ2VvbWV0cnkuZ3JvdXBzO1xcblxcblxcdFxcdFxcdC8vIG1vcnBoc1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBuYW1lIGluIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYXJyYXkgPSBbXTtcXG5cXHRcXHRcXHRcXHR2YXIgbW9ycGhUYXJnZXRzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBuYW1lIF07XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1vcnBoVGFyZ2V0ID0gbW9ycGhUYXJnZXRzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGF0dHJpYnV0ZSA9IG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBtb3JwaFRhcmdldC5sZW5ndGggKiAzLCAzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YXJyYXkucHVzaCggYXR0cmlidXRlLmNvcHlWZWN0b3Izc0FycmF5KCBtb3JwaFRhcmdldCApICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRoaXMubW9ycGhBdHRyaWJ1dGVzWyBuYW1lIF0gPSBhcnJheTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gc2tpbm5pbmdcXG5cXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHNraW5JbmRpY2VzID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAqIDQsIDQgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3NraW5JbmRleCcsIHNraW5JbmRpY2VzLmNvcHlWZWN0b3I0c0FycmF5KCBnZW9tZXRyeS5za2luSW5kaWNlcyApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgc2tpbldlaWdodHMgPSBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICogNCwgNCApO1xcblxcdFxcdFxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAnc2tpbldlaWdodCcsIHNraW5XZWlnaHRzLmNvcHlWZWN0b3I0c0FycmF5KCBnZW9tZXRyeS5za2luV2VpZ2h0cyApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vXFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ0JveCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmJvdW5kaW5nQm94ID0gZ2VvbWV0cnkuYm91bmRpbmdCb3guY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb21wdXRlQm91bmRpbmdCb3g6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuYm91bmRpbmdCb3ggPT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5ib3VuZGluZ0JveCA9IG5ldyBCb3gzKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcXG5cXG5cXHRcXHRcXHRpZiAoIHBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5ib3VuZGluZ0JveC5zZXRGcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5ib3VuZGluZ0JveC5tYWtlRW1wdHkoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBpc05hTiggdGhpcy5ib3VuZGluZ0JveC5taW4ueCApIHx8IGlzTmFOKCB0aGlzLmJvdW5kaW5nQm94Lm1pbi55ICkgfHwgaXNOYU4oIHRoaXMuYm91bmRpbmdCb3gubWluLnogKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94OiBDb21wdXRlZCBtaW4vbWF4IGhhdmUgTmFOIHZhbHVlcy4gVGhlIFxcXCJwb3NpdGlvblxcXCIgYXR0cmlidXRlIGlzIGxpa2VseSB0byBoYXZlIE5hTiB2YWx1ZXMuJywgdGhpcyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvbXB1dGVCb3VuZGluZ1NwaGVyZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBib3ggPSBuZXcgQm94MygpO1xcblxcdFxcdFxcdHZhciB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBjb21wdXRlQm91bmRpbmdTcGhlcmUoKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0aGlzLmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBuZXcgU3BoZXJlKCk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciBwb3NpdGlvbiA9IHRoaXMuYXR0cmlidXRlcy5wb3NpdGlvbjtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHBvc2l0aW9uICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBjZW50ZXIgPSB0aGlzLmJvdW5kaW5nU3BoZXJlLmNlbnRlcjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRib3guc2V0RnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24gKTtcXG5cXHRcXHRcXHRcXHRcXHRib3guZ2V0Q2VudGVyKCBjZW50ZXIgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBob3BpbmcgdG8gZmluZCBhIGJvdW5kaW5nU3BoZXJlIHdpdGggYSByYWRpdXMgc21hbGxlciB0aGFuIHRoZVxcblxcdFxcdFxcdFxcdFxcdC8vIGJvdW5kaW5nU3BoZXJlIG9mIHRoZSBib3VuZGluZ0JveDogc3FydCgzKSBzbWFsbGVyIGluIHRoZSBiZXN0IGNhc2VcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgbWF4UmFkaXVzU3EgPSAwO1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBwb3NpdGlvbi5jb3VudDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZlY3Rvci54ID0gcG9zaXRpb24uZ2V0WCggaSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZlY3Rvci55ID0gcG9zaXRpb24uZ2V0WSggaSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZlY3Rvci56ID0gcG9zaXRpb24uZ2V0WiggaSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdG1heFJhZGl1c1NxID0gTWF0aC5tYXgoIG1heFJhZGl1c1NxLCBjZW50ZXIuZGlzdGFuY2VUb1NxdWFyZWQoIHZlY3RvciApICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzID0gTWF0aC5zcXJ0KCBtYXhSYWRpdXNTcSApO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggaXNOYU4oIHRoaXMuYm91bmRpbmdTcGhlcmUucmFkaXVzICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpOiBDb21wdXRlZCByYWRpdXMgaXMgTmFOLiBUaGUgXFxcInBvc2l0aW9uXFxcIiBhdHRyaWJ1dGUgaXMgbGlrZWx5IHRvIGhhdmUgTmFOIHZhbHVlcy4nLCB0aGlzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRjb21wdXRlRmFjZU5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29tcHV0ZVZlcnRleE5vcm1hbHM6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xcblxcdFxcdFxcdHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzO1xcblxcdFxcdFxcdHZhciBncm91cHMgPSB0aGlzLmdyb3VwcztcXG5cXG5cXHRcXHRcXHRpZiAoIGF0dHJpYnV0ZXMucG9zaXRpb24gKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBhdHRyaWJ1dGVzLm5vcm1hbCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggbmV3IEZsb2F0MzJBcnJheSggcG9zaXRpb25zLmxlbmd0aCApLCAzICkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHJlc2V0IGV4aXN0aW5nIG5vcm1hbHMgdG8gemVyb1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBhcnJheSA9IGF0dHJpYnV0ZXMubm9ybWFsLmFycmF5O1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBhcnJheS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRhcnJheVsgaSBdID0gMDtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciBub3JtYWxzID0gYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHZBLCB2QiwgdkM7XFxuXFx0XFx0XFx0XFx0dmFyIHBBID0gbmV3IFZlY3RvcjMoKSwgcEIgPSBuZXcgVmVjdG9yMygpLCBwQyA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0XFx0dmFyIGNiID0gbmV3IFZlY3RvcjMoKSwgYWIgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdFxcdC8vIGluZGV4ZWQgZWxlbWVudHNcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGluZGV4ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBncm91cHMubGVuZ3RoID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuYWRkR3JvdXAoIDAsIGluZGljZXMubGVuZ3RoICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMCwgamwgPSBncm91cHMubGVuZ3RoOyBqIDwgamw7ICsrIGogKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBqIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHN0YXJ0ID0gZ3JvdXAuc3RhcnQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGNvdW50ID0gZ3JvdXAuY291bnQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSBzdGFydCwgaWwgPSBzdGFydCArIGNvdW50OyBpIDwgaWw7IGkgKz0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2QSA9IGluZGljZXNbIGkgKyAwIF0gKiAzO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZCID0gaW5kaWNlc1sgaSArIDEgXSAqIDM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dkMgPSBpbmRpY2VzWyBpICsgMiBdICogMztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwQS5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkEgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwQi5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwQy5mcm9tQXJyYXkoIHBvc2l0aW9ucywgdkMgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjYi5zdWJWZWN0b3JzKCBwQywgcEIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRhYi5zdWJWZWN0b3JzKCBwQSwgcEIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjYi5jcm9zcyggYWIgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyB2QSBdICs9IGNiLng7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgdkEgKyAxIF0gKz0gY2IueTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyB2QSArIDIgXSArPSBjYi56O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIHZCIF0gKz0gY2IueDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyB2QiArIDEgXSArPSBjYi55O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIHZCICsgMiBdICs9IGNiLno7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgdkMgXSArPSBjYi54O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIHZDICsgMSBdICs9IGNiLnk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgdkMgKyAyIF0gKz0gY2IuejtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbm9uLWluZGV4ZWQgZWxlbWVudHMgKHVuY29ubmVjdGVkIHRyaWFuZ2xlIHNvdXApXFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpbDsgaSArPSA5ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHBBLmZyb21BcnJheSggcG9zaXRpb25zLCBpICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cEIuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyAzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cEMuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKyA2ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2Iuc3ViVmVjdG9ycyggcEMsIHBCICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YWIuc3ViVmVjdG9ycyggcEEsIHBCICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2IuY3Jvc3MoIGFiICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgaSBdID0gY2IueDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBpICsgMSBdID0gY2IueTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBpICsgMiBdID0gY2IuejtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBpICsgMyBdID0gY2IueDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBpICsgNCBdID0gY2IueTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBpICsgNSBdID0gY2IuejtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBpICsgNiBdID0gY2IueDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBpICsgNyBdID0gY2IueTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBpICsgOCBdID0gY2IuejtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRoaXMubm9ybWFsaXplTm9ybWFscygpO1xcblxcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZXMubm9ybWFsLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtZXJnZTogZnVuY3Rpb24gKCBnZW9tZXRyeSwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdGlmICggISAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnkubWVyZ2UoKTogZ2VvbWV0cnkgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkJ1ZmZlckdlb21ldHJ5LicsIGdlb21ldHJ5ICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHR2YXIgYXR0cmlidXRlcyA9IHRoaXMuYXR0cmlidXRlcztcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5hdHRyaWJ1dGVzWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGF0dHJpYnV0ZTEgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcXG5cXHRcXHRcXHRcXHR2YXIgYXR0cmlidXRlQXJyYXkxID0gYXR0cmlidXRlMS5hcnJheTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYXR0cmlidXRlMiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXNbIGtleSBdO1xcblxcdFxcdFxcdFxcdHZhciBhdHRyaWJ1dGVBcnJheTIgPSBhdHRyaWJ1dGUyLmFycmF5O1xcblxcblxcdFxcdFxcdFxcdHZhciBhdHRyaWJ1dGVTaXplID0gYXR0cmlidXRlMi5pdGVtU2l6ZTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGogPSBhdHRyaWJ1dGVTaXplICogb2Zmc2V0OyBpIDwgYXR0cmlidXRlQXJyYXkyLmxlbmd0aDsgaSArKywgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRhdHRyaWJ1dGVBcnJheTFbIGogXSA9IGF0dHJpYnV0ZUFycmF5MlsgaSBdO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRub3JtYWxpemVOb3JtYWxzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIG5vcm1hbGl6ZU5vcm1hbHMoKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG5vcm1hbHMgPSB0aGlzLmF0dHJpYnV0ZXMubm9ybWFsO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBub3JtYWxzLmNvdW50OyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVjdG9yLnggPSBub3JtYWxzLmdldFgoIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZWN0b3IueSA9IG5vcm1hbHMuZ2V0WSggaSApO1xcblxcdFxcdFxcdFxcdFxcdHZlY3Rvci56ID0gbm9ybWFscy5nZXRaKCBpICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVjdG9yLm5vcm1hbGl6ZSgpO1xcblxcblxcdFxcdFxcdFxcdFxcdG5vcm1hbHMuc2V0WFlaKCBpLCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdHRvTm9uSW5kZXhlZDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5pbmRleCA9PT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeS50b05vbkluZGV4ZWQoKTogR2VvbWV0cnkgaXMgYWxyZWFkeSBub24taW5kZXhlZC4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBnZW9tZXRyeTIgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXG5cXG5cXHRcXHRcXHR2YXIgaW5kaWNlcyA9IHRoaXMuaW5kZXguYXJyYXk7XFxuXFx0XFx0XFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYXR0cmlidXRlID0gYXR0cmlidXRlc1sgbmFtZSBdO1xcblxcblxcdFxcdFxcdFxcdHZhciBhcnJheSA9IGF0dHJpYnV0ZS5hcnJheTtcXG5cXHRcXHRcXHRcXHR2YXIgaXRlbVNpemUgPSBhdHRyaWJ1dGUuaXRlbVNpemU7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGFycmF5MiA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvciggaW5kaWNlcy5sZW5ndGggKiBpdGVtU2l6ZSApO1xcblxcblxcdFxcdFxcdFxcdHZhciBpbmRleCA9IDAsIGluZGV4MiA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGluZGV4ID0gaW5kaWNlc1sgaSBdICogaXRlbVNpemU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwOyBqIDwgaXRlbVNpemU7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YXJyYXkyWyBpbmRleDIgKysgXSA9IGFycmF5WyBpbmRleCArKyBdO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkyLmFkZEF0dHJpYnV0ZSggbmFtZSwgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXkyLCBpdGVtU2l6ZSApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBnZW9tZXRyeTI7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgZGF0YSA9IHtcXG5cXHRcXHRcXHRcXHRtZXRhZGF0YToge1xcblxcdFxcdFxcdFxcdFxcdHZlcnNpb246IDQuNSxcXG5cXHRcXHRcXHRcXHRcXHR0eXBlOiAnQnVmZmVyR2VvbWV0cnknLFxcblxcdFxcdFxcdFxcdFxcdGdlbmVyYXRvcjogJ0J1ZmZlckdlb21ldHJ5LnRvSlNPTidcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHQvLyBzdGFuZGFyZCBCdWZmZXJHZW9tZXRyeSBzZXJpYWxpemF0aW9uXFxuXFxuXFx0XFx0XFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xcblxcdFxcdFxcdGRhdGEudHlwZSA9IHRoaXMudHlwZTtcXG5cXHRcXHRcXHRpZiAoIHRoaXMubmFtZSAhPT0gJycgKSBkYXRhLm5hbWUgPSB0aGlzLm5hbWU7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnBhcmFtZXRlcnMgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIga2V5IGluIHBhcmFtZXRlcnMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwYXJhbWV0ZXJzWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkgZGF0YVsga2V5IF0gPSBwYXJhbWV0ZXJzWyBrZXkgXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGRhdGEuZGF0YSA9IHsgYXR0cmlidXRlczoge30gfTtcXG5cXG5cXHRcXHRcXHR2YXIgaW5kZXggPSB0aGlzLmluZGV4O1xcblxcblxcdFxcdFxcdGlmICggaW5kZXggIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGluZGV4LmFycmF5ICk7XFxuXFxuXFx0XFx0XFx0XFx0ZGF0YS5kYXRhLmluZGV4ID0ge1xcblxcdFxcdFxcdFxcdFxcdHR5cGU6IGluZGV4LmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXFxuXFx0XFx0XFx0XFx0XFx0YXJyYXk6IGFycmF5XFxuXFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXM7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGtleSBpbiBhdHRyaWJ1dGVzICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBrZXkgXTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYXJyYXkgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXR0cmlidXRlLmFycmF5ICk7XFxuXFxuXFx0XFx0XFx0XFx0ZGF0YS5kYXRhLmF0dHJpYnV0ZXNbIGtleSBdID0ge1xcblxcdFxcdFxcdFxcdFxcdGl0ZW1TaXplOiBhdHRyaWJ1dGUuaXRlbVNpemUsXFxuXFx0XFx0XFx0XFx0XFx0dHlwZTogYXR0cmlidXRlLmFycmF5LmNvbnN0cnVjdG9yLm5hbWUsXFxuXFx0XFx0XFx0XFx0XFx0YXJyYXk6IGFycmF5LFxcblxcdFxcdFxcdFxcdFxcdG5vcm1hbGl6ZWQ6IGF0dHJpYnV0ZS5ub3JtYWxpemVkXFxuXFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGdyb3VwcyA9IHRoaXMuZ3JvdXBzO1xcblxcblxcdFxcdFxcdGlmICggZ3JvdXBzLmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZGF0YS5kYXRhLmdyb3VwcyA9IEpTT04ucGFyc2UoIEpTT04uc3RyaW5naWZ5KCBncm91cHMgKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgYm91bmRpbmdTcGhlcmUgPSB0aGlzLmJvdW5kaW5nU3BoZXJlO1xcblxcblxcdFxcdFxcdGlmICggYm91bmRpbmdTcGhlcmUgIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZGF0YS5kYXRhLmJvdW5kaW5nU3BoZXJlID0ge1xcblxcdFxcdFxcdFxcdFxcdGNlbnRlcjogYm91bmRpbmdTcGhlcmUuY2VudGVyLnRvQXJyYXkoKSxcXG5cXHRcXHRcXHRcXHRcXHRyYWRpdXM6IGJvdW5kaW5nU3BoZXJlLnJhZGl1c1xcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBkYXRhO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHQvKlxcblxcdFxcdFxcdCAvLyBIYW5kbGUgcHJpbWl0aXZlc1xcblxcblxcdFxcdFxcdCB2YXIgcGFyYW1ldGVycyA9IHRoaXMucGFyYW1ldGVycztcXG5cXG5cXHRcXHRcXHQgaWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0IHZhciB2YWx1ZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHQgZm9yICggdmFyIGtleSBpbiBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdFxcdCB2YWx1ZXMucHVzaCggcGFyYW1ldGVyc1sga2V5IF0gKTtcXG5cXG5cXHRcXHRcXHQgfVxcblxcblxcdFxcdFxcdCB2YXIgZ2VvbWV0cnkgPSBPYmplY3QuY3JlYXRlKCB0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSApO1xcblxcdFxcdFxcdCB0aGlzLmNvbnN0cnVjdG9yLmFwcGx5KCBnZW9tZXRyeSwgdmFsdWVzICk7XFxuXFx0XFx0XFx0IHJldHVybiBnZW9tZXRyeTtcXG5cXG5cXHRcXHRcXHQgfVxcblxcblxcdFxcdFxcdCByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxuXFx0XFx0XFx0ICovXFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBCdWZmZXJHZW9tZXRyeSgpLmNvcHkoIHRoaXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdFxcdHZhciBuYW1lLCBpLCBsO1xcblxcblxcdFxcdFxcdC8vIHJlc2V0XFxuXFxuXFx0XFx0XFx0dGhpcy5pbmRleCA9IG51bGw7XFxuXFx0XFx0XFx0dGhpcy5hdHRyaWJ1dGVzID0ge307XFxuXFx0XFx0XFx0dGhpcy5tb3JwaEF0dHJpYnV0ZXMgPSB7fTtcXG5cXHRcXHRcXHR0aGlzLmdyb3VwcyA9IFtdO1xcblxcdFxcdFxcdHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xcblxcdFxcdFxcdHRoaXMuYm91bmRpbmdTcGhlcmUgPSBudWxsO1xcblxcblxcdFxcdFxcdC8vIG5hbWVcXG5cXG5cXHRcXHRcXHR0aGlzLm5hbWUgPSBzb3VyY2UubmFtZTtcXG5cXG5cXHRcXHRcXHQvLyBpbmRleFxcblxcblxcdFxcdFxcdHZhciBpbmRleCA9IHNvdXJjZS5pbmRleDtcXG5cXG5cXHRcXHRcXHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuc2V0SW5kZXgoIGluZGV4LmNsb25lKCkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gYXR0cmlidXRlc1xcblxcblxcdFxcdFxcdHZhciBhdHRyaWJ1dGVzID0gc291cmNlLmF0dHJpYnV0ZXM7XFxuXFxuXFx0XFx0XFx0Zm9yICggbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzWyBuYW1lIF07XFxuXFx0XFx0XFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoIG5hbWUsIGF0dHJpYnV0ZS5jbG9uZSgpICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIG1vcnBoIGF0dHJpYnV0ZXNcXG5cXG5cXHRcXHRcXHR2YXIgbW9ycGhBdHRyaWJ1dGVzID0gc291cmNlLm1vcnBoQXR0cmlidXRlcztcXG5cXG5cXHRcXHRcXHRmb3IgKCBuYW1lIGluIG1vcnBoQXR0cmlidXRlcyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYXJyYXkgPSBbXTtcXG5cXHRcXHRcXHRcXHR2YXIgbW9ycGhBdHRyaWJ1dGUgPSBtb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXTsgLy8gbW9ycGhBdHRyaWJ1dGU6IGFycmF5IG9mIEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGVzXFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDAsIGwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGFycmF5LnB1c2goIG1vcnBoQXR0cmlidXRlWyBpIF0uY2xvbmUoKSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLm1vcnBoQXR0cmlidXRlc1sgbmFtZSBdID0gYXJyYXk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGdyb3Vwc1xcblxcblxcdFxcdFxcdHZhciBncm91cHMgPSBzb3VyY2UuZ3JvdXBzO1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XFxuXFx0XFx0XFx0XFx0dGhpcy5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGJvdW5kaW5nIGJveFxcblxcblxcdFxcdFxcdHZhciBib3VuZGluZ0JveCA9IHNvdXJjZS5ib3VuZGluZ0JveDtcXG5cXG5cXHRcXHRcXHRpZiAoIGJvdW5kaW5nQm94ICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveC5jbG9uZSgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBib3VuZGluZyBzcGhlcmVcXG5cXG5cXHRcXHRcXHR2YXIgYm91bmRpbmdTcGhlcmUgPSBzb3VyY2UuYm91bmRpbmdTcGhlcmU7XFxuXFxuXFx0XFx0XFx0aWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmJvdW5kaW5nU3BoZXJlID0gYm91bmRpbmdTcGhlcmUuY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gZHJhdyByYW5nZVxcblxcblxcdFxcdFxcdHRoaXMuZHJhd1JhbmdlLnN0YXJ0ID0gc291cmNlLmRyYXdSYW5nZS5zdGFydDtcXG5cXHRcXHRcXHR0aGlzLmRyYXdSYW5nZS5jb3VudCA9IHNvdXJjZS5kcmF3UmFuZ2UuY291bnQ7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5kaXNwYXRjaEV2ZW50KCB7IHR5cGU6ICdkaXNwb3NlJyB9ICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxuXFx0ICovXFxuXFxuXFx0Ly8gQm94R2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBCb3hHZW9tZXRyeSggd2lkdGgsIGhlaWdodCwgZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBkZXB0aFNlZ21lbnRzICkge1xcblxcblxcdFxcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnQm94R2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHR3aWR0aDogd2lkdGgsXFxuXFx0XFx0XFx0aGVpZ2h0OiBoZWlnaHQsXFxuXFx0XFx0XFx0ZGVwdGg6IGRlcHRoLFxcblxcdFxcdFxcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXFxuXFx0XFx0XFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxcblxcdFxcdFxcdGRlcHRoU2VnbWVudHM6IGRlcHRoU2VnbWVudHNcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgQm94QnVmZmVyR2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgZGVwdGhTZWdtZW50cyApICk7XFxuXFx0XFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XFxuXFxuXFx0fVxcblxcblxcdEJveEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdEJveEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJveEdlb21ldHJ5O1xcblxcblxcdC8vIEJveEJ1ZmZlckdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gQm94QnVmZmVyR2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgZGVwdGhTZWdtZW50cyApIHtcXG5cXG5cXHRcXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0JveEJ1ZmZlckdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0d2lkdGg6IHdpZHRoLFxcblxcdFxcdFxcdGhlaWdodDogaGVpZ2h0LFxcblxcdFxcdFxcdGRlcHRoOiBkZXB0aCxcXG5cXHRcXHRcXHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxcblxcdFxcdFxcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcXG5cXHRcXHRcXHRkZXB0aFNlZ21lbnRzOiBkZXB0aFNlZ21lbnRzXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcblxcblxcdFxcdHdpZHRoID0gd2lkdGggfHwgMTtcXG5cXHRcXHRoZWlnaHQgPSBoZWlnaHQgfHwgMTtcXG5cXHRcXHRkZXB0aCA9IGRlcHRoIHx8IDE7XFxuXFxuXFx0XFx0Ly8gc2VnbWVudHNcXG5cXG5cXHRcXHR3aWR0aFNlZ21lbnRzID0gTWF0aC5mbG9vciggd2lkdGhTZWdtZW50cyApIHx8IDE7XFxuXFx0XFx0aGVpZ2h0U2VnbWVudHMgPSBNYXRoLmZsb29yKCBoZWlnaHRTZWdtZW50cyApIHx8IDE7XFxuXFx0XFx0ZGVwdGhTZWdtZW50cyA9IE1hdGguZmxvb3IoIGRlcHRoU2VnbWVudHMgKSB8fCAxO1xcblxcblxcdFxcdC8vIGJ1ZmZlcnNcXG5cXG5cXHRcXHR2YXIgaW5kaWNlcyA9IFtdO1xcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdO1xcblxcdFxcdHZhciBub3JtYWxzID0gW107XFxuXFx0XFx0dmFyIHV2cyA9IFtdO1xcblxcblxcdFxcdC8vIGhlbHBlciB2YXJpYWJsZXNcXG5cXG5cXHRcXHR2YXIgbnVtYmVyT2ZWZXJ0aWNlcyA9IDA7XFxuXFx0XFx0dmFyIGdyb3VwU3RhcnQgPSAwO1xcblxcblxcdFxcdC8vIGJ1aWxkIGVhY2ggc2lkZSBvZiB0aGUgYm94IGdlb21ldHJ5XFxuXFxuXFx0XFx0YnVpbGRQbGFuZSggJ3onLCAneScsICd4JywgLSAxLCAtIDEsIGRlcHRoLCBoZWlnaHQsIHdpZHRoLCBkZXB0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgMCApOyAvLyBweFxcblxcdFxcdGJ1aWxkUGxhbmUoICd6JywgJ3knLCAneCcsIDEsIC0gMSwgZGVwdGgsIGhlaWdodCwgLSB3aWR0aCwgZGVwdGhTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIDEgKTsgLy8gbnhcXG5cXHRcXHRidWlsZFBsYW5lKCAneCcsICd6JywgJ3knLCAxLCAxLCB3aWR0aCwgZGVwdGgsIGhlaWdodCwgd2lkdGhTZWdtZW50cywgZGVwdGhTZWdtZW50cywgMiApOyAvLyBweVxcblxcdFxcdGJ1aWxkUGxhbmUoICd4JywgJ3onLCAneScsIDEsIC0gMSwgd2lkdGgsIGRlcHRoLCAtIGhlaWdodCwgd2lkdGhTZWdtZW50cywgZGVwdGhTZWdtZW50cywgMyApOyAvLyBueVxcblxcdFxcdGJ1aWxkUGxhbmUoICd4JywgJ3knLCAneicsIDEsIC0gMSwgd2lkdGgsIGhlaWdodCwgZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCA0ICk7IC8vIHB6XFxuXFx0XFx0YnVpbGRQbGFuZSggJ3gnLCAneScsICd6JywgLSAxLCAtIDEsIHdpZHRoLCBoZWlnaHQsIC0gZGVwdGgsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCA1ICk7IC8vIG56XFxuXFxuXFx0XFx0Ly8gYnVpbGQgZ2VvbWV0cnlcXG5cXG5cXHRcXHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xcblxcblxcdFxcdGZ1bmN0aW9uIGJ1aWxkUGxhbmUoIHUsIHYsIHcsIHVkaXIsIHZkaXIsIHdpZHRoLCBoZWlnaHQsIGRlcHRoLCBncmlkWCwgZ3JpZFksIG1hdGVyaWFsSW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHNlZ21lbnRXaWR0aCA9IHdpZHRoIC8gZ3JpZFg7XFxuXFx0XFx0XFx0dmFyIHNlZ21lbnRIZWlnaHQgPSBoZWlnaHQgLyBncmlkWTtcXG5cXG5cXHRcXHRcXHR2YXIgd2lkdGhIYWxmID0gd2lkdGggLyAyO1xcblxcdFxcdFxcdHZhciBoZWlnaHRIYWxmID0gaGVpZ2h0IC8gMjtcXG5cXHRcXHRcXHR2YXIgZGVwdGhIYWxmID0gZGVwdGggLyAyO1xcblxcblxcdFxcdFxcdHZhciBncmlkWDEgPSBncmlkWCArIDE7XFxuXFx0XFx0XFx0dmFyIGdyaWRZMSA9IGdyaWRZICsgMTtcXG5cXG5cXHRcXHRcXHR2YXIgdmVydGV4Q291bnRlciA9IDA7XFxuXFx0XFx0XFx0dmFyIGdyb3VwQ291bnQgPSAwO1xcblxcblxcdFxcdFxcdHZhciBpeCwgaXk7XFxuXFxuXFx0XFx0XFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xcblxcblxcdFxcdFxcdGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5ICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB5ID0gaXkgKiBzZWdtZW50SGVpZ2h0IC0gaGVpZ2h0SGFsZjtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFgxOyBpeCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgeCA9IGl4ICogc2VnbWVudFdpZHRoIC0gd2lkdGhIYWxmO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHNldCB2YWx1ZXMgdG8gY29ycmVjdCB2ZWN0b3IgY29tcG9uZW50XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVjdG9yWyB1IF0gPSB4ICogdWRpcjtcXG5cXHRcXHRcXHRcXHRcXHR2ZWN0b3JbIHYgXSA9IHkgKiB2ZGlyO1xcblxcdFxcdFxcdFxcdFxcdHZlY3RvclsgdyBdID0gZGVwdGhIYWxmO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIG5vdyBhcHBseSB2ZWN0b3IgdG8gdmVydGV4IGJ1ZmZlclxcblxcblxcdFxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnogKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBzZXQgdmFsdWVzIHRvIGNvcnJlY3QgdmVjdG9yIGNvbXBvbmVudFxcblxcblxcdFxcdFxcdFxcdFxcdHZlY3RvclsgdSBdID0gMDtcXG5cXHRcXHRcXHRcXHRcXHR2ZWN0b3JbIHYgXSA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0dmVjdG9yWyB3IF0gPSBkZXB0aCA+IDAgPyAxIDogLSAxO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIG5vdyBhcHBseSB2ZWN0b3IgdG8gbm9ybWFsIGJ1ZmZlclxcblxcblxcdFxcdFxcdFxcdFxcdG5vcm1hbHMucHVzaCggdmVjdG9yLngsIHZlY3Rvci55LCB2ZWN0b3IueiApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHV2c1xcblxcblxcdFxcdFxcdFxcdFxcdHV2cy5wdXNoKCBpeCAvIGdyaWRYICk7XFxuXFx0XFx0XFx0XFx0XFx0dXZzLnB1c2goIDEgLSAoIGl5IC8gZ3JpZFkgKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGNvdW50ZXJzXFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4Q291bnRlciArPSAxO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gaW5kaWNlc1xcblxcblxcdFxcdFxcdC8vIDEuIHlvdSBuZWVkIHRocmVlIGluZGljZXMgdG8gZHJhdyBhIHNpbmdsZSBmYWNlXFxuXFx0XFx0XFx0Ly8gMi4gYSBzaW5nbGUgc2VnbWVudCBjb25zaXN0cyBvZiB0d28gZmFjZXNcXG5cXHRcXHRcXHQvLyAzLiBzbyB3ZSBuZWVkIHRvIGdlbmVyYXRlIHNpeCAoMiozKSBpbmRpY2VzIHBlciBzZWdtZW50XFxuXFxuXFx0XFx0XFx0Zm9yICggaXkgPSAwOyBpeSA8IGdyaWRZOyBpeSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBpeCA9IDA7IGl4IDwgZ3JpZFg7IGl4ICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBhID0gbnVtYmVyT2ZWZXJ0aWNlcyArIGl4ICsgZ3JpZFgxICogaXk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGIgPSBudW1iZXJPZlZlcnRpY2VzICsgaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xcblxcdFxcdFxcdFxcdFxcdHZhciBjID0gbnVtYmVyT2ZWZXJ0aWNlcyArICggaXggKyAxICkgKyBncmlkWDEgKiAoIGl5ICsgMSApO1xcblxcdFxcdFxcdFxcdFxcdHZhciBkID0gbnVtYmVyT2ZWZXJ0aWNlcyArICggaXggKyAxICkgKyBncmlkWDEgKiBpeTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBmYWNlc1xcblxcblxcdFxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xcblxcdFxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGluY3JlYXNlIGNvdW50ZXJcXG5cXG5cXHRcXHRcXHRcXHRcXHRncm91cENvdW50ICs9IDY7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBhZGQgYSBncm91cCB0byB0aGUgZ2VvbWV0cnkuIHRoaXMgd2lsbCBlbnN1cmUgbXVsdGkgbWF0ZXJpYWwgc3VwcG9ydFxcblxcblxcdFxcdFxcdHNjb3BlLmFkZEdyb3VwKCBncm91cFN0YXJ0LCBncm91cENvdW50LCBtYXRlcmlhbEluZGV4ICk7XFxuXFxuXFx0XFx0XFx0Ly8gY2FsY3VsYXRlIG5ldyBzdGFydCB2YWx1ZSBmb3IgZ3JvdXBzXFxuXFxuXFx0XFx0XFx0Z3JvdXBTdGFydCArPSBncm91cENvdW50O1xcblxcblxcdFxcdFxcdC8vIHVwZGF0ZSB0b3RhbCBudW1iZXIgb2YgdmVydGljZXNcXG5cXG5cXHRcXHRcXHRudW1iZXJPZlZlcnRpY2VzICs9IHZlcnRleENvdW50ZXI7XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHRCb3hCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRCb3hCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBCb3hCdWZmZXJHZW9tZXRyeTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxuXFx0ICovXFxuXFxuXFx0Ly8gUGxhbmVHZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIFBsYW5lR2VvbWV0cnkoIHdpZHRoLCBoZWlnaHQsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzICkge1xcblxcblxcdFxcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnUGxhbmVHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHdpZHRoOiB3aWR0aCxcXG5cXHRcXHRcXHRoZWlnaHQ6IGhlaWdodCxcXG5cXHRcXHRcXHR3aWR0aFNlZ21lbnRzOiB3aWR0aFNlZ21lbnRzLFxcblxcdFxcdFxcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50c1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBQbGFuZUJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApICk7XFxuXFx0XFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XFxuXFxuXFx0fVxcblxcblxcdFBsYW5lR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0UGxhbmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQbGFuZUdlb21ldHJ5O1xcblxcblxcdC8vIFBsYW5lQnVmZmVyR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBQbGFuZUJ1ZmZlckdlb21ldHJ5KCB3aWR0aCwgaGVpZ2h0LCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cyApIHtcXG5cXG5cXHRcXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1BsYW5lQnVmZmVyR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHR3aWR0aDogd2lkdGgsXFxuXFx0XFx0XFx0aGVpZ2h0OiBoZWlnaHQsXFxuXFx0XFx0XFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcXG5cXHRcXHRcXHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHNcXG5cXHRcXHR9O1xcblxcblxcdFxcdHdpZHRoID0gd2lkdGggfHwgMTtcXG5cXHRcXHRoZWlnaHQgPSBoZWlnaHQgfHwgMTtcXG5cXG5cXHRcXHR2YXIgd2lkdGhfaGFsZiA9IHdpZHRoIC8gMjtcXG5cXHRcXHR2YXIgaGVpZ2h0X2hhbGYgPSBoZWlnaHQgLyAyO1xcblxcblxcdFxcdHZhciBncmlkWCA9IE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSB8fCAxO1xcblxcdFxcdHZhciBncmlkWSA9IE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgfHwgMTtcXG5cXG5cXHRcXHR2YXIgZ3JpZFgxID0gZ3JpZFggKyAxO1xcblxcdFxcdHZhciBncmlkWTEgPSBncmlkWSArIDE7XFxuXFxuXFx0XFx0dmFyIHNlZ21lbnRfd2lkdGggPSB3aWR0aCAvIGdyaWRYO1xcblxcdFxcdHZhciBzZWdtZW50X2hlaWdodCA9IGhlaWdodCAvIGdyaWRZO1xcblxcblxcdFxcdHZhciBpeCwgaXk7XFxuXFxuXFx0XFx0Ly8gYnVmZmVyc1xcblxcblxcdFxcdHZhciBpbmRpY2VzID0gW107XFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW107XFxuXFx0XFx0dmFyIG5vcm1hbHMgPSBbXTtcXG5cXHRcXHR2YXIgdXZzID0gW107XFxuXFxuXFx0XFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xcblxcblxcdFxcdGZvciAoIGl5ID0gMDsgaXkgPCBncmlkWTE7IGl5ICsrICkge1xcblxcblxcdFxcdFxcdHZhciB5ID0gaXkgKiBzZWdtZW50X2hlaWdodCAtIGhlaWdodF9oYWxmO1xcblxcblxcdFxcdFxcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDE7IGl4ICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB4ID0gaXggKiBzZWdtZW50X3dpZHRoIC0gd2lkdGhfaGFsZjtcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB4LCAtIHksIDAgKTtcXG5cXG5cXHRcXHRcXHRcXHRub3JtYWxzLnB1c2goIDAsIDAsIDEgKTtcXG5cXG5cXHRcXHRcXHRcXHR1dnMucHVzaCggaXggLyBncmlkWCApO1xcblxcdFxcdFxcdFxcdHV2cy5wdXNoKCAxIC0gKCBpeSAvIGdyaWRZICkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGluZGljZXNcXG5cXG5cXHRcXHRmb3IgKCBpeSA9IDA7IGl5IDwgZ3JpZFk7IGl5ICsrICkge1xcblxcblxcdFxcdFxcdGZvciAoIGl4ID0gMDsgaXggPCBncmlkWDsgaXggKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGEgPSBpeCArIGdyaWRYMSAqIGl5O1xcblxcdFxcdFxcdFxcdHZhciBiID0gaXggKyBncmlkWDEgKiAoIGl5ICsgMSApO1xcblxcdFxcdFxcdFxcdHZhciBjID0gKCBpeCArIDEgKSArIGdyaWRYMSAqICggaXkgKyAxICk7XFxuXFx0XFx0XFx0XFx0dmFyIGQgPSAoIGl4ICsgMSApICsgZ3JpZFgxICogaXk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gZmFjZXNcXG5cXG5cXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcXG5cXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGJ1aWxkIGdlb21ldHJ5XFxuXFxuXFx0XFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcXG5cXG5cXHR9XFxuXFxuXFx0UGxhbmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRQbGFuZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsYW5lQnVmZmVyR2VvbWV0cnk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqXFxuXFx0ICogcGFyYW1ldGVycyA9IHtcXG5cXHQgKiAgY29sb3I6IDxoZXg+LFxcblxcdCAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxcblxcdCAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICpcXG5cXHQgKiAgbGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XFxuXFx0ICpcXG5cXHQgKiAgYW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XFxuXFx0ICpcXG5cXHQgKiAgc3BlY3VsYXJNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICpcXG5cXHQgKiAgYWxwaGFNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICpcXG5cXHQgKiAgZW52TWFwOiBuZXcgVEhSRUUuVGV4dHVyZUN1YmUoIFtwb3N4LCBuZWd4LCBwb3N5LCBuZWd5LCBwb3N6LCBuZWd6XSApLFxcblxcdCAqICBjb21iaW5lOiBUSFJFRS5NdWx0aXBseSxcXG5cXHQgKiAgcmVmbGVjdGl2aXR5OiA8ZmxvYXQ+LFxcblxcdCAqICByZWZyYWN0aW9uUmF0aW86IDxmbG9hdD4sXFxuXFx0ICpcXG5cXHQgKiAgZGVwdGhUZXN0OiA8Ym9vbD4sXFxuXFx0ICogIGRlcHRoV3JpdGU6IDxib29sPixcXG5cXHQgKlxcblxcdCAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcXG5cXHQgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxcblxcdCAqXFxuXFx0ICogIHNraW5uaW5nOiA8Ym9vbD4sXFxuXFx0ICogIG1vcnBoVGFyZ2V0czogPGJvb2w+XFxuXFx0ICogfVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIE1lc2hCYXNpY01hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xcblxcblxcdFxcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGVtaXNzaXZlXFxuXFxuXFx0XFx0dGhpcy5tYXAgPSBudWxsO1xcblxcblxcdFxcdHRoaXMubGlnaHRNYXAgPSBudWxsO1xcblxcdFxcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XFxuXFxuXFx0XFx0dGhpcy5hb01hcCA9IG51bGw7XFxuXFx0XFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcXG5cXG5cXHRcXHR0aGlzLnNwZWN1bGFyTWFwID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLmFscGhhTWFwID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLmVudk1hcCA9IG51bGw7XFxuXFx0XFx0dGhpcy5jb21iaW5lID0gTXVsdGlwbHlPcGVyYXRpb247XFxuXFx0XFx0dGhpcy5yZWZsZWN0aXZpdHkgPSAxO1xcblxcdFxcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gMC45ODtcXG5cXG5cXHRcXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSAncm91bmQnO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSAncm91bmQnO1xcblxcblxcdFxcdHRoaXMuc2tpbm5pbmcgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMubGlnaHRzID0gZmFsc2U7XFxuXFxuXFx0XFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcXG5cXG5cXHR9XFxuXFxuXFx0TWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XFxuXFx0TWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaEJhc2ljTWF0ZXJpYWw7XFxuXFxuXFx0TWVzaEJhc2ljTWF0ZXJpYWwucHJvdG90eXBlLmlzTWVzaEJhc2ljTWF0ZXJpYWwgPSB0cnVlO1xcblxcblxcdE1lc2hCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcXG5cXG5cXHRcXHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XFxuXFxuXFx0XFx0dGhpcy5saWdodE1hcCA9IHNvdXJjZS5saWdodE1hcDtcXG5cXHRcXHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gc291cmNlLmxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcblxcdFxcdHRoaXMuYW9NYXAgPSBzb3VyY2UuYW9NYXA7XFxuXFx0XFx0dGhpcy5hb01hcEludGVuc2l0eSA9IHNvdXJjZS5hb01hcEludGVuc2l0eTtcXG5cXG5cXHRcXHR0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xcblxcblxcdFxcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XFxuXFxuXFx0XFx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xcblxcdFxcdHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xcblxcdFxcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcXG5cXHRcXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XFxuXFxuXFx0XFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xcblxcblxcdFxcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XFxuXFx0XFx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKlxcblxcdCAqIHBhcmFtZXRlcnMgPSB7XFxuXFx0ICogIGRlZmluZXM6IHsgXFxcImxhYmVsXFxcIiA6IFxcXCJ2YWx1ZVxcXCIgfSxcXG5cXHQgKiAgdW5pZm9ybXM6IHsgXFxcInBhcmFtZXRlcjFcXFwiOiB7IHZhbHVlOiAxLjAgfSwgXFxcInBhcmFtZXRlcjJcXFwiOiB7IHZhbHVlMjogMiB9IH0sXFxuXFx0ICpcXG5cXHQgKiAgZnJhZ21lbnRTaGFkZXI6IDxzdHJpbmc+LFxcblxcdCAqICB2ZXJ0ZXhTaGFkZXI6IDxzdHJpbmc+LFxcblxcdCAqXFxuXFx0ICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxcblxcdCAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXFxuXFx0ICpcXG5cXHQgKiAgbGlnaHRzOiA8Ym9vbD4sXFxuXFx0ICpcXG5cXHQgKiAgc2tpbm5pbmc6IDxib29sPixcXG5cXHQgKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXFxuXFx0ICogIG1vcnBoTm9ybWFsczogPGJvb2w+XFxuXFx0ICogfVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFNoYWRlck1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnU2hhZGVyTWF0ZXJpYWwnO1xcblxcblxcdFxcdHRoaXMuZGVmaW5lcyA9IHt9O1xcblxcdFxcdHRoaXMudW5pZm9ybXMgPSB7fTtcXG5cXG5cXHRcXHR0aGlzLnZlcnRleFNoYWRlciA9ICd2b2lkIG1haW4oKSB7XFxcXG5cXFxcdGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIG1vZGVsVmlld01hdHJpeCAqIHZlYzQoIHBvc2l0aW9uLCAxLjAgKTtcXFxcbn0nO1xcblxcdFxcdHRoaXMuZnJhZ21lbnRTaGFkZXIgPSAndm9pZCBtYWluKCkge1xcXFxuXFxcXHRnbF9GcmFnQ29sb3IgPSB2ZWM0KCAxLjAsIDAuMCwgMC4wLCAxLjAgKTtcXFxcbn0nO1xcblxcblxcdFxcdHRoaXMubGluZXdpZHRoID0gMTtcXG5cXG5cXHRcXHR0aGlzLndpcmVmcmFtZSA9IGZhbHNlO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gMTtcXG5cXG5cXHRcXHR0aGlzLmZvZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHNjZW5lIGZvZ1xcblxcdFxcdHRoaXMubGlnaHRzID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2NlbmUgbGlnaHRzXFxuXFx0XFx0dGhpcy5jbGlwcGluZyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIHVzZXItZGVmaW5lZCBjbGlwcGluZyBwbGFuZXNcXG5cXG5cXHRcXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7IC8vIHNldCB0byB1c2Ugc2tpbm5pbmcgYXR0cmlidXRlIHN0cmVhbXNcXG5cXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIG1vcnBoIHRhcmdldHNcXG5cXHRcXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlOyAvLyBzZXQgdG8gdXNlIG1vcnBoIG5vcm1hbHNcXG5cXG5cXHRcXHR0aGlzLmV4dGVuc2lvbnMgPSB7XFxuXFx0XFx0XFx0ZGVyaXZhdGl2ZXM6IGZhbHNlLCAvLyBzZXQgdG8gdXNlIGRlcml2YXRpdmVzXFxuXFx0XFx0XFx0ZnJhZ0RlcHRoOiBmYWxzZSwgLy8gc2V0IHRvIHVzZSBmcmFnbWVudCBkZXB0aCB2YWx1ZXNcXG5cXHRcXHRcXHRkcmF3QnVmZmVyczogZmFsc2UsIC8vIHNldCB0byB1c2UgZHJhdyBidWZmZXJzXFxuXFx0XFx0XFx0c2hhZGVyVGV4dHVyZUxPRDogZmFsc2UgLy8gc2V0IHRvIHVzZSBzaGFkZXIgdGV4dHVyZSBMT0RcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIFdoZW4gcmVuZGVyZWQgZ2VvbWV0cnkgZG9lc24ndCBpbmNsdWRlIHRoZXNlIGF0dHJpYnV0ZXMgYnV0IHRoZSBtYXRlcmlhbCBkb2VzLFxcblxcdFxcdC8vIHVzZSB0aGVzZSBkZWZhdWx0IHZhbHVlcyBpbiBXZWJHTC4gVGhpcyBhdm9pZHMgZXJyb3JzIHdoZW4gYnVmZmVyIGRhdGEgaXMgbWlzc2luZy5cXG5cXHRcXHR0aGlzLmRlZmF1bHRBdHRyaWJ1dGVWYWx1ZXMgPSB7XFxuXFx0XFx0XFx0J2NvbG9yJzogWyAxLCAxLCAxIF0sXFxuXFx0XFx0XFx0J3V2JzogWyAwLCAwIF0sXFxuXFx0XFx0XFx0J3V2Mic6IFsgMCwgMCBdXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLmluZGV4MEF0dHJpYnV0ZU5hbWUgPSB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0aWYgKCBwYXJhbWV0ZXJzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBwYXJhbWV0ZXJzLmF0dHJpYnV0ZXMgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuU2hhZGVyTWF0ZXJpYWw6IGF0dHJpYnV0ZXMgc2hvdWxkIG5vdyBiZSBkZWZpbmVkIGluIFRIUkVFLkJ1ZmZlckdlb21ldHJ5IGluc3RlYWQuJyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XFxuXFx0U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhZGVyTWF0ZXJpYWw7XFxuXFxuXFx0U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmlzU2hhZGVyTWF0ZXJpYWwgPSB0cnVlO1xcblxcblxcdFNoYWRlck1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0dGhpcy5mcmFnbWVudFNoYWRlciA9IHNvdXJjZS5mcmFnbWVudFNoYWRlcjtcXG5cXHRcXHR0aGlzLnZlcnRleFNoYWRlciA9IHNvdXJjZS52ZXJ0ZXhTaGFkZXI7XFxuXFxuXFx0XFx0dGhpcy51bmlmb3JtcyA9IFVuaWZvcm1zVXRpbHMuY2xvbmUoIHNvdXJjZS51bmlmb3JtcyApO1xcblxcblxcdFxcdHRoaXMuZGVmaW5lcyA9IHNvdXJjZS5kZWZpbmVzO1xcblxcblxcdFxcdHRoaXMud2lyZWZyYW1lID0gc291cmNlLndpcmVmcmFtZTtcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IHNvdXJjZS53aXJlZnJhbWVMaW5ld2lkdGg7XFxuXFxuXFx0XFx0dGhpcy5saWdodHMgPSBzb3VyY2UubGlnaHRzO1xcblxcdFxcdHRoaXMuY2xpcHBpbmcgPSBzb3VyY2UuY2xpcHBpbmc7XFxuXFxuXFx0XFx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcXG5cXG5cXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XFxuXFx0XFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xcblxcblxcdFxcdHRoaXMuZXh0ZW5zaW9ucyA9IHNvdXJjZS5leHRlbnNpb25zO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFx0U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICggbWV0YSApIHtcXG5cXG5cXHRcXHR2YXIgZGF0YSA9IE1hdGVyaWFsLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xcblxcblxcdFxcdGRhdGEudW5pZm9ybXMgPSB0aGlzLnVuaWZvcm1zO1xcblxcdFxcdGRhdGEudmVydGV4U2hhZGVyID0gdGhpcy52ZXJ0ZXhTaGFkZXI7XFxuXFx0XFx0ZGF0YS5mcmFnbWVudFNoYWRlciA9IHRoaXMuZnJhZ21lbnRTaGFkZXI7XFxuXFxuXFx0XFx0cmV0dXJuIGRhdGE7XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gUmF5KCBvcmlnaW4sIGRpcmVjdGlvbiApIHtcXG5cXG5cXHRcXHR0aGlzLm9yaWdpbiA9ICggb3JpZ2luICE9PSB1bmRlZmluZWQgKSA/IG9yaWdpbiA6IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dGhpcy5kaXJlY3Rpb24gPSAoIGRpcmVjdGlvbiAhPT0gdW5kZWZpbmVkICkgPyBkaXJlY3Rpb24gOiBuZXcgVmVjdG9yMygpO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBSYXkucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIG9yaWdpbiwgZGlyZWN0aW9uICkge1xcblxcblxcdFxcdFxcdHRoaXMub3JpZ2luLmNvcHkoIG9yaWdpbiApO1xcblxcdFxcdFxcdHRoaXMuZGlyZWN0aW9uLmNvcHkoIGRpcmVjdGlvbiApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHJheSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm9yaWdpbi5jb3B5KCByYXkub3JpZ2luICk7XFxuXFx0XFx0XFx0dGhpcy5kaXJlY3Rpb24uY29weSggcmF5LmRpcmVjdGlvbiApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YXQ6IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLmRpcmVjdGlvbiApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLm9yaWdpbiApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bG9va0F0OiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5kaXJlY3Rpb24uY29weSggdiApLnN1YiggdGhpcy5vcmlnaW4gKS5ub3JtYWxpemUoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHJlY2FzdDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHJlY2FzdCggdCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLm9yaWdpbi5jb3B5KCB0aGlzLmF0KCB0LCB2MSApICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0Y2xvc2VzdFBvaW50VG9Qb2ludDogZnVuY3Rpb24gKCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0cmVzdWx0LnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApO1xcblxcdFxcdFxcdHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IHJlc3VsdC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBkaXJlY3Rpb25EaXN0YW5jZSA8IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5jb3B5KCB0aGlzLm9yaWdpbiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIGRpcmVjdGlvbkRpc3RhbmNlICkuYWRkKCB0aGlzLm9yaWdpbiApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGlzdGFuY2VUb1BvaW50OiBmdW5jdGlvbiAoIHBvaW50ICkge1xcblxcblxcdFxcdFxcdHJldHVybiBNYXRoLnNxcnQoIHRoaXMuZGlzdGFuY2VTcVRvUG9pbnQoIHBvaW50ICkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGRpc3RhbmNlU3FUb1BvaW50OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VTcVRvUG9pbnQoIHBvaW50ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBkaXJlY3Rpb25EaXN0YW5jZSA9IHYxLnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLm9yaWdpbiApLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBwb2ludCBiZWhpbmQgdGhlIHJheVxcblxcblxcdFxcdFxcdFxcdGlmICggZGlyZWN0aW9uRGlzdGFuY2UgPCAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLm9yaWdpbi5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0djEuY29weSggdGhpcy5kaXJlY3Rpb24gKS5tdWx0aXBseVNjYWxhciggZGlyZWN0aW9uRGlzdGFuY2UgKS5hZGQoIHRoaXMub3JpZ2luICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHYxLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGRpc3RhbmNlU3FUb1NlZ21lbnQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgc2VnQ2VudGVyID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgc2VnRGlyID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgZGlmZiA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlU3FUb1NlZ21lbnQoIHYwLCB2MSwgb3B0aW9uYWxQb2ludE9uUmF5LCBvcHRpb25hbFBvaW50T25TZWdtZW50ICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vR1RFbmdpbmUvSW5jbHVkZS9NYXRoZW1hdGljcy9HdGVEaXN0UmF5U2VnbWVudC5oXFxuXFx0XFx0XFx0XFx0Ly8gSXQgcmV0dXJucyB0aGUgbWluIGRpc3RhbmNlIGJldHdlZW4gdGhlIHJheSBhbmQgdGhlIHNlZ21lbnRcXG5cXHRcXHRcXHRcXHQvLyBkZWZpbmVkIGJ5IHYwIGFuZCB2MVxcblxcdFxcdFxcdFxcdC8vIEl0IGNhbiBhbHNvIHNldCB0d28gb3B0aW9uYWwgdGFyZ2V0cyA6XFxuXFx0XFx0XFx0XFx0Ly8gLSBUaGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgcmF5XFxuXFx0XFx0XFx0XFx0Ly8gLSBUaGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgc2VnbWVudFxcblxcblxcdFxcdFxcdFxcdHNlZ0NlbnRlci5jb3B5KCB2MCApLmFkZCggdjEgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XFxuXFx0XFx0XFx0XFx0c2VnRGlyLmNvcHkoIHYxICkuc3ViKCB2MCApLm5vcm1hbGl6ZSgpO1xcblxcdFxcdFxcdFxcdGRpZmYuY29weSggdGhpcy5vcmlnaW4gKS5zdWIoIHNlZ0NlbnRlciApO1xcblxcblxcdFxcdFxcdFxcdHZhciBzZWdFeHRlbnQgPSB2MC5kaXN0YW5jZVRvKCB2MSApICogMC41O1xcblxcdFxcdFxcdFxcdHZhciBhMDEgPSAtIHRoaXMuZGlyZWN0aW9uLmRvdCggc2VnRGlyICk7XFxuXFx0XFx0XFx0XFx0dmFyIGIwID0gZGlmZi5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XFxuXFx0XFx0XFx0XFx0dmFyIGIxID0gLSBkaWZmLmRvdCggc2VnRGlyICk7XFxuXFx0XFx0XFx0XFx0dmFyIGMgPSBkaWZmLmxlbmd0aFNxKCk7XFxuXFx0XFx0XFx0XFx0dmFyIGRldCA9IE1hdGguYWJzKCAxIC0gYTAxICogYTAxICk7XFxuXFx0XFx0XFx0XFx0dmFyIHMwLCBzMSwgc3FyRGlzdCwgZXh0RGV0O1xcblxcblxcdFxcdFxcdFxcdGlmICggZGV0ID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBUaGUgcmF5IGFuZCBzZWdtZW50IGFyZSBub3QgcGFyYWxsZWwuXFxuXFxuXFx0XFx0XFx0XFx0XFx0czAgPSBhMDEgKiBiMSAtIGIwO1xcblxcdFxcdFxcdFxcdFxcdHMxID0gYTAxICogYjAgLSBiMTtcXG5cXHRcXHRcXHRcXHRcXHRleHREZXQgPSBzZWdFeHRlbnQgKiBkZXQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBzMCA+PSAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggczEgPj0gLSBleHREZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBzMSA8PSBleHREZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gcmVnaW9uIDBcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBNaW5pbXVtIGF0IGludGVyaW9yIHBvaW50cyBvZiByYXkgYW5kIHNlZ21lbnQuXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGludkRldCA9IDEgLyBkZXQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0czAgKj0gaW52RGV0O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHMxICo9IGludkRldDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzcXJEaXN0ID0gczAgKiAoIHMwICsgYTAxICogczEgKyAyICogYjAgKSArIHMxICogKCBhMDEgKiBzMCArIHMxICsgMiAqIGIxICkgKyBjO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gcmVnaW9uIDFcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzMSA9IHNlZ0V4dGVudDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyByZWdpb24gNVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMxID0gLSBzZWdFeHRlbnQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0czAgPSBNYXRoLm1heCggMCwgLSAoIGEwMSAqIHMxICsgYjAgKSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNxckRpc3QgPSAtIHMwICogczAgKyBzMSAqICggczEgKyAyICogYjEgKSArIGM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBzMSA8PSAtIGV4dERldCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyByZWdpb24gNFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCAtIGEwMSAqIHNlZ0V4dGVudCArIGIwICkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzMSA9ICggczAgPiAwICkgPyAtIHNlZ0V4dGVudCA6IE1hdGgubWluKCBNYXRoLm1heCggLSBzZWdFeHRlbnQsIC0gYjEgKSwgc2VnRXh0ZW50ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBzMSA8PSBleHREZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gcmVnaW9uIDNcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzMCA9IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0czEgPSBNYXRoLm1pbiggTWF0aC5tYXgoIC0gc2VnRXh0ZW50LCAtIGIxICksIHNlZ0V4dGVudCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNxckRpc3QgPSBzMSAqICggczEgKyAyICogYjEgKSArIGM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyByZWdpb24gMlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHMwID0gTWF0aC5tYXgoIDAsIC0gKCBhMDEgKiBzZWdFeHRlbnQgKyBiMCApICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0czEgPSAoIHMwID4gMCApID8gc2VnRXh0ZW50IDogTWF0aC5taW4oIE1hdGgubWF4KCAtIHNlZ0V4dGVudCwgLSBiMSApLCBzZWdFeHRlbnQgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzcXJEaXN0ID0gLSBzMCAqIHMwICsgczEgKiAoIHMxICsgMiAqIGIxICkgKyBjO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBSYXkgYW5kIHNlZ21lbnQgYXJlIHBhcmFsbGVsLlxcblxcblxcdFxcdFxcdFxcdFxcdHMxID0gKCBhMDEgPiAwICkgPyAtIHNlZ0V4dGVudCA6IHNlZ0V4dGVudDtcXG5cXHRcXHRcXHRcXHRcXHRzMCA9IE1hdGgubWF4KCAwLCAtICggYTAxICogczEgKyBiMCApICk7XFxuXFx0XFx0XFx0XFx0XFx0c3FyRGlzdCA9IC0gczAgKiBzMCArIHMxICogKCBzMSArIDIgKiBiMSApICsgYztcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBvcHRpb25hbFBvaW50T25SYXkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0b3B0aW9uYWxQb2ludE9uUmF5LmNvcHkoIHRoaXMuZGlyZWN0aW9uICkubXVsdGlwbHlTY2FsYXIoIHMwICkuYWRkKCB0aGlzLm9yaWdpbiApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG9wdGlvbmFsUG9pbnRPblNlZ21lbnQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0b3B0aW9uYWxQb2ludE9uU2VnbWVudC5jb3B5KCBzZWdEaXIgKS5tdWx0aXBseVNjYWxhciggczEgKS5hZGQoIHNlZ0NlbnRlciApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gc3FyRGlzdDtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRpbnRlcnNlY3RTcGhlcmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RTcGhlcmUoIHNwaGVyZSwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0djEuc3ViVmVjdG9ycyggc3BoZXJlLmNlbnRlciwgdGhpcy5vcmlnaW4gKTtcXG5cXHRcXHRcXHRcXHR2YXIgdGNhID0gdjEuZG90KCB0aGlzLmRpcmVjdGlvbiApO1xcblxcdFxcdFxcdFxcdHZhciBkMiA9IHYxLmRvdCggdjEgKSAtIHRjYSAqIHRjYTtcXG5cXHRcXHRcXHRcXHR2YXIgcmFkaXVzMiA9IHNwaGVyZS5yYWRpdXMgKiBzcGhlcmUucmFkaXVzO1xcblxcblxcdFxcdFxcdFxcdGlmICggZDIgPiByYWRpdXMyICkgcmV0dXJuIG51bGw7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHRoYyA9IE1hdGguc3FydCggcmFkaXVzMiAtIGQyICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdDAgPSBmaXJzdCBpbnRlcnNlY3QgcG9pbnQgLSBlbnRyYW5jZSBvbiBmcm9udCBvZiBzcGhlcmVcXG5cXHRcXHRcXHRcXHR2YXIgdDAgPSB0Y2EgLSB0aGM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdDEgPSBzZWNvbmQgaW50ZXJzZWN0IHBvaW50IC0gZXhpdCBwb2ludCBvbiBiYWNrIG9mIHNwaGVyZVxcblxcdFxcdFxcdFxcdHZhciB0MSA9IHRjYSArIHRoYztcXG5cXG5cXHRcXHRcXHRcXHQvLyB0ZXN0IHRvIHNlZSBpZiBib3RoIHQwIGFuZCB0MSBhcmUgYmVoaW5kIHRoZSByYXkgLSBpZiBzbywgcmV0dXJuIG51bGxcXG5cXHRcXHRcXHRcXHRpZiAoIHQwIDwgMCAmJiB0MSA8IDAgKSByZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHQvLyB0ZXN0IHRvIHNlZSBpZiB0MCBpcyBiZWhpbmQgdGhlIHJheTpcXG5cXHRcXHRcXHRcXHQvLyBpZiBpdCBpcywgdGhlIHJheSBpcyBpbnNpZGUgdGhlIHNwaGVyZSwgc28gcmV0dXJuIHRoZSBzZWNvbmQgZXhpdCBwb2ludCBzY2FsZWQgYnkgdDEsXFxuXFx0XFx0XFx0XFx0Ly8gaW4gb3JkZXIgdG8gYWx3YXlzIHJldHVybiBhbiBpbnRlcnNlY3QgcG9pbnQgdGhhdCBpcyBpbiBmcm9udCBvZiB0aGUgcmF5LlxcblxcdFxcdFxcdFxcdGlmICggdDAgPCAwICkgcmV0dXJuIHRoaXMuYXQoIHQxLCBvcHRpb25hbFRhcmdldCApO1xcblxcblxcdFxcdFxcdFxcdC8vIGVsc2UgdDAgaXMgaW4gZnJvbnQgb2YgdGhlIHJheSwgc28gcmV0dXJuIHRoZSBmaXJzdCBjb2xsaXNpb24gcG9pbnQgc2NhbGVkIGJ5IHQwXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuYXQoIHQwLCBvcHRpb25hbFRhcmdldCApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGludGVyc2VjdHNTcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmRpc3RhbmNlVG9Qb2ludCggc3BoZXJlLmNlbnRlciApIDw9IHNwaGVyZS5yYWRpdXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXN0YW5jZVRvUGxhbmU6IGZ1bmN0aW9uICggcGxhbmUgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGRlbm9taW5hdG9yID0gcGxhbmUubm9ybWFsLmRvdCggdGhpcy5kaXJlY3Rpb24gKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGRlbm9taW5hdG9yID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGxpbmUgaXMgY29wbGFuYXIsIHJldHVybiBvcmlnaW5cXG5cXHRcXHRcXHRcXHRpZiAoIHBsYW5lLmRpc3RhbmNlVG9Qb2ludCggdGhpcy5vcmlnaW4gKSA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gMDtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTnVsbCBpcyBwcmVmZXJhYmxlIHRvIHVuZGVmaW5lZCBzaW5jZSB1bmRlZmluZWQgbWVhbnMuLi4uIGl0IGlzIHVuZGVmaW5lZFxcblxcblxcdFxcdFxcdFxcdHJldHVybiBudWxsO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgdCA9IC0gKCB0aGlzLm9yaWdpbi5kb3QoIHBsYW5lLm5vcm1hbCApICsgcGxhbmUuY29uc3RhbnQgKSAvIGRlbm9taW5hdG9yO1xcblxcblxcdFxcdFxcdC8vIFJldHVybiBpZiB0aGUgcmF5IG5ldmVyIGludGVyc2VjdHMgdGhlIHBsYW5lXFxuXFxuXFx0XFx0XFx0cmV0dXJuIHQgPj0gMCA/IHQgOiBudWxsO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0aW50ZXJzZWN0UGxhbmU6IGZ1bmN0aW9uICggcGxhbmUsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHZhciB0ID0gdGhpcy5kaXN0YW5jZVRvUGxhbmUoIHBsYW5lICk7XFxuXFxuXFx0XFx0XFx0aWYgKCB0ID09PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBudWxsO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5hdCggdCwgb3B0aW9uYWxUYXJnZXQgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGludGVyc2VjdHNQbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcXG5cXG5cXHRcXHRcXHQvLyBjaGVjayBpZiB0aGUgcmF5IGxpZXMgb24gdGhlIHBsYW5lIGZpcnN0XFxuXFxuXFx0XFx0XFx0dmFyIGRpc3RUb1BvaW50ID0gcGxhbmUuZGlzdGFuY2VUb1BvaW50KCB0aGlzLm9yaWdpbiApO1xcblxcblxcdFxcdFxcdGlmICggZGlzdFRvUG9pbnQgPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBkZW5vbWluYXRvciA9IHBsYW5lLm5vcm1hbC5kb3QoIHRoaXMuZGlyZWN0aW9uICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBkZW5vbWluYXRvciAqIGRpc3RUb1BvaW50IDwgMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gcmF5IG9yaWdpbiBpcyBiZWhpbmQgdGhlIHBsYW5lIChhbmQgaXMgcG9pbnRpbmcgYmVoaW5kIGl0KVxcblxcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGludGVyc2VjdEJveDogZnVuY3Rpb24gKCBib3gsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHZhciB0bWluLCB0bWF4LCB0eW1pbiwgdHltYXgsIHR6bWluLCB0em1heDtcXG5cXG5cXHRcXHRcXHR2YXIgaW52ZGlyeCA9IDEgLyB0aGlzLmRpcmVjdGlvbi54LFxcblxcdFxcdFxcdFxcdGludmRpcnkgPSAxIC8gdGhpcy5kaXJlY3Rpb24ueSxcXG5cXHRcXHRcXHRcXHRpbnZkaXJ6ID0gMSAvIHRoaXMuZGlyZWN0aW9uLno7XFxuXFxuXFx0XFx0XFx0dmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luO1xcblxcblxcdFxcdFxcdGlmICggaW52ZGlyeCA+PSAwICkge1xcblxcblxcdFxcdFxcdFxcdHRtaW4gPSAoIGJveC5taW4ueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xcblxcdFxcdFxcdFxcdHRtYXggPSAoIGJveC5tYXgueCAtIG9yaWdpbi54ICkgKiBpbnZkaXJ4O1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0dG1pbiA9ICggYm94Lm1heC54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XFxuXFx0XFx0XFx0XFx0dG1heCA9ICggYm94Lm1pbi54IC0gb3JpZ2luLnggKSAqIGludmRpcng7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggaW52ZGlyeSA+PSAwICkge1xcblxcblxcdFxcdFxcdFxcdHR5bWluID0gKCBib3gubWluLnkgLSBvcmlnaW4ueSApICogaW52ZGlyeTtcXG5cXHRcXHRcXHRcXHR0eW1heCA9ICggYm94Lm1heC55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR0eW1pbiA9ICggYm94Lm1heC55IC0gb3JpZ2luLnkgKSAqIGludmRpcnk7XFxuXFx0XFx0XFx0XFx0dHltYXggPSAoIGJveC5taW4ueSAtIG9yaWdpbi55ICkgKiBpbnZkaXJ5O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoICggdG1pbiA+IHR5bWF4ICkgfHwgKCB0eW1pbiA+IHRtYXggKSApIHJldHVybiBudWxsO1xcblxcblxcdFxcdFxcdC8vIFRoZXNlIGxpbmVzIGFsc28gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHRtaW4gb3IgdG1heCBpcyBOYU5cXG5cXHRcXHRcXHQvLyAocmVzdWx0IG9mIDAgKiBJbmZpbml0eSkuIHggIT09IHggcmV0dXJucyB0cnVlIGlmIHggaXMgTmFOXFxuXFxuXFx0XFx0XFx0aWYgKCB0eW1pbiA+IHRtaW4gfHwgdG1pbiAhPT0gdG1pbiApIHRtaW4gPSB0eW1pbjtcXG5cXG5cXHRcXHRcXHRpZiAoIHR5bWF4IDwgdG1heCB8fCB0bWF4ICE9PSB0bWF4ICkgdG1heCA9IHR5bWF4O1xcblxcblxcdFxcdFxcdGlmICggaW52ZGlyeiA+PSAwICkge1xcblxcblxcdFxcdFxcdFxcdHR6bWluID0gKCBib3gubWluLnogLSBvcmlnaW4ueiApICogaW52ZGlyejtcXG5cXHRcXHRcXHRcXHR0em1heCA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR0em1pbiA9ICggYm94Lm1heC56IC0gb3JpZ2luLnogKSAqIGludmRpcno7XFxuXFx0XFx0XFx0XFx0dHptYXggPSAoIGJveC5taW4ueiAtIG9yaWdpbi56ICkgKiBpbnZkaXJ6O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoICggdG1pbiA+IHR6bWF4ICkgfHwgKCB0em1pbiA+IHRtYXggKSApIHJldHVybiBudWxsO1xcblxcblxcdFxcdFxcdGlmICggdHptaW4gPiB0bWluIHx8IHRtaW4gIT09IHRtaW4gKSB0bWluID0gdHptaW47XFxuXFxuXFx0XFx0XFx0aWYgKCB0em1heCA8IHRtYXggfHwgdG1heCAhPT0gdG1heCApIHRtYXggPSB0em1heDtcXG5cXG5cXHRcXHRcXHQvL3JldHVybiBwb2ludCBjbG9zZXN0IHRvIHRoZSByYXkgKHBvc2l0aXZlIHNpZGUpXFxuXFxuXFx0XFx0XFx0aWYgKCB0bWF4IDwgMCApIHJldHVybiBudWxsO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmF0KCB0bWluID49IDAgPyB0bWluIDogdG1heCwgb3B0aW9uYWxUYXJnZXQgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGludGVyc2VjdHNCb3g6ICggZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2ID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c0JveCggYm94ICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmludGVyc2VjdEJveCggYm94LCB2ICkgIT09IG51bGw7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9ICkoKSxcXG5cXG5cXHRcXHRpbnRlcnNlY3RUcmlhbmdsZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIENvbXB1dGUgdGhlIG9mZnNldCBvcmlnaW4sIGVkZ2VzLCBhbmQgbm9ybWFsLlxcblxcdFxcdFxcdHZhciBkaWZmID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgZWRnZTEgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciBlZGdlMiA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGludGVyc2VjdFRyaWFuZ2xlKCBhLCBiLCBjLCBiYWNrZmFjZUN1bGxpbmcsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGZyb20gaHR0cDovL3d3dy5nZW9tZXRyaWN0b29scy5jb20vR1RFbmdpbmUvSW5jbHVkZS9NYXRoZW1hdGljcy9HdGVJbnRyUmF5M1RyaWFuZ2xlMy5oXFxuXFxuXFx0XFx0XFx0XFx0ZWRnZTEuc3ViVmVjdG9ycyggYiwgYSApO1xcblxcdFxcdFxcdFxcdGVkZ2UyLnN1YlZlY3RvcnMoIGMsIGEgKTtcXG5cXHRcXHRcXHRcXHRub3JtYWwuY3Jvc3NWZWN0b3JzKCBlZGdlMSwgZWRnZTIgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBTb2x2ZSBRICsgdCpEID0gYjEqRTEgKyBiMipFMiAoUSA9IGtEaWZmLCBEID0gcmF5IGRpcmVjdGlvbixcXG5cXHRcXHRcXHRcXHQvLyBFMSA9IGtFZGdlMSwgRTIgPSBrRWRnZTIsIE4gPSBDcm9zcyhFMSxFMikpIGJ5XFxuXFx0XFx0XFx0XFx0Ly8gICB8RG90KEQsTil8KmIxID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoUSxFMikpXFxuXFx0XFx0XFx0XFx0Ly8gICB8RG90KEQsTil8KmIyID0gc2lnbihEb3QoRCxOKSkqRG90KEQsQ3Jvc3MoRTEsUSkpXFxuXFx0XFx0XFx0XFx0Ly8gICB8RG90KEQsTil8KnQgPSAtc2lnbihEb3QoRCxOKSkqRG90KFEsTilcXG5cXHRcXHRcXHRcXHR2YXIgRGROID0gdGhpcy5kaXJlY3Rpb24uZG90KCBub3JtYWwgKTtcXG5cXHRcXHRcXHRcXHR2YXIgc2lnbjtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIERkTiA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBiYWNrZmFjZUN1bGxpbmcgKSByZXR1cm4gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRzaWduID0gMTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBEZE4gPCAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHNpZ24gPSAtIDE7XFxuXFx0XFx0XFx0XFx0XFx0RGROID0gLSBEZE47XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0ZGlmZi5zdWJWZWN0b3JzKCB0aGlzLm9yaWdpbiwgYSApO1xcblxcdFxcdFxcdFxcdHZhciBEZFF4RTIgPSBzaWduICogdGhpcy5kaXJlY3Rpb24uZG90KCBlZGdlMi5jcm9zc1ZlY3RvcnMoIGRpZmYsIGVkZ2UyICkgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBiMSA8IDAsIG5vIGludGVyc2VjdGlvblxcblxcdFxcdFxcdFxcdGlmICggRGRReEUyIDwgMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIERkRTF4USA9IHNpZ24gKiB0aGlzLmRpcmVjdGlvbi5kb3QoIGVkZ2UxLmNyb3NzKCBkaWZmICkgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBiMiA8IDAsIG5vIGludGVyc2VjdGlvblxcblxcdFxcdFxcdFxcdGlmICggRGRFMXhRIDwgMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gYjErYjIgPiAxLCBubyBpbnRlcnNlY3Rpb25cXG5cXHRcXHRcXHRcXHRpZiAoIERkUXhFMiArIERkRTF4USA+IERkTiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gTGluZSBpbnRlcnNlY3RzIHRyaWFuZ2xlLCBjaGVjayBpZiByYXkgZG9lcy5cXG5cXHRcXHRcXHRcXHR2YXIgUWROID0gLSBzaWduICogZGlmZi5kb3QoIG5vcm1hbCApO1xcblxcblxcdFxcdFxcdFxcdC8vIHQgPCAwLCBubyBpbnRlcnNlY3Rpb25cXG5cXHRcXHRcXHRcXHRpZiAoIFFkTiA8IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFJheSBpbnRlcnNlY3RzIHRyaWFuZ2xlLlxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmF0KCBRZE4gLyBEZE4sIG9wdGlvbmFsVGFyZ2V0ICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0YXBwbHlNYXRyaXg0OiBmdW5jdGlvbiAoIG1hdHJpeDQgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5vcmlnaW4uYXBwbHlNYXRyaXg0KCBtYXRyaXg0ICk7XFxuXFx0XFx0XFx0dGhpcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCBtYXRyaXg0ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRlcXVhbHM6IGZ1bmN0aW9uICggcmF5ICkge1xcblxcblxcdFxcdFxcdHJldHVybiByYXkub3JpZ2luLmVxdWFscyggdGhpcy5vcmlnaW4gKSAmJiByYXkuZGlyZWN0aW9uLmVxdWFscyggdGhpcy5kaXJlY3Rpb24gKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBMaW5lMyggc3RhcnQsIGVuZCApIHtcXG5cXG5cXHRcXHR0aGlzLnN0YXJ0ID0gKCBzdGFydCAhPT0gdW5kZWZpbmVkICkgPyBzdGFydCA6IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dGhpcy5lbmQgPSAoIGVuZCAhPT0gdW5kZWZpbmVkICkgPyBlbmQgOiBuZXcgVmVjdG9yMygpO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBMaW5lMy5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggc3RhcnQsIGVuZCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnN0YXJ0LmNvcHkoIHN0YXJ0ICk7XFxuXFx0XFx0XFx0dGhpcy5lbmQuY29weSggZW5kICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggbGluZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnN0YXJ0LmNvcHkoIGxpbmUuc3RhcnQgKTtcXG5cXHRcXHRcXHR0aGlzLmVuZC5jb3B5KCBsaW5lLmVuZCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHJldHVybiByZXN1bHQuYWRkVmVjdG9ycyggdGhpcy5zdGFydCwgdGhpcy5lbmQgKS5tdWx0aXBseVNjYWxhciggMC41ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkZWx0YTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0LnN1YlZlY3RvcnMoIHRoaXMuZW5kLCB0aGlzLnN0YXJ0ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXN0YW5jZVNxOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuc3RhcnQuZGlzdGFuY2VUb1NxdWFyZWQoIHRoaXMuZW5kICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRkaXN0YW5jZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLnN0YXJ0LmRpc3RhbmNlVG8oIHRoaXMuZW5kICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhdDogZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5kZWx0YSggcmVzdWx0ICkubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMuc3RhcnQgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb3Nlc3RQb2ludFRvUG9pbnRQYXJhbWV0ZXI6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgc3RhcnRQID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgc3RhcnRFbmQgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBjbG9zZXN0UG9pbnRUb1BvaW50UGFyYW1ldGVyKCBwb2ludCwgY2xhbXBUb0xpbmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c3RhcnRQLnN1YlZlY3RvcnMoIHBvaW50LCB0aGlzLnN0YXJ0ICk7XFxuXFx0XFx0XFx0XFx0c3RhcnRFbmQuc3ViVmVjdG9ycyggdGhpcy5lbmQsIHRoaXMuc3RhcnQgKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgc3RhcnRFbmQyID0gc3RhcnRFbmQuZG90KCBzdGFydEVuZCApO1xcblxcdFxcdFxcdFxcdHZhciBzdGFydEVuZF9zdGFydFAgPSBzdGFydEVuZC5kb3QoIHN0YXJ0UCApO1xcblxcblxcdFxcdFxcdFxcdHZhciB0ID0gc3RhcnRFbmRfc3RhcnRQIC8gc3RhcnRFbmQyO1xcblxcblxcdFxcdFxcdFxcdGlmICggY2xhbXBUb0xpbmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dCA9IF9NYXRoLmNsYW1wKCB0LCAwLCAxICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiB0O1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIGNsYW1wVG9MaW5lLCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdCA9IHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludFBhcmFtZXRlciggcG9pbnQsIGNsYW1wVG9MaW5lICk7XFxuXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZGVsdGEoIHJlc3VsdCApLm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnN0YXJ0ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRhcHBseU1hdHJpeDQ6IGZ1bmN0aW9uICggbWF0cml4ICkge1xcblxcblxcdFxcdFxcdHRoaXMuc3RhcnQuYXBwbHlNYXRyaXg0KCBtYXRyaXggKTtcXG5cXHRcXHRcXHR0aGlzLmVuZC5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZXF1YWxzOiBmdW5jdGlvbiAoIGxpbmUgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGxpbmUuc3RhcnQuZXF1YWxzKCB0aGlzLnN0YXJ0ICkgJiYgbGluZS5lbmQuZXF1YWxzKCB0aGlzLmVuZCApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBiaG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pb1xcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gVHJpYW5nbGUoIGEsIGIsIGMgKSB7XFxuXFxuXFx0XFx0dGhpcy5hID0gKCBhICE9PSB1bmRlZmluZWQgKSA/IGEgOiBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHRoaXMuYiA9ICggYiAhPT0gdW5kZWZpbmVkICkgPyBiIDogbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR0aGlzLmMgPSAoIGMgIT09IHVuZGVmaW5lZCApID8gYyA6IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIFRyaWFuZ2xlLCB7XFxuXFxuXFx0XFx0bm9ybWFsOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHYwID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gbm9ybWFsKCBhLCBiLCBjLCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXN1bHQuc3ViVmVjdG9ycyggYywgYiApO1xcblxcdFxcdFxcdFxcdHYwLnN1YlZlY3RvcnMoIGEsIGIgKTtcXG5cXHRcXHRcXHRcXHRyZXN1bHQuY3Jvc3MoIHYwICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHJlc3VsdExlbmd0aFNxID0gcmVzdWx0Lmxlbmd0aFNxKCk7XFxuXFx0XFx0XFx0XFx0aWYgKCByZXN1bHRMZW5ndGhTcSA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHJlc3VsdC5tdWx0aXBseVNjYWxhciggMSAvIE1hdGguc3FydCggcmVzdWx0TGVuZ3RoU3EgKSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0LnNldCggMCwgMCwgMCApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdC8vIHN0YXRpYy9pbnN0YW5jZSBtZXRob2QgdG8gY2FsY3VsYXRlIGJhcnljZW50cmljIGNvb3JkaW5hdGVzXFxuXFx0XFx0Ly8gYmFzZWQgb246IGh0dHA6Ly93d3cuYmxhY2twYXduLmNvbS90ZXh0cy9wb2ludGlucG9seS9kZWZhdWx0Lmh0bWxcXG5cXHRcXHRiYXJ5Y29vcmRGcm9tUG9pbnQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjAgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIHYyID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gYmFyeWNvb3JkRnJvbVBvaW50KCBwb2ludCwgYSwgYiwgYywgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0djAuc3ViVmVjdG9ycyggYywgYSApO1xcblxcdFxcdFxcdFxcdHYxLnN1YlZlY3RvcnMoIGIsIGEgKTtcXG5cXHRcXHRcXHRcXHR2Mi5zdWJWZWN0b3JzKCBwb2ludCwgYSApO1xcblxcblxcdFxcdFxcdFxcdHZhciBkb3QwMCA9IHYwLmRvdCggdjAgKTtcXG5cXHRcXHRcXHRcXHR2YXIgZG90MDEgPSB2MC5kb3QoIHYxICk7XFxuXFx0XFx0XFx0XFx0dmFyIGRvdDAyID0gdjAuZG90KCB2MiApO1xcblxcdFxcdFxcdFxcdHZhciBkb3QxMSA9IHYxLmRvdCggdjEgKTtcXG5cXHRcXHRcXHRcXHR2YXIgZG90MTIgPSB2MS5kb3QoIHYyICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGRlbm9tID0gKCBkb3QwMCAqIGRvdDExIC0gZG90MDEgKiBkb3QwMSApO1xcblxcblxcdFxcdFxcdFxcdHZhciByZXN1bHQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdFxcdC8vIGNvbGxpbmVhciBvciBzaW5ndWxhciB0cmlhbmdsZVxcblxcdFxcdFxcdFxcdGlmICggZGVub20gPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYXJiaXRyYXJ5IGxvY2F0aW9uIG91dHNpZGUgb2YgdHJpYW5nbGU/XFxuXFx0XFx0XFx0XFx0XFx0Ly8gbm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgYmVzdCBpZGVhLCBtYXliZSBzaG91bGQgYmUgcmV0dXJuaW5nIHVuZGVmaW5lZFxcblxcdFxcdFxcdFxcdFxcdHJldHVybiByZXN1bHQuc2V0KCAtIDIsIC0gMSwgLSAxICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciBpbnZEZW5vbSA9IDEgLyBkZW5vbTtcXG5cXHRcXHRcXHRcXHR2YXIgdSA9ICggZG90MTEgKiBkb3QwMiAtIGRvdDAxICogZG90MTIgKSAqIGludkRlbm9tO1xcblxcdFxcdFxcdFxcdHZhciB2ID0gKCBkb3QwMCAqIGRvdDEyIC0gZG90MDEgKiBkb3QwMiApICogaW52RGVub207XFxuXFxuXFx0XFx0XFx0XFx0Ly8gYmFyeWNlbnRyaWMgY29vcmRpbmF0ZXMgbXVzdCBhbHdheXMgc3VtIHRvIDFcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0LnNldCggMSAtIHUgLSB2LCB2LCB1ICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFxuXFx0XFx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGNvbnRhaW5zUG9pbnQoIHBvaW50LCBhLCBiLCBjICkge1xcblxcblxcdFxcdFxcdFxcdHZhciByZXN1bHQgPSBUcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCBhLCBiLCBjLCB2MSApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiAoIHJlc3VsdC54ID49IDAgKSAmJiAoIHJlc3VsdC55ID49IDAgKSAmJiAoICggcmVzdWx0LnggKyByZXN1bHQueSApIDw9IDEgKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuYXNzaWduKCBUcmlhbmdsZS5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggYSwgYiwgYyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmEuY29weSggYSApO1xcblxcdFxcdFxcdHRoaXMuYi5jb3B5KCBiICk7XFxuXFx0XFx0XFx0dGhpcy5jLmNvcHkoIGMgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZyb21Qb2ludHNBbmRJbmRpY2VzOiBmdW5jdGlvbiAoIHBvaW50cywgaTAsIGkxLCBpMiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmEuY29weSggcG9pbnRzWyBpMCBdICk7XFxuXFx0XFx0XFx0dGhpcy5iLmNvcHkoIHBvaW50c1sgaTEgXSApO1xcblxcdFxcdFxcdHRoaXMuYy5jb3B5KCBwb2ludHNbIGkyIF0gKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCB0cmlhbmdsZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmEuY29weSggdHJpYW5nbGUuYSApO1xcblxcdFxcdFxcdHRoaXMuYi5jb3B5KCB0cmlhbmdsZS5iICk7XFxuXFx0XFx0XFx0dGhpcy5jLmNvcHkoIHRyaWFuZ2xlLmMgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFyZWE6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjAgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciB2MSA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGFyZWEoKSB7XFxuXFxuXFx0XFx0XFx0XFx0djAuc3ViVmVjdG9ycyggdGhpcy5jLCB0aGlzLmIgKTtcXG5cXHRcXHRcXHRcXHR2MS5zdWJWZWN0b3JzKCB0aGlzLmEsIHRoaXMuYiApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB2MC5jcm9zcyggdjEgKS5sZW5ndGgoKSAqIDAuNTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRtaWRwb2ludDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHRyZXR1cm4gcmVzdWx0LmFkZFZlY3RvcnMoIHRoaXMuYSwgdGhpcy5iICkuYWRkKCB0aGlzLmMgKS5tdWx0aXBseVNjYWxhciggMSAvIDMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdG5vcm1hbDogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gVHJpYW5nbGUubm9ybWFsKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBvcHRpb25hbFRhcmdldCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cGxhbmU6IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBQbGFuZSgpO1xcblxcblxcdFxcdFxcdHJldHVybiByZXN1bHQuc2V0RnJvbUNvcGxhbmFyUG9pbnRzKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRiYXJ5Y29vcmRGcm9tUG9pbnQ6IGZ1bmN0aW9uICggcG9pbnQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHJldHVybiBUcmlhbmdsZS5iYXJ5Y29vcmRGcm9tUG9pbnQoIHBvaW50LCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jLCBvcHRpb25hbFRhcmdldCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29udGFpbnNQb2ludDogZnVuY3Rpb24gKCBwb2ludCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gVHJpYW5nbGUuY29udGFpbnNQb2ludCggcG9pbnQsIHRoaXMuYSwgdGhpcy5iLCB0aGlzLmMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb3Nlc3RQb2ludFRvUG9pbnQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgcGxhbmUgPSBuZXcgUGxhbmUoKTtcXG5cXHRcXHRcXHR2YXIgZWRnZUxpc3QgPSBbIG5ldyBMaW5lMygpLCBuZXcgTGluZTMoKSwgbmV3IExpbmUzKCkgXTtcXG5cXHRcXHRcXHR2YXIgcHJvamVjdGVkUG9pbnQgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciBjbG9zZXN0UG9pbnQgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBjbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHJlc3VsdCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0XFx0dmFyIG1pbkRpc3RhbmNlID0gSW5maW5pdHk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gcHJvamVjdCB0aGUgcG9pbnQgb250byB0aGUgcGxhbmUgb2YgdGhlIHRyaWFuZ2xlXFxuXFxuXFx0XFx0XFx0XFx0cGxhbmUuc2V0RnJvbUNvcGxhbmFyUG9pbnRzKCB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jICk7XFxuXFx0XFx0XFx0XFx0cGxhbmUucHJvamVjdFBvaW50KCBwb2ludCwgcHJvamVjdGVkUG9pbnQgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBjaGVjayBpZiB0aGUgcHJvamVjdGlvbiBsaWVzIHdpdGhpbiB0aGUgdHJpYW5nbGVcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRoaXMuY29udGFpbnNQb2ludCggcHJvamVjdGVkUG9pbnQgKSA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBpZiBzbywgdGhpcyBpcyB0aGUgY2xvc2VzdCBwb2ludFxcblxcblxcdFxcdFxcdFxcdFxcdHJlc3VsdC5jb3B5KCBwcm9qZWN0ZWRQb2ludCApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaWYgbm90LCB0aGUgcG9pbnQgZmFsbHMgb3V0c2lkZSB0aGUgdHJpYW5nbGUuIHRoZSByZXN1bHQgaXMgdGhlIGNsb3Nlc3QgcG9pbnQgdG8gdGhlIHRyaWFuZ2xlJ3MgZWRnZXMgb3IgdmVydGljZXNcXG5cXG5cXHRcXHRcXHRcXHRcXHRlZGdlTGlzdFsgMCBdLnNldCggdGhpcy5hLCB0aGlzLmIgKTtcXG5cXHRcXHRcXHRcXHRcXHRlZGdlTGlzdFsgMSBdLnNldCggdGhpcy5iLCB0aGlzLmMgKTtcXG5cXHRcXHRcXHRcXHRcXHRlZGdlTGlzdFsgMiBdLnNldCggdGhpcy5jLCB0aGlzLmEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBlZGdlTGlzdC5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZWRnZUxpc3RbIGkgXS5jbG9zZXN0UG9pbnRUb1BvaW50KCBwcm9qZWN0ZWRQb2ludCwgdHJ1ZSwgY2xvc2VzdFBvaW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGRpc3RhbmNlID0gcHJvamVjdGVkUG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIGNsb3Nlc3RQb2ludCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc3VsdC5jb3B5KCBjbG9zZXN0UG9pbnQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0O1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdGVxdWFsczogZnVuY3Rpb24gKCB0cmlhbmdsZSApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdHJpYW5nbGUuYS5lcXVhbHMoIHRoaXMuYSApICYmIHRyaWFuZ2xlLmIuZXF1YWxzKCB0aGlzLmIgKSAmJiB0cmlhbmdsZS5jLmVxdWFscyggdGhpcy5jICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cXG5cXHQgKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwOi8vam9ub2JyMS5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xcblxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnTWVzaCc7XFxuXFxuXFx0XFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcblxcdFxcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XFxuXFxuXFx0XFx0dGhpcy5kcmF3TW9kZSA9IFRyaWFuZ2xlc0RyYXdNb2RlO1xcblxcblxcdFxcdHRoaXMudXBkYXRlTW9ycGhUYXJnZXRzKCk7XFxuXFxuXFx0fVxcblxcblxcdE1lc2gucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogTWVzaCxcXG5cXG5cXHRcXHRpc01lc2g6IHRydWUsXFxuXFxuXFx0XFx0c2V0RHJhd01vZGU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5kcmF3TW9kZSA9IHZhbHVlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0XFx0T2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5kcmF3TW9kZSA9IHNvdXJjZS5kcmF3TW9kZTtcXG5cXG5cXHRcXHRcXHRpZiAoIHNvdXJjZS5tb3JwaFRhcmdldEluZmx1ZW5jZXMgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IHNvdXJjZS5tb3JwaFRhcmdldEluZmx1ZW5jZXMuc2xpY2UoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBzb3VyY2UubW9ycGhUYXJnZXREaWN0aW9uYXJ5ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSBPYmplY3QuYXNzaWduKCB7fSwgc291cmNlLm1vcnBoVGFyZ2V0RGljdGlvbmFyeSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHVwZGF0ZU1vcnBoVGFyZ2V0czogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XFxuXFx0XFx0XFx0dmFyIG0sIG1sLCBuYW1lO1xcblxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xcblxcdFxcdFxcdFxcdHZhciBrZXlzID0gT2JqZWN0LmtleXMoIG1vcnBoQXR0cmlidXRlcyApO1xcblxcblxcdFxcdFxcdFxcdGlmICgga2V5cy5sZW5ndGggPiAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBtb3JwaEF0dHJpYnV0ZSA9IG1vcnBoQXR0cmlidXRlc1sga2V5c1sgMCBdIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBtb3JwaEF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzID0gW107XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5tb3JwaFRhcmdldERpY3Rpb25hcnkgPSB7fTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCBtID0gMCwgbWwgPSBtb3JwaEF0dHJpYnV0ZS5sZW5ndGg7IG0gPCBtbDsgbSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRuYW1lID0gbW9ycGhBdHRyaWJ1dGVbIG0gXS5uYW1lIHx8IFN0cmluZyggbSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goIDAgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdID0gbTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHZhciBtb3JwaFRhcmdldHMgPSBnZW9tZXRyeS5tb3JwaFRhcmdldHM7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtb3JwaFRhcmdldHMgIT09IHVuZGVmaW5lZCAmJiBtb3JwaFRhcmdldHMubGVuZ3RoID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMubW9ycGhUYXJnZXREaWN0aW9uYXJ5ID0ge307XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggbSA9IDAsIG1sID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgbSA8IG1sOyBtICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdG5hbWUgPSBtb3JwaFRhcmdldHNbIG0gXS5uYW1lIHx8IFN0cmluZyggbSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMubW9ycGhUYXJnZXRJbmZsdWVuY2VzLnB1c2goIDAgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLm1vcnBoVGFyZ2V0RGljdGlvbmFyeVsgbmFtZSBdID0gbTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHJheWNhc3Q6ICggZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcXG5cXHRcXHRcXHR2YXIgcmF5ID0gbmV3IFJheSgpO1xcblxcdFxcdFxcdHZhciBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XFxuXFxuXFx0XFx0XFx0dmFyIHZBID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgdkIgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciB2QyA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0dmFyIHRlbXBBID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgdGVtcEIgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciB0ZW1wQyA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0dmFyIHV2QSA9IG5ldyBWZWN0b3IyKCk7XFxuXFx0XFx0XFx0dmFyIHV2QiA9IG5ldyBWZWN0b3IyKCk7XFxuXFx0XFx0XFx0dmFyIHV2QyA9IG5ldyBWZWN0b3IyKCk7XFxuXFxuXFx0XFx0XFx0dmFyIGJhcnljb29yZCA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0dmFyIGludGVyc2VjdGlvblBvaW50ID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgaW50ZXJzZWN0aW9uUG9pbnRXb3JsZCA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gdXZJbnRlcnNlY3Rpb24oIHBvaW50LCBwMSwgcDIsIHAzLCB1djEsIHV2MiwgdXYzICkge1xcblxcblxcdFxcdFxcdFxcdFRyaWFuZ2xlLmJhcnljb29yZEZyb21Qb2ludCggcG9pbnQsIHAxLCBwMiwgcDMsIGJhcnljb29yZCApO1xcblxcblxcdFxcdFxcdFxcdHV2MS5tdWx0aXBseVNjYWxhciggYmFyeWNvb3JkLnggKTtcXG5cXHRcXHRcXHRcXHR1djIubXVsdGlwbHlTY2FsYXIoIGJhcnljb29yZC55ICk7XFxuXFx0XFx0XFx0XFx0dXYzLm11bHRpcGx5U2NhbGFyKCBiYXJ5Y29vcmQueiApO1xcblxcblxcdFxcdFxcdFxcdHV2MS5hZGQoIHV2MiApLmFkZCggdXYzICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHV2MS5jbG9uZSgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBjaGVja0ludGVyc2VjdGlvbiggb2JqZWN0LCBtYXRlcmlhbCwgcmF5Y2FzdGVyLCByYXksIHBBLCBwQiwgcEMsIHBvaW50ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBpbnRlcnNlY3Q7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5zaWRlID09PSBCYWNrU2lkZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3QgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHBDLCBwQiwgcEEsIHRydWUsIHBvaW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3QgPSByYXkuaW50ZXJzZWN0VHJpYW5nbGUoIHBBLCBwQiwgcEMsIG1hdGVyaWFsLnNpZGUgIT09IERvdWJsZVNpZGUsIHBvaW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggaW50ZXJzZWN0ID09PSBudWxsICkgcmV0dXJuIG51bGw7XFxuXFxuXFx0XFx0XFx0XFx0aW50ZXJzZWN0aW9uUG9pbnRXb3JsZC5jb3B5KCBwb2ludCApO1xcblxcdFxcdFxcdFxcdGludGVyc2VjdGlvblBvaW50V29ybGQuYXBwbHlNYXRyaXg0KCBvYmplY3QubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybiBudWxsO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0XFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxcblxcdFxcdFxcdFxcdFxcdHBvaW50OiBpbnRlcnNlY3Rpb25Qb2ludFdvcmxkLmNsb25lKCksXFxuXFx0XFx0XFx0XFx0XFx0b2JqZWN0OiBvYmplY3RcXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCBvYmplY3QsIHJheWNhc3RlciwgcmF5LCBwb3NpdGlvbiwgdXYsIGEsIGIsIGMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGEgKTtcXG5cXHRcXHRcXHRcXHR2Qi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgYiApO1xcblxcdFxcdFxcdFxcdHZDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBjICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGludGVyc2VjdGlvbiA9IGNoZWNrSW50ZXJzZWN0aW9uKCBvYmplY3QsIG9iamVjdC5tYXRlcmlhbCwgcmF5Y2FzdGVyLCByYXksIHZBLCB2QiwgdkMsIGludGVyc2VjdGlvblBvaW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB1diApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR1dkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYsIGEgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR1dkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYsIGIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR1dkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYsIGMgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3Rpb24udXYgPSB1dkludGVyc2VjdGlvbiggaW50ZXJzZWN0aW9uUG9pbnQsIHZBLCB2QiwgdkMsIHV2QSwgdXZCLCB1dkMgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0aW9uLmZhY2UgPSBuZXcgRmFjZTMoIGEsIGIsIGMsIFRyaWFuZ2xlLm5vcm1hbCggdkEsIHZCLCB2QyApICk7XFxuXFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IGE7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiBpbnRlcnNlY3Rpb247XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiByYXljYXN0KCByYXljYXN0ZXIsIGludGVyc2VjdHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcXG5cXHRcXHRcXHRcXHR2YXIgbWF0ZXJpYWwgPSB0aGlzLm1hdGVyaWFsO1xcblxcdFxcdFxcdFxcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMubWF0cml4V29ybGQ7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtYXRlcmlhbCA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxcblxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcXG5cXG5cXHRcXHRcXHRcXHRzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcXG5cXHRcXHRcXHRcXHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xcblxcblxcdFxcdFxcdFxcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0Ly9cXG5cXG5cXHRcXHRcXHRcXHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIG1hdHJpeFdvcmxkICk7XFxuXFx0XFx0XFx0XFx0cmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDaGVjayBib3VuZGluZ0JveCBiZWZvcmUgY29udGludWluZ1xcblxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdCb3ggIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCByYXkuaW50ZXJzZWN0c0JveCggZ2VvbWV0cnkuYm91bmRpbmdCb3ggKSA9PT0gZmFsc2UgKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciBpbnRlcnNlY3Rpb247XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBhLCBiLCBjO1xcblxcdFxcdFxcdFxcdFxcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xcblxcdFxcdFxcdFxcdFxcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHV2ID0gZ2VvbWV0cnkuYXR0cmlidXRlcy51djtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgaSwgbDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGluZGV4ZWQgYnVmZmVyIGdlb21ldHJ5XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggaSA9IDAsIGwgPSBpbmRleC5jb3VudDsgaSA8IGw7IGkgKz0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRhID0gaW5kZXguZ2V0WCggaSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGIgPSBpbmRleC5nZXRYKCBpICsgMSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGMgPSBpbmRleC5nZXRYKCBpICsgMiApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGludGVyc2VjdGlvbiA9IGNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24oIHRoaXMsIHJheWNhc3RlciwgcmF5LCBwb3NpdGlvbiwgdXYsIGEsIGIsIGMgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGludGVyc2VjdGlvbiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gTWF0aC5mbG9vciggaSAvIDMgKTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIGluZGljZXMgYnVmZmVyIHNlbWFudGljc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGludGVyc2VjdHMucHVzaCggaW50ZXJzZWN0aW9uICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIG5vbi1pbmRleGVkIGJ1ZmZlciBnZW9tZXRyeVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIGkgPSAwLCBsID0gcG9zaXRpb24uY291bnQ7IGkgPCBsOyBpICs9IDMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YSA9IGk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YiA9IGkgKyAxO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGMgPSBpICsgMjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3Rpb24gPSBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCB0aGlzLCByYXljYXN0ZXIsIHJheSwgcG9zaXRpb24sIHV2LCBhLCBiLCBjICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0aW9uLmluZGV4ID0gYTsgLy8gdHJpYW5nbGUgbnVtYmVyIGluIHBvc2l0aW9ucyBidWZmZXIgc2VtYW50aWNzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0cy5wdXNoKCBpbnRlcnNlY3Rpb24gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBnZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBmdkEsIGZ2QiwgZnZDO1xcblxcdFxcdFxcdFxcdFxcdHZhciBpc011bHRpTWF0ZXJpYWwgPSBBcnJheS5pc0FycmF5KCBtYXRlcmlhbCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xcblxcdFxcdFxcdFxcdFxcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xcblxcdFxcdFxcdFxcdFxcdHZhciB1dnM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGZhY2VWZXJ0ZXhVdnMgPSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyAwIF07XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBmYWNlVmVydGV4VXZzLmxlbmd0aCA+IDAgKSB1dnMgPSBmYWNlVmVydGV4VXZzO1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBmID0gMCwgZmwgPSBmYWNlcy5sZW5ndGg7IGYgPCBmbDsgZiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZmFjZSA9IGZhY2VzWyBmIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGZhY2VNYXRlcmlhbCA9IGlzTXVsdGlNYXRlcmlhbCA/IG1hdGVyaWFsWyBmYWNlLm1hdGVyaWFsSW5kZXggXSA6IG1hdGVyaWFsO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZmFjZU1hdGVyaWFsID09PSB1bmRlZmluZWQgKSBjb250aW51ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmdkEgPSB2ZXJ0aWNlc1sgZmFjZS5hIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZnZCID0gdmVydGljZXNbIGZhY2UuYiBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdGZ2QyA9IHZlcnRpY2VzWyBmYWNlLmMgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGZhY2VNYXRlcmlhbC5tb3JwaFRhcmdldHMgPT09IHRydWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIG1vcnBoVGFyZ2V0cyA9IGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgbW9ycGhJbmZsdWVuY2VzID0gdGhpcy5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dkEuc2V0KCAwLCAwLCAwICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dkIuc2V0KCAwLCAwLCAwICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dkMuc2V0KCAwLCAwLCAwICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIHQgPSAwLCB0bCA9IG1vcnBoVGFyZ2V0cy5sZW5ndGg7IHQgPCB0bDsgdCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgaW5mbHVlbmNlID0gbW9ycGhJbmZsdWVuY2VzWyB0IF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpbmZsdWVuY2UgPT09IDAgKSBjb250aW51ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgdGFyZ2V0cyA9IG1vcnBoVGFyZ2V0c1sgdCBdLnZlcnRpY2VzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZBLmFkZFNjYWxlZFZlY3RvciggdGVtcEEuc3ViVmVjdG9ycyggdGFyZ2V0c1sgZmFjZS5hIF0sIGZ2QSApLCBpbmZsdWVuY2UgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2Qi5hZGRTY2FsZWRWZWN0b3IoIHRlbXBCLnN1YlZlY3RvcnMoIHRhcmdldHNbIGZhY2UuYiBdLCBmdkIgKSwgaW5mbHVlbmNlICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dkMuYWRkU2NhbGVkVmVjdG9yKCB0ZW1wQy5zdWJWZWN0b3JzKCB0YXJnZXRzWyBmYWNlLmMgXSwgZnZDICksIGluZmx1ZW5jZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2QS5hZGQoIGZ2QSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZCLmFkZCggZnZCICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dkMuYWRkKCBmdkMgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmdkEgPSB2QTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmdkIgPSB2QjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmdkMgPSB2QztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0aW9uID0gY2hlY2tJbnRlcnNlY3Rpb24oIHRoaXMsIGZhY2VNYXRlcmlhbCwgcmF5Y2FzdGVyLCByYXksIGZ2QSwgZnZCLCBmdkMsIGludGVyc2VjdGlvblBvaW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB1dnMgJiYgdXZzWyBmIF0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHV2c19mID0gdXZzWyBmIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dXZBLmNvcHkoIHV2c19mWyAwIF0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR1dkIuY29weSggdXZzX2ZbIDEgXSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHV2Qy5jb3B5KCB1dnNfZlsgMiBdICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0aW9uLnV2ID0gdXZJbnRlcnNlY3Rpb24oIGludGVyc2VjdGlvblBvaW50LCBmdkEsIGZ2QiwgZnZDLCB1dkEsIHV2QiwgdXZDICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGludGVyc2VjdGlvbi5mYWNlID0gZmFjZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gZjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3RzLnB1c2goIGludGVyc2VjdGlvbiApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpICksXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoIHRoaXMuZ2VvbWV0cnksIHRoaXMubWF0ZXJpYWwgKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFdlYkdMQmFja2dyb3VuZCggcmVuZGVyZXIsIHN0YXRlLCBnZW9tZXRyaWVzLCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XFxuXFxuXFx0XFx0dmFyIGNsZWFyQ29sb3IgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XFxuXFx0XFx0dmFyIGNsZWFyQWxwaGEgPSAwO1xcblxcblxcdFxcdHZhciBwbGFuZUNhbWVyYSwgcGxhbmVNZXNoO1xcblxcdFxcdHZhciBib3hNZXNoO1xcblxcblxcdFxcdGZ1bmN0aW9uIHJlbmRlciggcmVuZGVyTGlzdCwgc2NlbmUsIGNhbWVyYSwgZm9yY2VDbGVhciApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYmFja2dyb3VuZCA9IHNjZW5lLmJhY2tncm91bmQ7XFxuXFxuXFx0XFx0XFx0aWYgKCBiYWNrZ3JvdW5kID09PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHNldENsZWFyKCBjbGVhckNvbG9yLCBjbGVhckFscGhhICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggYmFja2dyb3VuZCAmJiBiYWNrZ3JvdW5kLmlzQ29sb3IgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c2V0Q2xlYXIoIGJhY2tncm91bmQsIDEgKTtcXG5cXHRcXHRcXHRcXHRmb3JjZUNsZWFyID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCByZW5kZXJlci5hdXRvQ2xlYXIgfHwgZm9yY2VDbGVhciApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZW5kZXJlci5jbGVhciggcmVuZGVyZXIuYXV0b0NsZWFyQ29sb3IsIHJlbmRlcmVyLmF1dG9DbGVhckRlcHRoLCByZW5kZXJlci5hdXRvQ2xlYXJTdGVuY2lsICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggYmFja2dyb3VuZCAmJiBiYWNrZ3JvdW5kLmlzQ3ViZVRleHR1cmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBib3hNZXNoID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ym94TWVzaCA9IG5ldyBNZXNoKFxcblxcdFxcdFxcdFxcdFxcdFxcdG5ldyBCb3hCdWZmZXJHZW9tZXRyeSggMSwgMSwgMSApLFxcblxcdFxcdFxcdFxcdFxcdFxcdG5ldyBTaGFkZXJNYXRlcmlhbCgge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zOiBTaGFkZXJMaWIuY3ViZS51bmlmb3JtcyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhTaGFkZXI6IFNoYWRlckxpYi5jdWJlLnZlcnRleFNoYWRlcixcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmcmFnbWVudFNoYWRlcjogU2hhZGVyTGliLmN1YmUuZnJhZ21lbnRTaGFkZXIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2lkZTogQmFja1NpZGUsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGVwdGhUZXN0OiB0cnVlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRlcHRoV3JpdGU6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvZzogZmFsc2VcXG5cXHRcXHRcXHRcXHRcXHRcXHR9IClcXG5cXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdFxcdGJveE1lc2guZ2VvbWV0cnkucmVtb3ZlQXR0cmlidXRlKCAnbm9ybWFsJyApO1xcblxcdFxcdFxcdFxcdFxcdGJveE1lc2guZ2VvbWV0cnkucmVtb3ZlQXR0cmlidXRlKCAndXYnICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ym94TWVzaC5vbkJlZm9yZVJlbmRlciA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHNjZW5lLCBjYW1lcmEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5tYXRyaXhXb3JsZC5jb3B5UG9zaXRpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2VvbWV0cmllcy51cGRhdGUoIGJveE1lc2guZ2VvbWV0cnkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ym94TWVzaC5tYXRlcmlhbC51bmlmb3Jtcy50Q3ViZS52YWx1ZSA9IGJhY2tncm91bmQ7XFxuXFxuXFx0XFx0XFx0XFx0cmVuZGVyTGlzdC5wdXNoKCBib3hNZXNoLCBib3hNZXNoLmdlb21ldHJ5LCBib3hNZXNoLm1hdGVyaWFsLCAwLCBudWxsICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggYmFja2dyb3VuZCAmJiBiYWNrZ3JvdW5kLmlzVGV4dHVyZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHBsYW5lQ2FtZXJhID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cGxhbmVDYW1lcmEgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKCAtIDEsIDEsIDEsIC0gMSwgMCwgMSApO1xcblxcblxcdFxcdFxcdFxcdFxcdHBsYW5lTWVzaCA9IG5ldyBNZXNoKFxcblxcdFxcdFxcdFxcdFxcdFxcdG5ldyBQbGFuZUJ1ZmZlckdlb21ldHJ5KCAyLCAyICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0bmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IGRlcHRoVGVzdDogZmFsc2UsIGRlcHRoV3JpdGU6IGZhbHNlLCBmb2c6IGZhbHNlIH0gKVxcblxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2VvbWV0cmllcy51cGRhdGUoIHBsYW5lTWVzaC5nZW9tZXRyeSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRwbGFuZU1lc2gubWF0ZXJpYWwubWFwID0gYmFja2dyb3VuZDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBUT0RPIFB1c2ggdGhpcyB0byByZW5kZXJMaXN0XFxuXFxuXFx0XFx0XFx0XFx0cmVuZGVyZXIucmVuZGVyQnVmZmVyRGlyZWN0KCBwbGFuZUNhbWVyYSwgbnVsbCwgcGxhbmVNZXNoLmdlb21ldHJ5LCBwbGFuZU1lc2gubWF0ZXJpYWwsIHBsYW5lTWVzaCwgbnVsbCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2V0Q2xlYXIoIGNvbG9yLCBhbHBoYSApIHtcXG5cXG5cXHRcXHRcXHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldENsZWFyKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iLCBhbHBoYSwgcHJlbXVsdGlwbGllZEFscGhhICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB7XFxuXFxuXFx0XFx0XFx0Z2V0Q2xlYXJDb2xvcjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBjbGVhckNvbG9yO1xcblxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2V0Q2xlYXJDb2xvcjogZnVuY3Rpb24gKCBjb2xvciwgYWxwaGEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y2xlYXJDb2xvci5zZXQoIGNvbG9yICk7XFxuXFx0XFx0XFx0XFx0Y2xlYXJBbHBoYSA9IGFscGhhICE9PSB1bmRlZmluZWQgPyBhbHBoYSA6IDE7XFxuXFx0XFx0XFx0XFx0c2V0Q2xlYXIoIGNsZWFyQ29sb3IsIGNsZWFyQWxwaGEgKTtcXG5cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGdldENsZWFyQWxwaGE6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gY2xlYXJBbHBoYTtcXG5cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHNldENsZWFyQWxwaGE6IGZ1bmN0aW9uICggYWxwaGEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y2xlYXJBbHBoYSA9IGFscGhhO1xcblxcdFxcdFxcdFxcdHNldENsZWFyKCBjbGVhckNvbG9yLCBjbGVhckFscGhhICk7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRyZW5kZXI6IHJlbmRlclxcblxcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gcGFpbnRlclNvcnRTdGFibGUoIGEsIGIgKSB7XFxuXFxuXFx0XFx0aWYgKCBhLnJlbmRlck9yZGVyICE9PSBiLnJlbmRlck9yZGVyICkge1xcblxcblxcdFxcdFxcdHJldHVybiBhLnJlbmRlck9yZGVyIC0gYi5yZW5kZXJPcmRlcjtcXG5cXG5cXHRcXHR9IGVsc2UgaWYgKCBhLnByb2dyYW0gJiYgYi5wcm9ncmFtICYmIGEucHJvZ3JhbSAhPT0gYi5wcm9ncmFtICkge1xcblxcblxcdFxcdFxcdHJldHVybiBhLnByb2dyYW0uaWQgLSBiLnByb2dyYW0uaWQ7XFxuXFxuXFx0XFx0fSBlbHNlIGlmICggYS5tYXRlcmlhbC5pZCAhPT0gYi5tYXRlcmlhbC5pZCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYS5tYXRlcmlhbC5pZCAtIGIubWF0ZXJpYWwuaWQ7XFxuXFxuXFx0XFx0fSBlbHNlIGlmICggYS56ICE9PSBiLnogKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGEueiAtIGIuejtcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdHJldHVybiBhLmlkIC0gYi5pZDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHJldmVyc2VQYWludGVyU29ydFN0YWJsZSggYSwgYiApIHtcXG5cXG5cXHRcXHRpZiAoIGEucmVuZGVyT3JkZXIgIT09IGIucmVuZGVyT3JkZXIgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGEucmVuZGVyT3JkZXIgLSBiLnJlbmRlck9yZGVyO1xcblxcblxcdFxcdH0gaWYgKCBhLnogIT09IGIueiApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYi56IC0gYS56O1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGEuaWQgLSBiLmlkO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gV2ViR0xSZW5kZXJMaXN0KCkge1xcblxcblxcdFxcdHZhciByZW5kZXJJdGVtcyA9IFtdO1xcblxcdFxcdHZhciByZW5kZXJJdGVtc0luZGV4ID0gMDtcXG5cXG5cXHRcXHR2YXIgb3BhcXVlID0gW107XFxuXFx0XFx0dmFyIHRyYW5zcGFyZW50ID0gW107XFxuXFxuXFx0XFx0ZnVuY3Rpb24gaW5pdCgpIHtcXG5cXG5cXHRcXHRcXHRyZW5kZXJJdGVtc0luZGV4ID0gMDtcXG5cXG5cXHRcXHRcXHRvcGFxdWUubGVuZ3RoID0gMDtcXG5cXHRcXHRcXHR0cmFuc3BhcmVudC5sZW5ndGggPSAwO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBwdXNoKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgeiwgZ3JvdXAgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJlbmRlckl0ZW0gPSByZW5kZXJJdGVtc1sgcmVuZGVySXRlbXNJbmRleCBdO1xcblxcblxcdFxcdFxcdGlmICggcmVuZGVySXRlbSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHJlbmRlckl0ZW0gPSB7XFxuXFx0XFx0XFx0XFx0XFx0aWQ6IG9iamVjdC5pZCxcXG5cXHRcXHRcXHRcXHRcXHRvYmplY3Q6IG9iamVjdCxcXG5cXHRcXHRcXHRcXHRcXHRnZW9tZXRyeTogZ2VvbWV0cnksXFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWw6IG1hdGVyaWFsLFxcblxcdFxcdFxcdFxcdFxcdHByb2dyYW06IG1hdGVyaWFsLnByb2dyYW0sXFxuXFx0XFx0XFx0XFx0XFx0cmVuZGVyT3JkZXI6IG9iamVjdC5yZW5kZXJPcmRlcixcXG5cXHRcXHRcXHRcXHRcXHR6OiB6LFxcblxcdFxcdFxcdFxcdFxcdGdyb3VwOiBncm91cFxcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0cmVuZGVySXRlbXNbIHJlbmRlckl0ZW1zSW5kZXggXSA9IHJlbmRlckl0ZW07XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRyZW5kZXJJdGVtLmlkID0gb2JqZWN0LmlkO1xcblxcdFxcdFxcdFxcdHJlbmRlckl0ZW0ub2JqZWN0ID0gb2JqZWN0O1xcblxcdFxcdFxcdFxcdHJlbmRlckl0ZW0uZ2VvbWV0cnkgPSBnZW9tZXRyeTtcXG5cXHRcXHRcXHRcXHRyZW5kZXJJdGVtLm1hdGVyaWFsID0gbWF0ZXJpYWw7XFxuXFx0XFx0XFx0XFx0cmVuZGVySXRlbS5wcm9ncmFtID0gbWF0ZXJpYWwucHJvZ3JhbTtcXG5cXHRcXHRcXHRcXHRyZW5kZXJJdGVtLnJlbmRlck9yZGVyID0gb2JqZWN0LnJlbmRlck9yZGVyO1xcblxcdFxcdFxcdFxcdHJlbmRlckl0ZW0ueiA9IHo7XFxuXFx0XFx0XFx0XFx0cmVuZGVySXRlbS5ncm91cCA9IGdyb3VwO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQoIG1hdGVyaWFsLnRyYW5zcGFyZW50ID09PSB0cnVlID8gdHJhbnNwYXJlbnQgOiBvcGFxdWUgKS5wdXNoKCByZW5kZXJJdGVtICk7XFxuXFxuXFx0XFx0XFx0cmVuZGVySXRlbXNJbmRleCArKztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc29ydCgpIHtcXG5cXG5cXHRcXHRcXHRpZiAoIG9wYXF1ZS5sZW5ndGggPiAxICkgb3BhcXVlLnNvcnQoIHBhaW50ZXJTb3J0U3RhYmxlICk7XFxuXFx0XFx0XFx0aWYgKCB0cmFuc3BhcmVudC5sZW5ndGggPiAxICkgdHJhbnNwYXJlbnQuc29ydCggcmV2ZXJzZVBhaW50ZXJTb3J0U3RhYmxlICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0b3BhcXVlOiBvcGFxdWUsXFxuXFx0XFx0XFx0dHJhbnNwYXJlbnQ6IHRyYW5zcGFyZW50LFxcblxcblxcdFxcdFxcdGluaXQ6IGluaXQsXFxuXFx0XFx0XFx0cHVzaDogcHVzaCxcXG5cXG5cXHRcXHRcXHRzb3J0OiBzb3J0XFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gV2ViR0xSZW5kZXJMaXN0cygpIHtcXG5cXG5cXHRcXHR2YXIgbGlzdHMgPSB7fTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBnZXQoIHNjZW5lLCBjYW1lcmEgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGhhc2ggPSBzY2VuZS5pZCArICcsJyArIGNhbWVyYS5pZDtcXG5cXHRcXHRcXHR2YXIgbGlzdCA9IGxpc3RzWyBoYXNoIF07XFxuXFxuXFx0XFx0XFx0aWYgKCBsaXN0ID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlckxpc3RzOicsIGhhc2ggKTtcXG5cXG5cXHRcXHRcXHRcXHRsaXN0ID0gbmV3IFdlYkdMUmVuZGVyTGlzdCgpO1xcblxcdFxcdFxcdFxcdGxpc3RzWyBoYXNoIF0gPSBsaXN0O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gbGlzdDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZGlzcG9zZSgpIHtcXG5cXG5cXHRcXHRcXHRsaXN0cyA9IHt9O1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdGdldDogZ2V0LFxcblxcdFxcdFxcdGRpc3Bvc2U6IGRpc3Bvc2VcXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIGFic051bWVyaWNhbFNvcnQoIGEsIGIgKSB7XFxuXFxuXFx0XFx0cmV0dXJuIE1hdGguYWJzKCBiWyAxIF0gKSAtIE1hdGguYWJzKCBhWyAxIF0gKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gV2ViR0xNb3JwaHRhcmdldHMoIGdsICkge1xcblxcblxcdFxcdHZhciBpbmZsdWVuY2VzTGlzdCA9IHt9O1xcblxcdFxcdHZhciBtb3JwaEluZmx1ZW5jZXMgPSBuZXcgRmxvYXQzMkFycmF5KCA4ICk7XFxuXFxuXFx0XFx0ZnVuY3Rpb24gdXBkYXRlKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcHJvZ3JhbSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgb2JqZWN0SW5mbHVlbmNlcyA9IG9iamVjdC5tb3JwaFRhcmdldEluZmx1ZW5jZXM7XFxuXFxuXFx0XFx0XFx0dmFyIGxlbmd0aCA9IG9iamVjdEluZmx1ZW5jZXMubGVuZ3RoO1xcblxcblxcdFxcdFxcdHZhciBpbmZsdWVuY2VzID0gaW5mbHVlbmNlc0xpc3RbIGdlb21ldHJ5LmlkIF07XFxuXFxuXFx0XFx0XFx0aWYgKCBpbmZsdWVuY2VzID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gaW5pdGlhbGlzZSBsaXN0XFxuXFxuXFx0XFx0XFx0XFx0aW5mbHVlbmNlcyA9IFtdO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpbmZsdWVuY2VzWyBpIF0gPSBbIGksIDAgXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aW5mbHVlbmNlc0xpc3RbIGdlb21ldHJ5LmlkIF0gPSBpbmZsdWVuY2VzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgbW9ycGhUYXJnZXRzID0gbWF0ZXJpYWwubW9ycGhUYXJnZXRzICYmIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5wb3NpdGlvbjtcXG5cXHRcXHRcXHR2YXIgbW9ycGhOb3JtYWxzID0gbWF0ZXJpYWwubW9ycGhOb3JtYWxzICYmIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy5ub3JtYWw7XFxuXFxuXFx0XFx0XFx0Ly8gUmVtb3ZlIGN1cnJlbnQgbW9ycGhBdHRyaWJ1dGVzXFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBpbmZsdWVuY2UgPSBpbmZsdWVuY2VzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpbmZsdWVuY2VbIDEgXSAhPT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG1vcnBoVGFyZ2V0cyApIGdlb21ldHJ5LnJlbW92ZUF0dHJpYnV0ZSggJ21vcnBoVGFyZ2V0JyArIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG1vcnBoTm9ybWFscyApIGdlb21ldHJ5LnJlbW92ZUF0dHJpYnV0ZSggJ21vcnBoTm9ybWFsJyArIGkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENvbGxlY3QgaW5mbHVlbmNlc1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgaW5mbHVlbmNlID0gaW5mbHVlbmNlc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdGluZmx1ZW5jZVsgMCBdID0gaTtcXG5cXHRcXHRcXHRcXHRpbmZsdWVuY2VbIDEgXSA9IG9iamVjdEluZmx1ZW5jZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aW5mbHVlbmNlcy5zb3J0KCBhYnNOdW1lcmljYWxTb3J0ICk7XFxuXFxuXFx0XFx0XFx0Ly8gQWRkIG1vcnBoQXR0cmlidXRlc1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IDg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGluZmx1ZW5jZSA9IGluZmx1ZW5jZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGluZmx1ZW5jZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgaW5kZXggPSBpbmZsdWVuY2VbIDAgXTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdmFsdWUgPSBpbmZsdWVuY2VbIDEgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggbW9ycGhUYXJnZXRzICkgZ2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnbW9ycGhUYXJnZXQnICsgaSwgbW9ycGhUYXJnZXRzWyBpbmRleCBdICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBtb3JwaE5vcm1hbHMgKSBnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdtb3JwaE5vcm1hbCcgKyBpLCBtb3JwaE5vcm1hbHNbIGluZGV4IF0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRtb3JwaEluZmx1ZW5jZXNbIGkgXSA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0bW9ycGhJbmZsdWVuY2VzWyBpIF0gPSAwO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRwcm9ncmFtLmdldFVuaWZvcm1zKCkuc2V0VmFsdWUoIGdsLCAnbW9ycGhUYXJnZXRJbmZsdWVuY2VzJywgbW9ycGhJbmZsdWVuY2VzICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB7XFxuXFxuXFx0XFx0XFx0dXBkYXRlOiB1cGRhdGVcXG5cXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFdlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyKCBnbCwgZXh0ZW5zaW9ucywgaW5mb1JlbmRlciApIHtcXG5cXG5cXHRcXHR2YXIgbW9kZTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBzZXRNb2RlKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRtb2RlID0gdmFsdWU7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHZhciB0eXBlLCBieXRlc1BlckVsZW1lbnQ7XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2V0SW5kZXgoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHR5cGUgPSB2YWx1ZS50eXBlO1xcblxcdFxcdFxcdGJ5dGVzUGVyRWxlbWVudCA9IHZhbHVlLmJ5dGVzUGVyRWxlbWVudDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVuZGVyKCBzdGFydCwgY291bnQgKSB7XFxuXFxuXFx0XFx0XFx0Z2wuZHJhd0VsZW1lbnRzKCBtb2RlLCBjb3VudCwgdHlwZSwgc3RhcnQgKiBieXRlc1BlckVsZW1lbnQgKTtcXG5cXG5cXHRcXHRcXHRpbmZvUmVuZGVyLmNhbGxzICsrO1xcblxcdFxcdFxcdGluZm9SZW5kZXIudmVydGljZXMgKz0gY291bnQ7XFxuXFxuXFx0XFx0XFx0aWYgKCBtb2RlID09PSBnbC5UUklBTkdMRVMgKSBpbmZvUmVuZGVyLmZhY2VzICs9IGNvdW50IC8gMztcXG5cXHRcXHRcXHRlbHNlIGlmICggbW9kZSA9PT0gZ2wuUE9JTlRTICkgaW5mb1JlbmRlci5wb2ludHMgKz0gY291bnQ7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHJlbmRlckluc3RhbmNlcyggZ2VvbWV0cnksIHN0YXJ0LCBjb3VudCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xcblxcblxcdFxcdFxcdGlmICggZXh0ZW5zaW9uID09PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTEluZGV4ZWRCdWZmZXJSZW5kZXJlcjogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZXh0ZW5zaW9uLmRyYXdFbGVtZW50c0luc3RhbmNlZEFOR0xFKCBtb2RlLCBjb3VudCwgdHlwZSwgc3RhcnQgKiBieXRlc1BlckVsZW1lbnQsIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICk7XFxuXFxuXFx0XFx0XFx0aW5mb1JlbmRlci5jYWxscyArKztcXG5cXHRcXHRcXHRpbmZvUmVuZGVyLnZlcnRpY2VzICs9IGNvdW50ICogZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQ7XFxuXFxuXFx0XFx0XFx0aWYgKCBtb2RlID09PSBnbC5UUklBTkdMRVMgKSBpbmZvUmVuZGVyLmZhY2VzICs9IGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICogY291bnQgLyAzO1xcblxcdFxcdFxcdGVsc2UgaWYgKCBtb2RlID09PSBnbC5QT0lOVFMgKSBpbmZvUmVuZGVyLnBvaW50cyArPSBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCAqIGNvdW50O1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvL1xcblxcblxcdFxcdHRoaXMuc2V0TW9kZSA9IHNldE1vZGU7XFxuXFx0XFx0dGhpcy5zZXRJbmRleCA9IHNldEluZGV4O1xcblxcdFxcdHRoaXMucmVuZGVyID0gcmVuZGVyO1xcblxcdFxcdHRoaXMucmVuZGVySW5zdGFuY2VzID0gcmVuZGVySW5zdGFuY2VzO1xcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFdlYkdMQnVmZmVyUmVuZGVyZXIoIGdsLCBleHRlbnNpb25zLCBpbmZvUmVuZGVyICkge1xcblxcblxcdFxcdHZhciBtb2RlO1xcblxcblxcdFxcdGZ1bmN0aW9uIHNldE1vZGUoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdG1vZGUgPSB2YWx1ZTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVuZGVyKCBzdGFydCwgY291bnQgKSB7XFxuXFxuXFx0XFx0XFx0Z2wuZHJhd0FycmF5cyggbW9kZSwgc3RhcnQsIGNvdW50ICk7XFxuXFxuXFx0XFx0XFx0aW5mb1JlbmRlci5jYWxscyArKztcXG5cXHRcXHRcXHRpbmZvUmVuZGVyLnZlcnRpY2VzICs9IGNvdW50O1xcblxcblxcdFxcdFxcdGlmICggbW9kZSA9PT0gZ2wuVFJJQU5HTEVTICkgaW5mb1JlbmRlci5mYWNlcyArPSBjb3VudCAvIDM7XFxuXFx0XFx0XFx0ZWxzZSBpZiAoIG1vZGUgPT09IGdsLlBPSU5UUyApIGluZm9SZW5kZXIucG9pbnRzICs9IGNvdW50O1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiByZW5kZXJJbnN0YW5jZXMoIGdlb21ldHJ5LCBzdGFydCwgY291bnQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnQU5HTEVfaW5zdGFuY2VkX2FycmF5cycgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xCdWZmZXJSZW5kZXJlcjogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcXG5cXG5cXHRcXHRcXHRpZiAoIHBvc2l0aW9uLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y291bnQgPSBwb3NpdGlvbi5kYXRhLmNvdW50O1xcblxcblxcdFxcdFxcdFxcdGV4dGVuc2lvbi5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUoIG1vZGUsIDAsIGNvdW50LCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0ZXh0ZW5zaW9uLmRyYXdBcnJheXNJbnN0YW5jZWRBTkdMRSggbW9kZSwgc3RhcnQsIGNvdW50LCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpbmZvUmVuZGVyLmNhbGxzICsrO1xcblxcdFxcdFxcdGluZm9SZW5kZXIudmVydGljZXMgKz0gY291bnQgKiBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudDtcXG5cXG5cXHRcXHRcXHRpZiAoIG1vZGUgPT09IGdsLlRSSUFOR0xFUyApIGluZm9SZW5kZXIuZmFjZXMgKz0gZ2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgKiBjb3VudCAvIDM7XFxuXFx0XFx0XFx0ZWxzZSBpZiAoIG1vZGUgPT09IGdsLlBPSU5UUyApIGluZm9SZW5kZXIucG9pbnRzICs9IGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ICogY291bnQ7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vXFxuXFxuXFx0XFx0dGhpcy5zZXRNb2RlID0gc2V0TW9kZTtcXG5cXHRcXHR0aGlzLnJlbmRlciA9IHJlbmRlcjtcXG5cXHRcXHR0aGlzLnJlbmRlckluc3RhbmNlcyA9IHJlbmRlckluc3RhbmNlcztcXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBXZWJHTEdlb21ldHJpZXMoIGdsLCBhdHRyaWJ1dGVzLCBpbmZvTWVtb3J5ICkge1xcblxcblxcdFxcdHZhciBnZW9tZXRyaWVzID0ge307XFxuXFx0XFx0dmFyIHdpcmVmcmFtZUF0dHJpYnV0ZXMgPSB7fTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBvbkdlb21ldHJ5RGlzcG9zZSggZXZlbnQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gZXZlbnQudGFyZ2V0O1xcblxcdFxcdFxcdHZhciBidWZmZXJnZW9tZXRyeSA9IGdlb21ldHJpZXNbIGdlb21ldHJ5LmlkIF07XFxuXFxuXFx0XFx0XFx0aWYgKCBidWZmZXJnZW9tZXRyeS5pbmRleCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGVzLnJlbW92ZSggYnVmZmVyZ2VvbWV0cnkuaW5kZXggKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIG5hbWUgaW4gYnVmZmVyZ2VvbWV0cnkuYXR0cmlidXRlcyApIHtcXG5cXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGVzLnJlbW92ZSggYnVmZmVyZ2VvbWV0cnkuYXR0cmlidXRlc1sgbmFtZSBdICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGdlb21ldHJ5LnJlbW92ZUV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcXG5cXG5cXHRcXHRcXHRkZWxldGUgZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXTtcXG5cXG5cXHRcXHRcXHQvLyBUT0RPIFJlbW92ZSBkdXBsaWNhdGUgY29kZVxcblxcblxcdFxcdFxcdHZhciBhdHRyaWJ1dGUgPSB3aXJlZnJhbWVBdHRyaWJ1dGVzWyBnZW9tZXRyeS5pZCBdO1xcblxcblxcdFxcdFxcdGlmICggYXR0cmlidXRlICkge1xcblxcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZXMucmVtb3ZlKCBhdHRyaWJ1dGUgKTtcXG5cXHRcXHRcXHRcXHRkZWxldGUgd2lyZWZyYW1lQXR0cmlidXRlc1sgZ2VvbWV0cnkuaWQgXTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0YXR0cmlidXRlID0gd2lyZWZyYW1lQXR0cmlidXRlc1sgYnVmZmVyZ2VvbWV0cnkuaWQgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIGF0dHJpYnV0ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRhdHRyaWJ1dGVzLnJlbW92ZSggYXR0cmlidXRlICk7XFxuXFx0XFx0XFx0XFx0ZGVsZXRlIHdpcmVmcmFtZUF0dHJpYnV0ZXNbIGJ1ZmZlcmdlb21ldHJ5LmlkIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vXFxuXFxuXFx0XFx0XFx0aW5mb01lbW9yeS5nZW9tZXRyaWVzIC0tO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBnZXQoIG9iamVjdCwgZ2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cmllc1sgZ2VvbWV0cnkuaWQgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIGJ1ZmZlcmdlb21ldHJ5ICkgcmV0dXJuIGJ1ZmZlcmdlb21ldHJ5O1xcblxcblxcdFxcdFxcdGdlb21ldHJ5LmFkZEV2ZW50TGlzdGVuZXIoICdkaXNwb3NlJywgb25HZW9tZXRyeURpc3Bvc2UgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YnVmZmVyZ2VvbWV0cnkgPSBnZW9tZXRyeTtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBnZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5ID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCkuc2V0RnJvbU9iamVjdCggb2JqZWN0ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cnkuX2J1ZmZlckdlb21ldHJ5O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRnZW9tZXRyaWVzWyBnZW9tZXRyeS5pZCBdID0gYnVmZmVyZ2VvbWV0cnk7XFxuXFxuXFx0XFx0XFx0aW5mb01lbW9yeS5nZW9tZXRyaWVzICsrO1xcblxcblxcdFxcdFxcdHJldHVybiBidWZmZXJnZW9tZXRyeTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gdXBkYXRlKCBnZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcXG5cXHRcXHRcXHR2YXIgZ2VvbWV0cnlBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcXG5cXG5cXHRcXHRcXHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZXMudXBkYXRlKCBpbmRleCwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIG5hbWUgaW4gZ2VvbWV0cnlBdHRyaWJ1dGVzICkge1xcblxcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZXMudXBkYXRlKCBnZW9tZXRyeUF0dHJpYnV0ZXNbIG5hbWUgXSwgZ2wuQVJSQVlfQlVGRkVSICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIG1vcnBoIHRhcmdldHNcXG5cXG5cXHRcXHRcXHR2YXIgbW9ycGhBdHRyaWJ1dGVzID0gZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBuYW1lIGluIG1vcnBoQXR0cmlidXRlcyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYXJyYXkgPSBtb3JwaEF0dHJpYnV0ZXNbIG5hbWUgXTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBhcnJheS5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGF0dHJpYnV0ZXMudXBkYXRlKCBhcnJheVsgaSBdLCBnbC5BUlJBWV9CVUZGRVIgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBnZXRXaXJlZnJhbWVBdHRyaWJ1dGUoIGdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdHZhciBhdHRyaWJ1dGUgPSB3aXJlZnJhbWVBdHRyaWJ1dGVzWyBnZW9tZXRyeS5pZCBdO1xcblxcblxcdFxcdFxcdGlmICggYXR0cmlidXRlICkgcmV0dXJuIGF0dHJpYnV0ZTtcXG5cXG5cXHRcXHRcXHR2YXIgaW5kaWNlcyA9IFtdO1xcblxcblxcdFxcdFxcdHZhciBnZW9tZXRyeUluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XFxuXFx0XFx0XFx0dmFyIGdlb21ldHJ5QXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XFxuXFxuXFx0XFx0XFx0Ly8gY29uc29sZS50aW1lKCAnd2lyZWZyYW1lJyApO1xcblxcblxcdFxcdFxcdGlmICggZ2VvbWV0cnlJbmRleCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYXJyYXkgPSBnZW9tZXRyeUluZGV4LmFycmF5O1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGFycmF5Lmxlbmd0aDsgaSA8IGw7IGkgKz0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgYSA9IGFycmF5WyBpICsgMCBdO1xcblxcdFxcdFxcdFxcdFxcdHZhciBiID0gYXJyYXlbIGkgKyAxIF07XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGMgPSBhcnJheVsgaSArIDIgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGEsIGIsIGIsIGMsIGMsIGEgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYXJyYXkgPSBnZW9tZXRyeUF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gKCBhcnJheS5sZW5ndGggLyAzICkgLSAxOyBpIDwgbDsgaSArPSAzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBhID0gaSArIDA7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGIgPSBpICsgMTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYyA9IGkgKyAyO1xcblxcblxcdFxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYSwgYiwgYiwgYywgYywgYSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gY29uc29sZS50aW1lRW5kKCAnd2lyZWZyYW1lJyApO1xcblxcblxcdFxcdFxcdGF0dHJpYnV0ZSA9IG5ldyAoIGFycmF5TWF4KCBpbmRpY2VzICkgPiA2NTUzNSA/IFVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSA6IFVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSApKCBpbmRpY2VzLCAxICk7XFxuXFxuXFx0XFx0XFx0YXR0cmlidXRlcy51cGRhdGUoIGF0dHJpYnV0ZSwgZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIgKTtcXG5cXG5cXHRcXHRcXHR3aXJlZnJhbWVBdHRyaWJ1dGVzWyBnZW9tZXRyeS5pZCBdID0gYXR0cmlidXRlO1xcblxcblxcdFxcdFxcdHJldHVybiBhdHRyaWJ1dGU7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB7XFxuXFxuXFx0XFx0XFx0Z2V0OiBnZXQsXFxuXFx0XFx0XFx0dXBkYXRlOiB1cGRhdGUsXFxuXFxuXFx0XFx0XFx0Z2V0V2lyZWZyYW1lQXR0cmlidXRlOiBnZXRXaXJlZnJhbWVBdHRyaWJ1dGVcXG5cXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFVuaWZvcm1zQ2FjaGUoKSB7XFxuXFxuXFx0XFx0dmFyIGxpZ2h0cyA9IHt9O1xcblxcblxcdFxcdHJldHVybiB7XFxuXFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoIGxpZ2h0ICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggbGlnaHRzWyBsaWdodC5pZCBdICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGxpZ2h0c1sgbGlnaHQuaWQgXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHVuaWZvcm1zO1xcblxcblxcdFxcdFxcdFxcdHN3aXRjaCAoIGxpZ2h0LnR5cGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnRGlyZWN0aW9uYWxMaWdodCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMgPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygpLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbG9yOiBuZXcgQ29sb3IoKSxcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3c6IGZhbHNlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvd0JpYXM6IDAsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93UmFkaXVzOiAxLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvd01hcFNpemU6IG5ldyBWZWN0b3IyKClcXG5cXHRcXHRcXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ1Nwb3RMaWdodCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMgPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb246IG5ldyBWZWN0b3IzKCksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlyZWN0aW9uOiBuZXcgVmVjdG9yMygpLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbG9yOiBuZXcgQ29sb3IoKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkaXN0YW5jZTogMCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb25lQ29zOiAwLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBlbnVtYnJhQ29zOiAwLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRlY2F5OiAwLFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvdzogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93QmlhczogMCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3dSYWRpdXM6IDEsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93TWFwU2l6ZTogbmV3IFZlY3RvcjIoKVxcblxcdFxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnUG9pbnRMaWdodCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMgPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb246IG5ldyBWZWN0b3IzKCksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29sb3I6IG5ldyBDb2xvcigpLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpc3RhbmNlOiAwLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRlY2F5OiAwLFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvdzogZmFsc2UsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93QmlhczogMCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3dSYWRpdXM6IDEsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2hhZG93TWFwU2l6ZTogbmV3IFZlY3RvcjIoKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3dDYW1lcmFOZWFyOiAxLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNoYWRvd0NhbWVyYUZhcjogMTAwMFxcblxcdFxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnSGVtaXNwaGVyZUxpZ2h0JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3JtcyA9IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkaXJlY3Rpb246IG5ldyBWZWN0b3IzKCksXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2t5Q29sb3I6IG5ldyBDb2xvcigpLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdyb3VuZENvbG9yOiBuZXcgQ29sb3IoKVxcblxcdFxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnUmVjdEFyZWFMaWdodCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMgPSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29sb3I6IG5ldyBDb2xvcigpLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uOiBuZXcgVmVjdG9yMygpLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGhhbGZXaWR0aDogbmV3IFZlY3RvcjMoKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRoYWxmSGVpZ2h0OiBuZXcgVmVjdG9yMygpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IHNldCBSZWN0QXJlYUxpZ2h0IHNoYWRvdyB1bmlmb3Jtc1xcblxcdFxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGxpZ2h0c1sgbGlnaHQuaWQgXSA9IHVuaWZvcm1zO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB1bmlmb3JtcztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gV2ViR0xMaWdodHMoKSB7XFxuXFxuXFx0XFx0dmFyIGNhY2hlID0gbmV3IFVuaWZvcm1zQ2FjaGUoKTtcXG5cXG5cXHRcXHR2YXIgc3RhdGUgPSB7XFxuXFxuXFx0XFx0XFx0aGFzaDogJycsXFxuXFxuXFx0XFx0XFx0YW1iaWVudDogWyAwLCAwLCAwIF0sXFxuXFx0XFx0XFx0ZGlyZWN0aW9uYWw6IFtdLFxcblxcdFxcdFxcdGRpcmVjdGlvbmFsU2hhZG93TWFwOiBbXSxcXG5cXHRcXHRcXHRkaXJlY3Rpb25hbFNoYWRvd01hdHJpeDogW10sXFxuXFx0XFx0XFx0c3BvdDogW10sXFxuXFx0XFx0XFx0c3BvdFNoYWRvd01hcDogW10sXFxuXFx0XFx0XFx0c3BvdFNoYWRvd01hdHJpeDogW10sXFxuXFx0XFx0XFx0cmVjdEFyZWE6IFtdLFxcblxcdFxcdFxcdHBvaW50OiBbXSxcXG5cXHRcXHRcXHRwb2ludFNoYWRvd01hcDogW10sXFxuXFx0XFx0XFx0cG9pbnRTaGFkb3dNYXRyaXg6IFtdLFxcblxcdFxcdFxcdGhlbWk6IFtdXFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR2YXIgdmVjdG9yMyA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dmFyIG1hdHJpeDQgPSBuZXcgTWF0cml4NCgpO1xcblxcdFxcdHZhciBtYXRyaXg0MiA9IG5ldyBNYXRyaXg0KCk7XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2V0dXAoIGxpZ2h0cywgc2hhZG93cywgY2FtZXJhICkge1xcblxcblxcdFxcdFxcdHZhciByID0gMCwgZyA9IDAsIGIgPSAwO1xcblxcblxcdFxcdFxcdHZhciBkaXJlY3Rpb25hbExlbmd0aCA9IDA7XFxuXFx0XFx0XFx0dmFyIHBvaW50TGVuZ3RoID0gMDtcXG5cXHRcXHRcXHR2YXIgc3BvdExlbmd0aCA9IDA7XFxuXFx0XFx0XFx0dmFyIHJlY3RBcmVhTGVuZ3RoID0gMDtcXG5cXHRcXHRcXHR2YXIgaGVtaUxlbmd0aCA9IDA7XFxuXFxuXFx0XFx0XFx0dmFyIHZpZXdNYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGxpZ2h0cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBsaWdodCA9IGxpZ2h0c1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdHZhciBjb2xvciA9IGxpZ2h0LmNvbG9yO1xcblxcdFxcdFxcdFxcdHZhciBpbnRlbnNpdHkgPSBsaWdodC5pbnRlbnNpdHk7XFxuXFx0XFx0XFx0XFx0dmFyIGRpc3RhbmNlID0gbGlnaHQuZGlzdGFuY2U7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHNoYWRvd01hcCA9ICggbGlnaHQuc2hhZG93ICYmIGxpZ2h0LnNoYWRvdy5tYXAgKSA/IGxpZ2h0LnNoYWRvdy5tYXAudGV4dHVyZSA6IG51bGw7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBsaWdodC5pc0FtYmllbnRMaWdodCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyICs9IGNvbG9yLnIgKiBpbnRlbnNpdHk7XFxuXFx0XFx0XFx0XFx0XFx0ZyArPSBjb2xvci5nICogaW50ZW5zaXR5O1xcblxcdFxcdFxcdFxcdFxcdGIgKz0gY29sb3IuYiAqIGludGVuc2l0eTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBsaWdodC5pc0RpcmVjdGlvbmFsTGlnaHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHVuaWZvcm1zID0gY2FjaGUuZ2V0KCBsaWdodCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmNvbG9yLmNvcHkoIGxpZ2h0LmNvbG9yICkubXVsdGlwbHlTY2FsYXIoIGxpZ2h0LmludGVuc2l0eSApO1xcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XFxuXFx0XFx0XFx0XFx0XFx0dmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpcmVjdGlvbi5zdWIoIHZlY3RvcjMgKTtcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXJlY3Rpb24udHJhbnNmb3JtRGlyZWN0aW9uKCB2aWV3TWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuc2hhZG93ID0gbGlnaHQuY2FzdFNoYWRvdztcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHNoYWRvdyA9IGxpZ2h0LnNoYWRvdztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5zaGFkb3dCaWFzID0gc2hhZG93LmJpYXM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuc2hhZG93UmFkaXVzID0gc2hhZG93LnJhZGl1cztcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gc2hhZG93Lm1hcFNpemU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWFwWyBkaXJlY3Rpb25hbExlbmd0aCBdID0gc2hhZG93TWFwO1xcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmRpcmVjdGlvbmFsU2hhZG93TWF0cml4WyBkaXJlY3Rpb25hbExlbmd0aCBdID0gbGlnaHQuc2hhZG93Lm1hdHJpeDtcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5kaXJlY3Rpb25hbFsgZGlyZWN0aW9uYWxMZW5ndGggXSA9IHVuaWZvcm1zO1xcblxcblxcdFxcdFxcdFxcdFxcdGRpcmVjdGlvbmFsTGVuZ3RoICsrO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzU3BvdExpZ2h0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB1bmlmb3JtcyA9IGNhY2hlLmdldCggbGlnaHQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5wb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMucG9zaXRpb24uYXBwbHlNYXRyaXg0KCB2aWV3TWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuY29sb3IuY29weSggY29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXJlY3Rpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdFxcdFxcdHZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXJlY3Rpb24uc3ViKCB2ZWN0b3IzICk7XFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmNvbmVDb3MgPSBNYXRoLmNvcyggbGlnaHQuYW5nbGUgKTtcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5wZW51bWJyYUNvcyA9IE1hdGguY29zKCBsaWdodC5hbmdsZSAqICggMSAtIGxpZ2h0LnBlbnVtYnJhICkgKTtcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5kZWNheSA9ICggbGlnaHQuZGlzdGFuY2UgPT09IDAgKSA/IDAuMCA6IGxpZ2h0LmRlY2F5O1xcblxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnNoYWRvdyA9IGxpZ2h0LmNhc3RTaGFkb3c7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBsaWdodC5jYXN0U2hhZG93ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBzaGFkb3cgPSBsaWdodC5zaGFkb3c7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuc2hhZG93QmlhcyA9IHNoYWRvdy5iaWFzO1xcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnNoYWRvd1JhZGl1cyA9IHNoYWRvdy5yYWRpdXM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuc2hhZG93TWFwU2l6ZSA9IHNoYWRvdy5tYXBTaXplO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5zcG90U2hhZG93TWFwWyBzcG90TGVuZ3RoIF0gPSBzaGFkb3dNYXA7XFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuc3BvdFNoYWRvd01hdHJpeFsgc3BvdExlbmd0aCBdID0gbGlnaHQuc2hhZG93Lm1hdHJpeDtcXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5zcG90WyBzcG90TGVuZ3RoIF0gPSB1bmlmb3JtcztcXG5cXG5cXHRcXHRcXHRcXHRcXHRzcG90TGVuZ3RoICsrO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGxpZ2h0LmlzUmVjdEFyZWFMaWdodCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdW5pZm9ybXMgPSBjYWNoZS5nZXQoIGxpZ2h0ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gKGEpIGludGVuc2l0eSBjb250cm9scyBpcnJhZGlhbmNlIG9mIGVudGlyZSBsaWdodFxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmNvbG9yXFxuXFx0XFx0XFx0XFx0XFx0XFx0LmNvcHkoIGNvbG9yIClcXG5cXHRcXHRcXHRcXHRcXHRcXHQubXVsdGlwbHlTY2FsYXIoIGludGVuc2l0eSAvICggbGlnaHQud2lkdGggKiBsaWdodC5oZWlnaHQgKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIChiKSBpbnRlbnNpdHkgY29udHJvbHMgdGhlIHJhZGlhbmNlIHBlciBsaWdodCBhcmVhXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdW5pZm9ybXMuY29sb3IuY29weSggY29sb3IgKS5tdWx0aXBseVNjYWxhciggaW50ZW5zaXR5ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMucG9zaXRpb24uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBsaWdodC5tYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnBvc2l0aW9uLmFwcGx5TWF0cml4NCggdmlld01hdHJpeCApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGV4dHJhY3QgbG9jYWwgcm90YXRpb24gb2YgbGlnaHQgdG8gZGVyaXZlIHdpZHRoL2hlaWdodCBoYWxmIHZlY3RvcnNcXG5cXHRcXHRcXHRcXHRcXHRtYXRyaXg0Mi5pZGVudGl0eSgpO1xcblxcdFxcdFxcdFxcdFxcdG1hdHJpeDQuY29weSggbGlnaHQubWF0cml4V29ybGQgKTtcXG5cXHRcXHRcXHRcXHRcXHRtYXRyaXg0LnByZW11bHRpcGx5KCB2aWV3TWF0cml4ICk7XFxuXFx0XFx0XFx0XFx0XFx0bWF0cml4NDIuZXh0cmFjdFJvdGF0aW9uKCBtYXRyaXg0ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuaGFsZldpZHRoLnNldCggbGlnaHQud2lkdGggKiAwLjUsIDAuMCwgMC4wICk7XFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuaGFsZkhlaWdodC5zZXQoIDAuMCwgbGlnaHQuaGVpZ2h0ICogMC41LCAwLjAgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5oYWxmV2lkdGguYXBwbHlNYXRyaXg0KCBtYXRyaXg0MiApO1xcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmhhbGZIZWlnaHQuYXBwbHlNYXRyaXg0KCBtYXRyaXg0MiApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFRPRE8gKGFiZWxuYXRpb24pOiBSZWN0QXJlYUxpZ2h0IGRpc3RhbmNlP1xcblxcdFxcdFxcdFxcdFxcdC8vIHVuaWZvcm1zLmRpc3RhbmNlID0gZGlzdGFuY2U7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUucmVjdEFyZWFbIHJlY3RBcmVhTGVuZ3RoIF0gPSB1bmlmb3JtcztcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZWN0QXJlYUxlbmd0aCArKztcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBsaWdodC5pc1BvaW50TGlnaHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHVuaWZvcm1zID0gY2FjaGUuZ2V0KCBsaWdodCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLnBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbGlnaHQubWF0cml4V29ybGQgKTtcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5wb3NpdGlvbi5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5jb2xvci5jb3B5KCBsaWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCBsaWdodC5pbnRlbnNpdHkgKTtcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXN0YW5jZSA9IGxpZ2h0LmRpc3RhbmNlO1xcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmRlY2F5ID0gKCBsaWdodC5kaXN0YW5jZSA9PT0gMCApID8gMC4wIDogbGlnaHQuZGVjYXk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuc2hhZG93ID0gbGlnaHQuY2FzdFNoYWRvdztcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGxpZ2h0LmNhc3RTaGFkb3cgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHNoYWRvdyA9IGxpZ2h0LnNoYWRvdztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5zaGFkb3dCaWFzID0gc2hhZG93LmJpYXM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuc2hhZG93UmFkaXVzID0gc2hhZG93LnJhZGl1cztcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5zaGFkb3dNYXBTaXplID0gc2hhZG93Lm1hcFNpemU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuc2hhZG93Q2FtZXJhTmVhciA9IHNoYWRvdy5jYW1lcmEubmVhcjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5zaGFkb3dDYW1lcmFGYXIgPSBzaGFkb3cuY2FtZXJhLmZhcjtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUucG9pbnRTaGFkb3dNYXBbIHBvaW50TGVuZ3RoIF0gPSBzaGFkb3dNYXA7XFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUucG9pbnRTaGFkb3dNYXRyaXhbIHBvaW50TGVuZ3RoIF0gPSBsaWdodC5zaGFkb3cubWF0cml4O1xcblxcdFxcdFxcdFxcdFxcdHN0YXRlLnBvaW50WyBwb2ludExlbmd0aCBdID0gdW5pZm9ybXM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cG9pbnRMZW5ndGggKys7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbGlnaHQuaXNIZW1pc3BoZXJlTGlnaHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHVuaWZvcm1zID0gY2FjaGUuZ2V0KCBsaWdodCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpcmVjdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGxpZ2h0Lm1hdHJpeFdvcmxkICk7XFxuXFx0XFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlyZWN0aW9uLnRyYW5zZm9ybURpcmVjdGlvbiggdmlld01hdHJpeCApO1xcblxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpcmVjdGlvbi5ub3JtYWxpemUoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5za3lDb2xvci5jb3B5KCBsaWdodC5jb2xvciApLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgKTtcXG5cXHRcXHRcXHRcXHRcXHR1bmlmb3Jtcy5ncm91bmRDb2xvci5jb3B5KCBsaWdodC5ncm91bmRDb2xvciApLm11bHRpcGx5U2NhbGFyKCBpbnRlbnNpdHkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5oZW1pWyBoZW1pTGVuZ3RoIF0gPSB1bmlmb3JtcztcXG5cXG5cXHRcXHRcXHRcXHRcXHRoZW1pTGVuZ3RoICsrO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0c3RhdGUuYW1iaWVudFsgMCBdID0gcjtcXG5cXHRcXHRcXHRzdGF0ZS5hbWJpZW50WyAxIF0gPSBnO1xcblxcdFxcdFxcdHN0YXRlLmFtYmllbnRbIDIgXSA9IGI7XFxuXFxuXFx0XFx0XFx0c3RhdGUuZGlyZWN0aW9uYWwubGVuZ3RoID0gZGlyZWN0aW9uYWxMZW5ndGg7XFxuXFx0XFx0XFx0c3RhdGUuc3BvdC5sZW5ndGggPSBzcG90TGVuZ3RoO1xcblxcdFxcdFxcdHN0YXRlLnJlY3RBcmVhLmxlbmd0aCA9IHJlY3RBcmVhTGVuZ3RoO1xcblxcdFxcdFxcdHN0YXRlLnBvaW50Lmxlbmd0aCA9IHBvaW50TGVuZ3RoO1xcblxcdFxcdFxcdHN0YXRlLmhlbWkubGVuZ3RoID0gaGVtaUxlbmd0aDtcXG5cXG5cXHRcXHRcXHQvLyBUT0RPIChzYW0tZy1zdGVlbCkgd2h5IGFyZW4ndCB3ZSB1c2luZyBqb2luXFxuXFx0XFx0XFx0c3RhdGUuaGFzaCA9IGRpcmVjdGlvbmFsTGVuZ3RoICsgJywnICsgcG9pbnRMZW5ndGggKyAnLCcgKyBzcG90TGVuZ3RoICsgJywnICsgcmVjdEFyZWFMZW5ndGggKyAnLCcgKyBoZW1pTGVuZ3RoICsgJywnICsgc2hhZG93cy5sZW5ndGg7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0c2V0dXA6IHNldHVwLFxcblxcdFxcdFxcdHN0YXRlOiBzdGF0ZVxcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gV2ViR0xPYmplY3RzKCBnZW9tZXRyaWVzLCBpbmZvUmVuZGVyICkge1xcblxcblxcdFxcdHZhciB1cGRhdGVMaXN0ID0ge307XFxuXFxuXFx0XFx0ZnVuY3Rpb24gdXBkYXRlKCBvYmplY3QgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGZyYW1lID0gaW5mb1JlbmRlci5mcmFtZTtcXG5cXG5cXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XFxuXFx0XFx0XFx0dmFyIGJ1ZmZlcmdlb21ldHJ5ID0gZ2VvbWV0cmllcy5nZXQoIG9iamVjdCwgZ2VvbWV0cnkgKTtcXG5cXG5cXHRcXHRcXHQvLyBVcGRhdGUgb25jZSBwZXIgZnJhbWVcXG5cXG5cXHRcXHRcXHRpZiAoIHVwZGF0ZUxpc3RbIGJ1ZmZlcmdlb21ldHJ5LmlkIF0gIT09IGZyYW1lICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRidWZmZXJnZW9tZXRyeS51cGRhdGVGcm9tT2JqZWN0KCBvYmplY3QgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cmllcy51cGRhdGUoIGJ1ZmZlcmdlb21ldHJ5ICk7XFxuXFxuXFx0XFx0XFx0XFx0dXBkYXRlTGlzdFsgYnVmZmVyZ2VvbWV0cnkuaWQgXSA9IGZyYW1lO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gYnVmZmVyZ2VvbWV0cnk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGNsZWFyKCkge1xcblxcblxcdFxcdFxcdHVwZGF0ZUxpc3QgPSB7fTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHtcXG5cXG5cXHRcXHRcXHR1cGRhdGU6IHVwZGF0ZSxcXG5cXHRcXHRcXHRjbGVhcjogY2xlYXJcXG5cXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIGFkZExpbmVOdW1iZXJzKCBzdHJpbmcgKSB7XFxuXFxuXFx0XFx0dmFyIGxpbmVzID0gc3RyaW5nLnNwbGl0KCAnXFxcXG4nICk7XFxuXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdGxpbmVzWyBpIF0gPSAoIGkgKyAxICkgKyAnOiAnICsgbGluZXNbIGkgXTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGxpbmVzLmpvaW4oICdcXFxcbicgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gV2ViR0xTaGFkZXIoIGdsLCB0eXBlLCBzdHJpbmcgKSB7XFxuXFxuXFx0XFx0dmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggdHlwZSApO1xcblxcblxcdFxcdGdsLnNoYWRlclNvdXJjZSggc2hhZGVyLCBzdHJpbmcgKTtcXG5cXHRcXHRnbC5jb21waWxlU2hhZGVyKCBzaGFkZXIgKTtcXG5cXG5cXHRcXHRpZiAoIGdsLmdldFNoYWRlclBhcmFtZXRlciggc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUyApID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTaGFkZXI6IFNoYWRlciBjb3VsZG5cXFxcJ3QgY29tcGlsZS4nICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyICkgIT09ICcnICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMU2hhZGVyOiBnbC5nZXRTaGFkZXJJbmZvTG9nKCknLCB0eXBlID09PSBnbC5WRVJURVhfU0hBREVSID8gJ3ZlcnRleCcgOiAnZnJhZ21lbnQnLCBnbC5nZXRTaGFkZXJJbmZvTG9nKCBzaGFkZXIgKSwgYWRkTGluZU51bWJlcnMoIHN0cmluZyApICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIC0tZW5hYmxlLXByaXZpbGVnZWQtd2ViZ2wtZXh0ZW5zaW9uXFxuXFx0XFx0Ly8gY29uc29sZS5sb2coIHR5cGUsIGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2RlYnVnX3NoYWRlcnMnICkuZ2V0VHJhbnNsYXRlZFNoYWRlclNvdXJjZSggc2hhZGVyICkgKTtcXG5cXG5cXHRcXHRyZXR1cm4gc2hhZGVyO1xcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdHZhciBwcm9ncmFtSWRDb3VudCA9IDA7XFxuXFxuXFx0ZnVuY3Rpb24gZ2V0RW5jb2RpbmdDb21wb25lbnRzKCBlbmNvZGluZyApIHtcXG5cXG5cXHRcXHRzd2l0Y2ggKCBlbmNvZGluZyApIHtcXG5cXG5cXHRcXHRcXHRjYXNlIExpbmVhckVuY29kaW5nOlxcblxcdFxcdFxcdFxcdHJldHVybiBbICdMaW5lYXInLCAnKCB2YWx1ZSApJyBdO1xcblxcdFxcdFxcdGNhc2Ugc1JHQkVuY29kaW5nOlxcblxcdFxcdFxcdFxcdHJldHVybiBbICdzUkdCJywgJyggdmFsdWUgKScgXTtcXG5cXHRcXHRcXHRjYXNlIFJHQkVFbmNvZGluZzpcXG5cXHRcXHRcXHRcXHRyZXR1cm4gWyAnUkdCRScsICcoIHZhbHVlICknIF07XFxuXFx0XFx0XFx0Y2FzZSBSR0JNN0VuY29kaW5nOlxcblxcdFxcdFxcdFxcdHJldHVybiBbICdSR0JNJywgJyggdmFsdWUsIDcuMCApJyBdO1xcblxcdFxcdFxcdGNhc2UgUkdCTTE2RW5jb2Rpbmc6XFxuXFx0XFx0XFx0XFx0cmV0dXJuIFsgJ1JHQk0nLCAnKCB2YWx1ZSwgMTYuMCApJyBdO1xcblxcdFxcdFxcdGNhc2UgUkdCREVuY29kaW5nOlxcblxcdFxcdFxcdFxcdHJldHVybiBbICdSR0JEJywgJyggdmFsdWUsIDI1Ni4wICknIF07XFxuXFx0XFx0XFx0Y2FzZSBHYW1tYUVuY29kaW5nOlxcblxcdFxcdFxcdFxcdHJldHVybiBbICdHYW1tYScsICcoIHZhbHVlLCBmbG9hdCggR0FNTUFfRkFDVE9SICkgKScgXTtcXG5cXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggJ3Vuc3VwcG9ydGVkIGVuY29kaW5nOiAnICsgZW5jb2RpbmcgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGdldFRleGVsRGVjb2RpbmdGdW5jdGlvbiggZnVuY3Rpb25OYW1lLCBlbmNvZGluZyApIHtcXG5cXG5cXHRcXHR2YXIgY29tcG9uZW50cyA9IGdldEVuY29kaW5nQ29tcG9uZW50cyggZW5jb2RpbmcgKTtcXG5cXHRcXHRyZXR1cm4gJ3ZlYzQgJyArIGZ1bmN0aW9uTmFtZSArICcoIHZlYzQgdmFsdWUgKSB7IHJldHVybiAnICsgY29tcG9uZW50c1sgMCBdICsgJ1RvTGluZWFyJyArIGNvbXBvbmVudHNbIDEgXSArICc7IH0nO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBnZXRUZXhlbEVuY29kaW5nRnVuY3Rpb24oIGZ1bmN0aW9uTmFtZSwgZW5jb2RpbmcgKSB7XFxuXFxuXFx0XFx0dmFyIGNvbXBvbmVudHMgPSBnZXRFbmNvZGluZ0NvbXBvbmVudHMoIGVuY29kaW5nICk7XFxuXFx0XFx0cmV0dXJuICd2ZWM0ICcgKyBmdW5jdGlvbk5hbWUgKyAnKCB2ZWM0IHZhbHVlICkgeyByZXR1cm4gTGluZWFyVG8nICsgY29tcG9uZW50c1sgMCBdICsgY29tcG9uZW50c1sgMSBdICsgJzsgfSc7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGdldFRvbmVNYXBwaW5nRnVuY3Rpb24oIGZ1bmN0aW9uTmFtZSwgdG9uZU1hcHBpbmcgKSB7XFxuXFxuXFx0XFx0dmFyIHRvbmVNYXBwaW5nTmFtZTtcXG5cXG5cXHRcXHRzd2l0Y2ggKCB0b25lTWFwcGluZyApIHtcXG5cXG5cXHRcXHRcXHRjYXNlIExpbmVhclRvbmVNYXBwaW5nOlxcblxcdFxcdFxcdFxcdHRvbmVNYXBwaW5nTmFtZSA9ICdMaW5lYXInO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdGNhc2UgUmVpbmhhcmRUb25lTWFwcGluZzpcXG5cXHRcXHRcXHRcXHR0b25lTWFwcGluZ05hbWUgPSAnUmVpbmhhcmQnO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdGNhc2UgVW5jaGFydGVkMlRvbmVNYXBwaW5nOlxcblxcdFxcdFxcdFxcdHRvbmVNYXBwaW5nTmFtZSA9ICdVbmNoYXJ0ZWQyJztcXG5cXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRjYXNlIENpbmVvblRvbmVNYXBwaW5nOlxcblxcdFxcdFxcdFxcdHRvbmVNYXBwaW5nTmFtZSA9ICdPcHRpbWl6ZWRDaW5lb24nO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCAndW5zdXBwb3J0ZWQgdG9uZU1hcHBpbmc6ICcgKyB0b25lTWFwcGluZyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gJ3ZlYzMgJyArIGZ1bmN0aW9uTmFtZSArICcoIHZlYzMgY29sb3IgKSB7IHJldHVybiAnICsgdG9uZU1hcHBpbmdOYW1lICsgJ1RvbmVNYXBwaW5nKCBjb2xvciApOyB9JztcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gZ2VuZXJhdGVFeHRlbnNpb25zKCBleHRlbnNpb25zLCBwYXJhbWV0ZXJzLCByZW5kZXJlckV4dGVuc2lvbnMgKSB7XFxuXFxuXFx0XFx0ZXh0ZW5zaW9ucyA9IGV4dGVuc2lvbnMgfHwge307XFxuXFxuXFx0XFx0dmFyIGNodW5rcyA9IFtcXG5cXHRcXHRcXHQoIGV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMgfHwgcGFyYW1ldGVycy5lbnZNYXBDdWJlVVYgfHwgcGFyYW1ldGVycy5idW1wTWFwIHx8IHBhcmFtZXRlcnMubm9ybWFsTWFwIHx8IHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgKSA/ICcjZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZScgOiAnJyxcXG5cXHRcXHRcXHQoIGV4dGVuc2lvbnMuZnJhZ0RlcHRoIHx8IHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciApICYmIHJlbmRlcmVyRXh0ZW5zaW9ucy5nZXQoICdFWFRfZnJhZ19kZXB0aCcgKSA/ICcjZXh0ZW5zaW9uIEdMX0VYVF9mcmFnX2RlcHRoIDogZW5hYmxlJyA6ICcnLFxcblxcdFxcdFxcdCggZXh0ZW5zaW9ucy5kcmF3QnVmZmVycyApICYmIHJlbmRlcmVyRXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9kcmF3X2J1ZmZlcnMnICkgPyAnI2V4dGVuc2lvbiBHTF9FWFRfZHJhd19idWZmZXJzIDogcmVxdWlyZScgOiAnJyxcXG5cXHRcXHRcXHQoIGV4dGVuc2lvbnMuc2hhZGVyVGV4dHVyZUxPRCB8fCBwYXJhbWV0ZXJzLmVudk1hcCApICYmIHJlbmRlcmVyRXh0ZW5zaW9ucy5nZXQoICdFWFRfc2hhZGVyX3RleHR1cmVfbG9kJyApID8gJyNleHRlbnNpb24gR0xfRVhUX3NoYWRlcl90ZXh0dXJlX2xvZCA6IGVuYWJsZScgOiAnJ1xcblxcdFxcdF07XFxuXFxuXFx0XFx0cmV0dXJuIGNodW5rcy5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXFxcbicgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gZ2VuZXJhdGVEZWZpbmVzKCBkZWZpbmVzICkge1xcblxcblxcdFxcdHZhciBjaHVua3MgPSBbXTtcXG5cXG5cXHRcXHRmb3IgKCB2YXIgbmFtZSBpbiBkZWZpbmVzICkge1xcblxcblxcdFxcdFxcdHZhciB2YWx1ZSA9IGRlZmluZXNbIG5hbWUgXTtcXG5cXG5cXHRcXHRcXHRpZiAoIHZhbHVlID09PSBmYWxzZSApIGNvbnRpbnVlO1xcblxcblxcdFxcdFxcdGNodW5rcy5wdXNoKCAnI2RlZmluZSAnICsgbmFtZSArICcgJyArIHZhbHVlICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBjaHVua3Muam9pbiggJ1xcXFxuJyApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBmZXRjaEF0dHJpYnV0ZUxvY2F0aW9ucyggZ2wsIHByb2dyYW0gKSB7XFxuXFxuXFx0XFx0dmFyIGF0dHJpYnV0ZXMgPSB7fTtcXG5cXG5cXHRcXHR2YXIgbiA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkFDVElWRV9BVFRSSUJVVEVTICk7XFxuXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgbjsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgaW5mbyA9IGdsLmdldEFjdGl2ZUF0dHJpYiggcHJvZ3JhbSwgaSApO1xcblxcdFxcdFxcdHZhciBuYW1lID0gaW5mby5uYW1lO1xcblxcblxcdFxcdFxcdC8vIGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiBBQ1RJVkUgVkVSVEVYIEFUVFJJQlVURTonLCBuYW1lLCBpICk7XFxuXFxuXFx0XFx0XFx0YXR0cmlidXRlc1sgbmFtZSBdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHByb2dyYW0sIG5hbWUgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGF0dHJpYnV0ZXM7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGZpbHRlckVtcHR5TGluZSggc3RyaW5nICkge1xcblxcblxcdFxcdHJldHVybiBzdHJpbmcgIT09ICcnO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiByZXBsYWNlTGlnaHROdW1zKCBzdHJpbmcsIHBhcmFtZXRlcnMgKSB7XFxuXFxuXFx0XFx0cmV0dXJuIHN0cmluZ1xcblxcdFxcdFxcdC5yZXBsYWNlKCAvTlVNX0RJUl9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1EaXJMaWdodHMgKVxcblxcdFxcdFxcdC5yZXBsYWNlKCAvTlVNX1NQT1RfTElHSFRTL2csIHBhcmFtZXRlcnMubnVtU3BvdExpZ2h0cyApXFxuXFx0XFx0XFx0LnJlcGxhY2UoIC9OVU1fUkVDVF9BUkVBX0xJR0hUUy9nLCBwYXJhbWV0ZXJzLm51bVJlY3RBcmVhTGlnaHRzIClcXG5cXHRcXHRcXHQucmVwbGFjZSggL05VTV9QT0lOVF9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1Qb2ludExpZ2h0cyApXFxuXFx0XFx0XFx0LnJlcGxhY2UoIC9OVU1fSEVNSV9MSUdIVFMvZywgcGFyYW1ldGVycy5udW1IZW1pTGlnaHRzICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHBhcnNlSW5jbHVkZXMoIHN0cmluZyApIHtcXG5cXG5cXHRcXHR2YXIgcGF0dGVybiA9IC9eWyBcXFxcdF0qI2luY2x1ZGUgKzwoW1xcXFx3XFxcXGQuXSspPi9nbTtcXG5cXG5cXHRcXHRmdW5jdGlvbiByZXBsYWNlKCBtYXRjaCwgaW5jbHVkZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcmVwbGFjZSA9IFNoYWRlckNodW5rWyBpbmNsdWRlIF07XFxuXFxuXFx0XFx0XFx0aWYgKCByZXBsYWNlID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCAnQ2FuIG5vdCByZXNvbHZlICNpbmNsdWRlIDwnICsgaW5jbHVkZSArICc+JyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gcGFyc2VJbmNsdWRlcyggcmVwbGFjZSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoIHBhdHRlcm4sIHJlcGxhY2UgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gdW5yb2xsTG9vcHMoIHN0cmluZyApIHtcXG5cXG5cXHRcXHR2YXIgcGF0dGVybiA9IC9mb3IgXFxcXCggaW50IGkgXFxcXD0gKFxcXFxkKylcXFxcOyBpIDwgKFxcXFxkKylcXFxcOyBpIFxcXFwrXFxcXCsgXFxcXCkgXFxcXHsoW1xcXFxzXFxcXFNdKz8pKD89XFxcXH0pXFxcXH0vZztcXG5cXG5cXHRcXHRmdW5jdGlvbiByZXBsYWNlKCBtYXRjaCwgc3RhcnQsIGVuZCwgc25pcHBldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdW5yb2xsID0gJyc7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSBwYXJzZUludCggc3RhcnQgKTsgaSA8IHBhcnNlSW50KCBlbmQgKTsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bnJvbGwgKz0gc25pcHBldC5yZXBsYWNlKCAvXFxcXFsgaSBcXFxcXS9nLCAnWyAnICsgaSArICcgXScgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHVucm9sbDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKCBwYXR0ZXJuLCByZXBsYWNlICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFdlYkdMUHJvZ3JhbSggcmVuZGVyZXIsIGV4dGVuc2lvbnMsIGNvZGUsIG1hdGVyaWFsLCBzaGFkZXIsIHBhcmFtZXRlcnMgKSB7XFxuXFxuXFx0XFx0dmFyIGdsID0gcmVuZGVyZXIuY29udGV4dDtcXG5cXG5cXHRcXHR2YXIgZGVmaW5lcyA9IG1hdGVyaWFsLmRlZmluZXM7XFxuXFxuXFx0XFx0dmFyIHZlcnRleFNoYWRlciA9IHNoYWRlci52ZXJ0ZXhTaGFkZXI7XFxuXFx0XFx0dmFyIGZyYWdtZW50U2hhZGVyID0gc2hhZGVyLmZyYWdtZW50U2hhZGVyO1xcblxcblxcdFxcdHZhciBzaGFkb3dNYXBUeXBlRGVmaW5lID0gJ1NIQURPV01BUF9UWVBFX0JBU0lDJztcXG5cXG5cXHRcXHRpZiAoIHBhcmFtZXRlcnMuc2hhZG93TWFwVHlwZSA9PT0gUENGU2hhZG93TWFwICkge1xcblxcblxcdFxcdFxcdHNoYWRvd01hcFR5cGVEZWZpbmUgPSAnU0hBRE9XTUFQX1RZUEVfUENGJztcXG5cXG5cXHRcXHR9IGVsc2UgaWYgKCBwYXJhbWV0ZXJzLnNoYWRvd01hcFR5cGUgPT09IFBDRlNvZnRTaGFkb3dNYXAgKSB7XFxuXFxuXFx0XFx0XFx0c2hhZG93TWFwVHlwZURlZmluZSA9ICdTSEFET1dNQVBfVFlQRV9QQ0ZfU09GVCc7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHZhciBlbnZNYXBUeXBlRGVmaW5lID0gJ0VOVk1BUF9UWVBFX0NVQkUnO1xcblxcdFxcdHZhciBlbnZNYXBNb2RlRGVmaW5lID0gJ0VOVk1BUF9NT0RFX1JFRkxFQ1RJT04nO1xcblxcdFxcdHZhciBlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTVVMVElQTFknO1xcblxcblxcdFxcdGlmICggcGFyYW1ldGVycy5lbnZNYXAgKSB7XFxuXFxuXFx0XFx0XFx0c3dpdGNoICggbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSBDdWJlUmVmbGVjdGlvbk1hcHBpbmc6XFxuXFx0XFx0XFx0XFx0Y2FzZSBDdWJlUmVmcmFjdGlvbk1hcHBpbmc6XFxuXFx0XFx0XFx0XFx0XFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFJztcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nOlxcblxcdFxcdFxcdFxcdGNhc2UgQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmc6XFxuXFx0XFx0XFx0XFx0XFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9DVUJFX1VWJztcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nOlxcblxcdFxcdFxcdFxcdGNhc2UgRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmc6XFxuXFx0XFx0XFx0XFx0XFx0ZW52TWFwVHlwZURlZmluZSA9ICdFTlZNQVBfVFlQRV9FUVVJUkVDJztcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIFNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nOlxcblxcdFxcdFxcdFxcdFxcdGVudk1hcFR5cGVEZWZpbmUgPSAnRU5WTUFQX1RZUEVfU1BIRVJFJztcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0c3dpdGNoICggbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSBDdWJlUmVmcmFjdGlvbk1hcHBpbmc6XFxuXFx0XFx0XFx0XFx0Y2FzZSBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzpcXG5cXHRcXHRcXHRcXHRcXHRlbnZNYXBNb2RlRGVmaW5lID0gJ0VOVk1BUF9NT0RFX1JFRlJBQ1RJT04nO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRzd2l0Y2ggKCBtYXRlcmlhbC5jb21iaW5lICkge1xcblxcblxcdFxcdFxcdFxcdGNhc2UgTXVsdGlwbHlPcGVyYXRpb246XFxuXFx0XFx0XFx0XFx0XFx0ZW52TWFwQmxlbmRpbmdEZWZpbmUgPSAnRU5WTUFQX0JMRU5ESU5HX01VTFRJUExZJztcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIE1peE9wZXJhdGlvbjpcXG5cXHRcXHRcXHRcXHRcXHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfTUlYJztcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIEFkZE9wZXJhdGlvbjpcXG5cXHRcXHRcXHRcXHRcXHRlbnZNYXBCbGVuZGluZ0RlZmluZSA9ICdFTlZNQVBfQkxFTkRJTkdfQUREJztcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHZhciBnYW1tYUZhY3RvckRlZmluZSA9ICggcmVuZGVyZXIuZ2FtbWFGYWN0b3IgPiAwICkgPyByZW5kZXJlci5nYW1tYUZhY3RvciA6IDEuMDtcXG5cXG5cXHRcXHQvLyBjb25zb2xlLmxvZyggJ2J1aWxkaW5nIG5ldyBwcm9ncmFtICcgKTtcXG5cXG5cXHRcXHQvL1xcblxcblxcdFxcdHZhciBjdXN0b21FeHRlbnNpb25zID0gZ2VuZXJhdGVFeHRlbnNpb25zKCBtYXRlcmlhbC5leHRlbnNpb25zLCBwYXJhbWV0ZXJzLCBleHRlbnNpb25zICk7XFxuXFxuXFx0XFx0dmFyIGN1c3RvbURlZmluZXMgPSBnZW5lcmF0ZURlZmluZXMoIGRlZmluZXMgKTtcXG5cXG5cXHRcXHQvL1xcblxcblxcdFxcdHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xcblxcblxcdFxcdHZhciBwcmVmaXhWZXJ0ZXgsIHByZWZpeEZyYWdtZW50O1xcblxcblxcdFxcdGlmICggbWF0ZXJpYWwuaXNSYXdTaGFkZXJNYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHRwcmVmaXhWZXJ0ZXggPSBbXFxuXFxuXFx0XFx0XFx0XFx0Y3VzdG9tRGVmaW5lc1xcblxcblxcdFxcdFxcdF0uZmlsdGVyKCBmaWx0ZXJFbXB0eUxpbmUgKS5qb2luKCAnXFxcXG4nICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBwcmVmaXhWZXJ0ZXgubGVuZ3RoID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRwcmVmaXhWZXJ0ZXggKz0gJ1xcXFxuJztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cHJlZml4RnJhZ21lbnQgPSBbXFxuXFxuXFx0XFx0XFx0XFx0Y3VzdG9tRXh0ZW5zaW9ucyxcXG5cXHRcXHRcXHRcXHRjdXN0b21EZWZpbmVzXFxuXFxuXFx0XFx0XFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXFxcbicgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHByZWZpeEZyYWdtZW50Lmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cHJlZml4RnJhZ21lbnQgKz0gJ1xcXFxuJztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRwcmVmaXhWZXJ0ZXggPSBbXFxuXFxuXFx0XFx0XFx0XFx0J3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGZsb2F0OycsXFxuXFx0XFx0XFx0XFx0J3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGludDsnLFxcblxcblxcdFxcdFxcdFxcdCcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBzaGFkZXIubmFtZSxcXG5cXG5cXHRcXHRcXHRcXHRjdXN0b21EZWZpbmVzLFxcblxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuc3VwcG9ydHNWZXJ0ZXhUZXh0dXJlcyA/ICcjZGVmaW5lIFZFUlRFWF9URVhUVVJFUycgOiAnJyxcXG5cXG5cXHRcXHRcXHRcXHQnI2RlZmluZSBHQU1NQV9GQUNUT1IgJyArIGdhbW1hRmFjdG9yRGVmaW5lLFxcblxcblxcdFxcdFxcdFxcdCcjZGVmaW5lIE1BWF9CT05FUyAnICsgcGFyYW1ldGVycy5tYXhCb25lcyxcXG5cXHRcXHRcXHRcXHQoIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nICkgPyAnI2RlZmluZSBVU0VfRk9HJyA6ICcnLFxcblxcdFxcdFxcdFxcdCggcGFyYW1ldGVycy51c2VGb2cgJiYgcGFyYW1ldGVycy5mb2dFeHAgKSA/ICcjZGVmaW5lIEZPR19FWFAyJyA6ICcnLFxcblxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMubWFwID8gJyNkZWZpbmUgVVNFX01BUCcgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lIFVTRV9FTlZNQVAnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwTW9kZURlZmluZSA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMubGlnaHRNYXAgPyAnI2RlZmluZSBVU0VfTElHSFRNQVAnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5hb01hcCA/ICcjZGVmaW5lIFVTRV9BT01BUCcgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwID8gJyNkZWZpbmUgVVNFX0VNSVNTSVZFTUFQJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuYnVtcE1hcCA/ICcjZGVmaW5lIFVTRV9CVU1QTUFQJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMubm9ybWFsTWFwID8gJyNkZWZpbmUgVVNFX05PUk1BTE1BUCcgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmRpc3BsYWNlbWVudE1hcCAmJiBwYXJhbWV0ZXJzLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMgPyAnI2RlZmluZSBVU0VfRElTUExBQ0VNRU5UTUFQJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuc3BlY3VsYXJNYXAgPyAnI2RlZmluZSBVU0VfU1BFQ1VMQVJNQVAnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5yb3VnaG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfUk9VR0hORVNTTUFQJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMubWV0YWxuZXNzTWFwID8gJyNkZWZpbmUgVVNFX01FVEFMTkVTU01BUCcgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmFscGhhTWFwID8gJyNkZWZpbmUgVVNFX0FMUEhBTUFQJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMudmVydGV4Q29sb3JzID8gJyNkZWZpbmUgVVNFX0NPTE9SJyA6ICcnLFxcblxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZmxhdFNoYWRpbmcgPyAnI2RlZmluZSBGTEFUX1NIQURFRCcgOiAnJyxcXG5cXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLnNraW5uaW5nID8gJyNkZWZpbmUgVVNFX1NLSU5OSU5HJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMudXNlVmVydGV4VGV4dHVyZSA/ICcjZGVmaW5lIEJPTkVfVEVYVFVSRScgOiAnJyxcXG5cXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLm1vcnBoVGFyZ2V0cyA/ICcjZGVmaW5lIFVTRV9NT1JQSFRBUkdFVFMnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5tb3JwaE5vcm1hbHMgJiYgcGFyYW1ldGVycy5mbGF0U2hhZGluZyA9PT0gZmFsc2UgPyAnI2RlZmluZSBVU0VfTU9SUEhOT1JNQUxTJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZG91YmxlU2lkZWQgPyAnI2RlZmluZSBET1VCTEVfU0lERUQnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5mbGlwU2lkZWQgPyAnI2RlZmluZSBGTElQX1NJREVEJyA6ICcnLFxcblxcblxcdFxcdFxcdFxcdCcjZGVmaW5lIE5VTV9DTElQUElOR19QTEFORVMgJyArIHBhcmFtZXRlcnMubnVtQ2xpcHBpbmdQbGFuZXMsXFxuXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgVVNFX1NIQURPV01BUCcgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLnNoYWRvd01hcEVuYWJsZWQgPyAnI2RlZmluZSAnICsgc2hhZG93TWFwVHlwZURlZmluZSA6ICcnLFxcblxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuc2l6ZUF0dGVudWF0aW9uID8gJyNkZWZpbmUgVVNFX1NJWkVBVFRFTlVBVElPTicgOiAnJyxcXG5cXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUYnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyICYmIGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2ZyYWdfZGVwdGgnICkgPyAnI2RlZmluZSBVU0VfTE9HREVQVEhCVUZfRVhUJyA6ICcnLFxcblxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7JyxcXG5cXHRcXHRcXHRcXHQndW5pZm9ybSBtYXQ0IG1vZGVsVmlld01hdHJpeDsnLFxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIG1hdDQgcHJvamVjdGlvbk1hdHJpeDsnLFxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIG1hdDQgdmlld01hdHJpeDsnLFxcblxcdFxcdFxcdFxcdCd1bmlmb3JtIG1hdDMgbm9ybWFsTWF0cml4OycsXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxcblxcblxcdFxcdFxcdFxcdCdhdHRyaWJ1dGUgdmVjMyBwb3NpdGlvbjsnLFxcblxcdFxcdFxcdFxcdCdhdHRyaWJ1dGUgdmVjMyBub3JtYWw7JyxcXG5cXHRcXHRcXHRcXHQnYXR0cmlidXRlIHZlYzIgdXY7JyxcXG5cXG5cXHRcXHRcXHRcXHQnI2lmZGVmIFVTRV9DT0xPUicsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdGF0dHJpYnV0ZSB2ZWMzIGNvbG9yOycsXFxuXFxuXFx0XFx0XFx0XFx0JyNlbmRpZicsXFxuXFxuXFx0XFx0XFx0XFx0JyNpZmRlZiBVU0VfTU9SUEhUQVJHRVRTJyxcXG5cXG5cXHRcXHRcXHRcXHQnXFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQwOycsXFxuXFx0XFx0XFx0XFx0J1xcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0MTsnLFxcblxcdFxcdFxcdFxcdCdcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDI7JyxcXG5cXHRcXHRcXHRcXHQnXFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQzOycsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdCNpZmRlZiBVU0VfTU9SUEhOT1JNQUxTJyxcXG5cXG5cXHRcXHRcXHRcXHQnXFx0XFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwwOycsXFxuXFx0XFx0XFx0XFx0J1xcdFxcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoTm9ybWFsMTsnLFxcblxcdFxcdFxcdFxcdCdcXHRcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaE5vcm1hbDI7JyxcXG5cXHRcXHRcXHRcXHQnXFx0XFx0YXR0cmlidXRlIHZlYzMgbW9ycGhOb3JtYWwzOycsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdCNlbHNlJyxcXG5cXG5cXHRcXHRcXHRcXHQnXFx0XFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ0OycsXFxuXFx0XFx0XFx0XFx0J1xcdFxcdGF0dHJpYnV0ZSB2ZWMzIG1vcnBoVGFyZ2V0NTsnLFxcblxcdFxcdFxcdFxcdCdcXHRcXHRhdHRyaWJ1dGUgdmVjMyBtb3JwaFRhcmdldDY7JyxcXG5cXHRcXHRcXHRcXHQnXFx0XFx0YXR0cmlidXRlIHZlYzMgbW9ycGhUYXJnZXQ3OycsXFxuXFxuXFx0XFx0XFx0XFx0J1xcdCNlbmRpZicsXFxuXFxuXFx0XFx0XFx0XFx0JyNlbmRpZicsXFxuXFxuXFx0XFx0XFx0XFx0JyNpZmRlZiBVU0VfU0tJTk5JTkcnLFxcblxcblxcdFxcdFxcdFxcdCdcXHRhdHRyaWJ1dGUgdmVjNCBza2luSW5kZXg7JyxcXG5cXHRcXHRcXHRcXHQnXFx0YXR0cmlidXRlIHZlYzQgc2tpbldlaWdodDsnLFxcblxcblxcdFxcdFxcdFxcdCcjZW5kaWYnLFxcblxcblxcdFxcdFxcdFxcdCdcXFxcbidcXG5cXG5cXHRcXHRcXHRdLmZpbHRlciggZmlsdGVyRW1wdHlMaW5lICkuam9pbiggJ1xcXFxuJyApO1xcblxcblxcdFxcdFxcdHByZWZpeEZyYWdtZW50ID0gW1xcblxcblxcdFxcdFxcdFxcdGN1c3RvbUV4dGVuc2lvbnMsXFxuXFxuXFx0XFx0XFx0XFx0J3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGZsb2F0OycsXFxuXFx0XFx0XFx0XFx0J3ByZWNpc2lvbiAnICsgcGFyYW1ldGVycy5wcmVjaXNpb24gKyAnIGludDsnLFxcblxcblxcdFxcdFxcdFxcdCcjZGVmaW5lIFNIQURFUl9OQU1FICcgKyBzaGFkZXIubmFtZSxcXG5cXG5cXHRcXHRcXHRcXHRjdXN0b21EZWZpbmVzLFxcblxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuYWxwaGFUZXN0ID8gJyNkZWZpbmUgQUxQSEFURVNUICcgKyBwYXJhbWV0ZXJzLmFscGhhVGVzdCA6ICcnLFxcblxcblxcdFxcdFxcdFxcdCcjZGVmaW5lIEdBTU1BX0ZBQ1RPUiAnICsgZ2FtbWFGYWN0b3JEZWZpbmUsXFxuXFxuXFx0XFx0XFx0XFx0KCBwYXJhbWV0ZXJzLnVzZUZvZyAmJiBwYXJhbWV0ZXJzLmZvZyApID8gJyNkZWZpbmUgVVNFX0ZPRycgOiAnJyxcXG5cXHRcXHRcXHRcXHQoIHBhcmFtZXRlcnMudXNlRm9nICYmIHBhcmFtZXRlcnMuZm9nRXhwICkgPyAnI2RlZmluZSBGT0dfRVhQMicgOiAnJyxcXG5cXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLm1hcCA/ICcjZGVmaW5lIFVTRV9NQVAnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSBVU0VfRU5WTUFQJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuZW52TWFwID8gJyNkZWZpbmUgJyArIGVudk1hcFR5cGVEZWZpbmUgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmVudk1hcCA/ICcjZGVmaW5lICcgKyBlbnZNYXBNb2RlRGVmaW5lIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5lbnZNYXAgPyAnI2RlZmluZSAnICsgZW52TWFwQmxlbmRpbmdEZWZpbmUgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmxpZ2h0TWFwID8gJyNkZWZpbmUgVVNFX0xJR0hUTUFQJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuYW9NYXAgPyAnI2RlZmluZSBVU0VfQU9NQVAnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5lbWlzc2l2ZU1hcCA/ICcjZGVmaW5lIFVTRV9FTUlTU0lWRU1BUCcgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmJ1bXBNYXAgPyAnI2RlZmluZSBVU0VfQlVNUE1BUCcgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLm5vcm1hbE1hcCA/ICcjZGVmaW5lIFVTRV9OT1JNQUxNQVAnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5zcGVjdWxhck1hcCA/ICcjZGVmaW5lIFVTRV9TUEVDVUxBUk1BUCcgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLnJvdWdobmVzc01hcCA/ICcjZGVmaW5lIFVTRV9ST1VHSE5FU1NNQVAnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5tZXRhbG5lc3NNYXAgPyAnI2RlZmluZSBVU0VfTUVUQUxORVNTTUFQJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuYWxwaGFNYXAgPyAnI2RlZmluZSBVU0VfQUxQSEFNQVAnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy52ZXJ0ZXhDb2xvcnMgPyAnI2RlZmluZSBVU0VfQ09MT1InIDogJycsXFxuXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5ncmFkaWVudE1hcCA/ICcjZGVmaW5lIFVTRV9HUkFESUVOVE1BUCcgOiAnJyxcXG5cXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmZsYXRTaGFkaW5nID8gJyNkZWZpbmUgRkxBVF9TSEFERUQnIDogJycsXFxuXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5kb3VibGVTaWRlZCA/ICcjZGVmaW5lIERPVUJMRV9TSURFRCcgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmZsaXBTaWRlZCA/ICcjZGVmaW5lIEZMSVBfU0lERUQnIDogJycsXFxuXFxuXFx0XFx0XFx0XFx0JyNkZWZpbmUgTlVNX0NMSVBQSU5HX1BMQU5FUyAnICsgcGFyYW1ldGVycy5udW1DbGlwcGluZ1BsYW5lcyxcXG5cXHRcXHRcXHRcXHQnI2RlZmluZSBVTklPTl9DTElQUElOR19QTEFORVMgJyArICggcGFyYW1ldGVycy5udW1DbGlwcGluZ1BsYW5lcyAtIHBhcmFtZXRlcnMubnVtQ2xpcEludGVyc2VjdGlvbiApLFxcblxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMuc2hhZG93TWFwRW5hYmxlZCA/ICcjZGVmaW5lIFVTRV9TSEFET1dNQVAnIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5zaGFkb3dNYXBFbmFibGVkID8gJyNkZWZpbmUgJyArIHNoYWRvd01hcFR5cGVEZWZpbmUgOiAnJyxcXG5cXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSA/ICcjZGVmaW5lIFBSRU1VTFRJUExJRURfQUxQSEEnIDogJycsXFxuXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5waHlzaWNhbGx5Q29ycmVjdExpZ2h0cyA/ICcjZGVmaW5lIFBIWVNJQ0FMTFlfQ09SUkVDVF9MSUdIVFMnIDogJycsXFxuXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5sb2dhcml0aG1pY0RlcHRoQnVmZmVyID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGJyA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMubG9nYXJpdGhtaWNEZXB0aEJ1ZmZlciAmJiBleHRlbnNpb25zLmdldCggJ0VYVF9mcmFnX2RlcHRoJyApID8gJyNkZWZpbmUgVVNFX0xPR0RFUFRIQlVGX0VYVCcgOiAnJyxcXG5cXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmVudk1hcCAmJiBleHRlbnNpb25zLmdldCggJ0VYVF9zaGFkZXJfdGV4dHVyZV9sb2QnICkgPyAnI2RlZmluZSBURVhUVVJFX0xPRF9FWFQnIDogJycsXFxuXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gbWF0NCB2aWV3TWF0cml4OycsXFxuXFx0XFx0XFx0XFx0J3VuaWZvcm0gdmVjMyBjYW1lcmFQb3NpdGlvbjsnLFxcblxcblxcdFxcdFxcdFxcdCggcGFyYW1ldGVycy50b25lTWFwcGluZyAhPT0gTm9Ub25lTWFwcGluZyApID8gJyNkZWZpbmUgVE9ORV9NQVBQSU5HJyA6ICcnLFxcblxcdFxcdFxcdFxcdCggcGFyYW1ldGVycy50b25lTWFwcGluZyAhPT0gTm9Ub25lTWFwcGluZyApID8gU2hhZGVyQ2h1bmtbICd0b25lbWFwcGluZ19wYXJzX2ZyYWdtZW50JyBdIDogJycsIC8vIHRoaXMgY29kZSBpcyByZXF1aXJlZCBoZXJlIGJlY2F1c2UgaXQgaXMgdXNlZCBieSB0aGUgdG9uZU1hcHBpbmcoKSBmdW5jdGlvbiBkZWZpbmVkIGJlbG93XFxuXFx0XFx0XFx0XFx0KCBwYXJhbWV0ZXJzLnRvbmVNYXBwaW5nICE9PSBOb1RvbmVNYXBwaW5nICkgPyBnZXRUb25lTWFwcGluZ0Z1bmN0aW9uKCAndG9uZU1hcHBpbmcnLCBwYXJhbWV0ZXJzLnRvbmVNYXBwaW5nICkgOiAnJyxcXG5cXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmRpdGhlcmluZyA/ICcjZGVmaW5lIERJVEhFUklORycgOiAnJyxcXG5cXG5cXHRcXHRcXHRcXHQoIHBhcmFtZXRlcnMub3V0cHV0RW5jb2RpbmcgfHwgcGFyYW1ldGVycy5tYXBFbmNvZGluZyB8fCBwYXJhbWV0ZXJzLmVudk1hcEVuY29kaW5nIHx8IHBhcmFtZXRlcnMuZW1pc3NpdmVNYXBFbmNvZGluZyApID8gU2hhZGVyQ2h1bmtbICdlbmNvZGluZ3NfcGFyc19mcmFnbWVudCcgXSA6ICcnLCAvLyB0aGlzIGNvZGUgaXMgcmVxdWlyZWQgaGVyZSBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgdGhlIHZhcmlvdXMgZW5jb2RpbmcvZGVjb2RpbmcgZnVuY3Rpb24gZGVmaW5lZCBiZWxvd1xcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMubWFwRW5jb2RpbmcgPyBnZXRUZXhlbERlY29kaW5nRnVuY3Rpb24oICdtYXBUZXhlbFRvTGluZWFyJywgcGFyYW1ldGVycy5tYXBFbmNvZGluZyApIDogJycsXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5lbnZNYXBFbmNvZGluZyA/IGdldFRleGVsRGVjb2RpbmdGdW5jdGlvbiggJ2Vudk1hcFRleGVsVG9MaW5lYXInLCBwYXJhbWV0ZXJzLmVudk1hcEVuY29kaW5nICkgOiAnJyxcXG5cXHRcXHRcXHRcXHRwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwRW5jb2RpbmcgPyBnZXRUZXhlbERlY29kaW5nRnVuY3Rpb24oICdlbWlzc2l2ZU1hcFRleGVsVG9MaW5lYXInLCBwYXJhbWV0ZXJzLmVtaXNzaXZlTWFwRW5jb2RpbmcgKSA6ICcnLFxcblxcdFxcdFxcdFxcdHBhcmFtZXRlcnMub3V0cHV0RW5jb2RpbmcgPyBnZXRUZXhlbEVuY29kaW5nRnVuY3Rpb24oICdsaW5lYXJUb091dHB1dFRleGVsJywgcGFyYW1ldGVycy5vdXRwdXRFbmNvZGluZyApIDogJycsXFxuXFxuXFx0XFx0XFx0XFx0cGFyYW1ldGVycy5kZXB0aFBhY2tpbmcgPyAnI2RlZmluZSBERVBUSF9QQUNLSU5HICcgKyBtYXRlcmlhbC5kZXB0aFBhY2tpbmcgOiAnJyxcXG5cXG5cXHRcXHRcXHRcXHQnXFxcXG4nXFxuXFxuXFx0XFx0XFx0XS5maWx0ZXIoIGZpbHRlckVtcHR5TGluZSApLmpvaW4oICdcXFxcbicgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmVydGV4U2hhZGVyID0gcGFyc2VJbmNsdWRlcyggdmVydGV4U2hhZGVyICk7XFxuXFx0XFx0dmVydGV4U2hhZGVyID0gcmVwbGFjZUxpZ2h0TnVtcyggdmVydGV4U2hhZGVyLCBwYXJhbWV0ZXJzICk7XFxuXFxuXFx0XFx0ZnJhZ21lbnRTaGFkZXIgPSBwYXJzZUluY2x1ZGVzKCBmcmFnbWVudFNoYWRlciApO1xcblxcdFxcdGZyYWdtZW50U2hhZGVyID0gcmVwbGFjZUxpZ2h0TnVtcyggZnJhZ21lbnRTaGFkZXIsIHBhcmFtZXRlcnMgKTtcXG5cXG5cXHRcXHRpZiAoICEgbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHR2ZXJ0ZXhTaGFkZXIgPSB1bnJvbGxMb29wcyggdmVydGV4U2hhZGVyICk7XFxuXFx0XFx0XFx0ZnJhZ21lbnRTaGFkZXIgPSB1bnJvbGxMb29wcyggZnJhZ21lbnRTaGFkZXIgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIHZlcnRleEdsc2wgPSBwcmVmaXhWZXJ0ZXggKyB2ZXJ0ZXhTaGFkZXI7XFxuXFx0XFx0dmFyIGZyYWdtZW50R2xzbCA9IHByZWZpeEZyYWdtZW50ICsgZnJhZ21lbnRTaGFkZXI7XFxuXFxuXFx0XFx0Ly8gY29uc29sZS5sb2coICcqVkVSVEVYKicsIHZlcnRleEdsc2wgKTtcXG5cXHRcXHQvLyBjb25zb2xlLmxvZyggJypGUkFHTUVOVConLCBmcmFnbWVudEdsc2wgKTtcXG5cXG5cXHRcXHR2YXIgZ2xWZXJ0ZXhTaGFkZXIgPSBXZWJHTFNoYWRlciggZ2wsIGdsLlZFUlRFWF9TSEFERVIsIHZlcnRleEdsc2wgKTtcXG5cXHRcXHR2YXIgZ2xGcmFnbWVudFNoYWRlciA9IFdlYkdMU2hhZGVyKCBnbCwgZ2wuRlJBR01FTlRfU0hBREVSLCBmcmFnbWVudEdsc2wgKTtcXG5cXG5cXHRcXHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGdsVmVydGV4U2hhZGVyICk7XFxuXFx0XFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBnbEZyYWdtZW50U2hhZGVyICk7XFxuXFxuXFx0XFx0Ly8gRm9yY2UgYSBwYXJ0aWN1bGFyIGF0dHJpYnV0ZSB0byBpbmRleCAwLlxcblxcblxcdFxcdGlmICggbWF0ZXJpYWwuaW5kZXgwQXR0cmlidXRlTmFtZSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdGdsLmJpbmRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgMCwgbWF0ZXJpYWwuaW5kZXgwQXR0cmlidXRlTmFtZSApO1xcblxcblxcdFxcdH0gZWxzZSBpZiAoIHBhcmFtZXRlcnMubW9ycGhUYXJnZXRzID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdC8vIHByb2dyYW1zIHdpdGggbW9ycGhUYXJnZXRzIGRpc3BsYWNlIHBvc2l0aW9uIG91dCBvZiBhdHRyaWJ1dGUgMFxcblxcdFxcdFxcdGdsLmJpbmRBdHRyaWJMb2NhdGlvbiggcHJvZ3JhbSwgMCwgJ3Bvc2l0aW9uJyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApO1xcblxcblxcdFxcdHZhciBwcm9ncmFtTG9nID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coIHByb2dyYW0gKTtcXG5cXHRcXHR2YXIgdmVydGV4TG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggZ2xWZXJ0ZXhTaGFkZXIgKTtcXG5cXHRcXHR2YXIgZnJhZ21lbnRMb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKCBnbEZyYWdtZW50U2hhZGVyICk7XFxuXFxuXFx0XFx0dmFyIHJ1bm5hYmxlID0gdHJ1ZTtcXG5cXHRcXHR2YXIgaGF2ZURpYWdub3N0aWNzID0gdHJ1ZTtcXG5cXG5cXHRcXHQvLyBjb25zb2xlLmxvZyggJyoqVkVSVEVYKionLCBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZWJ1Z19zaGFkZXJzJyApLmdldFRyYW5zbGF0ZWRTaGFkZXJTb3VyY2UoIGdsVmVydGV4U2hhZGVyICkgKTtcXG5cXHRcXHQvLyBjb25zb2xlLmxvZyggJyoqRlJBR01FTlQqKicsIGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2RlYnVnX3NoYWRlcnMnICkuZ2V0VHJhbnNsYXRlZFNoYWRlclNvdXJjZSggZ2xGcmFnbWVudFNoYWRlciApICk7XFxuXFxuXFx0XFx0aWYgKCBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKCBwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyApID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRydW5uYWJsZSA9IGZhbHNlO1xcblxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFByb2dyYW06IHNoYWRlciBlcnJvcjogJywgZ2wuZ2V0RXJyb3IoKSwgJ2dsLlZBTElEQVRFX1NUQVRVUycsIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLlZBTElEQVRFX1NUQVRVUyApLCAnZ2wuZ2V0UHJvZ3JhbUluZm9Mb2cnLCBwcm9ncmFtTG9nLCB2ZXJ0ZXhMb2csIGZyYWdtZW50TG9nICk7XFxuXFxuXFx0XFx0fSBlbHNlIGlmICggcHJvZ3JhbUxvZyAhPT0gJycgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xQcm9ncmFtOiBnbC5nZXRQcm9ncmFtSW5mb0xvZygpJywgcHJvZ3JhbUxvZyApO1xcblxcblxcdFxcdH0gZWxzZSBpZiAoIHZlcnRleExvZyA9PT0gJycgfHwgZnJhZ21lbnRMb2cgPT09ICcnICkge1xcblxcblxcdFxcdFxcdGhhdmVEaWFnbm9zdGljcyA9IGZhbHNlO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIGhhdmVEaWFnbm9zdGljcyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmRpYWdub3N0aWNzID0ge1xcblxcblxcdFxcdFxcdFxcdHJ1bm5hYmxlOiBydW5uYWJsZSxcXG5cXHRcXHRcXHRcXHRtYXRlcmlhbDogbWF0ZXJpYWwsXFxuXFxuXFx0XFx0XFx0XFx0cHJvZ3JhbUxvZzogcHJvZ3JhbUxvZyxcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0ZXhTaGFkZXI6IHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRsb2c6IHZlcnRleExvZyxcXG5cXHRcXHRcXHRcXHRcXHRwcmVmaXg6IHByZWZpeFZlcnRleFxcblxcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0ZnJhZ21lbnRTaGFkZXI6IHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRsb2c6IGZyYWdtZW50TG9nLFxcblxcdFxcdFxcdFxcdFxcdHByZWZpeDogcHJlZml4RnJhZ21lbnRcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gY2xlYW4gdXBcXG5cXG5cXHRcXHRnbC5kZWxldGVTaGFkZXIoIGdsVmVydGV4U2hhZGVyICk7XFxuXFx0XFx0Z2wuZGVsZXRlU2hhZGVyKCBnbEZyYWdtZW50U2hhZGVyICk7XFxuXFxuXFx0XFx0Ly8gc2V0IHVwIGNhY2hpbmcgZm9yIHVuaWZvcm0gbG9jYXRpb25zXFxuXFxuXFx0XFx0dmFyIGNhY2hlZFVuaWZvcm1zO1xcblxcblxcdFxcdHRoaXMuZ2V0VW5pZm9ybXMgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBjYWNoZWRVbmlmb3JtcyA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGNhY2hlZFVuaWZvcm1zID0gbmV3IFdlYkdMVW5pZm9ybXMoIGdsLCBwcm9ncmFtLCByZW5kZXJlciApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gY2FjaGVkVW5pZm9ybXM7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBzZXQgdXAgY2FjaGluZyBmb3IgYXR0cmlidXRlIGxvY2F0aW9uc1xcblxcblxcdFxcdHZhciBjYWNoZWRBdHRyaWJ1dGVzO1xcblxcblxcdFxcdHRoaXMuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGNhY2hlZEF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjYWNoZWRBdHRyaWJ1dGVzID0gZmV0Y2hBdHRyaWJ1dGVMb2NhdGlvbnMoIGdsLCBwcm9ncmFtICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBjYWNoZWRBdHRyaWJ1dGVzO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gZnJlZSByZXNvdXJjZVxcblxcblxcdFxcdHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRnbC5kZWxldGVQcm9ncmFtKCBwcm9ncmFtICk7XFxuXFx0XFx0XFx0dGhpcy5wcm9ncmFtID0gdW5kZWZpbmVkO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gREVQUkVDQVRFRFxcblxcblxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLCB7XFxuXFxuXFx0XFx0XFx0dW5pZm9ybXM6IHtcXG5cXHRcXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW06IC51bmlmb3JtcyBpcyBub3cgLmdldFVuaWZvcm1zKCkuJyApO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmdldFVuaWZvcm1zKCk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0YXR0cmlidXRlczoge1xcblxcdFxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUHJvZ3JhbTogLmF0dHJpYnV0ZXMgaXMgbm93IC5nZXRBdHRyaWJ1dGVzKCkuJyApO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZXMoKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0gKTtcXG5cXG5cXG5cXHRcXHQvL1xcblxcblxcdFxcdHRoaXMuaWQgPSBwcm9ncmFtSWRDb3VudCArKztcXG5cXHRcXHR0aGlzLmNvZGUgPSBjb2RlO1xcblxcdFxcdHRoaXMudXNlZFRpbWVzID0gMTtcXG5cXHRcXHR0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xcblxcdFxcdHRoaXMudmVydGV4U2hhZGVyID0gZ2xWZXJ0ZXhTaGFkZXI7XFxuXFx0XFx0dGhpcy5mcmFnbWVudFNoYWRlciA9IGdsRnJhZ21lbnRTaGFkZXI7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gV2ViR0xQcm9ncmFtcyggcmVuZGVyZXIsIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcyApIHtcXG5cXG5cXHRcXHR2YXIgcHJvZ3JhbXMgPSBbXTtcXG5cXG5cXHRcXHR2YXIgc2hhZGVySURzID0ge1xcblxcdFxcdFxcdE1lc2hEZXB0aE1hdGVyaWFsOiAnZGVwdGgnLFxcblxcdFxcdFxcdE1lc2hEaXN0YW5jZU1hdGVyaWFsOiAnZGlzdGFuY2VSR0JBJyxcXG5cXHRcXHRcXHRNZXNoTm9ybWFsTWF0ZXJpYWw6ICdub3JtYWwnLFxcblxcdFxcdFxcdE1lc2hCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxcblxcdFxcdFxcdE1lc2hMYW1iZXJ0TWF0ZXJpYWw6ICdsYW1iZXJ0JyxcXG5cXHRcXHRcXHRNZXNoUGhvbmdNYXRlcmlhbDogJ3Bob25nJyxcXG5cXHRcXHRcXHRNZXNoVG9vbk1hdGVyaWFsOiAncGhvbmcnLFxcblxcdFxcdFxcdE1lc2hTdGFuZGFyZE1hdGVyaWFsOiAncGh5c2ljYWwnLFxcblxcdFxcdFxcdE1lc2hQaHlzaWNhbE1hdGVyaWFsOiAncGh5c2ljYWwnLFxcblxcdFxcdFxcdExpbmVCYXNpY01hdGVyaWFsOiAnYmFzaWMnLFxcblxcdFxcdFxcdExpbmVEYXNoZWRNYXRlcmlhbDogJ2Rhc2hlZCcsXFxuXFx0XFx0XFx0UG9pbnRzTWF0ZXJpYWw6ICdwb2ludHMnLFxcblxcdFxcdFxcdFNoYWRvd01hdGVyaWFsOiAnc2hhZG93J1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dmFyIHBhcmFtZXRlck5hbWVzID0gW1xcblxcdFxcdFxcdFxcXCJwcmVjaXNpb25cXFwiLCBcXFwic3VwcG9ydHNWZXJ0ZXhUZXh0dXJlc1xcXCIsIFxcXCJtYXBcXFwiLCBcXFwibWFwRW5jb2RpbmdcXFwiLCBcXFwiZW52TWFwXFxcIiwgXFxcImVudk1hcE1vZGVcXFwiLCBcXFwiZW52TWFwRW5jb2RpbmdcXFwiLFxcblxcdFxcdFxcdFxcXCJsaWdodE1hcFxcXCIsIFxcXCJhb01hcFxcXCIsIFxcXCJlbWlzc2l2ZU1hcFxcXCIsIFxcXCJlbWlzc2l2ZU1hcEVuY29kaW5nXFxcIiwgXFxcImJ1bXBNYXBcXFwiLCBcXFwibm9ybWFsTWFwXFxcIiwgXFxcImRpc3BsYWNlbWVudE1hcFxcXCIsIFxcXCJzcGVjdWxhck1hcFxcXCIsXFxuXFx0XFx0XFx0XFxcInJvdWdobmVzc01hcFxcXCIsIFxcXCJtZXRhbG5lc3NNYXBcXFwiLCBcXFwiZ3JhZGllbnRNYXBcXFwiLFxcblxcdFxcdFxcdFxcXCJhbHBoYU1hcFxcXCIsIFxcXCJjb21iaW5lXFxcIiwgXFxcInZlcnRleENvbG9yc1xcXCIsIFxcXCJmb2dcXFwiLCBcXFwidXNlRm9nXFxcIiwgXFxcImZvZ0V4cFxcXCIsXFxuXFx0XFx0XFx0XFxcImZsYXRTaGFkaW5nXFxcIiwgXFxcInNpemVBdHRlbnVhdGlvblxcXCIsIFxcXCJsb2dhcml0aG1pY0RlcHRoQnVmZmVyXFxcIiwgXFxcInNraW5uaW5nXFxcIixcXG5cXHRcXHRcXHRcXFwibWF4Qm9uZXNcXFwiLCBcXFwidXNlVmVydGV4VGV4dHVyZVxcXCIsIFxcXCJtb3JwaFRhcmdldHNcXFwiLCBcXFwibW9ycGhOb3JtYWxzXFxcIixcXG5cXHRcXHRcXHRcXFwibWF4TW9ycGhUYXJnZXRzXFxcIiwgXFxcIm1heE1vcnBoTm9ybWFsc1xcXCIsIFxcXCJwcmVtdWx0aXBsaWVkQWxwaGFcXFwiLFxcblxcdFxcdFxcdFxcXCJudW1EaXJMaWdodHNcXFwiLCBcXFwibnVtUG9pbnRMaWdodHNcXFwiLCBcXFwibnVtU3BvdExpZ2h0c1xcXCIsIFxcXCJudW1IZW1pTGlnaHRzXFxcIiwgXFxcIm51bVJlY3RBcmVhTGlnaHRzXFxcIixcXG5cXHRcXHRcXHRcXFwic2hhZG93TWFwRW5hYmxlZFxcXCIsIFxcXCJzaGFkb3dNYXBUeXBlXFxcIiwgXFxcInRvbmVNYXBwaW5nXFxcIiwgJ3BoeXNpY2FsbHlDb3JyZWN0TGlnaHRzJyxcXG5cXHRcXHRcXHRcXFwiYWxwaGFUZXN0XFxcIiwgXFxcImRvdWJsZVNpZGVkXFxcIiwgXFxcImZsaXBTaWRlZFxcXCIsIFxcXCJudW1DbGlwcGluZ1BsYW5lc1xcXCIsIFxcXCJudW1DbGlwSW50ZXJzZWN0aW9uXFxcIiwgXFxcImRlcHRoUGFja2luZ1xcXCIsIFxcXCJkaXRoZXJpbmdcXFwiXFxuXFx0XFx0XTtcXG5cXG5cXG5cXHRcXHRmdW5jdGlvbiBhbGxvY2F0ZUJvbmVzKCBvYmplY3QgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHNrZWxldG9uID0gb2JqZWN0LnNrZWxldG9uO1xcblxcdFxcdFxcdHZhciBib25lcyA9IHNrZWxldG9uLmJvbmVzO1xcblxcblxcdFxcdFxcdGlmICggY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIDEwMjQ7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBkZWZhdWx0IGZvciB3aGVuIG9iamVjdCBpcyBub3Qgc3BlY2lmaWVkXFxuXFx0XFx0XFx0XFx0Ly8gKCBmb3IgZXhhbXBsZSB3aGVuIHByZWJ1aWxkaW5nIHNoYWRlciB0byBiZSB1c2VkIHdpdGggbXVsdGlwbGUgb2JqZWN0cyApXFxuXFx0XFx0XFx0XFx0Ly9cXG5cXHRcXHRcXHRcXHQvLyAgLSBsZWF2ZSBzb21lIGV4dHJhIHNwYWNlIGZvciBvdGhlciB1bmlmb3Jtc1xcblxcdFxcdFxcdFxcdC8vICAtIGxpbWl0IGhlcmUgaXMgQU5HTEUncyAyNTQgbWF4IHVuaWZvcm0gdmVjdG9yc1xcblxcdFxcdFxcdFxcdC8vICAgICh1cCB0byA1NCBzaG91bGQgYmUgc2FmZSlcXG5cXG5cXHRcXHRcXHRcXHR2YXIgblZlcnRleFVuaWZvcm1zID0gY2FwYWJpbGl0aWVzLm1heFZlcnRleFVuaWZvcm1zO1xcblxcdFxcdFxcdFxcdHZhciBuVmVydGV4TWF0cmljZXMgPSBNYXRoLmZsb29yKCAoIG5WZXJ0ZXhVbmlmb3JtcyAtIDIwICkgLyA0ICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG1heEJvbmVzID0gTWF0aC5taW4oIG5WZXJ0ZXhNYXRyaWNlcywgYm9uZXMubGVuZ3RoICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtYXhCb25lcyA8IGJvbmVzLmxlbmd0aCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBTa2VsZXRvbiBoYXMgJyArIGJvbmVzLmxlbmd0aCArICcgYm9uZXMuIFRoaXMgR1BVIHN1cHBvcnRzICcgKyBtYXhCb25lcyArICcuJyApO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAwO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gbWF4Qm9uZXM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBnZXRUZXh0dXJlRW5jb2RpbmdGcm9tTWFwKCBtYXAsIGdhbW1hT3ZlcnJpZGVMaW5lYXIgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGVuY29kaW5nO1xcblxcblxcdFxcdFxcdGlmICggISBtYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZW5jb2RpbmcgPSBMaW5lYXJFbmNvZGluZztcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXAuaXNUZXh0dXJlICkge1xcblxcblxcdFxcdFxcdFxcdGVuY29kaW5nID0gbWFwLmVuY29kaW5nO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hcC5pc1dlYkdMUmVuZGVyVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggXFxcIlRIUkVFLldlYkdMUHJvZ3JhbXMuZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcDogZG9uJ3QgdXNlIHJlbmRlciB0YXJnZXRzIGFzIHRleHR1cmVzLiBVc2UgdGhlaXIgLnRleHR1cmUgcHJvcGVydHkgaW5zdGVhZC5cXFwiICk7XFxuXFx0XFx0XFx0XFx0ZW5jb2RpbmcgPSBtYXAudGV4dHVyZS5lbmNvZGluZztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gYWRkIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGZvciBXZWJHTFJlbmRlcmVyLmdhbW1hSW5wdXQvZ2FtbWFPdXRwdXQgcGFyYW1ldGVyLCBzaG91bGQgcHJvYmFibHkgYmUgcmVtb3ZlZCBhdCBzb21lIHBvaW50LlxcblxcdFxcdFxcdGlmICggZW5jb2RpbmcgPT09IExpbmVhckVuY29kaW5nICYmIGdhbW1hT3ZlcnJpZGVMaW5lYXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZW5jb2RpbmcgPSBHYW1tYUVuY29kaW5nO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZW5jb2Rpbmc7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuZ2V0UGFyYW1ldGVycyA9IGZ1bmN0aW9uICggbWF0ZXJpYWwsIGxpZ2h0cywgc2hhZG93cywgZm9nLCBuQ2xpcFBsYW5lcywgbkNsaXBJbnRlcnNlY3Rpb24sIG9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgc2hhZGVySUQgPSBzaGFkZXJJRHNbIG1hdGVyaWFsLnR5cGUgXTtcXG5cXG5cXHRcXHRcXHQvLyBoZXVyaXN0aWNzIHRvIGNyZWF0ZSBzaGFkZXIgcGFyYW1ldGVycyBhY2NvcmRpbmcgdG8gbGlnaHRzIGluIHRoZSBzY2VuZVxcblxcdFxcdFxcdC8vIChub3QgdG8gYmxvdyBvdmVyIG1heExpZ2h0cyBidWRnZXQpXFxuXFxuXFx0XFx0XFx0dmFyIG1heEJvbmVzID0gb2JqZWN0LmlzU2tpbm5lZE1lc2ggPyBhbGxvY2F0ZUJvbmVzKCBvYmplY3QgKSA6IDA7XFxuXFx0XFx0XFx0dmFyIHByZWNpc2lvbiA9IGNhcGFiaWxpdGllcy5wcmVjaXNpb247XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5wcmVjaXNpb24gIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cHJlY2lzaW9uID0gY2FwYWJpbGl0aWVzLmdldE1heFByZWNpc2lvbiggbWF0ZXJpYWwucHJlY2lzaW9uICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBwcmVjaXNpb24gIT09IG1hdGVyaWFsLnByZWNpc2lvbiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFByb2dyYW0uZ2V0UGFyYW1ldGVyczonLCBtYXRlcmlhbC5wcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIHByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGN1cnJlbnRSZW5kZXJUYXJnZXQgPSByZW5kZXJlci5nZXRSZW5kZXJUYXJnZXQoKTtcXG5cXG5cXHRcXHRcXHR2YXIgcGFyYW1ldGVycyA9IHtcXG5cXG5cXHRcXHRcXHRcXHRzaGFkZXJJRDogc2hhZGVySUQsXFxuXFxuXFx0XFx0XFx0XFx0cHJlY2lzaW9uOiBwcmVjaXNpb24sXFxuXFx0XFx0XFx0XFx0c3VwcG9ydHNWZXJ0ZXhUZXh0dXJlczogY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzLFxcblxcdFxcdFxcdFxcdG91dHB1dEVuY29kaW5nOiBnZXRUZXh0dXJlRW5jb2RpbmdGcm9tTWFwKCAoICEgY3VycmVudFJlbmRlclRhcmdldCApID8gbnVsbCA6IGN1cnJlbnRSZW5kZXJUYXJnZXQudGV4dHVyZSwgcmVuZGVyZXIuZ2FtbWFPdXRwdXQgKSxcXG5cXHRcXHRcXHRcXHRtYXA6ICEhIG1hdGVyaWFsLm1hcCxcXG5cXHRcXHRcXHRcXHRtYXBFbmNvZGluZzogZ2V0VGV4dHVyZUVuY29kaW5nRnJvbU1hcCggbWF0ZXJpYWwubWFwLCByZW5kZXJlci5nYW1tYUlucHV0ICksXFxuXFx0XFx0XFx0XFx0ZW52TWFwOiAhISBtYXRlcmlhbC5lbnZNYXAsXFxuXFx0XFx0XFx0XFx0ZW52TWFwTW9kZTogbWF0ZXJpYWwuZW52TWFwICYmIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nLFxcblxcdFxcdFxcdFxcdGVudk1hcEVuY29kaW5nOiBnZXRUZXh0dXJlRW5jb2RpbmdGcm9tTWFwKCBtYXRlcmlhbC5lbnZNYXAsIHJlbmRlcmVyLmdhbW1hSW5wdXQgKSxcXG5cXHRcXHRcXHRcXHRlbnZNYXBDdWJlVVY6ICggISEgbWF0ZXJpYWwuZW52TWFwICkgJiYgKCAoIG1hdGVyaWFsLmVudk1hcC5tYXBwaW5nID09PSBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyApIHx8ICggbWF0ZXJpYWwuZW52TWFwLm1hcHBpbmcgPT09IEN1YmVVVlJlZnJhY3Rpb25NYXBwaW5nICkgKSxcXG5cXHRcXHRcXHRcXHRsaWdodE1hcDogISEgbWF0ZXJpYWwubGlnaHRNYXAsXFxuXFx0XFx0XFx0XFx0YW9NYXA6ICEhIG1hdGVyaWFsLmFvTWFwLFxcblxcdFxcdFxcdFxcdGVtaXNzaXZlTWFwOiAhISBtYXRlcmlhbC5lbWlzc2l2ZU1hcCxcXG5cXHRcXHRcXHRcXHRlbWlzc2l2ZU1hcEVuY29kaW5nOiBnZXRUZXh0dXJlRW5jb2RpbmdGcm9tTWFwKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCwgcmVuZGVyZXIuZ2FtbWFJbnB1dCApLFxcblxcdFxcdFxcdFxcdGJ1bXBNYXA6ICEhIG1hdGVyaWFsLmJ1bXBNYXAsXFxuXFx0XFx0XFx0XFx0bm9ybWFsTWFwOiAhISBtYXRlcmlhbC5ub3JtYWxNYXAsXFxuXFx0XFx0XFx0XFx0ZGlzcGxhY2VtZW50TWFwOiAhISBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAsXFxuXFx0XFx0XFx0XFx0cm91Z2huZXNzTWFwOiAhISBtYXRlcmlhbC5yb3VnaG5lc3NNYXAsXFxuXFx0XFx0XFx0XFx0bWV0YWxuZXNzTWFwOiAhISBtYXRlcmlhbC5tZXRhbG5lc3NNYXAsXFxuXFx0XFx0XFx0XFx0c3BlY3VsYXJNYXA6ICEhIG1hdGVyaWFsLnNwZWN1bGFyTWFwLFxcblxcdFxcdFxcdFxcdGFscGhhTWFwOiAhISBtYXRlcmlhbC5hbHBoYU1hcCxcXG5cXG5cXHRcXHRcXHRcXHRncmFkaWVudE1hcDogISEgbWF0ZXJpYWwuZ3JhZGllbnRNYXAsXFxuXFxuXFx0XFx0XFx0XFx0Y29tYmluZTogbWF0ZXJpYWwuY29tYmluZSxcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0ZXhDb2xvcnM6IG1hdGVyaWFsLnZlcnRleENvbG9ycyxcXG5cXG5cXHRcXHRcXHRcXHRmb2c6ICEhIGZvZyxcXG5cXHRcXHRcXHRcXHR1c2VGb2c6IG1hdGVyaWFsLmZvZyxcXG5cXHRcXHRcXHRcXHRmb2dFeHA6ICggZm9nICYmIGZvZy5pc0ZvZ0V4cDIgKSxcXG5cXG5cXHRcXHRcXHRcXHRmbGF0U2hhZGluZzogbWF0ZXJpYWwuZmxhdFNoYWRpbmcsXFxuXFxuXFx0XFx0XFx0XFx0c2l6ZUF0dGVudWF0aW9uOiBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24sXFxuXFx0XFx0XFx0XFx0bG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjogY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIsXFxuXFxuXFx0XFx0XFx0XFx0c2tpbm5pbmc6IG1hdGVyaWFsLnNraW5uaW5nICYmIG1heEJvbmVzID4gMCxcXG5cXHRcXHRcXHRcXHRtYXhCb25lczogbWF4Qm9uZXMsXFxuXFx0XFx0XFx0XFx0dXNlVmVydGV4VGV4dHVyZTogY2FwYWJpbGl0aWVzLmZsb2F0VmVydGV4VGV4dHVyZXMsXFxuXFxuXFx0XFx0XFx0XFx0bW9ycGhUYXJnZXRzOiBtYXRlcmlhbC5tb3JwaFRhcmdldHMsXFxuXFx0XFx0XFx0XFx0bW9ycGhOb3JtYWxzOiBtYXRlcmlhbC5tb3JwaE5vcm1hbHMsXFxuXFx0XFx0XFx0XFx0bWF4TW9ycGhUYXJnZXRzOiByZW5kZXJlci5tYXhNb3JwaFRhcmdldHMsXFxuXFx0XFx0XFx0XFx0bWF4TW9ycGhOb3JtYWxzOiByZW5kZXJlci5tYXhNb3JwaE5vcm1hbHMsXFxuXFxuXFx0XFx0XFx0XFx0bnVtRGlyTGlnaHRzOiBsaWdodHMuZGlyZWN0aW9uYWwubGVuZ3RoLFxcblxcdFxcdFxcdFxcdG51bVBvaW50TGlnaHRzOiBsaWdodHMucG9pbnQubGVuZ3RoLFxcblxcdFxcdFxcdFxcdG51bVNwb3RMaWdodHM6IGxpZ2h0cy5zcG90Lmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRudW1SZWN0QXJlYUxpZ2h0czogbGlnaHRzLnJlY3RBcmVhLmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRudW1IZW1pTGlnaHRzOiBsaWdodHMuaGVtaS5sZW5ndGgsXFxuXFxuXFx0XFx0XFx0XFx0bnVtQ2xpcHBpbmdQbGFuZXM6IG5DbGlwUGxhbmVzLFxcblxcdFxcdFxcdFxcdG51bUNsaXBJbnRlcnNlY3Rpb246IG5DbGlwSW50ZXJzZWN0aW9uLFxcblxcblxcdFxcdFxcdFxcdGRpdGhlcmluZzogbWF0ZXJpYWwuZGl0aGVyaW5nLFxcblxcblxcdFxcdFxcdFxcdHNoYWRvd01hcEVuYWJsZWQ6IHJlbmRlcmVyLnNoYWRvd01hcC5lbmFibGVkICYmIG9iamVjdC5yZWNlaXZlU2hhZG93ICYmIHNoYWRvd3MubGVuZ3RoID4gMCxcXG5cXHRcXHRcXHRcXHRzaGFkb3dNYXBUeXBlOiByZW5kZXJlci5zaGFkb3dNYXAudHlwZSxcXG5cXG5cXHRcXHRcXHRcXHR0b25lTWFwcGluZzogcmVuZGVyZXIudG9uZU1hcHBpbmcsXFxuXFx0XFx0XFx0XFx0cGh5c2ljYWxseUNvcnJlY3RMaWdodHM6IHJlbmRlcmVyLnBoeXNpY2FsbHlDb3JyZWN0TGlnaHRzLFxcblxcblxcdFxcdFxcdFxcdHByZW11bHRpcGxpZWRBbHBoYTogbWF0ZXJpYWwucHJlbXVsdGlwbGllZEFscGhhLFxcblxcblxcdFxcdFxcdFxcdGFscGhhVGVzdDogbWF0ZXJpYWwuYWxwaGFUZXN0LFxcblxcdFxcdFxcdFxcdGRvdWJsZVNpZGVkOiBtYXRlcmlhbC5zaWRlID09PSBEb3VibGVTaWRlLFxcblxcdFxcdFxcdFxcdGZsaXBTaWRlZDogbWF0ZXJpYWwuc2lkZSA9PT0gQmFja1NpZGUsXFxuXFxuXFx0XFx0XFx0XFx0ZGVwdGhQYWNraW5nOiAoIG1hdGVyaWFsLmRlcHRoUGFja2luZyAhPT0gdW5kZWZpbmVkICkgPyBtYXRlcmlhbC5kZXB0aFBhY2tpbmcgOiBmYWxzZVxcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHBhcmFtZXRlcnM7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLmdldFByb2dyYW1Db2RlID0gZnVuY3Rpb24gKCBtYXRlcmlhbCwgcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYXJyYXkgPSBbXTtcXG5cXG5cXHRcXHRcXHRpZiAoIHBhcmFtZXRlcnMuc2hhZGVySUQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YXJyYXkucHVzaCggcGFyYW1ldGVycy5zaGFkZXJJRCApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0YXJyYXkucHVzaCggbWF0ZXJpYWwuZnJhZ21lbnRTaGFkZXIgKTtcXG5cXHRcXHRcXHRcXHRhcnJheS5wdXNoKCBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5kZWZpbmVzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIG5hbWUgaW4gbWF0ZXJpYWwuZGVmaW5lcyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRhcnJheS5wdXNoKCBuYW1lICk7XFxuXFx0XFx0XFx0XFx0XFx0YXJyYXkucHVzaCggbWF0ZXJpYWwuZGVmaW5lc1sgbmFtZSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBwYXJhbWV0ZXJOYW1lcy5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YXJyYXkucHVzaCggcGFyYW1ldGVyc1sgcGFyYW1ldGVyTmFtZXNbIGkgXSBdICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGFycmF5LnB1c2goIG1hdGVyaWFsLm9uQmVmb3JlQ29tcGlsZS50b1N0cmluZygpICk7XFxuXFxuXFx0XFx0XFx0YXJyYXkucHVzaCggcmVuZGVyZXIuZ2FtbWFPdXRwdXQgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYXJyYXkuam9pbigpO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5hY3F1aXJlUHJvZ3JhbSA9IGZ1bmN0aW9uICggbWF0ZXJpYWwsIHNoYWRlciwgcGFyYW1ldGVycywgY29kZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcHJvZ3JhbTtcXG5cXG5cXHRcXHRcXHQvLyBDaGVjayBpZiBjb2RlIGhhcyBiZWVuIGFscmVhZHkgY29tcGlsZWRcXG5cXHRcXHRcXHRmb3IgKCB2YXIgcCA9IDAsIHBsID0gcHJvZ3JhbXMubGVuZ3RoOyBwIDwgcGw7IHAgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHByb2dyYW1JbmZvID0gcHJvZ3JhbXNbIHAgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHByb2dyYW1JbmZvLmNvZGUgPT09IGNvZGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cHJvZ3JhbSA9IHByb2dyYW1JbmZvO1xcblxcdFxcdFxcdFxcdFxcdCsrIHByb2dyYW0udXNlZFRpbWVzO1xcblxcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cHJvZ3JhbSA9IG5ldyBXZWJHTFByb2dyYW0oIHJlbmRlcmVyLCBleHRlbnNpb25zLCBjb2RlLCBtYXRlcmlhbCwgc2hhZGVyLCBwYXJhbWV0ZXJzICk7XFxuXFx0XFx0XFx0XFx0cHJvZ3JhbXMucHVzaCggcHJvZ3JhbSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gcHJvZ3JhbTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMucmVsZWFzZVByb2dyYW0gPSBmdW5jdGlvbiAoIHByb2dyYW0gKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCAtLSBwcm9ncmFtLnVzZWRUaW1lcyA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBSZW1vdmUgZnJvbSB1bm9yZGVyZWQgc2V0XFxuXFx0XFx0XFx0XFx0dmFyIGkgPSBwcm9ncmFtcy5pbmRleE9mKCBwcm9ncmFtICk7XFxuXFx0XFx0XFx0XFx0cHJvZ3JhbXNbIGkgXSA9IHByb2dyYW1zWyBwcm9ncmFtcy5sZW5ndGggLSAxIF07XFxuXFx0XFx0XFx0XFx0cHJvZ3JhbXMucG9wKCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRnJlZSBXZWJHTCByZXNvdXJjZXNcXG5cXHRcXHRcXHRcXHRwcm9ncmFtLmRlc3Ryb3koKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBFeHBvc2VkIGZvciByZXNvdXJjZSBtb25pdG9yaW5nICYgZXJyb3IgZmVlZGJhY2sgdmlhIHJlbmRlcmVyLmluZm86XFxuXFx0XFx0dGhpcy5wcm9ncmFtcyA9IHByb2dyYW1zO1xcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFdlYkdMVGV4dHVyZXMoIF9nbCwgZXh0ZW5zaW9ucywgc3RhdGUsIHByb3BlcnRpZXMsIGNhcGFiaWxpdGllcywgdXRpbHMsIGluZm9NZW1vcnkgKSB7XFxuXFxuXFx0XFx0dmFyIF9pc1dlYkdMMiA9ICggdHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQgIT09ICd1bmRlZmluZWQnICYmIF9nbCBpbnN0YW5jZW9mIHdpbmRvdy5XZWJHTDJSZW5kZXJpbmdDb250ZXh0ICk7XFxuXFx0XFx0dmFyIF92aWRlb1RleHR1cmVzID0ge307XFxuXFxuXFx0XFx0Ly9cXG5cXG5cXHRcXHRmdW5jdGlvbiBjbGFtcFRvTWF4U2l6ZSggaW1hZ2UsIG1heFNpemUgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBpbWFnZS53aWR0aCA+IG1heFNpemUgfHwgaW1hZ2UuaGVpZ2h0ID4gbWF4U2l6ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBXYXJuaW5nOiBTY2FsaW5nIHRocm91Z2ggdGhlIGNhbnZhcyB3aWxsIG9ubHkgd29yayB3aXRoIGltYWdlcyB0aGF0IHVzZVxcblxcdFxcdFxcdFxcdC8vIHByZW11bHRpcGxpZWQgYWxwaGEuXFxuXFxuXFx0XFx0XFx0XFx0dmFyIHNjYWxlID0gbWF4U2l6ZSAvIE1hdGgubWF4KCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0ICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyApO1xcblxcdFxcdFxcdFxcdGNhbnZhcy53aWR0aCA9IE1hdGguZmxvb3IoIGltYWdlLndpZHRoICogc2NhbGUgKTtcXG5cXHRcXHRcXHRcXHRjYW52YXMuaGVpZ2h0ID0gTWF0aC5mbG9vciggaW1hZ2UuaGVpZ2h0ICogc2NhbGUgKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCAnMmQnICk7XFxuXFx0XFx0XFx0XFx0Y29udGV4dC5kcmF3SW1hZ2UoIGltYWdlLCAwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0LCAwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQgKTtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBpbWFnZSBpcyB0b28gYmlnICgnICsgaW1hZ2Uud2lkdGggKyAneCcgKyBpbWFnZS5oZWlnaHQgKyAnKS4gUmVzaXplZCB0byAnICsgY2FudmFzLndpZHRoICsgJ3gnICsgY2FudmFzLmhlaWdodCwgaW1hZ2UgKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gY2FudmFzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gaW1hZ2U7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGlzUG93ZXJPZlR3byggaW1hZ2UgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIF9NYXRoLmlzUG93ZXJPZlR3byggaW1hZ2Uud2lkdGggKSAmJiBfTWF0aC5pc1Bvd2VyT2ZUd28oIGltYWdlLmhlaWdodCApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBtYWtlUG93ZXJPZlR3byggaW1hZ2UgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQgfHwgaW1hZ2UgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCB8fCBpbWFnZSBpbnN0YW5jZW9mIEltYWdlQml0bWFwICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywgJ2NhbnZhcycgKTtcXG5cXHRcXHRcXHRcXHRjYW52YXMud2lkdGggPSBfTWF0aC5mbG9vclBvd2VyT2ZUd28oIGltYWdlLndpZHRoICk7XFxuXFx0XFx0XFx0XFx0Y2FudmFzLmhlaWdodCA9IF9NYXRoLmZsb29yUG93ZXJPZlR3byggaW1hZ2UuaGVpZ2h0ICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCggJzJkJyApO1xcblxcdFxcdFxcdFxcdGNvbnRleHQuZHJhd0ltYWdlKCBpbWFnZSwgMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0ICk7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogaW1hZ2UgaXMgbm90IHBvd2VyIG9mIHR3byAoJyArIGltYWdlLndpZHRoICsgJ3gnICsgaW1hZ2UuaGVpZ2h0ICsgJykuIFJlc2l6ZWQgdG8gJyArIGNhbnZhcy53aWR0aCArICd4JyArIGNhbnZhcy5oZWlnaHQsIGltYWdlICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNhbnZhcztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGltYWdlO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiB0ZXh0dXJlTmVlZHNQb3dlck9mVHdvKCB0ZXh0dXJlICkge1xcblxcblxcdFxcdFxcdHJldHVybiAoIHRleHR1cmUud3JhcFMgIT09IENsYW1wVG9FZGdlV3JhcHBpbmcgfHwgdGV4dHVyZS53cmFwVCAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyApIHx8XFxuXFx0XFx0XFx0XFx0KCB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTGluZWFyRmlsdGVyICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSwgaXNQb3dlck9mVHdvICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcyAmJiBpc1Bvd2VyT2ZUd28gJiZcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTmVhcmVzdEZpbHRlciAmJiB0ZXh0dXJlLm1pbkZpbHRlciAhPT0gTGluZWFyRmlsdGVyO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBGYWxsYmFjayBmaWx0ZXJzIGZvciBub24tcG93ZXItb2YtMiB0ZXh0dXJlc1xcblxcblxcdFxcdGZ1bmN0aW9uIGZpbHRlckZhbGxiYWNrKCBmICkge1xcblxcblxcdFxcdFxcdGlmICggZiA9PT0gTmVhcmVzdEZpbHRlciB8fCBmID09PSBOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciB8fCBmID09PSBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBfZ2wuTkVBUkVTVDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIF9nbC5MSU5FQVI7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vXFxuXFxuXFx0XFx0ZnVuY3Rpb24gb25UZXh0dXJlRGlzcG9zZSggZXZlbnQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRleHR1cmUgPSBldmVudC50YXJnZXQ7XFxuXFxuXFx0XFx0XFx0dGV4dHVyZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uVGV4dHVyZURpc3Bvc2UgKTtcXG5cXG5cXHRcXHRcXHRkZWFsbG9jYXRlVGV4dHVyZSggdGV4dHVyZSApO1xcblxcblxcdFxcdFxcdGlmICggdGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRkZWxldGUgX3ZpZGVvVGV4dHVyZXNbIHRleHR1cmUuaWQgXTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aW5mb01lbW9yeS50ZXh0dXJlcyAtLTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gb25SZW5kZXJUYXJnZXREaXNwb3NlKCBldmVudCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcmVuZGVyVGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xcblxcblxcdFxcdFxcdHJlbmRlclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCAnZGlzcG9zZScsIG9uUmVuZGVyVGFyZ2V0RGlzcG9zZSApO1xcblxcblxcdFxcdFxcdGRlYWxsb2NhdGVSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xcblxcblxcdFxcdFxcdGluZm9NZW1vcnkudGV4dHVyZXMgLS07XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vXFxuXFxuXFx0XFx0ZnVuY3Rpb24gZGVhbGxvY2F0ZVRleHR1cmUoIHRleHR1cmUgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRleHR1cmUuaW1hZ2UgJiYgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBjdWJlIHRleHR1cmVcXG5cXG5cXHRcXHRcXHRcXHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gMkQgdGV4dHVyZVxcblxcblxcdFxcdFxcdFxcdGlmICggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPT09IHVuZGVmaW5lZCApIHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHRfZ2wuZGVsZXRlVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gcmVtb3ZlIGFsbCB3ZWJnbCBwcm9wZXJ0aWVzXFxuXFx0XFx0XFx0cHJvcGVydGllcy5yZW1vdmUoIHRleHR1cmUgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZGVhbGxvY2F0ZVJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHZhciByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApO1xcblxcdFxcdFxcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xcblxcblxcdFxcdFxcdGlmICggISByZW5kZXJUYXJnZXQgKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0aWYgKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdF9nbC5kZWxldGVUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5kaXNwb3NlKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlICkge1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0X2dsLmRlbGV0ZUZyYW1lYnVmZmVyKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciApIF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRfZ2wuZGVsZXRlRnJhbWVidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyICk7XFxuXFx0XFx0XFx0XFx0aWYgKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlciApIF9nbC5kZWxldGVSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHByb3BlcnRpZXMucmVtb3ZlKCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xcblxcdFxcdFxcdHByb3BlcnRpZXMucmVtb3ZlKCByZW5kZXJUYXJnZXQgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly9cXG5cXG5cXG5cXG5cXHRcXHRmdW5jdGlvbiBzZXRUZXh0dXJlMkQoIHRleHR1cmUsIHNsb3QgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRleHR1cmVQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIHRleHR1cmUgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRleHR1cmUudmVyc2lvbiA+IDAgJiYgdGV4dHVyZVByb3BlcnRpZXMuX192ZXJzaW9uICE9PSB0ZXh0dXJlLnZlcnNpb24gKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGltYWdlID0gdGV4dHVyZS5pbWFnZTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGltYWdlID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVGV4dHVyZSBtYXJrZWQgZm9yIHVwZGF0ZSBidXQgaW1hZ2UgaXMgdW5kZWZpbmVkJywgdGV4dHVyZSApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIGltYWdlLmNvbXBsZXRlID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIG1hcmtlZCBmb3IgdXBkYXRlIGJ1dCBpbWFnZSBpcyBpbmNvbXBsZXRlJywgdGV4dHVyZSApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dXBsb2FkVGV4dHVyZSggdGV4dHVyZVByb3BlcnRpZXMsIHRleHR1cmUsIHNsb3QgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XFxuXFx0XFx0XFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBzZXRUZXh0dXJlQ3ViZSggdGV4dHVyZSwgc2xvdCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApO1xcblxcblxcdFxcdFxcdGlmICggdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlLnZlcnNpb24gPiAwICYmIHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiAhPT0gdGV4dHVyZS52ZXJzaW9uICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggISB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aW5mb01lbW9yeS50ZXh0dXJlcyArKztcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xcblxcdFxcdFxcdFxcdFxcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZVByb3BlcnRpZXMuX19pbWFnZV9fd2ViZ2xUZXh0dXJlQ3ViZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdF9nbC5waXhlbFN0b3JlaSggX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRleHR1cmUuZmxpcFkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgaXNDb21wcmVzc2VkID0gKCB0ZXh0dXJlICYmIHRleHR1cmUuaXNDb21wcmVzc2VkVGV4dHVyZSApO1xcblxcdFxcdFxcdFxcdFxcdHZhciBpc0RhdGFUZXh0dXJlID0gKCB0ZXh0dXJlLmltYWdlWyAwIF0gJiYgdGV4dHVyZS5pbWFnZVsgMCBdLmlzRGF0YVRleHR1cmUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgY3ViZUltYWdlID0gW107XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoICEgaXNDb21wcmVzc2VkICYmICEgaXNEYXRhVGV4dHVyZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjdWJlSW1hZ2VbIGkgXSA9IGNsYW1wVG9NYXhTaXplKCB0ZXh0dXJlLmltYWdlWyBpIF0sIGNhcGFiaWxpdGllcy5tYXhDdWJlbWFwU2l6ZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3ViZUltYWdlWyBpIF0gPSBpc0RhdGFUZXh0dXJlID8gdGV4dHVyZS5pbWFnZVsgaSBdLmltYWdlIDogdGV4dHVyZS5pbWFnZVsgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGltYWdlID0gY3ViZUltYWdlWyAwIF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0aXNQb3dlck9mVHdvSW1hZ2UgPSBpc1Bvd2VyT2ZUd28oIGltYWdlICksXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2xGb3JtYXQgPSB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLmZvcm1hdCApLFxcblxcdFxcdFxcdFxcdFxcdFxcdGdsVHlwZSA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUudHlwZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgdGV4dHVyZSwgaXNQb3dlck9mVHdvSW1hZ2UgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCA2OyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggISBpc0NvbXByZXNzZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpc0RhdGFUZXh0dXJlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCAwLCBnbEZvcm1hdCwgY3ViZUltYWdlWyBpIF0ud2lkdGgsIGN1YmVJbWFnZVsgaSBdLmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgY3ViZUltYWdlWyBpIF0uZGF0YSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCArIGksIDAsIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBjdWJlSW1hZ2VbIGkgXSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBtaXBtYXAsIG1pcG1hcHMgPSBjdWJlSW1hZ2VbIGkgXS5taXBtYXBzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMCwgamwgPSBtaXBtYXBzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG1pcG1hcCA9IG1pcG1hcHNbIGogXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBSR0JBRm9ybWF0ICYmIHRleHR1cmUuZm9ybWF0ICE9PSBSR0JGb3JtYXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBzdGF0ZS5nZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKS5pbmRleE9mKCBnbEZvcm1hdCApID4gLSAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSwgaiwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC5zZXRUZXh0dXJlQ3ViZSgpJyApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyBpLCBqLCBnbEZvcm1hdCwgbWlwbWFwLndpZHRoLCBtaXBtYXAuaGVpZ2h0LCAwLCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAuZGF0YSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSwgaXNQb3dlck9mVHdvSW1hZ2UgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRfZ2wuZ2VuZXJhdGVNaXBtYXAoIF9nbC5URVhUVVJFX0NVQkVfTUFQICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRleHR1cmUub25VcGRhdGUgKSB0ZXh0dXJlLm9uVXBkYXRlKCB0ZXh0dXJlICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5hY3RpdmVUZXh0dXJlKCBfZ2wuVEVYVFVSRTAgKyBzbG90ICk7XFxuXFx0XFx0XFx0XFx0XFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX2ltYWdlX193ZWJnbFRleHR1cmVDdWJlICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2V0VGV4dHVyZUN1YmVEeW5hbWljKCB0ZXh0dXJlLCBzbG90ICkge1xcblxcblxcdFxcdFxcdHN0YXRlLmFjdGl2ZVRleHR1cmUoIF9nbC5URVhUVVJFMCArIHNsb3QgKTtcXG5cXHRcXHRcXHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfQ1VCRV9NQVAsIHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX193ZWJnbFRleHR1cmUgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2V0VGV4dHVyZVBhcmFtZXRlcnMoIHRleHR1cmVUeXBlLCB0ZXh0dXJlLCBpc1Bvd2VyT2ZUd29JbWFnZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZXh0ZW5zaW9uO1xcblxcblxcdFxcdFxcdGlmICggaXNQb3dlck9mVHdvSW1hZ2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9XUkFQX1MsIHV0aWxzLmNvbnZlcnQoIHRleHR1cmUud3JhcFMgKSApO1xcblxcdFxcdFxcdFxcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlLndyYXBUICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIHV0aWxzLmNvbnZlcnQoIHRleHR1cmUubWFnRmlsdGVyICkgKTtcXG5cXHRcXHRcXHRcXHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01JTl9GSUxURVIsIHV0aWxzLmNvbnZlcnQoIHRleHR1cmUubWluRmlsdGVyICkgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9TLCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xcblxcdFxcdFxcdFxcdF9nbC50ZXhQYXJhbWV0ZXJpKCB0ZXh0dXJlVHlwZSwgX2dsLlRFWFRVUkVfV1JBUF9ULCBfZ2wuQ0xBTVBfVE9fRURHRSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggdGV4dHVyZS53cmFwUyAhPT0gQ2xhbXBUb0VkZ2VXcmFwcGluZyB8fCB0ZXh0dXJlLndyYXBUICE9PSBDbGFtcFRvRWRnZVdyYXBwaW5nICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFRleHR1cmUgaXMgbm90IHBvd2VyIG9mIHR3by4gVGV4dHVyZS53cmFwUyBhbmQgVGV4dHVyZS53cmFwVCBzaG91bGQgYmUgc2V0IHRvIFRIUkVFLkNsYW1wVG9FZGdlV3JhcHBpbmcuJywgdGV4dHVyZSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRfZ2wudGV4UGFyYW1ldGVyaSggdGV4dHVyZVR5cGUsIF9nbC5URVhUVVJFX01BR19GSUxURVIsIGZpbHRlckZhbGxiYWNrKCB0ZXh0dXJlLm1hZ0ZpbHRlciApICk7XFxuXFx0XFx0XFx0XFx0X2dsLnRleFBhcmFtZXRlcmkoIHRleHR1cmVUeXBlLCBfZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBmaWx0ZXJGYWxsYmFjayggdGV4dHVyZS5taW5GaWx0ZXIgKSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggdGV4dHVyZS5taW5GaWx0ZXIgIT09IE5lYXJlc3RGaWx0ZXIgJiYgdGV4dHVyZS5taW5GaWx0ZXIgIT09IExpbmVhckZpbHRlciApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBUZXh0dXJlIGlzIG5vdCBwb3dlciBvZiB0d28uIFRleHR1cmUubWluRmlsdGVyIHNob3VsZCBiZSBzZXQgdG8gVEhSRUUuTmVhcmVzdEZpbHRlciBvciBUSFJFRS5MaW5lYXJGaWx0ZXIuJywgdGV4dHVyZSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBleHRlbnNpb24gKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlLnR5cGUgPT09IEZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicgKSA9PT0gbnVsbCApIHJldHVybjtcXG5cXHRcXHRcXHRcXHRpZiAoIHRleHR1cmUudHlwZSA9PT0gSGFsZkZsb2F0VHlwZSAmJiBleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyJyApID09PSBudWxsICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdGlmICggdGV4dHVyZS5hbmlzb3Ryb3B5ID4gMSB8fCBwcm9wZXJ0aWVzLmdldCggdGV4dHVyZSApLl9fY3VycmVudEFuaXNvdHJvcHkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0X2dsLnRleFBhcmFtZXRlcmYoIHRleHR1cmVUeXBlLCBleHRlbnNpb24uVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIE1hdGgubWluKCB0ZXh0dXJlLmFuaXNvdHJvcHksIGNhcGFiaWxpdGllcy5nZXRNYXhBbmlzb3Ryb3B5KCkgKSApO1xcblxcdFxcdFxcdFxcdFxcdHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX19jdXJyZW50QW5pc290cm9weSA9IHRleHR1cmUuYW5pc290cm9weTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiB1cGxvYWRUZXh0dXJlKCB0ZXh0dXJlUHJvcGVydGllcywgdGV4dHVyZSwgc2xvdCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xJbml0ID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbEluaXQgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdHRleHR1cmUuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblRleHR1cmVEaXNwb3NlICk7XFxuXFxuXFx0XFx0XFx0XFx0dGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgPSBfZ2wuY3JlYXRlVGV4dHVyZSgpO1xcblxcblxcdFxcdFxcdFxcdGlmICggdGV4dHVyZS5pc1ZpZGVvVGV4dHVyZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRfdmlkZW9UZXh0dXJlc1sgdGV4dHVyZS5pZCBdID0gdGV4dHVyZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aW5mb01lbW9yeS50ZXh0dXJlcyArKztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0c3RhdGUuYWN0aXZlVGV4dHVyZSggX2dsLlRFWFRVUkUwICsgc2xvdCApO1xcblxcdFxcdFxcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZVByb3BlcnRpZXMuX193ZWJnbFRleHR1cmUgKTtcXG5cXG5cXHRcXHRcXHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0ZXh0dXJlLmZsaXBZICk7XFxuXFx0XFx0XFx0X2dsLnBpeGVsU3RvcmVpKCBfZ2wuVU5QQUNLX1BSRU1VTFRJUExZX0FMUEhBX1dFQkdMLCB0ZXh0dXJlLnByZW11bHRpcGx5QWxwaGEgKTtcXG5cXHRcXHRcXHRfZ2wucGl4ZWxTdG9yZWkoIF9nbC5VTlBBQ0tfQUxJR05NRU5ULCB0ZXh0dXJlLnVucGFja0FsaWdubWVudCApO1xcblxcblxcdFxcdFxcdHZhciBpbWFnZSA9IGNsYW1wVG9NYXhTaXplKCB0ZXh0dXJlLmltYWdlLCBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZVNpemUgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRleHR1cmVOZWVkc1Bvd2VyT2ZUd28oIHRleHR1cmUgKSAmJiBpc1Bvd2VyT2ZUd28oIGltYWdlICkgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdGltYWdlID0gbWFrZVBvd2VyT2ZUd28oIGltYWdlICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBpc1Bvd2VyT2ZUd29JbWFnZSA9IGlzUG93ZXJPZlR3byggaW1hZ2UgKSxcXG5cXHRcXHRcXHRcXHRnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQoIHRleHR1cmUuZm9ybWF0ICksXFxuXFx0XFx0XFx0XFx0Z2xUeXBlID0gdXRpbHMuY29udmVydCggdGV4dHVyZS50eXBlICk7XFxuXFxuXFx0XFx0XFx0c2V0VGV4dHVyZVBhcmFtZXRlcnMoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlLCBpc1Bvd2VyT2ZUd29JbWFnZSApO1xcblxcblxcdFxcdFxcdHZhciBtaXBtYXAsIG1pcG1hcHMgPSB0ZXh0dXJlLm1pcG1hcHM7XFxuXFxuXFx0XFx0XFx0aWYgKCB0ZXh0dXJlLmlzRGVwdGhUZXh0dXJlICkge1xcblxcblxcdFxcdFxcdFxcdC8vIHBvcHVsYXRlIGRlcHRoIHRleHR1cmUgd2l0aCBkdW1teSBkYXRhXFxuXFxuXFx0XFx0XFx0XFx0dmFyIGludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRleHR1cmUudHlwZSA9PT0gRmxvYXRUeXBlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggISBfaXNXZWJHTDIgKSB0aHJvdyBuZXcgRXJyb3IoICdGbG9hdCBEZXB0aCBUZXh0dXJlIG9ubHkgc3VwcG9ydGVkIGluIFdlYkdMMi4wJyApO1xcblxcdFxcdFxcdFxcdFxcdGludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX0NPTVBPTkVOVDMyRjtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBfaXNXZWJHTDIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gV2ViR0wgMi4wIHJlcXVpcmVzIHNpZ25lZCBpbnRlcm5hbGZvcm1hdCBmb3IgZ2xUZXhJbWFnZTJEXFxuXFx0XFx0XFx0XFx0XFx0aW50ZXJuYWxGb3JtYXQgPSBfZ2wuREVQVEhfQ09NUE9ORU5UMTY7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggdGV4dHVyZS5mb3JtYXQgPT09IERlcHRoRm9ybWF0ICYmIGludGVybmFsRm9ybWF0ID09PSBfZ2wuREVQVEhfQ09NUE9ORU5UICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFRoZSBlcnJvciBJTlZBTElEX09QRVJBVElPTiBpcyBnZW5lcmF0ZWQgYnkgdGV4SW1hZ2UyRCBpZiBmb3JtYXQgYW5kIGludGVybmFsZm9ybWF0IGFyZVxcblxcdFxcdFxcdFxcdFxcdC8vIERFUFRIX0NPTVBPTkVOVCBhbmQgdHlwZSBpcyBub3QgVU5TSUdORURfU0hPUlQgb3IgVU5TSUdORURfSU5UXFxuXFx0XFx0XFx0XFx0XFx0Ly8gKGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL2V4dGVuc2lvbnMvV0VCR0xfZGVwdGhfdGV4dHVyZS8pXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlLnR5cGUgIT09IFVuc2lnbmVkU2hvcnRUeXBlICYmIHRleHR1cmUudHlwZSAhPT0gVW5zaWduZWRJbnRUeXBlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IFVzZSBVbnNpZ25lZFNob3J0VHlwZSBvciBVbnNpZ25lZEludFR5cGUgZm9yIERlcHRoRm9ybWF0IERlcHRoVGV4dHVyZS4nICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZS50eXBlID0gVW5zaWduZWRTaG9ydFR5cGU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2xUeXBlID0gdXRpbHMuY29udmVydCggdGV4dHVyZS50eXBlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBEZXB0aCBzdGVuY2lsIHRleHR1cmVzIG5lZWQgdGhlIERFUFRIX1NURU5DSUwgaW50ZXJuYWwgZm9ybWF0XFxuXFx0XFx0XFx0XFx0Ly8gKGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL2V4dGVuc2lvbnMvV0VCR0xfZGVwdGhfdGV4dHVyZS8pXFxuXFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGludGVybmFsRm9ybWF0ID0gX2dsLkRFUFRIX1NURU5DSUw7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVGhlIGVycm9yIElOVkFMSURfT1BFUkFUSU9OIGlzIGdlbmVyYXRlZCBieSB0ZXhJbWFnZTJEIGlmIGZvcm1hdCBhbmQgaW50ZXJuYWxmb3JtYXQgYXJlXFxuXFx0XFx0XFx0XFx0XFx0Ly8gREVQVEhfU1RFTkNJTCBhbmQgdHlwZSBpcyBub3QgVU5TSUdORURfSU5UXzI0XzhfV0VCR0wuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gKGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3JlZ2lzdHJ5L3dlYmdsL2V4dGVuc2lvbnMvV0VCR0xfZGVwdGhfdGV4dHVyZS8pXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlLnR5cGUgIT09IFVuc2lnbmVkSW50MjQ4VHlwZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiBVc2UgVW5zaWduZWRJbnQyNDhUeXBlIGZvciBEZXB0aFN0ZW5jaWxGb3JtYXQgRGVwdGhUZXh0dXJlLicgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLnR5cGUgPSBVbnNpZ25lZEludDI0OFR5cGU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2xUeXBlID0gdXRpbHMuY29udmVydCggdGV4dHVyZS50eXBlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgaW50ZXJuYWxGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG51bGwgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCB0ZXh0dXJlLmlzRGF0YVRleHR1cmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcXG5cXHRcXHRcXHRcXHQvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcXG5cXHRcXHRcXHRcXHQvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG1pcG1hcHMubGVuZ3RoID4gMCAmJiBpc1Bvd2VyT2ZUd29JbWFnZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS50ZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgMCwgZ2xGb3JtYXQsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIGltYWdlLmRhdGEgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggdGV4dHVyZS5pc0NvbXByZXNzZWRUZXh0dXJlICkge1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBtaXBtYXBzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG1pcG1hcCA9IG1pcG1hcHNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRleHR1cmUuZm9ybWF0ICE9PSBSR0JBRm9ybWF0ICYmIHRleHR1cmUuZm9ybWF0ICE9PSBSR0JGb3JtYXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBzdGF0ZS5nZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMoKS5pbmRleE9mKCBnbEZvcm1hdCApID4gLSAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlLmNvbXByZXNzZWRUZXhJbWFnZTJEKCBfZ2wuVEVYVFVSRV8yRCwgaSwgZ2xGb3JtYXQsIG1pcG1hcC53aWR0aCwgbWlwbWFwLmhlaWdodCwgMCwgbWlwbWFwLmRhdGEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IEF0dGVtcHQgdG8gbG9hZCB1bnN1cHBvcnRlZCBjb21wcmVzc2VkIHRleHR1cmUgZm9ybWF0IGluIC51cGxvYWRUZXh0dXJlKCknICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBtaXBtYXAud2lkdGgsIG1pcG1hcC5oZWlnaHQsIDAsIGdsRm9ybWF0LCBnbFR5cGUsIG1pcG1hcC5kYXRhICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdC8vIHJlZ3VsYXIgVGV4dHVyZSAoaW1hZ2UsIHZpZGVvLCBjYW52YXMpXFxuXFxuXFx0XFx0XFx0XFx0Ly8gdXNlIG1hbnVhbGx5IGNyZWF0ZWQgbWlwbWFwcyBpZiBhdmFpbGFibGVcXG5cXHRcXHRcXHRcXHQvLyBpZiB0aGVyZSBhcmUgbm8gbWFudWFsIG1pcG1hcHNcXG5cXHRcXHRcXHRcXHQvLyBzZXQgMCBsZXZlbCBtaXBtYXAgYW5kIHRoZW4gdXNlIEdMIHRvIGdlbmVyYXRlIG90aGVyIG1pcG1hcCBsZXZlbHNcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG1pcG1hcHMubGVuZ3RoID4gMCAmJiBpc1Bvd2VyT2ZUd29JbWFnZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbWlwbWFwcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRtaXBtYXAgPSBtaXBtYXBzWyBpIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUudGV4SW1hZ2UyRCggX2dsLlRFWFRVUkVfMkQsIGksIGdsRm9ybWF0LCBnbEZvcm1hdCwgZ2xUeXBlLCBtaXBtYXAgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHN0YXRlLnRleEltYWdlMkQoIF9nbC5URVhUVVJFXzJELCAwLCBnbEZvcm1hdCwgZ2xGb3JtYXQsIGdsVHlwZSwgaW1hZ2UgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdGV4dHVyZU5lZWRzR2VuZXJhdGVNaXBtYXBzKCB0ZXh0dXJlLCBpc1Bvd2VyT2ZUd29JbWFnZSApICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV8yRCApO1xcblxcblxcdFxcdFxcdHRleHR1cmVQcm9wZXJ0aWVzLl9fdmVyc2lvbiA9IHRleHR1cmUudmVyc2lvbjtcXG5cXG5cXHRcXHRcXHRpZiAoIHRleHR1cmUub25VcGRhdGUgKSB0ZXh0dXJlLm9uVXBkYXRlKCB0ZXh0dXJlICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFJlbmRlciB0YXJnZXRzXFxuXFxuXFx0XFx0Ly8gU2V0dXAgc3RvcmFnZSBmb3IgdGFyZ2V0IHRleHR1cmUgYW5kIGJpbmQgaXQgdG8gY29ycmVjdCBmcmFtZWJ1ZmZlclxcblxcdFxcdGZ1bmN0aW9uIHNldHVwRnJhbWVCdWZmZXJUZXh0dXJlKCBmcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCBhdHRhY2htZW50LCB0ZXh0dXJlVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHZhciBnbEZvcm1hdCA9IHV0aWxzLmNvbnZlcnQoIHJlbmRlclRhcmdldC50ZXh0dXJlLmZvcm1hdCApO1xcblxcdFxcdFxcdHZhciBnbFR5cGUgPSB1dGlscy5jb252ZXJ0KCByZW5kZXJUYXJnZXQudGV4dHVyZS50eXBlICk7XFxuXFx0XFx0XFx0c3RhdGUudGV4SW1hZ2UyRCggdGV4dHVyZVRhcmdldCwgMCwgZ2xGb3JtYXQsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCwgMCwgZ2xGb3JtYXQsIGdsVHlwZSwgbnVsbCApO1xcblxcdFxcdFxcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIgKTtcXG5cXHRcXHRcXHRfZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoIF9nbC5GUkFNRUJVRkZFUiwgYXR0YWNobWVudCwgdGV4dHVyZVRhcmdldCwgcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldC50ZXh0dXJlICkuX193ZWJnbFRleHR1cmUsIDAgKTtcXG5cXHRcXHRcXHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU2V0dXAgc3RvcmFnZSBmb3IgaW50ZXJuYWwgZGVwdGgvc3RlbmNpbCBidWZmZXJzIGFuZCBiaW5kIHRvIGNvcnJlY3QgZnJhbWVidWZmZXJcXG5cXHRcXHRmdW5jdGlvbiBzZXR1cFJlbmRlckJ1ZmZlclN0b3JhZ2UoIHJlbmRlcmJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdF9nbC5iaW5kUmVuZGVyYnVmZmVyKCBfZ2wuUkVOREVSQlVGRkVSLCByZW5kZXJidWZmZXIgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHJlbmRlclRhcmdldC5kZXB0aEJ1ZmZlciAmJiAhIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xcblxcblxcdFxcdFxcdFxcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuREVQVEhfQ09NUE9ORU5UMTYsIHJlbmRlclRhcmdldC53aWR0aCwgcmVuZGVyVGFyZ2V0LmhlaWdodCApO1xcblxcdFxcdFxcdFxcdF9nbC5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfQVRUQUNITUVOVCwgX2dsLlJFTkRFUkJVRkZFUiwgcmVuZGVyYnVmZmVyICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICYmIHJlbmRlclRhcmdldC5zdGVuY2lsQnVmZmVyICkge1xcblxcblxcdFxcdFxcdFxcdF9nbC5yZW5kZXJidWZmZXJTdG9yYWdlKCBfZ2wuUkVOREVSQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XFxuXFx0XFx0XFx0XFx0X2dsLmZyYW1lYnVmZmVyUmVuZGVyYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9TVEVOQ0lMX0FUVEFDSE1FTlQsIF9nbC5SRU5ERVJCVUZGRVIsIHJlbmRlcmJ1ZmZlciApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRklYTUU6IFdlIGRvbid0IHN1cHBvcnQgIWRlcHRoICFzdGVuY2lsXFxuXFx0XFx0XFx0XFx0X2dsLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoIF9nbC5SRU5ERVJCVUZGRVIsIF9nbC5SR0JBNCwgcmVuZGVyVGFyZ2V0LndpZHRoLCByZW5kZXJUYXJnZXQuaGVpZ2h0ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdF9nbC5iaW5kUmVuZGVyYnVmZmVyKCBfZ2wuUkVOREVSQlVGRkVSLCBudWxsICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNldHVwIHJlc291cmNlcyBmb3IgYSBEZXB0aCBUZXh0dXJlIGZvciBhIEZCTyAobmVlZHMgYW4gZXh0ZW5zaW9uKVxcblxcdFxcdGZ1bmN0aW9uIHNldHVwRGVwdGhUZXh0dXJlKCBmcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdHZhciBpc0N1YmUgPSAoIHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgKTtcXG5cXHRcXHRcXHRpZiAoIGlzQ3ViZSApIHRocm93IG5ldyBFcnJvciggJ0RlcHRoIFRleHR1cmUgd2l0aCBjdWJlIHJlbmRlciB0YXJnZXRzIGlzIG5vdCBzdXBwb3J0ZWQnICk7XFxuXFxuXFx0XFx0XFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xcblxcblxcdFxcdFxcdGlmICggISAoIHJlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgJiYgcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pc0RlcHRoVGV4dHVyZSApICkge1xcblxcblxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggJ3JlbmRlclRhcmdldC5kZXB0aFRleHR1cmUgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBUSFJFRS5EZXB0aFRleHR1cmUnICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHVwbG9hZCBhbiBlbXB0eSBkZXB0aCB0ZXh0dXJlIHdpdGggZnJhbWVidWZmZXIgc2l6ZVxcblxcdFxcdFxcdGlmICggISBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSApLl9fd2ViZ2xUZXh0dXJlIHx8XFxuXFx0XFx0XFx0XFx0XFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS53aWR0aCAhPT0gcmVuZGVyVGFyZ2V0LndpZHRoIHx8XFxuXFx0XFx0XFx0XFx0XFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS5oZWlnaHQgIT09IHJlbmRlclRhcmdldC5oZWlnaHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5pbWFnZS53aWR0aCA9IHJlbmRlclRhcmdldC53aWR0aDtcXG5cXHRcXHRcXHRcXHRyZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmltYWdlLmhlaWdodCA9IHJlbmRlclRhcmdldC5oZWlnaHQ7XFxuXFx0XFx0XFx0XFx0cmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHNldFRleHR1cmUyRCggcmVuZGVyVGFyZ2V0LmRlcHRoVGV4dHVyZSwgMCApO1xcblxcblxcdFxcdFxcdHZhciB3ZWJnbERlcHRoVGV4dHVyZSA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICkuX193ZWJnbFRleHR1cmU7XFxuXFxuXFx0XFx0XFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhGb3JtYXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0X2dsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKCBfZ2wuRlJBTUVCVUZGRVIsIF9nbC5ERVBUSF9BVFRBQ0hNRU5ULCBfZ2wuVEVYVFVSRV8yRCwgd2ViZ2xEZXB0aFRleHR1cmUsIDAgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlLmZvcm1hdCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0ICkge1xcblxcblxcdFxcdFxcdFxcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuREVQVEhfU1RFTkNJTF9BVFRBQ0hNRU5ULCBfZ2wuVEVYVFVSRV8yRCwgd2ViZ2xEZXB0aFRleHR1cmUsIDAgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggJ1Vua25vd24gZGVwdGhUZXh0dXJlIGZvcm1hdCcgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNldHVwIEdMIHJlc291cmNlcyBmb3IgYSBub24tdGV4dHVyZSBkZXB0aCBidWZmZXJcXG5cXHRcXHRmdW5jdGlvbiBzZXR1cERlcHRoUmVuZGVyYnVmZmVyKCByZW5kZXJUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJlbmRlclRhcmdldFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICk7XFxuXFxuXFx0XFx0XFx0dmFyIGlzQ3ViZSA9ICggcmVuZGVyVGFyZ2V0LmlzV2ViR0xSZW5kZXJUYXJnZXRDdWJlID09PSB0cnVlICk7XFxuXFxuXFx0XFx0XFx0aWYgKCByZW5kZXJUYXJnZXQuZGVwdGhUZXh0dXJlICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggaXNDdWJlICkgdGhyb3cgbmV3IEVycm9yKCAndGFyZ2V0LmRlcHRoVGV4dHVyZSBub3Qgc3VwcG9ydGVkIGluIEN1YmUgcmVuZGVyIHRhcmdldHMnICk7XFxuXFxuXFx0XFx0XFx0XFx0c2V0dXBEZXB0aFRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyLCByZW5kZXJUYXJnZXQgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdGlmICggaXNDdWJlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyID0gW107XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xEZXB0aGJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHNldHVwUmVuZGVyQnVmZmVyU3RvcmFnZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXJbIGkgXSwgcmVuZGVyVGFyZ2V0ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciApO1xcblxcdFxcdFxcdFxcdFxcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbERlcHRoYnVmZmVyID0gX2dsLmNyZWF0ZVJlbmRlcmJ1ZmZlcigpO1xcblxcdFxcdFxcdFxcdFxcdHNldHVwUmVuZGVyQnVmZmVyU3RvcmFnZSggcmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRGVwdGhidWZmZXIsIHJlbmRlclRhcmdldCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBudWxsICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIFNldCB1cCBHTCByZXNvdXJjZXMgZm9yIHRoZSByZW5kZXIgdGFyZ2V0XFxuXFx0XFx0ZnVuY3Rpb24gc2V0dXBSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcmVuZGVyVGFyZ2V0UHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQgKTtcXG5cXHRcXHRcXHR2YXIgdGV4dHVyZVByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0LnRleHR1cmUgKTtcXG5cXG5cXHRcXHRcXHRyZW5kZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvblJlbmRlclRhcmdldERpc3Bvc2UgKTtcXG5cXG5cXHRcXHRcXHR0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSA9IF9nbC5jcmVhdGVUZXh0dXJlKCk7XFxuXFxuXFx0XFx0XFx0aW5mb01lbW9yeS50ZXh0dXJlcyArKztcXG5cXG5cXHRcXHRcXHR2YXIgaXNDdWJlID0gKCByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldEN1YmUgPT09IHRydWUgKTtcXG5cXHRcXHRcXHR2YXIgaXNUYXJnZXRQb3dlck9mVHdvID0gaXNQb3dlck9mVHdvKCByZW5kZXJUYXJnZXQgKTtcXG5cXG5cXHRcXHRcXHQvLyBTZXR1cCBmcmFtZWJ1ZmZlclxcblxcblxcdFxcdFxcdGlmICggaXNDdWJlICkge1xcblxcblxcdFxcdFxcdFxcdHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyID0gW107XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlclsgaSBdID0gX2dsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0cmVuZGVyVGFyZ2V0UHJvcGVydGllcy5fX3dlYmdsRnJhbWVidWZmZXIgPSBfZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU2V0dXAgY29sb3IgYnVmZmVyXFxuXFxuXFx0XFx0XFx0aWYgKCBpc0N1YmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFX0NVQkVfTUFQLCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xcblxcdFxcdFxcdFxcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgcmVuZGVyVGFyZ2V0LnRleHR1cmUsIGlzVGFyZ2V0UG93ZXJPZlR3byApO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IDY7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2V0dXBGcmFtZUJ1ZmZlclRleHR1cmUoIHJlbmRlclRhcmdldFByb3BlcnRpZXMuX193ZWJnbEZyYW1lYnVmZmVyWyBpIF0sIHJlbmRlclRhcmdldCwgX2dsLkNPTE9SX0FUVEFDSE1FTlQwLCBfZ2wuVEVYVFVSRV9DVUJFX01BUF9QT1NJVElWRV9YICsgaSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggcmVuZGVyVGFyZ2V0LnRleHR1cmUsIGlzVGFyZ2V0UG93ZXJPZlR3byApICkgX2dsLmdlbmVyYXRlTWlwbWFwKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCApO1xcblxcdFxcdFxcdFxcdHN0YXRlLmJpbmRUZXh0dXJlKCBfZ2wuVEVYVFVSRV9DVUJFX01BUCwgbnVsbCApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0c3RhdGUuYmluZFRleHR1cmUoIF9nbC5URVhUVVJFXzJELCB0ZXh0dXJlUHJvcGVydGllcy5fX3dlYmdsVGV4dHVyZSApO1xcblxcdFxcdFxcdFxcdHNldFRleHR1cmVQYXJhbWV0ZXJzKCBfZ2wuVEVYVFVSRV8yRCwgcmVuZGVyVGFyZ2V0LnRleHR1cmUsIGlzVGFyZ2V0UG93ZXJPZlR3byApO1xcblxcdFxcdFxcdFxcdHNldHVwRnJhbWVCdWZmZXJUZXh0dXJlKCByZW5kZXJUYXJnZXRQcm9wZXJ0aWVzLl9fd2ViZ2xGcmFtZWJ1ZmZlciwgcmVuZGVyVGFyZ2V0LCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5URVhUVVJFXzJEICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlTmVlZHNHZW5lcmF0ZU1pcG1hcHMoIHJlbmRlclRhcmdldC50ZXh0dXJlLCBpc1RhcmdldFBvd2VyT2ZUd28gKSApIF9nbC5nZW5lcmF0ZU1pcG1hcCggX2dsLlRFWFRVUkVfMkQgKTtcXG5cXHRcXHRcXHRcXHRzdGF0ZS5iaW5kVGV4dHVyZSggX2dsLlRFWFRVUkVfMkQsIG51bGwgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gU2V0dXAgZGVwdGggYW5kIHN0ZW5jaWwgYnVmZmVyc1xcblxcblxcdFxcdFxcdGlmICggcmVuZGVyVGFyZ2V0LmRlcHRoQnVmZmVyICkge1xcblxcblxcdFxcdFxcdFxcdHNldHVwRGVwdGhSZW5kZXJidWZmZXIoIHJlbmRlclRhcmdldCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gdXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKCByZW5kZXJUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcXG5cXHRcXHRcXHR2YXIgaXNUYXJnZXRQb3dlck9mVHdvID0gaXNQb3dlck9mVHdvKCByZW5kZXJUYXJnZXQgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRleHR1cmVOZWVkc0dlbmVyYXRlTWlwbWFwcyggdGV4dHVyZSwgaXNUYXJnZXRQb3dlck9mVHdvICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHRhcmdldCA9IHJlbmRlclRhcmdldC5pc1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZSA/IF9nbC5URVhUVVJFX0NVQkVfTUFQIDogX2dsLlRFWFRVUkVfMkQ7XFxuXFx0XFx0XFx0XFx0dmFyIHdlYmdsVGV4dHVyZSA9IHByb3BlcnRpZXMuZ2V0KCB0ZXh0dXJlICkuX193ZWJnbFRleHR1cmU7XFxuXFxuXFx0XFx0XFx0XFx0c3RhdGUuYmluZFRleHR1cmUoIHRhcmdldCwgd2ViZ2xUZXh0dXJlICk7XFxuXFx0XFx0XFx0XFx0X2dsLmdlbmVyYXRlTWlwbWFwKCB0YXJnZXQgKTtcXG5cXHRcXHRcXHRcXHRzdGF0ZS5iaW5kVGV4dHVyZSggdGFyZ2V0LCBudWxsICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiB1cGRhdGVWaWRlb1RleHR1cmVzKCkge1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpZCBpbiBfdmlkZW9UZXh0dXJlcyApIHtcXG5cXG5cXHRcXHRcXHRcXHRfdmlkZW9UZXh0dXJlc1sgaWQgXS51cGRhdGUoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuc2V0VGV4dHVyZTJEID0gc2V0VGV4dHVyZTJEO1xcblxcdFxcdHRoaXMuc2V0VGV4dHVyZUN1YmUgPSBzZXRUZXh0dXJlQ3ViZTtcXG5cXHRcXHR0aGlzLnNldFRleHR1cmVDdWJlRHluYW1pYyA9IHNldFRleHR1cmVDdWJlRHluYW1pYztcXG5cXHRcXHR0aGlzLnNldHVwUmVuZGVyVGFyZ2V0ID0gc2V0dXBSZW5kZXJUYXJnZXQ7XFxuXFx0XFx0dGhpcy51cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXAgPSB1cGRhdGVSZW5kZXJUYXJnZXRNaXBtYXA7XFxuXFx0XFx0dGhpcy51cGRhdGVWaWRlb1RleHR1cmVzID0gdXBkYXRlVmlkZW9UZXh0dXJlcztcXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBmb3JkYWNpb3VzIC8gZm9yZGFjaW91cy5naXRodWIuaW9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBXZWJHTFByb3BlcnRpZXMoKSB7XFxuXFxuXFx0XFx0dmFyIHByb3BlcnRpZXMgPSB7fTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBnZXQoIG9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdXVpZCA9IG9iamVjdC51dWlkO1xcblxcdFxcdFxcdHZhciBtYXAgPSBwcm9wZXJ0aWVzWyB1dWlkIF07XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXAgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRtYXAgPSB7fTtcXG5cXHRcXHRcXHRcXHRwcm9wZXJ0aWVzWyB1dWlkIF0gPSBtYXA7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBtYXA7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHJlbW92ZSggb2JqZWN0ICkge1xcblxcblxcdFxcdFxcdGRlbGV0ZSBwcm9wZXJ0aWVzWyBvYmplY3QudXVpZCBdO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBjbGVhcigpIHtcXG5cXG5cXHRcXHRcXHRwcm9wZXJ0aWVzID0ge307XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0Z2V0OiBnZXQsXFxuXFx0XFx0XFx0cmVtb3ZlOiByZW1vdmUsXFxuXFx0XFx0XFx0Y2xlYXI6IGNsZWFyXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBXZWJHTFN0YXRlKCBnbCwgZXh0ZW5zaW9ucywgdXRpbHMgKSB7XFxuXFxuXFx0XFx0ZnVuY3Rpb24gQ29sb3JCdWZmZXIoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGxvY2tlZCA9IGZhbHNlO1xcblxcblxcdFxcdFxcdHZhciBjb2xvciA9IG5ldyBWZWN0b3I0KCk7XFxuXFx0XFx0XFx0dmFyIGN1cnJlbnRDb2xvck1hc2sgPSBudWxsO1xcblxcdFxcdFxcdHZhciBjdXJyZW50Q29sb3JDbGVhciA9IG5ldyBWZWN0b3I0KCAwLCAwLCAwLCAwICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHtcXG5cXG5cXHRcXHRcXHRcXHRzZXRNYXNrOiBmdW5jdGlvbiAoIGNvbG9yTWFzayApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGN1cnJlbnRDb2xvck1hc2sgIT09IGNvbG9yTWFzayAmJiAhIGxvY2tlZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRnbC5jb2xvck1hc2soIGNvbG9yTWFzaywgY29sb3JNYXNrLCBjb2xvck1hc2ssIGNvbG9yTWFzayApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGN1cnJlbnRDb2xvck1hc2sgPSBjb2xvck1hc2s7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0c2V0TG9ja2VkOiBmdW5jdGlvbiAoIGxvY2sgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bG9ja2VkID0gbG9jaztcXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdHNldENsZWFyOiBmdW5jdGlvbiAoIHIsIGcsIGIsIGEsIHByZW11bHRpcGxpZWRBbHBoYSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHByZW11bHRpcGxpZWRBbHBoYSA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRyICo9IGE7IGcgKj0gYTsgYiAqPSBhO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRjb2xvci5zZXQoIHIsIGcsIGIsIGEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGN1cnJlbnRDb2xvckNsZWFyLmVxdWFscyggY29sb3IgKSA9PT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2wuY2xlYXJDb2xvciggciwgZywgYiwgYSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGN1cnJlbnRDb2xvckNsZWFyLmNvcHkoIGNvbG9yICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0cmVzZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRsb2NrZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50Q29sb3JNYXNrID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50Q29sb3JDbGVhci5zZXQoIC0gMSwgMCwgMCwgMCApOyAvLyBzZXQgdG8gaW52YWxpZCBzdGF0ZVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBEZXB0aEJ1ZmZlcigpIHtcXG5cXG5cXHRcXHRcXHR2YXIgbG9ja2VkID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0dmFyIGN1cnJlbnREZXB0aE1hc2sgPSBudWxsO1xcblxcdFxcdFxcdHZhciBjdXJyZW50RGVwdGhGdW5jID0gbnVsbDtcXG5cXHRcXHRcXHR2YXIgY3VycmVudERlcHRoQ2xlYXIgPSBudWxsO1xcblxcblxcdFxcdFxcdHJldHVybiB7XFxuXFxuXFx0XFx0XFx0XFx0c2V0VGVzdDogZnVuY3Rpb24gKCBkZXB0aFRlc3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkZXB0aFRlc3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZW5hYmxlKCBnbC5ERVBUSF9URVNUICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRkaXNhYmxlKCBnbC5ERVBUSF9URVNUICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0c2V0TWFzazogZnVuY3Rpb24gKCBkZXB0aE1hc2sgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjdXJyZW50RGVwdGhNYXNrICE9PSBkZXB0aE1hc2sgJiYgISBsb2NrZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2wuZGVwdGhNYXNrKCBkZXB0aE1hc2sgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50RGVwdGhNYXNrID0gZGVwdGhNYXNrO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdHNldEZ1bmM6IGZ1bmN0aW9uICggZGVwdGhGdW5jICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggY3VycmVudERlcHRoRnVuYyAhPT0gZGVwdGhGdW5jICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGVwdGhGdW5jICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHN3aXRjaCAoIGRlcHRoRnVuYyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlIE5ldmVyRGVwdGg6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuZGVwdGhGdW5jKCBnbC5ORVZFUiApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgQWx3YXlzRGVwdGg6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuZGVwdGhGdW5jKCBnbC5BTFdBWVMgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlIExlc3NEZXB0aDpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5kZXB0aEZ1bmMoIGdsLkxFU1MgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlIExlc3NFcXVhbERlcHRoOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBFcXVhbERlcHRoOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmRlcHRoRnVuYyggZ2wuRVFVQUwgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlIEdyZWF0ZXJFcXVhbERlcHRoOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmRlcHRoRnVuYyggZ2wuR0VRVUFMICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBHcmVhdGVyRGVwdGg6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuZGVwdGhGdW5jKCBnbC5HUkVBVEVSICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBOb3RFcXVhbERlcHRoOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmRlcHRoRnVuYyggZ2wuTk9URVFVQUwgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkZWZhdWx0OlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmRlcHRoRnVuYyggZ2wuTEVRVUFMICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuZGVwdGhGdW5jKCBnbC5MRVFVQUwgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y3VycmVudERlcHRoRnVuYyA9IGRlcHRoRnVuYztcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHRzZXRMb2NrZWQ6IGZ1bmN0aW9uICggbG9jayApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRsb2NrZWQgPSBsb2NrO1xcblxcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0c2V0Q2xlYXI6IGZ1bmN0aW9uICggZGVwdGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjdXJyZW50RGVwdGhDbGVhciAhPT0gZGVwdGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2wuY2xlYXJEZXB0aCggZGVwdGggKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50RGVwdGhDbGVhciA9IGRlcHRoO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bG9ja2VkID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudERlcHRoTWFzayA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudERlcHRoRnVuYyA9IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudERlcHRoQ2xlYXIgPSBudWxsO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBTdGVuY2lsQnVmZmVyKCkge1xcblxcblxcdFxcdFxcdHZhciBsb2NrZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHR2YXIgY3VycmVudFN0ZW5jaWxNYXNrID0gbnVsbDtcXG5cXHRcXHRcXHR2YXIgY3VycmVudFN0ZW5jaWxGdW5jID0gbnVsbDtcXG5cXHRcXHRcXHR2YXIgY3VycmVudFN0ZW5jaWxSZWYgPSBudWxsO1xcblxcdFxcdFxcdHZhciBjdXJyZW50U3RlbmNpbEZ1bmNNYXNrID0gbnVsbDtcXG5cXHRcXHRcXHR2YXIgY3VycmVudFN0ZW5jaWxGYWlsID0gbnVsbDtcXG5cXHRcXHRcXHR2YXIgY3VycmVudFN0ZW5jaWxaRmFpbCA9IG51bGw7XFxuXFx0XFx0XFx0dmFyIGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBudWxsO1xcblxcdFxcdFxcdHZhciBjdXJyZW50U3RlbmNpbENsZWFyID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4ge1xcblxcblxcdFxcdFxcdFxcdHNldFRlc3Q6IGZ1bmN0aW9uICggc3RlbmNpbFRlc3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBzdGVuY2lsVGVzdCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRlbmFibGUoIGdsLlNURU5DSUxfVEVTVCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGlzYWJsZSggZ2wuU1RFTkNJTF9URVNUICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0c2V0TWFzazogZnVuY3Rpb24gKCBzdGVuY2lsTWFzayApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGN1cnJlbnRTdGVuY2lsTWFzayAhPT0gc3RlbmNpbE1hc2sgJiYgISBsb2NrZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2wuc3RlbmNpbE1hc2soIHN0ZW5jaWxNYXNrICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y3VycmVudFN0ZW5jaWxNYXNrID0gc3RlbmNpbE1hc2s7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0c2V0RnVuYzogZnVuY3Rpb24gKCBzdGVuY2lsRnVuYywgc3RlbmNpbFJlZiwgc3RlbmNpbE1hc2sgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjdXJyZW50U3RlbmNpbEZ1bmMgIT09IHN0ZW5jaWxGdW5jIHx8XFxuXFx0XFx0XFx0XFx0XFx0ICAgICBjdXJyZW50U3RlbmNpbFJlZiBcXHQhPT0gc3RlbmNpbFJlZiBcXHR8fFxcblxcdFxcdFxcdFxcdFxcdCAgICAgY3VycmVudFN0ZW5jaWxGdW5jTWFzayAhPT0gc3RlbmNpbE1hc2sgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2wuc3RlbmNpbEZ1bmMoIHN0ZW5jaWxGdW5jLCBzdGVuY2lsUmVmLCBzdGVuY2lsTWFzayApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGN1cnJlbnRTdGVuY2lsRnVuYyA9IHN0ZW5jaWxGdW5jO1xcblxcdFxcdFxcdFxcdFxcdFxcdGN1cnJlbnRTdGVuY2lsUmVmID0gc3RlbmNpbFJlZjtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50U3RlbmNpbEZ1bmNNYXNrID0gc3RlbmNpbE1hc2s7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0c2V0T3A6IGZ1bmN0aW9uICggc3RlbmNpbEZhaWwsIHN0ZW5jaWxaRmFpbCwgc3RlbmNpbFpQYXNzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggY3VycmVudFN0ZW5jaWxGYWlsXFx0ICE9PSBzdGVuY2lsRmFpbCBcXHR8fFxcblxcdFxcdFxcdFxcdFxcdCAgICAgY3VycmVudFN0ZW5jaWxaRmFpbCAhPT0gc3RlbmNpbFpGYWlsIHx8XFxuXFx0XFx0XFx0XFx0XFx0ICAgICBjdXJyZW50U3RlbmNpbFpQYXNzICE9PSBzdGVuY2lsWlBhc3MgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2wuc3RlbmNpbE9wKCBzdGVuY2lsRmFpbCwgc3RlbmNpbFpGYWlsLCBzdGVuY2lsWlBhc3MgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50U3RlbmNpbEZhaWwgPSBzdGVuY2lsRmFpbDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRjdXJyZW50U3RlbmNpbFpGYWlsID0gc3RlbmNpbFpGYWlsO1xcblxcdFxcdFxcdFxcdFxcdFxcdGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBzdGVuY2lsWlBhc3M7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0c2V0TG9ja2VkOiBmdW5jdGlvbiAoIGxvY2sgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bG9ja2VkID0gbG9jaztcXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdHNldENsZWFyOiBmdW5jdGlvbiAoIHN0ZW5jaWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjdXJyZW50U3RlbmNpbENsZWFyICE9PSBzdGVuY2lsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGdsLmNsZWFyU3RlbmNpbCggc3RlbmNpbCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGN1cnJlbnRTdGVuY2lsQ2xlYXIgPSBzdGVuY2lsO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bG9ja2VkID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudFN0ZW5jaWxNYXNrID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50U3RlbmNpbEZ1bmMgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRTdGVuY2lsUmVmID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50U3RlbmNpbEZ1bmNNYXNrID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50U3RlbmNpbEZhaWwgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRTdGVuY2lsWkZhaWwgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRTdGVuY2lsWlBhc3MgPSBudWxsO1xcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRTdGVuY2lsQ2xlYXIgPSBudWxsO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvL1xcblxcblxcdFxcdHZhciBjb2xvckJ1ZmZlciA9IG5ldyBDb2xvckJ1ZmZlcigpO1xcblxcdFxcdHZhciBkZXB0aEJ1ZmZlciA9IG5ldyBEZXB0aEJ1ZmZlcigpO1xcblxcdFxcdHZhciBzdGVuY2lsQnVmZmVyID0gbmV3IFN0ZW5jaWxCdWZmZXIoKTtcXG5cXG5cXHRcXHR2YXIgbWF4VmVydGV4QXR0cmlidXRlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9BVFRSSUJTICk7XFxuXFx0XFx0dmFyIG5ld0F0dHJpYnV0ZXMgPSBuZXcgVWludDhBcnJheSggbWF4VmVydGV4QXR0cmlidXRlcyApO1xcblxcdFxcdHZhciBlbmFibGVkQXR0cmlidXRlcyA9IG5ldyBVaW50OEFycmF5KCBtYXhWZXJ0ZXhBdHRyaWJ1dGVzICk7XFxuXFx0XFx0dmFyIGF0dHJpYnV0ZURpdmlzb3JzID0gbmV3IFVpbnQ4QXJyYXkoIG1heFZlcnRleEF0dHJpYnV0ZXMgKTtcXG5cXG5cXHRcXHR2YXIgY2FwYWJpbGl0aWVzID0ge307XFxuXFxuXFx0XFx0dmFyIGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IG51bGw7XFxuXFxuXFx0XFx0dmFyIGN1cnJlbnRQcm9ncmFtID0gbnVsbDtcXG5cXG5cXHRcXHR2YXIgY3VycmVudEJsZW5kaW5nID0gbnVsbDtcXG5cXHRcXHR2YXIgY3VycmVudEJsZW5kRXF1YXRpb24gPSBudWxsO1xcblxcdFxcdHZhciBjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xcblxcdFxcdHZhciBjdXJyZW50QmxlbmREc3QgPSBudWxsO1xcblxcdFxcdHZhciBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gbnVsbDtcXG5cXHRcXHR2YXIgY3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xcblxcdFxcdHZhciBjdXJyZW50QmxlbmREc3RBbHBoYSA9IG51bGw7XFxuXFx0XFx0dmFyIGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSA9IGZhbHNlO1xcblxcblxcdFxcdHZhciBjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcXG5cXHRcXHR2YXIgY3VycmVudEN1bGxGYWNlID0gbnVsbDtcXG5cXG5cXHRcXHR2YXIgY3VycmVudExpbmVXaWR0aCA9IG51bGw7XFxuXFxuXFx0XFx0dmFyIGN1cnJlbnRQb2x5Z29uT2Zmc2V0RmFjdG9yID0gbnVsbDtcXG5cXHRcXHR2YXIgY3VycmVudFBvbHlnb25PZmZzZXRVbml0cyA9IG51bGw7XFxuXFxuXFx0XFx0dmFyIG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xcblxcblxcdFxcdHZhciB2ZXJzaW9uID0gcGFyc2VGbG9hdCggL15XZWJHTFxcXFwgKFswLTldKS8uZXhlYyggZ2wuZ2V0UGFyYW1ldGVyKCBnbC5WRVJTSU9OICkgKVsgMSBdICk7XFxuXFx0XFx0dmFyIGxpbmVXaWR0aEF2YWlsYWJsZSA9IHBhcnNlRmxvYXQoIHZlcnNpb24gKSA+PSAxLjA7XFxuXFxuXFx0XFx0dmFyIGN1cnJlbnRUZXh0dXJlU2xvdCA9IG51bGw7XFxuXFx0XFx0dmFyIGN1cnJlbnRCb3VuZFRleHR1cmVzID0ge307XFxuXFxuXFx0XFx0dmFyIGN1cnJlbnRTY2lzc29yID0gbmV3IFZlY3RvcjQoKTtcXG5cXHRcXHR2YXIgY3VycmVudFZpZXdwb3J0ID0gbmV3IFZlY3RvcjQoKTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBjcmVhdGVUZXh0dXJlKCB0eXBlLCB0YXJnZXQsIGNvdW50ICkge1xcblxcblxcdFxcdFxcdHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoIDQgKTsgLy8gNCBpcyByZXF1aXJlZCB0byBtYXRjaCBkZWZhdWx0IHVucGFjayBhbGlnbm1lbnQgb2YgNC5cXG5cXHRcXHRcXHR2YXIgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcXG5cXG5cXHRcXHRcXHRnbC5iaW5kVGV4dHVyZSggdHlwZSwgdGV4dHVyZSApO1xcblxcdFxcdFxcdGdsLnRleFBhcmFtZXRlcmkoIHR5cGUsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xcblxcdFxcdFxcdGdsLnRleFBhcmFtZXRlcmkoIHR5cGUsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCApO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGNvdW50OyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGdsLnRleEltYWdlMkQoIHRhcmdldCArIGksIDAsIGdsLlJHQkEsIDEsIDEsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGRhdGEgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmU7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHZhciBlbXB0eVRleHR1cmVzID0ge307XFxuXFx0XFx0ZW1wdHlUZXh0dXJlc1sgZ2wuVEVYVFVSRV8yRCBdID0gY3JlYXRlVGV4dHVyZSggZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV8yRCwgMSApO1xcblxcdFxcdGVtcHR5VGV4dHVyZXNbIGdsLlRFWFRVUkVfQ1VCRV9NQVAgXSA9IGNyZWF0ZVRleHR1cmUoIGdsLlRFWFRVUkVfQ1VCRV9NQVAsIGdsLlRFWFRVUkVfQ1VCRV9NQVBfUE9TSVRJVkVfWCwgNiApO1xcblxcblxcdFxcdC8vIGluaXRcXG5cXG5cXHRcXHRjb2xvckJ1ZmZlci5zZXRDbGVhciggMCwgMCwgMCwgMSApO1xcblxcdFxcdGRlcHRoQnVmZmVyLnNldENsZWFyKCAxICk7XFxuXFx0XFx0c3RlbmNpbEJ1ZmZlci5zZXRDbGVhciggMCApO1xcblxcblxcdFxcdGVuYWJsZSggZ2wuREVQVEhfVEVTVCApO1xcblxcdFxcdGRlcHRoQnVmZmVyLnNldEZ1bmMoIExlc3NFcXVhbERlcHRoICk7XFxuXFxuXFx0XFx0c2V0RmxpcFNpZGVkKCBmYWxzZSApO1xcblxcdFxcdHNldEN1bGxGYWNlKCBDdWxsRmFjZUJhY2sgKTtcXG5cXHRcXHRlbmFibGUoIGdsLkNVTExfRkFDRSApO1xcblxcblxcdFxcdGVuYWJsZSggZ2wuQkxFTkQgKTtcXG5cXHRcXHRzZXRCbGVuZGluZyggTm9ybWFsQmxlbmRpbmcgKTtcXG5cXG5cXHRcXHQvL1xcblxcblxcdFxcdGZ1bmN0aW9uIGluaXRBdHRyaWJ1dGVzKCkge1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IG5ld0F0dHJpYnV0ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRuZXdBdHRyaWJ1dGVzWyBpIF0gPSAwO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZW5hYmxlQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XFxuXFxuXFx0XFx0XFx0bmV3QXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xcblxcblxcdFxcdFxcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGUgKTtcXG5cXHRcXHRcXHRcXHRlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSAhPT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xcblxcblxcdFxcdFxcdFxcdGV4dGVuc2lvbi52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoIGF0dHJpYnV0ZSwgMCApO1xcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSA9IDA7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBlbmFibGVBdHRyaWJ1dGVBbmREaXZpc29yKCBhdHRyaWJ1dGUsIG1lc2hQZXJBdHRyaWJ1dGUgKSB7XFxuXFxuXFx0XFx0XFx0bmV3QXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xcblxcblxcdFxcdFxcdGlmICggZW5hYmxlZEF0dHJpYnV0ZXNbIGF0dHJpYnV0ZSBdID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KCBhdHRyaWJ1dGUgKTtcXG5cXHRcXHRcXHRcXHRlbmFibGVkQXR0cmlidXRlc1sgYXR0cmlidXRlIF0gPSAxO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSAhPT0gbWVzaFBlckF0dHJpYnV0ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApO1xcblxcblxcdFxcdFxcdFxcdGV4dGVuc2lvbi52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoIGF0dHJpYnV0ZSwgbWVzaFBlckF0dHJpYnV0ZSApO1xcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZURpdmlzb3JzWyBhdHRyaWJ1dGUgXSA9IG1lc2hQZXJBdHRyaWJ1dGU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBkaXNhYmxlVW51c2VkQXR0cmlidXRlcygpIHtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBlbmFibGVkQXR0cmlidXRlcy5sZW5ndGg7IGkgIT09IGw7ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBlbmFibGVkQXR0cmlidXRlc1sgaSBdICE9PSBuZXdBdHRyaWJ1dGVzWyBpIF0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCBpICk7XFxuXFx0XFx0XFx0XFx0XFx0ZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZW5hYmxlKCBpZCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGNhcGFiaWxpdGllc1sgaWQgXSAhPT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRnbC5lbmFibGUoIGlkICk7XFxuXFx0XFx0XFx0XFx0Y2FwYWJpbGl0aWVzWyBpZCBdID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGRpc2FibGUoIGlkICkge1xcblxcblxcdFxcdFxcdGlmICggY2FwYWJpbGl0aWVzWyBpZCBdICE9PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRnbC5kaXNhYmxlKCBpZCApO1xcblxcdFxcdFxcdFxcdGNhcGFiaWxpdGllc1sgaWQgXSA9IGZhbHNlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZ2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzKCkge1xcblxcblxcdFxcdFxcdGlmICggY29tcHJlc3NlZFRleHR1cmVGb3JtYXRzID09PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdGNvbXByZXNzZWRUZXh0dXJlRm9ybWF0cyA9IFtdO1xcblxcblxcdFxcdFxcdFxcdGlmICggZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICkgfHxcXG5cXHRcXHRcXHRcXHQgICAgIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHxcXG5cXHRcXHRcXHRcXHQgICAgIGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX2V0YzEnICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGZvcm1hdHMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLkNPTVBSRVNTRURfVEVYVFVSRV9GT1JNQVRTICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZm9ybWF0cy5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29tcHJlc3NlZFRleHR1cmVGb3JtYXRzLnB1c2goIGZvcm1hdHNbIGkgXSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHM7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHVzZVByb2dyYW0oIHByb2dyYW0gKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBjdXJyZW50UHJvZ3JhbSAhPT0gcHJvZ3JhbSApIHtcXG5cXG5cXHRcXHRcXHRcXHRnbC51c2VQcm9ncmFtKCBwcm9ncmFtICk7XFxuXFxuXFx0XFx0XFx0XFx0Y3VycmVudFByb2dyYW0gPSBwcm9ncmFtO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHNldEJsZW5kaW5nKCBibGVuZGluZywgYmxlbmRFcXVhdGlvbiwgYmxlbmRTcmMsIGJsZW5kRHN0LCBibGVuZEVxdWF0aW9uQWxwaGEsIGJsZW5kU3JjQWxwaGEsIGJsZW5kRHN0QWxwaGEsIHByZW11bHRpcGxpZWRBbHBoYSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGJsZW5kaW5nICE9PSBOb0JsZW5kaW5nICkge1xcblxcblxcdFxcdFxcdFxcdGVuYWJsZSggZ2wuQkxFTkQgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdGRpc2FibGUoIGdsLkJMRU5EICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggYmxlbmRpbmcgIT09IEN1c3RvbUJsZW5kaW5nICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggYmxlbmRpbmcgIT09IGN1cnJlbnRCbGVuZGluZyB8fCBwcmVtdWx0aXBsaWVkQWxwaGEgIT09IGN1cnJlbnRQcmVtdWx0aXBsZWRBbHBoYSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzd2l0Y2ggKCBibGVuZGluZyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlIEFkZGl0aXZlQmxlbmRpbmc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBwcmVtdWx0aXBsaWVkQWxwaGEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuYmxlbmRFcXVhdGlvblNlcGFyYXRlKCBnbC5GVU5DX0FERCwgZ2wuRlVOQ19BREQgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggZ2wuT05FLCBnbC5PTkUsIGdsLk9ORSwgZ2wuT05FICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5ibGVuZEVxdWF0aW9uKCBnbC5GVU5DX0FERCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmJsZW5kRnVuYyggZ2wuU1JDX0FMUEhBLCBnbC5PTkUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSBTdWJ0cmFjdGl2ZUJsZW5kaW5nOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggcHJlbXVsdGlwbGllZEFscGhhICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLlpFUk8sIGdsLlpFUk8sIGdsLk9ORV9NSU5VU19TUkNfQ09MT1IsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmJsZW5kRXF1YXRpb24oIGdsLkZVTkNfQUREICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuYmxlbmRGdW5jKCBnbC5aRVJPLCBnbC5PTkVfTUlOVVNfU1JDX0NPTE9SICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgTXVsdGlwbHlCbGVuZGluZzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHByZW11bHRpcGxpZWRBbHBoYSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5aRVJPLCBnbC5TUkNfQ09MT1IsIGdsLlpFUk8sIGdsLlNSQ19BTFBIQSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuYmxlbmRFcXVhdGlvbiggZ2wuRlVOQ19BREQgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5ibGVuZEZ1bmMoIGdsLlpFUk8sIGdsLlNSQ19DT0xPUiApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRkZWZhdWx0OlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggcHJlbXVsdGlwbGllZEFscGhhICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggZ2wuRlVOQ19BREQsIGdsLkZVTkNfQUREICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2wuYmxlbmRGdW5jU2VwYXJhdGUoIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSwgZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnbC5ibGVuZEVxdWF0aW9uU2VwYXJhdGUoIGdsLkZVTkNfQURELCBnbC5GVU5DX0FERCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdsLmJsZW5kRnVuY1NlcGFyYXRlKCBnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEsIGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRjdXJyZW50QmxlbmRTcmMgPSBudWxsO1xcblxcdFxcdFxcdFxcdGN1cnJlbnRCbGVuZERzdCA9IG51bGw7XFxuXFx0XFx0XFx0XFx0Y3VycmVudEJsZW5kRXF1YXRpb25BbHBoYSA9IG51bGw7XFxuXFx0XFx0XFx0XFx0Y3VycmVudEJsZW5kU3JjQWxwaGEgPSBudWxsO1xcblxcdFxcdFxcdFxcdGN1cnJlbnRCbGVuZERzdEFscGhhID0gbnVsbDtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdGJsZW5kRXF1YXRpb25BbHBoYSA9IGJsZW5kRXF1YXRpb25BbHBoYSB8fCBibGVuZEVxdWF0aW9uO1xcblxcdFxcdFxcdFxcdGJsZW5kU3JjQWxwaGEgPSBibGVuZFNyY0FscGhhIHx8IGJsZW5kU3JjO1xcblxcdFxcdFxcdFxcdGJsZW5kRHN0QWxwaGEgPSBibGVuZERzdEFscGhhIHx8IGJsZW5kRHN0O1xcblxcblxcdFxcdFxcdFxcdGlmICggYmxlbmRFcXVhdGlvbiAhPT0gY3VycmVudEJsZW5kRXF1YXRpb24gfHwgYmxlbmRFcXVhdGlvbkFscGhhICE9PSBjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGdsLmJsZW5kRXF1YXRpb25TZXBhcmF0ZSggdXRpbHMuY29udmVydCggYmxlbmRFcXVhdGlvbiApLCB1dGlscy5jb252ZXJ0KCBibGVuZEVxdWF0aW9uQWxwaGEgKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRCbGVuZEVxdWF0aW9uID0gYmxlbmRFcXVhdGlvbjtcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50QmxlbmRFcXVhdGlvbkFscGhhID0gYmxlbmRFcXVhdGlvbkFscGhhO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGJsZW5kU3JjICE9PSBjdXJyZW50QmxlbmRTcmMgfHwgYmxlbmREc3QgIT09IGN1cnJlbnRCbGVuZERzdCB8fCBibGVuZFNyY0FscGhhICE9PSBjdXJyZW50QmxlbmRTcmNBbHBoYSB8fCBibGVuZERzdEFscGhhICE9PSBjdXJyZW50QmxlbmREc3RBbHBoYSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRnbC5ibGVuZEZ1bmNTZXBhcmF0ZSggdXRpbHMuY29udmVydCggYmxlbmRTcmMgKSwgdXRpbHMuY29udmVydCggYmxlbmREc3QgKSwgdXRpbHMuY29udmVydCggYmxlbmRTcmNBbHBoYSApLCB1dGlscy5jb252ZXJ0KCBibGVuZERzdEFscGhhICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50QmxlbmRTcmMgPSBibGVuZFNyYztcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50QmxlbmREc3QgPSBibGVuZERzdDtcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50QmxlbmRTcmNBbHBoYSA9IGJsZW5kU3JjQWxwaGE7XFxuXFx0XFx0XFx0XFx0XFx0Y3VycmVudEJsZW5kRHN0QWxwaGEgPSBibGVuZERzdEFscGhhO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Y3VycmVudEJsZW5kaW5nID0gYmxlbmRpbmc7XFxuXFx0XFx0XFx0Y3VycmVudFByZW11bHRpcGxlZEFscGhhID0gcHJlbXVsdGlwbGllZEFscGhhO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBzZXRNYXRlcmlhbCggbWF0ZXJpYWwsIGZyb250RmFjZUNXICkge1xcblxcblxcdFxcdFxcdG1hdGVyaWFsLnNpZGUgPT09IERvdWJsZVNpZGVcXG5cXHRcXHRcXHRcXHQ/IGRpc2FibGUoIGdsLkNVTExfRkFDRSApXFxuXFx0XFx0XFx0XFx0OiBlbmFibGUoIGdsLkNVTExfRkFDRSApO1xcblxcblxcdFxcdFxcdHZhciBmbGlwU2lkZWQgPSAoIG1hdGVyaWFsLnNpZGUgPT09IEJhY2tTaWRlICk7XFxuXFx0XFx0XFx0aWYgKCBmcm9udEZhY2VDVyApIGZsaXBTaWRlZCA9ICEgZmxpcFNpZGVkO1xcblxcblxcdFxcdFxcdHNldEZsaXBTaWRlZCggZmxpcFNpZGVkICk7XFxuXFxuXFx0XFx0XFx0bWF0ZXJpYWwudHJhbnNwYXJlbnQgPT09IHRydWVcXG5cXHRcXHRcXHRcXHQ/IHNldEJsZW5kaW5nKCBtYXRlcmlhbC5ibGVuZGluZywgbWF0ZXJpYWwuYmxlbmRFcXVhdGlvbiwgbWF0ZXJpYWwuYmxlbmRTcmMsIG1hdGVyaWFsLmJsZW5kRHN0LCBtYXRlcmlhbC5ibGVuZEVxdWF0aW9uQWxwaGEsIG1hdGVyaWFsLmJsZW5kU3JjQWxwaGEsIG1hdGVyaWFsLmJsZW5kRHN0QWxwaGEsIG1hdGVyaWFsLnByZW11bHRpcGxpZWRBbHBoYSApXFxuXFx0XFx0XFx0XFx0OiBzZXRCbGVuZGluZyggTm9CbGVuZGluZyApO1xcblxcblxcdFxcdFxcdGRlcHRoQnVmZmVyLnNldEZ1bmMoIG1hdGVyaWFsLmRlcHRoRnVuYyApO1xcblxcdFxcdFxcdGRlcHRoQnVmZmVyLnNldFRlc3QoIG1hdGVyaWFsLmRlcHRoVGVzdCApO1xcblxcdFxcdFxcdGRlcHRoQnVmZmVyLnNldE1hc2soIG1hdGVyaWFsLmRlcHRoV3JpdGUgKTtcXG5cXHRcXHRcXHRjb2xvckJ1ZmZlci5zZXRNYXNrKCBtYXRlcmlhbC5jb2xvcldyaXRlICk7XFxuXFxuXFx0XFx0XFx0c2V0UG9seWdvbk9mZnNldCggbWF0ZXJpYWwucG9seWdvbk9mZnNldCwgbWF0ZXJpYWwucG9seWdvbk9mZnNldEZhY3RvciwgbWF0ZXJpYWwucG9seWdvbk9mZnNldFVuaXRzICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vXFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2V0RmxpcFNpZGVkKCBmbGlwU2lkZWQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBjdXJyZW50RmxpcFNpZGVkICE9PSBmbGlwU2lkZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBmbGlwU2lkZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2wuZnJvbnRGYWNlKCBnbC5DVyApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2wuZnJvbnRGYWNlKCBnbC5DQ1cgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Y3VycmVudEZsaXBTaWRlZCA9IGZsaXBTaWRlZDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHNldEN1bGxGYWNlKCBjdWxsRmFjZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGN1bGxGYWNlICE9PSBDdWxsRmFjZU5vbmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZW5hYmxlKCBnbC5DVUxMX0ZBQ0UgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGN1bGxGYWNlICE9PSBjdXJyZW50Q3VsbEZhY2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjdWxsRmFjZSA9PT0gQ3VsbEZhY2VCYWNrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGdsLmN1bGxGYWNlKCBnbC5CQUNLICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggY3VsbEZhY2UgPT09IEN1bGxGYWNlRnJvbnQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2wuY3VsbEZhY2UoIGdsLkZST05UICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRnbC5jdWxsRmFjZSggZ2wuRlJPTlRfQU5EX0JBQ0sgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0ZGlzYWJsZSggZ2wuQ1VMTF9GQUNFICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGN1cnJlbnRDdWxsRmFjZSA9IGN1bGxGYWNlO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBzZXRMaW5lV2lkdGgoIHdpZHRoICkge1xcblxcblxcdFxcdFxcdGlmICggd2lkdGggIT09IGN1cnJlbnRMaW5lV2lkdGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBsaW5lV2lkdGhBdmFpbGFibGUgKSBnbC5saW5lV2lkdGgoIHdpZHRoICk7XFxuXFxuXFx0XFx0XFx0XFx0Y3VycmVudExpbmVXaWR0aCA9IHdpZHRoO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2V0UG9seWdvbk9mZnNldCggcG9seWdvbk9mZnNldCwgZmFjdG9yLCB1bml0cyApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHBvbHlnb25PZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZW5hYmxlKCBnbC5QT0xZR09OX09GRlNFVF9GSUxMICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciAhPT0gZmFjdG9yIHx8IGN1cnJlbnRQb2x5Z29uT2Zmc2V0VW5pdHMgIT09IHVuaXRzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGdsLnBvbHlnb25PZmZzZXQoIGZhY3RvciwgdW5pdHMgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50UG9seWdvbk9mZnNldEZhY3RvciA9IGZhY3RvcjtcXG5cXHRcXHRcXHRcXHRcXHRjdXJyZW50UG9seWdvbk9mZnNldFVuaXRzID0gdW5pdHM7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0ZGlzYWJsZSggZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2V0U2Npc3NvclRlc3QoIHNjaXNzb3JUZXN0ICkge1xcblxcblxcdFxcdFxcdGlmICggc2Npc3NvclRlc3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZW5hYmxlKCBnbC5TQ0lTU09SX1RFU1QgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdGRpc2FibGUoIGdsLlNDSVNTT1JfVEVTVCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gdGV4dHVyZVxcblxcblxcdFxcdGZ1bmN0aW9uIGFjdGl2ZVRleHR1cmUoIHdlYmdsU2xvdCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHdlYmdsU2xvdCA9PT0gdW5kZWZpbmVkICkgd2ViZ2xTbG90ID0gZ2wuVEVYVFVSRTAgKyBtYXhUZXh0dXJlcyAtIDE7XFxuXFxuXFx0XFx0XFx0aWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgIT09IHdlYmdsU2xvdCApIHtcXG5cXG5cXHRcXHRcXHRcXHRnbC5hY3RpdmVUZXh0dXJlKCB3ZWJnbFNsb3QgKTtcXG5cXHRcXHRcXHRcXHRjdXJyZW50VGV4dHVyZVNsb3QgPSB3ZWJnbFNsb3Q7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBiaW5kVGV4dHVyZSggd2ViZ2xUeXBlLCB3ZWJnbFRleHR1cmUgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBjdXJyZW50VGV4dHVyZVNsb3QgPT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YWN0aXZlVGV4dHVyZSgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgYm91bmRUZXh0dXJlID0gY3VycmVudEJvdW5kVGV4dHVyZXNbIGN1cnJlbnRUZXh0dXJlU2xvdCBdO1xcblxcblxcdFxcdFxcdGlmICggYm91bmRUZXh0dXJlID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ym91bmRUZXh0dXJlID0geyB0eXBlOiB1bmRlZmluZWQsIHRleHR1cmU6IHVuZGVmaW5lZCB9O1xcblxcdFxcdFxcdFxcdGN1cnJlbnRCb3VuZFRleHR1cmVzWyBjdXJyZW50VGV4dHVyZVNsb3QgXSA9IGJvdW5kVGV4dHVyZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBib3VuZFRleHR1cmUudHlwZSAhPT0gd2ViZ2xUeXBlIHx8IGJvdW5kVGV4dHVyZS50ZXh0dXJlICE9PSB3ZWJnbFRleHR1cmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Z2wuYmluZFRleHR1cmUoIHdlYmdsVHlwZSwgd2ViZ2xUZXh0dXJlIHx8IGVtcHR5VGV4dHVyZXNbIHdlYmdsVHlwZSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0Ym91bmRUZXh0dXJlLnR5cGUgPSB3ZWJnbFR5cGU7XFxuXFx0XFx0XFx0XFx0Ym91bmRUZXh0dXJlLnRleHR1cmUgPSB3ZWJnbFRleHR1cmU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBjb21wcmVzc2VkVGV4SW1hZ2UyRCgpIHtcXG5cXG5cXHRcXHRcXHR0cnkge1xcblxcblxcdFxcdFxcdFxcdGdsLmNvbXByZXNzZWRUZXhJbWFnZTJELmFwcGx5KCBnbCwgYXJndW1lbnRzICk7XFxuXFxuXFx0XFx0XFx0fSBjYXRjaCAoIGVycm9yICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFN0YXRlOicsIGVycm9yICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiB0ZXhJbWFnZTJEKCkge1xcblxcblxcdFxcdFxcdHRyeSB7XFxuXFxuXFx0XFx0XFx0XFx0Z2wudGV4SW1hZ2UyRC5hcHBseSggZ2wsIGFyZ3VtZW50cyApO1xcblxcblxcdFxcdFxcdH0gY2F0Y2ggKCBlcnJvciApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xTdGF0ZTonLCBlcnJvciApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly9cXG5cXG5cXHRcXHRmdW5jdGlvbiBzY2lzc29yKCBzY2lzc29yICkge1xcblxcblxcdFxcdFxcdGlmICggY3VycmVudFNjaXNzb3IuZXF1YWxzKCBzY2lzc29yICkgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdGdsLnNjaXNzb3IoIHNjaXNzb3IueCwgc2Npc3Nvci55LCBzY2lzc29yLnosIHNjaXNzb3IudyApO1xcblxcdFxcdFxcdFxcdGN1cnJlbnRTY2lzc29yLmNvcHkoIHNjaXNzb3IgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHZpZXdwb3J0KCB2aWV3cG9ydCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGN1cnJlbnRWaWV3cG9ydC5lcXVhbHMoIHZpZXdwb3J0ICkgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdGdsLnZpZXdwb3J0KCB2aWV3cG9ydC54LCB2aWV3cG9ydC55LCB2aWV3cG9ydC56LCB2aWV3cG9ydC53ICk7XFxuXFx0XFx0XFx0XFx0Y3VycmVudFZpZXdwb3J0LmNvcHkoIHZpZXdwb3J0ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvL1xcblxcblxcdFxcdGZ1bmN0aW9uIHJlc2V0KCkge1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGVuYWJsZWRBdHRyaWJ1dGVzLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGVuYWJsZWRBdHRyaWJ1dGVzWyBpIF0gPT09IDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KCBpICk7XFxuXFx0XFx0XFx0XFx0XFx0ZW5hYmxlZEF0dHJpYnV0ZXNbIGkgXSA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRjYXBhYmlsaXRpZXMgPSB7fTtcXG5cXG5cXHRcXHRcXHRjb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMgPSBudWxsO1xcblxcblxcdFxcdFxcdGN1cnJlbnRUZXh0dXJlU2xvdCA9IG51bGw7XFxuXFx0XFx0XFx0Y3VycmVudEJvdW5kVGV4dHVyZXMgPSB7fTtcXG5cXG5cXHRcXHRcXHRjdXJyZW50UHJvZ3JhbSA9IG51bGw7XFxuXFxuXFx0XFx0XFx0Y3VycmVudEJsZW5kaW5nID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRjdXJyZW50RmxpcFNpZGVkID0gbnVsbDtcXG5cXHRcXHRcXHRjdXJyZW50Q3VsbEZhY2UgPSBudWxsO1xcblxcblxcdFxcdFxcdGNvbG9yQnVmZmVyLnJlc2V0KCk7XFxuXFx0XFx0XFx0ZGVwdGhCdWZmZXIucmVzZXQoKTtcXG5cXHRcXHRcXHRzdGVuY2lsQnVmZmVyLnJlc2V0KCk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB7XFxuXFxuXFx0XFx0XFx0YnVmZmVyczoge1xcblxcdFxcdFxcdFxcdGNvbG9yOiBjb2xvckJ1ZmZlcixcXG5cXHRcXHRcXHRcXHRkZXB0aDogZGVwdGhCdWZmZXIsXFxuXFx0XFx0XFx0XFx0c3RlbmNpbDogc3RlbmNpbEJ1ZmZlclxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0aW5pdEF0dHJpYnV0ZXM6IGluaXRBdHRyaWJ1dGVzLFxcblxcdFxcdFxcdGVuYWJsZUF0dHJpYnV0ZTogZW5hYmxlQXR0cmlidXRlLFxcblxcdFxcdFxcdGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3I6IGVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IsXFxuXFx0XFx0XFx0ZGlzYWJsZVVudXNlZEF0dHJpYnV0ZXM6IGRpc2FibGVVbnVzZWRBdHRyaWJ1dGVzLFxcblxcdFxcdFxcdGVuYWJsZTogZW5hYmxlLFxcblxcdFxcdFxcdGRpc2FibGU6IGRpc2FibGUsXFxuXFx0XFx0XFx0Z2V0Q29tcHJlc3NlZFRleHR1cmVGb3JtYXRzOiBnZXRDb21wcmVzc2VkVGV4dHVyZUZvcm1hdHMsXFxuXFxuXFx0XFx0XFx0dXNlUHJvZ3JhbTogdXNlUHJvZ3JhbSxcXG5cXG5cXHRcXHRcXHRzZXRCbGVuZGluZzogc2V0QmxlbmRpbmcsXFxuXFx0XFx0XFx0c2V0TWF0ZXJpYWw6IHNldE1hdGVyaWFsLFxcblxcblxcdFxcdFxcdHNldEZsaXBTaWRlZDogc2V0RmxpcFNpZGVkLFxcblxcdFxcdFxcdHNldEN1bGxGYWNlOiBzZXRDdWxsRmFjZSxcXG5cXG5cXHRcXHRcXHRzZXRMaW5lV2lkdGg6IHNldExpbmVXaWR0aCxcXG5cXHRcXHRcXHRzZXRQb2x5Z29uT2Zmc2V0OiBzZXRQb2x5Z29uT2Zmc2V0LFxcblxcblxcdFxcdFxcdHNldFNjaXNzb3JUZXN0OiBzZXRTY2lzc29yVGVzdCxcXG5cXG5cXHRcXHRcXHRhY3RpdmVUZXh0dXJlOiBhY3RpdmVUZXh0dXJlLFxcblxcdFxcdFxcdGJpbmRUZXh0dXJlOiBiaW5kVGV4dHVyZSxcXG5cXHRcXHRcXHRjb21wcmVzc2VkVGV4SW1hZ2UyRDogY29tcHJlc3NlZFRleEltYWdlMkQsXFxuXFx0XFx0XFx0dGV4SW1hZ2UyRDogdGV4SW1hZ2UyRCxcXG5cXG5cXHRcXHRcXHRzY2lzc29yOiBzY2lzc29yLFxcblxcdFxcdFxcdHZpZXdwb3J0OiB2aWV3cG9ydCxcXG5cXG5cXHRcXHRcXHRyZXNldDogcmVzZXRcXG5cXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFdlYkdMQ2FwYWJpbGl0aWVzKCBnbCwgZXh0ZW5zaW9ucywgcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHR2YXIgbWF4QW5pc290cm9weTtcXG5cXG5cXHRcXHRmdW5jdGlvbiBnZXRNYXhBbmlzb3Ryb3B5KCkge1xcblxcblxcdFxcdFxcdGlmICggbWF4QW5pc290cm9weSAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIG1heEFuaXNvdHJvcHk7XFxuXFxuXFx0XFx0XFx0dmFyIGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApO1xcblxcblxcdFxcdFxcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdG1heEFuaXNvdHJvcHkgPSBnbC5nZXRQYXJhbWV0ZXIoIGV4dGVuc2lvbi5NQVhfVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdG1heEFuaXNvdHJvcHkgPSAwO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gbWF4QW5pc290cm9weTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZ2V0TWF4UHJlY2lzaW9uKCBwcmVjaXNpb24gKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBwcmVjaXNpb24gPT09ICdoaWdocCcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLlZFUlRFWF9TSEFERVIsIGdsLkhJR0hfRkxPQVQgKS5wcmVjaXNpb24gPiAwICYmXFxuXFx0XFx0XFx0XFx0ICAgICBnbC5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoIGdsLkZSQUdNRU5UX1NIQURFUiwgZ2wuSElHSF9GTE9BVCApLnByZWNpc2lvbiA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICdoaWdocCc7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHByZWNpc2lvbiA9ICdtZWRpdW1wJztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBwcmVjaXNpb24gPT09ICdtZWRpdW1wJyApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGdsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCggZ2wuVkVSVEVYX1NIQURFUiwgZ2wuTUVESVVNX0ZMT0FUICkucHJlY2lzaW9uID4gMCAmJlxcblxcdFxcdFxcdFxcdCAgICAgZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0KCBnbC5GUkFHTUVOVF9TSEFERVIsIGdsLk1FRElVTV9GTE9BVCApLnByZWNpc2lvbiA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICdtZWRpdW1wJztcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiAnbG93cCc7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHZhciBwcmVjaXNpb24gPSBwYXJhbWV0ZXJzLnByZWNpc2lvbiAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wcmVjaXNpb24gOiAnaGlnaHAnO1xcblxcdFxcdHZhciBtYXhQcmVjaXNpb24gPSBnZXRNYXhQcmVjaXNpb24oIHByZWNpc2lvbiApO1xcblxcblxcdFxcdGlmICggbWF4UHJlY2lzaW9uICE9PSBwcmVjaXNpb24gKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjonLCBwcmVjaXNpb24sICdub3Qgc3VwcG9ydGVkLCB1c2luZycsIG1heFByZWNpc2lvbiwgJ2luc3RlYWQuJyApO1xcblxcdFxcdFxcdHByZWNpc2lvbiA9IG1heFByZWNpc2lvbjtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIGxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPSBwYXJhbWV0ZXJzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgPT09IHRydWU7XFxuXFxuXFx0XFx0dmFyIG1heFRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyApO1xcblxcdFxcdHZhciBtYXhWZXJ0ZXhUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9URVhUVVJFX0lNQUdFX1VOSVRTICk7XFxuXFx0XFx0dmFyIG1heFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfVEVYVFVSRV9TSVpFICk7XFxuXFx0XFx0dmFyIG1heEN1YmVtYXBTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKCBnbC5NQVhfQ1VCRV9NQVBfVEVYVFVSRV9TSVpFICk7XFxuXFxuXFx0XFx0dmFyIG1heEF0dHJpYnV0ZXMgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WRVJURVhfQVRUUklCUyApO1xcblxcdFxcdHZhciBtYXhWZXJ0ZXhVbmlmb3JtcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX1ZFUlRFWF9VTklGT1JNX1ZFQ1RPUlMgKTtcXG5cXHRcXHR2YXIgbWF4VmFyeWluZ3MgPSBnbC5nZXRQYXJhbWV0ZXIoIGdsLk1BWF9WQVJZSU5HX1ZFQ1RPUlMgKTtcXG5cXHRcXHR2YXIgbWF4RnJhZ21lbnRVbmlmb3JtcyA9IGdsLmdldFBhcmFtZXRlciggZ2wuTUFYX0ZSQUdNRU5UX1VOSUZPUk1fVkVDVE9SUyApO1xcblxcblxcdFxcdHZhciB2ZXJ0ZXhUZXh0dXJlcyA9IG1heFZlcnRleFRleHR1cmVzID4gMDtcXG5cXHRcXHR2YXIgZmxvYXRGcmFnbWVudFRleHR1cmVzID0gISEgZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9mbG9hdCcgKTtcXG5cXHRcXHR2YXIgZmxvYXRWZXJ0ZXhUZXh0dXJlcyA9IHZlcnRleFRleHR1cmVzICYmIGZsb2F0RnJhZ21lbnRUZXh0dXJlcztcXG5cXG5cXHRcXHRyZXR1cm4ge1xcblxcblxcdFxcdFxcdGdldE1heEFuaXNvdHJvcHk6IGdldE1heEFuaXNvdHJvcHksXFxuXFx0XFx0XFx0Z2V0TWF4UHJlY2lzaW9uOiBnZXRNYXhQcmVjaXNpb24sXFxuXFxuXFx0XFx0XFx0cHJlY2lzaW9uOiBwcmVjaXNpb24sXFxuXFx0XFx0XFx0bG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcjogbG9nYXJpdGhtaWNEZXB0aEJ1ZmZlcixcXG5cXG5cXHRcXHRcXHRtYXhUZXh0dXJlczogbWF4VGV4dHVyZXMsXFxuXFx0XFx0XFx0bWF4VmVydGV4VGV4dHVyZXM6IG1heFZlcnRleFRleHR1cmVzLFxcblxcdFxcdFxcdG1heFRleHR1cmVTaXplOiBtYXhUZXh0dXJlU2l6ZSxcXG5cXHRcXHRcXHRtYXhDdWJlbWFwU2l6ZTogbWF4Q3ViZW1hcFNpemUsXFxuXFxuXFx0XFx0XFx0bWF4QXR0cmlidXRlczogbWF4QXR0cmlidXRlcyxcXG5cXHRcXHRcXHRtYXhWZXJ0ZXhVbmlmb3JtczogbWF4VmVydGV4VW5pZm9ybXMsXFxuXFx0XFx0XFx0bWF4VmFyeWluZ3M6IG1heFZhcnlpbmdzLFxcblxcdFxcdFxcdG1heEZyYWdtZW50VW5pZm9ybXM6IG1heEZyYWdtZW50VW5pZm9ybXMsXFxuXFxuXFx0XFx0XFx0dmVydGV4VGV4dHVyZXM6IHZlcnRleFRleHR1cmVzLFxcblxcdFxcdFxcdGZsb2F0RnJhZ21lbnRUZXh0dXJlczogZmxvYXRGcmFnbWVudFRleHR1cmVzLFxcblxcdFxcdFxcdGZsb2F0VmVydGV4VGV4dHVyZXM6IGZsb2F0VmVydGV4VGV4dHVyZXNcXG5cXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgZ3JlZ2dtYW4gLyBodHRwOi8vZ2FtZXMuZ3JlZ2dtYW4uY29tL1xcblxcdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKSB7XFxuXFxuXFx0XFx0Q2FtZXJhLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnUGVyc3BlY3RpdmVDYW1lcmEnO1xcblxcblxcdFxcdHRoaXMuZm92ID0gZm92ICE9PSB1bmRlZmluZWQgPyBmb3YgOiA1MDtcXG5cXHRcXHR0aGlzLnpvb20gPSAxO1xcblxcblxcdFxcdHRoaXMubmVhciA9IG5lYXIgIT09IHVuZGVmaW5lZCA/IG5lYXIgOiAwLjE7XFxuXFx0XFx0dGhpcy5mYXIgPSBmYXIgIT09IHVuZGVmaW5lZCA/IGZhciA6IDIwMDA7XFxuXFx0XFx0dGhpcy5mb2N1cyA9IDEwO1xcblxcblxcdFxcdHRoaXMuYXNwZWN0ID0gYXNwZWN0ICE9PSB1bmRlZmluZWQgPyBhc3BlY3QgOiAxO1xcblxcdFxcdHRoaXMudmlldyA9IG51bGw7XFxuXFxuXFx0XFx0dGhpcy5maWxtR2F1Z2UgPSAzNTtcXHQvLyB3aWR0aCBvZiB0aGUgZmlsbSAoZGVmYXVsdCBpbiBtaWxsaW1ldGVycylcXG5cXHRcXHR0aGlzLmZpbG1PZmZzZXQgPSAwO1xcdC8vIGhvcml6b250YWwgZmlsbSBvZmZzZXQgKHNhbWUgdW5pdCBhcyBnYXVnZSlcXG5cXG5cXHRcXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcXG5cXG5cXHR9XFxuXFxuXFx0UGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQ2FtZXJhLnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IFBlcnNwZWN0aXZlQ2FtZXJhLFxcblxcblxcdFxcdGlzUGVyc3BlY3RpdmVDYW1lcmE6IHRydWUsXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcXG5cXG5cXHRcXHRcXHRDYW1lcmEucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlLCByZWN1cnNpdmUgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmZvdiA9IHNvdXJjZS5mb3Y7XFxuXFx0XFx0XFx0dGhpcy56b29tID0gc291cmNlLnpvb207XFxuXFxuXFx0XFx0XFx0dGhpcy5uZWFyID0gc291cmNlLm5lYXI7XFxuXFx0XFx0XFx0dGhpcy5mYXIgPSBzb3VyY2UuZmFyO1xcblxcdFxcdFxcdHRoaXMuZm9jdXMgPSBzb3VyY2UuZm9jdXM7XFxuXFxuXFx0XFx0XFx0dGhpcy5hc3BlY3QgPSBzb3VyY2UuYXNwZWN0O1xcblxcdFxcdFxcdHRoaXMudmlldyA9IHNvdXJjZS52aWV3ID09PSBudWxsID8gbnVsbCA6IE9iamVjdC5hc3NpZ24oIHt9LCBzb3VyY2UudmlldyApO1xcblxcblxcdFxcdFxcdHRoaXMuZmlsbUdhdWdlID0gc291cmNlLmZpbG1HYXVnZTtcXG5cXHRcXHRcXHR0aGlzLmZpbG1PZmZzZXQgPSBzb3VyY2UuZmlsbU9mZnNldDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIFNldHMgdGhlIEZPViBieSBmb2NhbCBsZW5ndGggaW4gcmVzcGVjdCB0byB0aGUgY3VycmVudCAuZmlsbUdhdWdlLlxcblxcdFxcdCAqXFxuXFx0XFx0ICogVGhlIGRlZmF1bHQgZmlsbSBnYXVnZSBpcyAzNSwgc28gdGhhdCB0aGUgZm9jYWwgbGVuZ3RoIGNhbiBiZSBzcGVjaWZpZWQgZm9yXFxuXFx0XFx0ICogYSAzNW1tIChmdWxsIGZyYW1lKSBjYW1lcmEuXFxuXFx0XFx0ICpcXG5cXHRcXHQgKiBWYWx1ZXMgZm9yIGZvY2FsIGxlbmd0aCBhbmQgZmlsbSBnYXVnZSBtdXN0IGhhdmUgdGhlIHNhbWUgdW5pdC5cXG5cXHRcXHQgKi9cXG5cXHRcXHRzZXRGb2NhbExlbmd0aDogZnVuY3Rpb24gKCBmb2NhbExlbmd0aCApIHtcXG5cXG5cXHRcXHRcXHQvLyBzZWUgaHR0cDovL3d3dy5ib2JhdGtpbnMuY29tL3Bob3RvZ3JhcGh5L3RlY2huaWNhbC9maWVsZF9vZl92aWV3Lmh0bWxcXG5cXHRcXHRcXHR2YXIgdkV4dGVudFNsb3BlID0gMC41ICogdGhpcy5nZXRGaWxtSGVpZ2h0KCkgLyBmb2NhbExlbmd0aDtcXG5cXG5cXHRcXHRcXHR0aGlzLmZvdiA9IF9NYXRoLlJBRDJERUcgKiAyICogTWF0aC5hdGFuKCB2RXh0ZW50U2xvcGUgKTtcXG5cXHRcXHRcXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qKlxcblxcdFxcdCAqIENhbGN1bGF0ZXMgdGhlIGZvY2FsIGxlbmd0aCBmcm9tIHRoZSBjdXJyZW50IC5mb3YgYW5kIC5maWxtR2F1Z2UuXFxuXFx0XFx0ICovXFxuXFx0XFx0Z2V0Rm9jYWxMZW5ndGg6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdkV4dGVudFNsb3BlID0gTWF0aC50YW4oIF9NYXRoLkRFRzJSQUQgKiAwLjUgKiB0aGlzLmZvdiApO1xcblxcblxcdFxcdFxcdHJldHVybiAwLjUgKiB0aGlzLmdldEZpbG1IZWlnaHQoKSAvIHZFeHRlbnRTbG9wZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldEVmZmVjdGl2ZUZPVjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBfTWF0aC5SQUQyREVHICogMiAqIE1hdGguYXRhbihcXG5cXHRcXHRcXHRcXHRNYXRoLnRhbiggX01hdGguREVHMlJBRCAqIDAuNSAqIHRoaXMuZm92ICkgLyB0aGlzLnpvb20gKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldEZpbG1XaWR0aDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIGZpbG0gbm90IGNvbXBsZXRlbHkgY292ZXJlZCBpbiBwb3J0cmFpdCBmb3JtYXQgKGFzcGVjdCA8IDEpXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZmlsbUdhdWdlICogTWF0aC5taW4oIHRoaXMuYXNwZWN0LCAxICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRGaWxtSGVpZ2h0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Ly8gZmlsbSBub3QgY29tcGxldGVseSBjb3ZlcmVkIGluIGxhbmRzY2FwZSBmb3JtYXQgKGFzcGVjdCA+IDEpXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZmlsbUdhdWdlIC8gTWF0aC5tYXgoIHRoaXMuYXNwZWN0LCAxICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBTZXRzIGFuIG9mZnNldCBpbiBhIGxhcmdlciBmcnVzdHVtLiBUaGlzIGlzIHVzZWZ1bCBmb3IgbXVsdGktd2luZG93IG9yXFxuXFx0XFx0ICogbXVsdGktbW9uaXRvci9tdWx0aS1tYWNoaW5lIHNldHVwcy5cXG5cXHRcXHQgKlxcblxcdFxcdCAqIEZvciBleGFtcGxlLCBpZiB5b3UgaGF2ZSAzeDIgbW9uaXRvcnMgYW5kIGVhY2ggbW9uaXRvciBpcyAxOTIweDEwODAgYW5kXFxuXFx0XFx0ICogdGhlIG1vbml0b3JzIGFyZSBpbiBncmlkIGxpa2UgdGhpc1xcblxcdFxcdCAqXFxuXFx0XFx0ICogICArLS0tKy0tLSstLS0rXFxuXFx0XFx0ICogICB8IEEgfCBCIHwgQyB8XFxuXFx0XFx0ICogICArLS0tKy0tLSstLS0rXFxuXFx0XFx0ICogICB8IEQgfCBFIHwgRiB8XFxuXFx0XFx0ICogICArLS0tKy0tLSstLS0rXFxuXFx0XFx0ICpcXG5cXHRcXHQgKiB0aGVuIGZvciBlYWNoIG1vbml0b3IgeW91IHdvdWxkIGNhbGwgaXQgbGlrZSB0aGlzXFxuXFx0XFx0ICpcXG5cXHRcXHQgKiAgIHZhciB3ID0gMTkyMDtcXG5cXHRcXHQgKiAgIHZhciBoID0gMTA4MDtcXG5cXHRcXHQgKiAgIHZhciBmdWxsV2lkdGggPSB3ICogMztcXG5cXHRcXHQgKiAgIHZhciBmdWxsSGVpZ2h0ID0gaCAqIDI7XFxuXFx0XFx0ICpcXG5cXHRcXHQgKiAgIC0tQS0tXFxuXFx0XFx0ICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMCwgdywgaCApO1xcblxcdFxcdCAqICAgLS1CLS1cXG5cXHRcXHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAwLCB3LCBoICk7XFxuXFx0XFx0ICogICAtLUMtLVxcblxcdFxcdCAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDAsIHcsIGggKTtcXG5cXHRcXHQgKiAgIC0tRC0tXFxuXFx0XFx0ICogICBjYW1lcmEuc2V0T2Zmc2V0KCBmdWxsV2lkdGgsIGZ1bGxIZWlnaHQsIHcgKiAwLCBoICogMSwgdywgaCApO1xcblxcdFxcdCAqICAgLS1FLS1cXG5cXHRcXHQgKiAgIGNhbWVyYS5zZXRPZmZzZXQoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgdyAqIDEsIGggKiAxLCB3LCBoICk7XFxuXFx0XFx0ICogICAtLUYtLVxcblxcdFxcdCAqICAgY2FtZXJhLnNldE9mZnNldCggZnVsbFdpZHRoLCBmdWxsSGVpZ2h0LCB3ICogMiwgaCAqIDEsIHcsIGggKTtcXG5cXHRcXHQgKlxcblxcdFxcdCAqICAgTm90ZSB0aGVyZSBpcyBubyByZWFzb24gbW9uaXRvcnMgaGF2ZSB0byBiZSB0aGUgc2FtZSBzaXplIG9yIGluIGEgZ3JpZC5cXG5cXHRcXHQgKi9cXG5cXHRcXHRzZXRWaWV3T2Zmc2V0OiBmdW5jdGlvbiAoIGZ1bGxXaWR0aCwgZnVsbEhlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmFzcGVjdCA9IGZ1bGxXaWR0aCAvIGZ1bGxIZWlnaHQ7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnZpZXcgPT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy52aWV3ID0ge1xcblxcdFxcdFxcdFxcdFxcdGVuYWJsZWQ6IHRydWUsXFxuXFx0XFx0XFx0XFx0XFx0ZnVsbFdpZHRoOiAxLFxcblxcdFxcdFxcdFxcdFxcdGZ1bGxIZWlnaHQ6IDEsXFxuXFx0XFx0XFx0XFx0XFx0b2Zmc2V0WDogMCxcXG5cXHRcXHRcXHRcXHRcXHRvZmZzZXRZOiAwLFxcblxcdFxcdFxcdFxcdFxcdHdpZHRoOiAxLFxcblxcdFxcdFxcdFxcdFxcdGhlaWdodDogMVxcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMudmlldy5lbmFibGVkID0gdHJ1ZTtcXG5cXHRcXHRcXHR0aGlzLnZpZXcuZnVsbFdpZHRoID0gZnVsbFdpZHRoO1xcblxcdFxcdFxcdHRoaXMudmlldy5mdWxsSGVpZ2h0ID0gZnVsbEhlaWdodDtcXG5cXHRcXHRcXHR0aGlzLnZpZXcub2Zmc2V0WCA9IHg7XFxuXFx0XFx0XFx0dGhpcy52aWV3Lm9mZnNldFkgPSB5O1xcblxcdFxcdFxcdHRoaXMudmlldy53aWR0aCA9IHdpZHRoO1xcblxcdFxcdFxcdHRoaXMudmlldy5oZWlnaHQgPSBoZWlnaHQ7XFxuXFxuXFx0XFx0XFx0dGhpcy51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbGVhclZpZXdPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMudmlldyAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnZpZXcuZW5hYmxlZCA9IGZhbHNlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHVwZGF0ZVByb2plY3Rpb25NYXRyaXg6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgbmVhciA9IHRoaXMubmVhcixcXG5cXHRcXHRcXHRcXHR0b3AgPSBuZWFyICogTWF0aC50YW4oXFxuXFx0XFx0XFx0XFx0XFx0X01hdGguREVHMlJBRCAqIDAuNSAqIHRoaXMuZm92ICkgLyB0aGlzLnpvb20sXFxuXFx0XFx0XFx0XFx0aGVpZ2h0ID0gMiAqIHRvcCxcXG5cXHRcXHRcXHRcXHR3aWR0aCA9IHRoaXMuYXNwZWN0ICogaGVpZ2h0LFxcblxcdFxcdFxcdFxcdGxlZnQgPSAtIDAuNSAqIHdpZHRoLFxcblxcdFxcdFxcdFxcdHZpZXcgPSB0aGlzLnZpZXc7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgJiYgdGhpcy52aWV3LmVuYWJsZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGZ1bGxXaWR0aCA9IHZpZXcuZnVsbFdpZHRoLFxcblxcdFxcdFxcdFxcdFxcdGZ1bGxIZWlnaHQgPSB2aWV3LmZ1bGxIZWlnaHQ7XFxuXFxuXFx0XFx0XFx0XFx0bGVmdCArPSB2aWV3Lm9mZnNldFggKiB3aWR0aCAvIGZ1bGxXaWR0aDtcXG5cXHRcXHRcXHRcXHR0b3AgLT0gdmlldy5vZmZzZXRZICogaGVpZ2h0IC8gZnVsbEhlaWdodDtcXG5cXHRcXHRcXHRcXHR3aWR0aCAqPSB2aWV3LndpZHRoIC8gZnVsbFdpZHRoO1xcblxcdFxcdFxcdFxcdGhlaWdodCAqPSB2aWV3LmhlaWdodCAvIGZ1bGxIZWlnaHQ7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBza2V3ID0gdGhpcy5maWxtT2Zmc2V0O1xcblxcdFxcdFxcdGlmICggc2tldyAhPT0gMCApIGxlZnQgKz0gbmVhciAqIHNrZXcgLyB0aGlzLmdldEZpbG1XaWR0aCgpO1xcblxcblxcdFxcdFxcdHRoaXMucHJvamVjdGlvbk1hdHJpeC5tYWtlUGVyc3BlY3RpdmUoIGxlZnQsIGxlZnQgKyB3aWR0aCwgdG9wLCB0b3AgLSBoZWlnaHQsIG5lYXIsIHRoaXMuZmFyICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZGF0YSA9IE9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xcblxcblxcdFxcdFxcdGRhdGEub2JqZWN0LmZvdiA9IHRoaXMuZm92O1xcblxcdFxcdFxcdGRhdGEub2JqZWN0Lnpvb20gPSB0aGlzLnpvb207XFxuXFxuXFx0XFx0XFx0ZGF0YS5vYmplY3QubmVhciA9IHRoaXMubmVhcjtcXG5cXHRcXHRcXHRkYXRhLm9iamVjdC5mYXIgPSB0aGlzLmZhcjtcXG5cXHRcXHRcXHRkYXRhLm9iamVjdC5mb2N1cyA9IHRoaXMuZm9jdXM7XFxuXFxuXFx0XFx0XFx0ZGF0YS5vYmplY3QuYXNwZWN0ID0gdGhpcy5hc3BlY3Q7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnZpZXcgIT09IG51bGwgKSBkYXRhLm9iamVjdC52aWV3ID0gT2JqZWN0LmFzc2lnbigge30sIHRoaXMudmlldyApO1xcblxcblxcdFxcdFxcdGRhdGEub2JqZWN0LmZpbG1HYXVnZSA9IHRoaXMuZmlsbUdhdWdlO1xcblxcdFxcdFxcdGRhdGEub2JqZWN0LmZpbG1PZmZzZXQgPSB0aGlzLmZpbG1PZmZzZXQ7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGRhdGE7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEFycmF5Q2FtZXJhKCBhcnJheSApIHtcXG5cXG5cXHRcXHRQZXJzcGVjdGl2ZUNhbWVyYS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy5jYW1lcmFzID0gYXJyYXkgfHwgW107XFxuXFxuXFx0fVxcblxcblxcdEFycmF5Q2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIFBlcnNwZWN0aXZlQ2FtZXJhLnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IEFycmF5Q2FtZXJhLFxcblxcblxcdFxcdGlzQXJyYXlDYW1lcmE6IHRydWVcXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBXZWJWUk1hbmFnZXIoIHJlbmRlcmVyICkge1xcblxcblxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxuXFxuXFx0XFx0dmFyIGRldmljZSA9IG51bGw7XFxuXFx0XFx0dmFyIGZyYW1lRGF0YSA9IG51bGw7XFxuXFxuXFx0XFx0dmFyIHBvc2VUYXJnZXQgPSBudWxsO1xcblxcblxcdFxcdGlmICggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ1ZSRnJhbWVEYXRhJyBpbiB3aW5kb3cgKSB7XFxuXFxuXFx0XFx0XFx0ZnJhbWVEYXRhID0gbmV3IHdpbmRvdy5WUkZyYW1lRGF0YSgpO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgbWF0cml4V29ybGRJbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcXG5cXG5cXHRcXHR2YXIgY2FtZXJhTCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xcblxcdFxcdGNhbWVyYUwuYm91bmRzID0gbmV3IFZlY3RvcjQoIDAuMCwgMC4wLCAwLjUsIDEuMCApO1xcblxcdFxcdGNhbWVyYUwubGF5ZXJzLmVuYWJsZSggMSApO1xcblxcblxcdFxcdHZhciBjYW1lcmFSID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XFxuXFx0XFx0Y2FtZXJhUi5ib3VuZHMgPSBuZXcgVmVjdG9yNCggMC41LCAwLjAsIDAuNSwgMS4wICk7XFxuXFx0XFx0Y2FtZXJhUi5sYXllcnMuZW5hYmxlKCAyICk7XFxuXFxuXFx0XFx0dmFyIGNhbWVyYVZSID0gbmV3IEFycmF5Q2FtZXJhKCBbIGNhbWVyYUwsIGNhbWVyYVIgXSApO1xcblxcdFxcdGNhbWVyYVZSLmxheWVycy5lbmFibGUoIDEgKTtcXG5cXHRcXHRjYW1lcmFWUi5sYXllcnMuZW5hYmxlKCAyICk7XFxuXFxuXFx0XFx0Ly9cXG5cXG5cXHRcXHR2YXIgY3VycmVudFNpemUsIGN1cnJlbnRQaXhlbFJhdGlvO1xcblxcblxcdFxcdGZ1bmN0aW9uIG9uVlJEaXNwbGF5UHJlc2VudENoYW5nZSgpIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGRldmljZSAhPT0gbnVsbCAmJiBkZXZpY2UuaXNQcmVzZW50aW5nICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBleWVQYXJhbWV0ZXJzID0gZGV2aWNlLmdldEV5ZVBhcmFtZXRlcnMoICdsZWZ0JyApO1xcblxcdFxcdFxcdFxcdHZhciByZW5kZXJXaWR0aCA9IGV5ZVBhcmFtZXRlcnMucmVuZGVyV2lkdGg7XFxuXFx0XFx0XFx0XFx0dmFyIHJlbmRlckhlaWdodCA9IGV5ZVBhcmFtZXRlcnMucmVuZGVySGVpZ2h0O1xcblxcblxcdFxcdFxcdFxcdGN1cnJlbnRQaXhlbFJhdGlvID0gcmVuZGVyZXIuZ2V0UGl4ZWxSYXRpbygpO1xcblxcdFxcdFxcdFxcdGN1cnJlbnRTaXplID0gcmVuZGVyZXIuZ2V0U2l6ZSgpO1xcblxcblxcdFxcdFxcdFxcdHJlbmRlcmVyLnNldERyYXdpbmdCdWZmZXJTaXplKCByZW5kZXJXaWR0aCAqIDIsIHJlbmRlckhlaWdodCwgMSApO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHNjb3BlLmVuYWJsZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmVuZGVyZXIuc2V0RHJhd2luZ0J1ZmZlclNpemUoIGN1cnJlbnRTaXplLndpZHRoLCBjdXJyZW50U2l6ZS5oZWlnaHQsIGN1cnJlbnRQaXhlbFJhdGlvICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICkge1xcblxcblxcdFxcdFxcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAndnJkaXNwbGF5cHJlc2VudGNoYW5nZScsIG9uVlJEaXNwbGF5UHJlc2VudENoYW5nZSwgZmFsc2UgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly9cXG5cXG5cXHRcXHR0aGlzLmVuYWJsZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLmdldERldmljZSA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZGV2aWNlO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5zZXREZXZpY2UgPSBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIGRldmljZSA9IHZhbHVlO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5zZXRQb3NlVGFyZ2V0ID0gZnVuY3Rpb24gKCBvYmplY3QgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBvYmplY3QgIT09IHVuZGVmaW5lZCApIHBvc2VUYXJnZXQgPSBvYmplY3Q7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLmdldENhbWVyYSA9IGZ1bmN0aW9uICggY2FtZXJhICkge1xcblxcblxcdFxcdFxcdGlmICggZGV2aWNlID09PSBudWxsICkgcmV0dXJuIGNhbWVyYTtcXG5cXG5cXHRcXHRcXHRkZXZpY2UuZGVwdGhOZWFyID0gY2FtZXJhLm5lYXI7XFxuXFx0XFx0XFx0ZGV2aWNlLmRlcHRoRmFyID0gY2FtZXJhLmZhcjtcXG5cXG5cXHRcXHRcXHRkZXZpY2UuZ2V0RnJhbWVEYXRhKCBmcmFtZURhdGEgKTtcXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdHZhciBwb3NlID0gZnJhbWVEYXRhLnBvc2U7XFxuXFx0XFx0XFx0dmFyIHBvc2VPYmplY3QgPSBwb3NlVGFyZ2V0ICE9PSBudWxsID8gcG9zZVRhcmdldCA6IGNhbWVyYTtcXG5cXG5cXHRcXHRcXHRpZiAoIHBvc2UucG9zaXRpb24gIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cG9zZU9iamVjdC5wb3NpdGlvbi5mcm9tQXJyYXkoIHBvc2UucG9zaXRpb24gKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHBvc2VPYmplY3QucG9zaXRpb24uc2V0KCAwLCAwLCAwICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggcG9zZS5vcmllbnRhdGlvbiAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRwb3NlT2JqZWN0LnF1YXRlcm5pb24uZnJvbUFycmF5KCBwb3NlLm9yaWVudGF0aW9uICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHBvc2VPYmplY3QudXBkYXRlTWF0cml4V29ybGQoKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGRldmljZS5pc1ByZXNlbnRpbmcgPT09IGZhbHNlICkgcmV0dXJuIGNhbWVyYTtcXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdGNhbWVyYUwubmVhciA9IGNhbWVyYS5uZWFyO1xcblxcdFxcdFxcdGNhbWVyYVIubmVhciA9IGNhbWVyYS5uZWFyO1xcblxcblxcdFxcdFxcdGNhbWVyYUwuZmFyID0gY2FtZXJhLmZhcjtcXG5cXHRcXHRcXHRjYW1lcmFSLmZhciA9IGNhbWVyYS5mYXI7XFxuXFxuXFx0XFx0XFx0Y2FtZXJhVlIubWF0cml4V29ybGQuY29weSggY2FtZXJhLm1hdHJpeFdvcmxkICk7XFxuXFx0XFx0XFx0Y2FtZXJhVlIubWF0cml4V29ybGRJbnZlcnNlLmNvcHkoIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcXG5cXG5cXHRcXHRcXHRjYW1lcmFMLm1hdHJpeFdvcmxkSW52ZXJzZS5mcm9tQXJyYXkoIGZyYW1lRGF0YS5sZWZ0Vmlld01hdHJpeCApO1xcblxcdFxcdFxcdGNhbWVyYVIubWF0cml4V29ybGRJbnZlcnNlLmZyb21BcnJheSggZnJhbWVEYXRhLnJpZ2h0Vmlld01hdHJpeCApO1xcblxcblxcdFxcdFxcdHZhciBwYXJlbnQgPSBwb3NlT2JqZWN0LnBhcmVudDtcXG5cXG5cXHRcXHRcXHRpZiAoIHBhcmVudCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRtYXRyaXhXb3JsZEludmVyc2UuZ2V0SW52ZXJzZSggcGFyZW50Lm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0XFx0Y2FtZXJhTC5tYXRyaXhXb3JsZEludmVyc2UubXVsdGlwbHkoIG1hdHJpeFdvcmxkSW52ZXJzZSApO1xcblxcdFxcdFxcdFxcdGNhbWVyYVIubWF0cml4V29ybGRJbnZlcnNlLm11bHRpcGx5KCBtYXRyaXhXb3JsZEludmVyc2UgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gZW52TWFwIGFuZCBNaXJyb3IgbmVlZHMgY2FtZXJhLm1hdHJpeFdvcmxkXFxuXFxuXFx0XFx0XFx0Y2FtZXJhTC5tYXRyaXhXb3JsZC5nZXRJbnZlcnNlKCBjYW1lcmFMLm1hdHJpeFdvcmxkSW52ZXJzZSApO1xcblxcdFxcdFxcdGNhbWVyYVIubWF0cml4V29ybGQuZ2V0SW52ZXJzZSggY2FtZXJhUi5tYXRyaXhXb3JsZEludmVyc2UgKTtcXG5cXG5cXHRcXHRcXHRjYW1lcmFMLnByb2plY3Rpb25NYXRyaXguZnJvbUFycmF5KCBmcmFtZURhdGEubGVmdFByb2plY3Rpb25NYXRyaXggKTtcXG5cXHRcXHRcXHRjYW1lcmFSLnByb2plY3Rpb25NYXRyaXguZnJvbUFycmF5KCBmcmFtZURhdGEucmlnaHRQcm9qZWN0aW9uTWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0Ly8gSEFDSyBAbXJkb29iXFxuXFx0XFx0XFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3czYy93ZWJ2ci9pc3N1ZXMvMjAzXFxuXFxuXFx0XFx0XFx0Y2FtZXJhVlIucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBjYW1lcmFMLnByb2plY3Rpb25NYXRyaXggKTtcXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdHZhciBsYXllcnMgPSBkZXZpY2UuZ2V0TGF5ZXJzKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCBsYXllcnMubGVuZ3RoICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBsYXllciA9IGxheWVyc1sgMCBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggbGF5ZXIubGVmdEJvdW5kcyAhPT0gbnVsbCAmJiBsYXllci5sZWZ0Qm91bmRzLmxlbmd0aCA9PT0gNCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYW1lcmFMLmJvdW5kcy5mcm9tQXJyYXkoIGxheWVyLmxlZnRCb3VuZHMgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBsYXllci5yaWdodEJvdW5kcyAhPT0gbnVsbCAmJiBsYXllci5yaWdodEJvdW5kcy5sZW5ndGggPT09IDQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FtZXJhUi5ib3VuZHMuZnJvbUFycmF5KCBsYXllci5yaWdodEJvdW5kcyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGNhbWVyYVZSO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5zdWJtaXRGcmFtZSA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGRldmljZSAmJiBkZXZpY2UuaXNQcmVzZW50aW5nICkgZGV2aWNlLnN1Ym1pdEZyYW1lKCk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyApIHtcXG5cXG5cXHRcXHRcXHRcXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ3ZyZGlzcGxheXByZXNlbnRjaGFuZ2UnLCBvblZSRGlzcGxheVByZXNlbnRDaGFuZ2UgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBXZWJHTEV4dGVuc2lvbnMoIGdsICkge1xcblxcblxcdFxcdHZhciBleHRlbnNpb25zID0ge307XFxuXFxuXFx0XFx0cmV0dXJuIHtcXG5cXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICggbmFtZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGV4dGVuc2lvbnNbIG5hbWUgXSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBleHRlbnNpb25zWyBuYW1lIF07XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHZhciBleHRlbnNpb247XFxuXFxuXFx0XFx0XFx0XFx0c3dpdGNoICggbmFtZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdXRUJHTF9kZXB0aF90ZXh0dXJlJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9kZXB0aF90ZXh0dXJlJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ01PWl9XRUJHTF9kZXB0aF90ZXh0dXJlJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9kZXB0aF90ZXh0dXJlJyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYyc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnRVhUX3RleHR1cmVfZmlsdGVyX2FuaXNvdHJvcGljJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ01PWl9FWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCS0lUX0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0Yyc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCAnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGMnICkgfHwgZ2wuZ2V0RXh0ZW5zaW9uKCAnTU9aX1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApIHx8IGdsLmdldEV4dGVuc2lvbiggJ1dFQktJVF9XRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9wdnJ0YycgKSB8fCBnbC5nZXRFeHRlbnNpb24oICdXRUJLSVRfV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjJyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRleHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfZXRjMScgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdFxcdFxcdGV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbiggbmFtZSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGV4dGVuc2lvbiA9PT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAnICsgbmFtZSArICcgZXh0ZW5zaW9uIG5vdCBzdXBwb3J0ZWQuJyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRleHRlbnNpb25zWyBuYW1lIF0gPSBleHRlbnNpb247XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGV4dGVuc2lvbjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFdlYkdMQ2xpcHBpbmcoKSB7XFxuXFxuXFx0XFx0dmFyIHNjb3BlID0gdGhpcyxcXG5cXG5cXHRcXHRcXHRnbG9iYWxTdGF0ZSA9IG51bGwsXFxuXFx0XFx0XFx0bnVtR2xvYmFsUGxhbmVzID0gMCxcXG5cXHRcXHRcXHRsb2NhbENsaXBwaW5nRW5hYmxlZCA9IGZhbHNlLFxcblxcdFxcdFxcdHJlbmRlcmluZ1NoYWRvd3MgPSBmYWxzZSxcXG5cXG5cXHRcXHRcXHRwbGFuZSA9IG5ldyBQbGFuZSgpLFxcblxcdFxcdFxcdHZpZXdOb3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpLFxcblxcblxcdFxcdFxcdHVuaWZvcm0gPSB7IHZhbHVlOiBudWxsLCBuZWVkc1VwZGF0ZTogZmFsc2UgfTtcXG5cXG5cXHRcXHR0aGlzLnVuaWZvcm0gPSB1bmlmb3JtO1xcblxcdFxcdHRoaXMubnVtUGxhbmVzID0gMDtcXG5cXHRcXHR0aGlzLm51bUludGVyc2VjdGlvbiA9IDA7XFxuXFxuXFx0XFx0dGhpcy5pbml0ID0gZnVuY3Rpb24gKCBwbGFuZXMsIGVuYWJsZUxvY2FsQ2xpcHBpbmcsIGNhbWVyYSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZW5hYmxlZCA9XFxuXFx0XFx0XFx0XFx0cGxhbmVzLmxlbmd0aCAhPT0gMCB8fFxcblxcdFxcdFxcdFxcdGVuYWJsZUxvY2FsQ2xpcHBpbmcgfHxcXG5cXHRcXHRcXHRcXHQvLyBlbmFibGUgc3RhdGUgb2YgcHJldmlvdXMgZnJhbWUgLSB0aGUgY2xpcHBpbmcgY29kZSBoYXMgdG9cXG5cXHRcXHRcXHRcXHQvLyBydW4gYW5vdGhlciBmcmFtZSBpbiBvcmRlciB0byByZXNldCB0aGUgc3RhdGU6XFxuXFx0XFx0XFx0XFx0bnVtR2xvYmFsUGxhbmVzICE9PSAwIHx8XFxuXFx0XFx0XFx0XFx0bG9jYWxDbGlwcGluZ0VuYWJsZWQ7XFxuXFxuXFx0XFx0XFx0bG9jYWxDbGlwcGluZ0VuYWJsZWQgPSBlbmFibGVMb2NhbENsaXBwaW5nO1xcblxcblxcdFxcdFxcdGdsb2JhbFN0YXRlID0gcHJvamVjdFBsYW5lcyggcGxhbmVzLCBjYW1lcmEsIDAgKTtcXG5cXHRcXHRcXHRudW1HbG9iYWxQbGFuZXMgPSBwbGFuZXMubGVuZ3RoO1xcblxcblxcdFxcdFxcdHJldHVybiBlbmFibGVkO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5iZWdpblNoYWRvd3MgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmVuZGVyaW5nU2hhZG93cyA9IHRydWU7XFxuXFx0XFx0XFx0cHJvamVjdFBsYW5lcyggbnVsbCApO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5lbmRTaGFkb3dzID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJlbmRlcmluZ1NoYWRvd3MgPSBmYWxzZTtcXG5cXHRcXHRcXHRyZXNldEdsb2JhbFN0YXRlKCk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLnNldFN0YXRlID0gZnVuY3Rpb24gKCBwbGFuZXMsIGNsaXBJbnRlcnNlY3Rpb24sIGNsaXBTaGFkb3dzLCBjYW1lcmEsIGNhY2hlLCBmcm9tQ2FjaGUgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCAhIGxvY2FsQ2xpcHBpbmdFbmFibGVkIHx8IHBsYW5lcyA9PT0gbnVsbCB8fCBwbGFuZXMubGVuZ3RoID09PSAwIHx8IHJlbmRlcmluZ1NoYWRvd3MgJiYgISBjbGlwU2hhZG93cyApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyB0aGVyZSdzIG5vIGxvY2FsIGNsaXBwaW5nXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCByZW5kZXJpbmdTaGFkb3dzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHRoZXJlJ3Mgbm8gZ2xvYmFsIGNsaXBwaW5nXFxuXFxuXFx0XFx0XFx0XFx0XFx0cHJvamVjdFBsYW5lcyggbnVsbCApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmVzZXRHbG9iYWxTdGF0ZSgpO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHZhciBuR2xvYmFsID0gcmVuZGVyaW5nU2hhZG93cyA/IDAgOiBudW1HbG9iYWxQbGFuZXMsXFxuXFx0XFx0XFx0XFx0XFx0bEdsb2JhbCA9IG5HbG9iYWwgKiA0LFxcblxcblxcdFxcdFxcdFxcdFxcdGRzdEFycmF5ID0gY2FjaGUuY2xpcHBpbmdTdGF0ZSB8fCBudWxsO1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm0udmFsdWUgPSBkc3RBcnJheTsgLy8gZW5zdXJlIHVuaXF1ZSBzdGF0ZVxcblxcblxcdFxcdFxcdFxcdGRzdEFycmF5ID0gcHJvamVjdFBsYW5lcyggcGxhbmVzLCBjYW1lcmEsIGxHbG9iYWwsIGZyb21DYWNoZSApO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbEdsb2JhbDsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRkc3RBcnJheVsgaSBdID0gZ2xvYmFsU3RhdGVbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Y2FjaGUuY2xpcHBpbmdTdGF0ZSA9IGRzdEFycmF5O1xcblxcdFxcdFxcdFxcdHRoaXMubnVtSW50ZXJzZWN0aW9uID0gY2xpcEludGVyc2VjdGlvbiA/IHRoaXMubnVtUGxhbmVzIDogMDtcXG5cXHRcXHRcXHRcXHR0aGlzLm51bVBsYW5lcyArPSBuR2xvYmFsO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdGZ1bmN0aW9uIHJlc2V0R2xvYmFsU3RhdGUoKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB1bmlmb3JtLnZhbHVlICE9PSBnbG9iYWxTdGF0ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3JtLnZhbHVlID0gZ2xvYmFsU3RhdGU7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybS5uZWVkc1VwZGF0ZSA9IG51bUdsb2JhbFBsYW5lcyA+IDA7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHNjb3BlLm51bVBsYW5lcyA9IG51bUdsb2JhbFBsYW5lcztcXG5cXHRcXHRcXHRzY29wZS5udW1JbnRlcnNlY3Rpb24gPSAwO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBwcm9qZWN0UGxhbmVzKCBwbGFuZXMsIGNhbWVyYSwgZHN0T2Zmc2V0LCBza2lwVHJhbnNmb3JtICkge1xcblxcblxcdFxcdFxcdHZhciBuUGxhbmVzID0gcGxhbmVzICE9PSBudWxsID8gcGxhbmVzLmxlbmd0aCA6IDAsXFxuXFx0XFx0XFx0XFx0ZHN0QXJyYXkgPSBudWxsO1xcblxcblxcdFxcdFxcdGlmICggblBsYW5lcyAhPT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRkc3RBcnJheSA9IHVuaWZvcm0udmFsdWU7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBza2lwVHJhbnNmb3JtICE9PSB0cnVlIHx8IGRzdEFycmF5ID09PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBmbGF0U2l6ZSA9IGRzdE9mZnNldCArIG5QbGFuZXMgKiA0LFxcblxcdFxcdFxcdFxcdFxcdFxcdHZpZXdNYXRyaXggPSBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlO1xcblxcblxcdFxcdFxcdFxcdFxcdHZpZXdOb3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCB2aWV3TWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkc3RBcnJheSA9PT0gbnVsbCB8fCBkc3RBcnJheS5sZW5ndGggPCBmbGF0U2l6ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRkc3RBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIGZsYXRTaXplICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaTQgPSBkc3RPZmZzZXQ7IGkgIT09IG5QbGFuZXM7ICsrIGksIGk0ICs9IDQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cGxhbmUuY29weSggcGxhbmVzWyBpIF0gKS5hcHBseU1hdHJpeDQoIHZpZXdNYXRyaXgsIHZpZXdOb3JtYWxNYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRwbGFuZS5ub3JtYWwudG9BcnJheSggZHN0QXJyYXksIGk0ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZHN0QXJyYXlbIGk0ICsgMyBdID0gcGxhbmUuY29uc3RhbnQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3JtLnZhbHVlID0gZHN0QXJyYXk7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybS5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHNjb3BlLm51bVBsYW5lcyA9IG5QbGFuZXM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGRzdEFycmF5O1xcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciB0aGVzcGl0ZSAvIGh0dHA6Ly93d3cudHdpdHRlci5jb20vdGhlc3BpdGVcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBXZWJHTFV0aWxzKCBnbCwgZXh0ZW5zaW9ucyApIHtcXG5cXG5cXHRcXHRmdW5jdGlvbiBjb252ZXJ0KCBwICkge1xcblxcblxcdFxcdFxcdHZhciBleHRlbnNpb247XFxuXFxuXFx0XFx0XFx0aWYgKCBwID09PSBSZXBlYXRXcmFwcGluZyApIHJldHVybiBnbC5SRVBFQVQ7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBDbGFtcFRvRWRnZVdyYXBwaW5nICkgcmV0dXJuIGdsLkNMQU1QX1RPX0VER0U7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nICkgcmV0dXJuIGdsLk1JUlJPUkVEX1JFUEVBVDtcXG5cXG5cXHRcXHRcXHRpZiAoIHAgPT09IE5lYXJlc3RGaWx0ZXIgKSByZXR1cm4gZ2wuTkVBUkVTVDtcXG5cXHRcXHRcXHRpZiAoIHAgPT09IE5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyICkgcmV0dXJuIGdsLk5FQVJFU1RfTUlQTUFQX05FQVJFU1Q7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyICkgcmV0dXJuIGdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUjtcXG5cXG5cXHRcXHRcXHRpZiAoIHAgPT09IExpbmVhckZpbHRlciApIHJldHVybiBnbC5MSU5FQVI7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBMaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyICkgcmV0dXJuIGdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVDtcXG5cXHRcXHRcXHRpZiAoIHAgPT09IExpbmVhck1pcE1hcExpbmVhckZpbHRlciApIHJldHVybiBnbC5MSU5FQVJfTUlQTUFQX0xJTkVBUjtcXG5cXG5cXHRcXHRcXHRpZiAoIHAgPT09IFVuc2lnbmVkQnl0ZVR5cGUgKSByZXR1cm4gZ2wuVU5TSUdORURfQllURTtcXG5cXHRcXHRcXHRpZiAoIHAgPT09IFVuc2lnbmVkU2hvcnQ0NDQ0VHlwZSApIHJldHVybiBnbC5VTlNJR05FRF9TSE9SVF80XzRfNF80O1xcblxcdFxcdFxcdGlmICggcCA9PT0gVW5zaWduZWRTaG9ydDU1NTFUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX1NIT1JUXzVfNV81XzE7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBVbnNpZ25lZFNob3J0NTY1VHlwZSApIHJldHVybiBnbC5VTlNJR05FRF9TSE9SVF81XzZfNTtcXG5cXG5cXHRcXHRcXHRpZiAoIHAgPT09IEJ5dGVUeXBlICkgcmV0dXJuIGdsLkJZVEU7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBTaG9ydFR5cGUgKSByZXR1cm4gZ2wuU0hPUlQ7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBVbnNpZ25lZFNob3J0VHlwZSApIHJldHVybiBnbC5VTlNJR05FRF9TSE9SVDtcXG5cXHRcXHRcXHRpZiAoIHAgPT09IEludFR5cGUgKSByZXR1cm4gZ2wuSU5UO1xcblxcdFxcdFxcdGlmICggcCA9PT0gVW5zaWduZWRJbnRUeXBlICkgcmV0dXJuIGdsLlVOU0lHTkVEX0lOVDtcXG5cXHRcXHRcXHRpZiAoIHAgPT09IEZsb2F0VHlwZSApIHJldHVybiBnbC5GTE9BVDtcXG5cXG5cXHRcXHRcXHRpZiAoIHAgPT09IEhhbGZGbG9hdFR5cGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JyApO1xcblxcblxcdFxcdFxcdFxcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkgcmV0dXJuIGV4dGVuc2lvbi5IQUxGX0ZMT0FUX09FUztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBwID09PSBBbHBoYUZvcm1hdCApIHJldHVybiBnbC5BTFBIQTtcXG5cXHRcXHRcXHRpZiAoIHAgPT09IFJHQkZvcm1hdCApIHJldHVybiBnbC5SR0I7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBSR0JBRm9ybWF0ICkgcmV0dXJuIGdsLlJHQkE7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBMdW1pbmFuY2VGb3JtYXQgKSByZXR1cm4gZ2wuTFVNSU5BTkNFO1xcblxcdFxcdFxcdGlmICggcCA9PT0gTHVtaW5hbmNlQWxwaGFGb3JtYXQgKSByZXR1cm4gZ2wuTFVNSU5BTkNFX0FMUEhBO1xcblxcdFxcdFxcdGlmICggcCA9PT0gRGVwdGhGb3JtYXQgKSByZXR1cm4gZ2wuREVQVEhfQ09NUE9ORU5UO1xcblxcdFxcdFxcdGlmICggcCA9PT0gRGVwdGhTdGVuY2lsRm9ybWF0ICkgcmV0dXJuIGdsLkRFUFRIX1NURU5DSUw7XFxuXFxuXFx0XFx0XFx0aWYgKCBwID09PSBBZGRFcXVhdGlvbiApIHJldHVybiBnbC5GVU5DX0FERDtcXG5cXHRcXHRcXHRpZiAoIHAgPT09IFN1YnRyYWN0RXF1YXRpb24gKSByZXR1cm4gZ2wuRlVOQ19TVUJUUkFDVDtcXG5cXHRcXHRcXHRpZiAoIHAgPT09IFJldmVyc2VTdWJ0cmFjdEVxdWF0aW9uICkgcmV0dXJuIGdsLkZVTkNfUkVWRVJTRV9TVUJUUkFDVDtcXG5cXG5cXHRcXHRcXHRpZiAoIHAgPT09IFplcm9GYWN0b3IgKSByZXR1cm4gZ2wuWkVSTztcXG5cXHRcXHRcXHRpZiAoIHAgPT09IE9uZUZhY3RvciApIHJldHVybiBnbC5PTkU7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBTcmNDb2xvckZhY3RvciApIHJldHVybiBnbC5TUkNfQ09MT1I7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBPbmVNaW51c1NyY0NvbG9yRmFjdG9yICkgcmV0dXJuIGdsLk9ORV9NSU5VU19TUkNfQ09MT1I7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBTcmNBbHBoYUZhY3RvciApIHJldHVybiBnbC5TUkNfQUxQSEE7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBPbmVNaW51c1NyY0FscGhhRmFjdG9yICkgcmV0dXJuIGdsLk9ORV9NSU5VU19TUkNfQUxQSEE7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBEc3RBbHBoYUZhY3RvciApIHJldHVybiBnbC5EU1RfQUxQSEE7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBPbmVNaW51c0RzdEFscGhhRmFjdG9yICkgcmV0dXJuIGdsLk9ORV9NSU5VU19EU1RfQUxQSEE7XFxuXFxuXFx0XFx0XFx0aWYgKCBwID09PSBEc3RDb2xvckZhY3RvciApIHJldHVybiBnbC5EU1RfQ09MT1I7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBPbmVNaW51c0RzdENvbG9yRmFjdG9yICkgcmV0dXJuIGdsLk9ORV9NSU5VU19EU1RfQ09MT1I7XFxuXFx0XFx0XFx0aWYgKCBwID09PSBTcmNBbHBoYVNhdHVyYXRlRmFjdG9yICkgcmV0dXJuIGdsLlNSQ19BTFBIQV9TQVRVUkFURTtcXG5cXG5cXHRcXHRcXHRpZiAoIHAgPT09IFJHQl9TM1RDX0RYVDFfRm9ybWF0IHx8IHAgPT09IFJHQkFfUzNUQ19EWFQxX0Zvcm1hdCB8fFxcblxcdFxcdFxcdFxcdHAgPT09IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCB8fCBwID09PSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfczN0YycgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHAgPT09IFJHQl9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9TM1RDX0RYVDFfRVhUO1xcblxcdFxcdFxcdFxcdFxcdGlmICggcCA9PT0gUkdCQV9TM1RDX0RYVDFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUzNUQ19EWFQxX0VYVDtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHAgPT09IFJHQkFfUzNUQ19EWFQzX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1MzVENfRFhUM19FWFQ7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwID09PSBSR0JBX1MzVENfRFhUNV9Gb3JtYXQgKSByZXR1cm4gZXh0ZW5zaW9uLkNPTVBSRVNTRURfUkdCQV9TM1RDX0RYVDVfRVhUO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBwID09PSBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCB8fCBwID09PSBSR0JfUFZSVENfMkJQUFYxX0Zvcm1hdCB8fFxcblxcdFxcdFxcdFxcdHAgPT09IFJHQkFfUFZSVENfNEJQUFYxX0Zvcm1hdCB8fCBwID09PSBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZXh0ZW5zaW9uID0gZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBwID09PSBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JfUFZSVENfNEJQUFYxX0lNRztcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHAgPT09IFJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9QVlJUQ18yQlBQVjFfSU1HO1xcblxcdFxcdFxcdFxcdFxcdGlmICggcCA9PT0gUkdCQV9QVlJUQ180QlBQVjFfRm9ybWF0ICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQkFfUFZSVENfNEJQUFYxX0lNRztcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHAgPT09IFJHQkFfUFZSVENfMkJQUFYxX0Zvcm1hdCApIHJldHVybiBleHRlbnNpb24uQ09NUFJFU1NFRF9SR0JBX1BWUlRDXzJCUFBWMV9JTUc7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHAgPT09IFJHQl9FVEMxX0Zvcm1hdCApIHtcXG5cXG5cXHRcXHRcXHRcXHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9ldGMxJyApO1xcblxcblxcdFxcdFxcdFxcdGlmICggZXh0ZW5zaW9uICE9PSBudWxsICkgcmV0dXJuIGV4dGVuc2lvbi5DT01QUkVTU0VEX1JHQl9FVEMxX1dFQkdMO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHAgPT09IE1pbkVxdWF0aW9uIHx8IHAgPT09IE1heEVxdWF0aW9uICkge1xcblxcblxcdFxcdFxcdFxcdGV4dGVuc2lvbiA9IGV4dGVuc2lvbnMuZ2V0KCAnRVhUX2JsZW5kX21pbm1heCcgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGV4dGVuc2lvbiAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHAgPT09IE1pbkVxdWF0aW9uICkgcmV0dXJuIGV4dGVuc2lvbi5NSU5fRVhUO1xcblxcdFxcdFxcdFxcdFxcdGlmICggcCA9PT0gTWF4RXF1YXRpb24gKSByZXR1cm4gZXh0ZW5zaW9uLk1BWF9FWFQ7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHAgPT09IFVuc2lnbmVkSW50MjQ4VHlwZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2RlcHRoX3RleHR1cmUnICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBleHRlbnNpb24gIT09IG51bGwgKSByZXR1cm4gZXh0ZW5zaW9uLlVOU0lHTkVEX0lOVF8yNF84X1dFQkdMO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gMDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHsgY29udmVydDogY29udmVydCB9O1xcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIHN1cGVyZWdnYmVydCAvIGh0dHA6Ly93d3cucGF1bGJydW50LmNvLnVrL1xcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKiBAYXV0aG9yIHN6aW1layAvIGh0dHBzOi8vZ2l0aHViLmNvbS9zemltZWsvXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFdlYkdMUmVuZGVyZXIoIHBhcmFtZXRlcnMgKSB7XFxuXFxuXFx0XFx0Y29uc29sZS5sb2coICdUSFJFRS5XZWJHTFJlbmRlcmVyJywgUkVWSVNJT04gKTtcXG5cXG5cXHRcXHRwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcXG5cXG5cXHRcXHR2YXIgX2NhbnZhcyA9IHBhcmFtZXRlcnMuY2FudmFzICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmNhbnZhcyA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLCAnY2FudmFzJyApLFxcblxcdFxcdFxcdF9jb250ZXh0ID0gcGFyYW1ldGVycy5jb250ZXh0ICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmNvbnRleHQgOiBudWxsLFxcblxcblxcdFxcdFxcdF9hbHBoYSA9IHBhcmFtZXRlcnMuYWxwaGEgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYWxwaGEgOiBmYWxzZSxcXG5cXHRcXHRcXHRfZGVwdGggPSBwYXJhbWV0ZXJzLmRlcHRoICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLmRlcHRoIDogdHJ1ZSxcXG5cXHRcXHRcXHRfc3RlbmNpbCA9IHBhcmFtZXRlcnMuc3RlbmNpbCAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5zdGVuY2lsIDogdHJ1ZSxcXG5cXHRcXHRcXHRfYW50aWFsaWFzID0gcGFyYW1ldGVycy5hbnRpYWxpYXMgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuYW50aWFsaWFzIDogZmFsc2UsXFxuXFx0XFx0XFx0X3ByZW11bHRpcGxpZWRBbHBoYSA9IHBhcmFtZXRlcnMucHJlbXVsdGlwbGllZEFscGhhICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZW11bHRpcGxpZWRBbHBoYSA6IHRydWUsXFxuXFx0XFx0XFx0X3ByZXNlcnZlRHJhd2luZ0J1ZmZlciA9IHBhcmFtZXRlcnMucHJlc2VydmVEcmF3aW5nQnVmZmVyICE9PSB1bmRlZmluZWQgPyBwYXJhbWV0ZXJzLnByZXNlcnZlRHJhd2luZ0J1ZmZlciA6IGZhbHNlLFxcblxcdFxcdFxcdF9wb3dlclByZWZlcmVuY2UgPSBwYXJhbWV0ZXJzLnBvd2VyUHJlZmVyZW5jZSAhPT0gdW5kZWZpbmVkID8gcGFyYW1ldGVycy5wb3dlclByZWZlcmVuY2UgOiAnZGVmYXVsdCc7XFxuXFxuXFx0XFx0dmFyIGxpZ2h0c0FycmF5ID0gW107XFxuXFx0XFx0dmFyIHNoYWRvd3NBcnJheSA9IFtdO1xcblxcblxcdFxcdHZhciBjdXJyZW50UmVuZGVyTGlzdCA9IG51bGw7XFxuXFxuXFx0XFx0dmFyIHNwcml0ZXNBcnJheSA9IFtdO1xcblxcdFxcdHZhciBmbGFyZXNBcnJheSA9IFtdO1xcblxcblxcdFxcdC8vIHB1YmxpYyBwcm9wZXJ0aWVzXFxuXFxuXFx0XFx0dGhpcy5kb21FbGVtZW50ID0gX2NhbnZhcztcXG5cXHRcXHR0aGlzLmNvbnRleHQgPSBudWxsO1xcblxcblxcdFxcdC8vIGNsZWFyaW5nXFxuXFxuXFx0XFx0dGhpcy5hdXRvQ2xlYXIgPSB0cnVlO1xcblxcdFxcdHRoaXMuYXV0b0NsZWFyQ29sb3IgPSB0cnVlO1xcblxcdFxcdHRoaXMuYXV0b0NsZWFyRGVwdGggPSB0cnVlO1xcblxcdFxcdHRoaXMuYXV0b0NsZWFyU3RlbmNpbCA9IHRydWU7XFxuXFxuXFx0XFx0Ly8gc2NlbmUgZ3JhcGhcXG5cXG5cXHRcXHR0aGlzLnNvcnRPYmplY3RzID0gdHJ1ZTtcXG5cXG5cXHRcXHQvLyB1c2VyLWRlZmluZWQgY2xpcHBpbmdcXG5cXG5cXHRcXHR0aGlzLmNsaXBwaW5nUGxhbmVzID0gW107XFxuXFx0XFx0dGhpcy5sb2NhbENsaXBwaW5nRW5hYmxlZCA9IGZhbHNlO1xcblxcblxcdFxcdC8vIHBoeXNpY2FsbHkgYmFzZWQgc2hhZGluZ1xcblxcblxcdFxcdHRoaXMuZ2FtbWFGYWN0b3IgPSAyLjA7XFx0Ly8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XFxuXFx0XFx0dGhpcy5nYW1tYUlucHV0ID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5nYW1tYU91dHB1dCA9IGZhbHNlO1xcblxcblxcdFxcdC8vIHBoeXNpY2FsIGxpZ2h0c1xcblxcblxcdFxcdHRoaXMucGh5c2ljYWxseUNvcnJlY3RMaWdodHMgPSBmYWxzZTtcXG5cXG5cXHRcXHQvLyB0b25lIG1hcHBpbmdcXG5cXG5cXHRcXHR0aGlzLnRvbmVNYXBwaW5nID0gTGluZWFyVG9uZU1hcHBpbmc7XFxuXFx0XFx0dGhpcy50b25lTWFwcGluZ0V4cG9zdXJlID0gMS4wO1xcblxcdFxcdHRoaXMudG9uZU1hcHBpbmdXaGl0ZVBvaW50ID0gMS4wO1xcblxcblxcdFxcdC8vIG1vcnBoc1xcblxcblxcdFxcdHRoaXMubWF4TW9ycGhUYXJnZXRzID0gODtcXG5cXHRcXHR0aGlzLm1heE1vcnBoTm9ybWFscyA9IDQ7XFxuXFxuXFx0XFx0Ly8gaW50ZXJuYWwgcHJvcGVydGllc1xcblxcblxcdFxcdHZhciBfdGhpcyA9IHRoaXMsXFxuXFxuXFx0XFx0XFx0X2lzQ29udGV4dExvc3QgPSBmYWxzZSxcXG5cXG5cXHRcXHRcXHQvLyBpbnRlcm5hbCBzdGF0ZSBjYWNoZVxcblxcblxcdFxcdFxcdF9jdXJyZW50UmVuZGVyVGFyZ2V0ID0gbnVsbCxcXG5cXHRcXHRcXHRfY3VycmVudEZyYW1lYnVmZmVyID0gbnVsbCxcXG5cXHRcXHRcXHRfY3VycmVudE1hdGVyaWFsSWQgPSAtIDEsXFxuXFx0XFx0XFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSAnJyxcXG5cXG5cXHRcXHRcXHRfY3VycmVudENhbWVyYSA9IG51bGwsXFxuXFx0XFx0XFx0X2N1cnJlbnRBcnJheUNhbWVyYSA9IG51bGwsXFxuXFxuXFx0XFx0XFx0X2N1cnJlbnRWaWV3cG9ydCA9IG5ldyBWZWN0b3I0KCksXFxuXFx0XFx0XFx0X2N1cnJlbnRTY2lzc29yID0gbmV3IFZlY3RvcjQoKSxcXG5cXHRcXHRcXHRfY3VycmVudFNjaXNzb3JUZXN0ID0gbnVsbCxcXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdF91c2VkVGV4dHVyZVVuaXRzID0gMCxcXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdF93aWR0aCA9IF9jYW52YXMud2lkdGgsXFxuXFx0XFx0XFx0X2hlaWdodCA9IF9jYW52YXMuaGVpZ2h0LFxcblxcblxcdFxcdFxcdF9waXhlbFJhdGlvID0gMSxcXG5cXG5cXHRcXHRcXHRfdmlld3BvcnQgPSBuZXcgVmVjdG9yNCggMCwgMCwgX3dpZHRoLCBfaGVpZ2h0ICksXFxuXFx0XFx0XFx0X3NjaXNzb3IgPSBuZXcgVmVjdG9yNCggMCwgMCwgX3dpZHRoLCBfaGVpZ2h0ICksXFxuXFx0XFx0XFx0X3NjaXNzb3JUZXN0ID0gZmFsc2UsXFxuXFxuXFx0XFx0XFx0Ly8gZnJ1c3R1bVxcblxcblxcdFxcdFxcdF9mcnVzdHVtID0gbmV3IEZydXN0dW0oKSxcXG5cXG5cXHRcXHRcXHQvLyBjbGlwcGluZ1xcblxcblxcdFxcdFxcdF9jbGlwcGluZyA9IG5ldyBXZWJHTENsaXBwaW5nKCksXFxuXFx0XFx0XFx0X2NsaXBwaW5nRW5hYmxlZCA9IGZhbHNlLFxcblxcdFxcdFxcdF9sb2NhbENsaXBwaW5nRW5hYmxlZCA9IGZhbHNlLFxcblxcblxcdFxcdFxcdC8vIGNhbWVyYSBtYXRyaWNlcyBjYWNoZVxcblxcblxcdFxcdFxcdF9wcm9qU2NyZWVuTWF0cml4ID0gbmV3IE1hdHJpeDQoKSxcXG5cXG5cXHRcXHRcXHRfdmVjdG9yMyA9IG5ldyBWZWN0b3IzKCksXFxuXFxuXFx0XFx0XFx0Ly8gaW5mb1xcblxcblxcdFxcdFxcdF9pbmZvTWVtb3J5ID0ge1xcblxcdFxcdFxcdFxcdGdlb21ldHJpZXM6IDAsXFxuXFx0XFx0XFx0XFx0dGV4dHVyZXM6IDBcXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdF9pbmZvUmVuZGVyID0ge1xcblxcblxcdFxcdFxcdFxcdGZyYW1lOiAwLFxcblxcdFxcdFxcdFxcdGNhbGxzOiAwLFxcblxcdFxcdFxcdFxcdHZlcnRpY2VzOiAwLFxcblxcdFxcdFxcdFxcdGZhY2VzOiAwLFxcblxcdFxcdFxcdFxcdHBvaW50czogMFxcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5pbmZvID0ge1xcblxcblxcdFxcdFxcdHJlbmRlcjogX2luZm9SZW5kZXIsXFxuXFx0XFx0XFx0bWVtb3J5OiBfaW5mb01lbW9yeSxcXG5cXHRcXHRcXHRwcm9ncmFtczogbnVsbFxcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZ2V0VGFyZ2V0UGl4ZWxSYXRpbygpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gX2N1cnJlbnRSZW5kZXJUYXJnZXQgPT09IG51bGwgPyBfcGl4ZWxSYXRpbyA6IDE7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGluaXRpYWxpemVcXG5cXG5cXHRcXHR2YXIgX2dsO1xcblxcblxcdFxcdHRyeSB7XFxuXFxuXFx0XFx0XFx0dmFyIGNvbnRleHRBdHRyaWJ1dGVzID0ge1xcblxcdFxcdFxcdFxcdGFscGhhOiBfYWxwaGEsXFxuXFx0XFx0XFx0XFx0ZGVwdGg6IF9kZXB0aCxcXG5cXHRcXHRcXHRcXHRzdGVuY2lsOiBfc3RlbmNpbCxcXG5cXHRcXHRcXHRcXHRhbnRpYWxpYXM6IF9hbnRpYWxpYXMsXFxuXFx0XFx0XFx0XFx0cHJlbXVsdGlwbGllZEFscGhhOiBfcHJlbXVsdGlwbGllZEFscGhhLFxcblxcdFxcdFxcdFxcdHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogX3ByZXNlcnZlRHJhd2luZ0J1ZmZlcixcXG5cXHRcXHRcXHRcXHRwb3dlclByZWZlcmVuY2U6IF9wb3dlclByZWZlcmVuY2VcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdC8vIGV2ZW50IGxpc3RlbmVycyBtdXN0IGJlIHJlZ2lzdGVyZWQgYmVmb3JlIFdlYkdMIGNvbnRleHQgaXMgY3JlYXRlZCwgc2VlICMxMjc1M1xcblxcblxcdFxcdFxcdF9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dGxvc3QnLCBvbkNvbnRleHRMb3N0LCBmYWxzZSApO1xcblxcdFxcdFxcdF9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lciggJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgb25Db250ZXh0UmVzdG9yZSwgZmFsc2UgKTtcXG5cXG5cXHRcXHRcXHRfZ2wgPSBfY29udGV4dCB8fCBfY2FudmFzLmdldENvbnRleHQoICd3ZWJnbCcsIGNvbnRleHRBdHRyaWJ1dGVzICkgfHwgX2NhbnZhcy5nZXRDb250ZXh0KCAnZXhwZXJpbWVudGFsLXdlYmdsJywgY29udGV4dEF0dHJpYnV0ZXMgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIF9nbCA9PT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIF9jYW52YXMuZ2V0Q29udGV4dCggJ3dlYmdsJyApICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggJ0Vycm9yIGNyZWF0aW5nIFdlYkdMIGNvbnRleHQgd2l0aCB5b3VyIHNlbGVjdGVkIGF0dHJpYnV0ZXMuJyApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCAnRXJyb3IgY3JlYXRpbmcgV2ViR0wgY29udGV4dC4nICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBTb21lIGV4cGVyaW1lbnRhbC13ZWJnbCBpbXBsZW1lbnRhdGlvbnMgZG8gbm90IGhhdmUgZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0XFxuXFxuXFx0XFx0XFx0aWYgKCBfZ2wuZ2V0U2hhZGVyUHJlY2lzaW9uRm9ybWF0ID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0X2dsLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdCA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4geyAncmFuZ2VNaW4nOiAxLCAncmFuZ2VNYXgnOiAxLCAncHJlY2lzaW9uJzogMSB9O1xcblxcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0gY2F0Y2ggKCBlcnJvciApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogJyArIGVycm9yLm1lc3NhZ2UgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIGV4dGVuc2lvbnMsIGNhcGFiaWxpdGllcywgc3RhdGU7XFxuXFx0XFx0dmFyIHByb3BlcnRpZXMsIHRleHR1cmVzLCBhdHRyaWJ1dGVzLCBnZW9tZXRyaWVzLCBvYmplY3RzLCBsaWdodHM7XFxuXFx0XFx0dmFyIHByb2dyYW1DYWNoZSwgcmVuZGVyTGlzdHM7XFxuXFxuXFx0XFx0dmFyIGJhY2tncm91bmQsIG1vcnBodGFyZ2V0cywgYnVmZmVyUmVuZGVyZXIsIGluZGV4ZWRCdWZmZXJSZW5kZXJlcjtcXG5cXHRcXHR2YXIgZmxhcmVSZW5kZXJlciwgc3ByaXRlUmVuZGVyZXI7XFxuXFxuXFx0XFx0dmFyIHV0aWxzO1xcblxcblxcdFxcdGZ1bmN0aW9uIGluaXRHTENvbnRleHQoKSB7XFxuXFxuXFx0XFx0XFx0ZXh0ZW5zaW9ucyA9IG5ldyBXZWJHTEV4dGVuc2lvbnMoIF9nbCApO1xcblxcdFxcdFxcdGV4dGVuc2lvbnMuZ2V0KCAnV0VCR0xfZGVwdGhfdGV4dHVyZScgKTtcXG5cXHRcXHRcXHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xcblxcdFxcdFxcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJyApO1xcblxcdFxcdFxcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfaGFsZl9mbG9hdCcgKTtcXG5cXHRcXHRcXHRleHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2hhbGZfZmxvYXRfbGluZWFyJyApO1xcblxcdFxcdFxcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzJyApO1xcblxcdFxcdFxcdGV4dGVuc2lvbnMuZ2V0KCAnT0VTX2VsZW1lbnRfaW5kZXhfdWludCcgKTtcXG5cXHRcXHRcXHRleHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XFxuXFxuXFx0XFx0XFx0dXRpbHMgPSBuZXcgV2ViR0xVdGlscyggX2dsLCBleHRlbnNpb25zICk7XFxuXFxuXFx0XFx0XFx0Y2FwYWJpbGl0aWVzID0gbmV3IFdlYkdMQ2FwYWJpbGl0aWVzKCBfZ2wsIGV4dGVuc2lvbnMsIHBhcmFtZXRlcnMgKTtcXG5cXG5cXHRcXHRcXHRzdGF0ZSA9IG5ldyBXZWJHTFN0YXRlKCBfZ2wsIGV4dGVuc2lvbnMsIHV0aWxzICk7XFxuXFx0XFx0XFx0c3RhdGUuc2Npc3NvciggX2N1cnJlbnRTY2lzc29yLmNvcHkoIF9zY2lzc29yICkubXVsdGlwbHlTY2FsYXIoIF9waXhlbFJhdGlvICkgKTtcXG5cXHRcXHRcXHRzdGF0ZS52aWV3cG9ydCggX2N1cnJlbnRWaWV3cG9ydC5jb3B5KCBfdmlld3BvcnQgKS5tdWx0aXBseVNjYWxhciggX3BpeGVsUmF0aW8gKSApO1xcblxcblxcdFxcdFxcdHByb3BlcnRpZXMgPSBuZXcgV2ViR0xQcm9wZXJ0aWVzKCk7XFxuXFx0XFx0XFx0dGV4dHVyZXMgPSBuZXcgV2ViR0xUZXh0dXJlcyggX2dsLCBleHRlbnNpb25zLCBzdGF0ZSwgcHJvcGVydGllcywgY2FwYWJpbGl0aWVzLCB1dGlscywgX2luZm9NZW1vcnkgKTtcXG5cXHRcXHRcXHRhdHRyaWJ1dGVzID0gbmV3IFdlYkdMQXR0cmlidXRlcyggX2dsICk7XFxuXFx0XFx0XFx0Z2VvbWV0cmllcyA9IG5ldyBXZWJHTEdlb21ldHJpZXMoIF9nbCwgYXR0cmlidXRlcywgX2luZm9NZW1vcnkgKTtcXG5cXHRcXHRcXHRvYmplY3RzID0gbmV3IFdlYkdMT2JqZWN0cyggZ2VvbWV0cmllcywgX2luZm9SZW5kZXIgKTtcXG5cXHRcXHRcXHRtb3JwaHRhcmdldHMgPSBuZXcgV2ViR0xNb3JwaHRhcmdldHMoIF9nbCApO1xcblxcdFxcdFxcdHByb2dyYW1DYWNoZSA9IG5ldyBXZWJHTFByb2dyYW1zKCBfdGhpcywgZXh0ZW5zaW9ucywgY2FwYWJpbGl0aWVzICk7XFxuXFx0XFx0XFx0bGlnaHRzID0gbmV3IFdlYkdMTGlnaHRzKCk7XFxuXFx0XFx0XFx0cmVuZGVyTGlzdHMgPSBuZXcgV2ViR0xSZW5kZXJMaXN0cygpO1xcblxcblxcdFxcdFxcdGJhY2tncm91bmQgPSBuZXcgV2ViR0xCYWNrZ3JvdW5kKCBfdGhpcywgc3RhdGUsIGdlb21ldHJpZXMsIF9wcmVtdWx0aXBsaWVkQWxwaGEgKTtcXG5cXG5cXHRcXHRcXHRidWZmZXJSZW5kZXJlciA9IG5ldyBXZWJHTEJ1ZmZlclJlbmRlcmVyKCBfZ2wsIGV4dGVuc2lvbnMsIF9pbmZvUmVuZGVyICk7XFxuXFx0XFx0XFx0aW5kZXhlZEJ1ZmZlclJlbmRlcmVyID0gbmV3IFdlYkdMSW5kZXhlZEJ1ZmZlclJlbmRlcmVyKCBfZ2wsIGV4dGVuc2lvbnMsIF9pbmZvUmVuZGVyICk7XFxuXFxuXFx0XFx0XFx0ZmxhcmVSZW5kZXJlciA9IG5ldyBXZWJHTEZsYXJlUmVuZGVyZXIoIF90aGlzLCBfZ2wsIHN0YXRlLCB0ZXh0dXJlcywgY2FwYWJpbGl0aWVzICk7XFxuXFx0XFx0XFx0c3ByaXRlUmVuZGVyZXIgPSBuZXcgV2ViR0xTcHJpdGVSZW5kZXJlciggX3RoaXMsIF9nbCwgc3RhdGUsIHRleHR1cmVzLCBjYXBhYmlsaXRpZXMgKTtcXG5cXG5cXHRcXHRcXHRfdGhpcy5pbmZvLnByb2dyYW1zID0gcHJvZ3JhbUNhY2hlLnByb2dyYW1zO1xcblxcblxcdFxcdFxcdF90aGlzLmNvbnRleHQgPSBfZ2w7XFxuXFx0XFx0XFx0X3RoaXMuY2FwYWJpbGl0aWVzID0gY2FwYWJpbGl0aWVzO1xcblxcdFxcdFxcdF90aGlzLmV4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xcblxcdFxcdFxcdF90aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzO1xcblxcdFxcdFxcdF90aGlzLnJlbmRlckxpc3RzID0gcmVuZGVyTGlzdHM7XFxuXFx0XFx0XFx0X3RoaXMuc3RhdGUgPSBzdGF0ZTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aW5pdEdMQ29udGV4dCgpO1xcblxcblxcdFxcdC8vIHZyXFxuXFxuXFx0XFx0dmFyIHZyID0gbmV3IFdlYlZSTWFuYWdlciggX3RoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnZyID0gdnI7XFxuXFxuXFx0XFx0Ly8gc2hhZG93IG1hcFxcblxcblxcdFxcdHZhciBzaGFkb3dNYXAgPSBuZXcgV2ViR0xTaGFkb3dNYXAoIF90aGlzLCBvYmplY3RzLCBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZVNpemUgKTtcXG5cXG5cXHRcXHR0aGlzLnNoYWRvd01hcCA9IHNoYWRvd01hcDtcXG5cXG5cXHRcXHQvLyBBUElcXG5cXG5cXHRcXHR0aGlzLmdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIF9nbDtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZ2V0Q29udGV4dEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIF9nbC5nZXRDb250ZXh0QXR0cmlidXRlcygpO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5mb3JjZUNvbnRleHRMb3NzID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2xvc2VfY29udGV4dCcgKTtcXG5cXHRcXHRcXHRpZiAoIGV4dGVuc2lvbiApIGV4dGVuc2lvbi5sb3NlQ29udGV4dCgpO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5mb3JjZUNvbnRleHRSZXN0b3JlID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBleHRlbnNpb24gPSBleHRlbnNpb25zLmdldCggJ1dFQkdMX2xvc2VfY29udGV4dCcgKTtcXG5cXHRcXHRcXHRpZiAoIGV4dGVuc2lvbiApIGV4dGVuc2lvbi5yZXN0b3JlQ29udGV4dCgpO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5nZXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBfcGl4ZWxSYXRpbztcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuc2V0UGl4ZWxSYXRpbyA9IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdF9waXhlbFJhdGlvID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0dGhpcy5zZXRTaXplKCBfd2lkdGgsIF9oZWlnaHQsIGZhbHNlICk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLmdldFNpemUgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHR3aWR0aDogX3dpZHRoLFxcblxcdFxcdFxcdFxcdGhlaWdodDogX2hlaWdodFxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLnNldFNpemUgPSBmdW5jdGlvbiAoIHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlICkge1xcblxcblxcdFxcdFxcdHZhciBkZXZpY2UgPSB2ci5nZXREZXZpY2UoKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGRldmljZSAmJiBkZXZpY2UuaXNQcmVzZW50aW5nICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IENhblxcXFwndCBjaGFuZ2Ugc2l6ZSB3aGlsZSBWUiBkZXZpY2UgaXMgcHJlc2VudGluZy4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRfd2lkdGggPSB3aWR0aDtcXG5cXHRcXHRcXHRfaGVpZ2h0ID0gaGVpZ2h0O1xcblxcblxcdFxcdFxcdF9jYW52YXMud2lkdGggPSB3aWR0aCAqIF9waXhlbFJhdGlvO1xcblxcdFxcdFxcdF9jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogX3BpeGVsUmF0aW87XFxuXFxuXFx0XFx0XFx0aWYgKCB1cGRhdGVTdHlsZSAhPT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0X2NhbnZhcy5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcXG5cXHRcXHRcXHRcXHRfY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuc2V0Vmlld3BvcnQoIDAsIDAsIHdpZHRoLCBoZWlnaHQgKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZ2V0RHJhd2luZ0J1ZmZlclNpemUgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHR3aWR0aDogX3dpZHRoICogX3BpeGVsUmF0aW8sXFxuXFx0XFx0XFx0XFx0aGVpZ2h0OiBfaGVpZ2h0ICogX3BpeGVsUmF0aW9cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5zZXREcmF3aW5nQnVmZmVyU2l6ZSA9IGZ1bmN0aW9uICggd2lkdGgsIGhlaWdodCwgcGl4ZWxSYXRpbyApIHtcXG5cXG5cXHRcXHRcXHRfd2lkdGggPSB3aWR0aDtcXG5cXHRcXHRcXHRfaGVpZ2h0ID0gaGVpZ2h0O1xcblxcblxcdFxcdFxcdF9waXhlbFJhdGlvID0gcGl4ZWxSYXRpbztcXG5cXG5cXHRcXHRcXHRfY2FudmFzLndpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xcblxcdFxcdFxcdF9jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcXG5cXG5cXHRcXHRcXHR0aGlzLnNldFZpZXdwb3J0KCAwLCAwLCB3aWR0aCwgaGVpZ2h0ICk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLnNldFZpZXdwb3J0ID0gZnVuY3Rpb24gKCB4LCB5LCB3aWR0aCwgaGVpZ2h0ICkge1xcblxcblxcdFxcdFxcdF92aWV3cG9ydC5zZXQoIHgsIF9oZWlnaHQgLSB5IC0gaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0ICk7XFxuXFx0XFx0XFx0c3RhdGUudmlld3BvcnQoIF9jdXJyZW50Vmlld3BvcnQuY29weSggX3ZpZXdwb3J0ICkubXVsdGlwbHlTY2FsYXIoIF9waXhlbFJhdGlvICkgKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuc2V0U2Npc3NvciA9IGZ1bmN0aW9uICggeCwgeSwgd2lkdGgsIGhlaWdodCApIHtcXG5cXG5cXHRcXHRcXHRfc2Npc3Nvci5zZXQoIHgsIF9oZWlnaHQgLSB5IC0gaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0ICk7XFxuXFx0XFx0XFx0c3RhdGUuc2Npc3NvciggX2N1cnJlbnRTY2lzc29yLmNvcHkoIF9zY2lzc29yICkubXVsdGlwbHlTY2FsYXIoIF9waXhlbFJhdGlvICkgKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuc2V0U2Npc3NvclRlc3QgPSBmdW5jdGlvbiAoIGJvb2xlYW4gKSB7XFxuXFxuXFx0XFx0XFx0c3RhdGUuc2V0U2Npc3NvclRlc3QoIF9zY2lzc29yVGVzdCA9IGJvb2xlYW4gKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIENsZWFyaW5nXFxuXFxuXFx0XFx0dGhpcy5nZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBiYWNrZ3JvdW5kLmdldENsZWFyQ29sb3IoKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuc2V0Q2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRiYWNrZ3JvdW5kLnNldENsZWFyQ29sb3IuYXBwbHkoIGJhY2tncm91bmQsIGFyZ3VtZW50cyApO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5nZXRDbGVhckFscGhhID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBiYWNrZ3JvdW5kLmdldENsZWFyQWxwaGEoKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuc2V0Q2xlYXJBbHBoYSA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRiYWNrZ3JvdW5kLnNldENsZWFyQWxwaGEuYXBwbHkoIGJhY2tncm91bmQsIGFyZ3VtZW50cyApO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5jbGVhciA9IGZ1bmN0aW9uICggY29sb3IsIGRlcHRoLCBzdGVuY2lsICkge1xcblxcblxcdFxcdFxcdHZhciBiaXRzID0gMDtcXG5cXG5cXHRcXHRcXHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgfHwgY29sb3IgKSBiaXRzIHw9IF9nbC5DT0xPUl9CVUZGRVJfQklUO1xcblxcdFxcdFxcdGlmICggZGVwdGggPT09IHVuZGVmaW5lZCB8fCBkZXB0aCApIGJpdHMgfD0gX2dsLkRFUFRIX0JVRkZFUl9CSVQ7XFxuXFx0XFx0XFx0aWYgKCBzdGVuY2lsID09PSB1bmRlZmluZWQgfHwgc3RlbmNpbCApIGJpdHMgfD0gX2dsLlNURU5DSUxfQlVGRkVSX0JJVDtcXG5cXG5cXHRcXHRcXHRfZ2wuY2xlYXIoIGJpdHMgKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuY2xlYXJDb2xvciA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmNsZWFyKCB0cnVlLCBmYWxzZSwgZmFsc2UgKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuY2xlYXJEZXB0aCA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmNsZWFyKCBmYWxzZSwgdHJ1ZSwgZmFsc2UgKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuY2xlYXJTdGVuY2lsID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMuY2xlYXIoIGZhbHNlLCBmYWxzZSwgdHJ1ZSApO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5jbGVhclRhcmdldCA9IGZ1bmN0aW9uICggcmVuZGVyVGFyZ2V0LCBjb2xvciwgZGVwdGgsIHN0ZW5jaWwgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xcblxcdFxcdFxcdHRoaXMuY2xlYXIoIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly9cXG5cXG5cXHRcXHR0aGlzLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0X2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0bG9zdCcsIG9uQ29udGV4dExvc3QsIGZhbHNlICk7XFxuXFx0XFx0XFx0X2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCAnd2ViZ2xjb250ZXh0cmVzdG9yZWQnLCBvbkNvbnRleHRSZXN0b3JlLCBmYWxzZSApO1xcblxcblxcdFxcdFxcdHJlbmRlckxpc3RzLmRpc3Bvc2UoKTtcXG5cXG5cXHRcXHRcXHR2ci5kaXNwb3NlKCk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBFdmVudHNcXG5cXG5cXHRcXHRmdW5jdGlvbiBvbkNvbnRleHRMb3N0KCBldmVudCApIHtcXG5cXG5cXHRcXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcblxcdFxcdFxcdGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBMb3N0LicgKTtcXG5cXG5cXHRcXHRcXHRfaXNDb250ZXh0TG9zdCA9IHRydWU7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIG9uQ29udGV4dFJlc3RvcmUoIC8qIGV2ZW50ICovICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUubG9nKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogQ29udGV4dCBSZXN0b3JlZC4nICk7XFxuXFxuXFx0XFx0XFx0X2lzQ29udGV4dExvc3QgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRpbml0R0xDb250ZXh0KCk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIG9uTWF0ZXJpYWxEaXNwb3NlKCBldmVudCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgbWF0ZXJpYWwgPSBldmVudC50YXJnZXQ7XFxuXFxuXFx0XFx0XFx0bWF0ZXJpYWwucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xcblxcblxcdFxcdFxcdGRlYWxsb2NhdGVNYXRlcmlhbCggbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQnVmZmVyIGRlYWxsb2NhdGlvblxcblxcblxcdFxcdGZ1bmN0aW9uIGRlYWxsb2NhdGVNYXRlcmlhbCggbWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0cmVsZWFzZU1hdGVyaWFsUHJvZ3JhbVJlZmVyZW5jZSggbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHRwcm9wZXJ0aWVzLnJlbW92ZSggbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVsZWFzZU1hdGVyaWFsUHJvZ3JhbVJlZmVyZW5jZSggbWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHByb2dyYW1JbmZvID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICkucHJvZ3JhbTtcXG5cXG5cXHRcXHRcXHRtYXRlcmlhbC5wcm9ncmFtID0gdW5kZWZpbmVkO1xcblxcblxcdFxcdFxcdGlmICggcHJvZ3JhbUluZm8gIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRwcm9ncmFtQ2FjaGUucmVsZWFzZVByb2dyYW0oIHByb2dyYW1JbmZvICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBCdWZmZXIgcmVuZGVyaW5nXFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVuZGVyT2JqZWN0SW1tZWRpYXRlKCBvYmplY3QsIHByb2dyYW0sIG1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdG9iamVjdC5yZW5kZXIoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xcblxcblxcdFxcdFxcdFxcdF90aGlzLnJlbmRlckJ1ZmZlckltbWVkaWF0ZSggb2JqZWN0LCBwcm9ncmFtLCBtYXRlcmlhbCApO1xcblxcblxcdFxcdFxcdH0gKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5yZW5kZXJCdWZmZXJJbW1lZGlhdGUgPSBmdW5jdGlvbiAoIG9iamVjdCwgcHJvZ3JhbSwgbWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0c3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcXG5cXG5cXHRcXHRcXHR2YXIgYnVmZmVycyA9IHByb3BlcnRpZXMuZ2V0KCBvYmplY3QgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgJiYgISBidWZmZXJzLnBvc2l0aW9uICkgYnVmZmVycy5wb3NpdGlvbiA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcXG5cXHRcXHRcXHRpZiAoIG9iamVjdC5oYXNOb3JtYWxzICYmICEgYnVmZmVycy5ub3JtYWwgKSBidWZmZXJzLm5vcm1hbCA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcXG5cXHRcXHRcXHRpZiAoIG9iamVjdC5oYXNVdnMgJiYgISBidWZmZXJzLnV2ICkgYnVmZmVycy51diA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcXG5cXHRcXHRcXHRpZiAoIG9iamVjdC5oYXNDb2xvcnMgJiYgISBidWZmZXJzLmNvbG9yICkgYnVmZmVycy5jb2xvciA9IF9nbC5jcmVhdGVCdWZmZXIoKTtcXG5cXG5cXHRcXHRcXHR2YXIgcHJvZ3JhbUF0dHJpYnV0ZXMgPSBwcm9ncmFtLmdldEF0dHJpYnV0ZXMoKTtcXG5cXG5cXHRcXHRcXHRpZiAoIG9iamVjdC5oYXNQb3NpdGlvbnMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMucG9zaXRpb24gKTtcXG5cXHRcXHRcXHRcXHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LnBvc2l0aW9uQXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcXG5cXG5cXHRcXHRcXHRcXHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGVzLnBvc2l0aW9uICk7XFxuXFx0XFx0XFx0XFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW1BdHRyaWJ1dGVzLnBvc2l0aW9uLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggb2JqZWN0Lmhhc05vcm1hbHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMubm9ybWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAhIG1hdGVyaWFsLmlzTWVzaFBob25nTWF0ZXJpYWwgJiZcXG5cXHRcXHRcXHRcXHRcXHQhIG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgJiZcXG5cXHRcXHRcXHRcXHRcXHQhIG1hdGVyaWFsLmlzTWVzaE5vcm1hbE1hdGVyaWFsICYmXFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwuZmxhdFNoYWRpbmcgPT09IHRydWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gb2JqZWN0LmNvdW50ICogMzsgaSA8IGw7IGkgKz0gOSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgYXJyYXkgPSBvYmplY3Qubm9ybWFsQXJyYXk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIG54ID0gKCBhcnJheVsgaSArIDAgXSArIGFycmF5WyBpICsgMyBdICsgYXJyYXlbIGkgKyA2IF0gKSAvIDM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIG55ID0gKCBhcnJheVsgaSArIDEgXSArIGFycmF5WyBpICsgNCBdICsgYXJyYXlbIGkgKyA3IF0gKSAvIDM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIG56ID0gKCBhcnJheVsgaSArIDIgXSArIGFycmF5WyBpICsgNSBdICsgYXJyYXlbIGkgKyA4IF0gKSAvIDM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YXJyYXlbIGkgKyAwIF0gPSBueDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhcnJheVsgaSArIDEgXSA9IG55O1xcblxcdFxcdFxcdFxcdFxcdFxcdGFycmF5WyBpICsgMiBdID0gbno7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YXJyYXlbIGkgKyAzIF0gPSBueDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhcnJheVsgaSArIDQgXSA9IG55O1xcblxcdFxcdFxcdFxcdFxcdFxcdGFycmF5WyBpICsgNSBdID0gbno7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YXJyYXlbIGkgKyA2IF0gPSBueDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRhcnJheVsgaSArIDcgXSA9IG55O1xcblxcdFxcdFxcdFxcdFxcdFxcdGFycmF5WyBpICsgOCBdID0gbno7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0Lm5vcm1hbEFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XFxuXFxuXFx0XFx0XFx0XFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtQXR0cmlidXRlcy5ub3JtYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZXMubm9ybWFsLCAzLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggb2JqZWN0Lmhhc1V2cyAmJiBtYXRlcmlhbC5tYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcnMudXYgKTtcXG5cXHRcXHRcXHRcXHRfZ2wuYnVmZmVyRGF0YSggX2dsLkFSUkFZX0JVRkZFUiwgb2JqZWN0LnV2QXJyYXksIF9nbC5EWU5BTUlDX0RSQVcgKTtcXG5cXG5cXHRcXHRcXHRcXHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGVzLnV2ICk7XFxuXFxuXFx0XFx0XFx0XFx0X2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoIHByb2dyYW1BdHRyaWJ1dGVzLnV2LCAyLCBfZ2wuRkxPQVQsIGZhbHNlLCAwLCAwICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggb2JqZWN0Lmhhc0NvbG9ycyAmJiBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgIT09IE5vQ29sb3JzICkge1xcblxcblxcdFxcdFxcdFxcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXJzLmNvbG9yICk7XFxuXFx0XFx0XFx0XFx0X2dsLmJ1ZmZlckRhdGEoIF9nbC5BUlJBWV9CVUZGRVIsIG9iamVjdC5jb2xvckFycmF5LCBfZ2wuRFlOQU1JQ19EUkFXICk7XFxuXFxuXFx0XFx0XFx0XFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtQXR0cmlidXRlcy5jb2xvciApO1xcblxcblxcdFxcdFxcdFxcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlcy5jb2xvciwgMywgX2dsLkZMT0FULCBmYWxzZSwgMCwgMCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xcblxcblxcdFxcdFxcdF9nbC5kcmF3QXJyYXlzKCBfZ2wuVFJJQU5HTEVTLCAwLCBvYmplY3QuY291bnQgKTtcXG5cXG5cXHRcXHRcXHRvYmplY3QuY291bnQgPSAwO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5yZW5kZXJCdWZmZXJEaXJlY3QgPSBmdW5jdGlvbiAoIGNhbWVyYSwgZm9nLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIG9iamVjdCwgZ3JvdXAgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGZyb250RmFjZUNXID0gKCBvYmplY3QuaXNNZXNoICYmIG9iamVjdC5tYXRyaXhXb3JsZC5kZXRlcm1pbmFudCgpIDwgMCApO1xcblxcblxcdFxcdFxcdHN0YXRlLnNldE1hdGVyaWFsKCBtYXRlcmlhbCwgZnJvbnRGYWNlQ1cgKTtcXG5cXG5cXHRcXHRcXHR2YXIgcHJvZ3JhbSA9IHNldFByb2dyYW0oIGNhbWVyYSwgZm9nLCBtYXRlcmlhbCwgb2JqZWN0ICk7XFxuXFx0XFx0XFx0dmFyIGdlb21ldHJ5UHJvZ3JhbSA9IGdlb21ldHJ5LmlkICsgJ18nICsgcHJvZ3JhbS5pZCArICdfJyArICggbWF0ZXJpYWwud2lyZWZyYW1lID09PSB0cnVlICk7XFxuXFxuXFx0XFx0XFx0dmFyIHVwZGF0ZUJ1ZmZlcnMgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5UHJvZ3JhbSAhPT0gX2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gKSB7XFxuXFxuXFx0XFx0XFx0XFx0X2N1cnJlbnRHZW9tZXRyeVByb2dyYW0gPSBnZW9tZXRyeVByb2dyYW07XFxuXFx0XFx0XFx0XFx0dXBkYXRlQnVmZmVycyA9IHRydWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggb2JqZWN0Lm1vcnBoVGFyZ2V0SW5mbHVlbmNlcyApIHtcXG5cXG5cXHRcXHRcXHRcXHRtb3JwaHRhcmdldHMudXBkYXRlKCBvYmplY3QsIGdlb21ldHJ5LCBtYXRlcmlhbCwgcHJvZ3JhbSApO1xcblxcblxcdFxcdFxcdFxcdHVwZGF0ZUJ1ZmZlcnMgPSB0cnVlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xcblxcdFxcdFxcdHZhciBwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XFxuXFx0XFx0XFx0dmFyIHJhbmdlRmFjdG9yID0gMTtcXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpbmRleCA9IGdlb21ldHJpZXMuZ2V0V2lyZWZyYW1lQXR0cmlidXRlKCBnZW9tZXRyeSApO1xcblxcdFxcdFxcdFxcdHJhbmdlRmFjdG9yID0gMjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGF0dHJpYnV0ZTtcXG5cXHRcXHRcXHR2YXIgcmVuZGVyZXIgPSBidWZmZXJSZW5kZXJlcjtcXG5cXG5cXHRcXHRcXHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMuZ2V0KCBpbmRleCApO1xcblxcblxcdFxcdFxcdFxcdHJlbmRlcmVyID0gaW5kZXhlZEJ1ZmZlclJlbmRlcmVyO1xcblxcdFxcdFxcdFxcdHJlbmRlcmVyLnNldEluZGV4KCBhdHRyaWJ1dGUgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB1cGRhdGVCdWZmZXJzICkge1xcblxcblxcdFxcdFxcdFxcdHNldHVwVmVydGV4QXR0cmlidXRlcyggbWF0ZXJpYWwsIHByb2dyYW0sIGdlb21ldHJ5ICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRfZ2wuYmluZEJ1ZmZlciggX2dsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBhdHRyaWJ1dGUuYnVmZmVyICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdHZhciBkYXRhQ291bnQgPSAwO1xcblxcblxcdFxcdFxcdGlmICggaW5kZXggIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZGF0YUNvdW50ID0gaW5kZXguY291bnQ7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggcG9zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRkYXRhQ291bnQgPSBwb3NpdGlvbi5jb3VudDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIHJhbmdlU3RhcnQgPSBnZW9tZXRyeS5kcmF3UmFuZ2Uuc3RhcnQgKiByYW5nZUZhY3RvcjtcXG5cXHRcXHRcXHR2YXIgcmFuZ2VDb3VudCA9IGdlb21ldHJ5LmRyYXdSYW5nZS5jb3VudCAqIHJhbmdlRmFjdG9yO1xcblxcblxcdFxcdFxcdHZhciBncm91cFN0YXJ0ID0gZ3JvdXAgIT09IG51bGwgPyBncm91cC5zdGFydCAqIHJhbmdlRmFjdG9yIDogMDtcXG5cXHRcXHRcXHR2YXIgZ3JvdXBDb3VudCA9IGdyb3VwICE9PSBudWxsID8gZ3JvdXAuY291bnQgKiByYW5nZUZhY3RvciA6IEluZmluaXR5O1xcblxcblxcdFxcdFxcdHZhciBkcmF3U3RhcnQgPSBNYXRoLm1heCggcmFuZ2VTdGFydCwgZ3JvdXBTdGFydCApO1xcblxcdFxcdFxcdHZhciBkcmF3RW5kID0gTWF0aC5taW4oIGRhdGFDb3VudCwgcmFuZ2VTdGFydCArIHJhbmdlQ291bnQsIGdyb3VwU3RhcnQgKyBncm91cENvdW50ICkgLSAxO1xcblxcblxcdFxcdFxcdHZhciBkcmF3Q291bnQgPSBNYXRoLm1heCggMCwgZHJhd0VuZCAtIGRyYXdTdGFydCArIDEgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGRyYXdDb3VudCA9PT0gMCApIHJldHVybjtcXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdGlmICggb2JqZWN0LmlzTWVzaCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG1hdGVyaWFsLndpcmVmcmFtZSA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzdGF0ZS5zZXRMaW5lV2lkdGgoIG1hdGVyaWFsLndpcmVmcmFtZUxpbmV3aWR0aCAqIGdldFRhcmdldFBpeGVsUmF0aW8oKSApO1xcblxcdFxcdFxcdFxcdFxcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5MSU5FUyApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c3dpdGNoICggb2JqZWN0LmRyYXdNb2RlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgVHJpYW5nbGVzRHJhd01vZGU6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlRSSUFOR0xFUyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgVHJpYW5nbGVTdHJpcERyYXdNb2RlOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlbmRlcmVyLnNldE1vZGUoIF9nbC5UUklBTkdMRV9TVFJJUCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgVHJpYW5nbGVGYW5EcmF3TW9kZTpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuVFJJQU5HTEVfRkFOICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBvYmplY3QuaXNMaW5lICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBsaW5lV2lkdGggPSBtYXRlcmlhbC5saW5ld2lkdGg7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBsaW5lV2lkdGggPT09IHVuZGVmaW5lZCApIGxpbmVXaWR0aCA9IDE7IC8vIE5vdCB1c2luZyBMaW5lKk1hdGVyaWFsXFxuXFxuXFx0XFx0XFx0XFx0c3RhdGUuc2V0TGluZVdpZHRoKCBsaW5lV2lkdGggKiBnZXRUYXJnZXRQaXhlbFJhdGlvKCkgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG9iamVjdC5pc0xpbmVTZWdtZW50cyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORVMgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBvYmplY3QuaXNMaW5lTG9vcCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORV9MT09QICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZW5kZXJlci5zZXRNb2RlKCBfZ2wuTElORV9TVFJJUCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBvYmplY3QuaXNQb2ludHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmVuZGVyZXIuc2V0TW9kZSggX2dsLlBPSU5UUyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5ICYmIGdlb21ldHJ5LmlzSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmVuZGVyZXIucmVuZGVySW5zdGFuY2VzKCBnZW9tZXRyeSwgZHJhd1N0YXJ0LCBkcmF3Q291bnQgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRyZW5kZXJlci5yZW5kZXIoIGRyYXdTdGFydCwgZHJhd0NvdW50ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2V0dXBWZXJ0ZXhBdHRyaWJ1dGVzKCBtYXRlcmlhbCwgcHJvZ3JhbSwgZ2VvbWV0cnksIHN0YXJ0SW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0luc3RhbmNlZEJ1ZmZlckdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggZXh0ZW5zaW9ucy5nZXQoICdBTkdMRV9pbnN0YW5jZWRfYXJyYXlzJyApID09PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnNldHVwVmVydGV4QXR0cmlidXRlczogdXNpbmcgVEhSRUUuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgYnV0IGhhcmR3YXJlIGRvZXMgbm90IHN1cHBvcnQgZXh0ZW5zaW9uIEFOR0xFX2luc3RhbmNlZF9hcnJheXMuJyApO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggc3RhcnRJbmRleCA9PT0gdW5kZWZpbmVkICkgc3RhcnRJbmRleCA9IDA7XFxuXFxuXFx0XFx0XFx0c3RhdGUuaW5pdEF0dHJpYnV0ZXMoKTtcXG5cXG5cXHRcXHRcXHR2YXIgZ2VvbWV0cnlBdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcXG5cXG5cXHRcXHRcXHR2YXIgcHJvZ3JhbUF0dHJpYnV0ZXMgPSBwcm9ncmFtLmdldEF0dHJpYnV0ZXMoKTtcXG5cXG5cXHRcXHRcXHR2YXIgbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzID0gbWF0ZXJpYWwuZGVmYXVsdEF0dHJpYnV0ZVZhbHVlcztcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgbmFtZSBpbiBwcm9ncmFtQXR0cmlidXRlcyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcHJvZ3JhbUF0dHJpYnV0ZSA9IHByb2dyYW1BdHRyaWJ1dGVzWyBuYW1lIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBwcm9ncmFtQXR0cmlidXRlID49IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGdlb21ldHJ5QXR0cmlidXRlID0gZ2VvbWV0cnlBdHRyaWJ1dGVzWyBuYW1lIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeUF0dHJpYnV0ZSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBub3JtYWxpemVkID0gZ2VvbWV0cnlBdHRyaWJ1dGUubm9ybWFsaXplZDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgc2l6ZSA9IGdlb21ldHJ5QXR0cmlidXRlLml0ZW1TaXplO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLmdldCggZ2VvbWV0cnlBdHRyaWJ1dGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBUT0RPIEF0dHJpYnV0ZSBtYXkgbm90IGJlIGF2YWlsYWJsZSBvbiBjb250ZXh0IHJlc3RvcmVcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGF0dHJpYnV0ZSA9PT0gdW5kZWZpbmVkICkgY29udGludWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGJ1ZmZlciA9IGF0dHJpYnV0ZS5idWZmZXI7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHR5cGUgPSBhdHRyaWJ1dGUudHlwZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgYnl0ZXNQZXJFbGVtZW50ID0gYXR0cmlidXRlLmJ5dGVzUGVyRWxlbWVudDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlLmlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGRhdGEgPSBnZW9tZXRyeUF0dHJpYnV0ZS5kYXRhO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBzdHJpZGUgPSBkYXRhLnN0cmlkZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgb2Zmc2V0ID0gZ2VvbWV0cnlBdHRyaWJ1dGUub2Zmc2V0O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGF0YSAmJiBkYXRhLmlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlQW5kRGl2aXNvciggcHJvZ3JhbUF0dHJpYnV0ZSwgZGF0YS5tZXNoUGVyQXR0cmlidXRlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5tYXhJbnN0YW5jZWRDb3VudCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID0gZGF0YS5tZXNoUGVyQXR0cmlidXRlICogZGF0YS5jb3VudDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRzdGF0ZS5lbmFibGVBdHRyaWJ1dGUoIHByb2dyYW1BdHRyaWJ1dGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0X2dsLmJpbmRCdWZmZXIoIF9nbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlciApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdF9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBwcm9ncmFtQXR0cmlidXRlLCBzaXplLCB0eXBlLCBub3JtYWxpemVkLCBzdHJpZGUgKiBieXRlc1BlckVsZW1lbnQsICggc3RhcnRJbmRleCAqIHN0cmlkZSArIG9mZnNldCApICogYnl0ZXNQZXJFbGVtZW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5QXR0cmlidXRlLmlzSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlLmVuYWJsZUF0dHJpYnV0ZUFuZERpdmlzb3IoIHByb2dyYW1BdHRyaWJ1dGUsIGdlb21ldHJ5QXR0cmlidXRlLm1lc2hQZXJBdHRyaWJ1dGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5Lm1heEluc3RhbmNlZENvdW50ID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkubWF4SW5zdGFuY2VkQ291bnQgPSBnZW9tZXRyeUF0dHJpYnV0ZS5tZXNoUGVyQXR0cmlidXRlICogZ2VvbWV0cnlBdHRyaWJ1dGUuY291bnQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0c3RhdGUuZW5hYmxlQXR0cmlidXRlKCBwcm9ncmFtQXR0cmlidXRlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdF9nbC5iaW5kQnVmZmVyKCBfZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRfZ2wudmVydGV4QXR0cmliUG9pbnRlciggcHJvZ3JhbUF0dHJpYnV0ZSwgc2l6ZSwgdHlwZSwgbm9ybWFsaXplZCwgMCwgc3RhcnRJbmRleCAqIHNpemUgKiBieXRlc1BlckVsZW1lbnQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHZhbHVlID0gbWF0ZXJpYWxEZWZhdWx0QXR0cmlidXRlVmFsdWVzWyBuYW1lIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHN3aXRjaCAoIHZhbHVlLmxlbmd0aCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlIDI6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0X2dsLnZlcnRleEF0dHJpYjJmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlIDM6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0X2dsLnZlcnRleEF0dHJpYjNmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlIDQ6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0X2dsLnZlcnRleEF0dHJpYjRmdiggcHJvZ3JhbUF0dHJpYnV0ZSwgdmFsdWUgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdF9nbC52ZXJ0ZXhBdHRyaWIxZnYoIHByb2dyYW1BdHRyaWJ1dGUsIHZhbHVlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRzdGF0ZS5kaXNhYmxlVW51c2VkQXR0cmlidXRlcygpO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDb21waWxlXFxuXFxuXFx0XFx0dGhpcy5jb21waWxlID0gZnVuY3Rpb24gKCBzY2VuZSwgY2FtZXJhICkge1xcblxcblxcdFxcdFxcdGxpZ2h0c0FycmF5Lmxlbmd0aCA9IDA7XFxuXFx0XFx0XFx0c2hhZG93c0FycmF5Lmxlbmd0aCA9IDA7XFxuXFxuXFx0XFx0XFx0c2NlbmUudHJhdmVyc2UoIGZ1bmN0aW9uICggb2JqZWN0ICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggb2JqZWN0LmlzTGlnaHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bGlnaHRzQXJyYXkucHVzaCggb2JqZWN0ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBvYmplY3QuY2FzdFNoYWRvdyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3dzQXJyYXkucHVzaCggb2JqZWN0ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9ICk7XFxuXFxuXFx0XFx0XFx0bGlnaHRzLnNldHVwKCBsaWdodHNBcnJheSwgc2hhZG93c0FycmF5LCBjYW1lcmEgKTtcXG5cXG5cXHRcXHRcXHRzY2VuZS50cmF2ZXJzZSggZnVuY3Rpb24gKCBvYmplY3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBvYmplY3QubWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmplY3QubWF0ZXJpYWwgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBvYmplY3QubWF0ZXJpYWwubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGluaXRNYXRlcmlhbCggb2JqZWN0Lm1hdGVyaWFsWyBpIF0sIHNjZW5lLmZvZywgb2JqZWN0ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aW5pdE1hdGVyaWFsKCBvYmplY3QubWF0ZXJpYWwsIHNjZW5lLmZvZywgb2JqZWN0ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9ICk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBBbmltYXRpb24gTG9vcFxcblxcblxcdFxcdHZhciBpc0FuaW1hdGluZyA9IGZhbHNlO1xcblxcdFxcdHZhciBvbkFuaW1hdGlvbkZyYW1lID0gbnVsbDtcXG5cXG5cXHRcXHRmdW5jdGlvbiBzdGFydCgpIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGlzQW5pbWF0aW5nICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdHZhciBkZXZpY2UgPSB2ci5nZXREZXZpY2UoKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGRldmljZSAmJiBkZXZpY2UuaXNQcmVzZW50aW5nICkge1xcblxcblxcdFxcdFxcdFxcdGRldmljZS5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGxvb3AgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGxvb3AgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aXNBbmltYXRpbmcgPSB0cnVlO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBsb29wKCB0aW1lICkge1xcblxcblxcdFxcdFxcdGlmICggb25BbmltYXRpb25GcmFtZSAhPT0gbnVsbCApIG9uQW5pbWF0aW9uRnJhbWUoIHRpbWUgKTtcXG5cXG5cXHRcXHRcXHR2YXIgZGV2aWNlID0gdnIuZ2V0RGV2aWNlKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCBkZXZpY2UgJiYgZGV2aWNlLmlzUHJlc2VudGluZyApIHtcXG5cXG5cXHRcXHRcXHRcXHRkZXZpY2UucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBsb29wICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBsb29wICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLmFuaW1hdGUgPSBmdW5jdGlvbiAoIGNhbGxiYWNrICkge1xcblxcblxcdFxcdFxcdG9uQW5pbWF0aW9uRnJhbWUgPSBjYWxsYmFjaztcXG5cXHRcXHRcXHRzdGFydCgpO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gUmVuZGVyaW5nXFxuXFxuXFx0XFx0dGhpcy5yZW5kZXIgPSBmdW5jdGlvbiAoIHNjZW5lLCBjYW1lcmEsIHJlbmRlclRhcmdldCwgZm9yY2VDbGVhciApIHtcXG5cXG5cXHRcXHRcXHRpZiAoICEgKCBjYW1lcmEgJiYgY2FtZXJhLmlzQ2FtZXJhICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVuZGVyOiBjYW1lcmEgaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkNhbWVyYS4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIF9pc0NvbnRleHRMb3N0ICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdC8vIHJlc2V0IGNhY2hpbmcgZm9yIHRoaXMgZnJhbWVcXG5cXG5cXHRcXHRcXHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnO1xcblxcdFxcdFxcdF9jdXJyZW50TWF0ZXJpYWxJZCA9IC0gMTtcXG5cXHRcXHRcXHRfY3VycmVudENhbWVyYSA9IG51bGw7XFxuXFxuXFx0XFx0XFx0Ly8gdXBkYXRlIHNjZW5lIGdyYXBoXFxuXFxuXFx0XFx0XFx0aWYgKCBzY2VuZS5hdXRvVXBkYXRlID09PSB0cnVlICkgc2NlbmUudXBkYXRlTWF0cml4V29ybGQoKTtcXG5cXG5cXHRcXHRcXHQvLyB1cGRhdGUgY2FtZXJhIG1hdHJpY2VzIGFuZCBmcnVzdHVtXFxuXFxuXFx0XFx0XFx0aWYgKCBjYW1lcmEucGFyZW50ID09PSBudWxsICkgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCB2ci5lbmFibGVkICkge1xcblxcblxcdFxcdFxcdFxcdGNhbWVyYSA9IHZyLmdldENhbWVyYSggY2FtZXJhICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdF9wcm9qU2NyZWVuTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIGNhbWVyYS5wcm9qZWN0aW9uTWF0cml4LCBjYW1lcmEubWF0cml4V29ybGRJbnZlcnNlICk7XFxuXFx0XFx0XFx0X2ZydXN0dW0uc2V0RnJvbU1hdHJpeCggX3Byb2pTY3JlZW5NYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRsaWdodHNBcnJheS5sZW5ndGggPSAwO1xcblxcdFxcdFxcdHNoYWRvd3NBcnJheS5sZW5ndGggPSAwO1xcblxcblxcdFxcdFxcdHNwcml0ZXNBcnJheS5sZW5ndGggPSAwO1xcblxcdFxcdFxcdGZsYXJlc0FycmF5Lmxlbmd0aCA9IDA7XFxuXFxuXFx0XFx0XFx0X2xvY2FsQ2xpcHBpbmdFbmFibGVkID0gdGhpcy5sb2NhbENsaXBwaW5nRW5hYmxlZDtcXG5cXHRcXHRcXHRfY2xpcHBpbmdFbmFibGVkID0gX2NsaXBwaW5nLmluaXQoIHRoaXMuY2xpcHBpbmdQbGFuZXMsIF9sb2NhbENsaXBwaW5nRW5hYmxlZCwgY2FtZXJhICk7XFxuXFxuXFx0XFx0XFx0Y3VycmVudFJlbmRlckxpc3QgPSByZW5kZXJMaXN0cy5nZXQoIHNjZW5lLCBjYW1lcmEgKTtcXG5cXHRcXHRcXHRjdXJyZW50UmVuZGVyTGlzdC5pbml0KCk7XFxuXFxuXFx0XFx0XFx0cHJvamVjdE9iamVjdCggc2NlbmUsIGNhbWVyYSwgX3RoaXMuc29ydE9iamVjdHMgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIF90aGlzLnNvcnRPYmplY3RzID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdGN1cnJlbnRSZW5kZXJMaXN0LnNvcnQoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly9cXG5cXG5cXHRcXHRcXHR0ZXh0dXJlcy51cGRhdGVWaWRlb1RleHR1cmVzKCk7XFxuXFxuXFx0XFx0XFx0Ly9cXG5cXG5cXHRcXHRcXHRpZiAoIF9jbGlwcGluZ0VuYWJsZWQgKSBfY2xpcHBpbmcuYmVnaW5TaGFkb3dzKCk7XFxuXFxuXFx0XFx0XFx0c2hhZG93TWFwLnJlbmRlciggc2hhZG93c0FycmF5LCBzY2VuZSwgY2FtZXJhICk7XFxuXFxuXFx0XFx0XFx0bGlnaHRzLnNldHVwKCBsaWdodHNBcnJheSwgc2hhZG93c0FycmF5LCBjYW1lcmEgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIF9jbGlwcGluZ0VuYWJsZWQgKSBfY2xpcHBpbmcuZW5kU2hhZG93cygpO1xcblxcblxcdFxcdFxcdC8vXFxuXFxuXFx0XFx0XFx0X2luZm9SZW5kZXIuZnJhbWUgKys7XFxuXFx0XFx0XFx0X2luZm9SZW5kZXIuY2FsbHMgPSAwO1xcblxcdFxcdFxcdF9pbmZvUmVuZGVyLnZlcnRpY2VzID0gMDtcXG5cXHRcXHRcXHRfaW5mb1JlbmRlci5mYWNlcyA9IDA7XFxuXFx0XFx0XFx0X2luZm9SZW5kZXIucG9pbnRzID0gMDtcXG5cXG5cXHRcXHRcXHRpZiAoIHJlbmRlclRhcmdldCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHJlbmRlclRhcmdldCA9IG51bGw7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuc2V0UmVuZGVyVGFyZ2V0KCByZW5kZXJUYXJnZXQgKTtcXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdGJhY2tncm91bmQucmVuZGVyKCBjdXJyZW50UmVuZGVyTGlzdCwgc2NlbmUsIGNhbWVyYSwgZm9yY2VDbGVhciApO1xcblxcblxcdFxcdFxcdC8vIHJlbmRlciBzY2VuZVxcblxcblxcdFxcdFxcdHZhciBvcGFxdWVPYmplY3RzID0gY3VycmVudFJlbmRlckxpc3Qub3BhcXVlO1xcblxcdFxcdFxcdHZhciB0cmFuc3BhcmVudE9iamVjdHMgPSBjdXJyZW50UmVuZGVyTGlzdC50cmFuc3BhcmVudDtcXG5cXG5cXHRcXHRcXHRpZiAoIHNjZW5lLm92ZXJyaWRlTWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG92ZXJyaWRlTWF0ZXJpYWwgPSBzY2VuZS5vdmVycmlkZU1hdGVyaWFsO1xcblxcblxcdFxcdFxcdFxcdGlmICggb3BhcXVlT2JqZWN0cy5sZW5ndGggKSByZW5kZXJPYmplY3RzKCBvcGFxdWVPYmplY3RzLCBzY2VuZSwgY2FtZXJhLCBvdmVycmlkZU1hdGVyaWFsICk7XFxuXFx0XFx0XFx0XFx0aWYgKCB0cmFuc3BhcmVudE9iamVjdHMubGVuZ3RoICkgcmVuZGVyT2JqZWN0cyggdHJhbnNwYXJlbnRPYmplY3RzLCBzY2VuZSwgY2FtZXJhLCBvdmVycmlkZU1hdGVyaWFsICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBvcGFxdWUgcGFzcyAoZnJvbnQtdG8tYmFjayBvcmRlcilcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG9wYXF1ZU9iamVjdHMubGVuZ3RoICkgcmVuZGVyT2JqZWN0cyggb3BhcXVlT2JqZWN0cywgc2NlbmUsIGNhbWVyYSApO1xcblxcblxcdFxcdFxcdFxcdC8vIHRyYW5zcGFyZW50IHBhc3MgKGJhY2stdG8tZnJvbnQgb3JkZXIpXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0cmFuc3BhcmVudE9iamVjdHMubGVuZ3RoICkgcmVuZGVyT2JqZWN0cyggdHJhbnNwYXJlbnRPYmplY3RzLCBzY2VuZSwgY2FtZXJhICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGN1c3RvbSByZW5kZXJlcnNcXG5cXG5cXHRcXHRcXHRzcHJpdGVSZW5kZXJlci5yZW5kZXIoIHNwcml0ZXNBcnJheSwgc2NlbmUsIGNhbWVyYSApO1xcblxcdFxcdFxcdGZsYXJlUmVuZGVyZXIucmVuZGVyKCBmbGFyZXNBcnJheSwgc2NlbmUsIGNhbWVyYSwgX2N1cnJlbnRWaWV3cG9ydCApO1xcblxcblxcdFxcdFxcdC8vIEdlbmVyYXRlIG1pcG1hcCBpZiB3ZSdyZSB1c2luZyBhbnkga2luZCBvZiBtaXBtYXAgZmlsdGVyaW5nXFxuXFxuXFx0XFx0XFx0aWYgKCByZW5kZXJUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGV4dHVyZXMudXBkYXRlUmVuZGVyVGFyZ2V0TWlwbWFwKCByZW5kZXJUYXJnZXQgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gRW5zdXJlIGRlcHRoIGJ1ZmZlciB3cml0aW5nIGlzIGVuYWJsZWQgc28gaXQgY2FuIGJlIGNsZWFyZWQgb24gbmV4dCByZW5kZXJcXG5cXG5cXHRcXHRcXHRzdGF0ZS5idWZmZXJzLmRlcHRoLnNldFRlc3QoIHRydWUgKTtcXG5cXHRcXHRcXHRzdGF0ZS5idWZmZXJzLmRlcHRoLnNldE1hc2soIHRydWUgKTtcXG5cXHRcXHRcXHRzdGF0ZS5idWZmZXJzLmNvbG9yLnNldE1hc2soIHRydWUgKTtcXG5cXG5cXHRcXHRcXHRzdGF0ZS5zZXRQb2x5Z29uT2Zmc2V0KCBmYWxzZSApO1xcblxcblxcdFxcdFxcdGlmICggdnIuZW5hYmxlZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2ci5zdWJtaXRGcmFtZSgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBfZ2wuZmluaXNoKCk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvKlxcblxcdFxcdC8vIFRPRE8gRHVwbGljYXRlZCBjb2RlIChGcnVzdHVtKVxcblxcblxcdFxcdHZhciBfc3BoZXJlID0gbmV3IFNwaGVyZSgpO1xcblxcblxcdFxcdGZ1bmN0aW9uIGlzT2JqZWN0Vmlld2FibGUoIG9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSBvYmplY3QuZ2VvbWV0cnk7XFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSA9PT0gbnVsbCApXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XFxuXFxuXFx0XFx0XFx0X3NwaGVyZS5jb3B5KCBnZW9tZXRyeS5ib3VuZGluZ1NwaGVyZSApLlxcblxcdFxcdFxcdGFwcGx5TWF0cml4NCggb2JqZWN0Lm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGlzU3BoZXJlVmlld2FibGUoIF9zcGhlcmUgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gaXNTcHJpdGVWaWV3YWJsZSggc3ByaXRlICkge1xcblxcblxcdFxcdFxcdF9zcGhlcmUuY2VudGVyLnNldCggMCwgMCwgMCApO1xcblxcdFxcdFxcdF9zcGhlcmUucmFkaXVzID0gMC43MDcxMDY3ODExODY1NDc2O1xcblxcdFxcdFxcdF9zcGhlcmUuYXBwbHlNYXRyaXg0KCBzcHJpdGUubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gaXNTcGhlcmVWaWV3YWJsZSggX3NwaGVyZSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBpc1NwaGVyZVZpZXdhYmxlKCBzcGhlcmUgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCAhIF9mcnVzdHVtLmludGVyc2VjdHNTcGhlcmUoIHNwaGVyZSApICkgcmV0dXJuIGZhbHNlO1xcblxcblxcdFxcdFxcdHZhciBudW1QbGFuZXMgPSBfY2xpcHBpbmcubnVtUGxhbmVzO1xcblxcblxcdFxcdFxcdGlmICggbnVtUGxhbmVzID09PSAwICkgcmV0dXJuIHRydWU7XFxuXFxuXFx0XFx0XFx0dmFyIHBsYW5lcyA9IF90aGlzLmNsaXBwaW5nUGxhbmVzLFxcblxcblxcdFxcdFxcdFxcdGNlbnRlciA9IHNwaGVyZS5jZW50ZXIsXFxuXFx0XFx0XFx0XFx0bmVnUmFkID0gLSBzcGhlcmUucmFkaXVzLFxcblxcdFxcdFxcdFxcdGkgPSAwO1xcblxcblxcdFxcdFxcdGRvIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBvdXQgd2hlbiBkZWVwZXIgdGhhbiByYWRpdXMgaW4gdGhlIG5lZ2F0aXZlIGhhbGZzcGFjZVxcblxcdFxcdFxcdFxcdGlmICggcGxhbmVzWyBpIF0uZGlzdGFuY2VUb1BvaW50KCBjZW50ZXIgKSA8IG5lZ1JhZCApIHJldHVybiBmYWxzZTtcXG5cXG5cXHRcXHRcXHR9IHdoaWxlICggKysgaSAhPT0gbnVtUGxhbmVzICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFxuXFx0XFx0fVxcblxcdFxcdCovXFxuXFxuXFx0XFx0ZnVuY3Rpb24gcHJvamVjdE9iamVjdCggb2JqZWN0LCBjYW1lcmEsIHNvcnRPYmplY3RzICkge1xcblxcblxcdFxcdFxcdGlmICggb2JqZWN0LnZpc2libGUgPT09IGZhbHNlICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdHZhciB2aXNpYmxlID0gb2JqZWN0LmxheWVycy50ZXN0KCBjYW1lcmEubGF5ZXJzICk7XFxuXFxuXFx0XFx0XFx0aWYgKCB2aXNpYmxlICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggb2JqZWN0LmlzTGlnaHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bGlnaHRzQXJyYXkucHVzaCggb2JqZWN0ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBvYmplY3QuY2FzdFNoYWRvdyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRzaGFkb3dzQXJyYXkucHVzaCggb2JqZWN0ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG9iamVjdC5pc1Nwcml0ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoICEgb2JqZWN0LmZydXN0dW1DdWxsZWQgfHwgX2ZydXN0dW0uaW50ZXJzZWN0c1Nwcml0ZSggb2JqZWN0ICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0c3ByaXRlc0FycmF5LnB1c2goIG9iamVjdCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBvYmplY3QuaXNMZW5zRmxhcmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmxhcmVzQXJyYXkucHVzaCggb2JqZWN0ICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggb2JqZWN0LmlzSW1tZWRpYXRlUmVuZGVyT2JqZWN0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggc29ydE9iamVjdHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBvYmplY3QubWF0cml4V29ybGQgKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC5hcHBseU1hdHJpeDQoIF9wcm9qU2NyZWVuTWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGN1cnJlbnRSZW5kZXJMaXN0LnB1c2goIG9iamVjdCwgbnVsbCwgb2JqZWN0Lm1hdGVyaWFsLCBfdmVjdG9yMy56LCBudWxsICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggb2JqZWN0LmlzTWVzaCB8fCBvYmplY3QuaXNMaW5lIHx8IG9iamVjdC5pc1BvaW50cyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG9iamVjdC5pc1NraW5uZWRNZXNoICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdC5za2VsZXRvbi51cGRhdGUoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhIG9iamVjdC5mcnVzdHVtQ3VsbGVkIHx8IF9mcnVzdHVtLmludGVyc2VjdHNPYmplY3QoIG9iamVjdCApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggc29ydE9iamVjdHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBvYmplY3QubWF0cml4V29ybGQgKVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC5hcHBseU1hdHJpeDQoIF9wcm9qU2NyZWVuTWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IG9iamVjdHMudXBkYXRlKCBvYmplY3QgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgbWF0ZXJpYWwgPSBvYmplY3QubWF0ZXJpYWw7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCBtYXRlcmlhbCApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBncm91cHMgPSBnZW9tZXRyeS5ncm91cHM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGdyb3VwID0gZ3JvdXBzWyBpIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGdyb3VwTWF0ZXJpYWwgPSBtYXRlcmlhbFsgZ3JvdXAubWF0ZXJpYWxJbmRleCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZ3JvdXBNYXRlcmlhbCAmJiBncm91cE1hdGVyaWFsLnZpc2libGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3VycmVudFJlbmRlckxpc3QucHVzaCggb2JqZWN0LCBnZW9tZXRyeSwgZ3JvdXBNYXRlcmlhbCwgX3ZlY3RvcjMueiwgZ3JvdXAgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLnZpc2libGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3VycmVudFJlbmRlckxpc3QucHVzaCggb2JqZWN0LCBnZW9tZXRyeSwgbWF0ZXJpYWwsIF92ZWN0b3IzLnosIG51bGwgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cHJvamVjdE9iamVjdCggY2hpbGRyZW5bIGkgXSwgY2FtZXJhLCBzb3J0T2JqZWN0cyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVuZGVyT2JqZWN0cyggcmVuZGVyTGlzdCwgc2NlbmUsIGNhbWVyYSwgb3ZlcnJpZGVNYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSByZW5kZXJMaXN0Lmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHJlbmRlckl0ZW0gPSByZW5kZXJMaXN0WyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG9iamVjdCA9IHJlbmRlckl0ZW0ub2JqZWN0O1xcblxcdFxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IHJlbmRlckl0ZW0uZ2VvbWV0cnk7XFxuXFx0XFx0XFx0XFx0dmFyIG1hdGVyaWFsID0gb3ZlcnJpZGVNYXRlcmlhbCA9PT0gdW5kZWZpbmVkID8gcmVuZGVySXRlbS5tYXRlcmlhbCA6IG92ZXJyaWRlTWF0ZXJpYWw7XFxuXFx0XFx0XFx0XFx0dmFyIGdyb3VwID0gcmVuZGVySXRlbS5ncm91cDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGNhbWVyYS5pc0FycmF5Q2FtZXJhICkge1xcblxcblxcdFxcdFxcdFxcdFxcdF9jdXJyZW50QXJyYXlDYW1lcmEgPSBjYW1lcmE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNhbWVyYXMgPSBjYW1lcmEuY2FtZXJhcztcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDAsIGpsID0gY2FtZXJhcy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgY2FtZXJhMiA9IGNhbWVyYXNbIGogXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG9iamVjdC5sYXllcnMudGVzdCggY2FtZXJhMi5sYXllcnMgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgYm91bmRzID0gY2FtZXJhMi5ib3VuZHM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHggPSBib3VuZHMueCAqIF93aWR0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgeSA9IGJvdW5kcy55ICogX2hlaWdodDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgd2lkdGggPSBib3VuZHMueiAqIF93aWR0aDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgaGVpZ2h0ID0gYm91bmRzLncgKiBfaGVpZ2h0O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHN0YXRlLnZpZXdwb3J0KCBfY3VycmVudFZpZXdwb3J0LnNldCggeCwgeSwgd2lkdGgsIGhlaWdodCApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVuZGVyT2JqZWN0KCBvYmplY3QsIHNjZW5lLCBjYW1lcmEyLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdF9jdXJyZW50QXJyYXlDYW1lcmEgPSBudWxsO1xcblxcblxcdFxcdFxcdFxcdFxcdHJlbmRlck9iamVjdCggb2JqZWN0LCBzY2VuZSwgY2FtZXJhLCBnZW9tZXRyeSwgbWF0ZXJpYWwsIGdyb3VwICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVuZGVyT2JqZWN0KCBvYmplY3QsIHNjZW5lLCBjYW1lcmEsIGdlb21ldHJ5LCBtYXRlcmlhbCwgZ3JvdXAgKSB7XFxuXFxuXFx0XFx0XFx0b2JqZWN0Lm9uQmVmb3JlUmVuZGVyKCBfdGhpcywgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCApO1xcblxcblxcdFxcdFxcdG9iamVjdC5tb2RlbFZpZXdNYXRyaXgubXVsdGlwbHlNYXRyaWNlcyggY2FtZXJhLm1hdHJpeFdvcmxkSW52ZXJzZSwgb2JqZWN0Lm1hdHJpeFdvcmxkICk7XFxuXFx0XFx0XFx0b2JqZWN0Lm5vcm1hbE1hdHJpeC5nZXROb3JtYWxNYXRyaXgoIG9iamVjdC5tb2RlbFZpZXdNYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRpZiAoIG9iamVjdC5pc0ltbWVkaWF0ZVJlbmRlck9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZnJvbnRGYWNlQ1cgPSAoIG9iamVjdC5pc01lc2ggJiYgb2JqZWN0Lm1hdHJpeFdvcmxkLmRldGVybWluYW50KCkgPCAwICk7XFxuXFxuXFx0XFx0XFx0XFx0c3RhdGUuc2V0TWF0ZXJpYWwoIG1hdGVyaWFsLCBmcm9udEZhY2VDVyApO1xcblxcblxcdFxcdFxcdFxcdHZhciBwcm9ncmFtID0gc2V0UHJvZ3JhbSggY2FtZXJhLCBzY2VuZS5mb2csIG1hdGVyaWFsLCBvYmplY3QgKTtcXG5cXG5cXHRcXHRcXHRcXHRfY3VycmVudEdlb21ldHJ5UHJvZ3JhbSA9ICcnO1xcblxcblxcdFxcdFxcdFxcdHJlbmRlck9iamVjdEltbWVkaWF0ZSggb2JqZWN0LCBwcm9ncmFtLCBtYXRlcmlhbCApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0X3RoaXMucmVuZGVyQnVmZmVyRGlyZWN0KCBjYW1lcmEsIHNjZW5lLmZvZywgZ2VvbWV0cnksIG1hdGVyaWFsLCBvYmplY3QsIGdyb3VwICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdG9iamVjdC5vbkFmdGVyUmVuZGVyKCBfdGhpcywgc2NlbmUsIGNhbWVyYSwgZ2VvbWV0cnksIG1hdGVyaWFsLCBncm91cCApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBmb2csIG9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgbWF0ZXJpYWxQcm9wZXJ0aWVzID0gcHJvcGVydGllcy5nZXQoIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0XFx0dmFyIHBhcmFtZXRlcnMgPSBwcm9ncmFtQ2FjaGUuZ2V0UGFyYW1ldGVycyhcXG5cXHRcXHRcXHRcXHRtYXRlcmlhbCwgbGlnaHRzLnN0YXRlLCBzaGFkb3dzQXJyYXksIGZvZywgX2NsaXBwaW5nLm51bVBsYW5lcywgX2NsaXBwaW5nLm51bUludGVyc2VjdGlvbiwgb2JqZWN0ICk7XFxuXFxuXFx0XFx0XFx0dmFyIGNvZGUgPSBwcm9ncmFtQ2FjaGUuZ2V0UHJvZ3JhbUNvZGUoIG1hdGVyaWFsLCBwYXJhbWV0ZXJzICk7XFxuXFxuXFx0XFx0XFx0dmFyIHByb2dyYW0gPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbTtcXG5cXHRcXHRcXHR2YXIgcHJvZ3JhbUNoYW5nZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0aWYgKCBwcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbmV3IG1hdGVyaWFsXFxuXFx0XFx0XFx0XFx0bWF0ZXJpYWwuYWRkRXZlbnRMaXN0ZW5lciggJ2Rpc3Bvc2UnLCBvbk1hdGVyaWFsRGlzcG9zZSApO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHByb2dyYW0uY29kZSAhPT0gY29kZSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBjaGFuZ2VkIGdsc2wgb3IgcGFyYW1ldGVyc1xcblxcdFxcdFxcdFxcdHJlbGVhc2VNYXRlcmlhbFByb2dyYW1SZWZlcmVuY2UoIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggcGFyYW1ldGVycy5zaGFkZXJJRCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdC8vIHNhbWUgZ2xzbCBhbmQgdW5pZm9ybSBsaXN0XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gb25seSByZWJ1aWxkIHVuaWZvcm0gbGlzdFxcblxcdFxcdFxcdFxcdHByb2dyYW1DaGFuZ2UgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBwcm9ncmFtQ2hhbmdlICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggcGFyYW1ldGVycy5zaGFkZXJJRCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgc2hhZGVyID0gU2hhZGVyTGliWyBwYXJhbWV0ZXJzLnNoYWRlcklEIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnNoYWRlciA9IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRuYW1lOiBtYXRlcmlhbC50eXBlLFxcblxcdFxcdFxcdFxcdFxcdFxcdHVuaWZvcm1zOiBVbmlmb3Jtc1V0aWxzLmNsb25lKCBzaGFkZXIudW5pZm9ybXMgKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHR2ZXJ0ZXhTaGFkZXI6IHNoYWRlci52ZXJ0ZXhTaGFkZXIsXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZnJhZ21lbnRTaGFkZXI6IHNoYWRlci5mcmFnbWVudFNoYWRlclxcblxcdFxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbFByb3BlcnRpZXMuc2hhZGVyID0ge1xcblxcdFxcdFxcdFxcdFxcdFxcdG5hbWU6IG1hdGVyaWFsLnR5cGUsXFxuXFx0XFx0XFx0XFx0XFx0XFx0dW5pZm9ybXM6IG1hdGVyaWFsLnVuaWZvcm1zLFxcblxcdFxcdFxcdFxcdFxcdFxcdHZlcnRleFNoYWRlcjogbWF0ZXJpYWwudmVydGV4U2hhZGVyLFxcblxcdFxcdFxcdFxcdFxcdFxcdGZyYWdtZW50U2hhZGVyOiBtYXRlcmlhbC5mcmFnbWVudFNoYWRlclxcblxcdFxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdG1hdGVyaWFsLm9uQmVmb3JlQ29tcGlsZSggbWF0ZXJpYWxQcm9wZXJ0aWVzLnNoYWRlciApO1xcblxcblxcdFxcdFxcdFxcdHByb2dyYW0gPSBwcm9ncmFtQ2FjaGUuYWNxdWlyZVByb2dyYW0oIG1hdGVyaWFsLCBtYXRlcmlhbFByb3BlcnRpZXMuc2hhZGVyLCBwYXJhbWV0ZXJzLCBjb2RlICk7XFxuXFxuXFx0XFx0XFx0XFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0gPSBwcm9ncmFtO1xcblxcdFxcdFxcdFxcdG1hdGVyaWFsLnByb2dyYW0gPSBwcm9ncmFtO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgcHJvZ3JhbUF0dHJpYnV0ZXMgPSBwcm9ncmFtLmdldEF0dHJpYnV0ZXMoKTtcXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLm1vcnBoVGFyZ2V0cyApIHtcXG5cXG5cXHRcXHRcXHRcXHRtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaFRhcmdldHMgPSAwO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IF90aGlzLm1heE1vcnBoVGFyZ2V0czsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHByb2dyYW1BdHRyaWJ1dGVzWyAnbW9ycGhUYXJnZXQnICsgaSBdID49IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwubnVtU3VwcG9ydGVkTW9ycGhUYXJnZXRzICsrO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwubW9ycGhOb3JtYWxzICkge1xcblxcblxcdFxcdFxcdFxcdG1hdGVyaWFsLm51bVN1cHBvcnRlZE1vcnBoTm9ybWFscyA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgX3RoaXMubWF4TW9ycGhOb3JtYWxzOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggcHJvZ3JhbUF0dHJpYnV0ZXNbICdtb3JwaE5vcm1hbCcgKyBpIF0gPj0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5udW1TdXBwb3J0ZWRNb3JwaE5vcm1hbHMgKys7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIHVuaWZvcm1zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnNoYWRlci51bmlmb3JtcztcXG5cXG5cXHRcXHRcXHRpZiAoICEgbWF0ZXJpYWwuaXNTaGFkZXJNYXRlcmlhbCAmJlxcblxcdFxcdFxcdFxcdCEgbWF0ZXJpYWwuaXNSYXdTaGFkZXJNYXRlcmlhbCB8fFxcblxcdFxcdFxcdFxcdG1hdGVyaWFsLmNsaXBwaW5nID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdG1hdGVyaWFsUHJvcGVydGllcy5udW1DbGlwcGluZ1BsYW5lcyA9IF9jbGlwcGluZy5udW1QbGFuZXM7XFxuXFx0XFx0XFx0XFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLm51bUludGVyc2VjdGlvbiA9IF9jbGlwcGluZy5udW1JbnRlcnNlY3Rpb247XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuY2xpcHBpbmdQbGFuZXMgPSBfY2xpcHBpbmcudW5pZm9ybTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmZvZyA9IGZvZztcXG5cXG5cXHRcXHRcXHQvLyBzdG9yZSB0aGUgbGlnaHQgc2V0dXAgaXQgd2FzIGNyZWF0ZWQgZm9yXFxuXFxuXFx0XFx0XFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLmxpZ2h0c0hhc2ggPSBsaWdodHMuc3RhdGUuaGFzaDtcXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmxpZ2h0cyApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyB3aXJlIHVwIHRoZSBtYXRlcmlhbCB0byB0aGlzIHJlbmRlcmVyJ3MgbGlnaHRpbmcgc3RhdGVcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5hbWJpZW50TGlnaHRDb2xvci52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5hbWJpZW50O1xcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpcmVjdGlvbmFsTGlnaHRzLnZhbHVlID0gbGlnaHRzLnN0YXRlLmRpcmVjdGlvbmFsO1xcblxcdFxcdFxcdFxcdHVuaWZvcm1zLnNwb3RMaWdodHMudmFsdWUgPSBsaWdodHMuc3RhdGUuc3BvdDtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5yZWN0QXJlYUxpZ2h0cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5yZWN0QXJlYTtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5wb2ludExpZ2h0cy52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5wb2ludDtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5oZW1pc3BoZXJlTGlnaHRzLnZhbHVlID0gbGlnaHRzLnN0YXRlLmhlbWk7XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxTaGFkb3dNYXAudmFsdWUgPSBsaWdodHMuc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXA7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXgudmFsdWUgPSBsaWdodHMuc3RhdGUuZGlyZWN0aW9uYWxTaGFkb3dNYXRyaXg7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuc3BvdFNoYWRvd01hcC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5zcG90U2hhZG93TWFwO1xcblxcdFxcdFxcdFxcdHVuaWZvcm1zLnNwb3RTaGFkb3dNYXRyaXgudmFsdWUgPSBsaWdodHMuc3RhdGUuc3BvdFNoYWRvd01hdHJpeDtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5wb2ludFNoYWRvd01hcC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5wb2ludFNoYWRvd01hcDtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5wb2ludFNoYWRvd01hdHJpeC52YWx1ZSA9IGxpZ2h0cy5zdGF0ZS5wb2ludFNoYWRvd01hdHJpeDtcXG5cXHRcXHRcXHRcXHQvLyBUT0RPIChhYmVsbmF0aW9uKTogYWRkIGFyZWEgbGlnaHRzIHNoYWRvdyBpbmZvIHRvIHVuaWZvcm1zXFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBwcm9nVW5pZm9ybXMgPSBtYXRlcmlhbFByb3BlcnRpZXMucHJvZ3JhbS5nZXRVbmlmb3JtcygpLFxcblxcdFxcdFxcdFxcdHVuaWZvcm1zTGlzdCA9XFxuXFx0XFx0XFx0XFx0XFx0V2ViR0xVbmlmb3Jtcy5zZXFXaXRoVmFsdWUoIHByb2dVbmlmb3Jtcy5zZXEsIHVuaWZvcm1zICk7XFxuXFxuXFx0XFx0XFx0bWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdCA9IHVuaWZvcm1zTGlzdDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc2V0UHJvZ3JhbSggY2FtZXJhLCBmb2csIG1hdGVyaWFsLCBvYmplY3QgKSB7XFxuXFxuXFx0XFx0XFx0X3VzZWRUZXh0dXJlVW5pdHMgPSAwO1xcblxcblxcdFxcdFxcdHZhciBtYXRlcmlhbFByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzLmdldCggbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIF9jbGlwcGluZ0VuYWJsZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBfbG9jYWxDbGlwcGluZ0VuYWJsZWQgfHwgY2FtZXJhICE9PSBfY3VycmVudENhbWVyYSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdXNlQ2FjaGUgPVxcblxcdFxcdFxcdFxcdFxcdFxcdGNhbWVyYSA9PT0gX2N1cnJlbnRDYW1lcmEgJiZcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5pZCA9PT0gX2N1cnJlbnRNYXRlcmlhbElkO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHdlIG1pZ2h0IHdhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHdpdGggc29tZSBDbGlwcGluZ0dyb3VwXFxuXFx0XFx0XFx0XFx0XFx0Ly8gb2JqZWN0IGluc3RlYWQgb2YgdGhlIG1hdGVyaWFsLCBvbmNlIGl0IGJlY29tZXMgZmVhc2libGVcXG5cXHRcXHRcXHRcXHRcXHQvLyAoIzg0NjUsICM4Mzc5KVxcblxcdFxcdFxcdFxcdFxcdF9jbGlwcGluZy5zZXRTdGF0ZShcXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5jbGlwcGluZ1BsYW5lcywgbWF0ZXJpYWwuY2xpcEludGVyc2VjdGlvbiwgbWF0ZXJpYWwuY2xpcFNoYWRvd3MsXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FtZXJhLCBtYXRlcmlhbFByb3BlcnRpZXMsIHVzZUNhY2hlICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLm5lZWRzVXBkYXRlID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG1hdGVyaWFsUHJvcGVydGllcy5wcm9ncmFtID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmZvZyAmJiBtYXRlcmlhbFByb3BlcnRpZXMuZm9nICE9PSBmb2cgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmxpZ2h0cyAmJiBtYXRlcmlhbFByb3BlcnRpZXMubGlnaHRzSGFzaCAhPT0gbGlnaHRzLnN0YXRlLmhhc2ggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsUHJvcGVydGllcy5udW1DbGlwcGluZ1BsYW5lcyAhPT0gdW5kZWZpbmVkICYmXFxuXFx0XFx0XFx0XFx0XFx0KCBtYXRlcmlhbFByb3BlcnRpZXMubnVtQ2xpcHBpbmdQbGFuZXMgIT09IF9jbGlwcGluZy5udW1QbGFuZXMgfHxcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbFByb3BlcnRpZXMubnVtSW50ZXJzZWN0aW9uICE9PSBfY2xpcHBpbmcubnVtSW50ZXJzZWN0aW9uICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5uZWVkc1VwZGF0ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpbml0TWF0ZXJpYWwoIG1hdGVyaWFsLCBmb2csIG9iamVjdCApO1xcblxcdFxcdFxcdFxcdG1hdGVyaWFsLm5lZWRzVXBkYXRlID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciByZWZyZXNoUHJvZ3JhbSA9IGZhbHNlO1xcblxcdFxcdFxcdHZhciByZWZyZXNoTWF0ZXJpYWwgPSBmYWxzZTtcXG5cXHRcXHRcXHR2YXIgcmVmcmVzaExpZ2h0cyA9IGZhbHNlO1xcblxcblxcdFxcdFxcdHZhciBwcm9ncmFtID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnByb2dyYW0sXFxuXFx0XFx0XFx0XFx0cF91bmlmb3JtcyA9IHByb2dyYW0uZ2V0VW5pZm9ybXMoKSxcXG5cXHRcXHRcXHRcXHRtX3VuaWZvcm1zID0gbWF0ZXJpYWxQcm9wZXJ0aWVzLnNoYWRlci51bmlmb3JtcztcXG5cXG5cXHRcXHRcXHRpZiAoIHN0YXRlLnVzZVByb2dyYW0oIHByb2dyYW0ucHJvZ3JhbSApICkge1xcblxcblxcdFxcdFxcdFxcdHJlZnJlc2hQcm9ncmFtID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRyZWZyZXNoTWF0ZXJpYWwgPSB0cnVlO1xcblxcdFxcdFxcdFxcdHJlZnJlc2hMaWdodHMgPSB0cnVlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmlkICE9PSBfY3VycmVudE1hdGVyaWFsSWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0X2N1cnJlbnRNYXRlcmlhbElkID0gbWF0ZXJpYWwuaWQ7XFxuXFxuXFx0XFx0XFx0XFx0cmVmcmVzaE1hdGVyaWFsID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCByZWZyZXNoUHJvZ3JhbSB8fCBjYW1lcmEgIT09IF9jdXJyZW50Q2FtZXJhICkge1xcblxcblxcdFxcdFxcdFxcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ3Byb2plY3Rpb25NYXRyaXgnLCBjYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xcblxcblxcdFxcdFxcdFxcdGlmICggY2FwYWJpbGl0aWVzLmxvZ2FyaXRobWljRGVwdGhCdWZmZXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAnbG9nRGVwdGhCdWZGQycsXFxuXFx0XFx0XFx0XFx0XFx0XFx0Mi4wIC8gKCBNYXRoLmxvZyggY2FtZXJhLmZhciArIDEuMCApIC8gTWF0aC5MTjIgKSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBBdm9pZCB1bm5lZWRlZCB1bmlmb3JtIHVwZGF0ZXMgcGVyIEFycmF5Q2FtZXJhJ3Mgc3ViLWNhbWVyYVxcblxcblxcdFxcdFxcdFxcdGlmICggX2N1cnJlbnRDYW1lcmEgIT09ICggX2N1cnJlbnRBcnJheUNhbWVyYSB8fCBjYW1lcmEgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRfY3VycmVudENhbWVyYSA9ICggX2N1cnJlbnRBcnJheUNhbWVyYSB8fCBjYW1lcmEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBsaWdodGluZyB1bmlmb3JtcyBkZXBlbmQgb24gdGhlIGNhbWVyYSBzbyBlbmZvcmNlIGFuIHVwZGF0ZVxcblxcdFxcdFxcdFxcdFxcdC8vIG5vdywgaW4gY2FzZSB0aGlzIG1hdGVyaWFsIHN1cHBvcnRzIGxpZ2h0cyAtIG9yIGxhdGVyLCB3aGVuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdGhlIG5leHQgbWF0ZXJpYWwgdGhhdCBkb2VzIGdldHMgYWN0aXZhdGVkOlxcblxcblxcdFxcdFxcdFxcdFxcdHJlZnJlc2hNYXRlcmlhbCA9IHRydWU7XFx0XFx0Ly8gc2V0IHRvIHRydWUgb24gbWF0ZXJpYWwgY2hhbmdlXFxuXFx0XFx0XFx0XFx0XFx0cmVmcmVzaExpZ2h0cyA9IHRydWU7XFx0XFx0Ly8gcmVtYWlucyBzZXQgdW50aWwgdXBkYXRlIGRvbmVcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbG9hZCBtYXRlcmlhbCBzcGVjaWZpYyB1bmlmb3Jtc1xcblxcdFxcdFxcdFxcdC8vIChzaGFkZXIgbWF0ZXJpYWwgYWxzbyBnZXRzIHRoZW0gZm9yIHRoZSBzYWtlIG9mIGdlbmVyaWNpdHkpXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsIHx8XFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwuaXNNZXNoUGhvbmdNYXRlcmlhbCB8fFxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgfHxcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5lbnZNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHVDYW1Qb3MgPSBwX3VuaWZvcm1zLm1hcC5jYW1lcmFQb3NpdGlvbjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHVDYW1Qb3MgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR1Q2FtUG9zLnNldFZhbHVlKCBfZ2wsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0X3ZlY3RvcjMuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsIHx8XFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwuaXNNZXNoTGFtYmVydE1hdGVyaWFsIHx8XFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwuaXNNZXNoQmFzaWNNYXRlcmlhbCB8fFxcblxcdFxcdFxcdFxcdFxcdG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgfHxcXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5pc1NoYWRlck1hdGVyaWFsIHx8XFxuXFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWwuc2tpbm5pbmcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAndmlld01hdHJpeCcsIGNhbWVyYS5tYXRyaXhXb3JsZEludmVyc2UgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIHNraW5uaW5nIHVuaWZvcm1zIG11c3QgYmUgc2V0IGV2ZW4gaWYgbWF0ZXJpYWwgZGlkbid0IGNoYW5nZVxcblxcdFxcdFxcdC8vIGF1dG8tc2V0dGluZyBvZiB0ZXh0dXJlIHVuaXQgZm9yIGJvbmUgdGV4dHVyZSBtdXN0IGdvIGJlZm9yZSBvdGhlciB0ZXh0dXJlc1xcblxcdFxcdFxcdC8vIG5vdCBzdXJlIHdoeSwgYnV0IG90aGVyd2lzZSB3ZWlyZCB0aGluZ3MgaGFwcGVuXFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5za2lubmluZyApIHtcXG5cXG5cXHRcXHRcXHRcXHRwX3VuaWZvcm1zLnNldE9wdGlvbmFsKCBfZ2wsIG9iamVjdCwgJ2JpbmRNYXRyaXgnICk7XFxuXFx0XFx0XFx0XFx0cF91bmlmb3Jtcy5zZXRPcHRpb25hbCggX2dsLCBvYmplY3QsICdiaW5kTWF0cml4SW52ZXJzZScgKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgc2tlbGV0b24gPSBvYmplY3Quc2tlbGV0b247XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBza2VsZXRvbiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgYm9uZXMgPSBza2VsZXRvbi5ib25lcztcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGNhcGFiaWxpdGllcy5mbG9hdFZlcnRleFRleHR1cmVzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggc2tlbGV0b24uYm9uZVRleHR1cmUgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBsYXlvdXQgKDEgbWF0cml4ID0gNCBwaXhlbHMpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gICAgICBSR0JBIFJHQkEgUkdCQSBSR0JBICg9PiBjb2x1bW4xLCBjb2x1bW4yLCBjb2x1bW4zLCBjb2x1bW40KVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vICB3aXRoICA4eDggIHBpeGVsIHRleHR1cmUgbWF4ICAgMTYgYm9uZXMgKiA0IHBpeGVscyA9ICAoOCAqIDgpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gICAgICAgMTZ4MTYgcGl4ZWwgdGV4dHVyZSBtYXggICA2NCBib25lcyAqIDQgcGl4ZWxzID0gKDE2ICogMTYpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gICAgICAgMzJ4MzIgcGl4ZWwgdGV4dHVyZSBtYXggIDI1NiBib25lcyAqIDQgcGl4ZWxzID0gKDMyICogMzIpXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gICAgICAgNjR4NjQgcGl4ZWwgdGV4dHVyZSBtYXggMTAyNCBib25lcyAqIDQgcGl4ZWxzID0gKDY0ICogNjQpXFxuXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIHNpemUgPSBNYXRoLnNxcnQoIGJvbmVzLmxlbmd0aCAqIDQgKTsgLy8gNCBwaXhlbHMgbmVlZGVkIGZvciAxIG1hdHJpeFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNpemUgPSBfTWF0aC5jZWlsUG93ZXJPZlR3byggc2l6ZSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHNpemUgPSBNYXRoLm1heCggc2l6ZSwgNCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCBzaXplICogc2l6ZSAqIDQgKTsgLy8gNCBmbG9hdHMgcGVyIFJHQkEgcGl4ZWxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRib25lTWF0cmljZXMuc2V0KCBza2VsZXRvbi5ib25lTWF0cmljZXMgKTsgLy8gY29weSBjdXJyZW50IHZhbHVlc1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBib25lVGV4dHVyZSA9IG5ldyBEYXRhVGV4dHVyZSggYm9uZU1hdHJpY2VzLCBzaXplLCBzaXplLCBSR0JBRm9ybWF0LCBGbG9hdFR5cGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRza2VsZXRvbi5ib25lTWF0cmljZXMgPSBib25lTWF0cmljZXM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0c2tlbGV0b24uYm9uZVRleHR1cmUgPSBib25lVGV4dHVyZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRza2VsZXRvbi5ib25lVGV4dHVyZVNpemUgPSBzaXplO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdib25lVGV4dHVyZScsIHNrZWxldG9uLmJvbmVUZXh0dXJlICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAnYm9uZVRleHR1cmVTaXplJywgc2tlbGV0b24uYm9uZVRleHR1cmVTaXplICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRwX3VuaWZvcm1zLnNldE9wdGlvbmFsKCBfZ2wsIHNrZWxldG9uLCAnYm9uZU1hdHJpY2VzJyApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggcmVmcmVzaE1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdFxcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ3RvbmVNYXBwaW5nRXhwb3N1cmUnLCBfdGhpcy50b25lTWFwcGluZ0V4cG9zdXJlICk7XFxuXFx0XFx0XFx0XFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAndG9uZU1hcHBpbmdXaGl0ZVBvaW50JywgX3RoaXMudG9uZU1hcHBpbmdXaGl0ZVBvaW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5saWdodHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdGhlIGN1cnJlbnQgbWF0ZXJpYWwgcmVxdWlyZXMgbGlnaHRpbmcgaW5mb1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIG5vdGU6IGFsbCBsaWdodGluZyB1bmlmb3JtcyBhcmUgYWx3YXlzIHNldCBjb3JyZWN0bHlcXG5cXHRcXHRcXHRcXHRcXHQvLyB0aGV5IHNpbXBseSByZWZlcmVuY2UgdGhlIHJlbmRlcmVyJ3Mgc3RhdGUgZm9yIHRoZWlyXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdmFsdWVzXFxuXFx0XFx0XFx0XFx0XFx0Ly9cXG5cXHRcXHRcXHRcXHRcXHQvLyB1c2UgdGhlIGN1cnJlbnQgbWF0ZXJpYWwncyAubmVlZHNVcGRhdGUgZmxhZ3MgdG8gc2V0XFxuXFx0XFx0XFx0XFx0XFx0Ly8gdGhlIEdMIHN0YXRlIHdoZW4gcmVxdWlyZWRcXG5cXG5cXHRcXHRcXHRcXHRcXHRtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggbV91bmlmb3JtcywgcmVmcmVzaExpZ2h0cyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyByZWZyZXNoIHVuaWZvcm1zIGNvbW1vbiB0byBzZXZlcmFsIG1hdGVyaWFsc1xcblxcblxcdFxcdFxcdFxcdGlmICggZm9nICYmIG1hdGVyaWFsLmZvZyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNGb2coIG1fdW5pZm9ybXMsIGZvZyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmlzTWVzaEJhc2ljTWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaExhbWJlcnRNYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxuXFx0XFx0XFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zTGFtYmVydCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hQaG9uZ01hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmlzTWVzaFRvb25NYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNUb29uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zUGhvbmcoIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTWVzaFN0YW5kYXJkTWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zQ29tbW9uKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggbWF0ZXJpYWwuaXNNZXNoUGh5c2ljYWxNYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNQaHlzaWNhbCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc1N0YW5kYXJkKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hEZXB0aE1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNEZXB0aCggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hEaXN0YW5jZU1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcXG5cXHRcXHRcXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNEaXN0YW5jZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5pc01lc2hOb3JtYWxNYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNDb21tb24oIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxuXFx0XFx0XFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zTm9ybWFsKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzTGluZUJhc2ljTWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zTGluZSggbV91bmlmb3JtcywgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmlzTGluZURhc2hlZE1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc0Rhc2goIG1fdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzUG9pbnRzTWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmVmcmVzaFVuaWZvcm1zUG9pbnRzKCBtX3VuaWZvcm1zLCBtYXRlcmlhbCApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIG1hdGVyaWFsLmlzU2hhZG93TWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bV91bmlmb3Jtcy5jb2xvci52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xcblxcdFxcdFxcdFxcdFxcdG1fdW5pZm9ybXMub3BhY2l0eS52YWx1ZSA9IG1hdGVyaWFsLm9wYWNpdHk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIFJlY3RBcmVhTGlnaHQgVGV4dHVyZVxcblxcdFxcdFxcdFxcdC8vIFRPRE8gKG1yZG9vYik6IEZpbmQgYSBuaWNlciBpbXBsZW1lbnRhdGlvblxcblxcblxcdFxcdFxcdFxcdGlmICggbV91bmlmb3Jtcy5sdGNNYXQgIT09IHVuZGVmaW5lZCApIG1fdW5pZm9ybXMubHRjTWF0LnZhbHVlID0gVW5pZm9ybXNMaWIuTFRDX01BVF9URVhUVVJFO1xcblxcdFxcdFxcdFxcdGlmICggbV91bmlmb3Jtcy5sdGNNYWcgIT09IHVuZGVmaW5lZCApIG1fdW5pZm9ybXMubHRjTWFnLnZhbHVlID0gVW5pZm9ybXNMaWIuTFRDX01BR19URVhUVVJFO1xcblxcblxcdFxcdFxcdFxcdFdlYkdMVW5pZm9ybXMudXBsb2FkKFxcblxcdFxcdFxcdFxcdFxcdF9nbCwgbWF0ZXJpYWxQcm9wZXJ0aWVzLnVuaWZvcm1zTGlzdCwgbV91bmlmb3JtcywgX3RoaXMgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFxuXFx0XFx0XFx0Ly8gY29tbW9uIG1hdHJpY2VzXFxuXFxuXFx0XFx0XFx0cF91bmlmb3Jtcy5zZXRWYWx1ZSggX2dsLCAnbW9kZWxWaWV3TWF0cml4Jywgb2JqZWN0Lm1vZGVsVmlld01hdHJpeCApO1xcblxcdFxcdFxcdHBfdW5pZm9ybXMuc2V0VmFsdWUoIF9nbCwgJ25vcm1hbE1hdHJpeCcsIG9iamVjdC5ub3JtYWxNYXRyaXggKTtcXG5cXHRcXHRcXHRwX3VuaWZvcm1zLnNldFZhbHVlKCBfZ2wsICdtb2RlbE1hdHJpeCcsIG9iamVjdC5tYXRyaXhXb3JsZCApO1xcblxcblxcdFxcdFxcdHJldHVybiBwcm9ncmFtO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBVbmlmb3JtcyAocmVmcmVzaCB1bmlmb3JtcyBvYmplY3RzKVxcblxcblxcdFxcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0NvbW1vbiggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuY29sb3IgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmVtaXNzaXZlICkge1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmVtaXNzaXZlLnZhbHVlLmNvcHkoIG1hdGVyaWFsLmVtaXNzaXZlICkubXVsdGlwbHlTY2FsYXIoIG1hdGVyaWFsLmVtaXNzaXZlSW50ZW5zaXR5ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwubWFwICkge1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5hbHBoYU1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5hbHBoYU1hcC52YWx1ZSA9IG1hdGVyaWFsLmFscGhhTWFwO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLnNwZWN1bGFyTWFwICkge1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLnNwZWN1bGFyTWFwLnZhbHVlID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuZW52TWFwICkge1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmVudk1hcC52YWx1ZSA9IG1hdGVyaWFsLmVudk1hcDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBkb24ndCBmbGlwIEN1YmVUZXh0dXJlIGVudk1hcHMsIGZsaXAgZXZlcnl0aGluZyBlbHNlOlxcblxcdFxcdFxcdFxcdC8vICBXZWJHTFJlbmRlclRhcmdldEN1YmUgd2lsbCBiZSBmbGlwcGVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxcblxcdFxcdFxcdFxcdC8vICBXZWJHTFJlbmRlclRhcmdldEN1YmUudGV4dHVyZSB3aWxsIGJlIGZsaXBwZWQgYmVjYXVzZSBpdCdzIGEgVGV4dHVyZSBhbmQgTk9UIGEgQ3ViZVRleHR1cmVcXG5cXHRcXHRcXHRcXHQvLyB0aGlzIGNoZWNrIG11c3QgYmUgaGFuZGxlZCBkaWZmZXJlbnRseSwgb3IgcmVtb3ZlZCBlbnRpcmVseSwgaWYgV2ViR0xSZW5kZXJUYXJnZXRDdWJlIHVzZXMgYSBDdWJlVGV4dHVyZSBpbiB0aGUgZnV0dXJlXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZmxpcEVudk1hcC52YWx1ZSA9ICggISAoIG1hdGVyaWFsLmVudk1hcCAmJiBtYXRlcmlhbC5lbnZNYXAuaXNDdWJlVGV4dHVyZSApICkgPyAxIDogLSAxO1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLnJlZmxlY3Rpdml0eS52YWx1ZSA9IG1hdGVyaWFsLnJlZmxlY3Rpdml0eTtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5yZWZyYWN0aW9uUmF0aW8udmFsdWUgPSBtYXRlcmlhbC5yZWZyYWN0aW9uUmF0aW87XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwubGlnaHRNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMubGlnaHRNYXAudmFsdWUgPSBtYXRlcmlhbC5saWdodE1hcDtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5saWdodE1hcEludGVuc2l0eS52YWx1ZSA9IG1hdGVyaWFsLmxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmFvTWFwICkge1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmFvTWFwLnZhbHVlID0gbWF0ZXJpYWwuYW9NYXA7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuYW9NYXBJbnRlbnNpdHkudmFsdWUgPSBtYXRlcmlhbC5hb01hcEludGVuc2l0eTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gdXYgcmVwZWF0IGFuZCBvZmZzZXQgc2V0dGluZyBwcmlvcml0aWVzXFxuXFx0XFx0XFx0Ly8gMS4gY29sb3IgbWFwXFxuXFx0XFx0XFx0Ly8gMi4gc3BlY3VsYXIgbWFwXFxuXFx0XFx0XFx0Ly8gMy4gbm9ybWFsIG1hcFxcblxcdFxcdFxcdC8vIDQuIGJ1bXAgbWFwXFxuXFx0XFx0XFx0Ly8gNS4gYWxwaGEgbWFwXFxuXFx0XFx0XFx0Ly8gNi4gZW1pc3NpdmUgbWFwXFxuXFxuXFx0XFx0XFx0dmFyIHV2U2NhbGVNYXA7XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5tYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLm1hcDtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5zcGVjdWxhck1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuc3BlY3VsYXJNYXA7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwICkge1xcblxcblxcdFxcdFxcdFxcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xcblxcblxcdFxcdFxcdFxcdHV2U2NhbGVNYXAgPSBtYXRlcmlhbC5ub3JtYWxNYXA7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYnVtcE1hcDtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5yb3VnaG5lc3NNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLnJvdWdobmVzc01hcDtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5tZXRhbG5lc3NNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLm1ldGFsbmVzc01hcDtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCBtYXRlcmlhbC5hbHBoYU1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1dlNjYWxlTWFwID0gbWF0ZXJpYWwuYWxwaGFNYXA7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggbWF0ZXJpYWwuZW1pc3NpdmVNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dXZTY2FsZU1hcCA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHV2U2NhbGVNYXAgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxcblxcdFxcdFxcdFxcdGlmICggdXZTY2FsZU1hcC5pc1dlYkdMUmVuZGVyVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHV2U2NhbGVNYXAgPSB1dlNjYWxlTWFwLnRleHR1cmU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggdXZTY2FsZU1hcC5tYXRyaXhBdXRvVXBkYXRlID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBvZmZzZXQgPSB1dlNjYWxlTWFwLm9mZnNldDtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcmVwZWF0ID0gdXZTY2FsZU1hcC5yZXBlYXQ7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHJvdGF0aW9uID0gdXZTY2FsZU1hcC5yb3RhdGlvbjtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgY2VudGVyID0gdXZTY2FsZU1hcC5jZW50ZXI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dXZTY2FsZU1hcC5tYXRyaXguc2V0VXZUcmFuc2Zvcm0oIG9mZnNldC54LCBvZmZzZXQueSwgcmVwZWF0LngsIHJlcGVhdC55LCByb3RhdGlvbiwgY2VudGVyLngsIGNlbnRlci55ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLnV2VHJhbnNmb3JtLnZhbHVlLmNvcHkoIHV2U2NhbGVNYXAubWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMaW5lKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xcblxcdFxcdFxcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNEYXNoKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0dW5pZm9ybXMuZGFzaFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZTtcXG5cXHRcXHRcXHR1bmlmb3Jtcy50b3RhbFNpemUudmFsdWUgPSBtYXRlcmlhbC5kYXNoU2l6ZSArIG1hdGVyaWFsLmdhcFNpemU7XFxuXFx0XFx0XFx0dW5pZm9ybXMuc2NhbGUudmFsdWUgPSBtYXRlcmlhbC5zY2FsZTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUG9pbnRzKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0dW5pZm9ybXMuZGlmZnVzZS52YWx1ZSA9IG1hdGVyaWFsLmNvbG9yO1xcblxcdFxcdFxcdHVuaWZvcm1zLm9wYWNpdHkudmFsdWUgPSBtYXRlcmlhbC5vcGFjaXR5O1xcblxcdFxcdFxcdHVuaWZvcm1zLnNpemUudmFsdWUgPSBtYXRlcmlhbC5zaXplICogX3BpeGVsUmF0aW87XFxuXFx0XFx0XFx0dW5pZm9ybXMuc2NhbGUudmFsdWUgPSBfaGVpZ2h0ICogMC41O1xcblxcblxcdFxcdFxcdHVuaWZvcm1zLm1hcC52YWx1ZSA9IG1hdGVyaWFsLm1hcDtcXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLm1hcCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG1hdGVyaWFsLm1hcC5tYXRyaXhBdXRvVXBkYXRlID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBvZmZzZXQgPSBtYXRlcmlhbC5tYXAub2Zmc2V0O1xcblxcdFxcdFxcdFxcdFxcdHZhciByZXBlYXQgPSBtYXRlcmlhbC5tYXAucmVwZWF0O1xcblxcdFxcdFxcdFxcdFxcdHZhciByb3RhdGlvbiA9IG1hdGVyaWFsLm1hcC5yb3RhdGlvbjtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgY2VudGVyID0gbWF0ZXJpYWwubWFwLmNlbnRlcjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtYXRlcmlhbC5tYXAubWF0cml4LnNldFV2VHJhbnNmb3JtKCBvZmZzZXQueCwgb2Zmc2V0LnksIHJlcGVhdC54LCByZXBlYXQueSwgcm90YXRpb24sIGNlbnRlci54LCBjZW50ZXIueSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy51dlRyYW5zZm9ybS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5tYXAubWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNGb2coIHVuaWZvcm1zLCBmb2cgKSB7XFxuXFxuXFx0XFx0XFx0dW5pZm9ybXMuZm9nQ29sb3IudmFsdWUgPSBmb2cuY29sb3I7XFxuXFxuXFx0XFx0XFx0aWYgKCBmb2cuaXNGb2cgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZm9nTmVhci52YWx1ZSA9IGZvZy5uZWFyO1xcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmZvZ0Zhci52YWx1ZSA9IGZvZy5mYXI7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggZm9nLmlzRm9nRXhwMiApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5mb2dEZW5zaXR5LnZhbHVlID0gZm9nLmRlbnNpdHk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiByZWZyZXNoVW5pZm9ybXNMYW1iZXJ0KCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5lbWlzc2l2ZU1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5lbWlzc2l2ZU1hcC52YWx1ZSA9IG1hdGVyaWFsLmVtaXNzaXZlTWFwO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUGhvbmcoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHR1bmlmb3Jtcy5zcGVjdWxhci52YWx1ZSA9IG1hdGVyaWFsLnNwZWN1bGFyO1xcblxcdFxcdFxcdHVuaWZvcm1zLnNoaW5pbmVzcy52YWx1ZSA9IE1hdGgubWF4KCBtYXRlcmlhbC5zaGluaW5lc3MsIDFlLTQgKTsgLy8gdG8gcHJldmVudCBwb3coIDAuMCwgMC4wIClcXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkge1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLm5vcm1hbE1hcC52YWx1ZSA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5ub3JtYWxTY2FsZSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc1Rvb24oIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHRyZWZyZXNoVW5pZm9ybXNQaG9uZyggdW5pZm9ybXMsIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5ncmFkaWVudE1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5ncmFkaWVudE1hcC52YWx1ZSA9IG1hdGVyaWFsLmdyYWRpZW50TWFwO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zU3RhbmRhcmQoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHR1bmlmb3Jtcy5yb3VnaG5lc3MudmFsdWUgPSBtYXRlcmlhbC5yb3VnaG5lc3M7XFxuXFx0XFx0XFx0dW5pZm9ybXMubWV0YWxuZXNzLnZhbHVlID0gbWF0ZXJpYWwubWV0YWxuZXNzO1xcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwucm91Z2huZXNzTWFwICkge1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLnJvdWdobmVzc01hcC52YWx1ZSA9IG1hdGVyaWFsLnJvdWdobmVzc01hcDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5tZXRhbG5lc3NNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMubWV0YWxuZXNzTWFwLnZhbHVlID0gbWF0ZXJpYWwubWV0YWxuZXNzTWFwO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmVtaXNzaXZlTWFwICkge1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmVtaXNzaXZlTWFwLnZhbHVlID0gbWF0ZXJpYWwuZW1pc3NpdmVNYXA7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLm5vcm1hbE1hcC52YWx1ZSA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5ub3JtYWxTY2FsZSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5lbnZNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly91bmlmb3Jtcy5lbnZNYXAudmFsdWUgPSBtYXRlcmlhbC5lbnZNYXA7IC8vIHBhcnQgb2YgdW5pZm9ybXMgY29tbW9uXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZW52TWFwSW50ZW5zaXR5LnZhbHVlID0gbWF0ZXJpYWwuZW52TWFwSW50ZW5zaXR5O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zUGh5c2ljYWwoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHR1bmlmb3Jtcy5jbGVhckNvYXQudmFsdWUgPSBtYXRlcmlhbC5jbGVhckNvYXQ7XFxuXFx0XFx0XFx0dW5pZm9ybXMuY2xlYXJDb2F0Um91Z2huZXNzLnZhbHVlID0gbWF0ZXJpYWwuY2xlYXJDb2F0Um91Z2huZXNzO1xcblxcblxcdFxcdFxcdHJlZnJlc2hVbmlmb3Jtc1N0YW5kYXJkKCB1bmlmb3JtcywgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gcmVmcmVzaFVuaWZvcm1zRGVwdGgoIHVuaWZvcm1zLCBtYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc0Rpc3RhbmNlKCB1bmlmb3JtcywgbWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50TWFwLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50TWFwO1xcblxcdFxcdFxcdFxcdHVuaWZvcm1zLmRpc3BsYWNlbWVudFNjYWxlLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGU7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50Qmlhcy52YWx1ZSA9IG1hdGVyaWFsLmRpc3BsYWNlbWVudEJpYXM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHVuaWZvcm1zLnJlZmVyZW5jZVBvc2l0aW9uLnZhbHVlLmNvcHkoIG1hdGVyaWFsLnJlZmVyZW5jZVBvc2l0aW9uICk7XFxuXFx0XFx0XFx0dW5pZm9ybXMubmVhckRpc3RhbmNlLnZhbHVlID0gbWF0ZXJpYWwubmVhckRpc3RhbmNlO1xcblxcdFxcdFxcdHVuaWZvcm1zLmZhckRpc3RhbmNlLnZhbHVlID0gbWF0ZXJpYWwuZmFyRGlzdGFuY2U7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHJlZnJlc2hVbmlmb3Jtc05vcm1hbCggdW5pZm9ybXMsIG1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwuYnVtcE1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5idW1wTWFwLnZhbHVlID0gbWF0ZXJpYWwuYnVtcE1hcDtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5idW1wU2NhbGUudmFsdWUgPSBtYXRlcmlhbC5idW1wU2NhbGU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggbWF0ZXJpYWwubm9ybWFsTWFwICkge1xcblxcblxcdFxcdFxcdFxcdHVuaWZvcm1zLm5vcm1hbE1hcC52YWx1ZSA9IG1hdGVyaWFsLm5vcm1hbE1hcDtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5ub3JtYWxTY2FsZS52YWx1ZS5jb3B5KCBtYXRlcmlhbC5ub3JtYWxTY2FsZSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIG1hdGVyaWFsLmRpc3BsYWNlbWVudE1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRNYXAudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXA7XFxuXFx0XFx0XFx0XFx0dW5pZm9ybXMuZGlzcGxhY2VtZW50U2NhbGUudmFsdWUgPSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRTY2FsZTtcXG5cXHRcXHRcXHRcXHR1bmlmb3Jtcy5kaXNwbGFjZW1lbnRCaWFzLnZhbHVlID0gbWF0ZXJpYWwuZGlzcGxhY2VtZW50QmlhcztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIElmIHVuaWZvcm1zIGFyZSBtYXJrZWQgYXMgY2xlYW4sIHRoZXkgZG9uJ3QgbmVlZCB0byBiZSBsb2FkZWQgdG8gdGhlIEdQVS5cXG5cXG5cXHRcXHRmdW5jdGlvbiBtYXJrVW5pZm9ybXNMaWdodHNOZWVkc1VwZGF0ZSggdW5pZm9ybXMsIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHVuaWZvcm1zLmFtYmllbnRMaWdodENvbG9yLm5lZWRzVXBkYXRlID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0dW5pZm9ybXMuZGlyZWN0aW9uYWxMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcXG5cXHRcXHRcXHR1bmlmb3Jtcy5wb2ludExpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xcblxcdFxcdFxcdHVuaWZvcm1zLnNwb3RMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcXG5cXHRcXHRcXHR1bmlmb3Jtcy5yZWN0QXJlYUxpZ2h0cy5uZWVkc1VwZGF0ZSA9IHZhbHVlO1xcblxcdFxcdFxcdHVuaWZvcm1zLmhlbWlzcGhlcmVMaWdodHMubmVlZHNVcGRhdGUgPSB2YWx1ZTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gR0wgc3RhdGUgc2V0dGluZ1xcblxcblxcdFxcdHRoaXMuc2V0RmFjZUN1bGxpbmcgPSBmdW5jdGlvbiAoIGN1bGxGYWNlLCBmcm9udEZhY2VEaXJlY3Rpb24gKSB7XFxuXFxuXFx0XFx0XFx0c3RhdGUuc2V0Q3VsbEZhY2UoIGN1bGxGYWNlICk7XFxuXFx0XFx0XFx0c3RhdGUuc2V0RmxpcFNpZGVkKCBmcm9udEZhY2VEaXJlY3Rpb24gPT09IEZyb250RmFjZURpcmVjdGlvbkNXICk7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBUZXh0dXJlc1xcblxcblxcdFxcdGZ1bmN0aW9uIGFsbG9jVGV4dHVyZVVuaXQoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRleHR1cmVVbml0ID0gX3VzZWRUZXh0dXJlVW5pdHM7XFxuXFxuXFx0XFx0XFx0aWYgKCB0ZXh0dXJlVW5pdCA+PSBjYXBhYmlsaXRpZXMubWF4VGV4dHVyZXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogVHJ5aW5nIHRvIHVzZSAnICsgdGV4dHVyZVVuaXQgKyAnIHRleHR1cmUgdW5pdHMgd2hpbGUgdGhpcyBHUFUgc3VwcG9ydHMgb25seSAnICsgY2FwYWJpbGl0aWVzLm1heFRleHR1cmVzICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdF91c2VkVGV4dHVyZVVuaXRzICs9IDE7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRleHR1cmVVbml0O1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLmFsbG9jVGV4dHVyZVVuaXQgPSBhbGxvY1RleHR1cmVVbml0O1xcblxcblxcdFxcdC8vIHRoaXMuc2V0VGV4dHVyZTJEID0gc2V0VGV4dHVyZTJEO1xcblxcdFxcdHRoaXMuc2V0VGV4dHVyZTJEID0gKCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHdhcm5lZCA9IGZhbHNlO1xcblxcblxcdFxcdFxcdC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBwZWVsIHRleHR1cmUudGV4dHVyZVxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBzZXRUZXh0dXJlMkQoIHRleHR1cmUsIHNsb3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlICYmIHRleHR1cmUuaXNXZWJHTFJlbmRlclRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoICEgd2FybmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggXFxcIlRIUkVFLldlYkdMUmVuZGVyZXIuc2V0VGV4dHVyZTJEOiBkb24ndCB1c2UgcmVuZGVyIHRhcmdldHMgYXMgdGV4dHVyZXMuIFVzZSB0aGVpciAudGV4dHVyZSBwcm9wZXJ0eSBpbnN0ZWFkLlxcXCIgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR3YXJuZWQgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlID0gdGV4dHVyZS50ZXh0dXJlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0ZXh0dXJlcy5zZXRUZXh0dXJlMkQoIHRleHR1cmUsIHNsb3QgKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSApO1xcblxcblxcdFxcdHRoaXMuc2V0VGV4dHVyZSA9ICggZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB3YXJuZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gc2V0VGV4dHVyZSggdGV4dHVyZSwgc2xvdCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoICEgd2FybmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggXFxcIlRIUkVFLldlYkdMUmVuZGVyZXI6IC5zZXRUZXh0dXJlIGlzIGRlcHJlY2F0ZWQsIHVzZSBzZXRUZXh0dXJlMkQgaW5zdGVhZC5cXFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0d2FybmVkID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dGV4dHVyZXMuc2V0VGV4dHVyZTJEKCB0ZXh0dXJlLCBzbG90ICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCkgKTtcXG5cXG5cXHRcXHR0aGlzLnNldFRleHR1cmVDdWJlID0gKCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHdhcm5lZCA9IGZhbHNlO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBzZXRUZXh0dXJlQ3ViZSggdGV4dHVyZSwgc2xvdCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eTogcGVlbCB0ZXh0dXJlLnRleHR1cmVcXG5cXHRcXHRcXHRcXHRpZiAoIHRleHR1cmUgJiYgdGV4dHVyZS5pc1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoICEgd2FybmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggXFxcIlRIUkVFLldlYkdMUmVuZGVyZXIuc2V0VGV4dHVyZUN1YmU6IGRvbid0IHVzZSBjdWJlIHJlbmRlciB0YXJnZXRzIGFzIHRleHR1cmVzLiBVc2UgdGhlaXIgLnRleHR1cmUgcHJvcGVydHkgaW5zdGVhZC5cXFwiICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0d2FybmVkID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZSA9IHRleHR1cmUudGV4dHVyZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gY3VycmVudGx5IHJlbHlpbmcgb24gdGhlIGZhY3QgdGhhdCBXZWJHTFJlbmRlclRhcmdldEN1YmUudGV4dHVyZSBpcyBhIFRleHR1cmUgYW5kIE5PVCBhIEN1YmVUZXh0dXJlXFxuXFx0XFx0XFx0XFx0Ly8gVE9ETzogdW5pZnkgdGhlc2UgY29kZSBwYXRoc1xcblxcdFxcdFxcdFxcdGlmICggKCB0ZXh0dXJlICYmIHRleHR1cmUuaXNDdWJlVGV4dHVyZSApIHx8XFxuXFx0XFx0XFx0XFx0XFx0KCBBcnJheS5pc0FycmF5KCB0ZXh0dXJlLmltYWdlICkgJiYgdGV4dHVyZS5pbWFnZS5sZW5ndGggPT09IDYgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBDb21wcmVzc2VkVGV4dHVyZSBjYW4gaGF2ZSBBcnJheSBpbiBpbWFnZSA6L1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHRoaXMgZnVuY3Rpb24gYWxvbmUgc2hvdWxkIHRha2UgY2FyZSBvZiBjdWJlIHRleHR1cmVzXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZXMuc2V0VGV4dHVyZUN1YmUoIHRleHR1cmUsIHNsb3QgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGFzc3VtZWQ6IHRleHR1cmUgcHJvcGVydHkgb2YgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXRDdWJlXFxuXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZXMuc2V0VGV4dHVyZUN1YmVEeW5hbWljKCB0ZXh0dXJlLCBzbG90ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpICk7XFxuXFxuXFx0XFx0dGhpcy5nZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIF9jdXJyZW50UmVuZGVyVGFyZ2V0O1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5zZXRSZW5kZXJUYXJnZXQgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHRfY3VycmVudFJlbmRlclRhcmdldCA9IHJlbmRlclRhcmdldDtcXG5cXG5cXHRcXHRcXHRpZiAoIHJlbmRlclRhcmdldCAmJiBwcm9wZXJ0aWVzLmdldCggcmVuZGVyVGFyZ2V0ICkuX193ZWJnbEZyYW1lYnVmZmVyID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGV4dHVyZXMuc2V0dXBSZW5kZXJUYXJnZXQoIHJlbmRlclRhcmdldCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgZnJhbWVidWZmZXIgPSBudWxsO1xcblxcdFxcdFxcdHZhciBpc0N1YmUgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRpZiAoIHJlbmRlclRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgX193ZWJnbEZyYW1lYnVmZmVyID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHJlbmRlclRhcmdldC5pc1dlYkdMUmVuZGVyVGFyZ2V0Q3ViZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmcmFtZWJ1ZmZlciA9IF9fd2ViZ2xGcmFtZWJ1ZmZlclsgcmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlIF07XFxuXFx0XFx0XFx0XFx0XFx0aXNDdWJlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdGZyYW1lYnVmZmVyID0gX193ZWJnbEZyYW1lYnVmZmVyO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRfY3VycmVudFZpZXdwb3J0LmNvcHkoIHJlbmRlclRhcmdldC52aWV3cG9ydCApO1xcblxcdFxcdFxcdFxcdF9jdXJyZW50U2Npc3Nvci5jb3B5KCByZW5kZXJUYXJnZXQuc2Npc3NvciApO1xcblxcdFxcdFxcdFxcdF9jdXJyZW50U2Npc3NvclRlc3QgPSByZW5kZXJUYXJnZXQuc2Npc3NvclRlc3Q7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRfY3VycmVudFZpZXdwb3J0LmNvcHkoIF92aWV3cG9ydCApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApO1xcblxcdFxcdFxcdFxcdF9jdXJyZW50U2Npc3Nvci5jb3B5KCBfc2Npc3NvciApLm11bHRpcGx5U2NhbGFyKCBfcGl4ZWxSYXRpbyApO1xcblxcdFxcdFxcdFxcdF9jdXJyZW50U2Npc3NvclRlc3QgPSBfc2Npc3NvclRlc3Q7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggX2N1cnJlbnRGcmFtZWJ1ZmZlciAhPT0gZnJhbWVidWZmZXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0X2dsLmJpbmRGcmFtZWJ1ZmZlciggX2dsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApO1xcblxcdFxcdFxcdFxcdF9jdXJyZW50RnJhbWVidWZmZXIgPSBmcmFtZWJ1ZmZlcjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0c3RhdGUudmlld3BvcnQoIF9jdXJyZW50Vmlld3BvcnQgKTtcXG5cXHRcXHRcXHRzdGF0ZS5zY2lzc29yKCBfY3VycmVudFNjaXNzb3IgKTtcXG5cXHRcXHRcXHRzdGF0ZS5zZXRTY2lzc29yVGVzdCggX2N1cnJlbnRTY2lzc29yVGVzdCApO1xcblxcblxcdFxcdFxcdGlmICggaXNDdWJlICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB0ZXh0dXJlUHJvcGVydGllcyA9IHByb3BlcnRpZXMuZ2V0KCByZW5kZXJUYXJnZXQudGV4dHVyZSApO1xcblxcdFxcdFxcdFxcdF9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRCggX2dsLkZSQU1FQlVGRkVSLCBfZ2wuQ09MT1JfQVRUQUNITUVOVDAsIF9nbC5URVhUVVJFX0NVQkVfTUFQX1BPU0lUSVZFX1ggKyByZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UsIHRleHR1cmVQcm9wZXJ0aWVzLl9fd2ViZ2xUZXh0dXJlLCByZW5kZXJUYXJnZXQuYWN0aXZlTWlwTWFwTGV2ZWwgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHMgPSBmdW5jdGlvbiAoIHJlbmRlclRhcmdldCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgYnVmZmVyICkge1xcblxcblxcdFxcdFxcdGlmICggISAoIHJlbmRlclRhcmdldCAmJiByZW5kZXJUYXJnZXQuaXNXZWJHTFJlbmRlclRhcmdldCApICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5XZWJHTFJlbmRlcmVyLnJlYWRSZW5kZXJUYXJnZXRQaXhlbHM6IHJlbmRlclRhcmdldCBpcyBub3QgVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGZyYW1lYnVmZmVyID0gcHJvcGVydGllcy5nZXQoIHJlbmRlclRhcmdldCApLl9fd2ViZ2xGcmFtZWJ1ZmZlcjtcXG5cXG5cXHRcXHRcXHRpZiAoIGZyYW1lYnVmZmVyICkge1xcblxcblxcdFxcdFxcdFxcdHZhciByZXN0b3JlID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBmcmFtZWJ1ZmZlciAhPT0gX2N1cnJlbnRGcmFtZWJ1ZmZlciApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRfZ2wuYmluZEZyYW1lYnVmZmVyKCBfZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmVzdG9yZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRyeSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRleHR1cmUgPSByZW5kZXJUYXJnZXQudGV4dHVyZTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdGV4dHVyZUZvcm1hdCA9IHRleHR1cmUuZm9ybWF0O1xcblxcdFxcdFxcdFxcdFxcdHZhciB0ZXh0dXJlVHlwZSA9IHRleHR1cmUudHlwZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRleHR1cmVGb3JtYXQgIT09IFJHQkFGb3JtYXQgJiYgdXRpbHMuY29udmVydCggdGV4dHVyZUZvcm1hdCApICE9PSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9GT1JNQVQgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFJHQkEgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBmb3JtYXQuJyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlVHlwZSAhPT0gVW5zaWduZWRCeXRlVHlwZSAmJiB1dGlscy5jb252ZXJ0KCB0ZXh0dXJlVHlwZSApICE9PSBfZ2wuZ2V0UGFyYW1ldGVyKCBfZ2wuSU1QTEVNRU5UQVRJT05fQ09MT1JfUkVBRF9UWVBFICkgJiYgLy8gSUUxMSwgRWRnZSBhbmQgQ2hyb21lIE1hYyA8IDUyICgjOTUxMylcXG5cXHRcXHRcXHRcXHRcXHRcXHQhICggdGV4dHVyZVR5cGUgPT09IEZsb2F0VHlwZSAmJiAoIGV4dGVuc2lvbnMuZ2V0KCAnT0VTX3RleHR1cmVfZmxvYXQnICkgfHwgZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb2xvcl9idWZmZXJfZmxvYXQnICkgKSApICYmIC8vIENocm9tZSBNYWMgPj0gNTIgYW5kIEZpcmVmb3hcXG5cXHRcXHRcXHRcXHRcXHRcXHQhICggdGV4dHVyZVR5cGUgPT09IEhhbGZGbG9hdFR5cGUgJiYgZXh0ZW5zaW9ucy5nZXQoICdFWFRfY29sb3JfYnVmZmVyX2hhbGZfZmxvYXQnICkgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuV2ViR0xSZW5kZXJlci5yZWFkUmVuZGVyVGFyZ2V0UGl4ZWxzOiByZW5kZXJUYXJnZXQgaXMgbm90IGluIFVuc2lnbmVkQnl0ZVR5cGUgb3IgaW1wbGVtZW50YXRpb24gZGVmaW5lZCB0eXBlLicgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmICggX2dsLmNoZWNrRnJhbWVidWZmZXJTdGF0dXMoIF9nbC5GUkFNRUJVRkZFUiApID09PSBfZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gdGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnQgZW5zdXJlcyB2YWxpZCByZWFkIHJlcXVlc3RzIChubyBvdXQtb2YtYm91bmRzIHBpeGVscywgc2VlICM4NjA0KVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggKCB4ID49IDAgJiYgeCA8PSAoIHJlbmRlclRhcmdldC53aWR0aCAtIHdpZHRoICkgKSAmJiAoIHkgPj0gMCAmJiB5IDw9ICggcmVuZGVyVGFyZ2V0LmhlaWdodCAtIGhlaWdodCApICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0X2dsLnJlYWRQaXhlbHMoIHgsIHksIHdpZHRoLCBoZWlnaHQsIHV0aWxzLmNvbnZlcnQoIHRleHR1cmVGb3JtYXQgKSwgdXRpbHMuY29udmVydCggdGV4dHVyZVR5cGUgKSwgYnVmZmVyICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLldlYkdMUmVuZGVyZXIucmVhZFJlbmRlclRhcmdldFBpeGVsczogcmVhZFBpeGVscyBmcm9tIHJlbmRlclRhcmdldCBmYWlsZWQuIEZyYW1lYnVmZmVyIG5vdCBjb21wbGV0ZS4nICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0gZmluYWxseSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCByZXN0b3JlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdF9nbC5iaW5kRnJhbWVidWZmZXIoIF9nbC5GUkFNRUJVRkZFUiwgX2N1cnJlbnRGcmFtZWJ1ZmZlciApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBGb2dFeHAyKCBjb2xvciwgZGVuc2l0eSApIHtcXG5cXG5cXHRcXHR0aGlzLm5hbWUgPSAnJztcXG5cXG5cXHRcXHR0aGlzLmNvbG9yID0gbmV3IENvbG9yKCBjb2xvciApO1xcblxcdFxcdHRoaXMuZGVuc2l0eSA9ICggZGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgPyBkZW5zaXR5IDogMC4wMDAyNTtcXG5cXG5cXHR9XFxuXFxuXFx0Rm9nRXhwMi5wcm90b3R5cGUuaXNGb2dFeHAyID0gdHJ1ZTtcXG5cXG5cXHRGb2dFeHAyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRyZXR1cm4gbmV3IEZvZ0V4cDIoIHRoaXMuY29sb3IuZ2V0SGV4KCksIHRoaXMuZGVuc2l0eSApO1xcblxcblxcdH07XFxuXFxuXFx0Rm9nRXhwMi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCAvKiBtZXRhICovICkge1xcblxcblxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0dHlwZTogJ0ZvZ0V4cDInLFxcblxcdFxcdFxcdGNvbG9yOiB0aGlzLmNvbG9yLmdldEhleCgpLFxcblxcdFxcdFxcdGRlbnNpdHk6IHRoaXMuZGVuc2l0eVxcblxcdFxcdH07XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gRm9nKCBjb2xvciwgbmVhciwgZmFyICkge1xcblxcblxcdFxcdHRoaXMubmFtZSA9ICcnO1xcblxcblxcdFxcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIGNvbG9yICk7XFxuXFxuXFx0XFx0dGhpcy5uZWFyID0gKCBuZWFyICE9PSB1bmRlZmluZWQgKSA/IG5lYXIgOiAxO1xcblxcdFxcdHRoaXMuZmFyID0gKCBmYXIgIT09IHVuZGVmaW5lZCApID8gZmFyIDogMTAwMDtcXG5cXG5cXHR9XFxuXFxuXFx0Rm9nLnByb3RvdHlwZS5pc0ZvZyA9IHRydWU7XFxuXFxuXFx0Rm9nLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRyZXR1cm4gbmV3IEZvZyggdGhpcy5jb2xvci5nZXRIZXgoKSwgdGhpcy5uZWFyLCB0aGlzLmZhciApO1xcblxcblxcdH07XFxuXFxuXFx0Rm9nLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoIC8qIG1ldGEgKi8gKSB7XFxuXFxuXFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHR0eXBlOiAnRm9nJyxcXG5cXHRcXHRcXHRjb2xvcjogdGhpcy5jb2xvci5nZXRIZXgoKSxcXG5cXHRcXHRcXHRuZWFyOiB0aGlzLm5lYXIsXFxuXFx0XFx0XFx0ZmFyOiB0aGlzLmZhclxcblxcdFxcdH07XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFNjZW5lKCkge1xcblxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnU2NlbmUnO1xcblxcblxcdFxcdHRoaXMuYmFja2dyb3VuZCA9IG51bGw7XFxuXFx0XFx0dGhpcy5mb2cgPSBudWxsO1xcblxcdFxcdHRoaXMub3ZlcnJpZGVNYXRlcmlhbCA9IG51bGw7XFxuXFxuXFx0XFx0dGhpcy5hdXRvVXBkYXRlID0gdHJ1ZTsgLy8gY2hlY2tlZCBieSB0aGUgcmVuZGVyZXJcXG5cXG5cXHR9XFxuXFxuXFx0U2NlbmUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogU2NlbmUsXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UsIHJlY3Vyc2l2ZSApIHtcXG5cXG5cXHRcXHRcXHRPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UsIHJlY3Vyc2l2ZSApO1xcblxcblxcdFxcdFxcdGlmICggc291cmNlLmJhY2tncm91bmQgIT09IG51bGwgKSB0aGlzLmJhY2tncm91bmQgPSBzb3VyY2UuYmFja2dyb3VuZC5jbG9uZSgpO1xcblxcdFxcdFxcdGlmICggc291cmNlLmZvZyAhPT0gbnVsbCApIHRoaXMuZm9nID0gc291cmNlLmZvZy5jbG9uZSgpO1xcblxcdFxcdFxcdGlmICggc291cmNlLm92ZXJyaWRlTWF0ZXJpYWwgIT09IG51bGwgKSB0aGlzLm92ZXJyaWRlTWF0ZXJpYWwgPSBzb3VyY2Uub3ZlcnJpZGVNYXRlcmlhbC5jbG9uZSgpO1xcblxcblxcdFxcdFxcdHRoaXMuYXV0b1VwZGF0ZSA9IHNvdXJjZS5hdXRvVXBkYXRlO1xcblxcdFxcdFxcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IHNvdXJjZS5tYXRyaXhBdXRvVXBkYXRlO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dG9KU09OOiBmdW5jdGlvbiAoIG1ldGEgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGRhdGEgPSBPYmplY3QzRC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMsIG1ldGEgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuYmFja2dyb3VuZCAhPT0gbnVsbCApIGRhdGEub2JqZWN0LmJhY2tncm91bmQgPSB0aGlzLmJhY2tncm91bmQudG9KU09OKCBtZXRhICk7XFxuXFx0XFx0XFx0aWYgKCB0aGlzLmZvZyAhPT0gbnVsbCApIGRhdGEub2JqZWN0LmZvZyA9IHRoaXMuZm9nLnRvSlNPTigpO1xcblxcblxcdFxcdFxcdHJldHVybiBkYXRhO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIExlbnNGbGFyZSggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApIHtcXG5cXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy5sZW5zRmxhcmVzID0gW107XFxuXFxuXFx0XFx0dGhpcy5wb3NpdGlvblNjcmVlbiA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dGhpcy5jdXN0b21VcGRhdGVDYWxsYmFjayA9IHVuZGVmaW5lZDtcXG5cXG5cXHRcXHRpZiAoIHRleHR1cmUgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmFkZCggdGV4dHVyZSwgc2l6ZSwgZGlzdGFuY2UsIGJsZW5kaW5nLCBjb2xvciApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0TGVuc0ZsYXJlLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IExlbnNGbGFyZSxcXG5cXG5cXHRcXHRpc0xlbnNGbGFyZTogdHJ1ZSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRcXHRPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnBvc2l0aW9uU2NyZWVuLmNvcHkoIHNvdXJjZS5wb3NpdGlvblNjcmVlbiApO1xcblxcdFxcdFxcdHRoaXMuY3VzdG9tVXBkYXRlQ2FsbGJhY2sgPSBzb3VyY2UuY3VzdG9tVXBkYXRlQ2FsbGJhY2s7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc291cmNlLmxlbnNGbGFyZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmxlbnNGbGFyZXMucHVzaCggc291cmNlLmxlbnNGbGFyZXNbIGkgXSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFkZDogZnVuY3Rpb24gKCB0ZXh0dXJlLCBzaXplLCBkaXN0YW5jZSwgYmxlbmRpbmcsIGNvbG9yLCBvcGFjaXR5ICkge1xcblxcblxcdFxcdFxcdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkgc2l6ZSA9IC0gMTtcXG5cXHRcXHRcXHRpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XFxuXFx0XFx0XFx0aWYgKCBvcGFjaXR5ID09PSB1bmRlZmluZWQgKSBvcGFjaXR5ID0gMTtcXG5cXHRcXHRcXHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTtcXG5cXHRcXHRcXHRpZiAoIGJsZW5kaW5nID09PSB1bmRlZmluZWQgKSBibGVuZGluZyA9IE5vcm1hbEJsZW5kaW5nO1xcblxcblxcdFxcdFxcdGRpc3RhbmNlID0gTWF0aC5taW4oIGRpc3RhbmNlLCBNYXRoLm1heCggMCwgZGlzdGFuY2UgKSApO1xcblxcblxcdFxcdFxcdHRoaXMubGVuc0ZsYXJlcy5wdXNoKCB7XFxuXFx0XFx0XFx0XFx0dGV4dHVyZTogdGV4dHVyZSxcXHQvLyBUSFJFRS5UZXh0dXJlXFxuXFx0XFx0XFx0XFx0c2l6ZTogc2l6ZSwgXFx0XFx0Ly8gc2l6ZSBpbiBwaXhlbHMgKC0xID0gdXNlIHRleHR1cmUud2lkdGgpXFxuXFx0XFx0XFx0XFx0ZGlzdGFuY2U6IGRpc3RhbmNlLCBcXHQvLyBkaXN0YW5jZSAoMC0xKSBmcm9tIGxpZ2h0IHNvdXJjZSAoMD1hdCBsaWdodCBzb3VyY2UpXFxuXFx0XFx0XFx0XFx0eDogMCwgeTogMCwgejogMCxcXHQvLyBzY3JlZW4gcG9zaXRpb24gKC0xID0+IDEpIHogPSAwIGlzIGluIGZyb250IHogPSAxIGlzIGJhY2tcXG5cXHRcXHRcXHRcXHRzY2FsZTogMSwgXFx0XFx0Ly8gc2NhbGVcXG5cXHRcXHRcXHRcXHRyb3RhdGlvbjogMCwgXFx0XFx0Ly8gcm90YXRpb25cXG5cXHRcXHRcXHRcXHRvcGFjaXR5OiBvcGFjaXR5LFxcdC8vIG9wYWNpdHlcXG5cXHRcXHRcXHRcXHRjb2xvcjogY29sb3IsXFx0XFx0Ly8gY29sb3JcXG5cXHRcXHRcXHRcXHRibGVuZGluZzogYmxlbmRpbmdcXHQvLyBibGVuZGluZ1xcblxcdFxcdFxcdH0gKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8qXFxuXFx0XFx0ICogVXBkYXRlIGxlbnMgZmxhcmVzIHVwZGF0ZSBwb3NpdGlvbnMgb24gYWxsIGZsYXJlcyBiYXNlZCBvbiB0aGUgc2NyZWVuIHBvc2l0aW9uXFxuXFx0XFx0ICogU2V0IG15TGVuc0ZsYXJlLmN1c3RvbVVwZGF0ZUNhbGxiYWNrIHRvIGFsdGVyIHRoZSBmbGFyZXMgaW4geW91ciBwcm9qZWN0IHNwZWNpZmljIHdheS5cXG5cXHRcXHQgKi9cXG5cXG5cXHRcXHR1cGRhdGVMZW5zRmxhcmVzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGYsIGZsID0gdGhpcy5sZW5zRmxhcmVzLmxlbmd0aDtcXG5cXHRcXHRcXHR2YXIgZmxhcmU7XFxuXFx0XFx0XFx0dmFyIHZlY1ggPSAtIHRoaXMucG9zaXRpb25TY3JlZW4ueCAqIDI7XFxuXFx0XFx0XFx0dmFyIHZlY1kgPSAtIHRoaXMucG9zaXRpb25TY3JlZW4ueSAqIDI7XFxuXFxuXFx0XFx0XFx0Zm9yICggZiA9IDA7IGYgPCBmbDsgZiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRmbGFyZSA9IHRoaXMubGVuc0ZsYXJlc1sgZiBdO1xcblxcblxcdFxcdFxcdFxcdGZsYXJlLnggPSB0aGlzLnBvc2l0aW9uU2NyZWVuLnggKyB2ZWNYICogZmxhcmUuZGlzdGFuY2U7XFxuXFx0XFx0XFx0XFx0ZmxhcmUueSA9IHRoaXMucG9zaXRpb25TY3JlZW4ueSArIHZlY1kgKiBmbGFyZS5kaXN0YW5jZTtcXG5cXG5cXHRcXHRcXHRcXHRmbGFyZS53YW50ZWRSb3RhdGlvbiA9IGZsYXJlLnggKiBNYXRoLlBJICogMC4yNTtcXG5cXHRcXHRcXHRcXHRmbGFyZS5yb3RhdGlvbiArPSAoIGZsYXJlLndhbnRlZFJvdGF0aW9uIC0gZmxhcmUucm90YXRpb24gKSAqIDAuMjU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKlxcblxcdCAqIHBhcmFtZXRlcnMgPSB7XFxuXFx0ICogIGNvbG9yOiA8aGV4PixcXG5cXHQgKiAgb3BhY2l0eTogPGZsb2F0PixcXG5cXHQgKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqXFxuXFx0ICpcXHR1dk9mZnNldDogbmV3IFRIUkVFLlZlY3RvcjIoKSxcXG5cXHQgKlxcdHV2U2NhbGU6IG5ldyBUSFJFRS5WZWN0b3IyKClcXG5cXHQgKiB9XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gU3ByaXRlTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XFxuXFxuXFx0XFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdTcHJpdGVNYXRlcmlhbCc7XFxuXFxuXFx0XFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTtcXG5cXHRcXHR0aGlzLm1hcCA9IG51bGw7XFxuXFxuXFx0XFx0dGhpcy5yb3RhdGlvbiA9IDA7XFxuXFxuXFx0XFx0dGhpcy5mb2cgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XFxuXFxuXFx0fVxcblxcblxcdFNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xcblxcdFNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNwcml0ZU1hdGVyaWFsO1xcblxcdFNwcml0ZU1hdGVyaWFsLnByb3RvdHlwZS5pc1Nwcml0ZU1hdGVyaWFsID0gdHJ1ZTtcXG5cXG5cXHRTcHJpdGVNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XFxuXFx0XFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xcblxcblxcdFxcdHRoaXMucm90YXRpb24gPSBzb3VyY2Uucm90YXRpb247XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gU3ByaXRlKCBtYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1Nwcml0ZSc7XFxuXFxuXFx0XFx0dGhpcy5tYXRlcmlhbCA9ICggbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCApID8gbWF0ZXJpYWwgOiBuZXcgU3ByaXRlTWF0ZXJpYWwoKTtcXG5cXG5cXHR9XFxuXFxuXFx0U3ByaXRlLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IFNwcml0ZSxcXG5cXG5cXHRcXHRpc1Nwcml0ZTogdHJ1ZSxcXG5cXG5cXHRcXHRyYXljYXN0OiAoIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgaW50ZXJzZWN0UG9pbnQgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciB3b3JsZFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgd29ybGRTY2FsZSA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcXG5cXG5cXHRcXHRcXHRcXHR3b3JsZFBvc2l0aW9uLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5tYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdFxcdHJheWNhc3Rlci5yYXkuY2xvc2VzdFBvaW50VG9Qb2ludCggd29ybGRQb3NpdGlvbiwgaW50ZXJzZWN0UG9pbnQgKTtcXG5cXG5cXHRcXHRcXHRcXHR3b3JsZFNjYWxlLnNldEZyb21NYXRyaXhTY2FsZSggdGhpcy5tYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdFxcdHZhciBndWVzc1NpemVTcSA9IHdvcmxkU2NhbGUueCAqIHdvcmxkU2NhbGUueSAvIDQ7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB3b3JsZFBvc2l0aW9uLmRpc3RhbmNlVG9TcXVhcmVkKCBpbnRlcnNlY3RQb2ludCApID4gZ3Vlc3NTaXplU3EgKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJzZWN0UG9pbnQgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdGludGVyc2VjdHMucHVzaCgge1xcblxcblxcdFxcdFxcdFxcdFxcdGRpc3RhbmNlOiBkaXN0YW5jZSxcXG5cXHRcXHRcXHRcXHRcXHRwb2ludDogaW50ZXJzZWN0UG9pbnQuY2xvbmUoKSxcXG5cXHRcXHRcXHRcXHRcXHRmYWNlOiBudWxsLFxcblxcdFxcdFxcdFxcdFxcdG9iamVjdDogdGhpc1xcblxcblxcdFxcdFxcdFxcdH0gKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSApLFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gTE9EKCkge1xcblxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnTE9EJztcXG5cXG5cXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcywge1xcblxcdFxcdFxcdGxldmVsczoge1xcblxcdFxcdFxcdFxcdGVudW1lcmFibGU6IHRydWUsXFxuXFx0XFx0XFx0XFx0dmFsdWU6IFtdXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXG5cXHR9XFxuXFxuXFx0TE9ELnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IExPRCxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRcXHRPYmplY3QzRC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UsIGZhbHNlICk7XFxuXFxuXFx0XFx0XFx0dmFyIGxldmVscyA9IHNvdXJjZS5sZXZlbHM7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGxldmVsID0gbGV2ZWxzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5hZGRMZXZlbCggbGV2ZWwub2JqZWN0LmNsb25lKCksIGxldmVsLmRpc3RhbmNlICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YWRkTGV2ZWw6IGZ1bmN0aW9uICggb2JqZWN0LCBkaXN0YW5jZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGRpc3RhbmNlID09PSB1bmRlZmluZWQgKSBkaXN0YW5jZSA9IDA7XFxuXFxuXFx0XFx0XFx0ZGlzdGFuY2UgPSBNYXRoLmFicyggZGlzdGFuY2UgKTtcXG5cXG5cXHRcXHRcXHR2YXIgbGV2ZWxzID0gdGhpcy5sZXZlbHM7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGwgPSAwOyBsIDwgbGV2ZWxzLmxlbmd0aDsgbCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGRpc3RhbmNlIDwgbGV2ZWxzWyBsIF0uZGlzdGFuY2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRsZXZlbHMuc3BsaWNlKCBsLCAwLCB7IGRpc3RhbmNlOiBkaXN0YW5jZSwgb2JqZWN0OiBvYmplY3QgfSApO1xcblxcblxcdFxcdFxcdHRoaXMuYWRkKCBvYmplY3QgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldE9iamVjdEZvckRpc3RhbmNlOiBmdW5jdGlvbiAoIGRpc3RhbmNlICkge1xcblxcblxcdFxcdFxcdHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDEsIGwgPSBsZXZlbHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGRpc3RhbmNlIDwgbGV2ZWxzWyBpIF0uZGlzdGFuY2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gbGV2ZWxzWyBpIC0gMSBdLm9iamVjdDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHJheWNhc3Q6ICggZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBtYXRyaXhQb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcXG5cXG5cXHRcXHRcXHRcXHRtYXRyaXhQb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZGlzdGFuY2UgPSByYXljYXN0ZXIucmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBtYXRyaXhQb3NpdGlvbiApO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuZ2V0T2JqZWN0Rm9yRGlzdGFuY2UoIGRpc3RhbmNlICkucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCkgKSxcXG5cXG5cXHRcXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSggY2FtZXJhICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBsZXZlbHMgPSB0aGlzLmxldmVscztcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGxldmVscy5sZW5ndGggPiAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHYxLnNldEZyb21NYXRyaXhQb3NpdGlvbiggY2FtZXJhLm1hdHJpeFdvcmxkICk7XFxuXFx0XFx0XFx0XFx0XFx0djIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGRpc3RhbmNlID0gdjEuZGlzdGFuY2VUbyggdjIgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRsZXZlbHNbIDAgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAxLCBsID0gbGV2ZWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkaXN0YW5jZSA+PSBsZXZlbHNbIGkgXS5kaXN0YW5jZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRsZXZlbHNbIGkgLSAxIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRsZXZlbHNbIGkgXS5vYmplY3QudmlzaWJsZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0bGV2ZWxzWyBpIF0ub2JqZWN0LnZpc2libGUgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSgpLFxcblxcblxcdFxcdHRvSlNPTjogZnVuY3Rpb24gKCBtZXRhICkge1xcblxcblxcdFxcdFxcdHZhciBkYXRhID0gT2JqZWN0M0QucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzLCBtZXRhICk7XFxuXFxuXFx0XFx0XFx0ZGF0YS5vYmplY3QubGV2ZWxzID0gW107XFxuXFxuXFx0XFx0XFx0dmFyIGxldmVscyA9IHRoaXMubGV2ZWxzO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGxldmVscy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBsZXZlbCA9IGxldmVsc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdGRhdGEub2JqZWN0LmxldmVscy5wdXNoKCB7XFxuXFx0XFx0XFx0XFx0XFx0b2JqZWN0OiBsZXZlbC5vYmplY3QudXVpZCxcXG5cXHRcXHRcXHRcXHRcXHRkaXN0YW5jZTogbGV2ZWwuZGlzdGFuY2VcXG5cXHRcXHRcXHRcXHR9ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBkYXRhO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtaWthZWwgZW10aW5nZXIgLyBodHRwOi8vZ29tby5zZS9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqIEBhdXRob3IgbWljaGFlbCBndWVycmVybyAvIGh0dHA6Ly9yZWFsaXR5bWVsdGRvd24uY29tXFxuXFx0ICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gU2tlbGV0b24oIGJvbmVzLCBib25lSW52ZXJzZXMgKSB7XFxuXFxuXFx0XFx0Ly8gY29weSB0aGUgYm9uZSBhcnJheVxcblxcblxcdFxcdGJvbmVzID0gYm9uZXMgfHwgW107XFxuXFxuXFx0XFx0dGhpcy5ib25lcyA9IGJvbmVzLnNsaWNlKCAwICk7XFxuXFx0XFx0dGhpcy5ib25lTWF0cmljZXMgPSBuZXcgRmxvYXQzMkFycmF5KCB0aGlzLmJvbmVzLmxlbmd0aCAqIDE2ICk7XFxuXFxuXFx0XFx0Ly8gdXNlIHRoZSBzdXBwbGllZCBib25lIGludmVyc2VzIG9yIGNhbGN1bGF0ZSB0aGUgaW52ZXJzZXNcXG5cXG5cXHRcXHRpZiAoIGJvbmVJbnZlcnNlcyA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdHRoaXMuY2FsY3VsYXRlSW52ZXJzZXMoKTtcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5ib25lcy5sZW5ndGggPT09IGJvbmVJbnZlcnNlcy5sZW5ndGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5ib25lSW52ZXJzZXMgPSBib25lSW52ZXJzZXMuc2xpY2UoIDAgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNrZWxldG9uIGJvbmVJbnZlcnNlcyBpcyB0aGUgd3JvbmcgbGVuZ3RoLicgKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuYm9uZUludmVyc2VzLnB1c2goIG5ldyBNYXRyaXg0KCkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggU2tlbGV0b24ucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0Y2FsY3VsYXRlSW52ZXJzZXM6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmJvbmVJbnZlcnNlcyA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBpbnZlcnNlID0gbmV3IE1hdHJpeDQoKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHRoaXMuYm9uZXNbIGkgXSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpbnZlcnNlLmdldEludmVyc2UoIHRoaXMuYm9uZXNbIGkgXS5tYXRyaXhXb3JsZCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmJvbmVJbnZlcnNlcy5wdXNoKCBpbnZlcnNlICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cG9zZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBib25lLCBpLCBpbDtcXG5cXG5cXHRcXHRcXHQvLyByZWNvdmVyIHRoZSBiaW5kLXRpbWUgd29ybGQgbWF0cmljZXNcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBib25lICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGJvbmUubWF0cml4V29ybGQuZ2V0SW52ZXJzZSggdGhpcy5ib25lSW52ZXJzZXNbIGkgXSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gY29tcHV0ZSB0aGUgbG9jYWwgbWF0cmljZXMsIHBvc2l0aW9ucywgcm90YXRpb25zIGFuZCBzY2FsZXNcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGJvbmUgPSB0aGlzLmJvbmVzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBib25lICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggYm9uZS5wYXJlbnQgJiYgYm9uZS5wYXJlbnQuaXNCb25lICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJvbmUubWF0cml4LmdldEludmVyc2UoIGJvbmUucGFyZW50Lm1hdHJpeFdvcmxkICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Ym9uZS5tYXRyaXgubXVsdGlwbHkoIGJvbmUubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJvbmUubWF0cml4LmNvcHkoIGJvbmUubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ym9uZS5tYXRyaXguZGVjb21wb3NlKCBib25lLnBvc2l0aW9uLCBib25lLnF1YXRlcm5pb24sIGJvbmUuc2NhbGUgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dXBkYXRlOiAoIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgb2Zmc2V0TWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcXG5cXHRcXHRcXHR2YXIgaWRlbnRpdHlNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGJvbmVzID0gdGhpcy5ib25lcztcXG5cXHRcXHRcXHRcXHR2YXIgYm9uZUludmVyc2VzID0gdGhpcy5ib25lSW52ZXJzZXM7XFxuXFx0XFx0XFx0XFx0dmFyIGJvbmVNYXRyaWNlcyA9IHRoaXMuYm9uZU1hdHJpY2VzO1xcblxcdFxcdFxcdFxcdHZhciBib25lVGV4dHVyZSA9IHRoaXMuYm9uZVRleHR1cmU7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gZmxhdHRlbiBib25lIG1hdHJpY2VzIHRvIGFycmF5XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGNvbXB1dGUgdGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBjdXJyZW50IGFuZCB0aGUgb3JpZ2luYWwgdHJhbnNmb3JtXFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG1hdHJpeCA9IGJvbmVzWyBpIF0gPyBib25lc1sgaSBdLm1hdHJpeFdvcmxkIDogaWRlbnRpdHlNYXRyaXg7XFxuXFxuXFx0XFx0XFx0XFx0XFx0b2Zmc2V0TWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeCwgYm9uZUludmVyc2VzWyBpIF0gKTtcXG5cXHRcXHRcXHRcXHRcXHRvZmZzZXRNYXRyaXgudG9BcnJheSggYm9uZU1hdHJpY2VzLCBpICogMTYgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBib25lVGV4dHVyZSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGJvbmVUZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9ICkoKSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgU2tlbGV0b24oIHRoaXMuYm9uZXMsIHRoaXMuYm9uZUludmVyc2VzICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1pa2FlbCBlbXRpbmdlciAvIGh0dHA6Ly9nb21vLnNlL1xcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICogQGF1dGhvciBpa2VyciAvIGh0dHA6Ly92ZXJvbGQuY29tXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gQm9uZSgpIHtcXG5cXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0JvbmUnO1xcblxcblxcdH1cXG5cXG5cXHRCb25lLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IEJvbmUsXFxuXFxuXFx0XFx0aXNCb25lOiB0cnVlXFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbWlrYWVsIGVtdGluZ2VyIC8gaHR0cDovL2dvbW8uc2UvXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKiBAYXV0aG9yIGlrZXJyIC8gaHR0cDovL3Zlcm9sZC5jb21cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBTa2lubmVkTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xcblxcblxcdFxcdE1lc2guY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1NraW5uZWRNZXNoJztcXG5cXG5cXHRcXHR0aGlzLmJpbmRNb2RlID0gJ2F0dGFjaGVkJztcXG5cXHRcXHR0aGlzLmJpbmRNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xcblxcdFxcdHRoaXMuYmluZE1hdHJpeEludmVyc2UgPSBuZXcgTWF0cml4NCgpO1xcblxcblxcdFxcdHZhciBib25lcyA9IHRoaXMuaW5pdEJvbmVzKCk7XFxuXFx0XFx0dmFyIHNrZWxldG9uID0gbmV3IFNrZWxldG9uKCBib25lcyApO1xcblxcblxcdFxcdHRoaXMuYmluZCggc2tlbGV0b24sIHRoaXMubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHR0aGlzLm5vcm1hbGl6ZVNraW5XZWlnaHRzKCk7XFxuXFxuXFx0fVxcblxcblxcdFNraW5uZWRNZXNoLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE1lc2gucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogU2tpbm5lZE1lc2gsXFxuXFxuXFx0XFx0aXNTa2lubmVkTWVzaDogdHJ1ZSxcXG5cXG5cXHRcXHRpbml0Qm9uZXM6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgYm9uZXMgPSBbXSwgYm9uZSwgZ2JvbmU7XFxuXFx0XFx0XFx0dmFyIGksIGlsO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5nZW9tZXRyeSAmJiB0aGlzLmdlb21ldHJ5LmJvbmVzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gZmlyc3QsIGNyZWF0ZSBhcnJheSBvZiAnQm9uZScgb2JqZWN0cyBmcm9tIGdlb21ldHJ5IGRhdGFcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmdlb21ldHJ5LmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGNyZWF0ZSBuZXcgJ0JvbmUnIG9iamVjdFxcblxcblxcdFxcdFxcdFxcdFxcdGJvbmUgPSBuZXcgQm9uZSgpO1xcblxcdFxcdFxcdFxcdFxcdGJvbmVzLnB1c2goIGJvbmUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBhcHBseSB2YWx1ZXNcXG5cXG5cXHRcXHRcXHRcXHRcXHRib25lLm5hbWUgPSBnYm9uZS5uYW1lO1xcblxcdFxcdFxcdFxcdFxcdGJvbmUucG9zaXRpb24uZnJvbUFycmF5KCBnYm9uZS5wb3MgKTtcXG5cXHRcXHRcXHRcXHRcXHRib25lLnF1YXRlcm5pb24uZnJvbUFycmF5KCBnYm9uZS5yb3RxICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBnYm9uZS5zY2wgIT09IHVuZGVmaW5lZCApIGJvbmUuc2NhbGUuZnJvbUFycmF5KCBnYm9uZS5zY2wgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gc2Vjb25kLCBjcmVhdGUgYm9uZSBoaWVyYXJjaHlcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSB0aGlzLmdlb21ldHJ5LmJvbmVzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGdib25lID0gdGhpcy5nZW9tZXRyeS5ib25lc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggKCBnYm9uZS5wYXJlbnQgIT09IC0gMSApICYmICggZ2JvbmUucGFyZW50ICE9PSBudWxsICkgJiYgKCBib25lc1sgZ2JvbmUucGFyZW50IF0gIT09IHVuZGVmaW5lZCApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHN1YnNlcXVlbnQgYm9uZXMgaW4gdGhlIGhpZXJhcmNoeVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJvbmVzWyBnYm9uZS5wYXJlbnQgXS5hZGQoIGJvbmVzWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHRvcG1vc3QgYm9uZSwgaW1tZWRpYXRlIGNoaWxkIG9mIHRoZSBza2lubmVkIG1lc2hcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLmFkZCggYm9uZXNbIGkgXSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIG5vdyB0aGUgYm9uZXMgYXJlIHBhcnQgb2YgdGhlIHNjZW5lIGdyYXBoIGFuZCBjaGlsZHJlbiBvZiB0aGUgc2tpbm5lZCBtZXNoLlxcblxcdFxcdFxcdC8vIGxldCdzIHVwZGF0ZSB0aGUgY29ycmVzcG9uZGluZyBtYXRyaWNlc1xcblxcblxcdFxcdFxcdHRoaXMudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gYm9uZXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRiaW5kOiBmdW5jdGlvbiAoIHNrZWxldG9uLCBiaW5kTWF0cml4ICkge1xcblxcblxcdFxcdFxcdHRoaXMuc2tlbGV0b24gPSBza2VsZXRvbjtcXG5cXG5cXHRcXHRcXHRpZiAoIGJpbmRNYXRyaXggPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5za2VsZXRvbi5jYWxjdWxhdGVJbnZlcnNlcygpO1xcblxcblxcdFxcdFxcdFxcdGJpbmRNYXRyaXggPSB0aGlzLm1hdHJpeFdvcmxkO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmJpbmRNYXRyaXguY29weSggYmluZE1hdHJpeCApO1xcblxcdFxcdFxcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggYmluZE1hdHJpeCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cG9zZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMuc2tlbGV0b24ucG9zZSgpO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bm9ybWFsaXplU2tpbldlaWdodHM6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgc2NhbGUsIGk7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmdlb21ldHJ5ICYmIHRoaXMuZ2VvbWV0cnkuaXNHZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IHRoaXMuZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBzdyA9IHRoaXMuZ2VvbWV0cnkuc2tpbldlaWdodHNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzY2FsZSA9IDEuMCAvIHN3Lm1hbmhhdHRhbkxlbmd0aCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggc2NhbGUgIT09IEluZmluaXR5ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHN3Lm11bHRpcGx5U2NhbGFyKCBzY2FsZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0c3cuc2V0KCAxLCAwLCAwLCAwICk7IC8vIGRvIHNvbWV0aGluZyByZWFzb25hYmxlXFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCB0aGlzLmdlb21ldHJ5ICYmIHRoaXMuZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdmVjID0gbmV3IFZlY3RvcjQoKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgc2tpbldlaWdodCA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5za2luV2VpZ2h0O1xcblxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgc2tpbldlaWdodC5jb3VudDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZWMueCA9IHNraW5XZWlnaHQuZ2V0WCggaSApO1xcblxcdFxcdFxcdFxcdFxcdHZlYy55ID0gc2tpbldlaWdodC5nZXRZKCBpICk7XFxuXFx0XFx0XFx0XFx0XFx0dmVjLnogPSBza2luV2VpZ2h0LmdldFooIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZWMudyA9IHNraW5XZWlnaHQuZ2V0VyggaSApO1xcblxcblxcdFxcdFxcdFxcdFxcdHNjYWxlID0gMS4wIC8gdmVjLm1hbmhhdHRhbkxlbmd0aCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggc2NhbGUgIT09IEluZmluaXR5ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZlYy5tdWx0aXBseVNjYWxhciggc2NhbGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZlYy5zZXQoIDEsIDAsIDAsIDAgKTsgLy8gZG8gc29tZXRoaW5nIHJlYXNvbmFibGVcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2tpbldlaWdodC5zZXRYWVpXKCBpLCB2ZWMueCwgdmVjLnksIHZlYy56LCB2ZWMudyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR1cGRhdGVNYXRyaXhXb3JsZDogZnVuY3Rpb24gKCBmb3JjZSApIHtcXG5cXG5cXHRcXHRcXHRNZXNoLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5iaW5kTW9kZSA9PT0gJ2F0dGFjaGVkJyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmJpbmRNYXRyaXhJbnZlcnNlLmdldEludmVyc2UoIHRoaXMubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCB0aGlzLmJpbmRNb2RlID09PSAnZGV0YWNoZWQnICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuYmluZE1hdHJpeEludmVyc2UuZ2V0SW52ZXJzZSggdGhpcy5iaW5kTWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Ta2lubmVkTWVzaDogVW5yZWNvZ25pemVkIGJpbmRNb2RlOiAnICsgdGhpcy5iaW5kTW9kZSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqXFxuXFx0ICogcGFyYW1ldGVycyA9IHtcXG5cXHQgKiAgY29sb3I6IDxoZXg+LFxcblxcdCAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxcblxcdCAqXFxuXFx0ICogIGxpbmV3aWR0aDogPGZsb2F0PixcXG5cXHQgKiAgbGluZWNhcDogXFxcInJvdW5kXFxcIixcXG5cXHQgKiAgbGluZWpvaW46IFxcXCJyb3VuZFxcXCJcXG5cXHQgKiB9XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gTGluZUJhc2ljTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XFxuXFxuXFx0XFx0TWF0ZXJpYWwuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdMaW5lQmFzaWNNYXRlcmlhbCc7XFxuXFxuXFx0XFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTtcXG5cXG5cXHRcXHR0aGlzLmxpbmV3aWR0aCA9IDE7XFxuXFx0XFx0dGhpcy5saW5lY2FwID0gJ3JvdW5kJztcXG5cXHRcXHR0aGlzLmxpbmVqb2luID0gJ3JvdW5kJztcXG5cXG5cXHRcXHR0aGlzLmxpZ2h0cyA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XFxuXFxuXFx0fVxcblxcblxcdExpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xcblxcdExpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVCYXNpY01hdGVyaWFsO1xcblxcblxcdExpbmVCYXNpY01hdGVyaWFsLnByb3RvdHlwZS5pc0xpbmVCYXNpY01hdGVyaWFsID0gdHJ1ZTtcXG5cXG5cXHRMaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdHRoaXMuY29sb3IuY29weSggc291cmNlLmNvbG9yICk7XFxuXFxuXFx0XFx0dGhpcy5saW5ld2lkdGggPSBzb3VyY2UubGluZXdpZHRoO1xcblxcdFxcdHRoaXMubGluZWNhcCA9IHNvdXJjZS5saW5lY2FwO1xcblxcdFxcdHRoaXMubGluZWpvaW4gPSBzb3VyY2UubGluZWpvaW47XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIExpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCwgbW9kZSApIHtcXG5cXG5cXHRcXHRpZiAoIG1vZGUgPT09IDEgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGluZTogcGFyYW1ldGVyIFRIUkVFLkxpbmVQaWVjZXMgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gQ3JlYXRlZCBUSFJFRS5MaW5lU2VnbWVudHMgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBMaW5lU2VnbWVudHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0xpbmUnO1xcblxcblxcdFxcdHRoaXMuZ2VvbWV0cnkgPSBnZW9tZXRyeSAhPT0gdW5kZWZpbmVkID8gZ2VvbWV0cnkgOiBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXG5cXHRcXHR0aGlzLm1hdGVyaWFsID0gbWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG1hdGVyaWFsIDogbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBNYXRoLnJhbmRvbSgpICogMHhmZmZmZmYgfSApO1xcblxcblxcdH1cXG5cXG5cXHRMaW5lLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IExpbmUsXFxuXFxuXFx0XFx0aXNMaW5lOiB0cnVlLFxcblxcblxcdFxcdHJheWNhc3Q6ICggZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBpbnZlcnNlTWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcXG5cXHRcXHRcXHR2YXIgcmF5ID0gbmV3IFJheSgpO1xcblxcdFxcdFxcdHZhciBzcGhlcmUgPSBuZXcgU3BoZXJlKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHJheWNhc3QoIHJheWNhc3RlciwgaW50ZXJzZWN0cyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcHJlY2lzaW9uID0gcmF5Y2FzdGVyLmxpbmVQcmVjaXNpb247XFxuXFx0XFx0XFx0XFx0dmFyIHByZWNpc2lvblNxID0gcHJlY2lzaW9uICogcHJlY2lzaW9uO1xcblxcblxcdFxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XFxuXFx0XFx0XFx0XFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBDaGVja2luZyBib3VuZGluZ1NwaGVyZSBkaXN0YW5jZSB0byByYXlcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID09PSBudWxsICkgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XFxuXFxuXFx0XFx0XFx0XFx0c3BoZXJlLmNvcHkoIGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlICk7XFxuXFx0XFx0XFx0XFx0c3BoZXJlLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHJheWNhc3Rlci5yYXkuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkgPT09IGZhbHNlICkgcmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdC8vXFxuXFxuXFx0XFx0XFx0XFx0aW52ZXJzZU1hdHJpeC5nZXRJbnZlcnNlKCBtYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdFxcdHJheS5jb3B5KCByYXljYXN0ZXIucmF5ICkuYXBwbHlNYXRyaXg0KCBpbnZlcnNlTWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHZTdGFydCA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0XFx0dmFyIHZFbmQgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdFxcdHZhciBpbnRlclNlZ21lbnQgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdFxcdHZhciBpbnRlclJheSA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0XFx0dmFyIHN0ZXAgPSAoIHRoaXMgJiYgdGhpcy5pc0xpbmVTZWdtZW50cyApID8gMiA6IDE7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBpbmRleCA9IGdlb21ldHJ5LmluZGV4O1xcblxcdFxcdFxcdFxcdFxcdHZhciBhdHRyaWJ1dGVzID0gZ2VvbWV0cnkuYXR0cmlidXRlcztcXG5cXHRcXHRcXHRcXHRcXHR2YXIgcG9zaXRpb25zID0gYXR0cmlidXRlcy5wb3NpdGlvbi5hcnJheTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGluZGV4ICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBpbmRpY2VzID0gaW5kZXguYXJyYXk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5kaWNlcy5sZW5ndGggLSAxOyBpIDwgbDsgaSArPSBzdGVwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBhID0gaW5kaWNlc1sgaSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBiID0gaW5kaWNlc1sgaSArIDEgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2U3RhcnQuZnJvbUFycmF5KCBwb3NpdGlvbnMsIGEgKiAzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dkVuZC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgYiAqIDMgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0cy5wdXNoKCB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpbmRleDogaSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRmYWNlOiBudWxsLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZhY2VJbmRleDogbnVsbCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvYmplY3Q6IHRoaXNcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gcG9zaXRpb25zLmxlbmd0aCAvIDMgLSAxOyBpIDwgbDsgaSArPSBzdGVwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZTdGFydC5mcm9tQXJyYXkoIHBvc2l0aW9ucywgMyAqIGkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2RW5kLmZyb21BcnJheSggcG9zaXRpb25zLCAzICogaSArIDMgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgZGlzdFNxID0gcmF5LmRpc3RhbmNlU3FUb1NlZ21lbnQoIHZTdGFydCwgdkVuZCwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0cy5wdXNoKCB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpbmRleDogaSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRmYWNlOiBudWxsLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZhY2VJbmRleDogbnVsbCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRvYmplY3Q6IHRoaXNcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBnZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB2ZXJ0aWNlcyA9IGdlb21ldHJ5LnZlcnRpY2VzO1xcblxcdFxcdFxcdFxcdFxcdHZhciBuYlZlcnRpY2VzID0gdmVydGljZXMubGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IG5iVmVydGljZXMgLSAxOyBpICs9IHN0ZXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGRpc3RTcSA9IHJheS5kaXN0YW5jZVNxVG9TZWdtZW50KCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc1sgaSArIDEgXSwgaW50ZXJSYXksIGludGVyU2VnbWVudCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGlzdFNxID4gcHJlY2lzaW9uU3EgKSBjb250aW51ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpbnRlclJheS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKTsgLy9Nb3ZlIGJhY2sgdG8gd29ybGQgc3BhY2UgZm9yIGRpc3RhbmNlIGNhbGN1bGF0aW9uXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGRpc3RhbmNlID0gcmF5Y2FzdGVyLnJheS5vcmlnaW4uZGlzdGFuY2VUbyggaW50ZXJSYXkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRpc3RhbmNlIDwgcmF5Y2FzdGVyLm5lYXIgfHwgZGlzdGFuY2UgPiByYXljYXN0ZXIuZmFyICkgY29udGludWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0cy5wdXNoKCB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlzdGFuY2U6IGRpc3RhbmNlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFdoYXQgZG8gd2Ugd2FudD8gaW50ZXJzZWN0aW9uIHBvaW50IG9uIHRoZSByYXkgb3Igb24gdGhlIHNlZ21lbnQ/P1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHBvaW50OiByYXljYXN0ZXIucmF5LmF0KCBkaXN0YW5jZSApLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvaW50OiBpbnRlclNlZ21lbnQuY2xvbmUoKS5hcHBseU1hdHJpeDQoIHRoaXMubWF0cml4V29ybGQgKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbmRleDogaSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmYWNlOiBudWxsLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZhY2VJbmRleDogbnVsbCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvYmplY3Q6IHRoaXNcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSApLFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCB0aGlzLmdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkuY29weSggdGhpcyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBMaW5lU2VnbWVudHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRMaW5lLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdMaW5lU2VnbWVudHMnO1xcblxcblxcdH1cXG5cXG5cXHRMaW5lU2VnbWVudHMucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGluZS5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBMaW5lU2VnbWVudHMsXFxuXFxuXFx0XFx0aXNMaW5lU2VnbWVudHM6IHRydWVcXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtZ3JldGVyIC8gaHR0cDovL2dpdGh1Yi5jb20vbWdyZXRlclxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIExpbmVMb29wKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0TGluZS5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnTGluZUxvb3AnO1xcblxcblxcdH1cXG5cXG5cXHRMaW5lTG9vcC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaW5lLnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IExpbmVMb29wLFxcblxcblxcdFxcdGlzTGluZUxvb3A6IHRydWUsXFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKlxcblxcdCAqIHBhcmFtZXRlcnMgPSB7XFxuXFx0ICogIGNvbG9yOiA8aGV4PixcXG5cXHQgKiAgb3BhY2l0eTogPGZsb2F0PixcXG5cXHQgKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqXFxuXFx0ICogIHNpemU6IDxmbG9hdD4sXFxuXFx0ICogIHNpemVBdHRlbnVhdGlvbjogPGJvb2w+XFxuXFx0ICogfVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnUG9pbnRzTWF0ZXJpYWwnO1xcblxcblxcdFxcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XFxuXFxuXFx0XFx0dGhpcy5tYXAgPSBudWxsO1xcblxcblxcdFxcdHRoaXMuc2l6ZSA9IDE7XFxuXFx0XFx0dGhpcy5zaXplQXR0ZW51YXRpb24gPSB0cnVlO1xcblxcblxcdFxcdHRoaXMubGlnaHRzID0gZmFsc2U7XFxuXFxuXFx0XFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcXG5cXG5cXHR9XFxuXFxuXFx0UG9pbnRzTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTWF0ZXJpYWwucHJvdG90eXBlICk7XFxuXFx0UG9pbnRzTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9pbnRzTWF0ZXJpYWw7XFxuXFxuXFx0UG9pbnRzTWF0ZXJpYWwucHJvdG90eXBlLmlzUG9pbnRzTWF0ZXJpYWwgPSB0cnVlO1xcblxcblxcdFBvaW50c01hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcXG5cXG5cXHRcXHR0aGlzLm1hcCA9IHNvdXJjZS5tYXA7XFxuXFxuXFx0XFx0dGhpcy5zaXplID0gc291cmNlLnNpemU7XFxuXFx0XFx0dGhpcy5zaXplQXR0ZW51YXRpb24gPSBzb3VyY2Uuc2l6ZUF0dGVudWF0aW9uO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBQb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1BvaW50cyc7XFxuXFxuXFx0XFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5ICE9PSB1bmRlZmluZWQgPyBnZW9tZXRyeSA6IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcblxcdFxcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbCAhPT0gdW5kZWZpbmVkID8gbWF0ZXJpYWwgOiBuZXcgUG9pbnRzTWF0ZXJpYWwoIHsgY29sb3I6IE1hdGgucmFuZG9tKCkgKiAweGZmZmZmZiB9ICk7XFxuXFxuXFx0fVxcblxcblxcdFBvaW50cy5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBQb2ludHMsXFxuXFxuXFx0XFx0aXNQb2ludHM6IHRydWUsXFxuXFxuXFx0XFx0cmF5Y2FzdDogKCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGludmVyc2VNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xcblxcdFxcdFxcdHZhciByYXkgPSBuZXcgUmF5KCk7XFxuXFx0XFx0XFx0dmFyIHNwaGVyZSA9IG5ldyBTcGhlcmUoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gcmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBvYmplY3QgPSB0aGlzO1xcblxcdFxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XFxuXFx0XFx0XFx0XFx0dmFyIG1hdHJpeFdvcmxkID0gdGhpcy5tYXRyaXhXb3JsZDtcXG5cXHRcXHRcXHRcXHR2YXIgdGhyZXNob2xkID0gcmF5Y2FzdGVyLnBhcmFtcy5Qb2ludHMudGhyZXNob2xkO1xcblxcblxcdFxcdFxcdFxcdC8vIENoZWNraW5nIGJvdW5kaW5nU3BoZXJlIGRpc3RhbmNlIHRvIHJheVxcblxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgPT09IG51bGwgKSBnZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcXG5cXG5cXHRcXHRcXHRcXHRzcGhlcmUuY29weSggZ2VvbWV0cnkuYm91bmRpbmdTcGhlcmUgKTtcXG5cXHRcXHRcXHRcXHRzcGhlcmUuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdFxcdHNwaGVyZS5yYWRpdXMgKz0gdGhyZXNob2xkO1xcblxcblxcdFxcdFxcdFxcdGlmICggcmF5Y2FzdGVyLnJheS5pbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSA9PT0gZmFsc2UgKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0Ly9cXG5cXG5cXHRcXHRcXHRcXHRpbnZlcnNlTWF0cml4LmdldEludmVyc2UoIG1hdHJpeFdvcmxkICk7XFxuXFx0XFx0XFx0XFx0cmF5LmNvcHkoIHJheWNhc3Rlci5yYXkgKS5hcHBseU1hdHJpeDQoIGludmVyc2VNYXRyaXggKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbG9jYWxUaHJlc2hvbGQgPSB0aHJlc2hvbGQgLyAoICggdGhpcy5zY2FsZS54ICsgdGhpcy5zY2FsZS55ICsgdGhpcy5zY2FsZS56ICkgLyAzICk7XFxuXFx0XFx0XFx0XFx0dmFyIGxvY2FsVGhyZXNob2xkU3EgPSBsb2NhbFRocmVzaG9sZCAqIGxvY2FsVGhyZXNob2xkO1xcblxcdFxcdFxcdFxcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gdGVzdFBvaW50KCBwb2ludCwgaW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHJheVBvaW50RGlzdGFuY2VTcSA9IHJheS5kaXN0YW5jZVNxVG9Qb2ludCggcG9pbnQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHJheVBvaW50RGlzdGFuY2VTcSA8IGxvY2FsVGhyZXNob2xkU3EgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGludGVyc2VjdFBvaW50ID0gcmF5LmNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aW50ZXJzZWN0UG9pbnQuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBkaXN0YW5jZSA9IHJheWNhc3Rlci5yYXkub3JpZ2luLmRpc3RhbmNlVG8oIGludGVyc2VjdFBvaW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGRpc3RhbmNlID4gcmF5Y2FzdGVyLmZhciApIHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpbnRlcnNlY3RzLnB1c2goIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkaXN0YW5jZTogZGlzdGFuY2UsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlzdGFuY2VUb1JheTogTWF0aC5zcXJ0KCByYXlQb2ludERpc3RhbmNlU3EgKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRwb2ludDogaW50ZXJzZWN0UG9pbnQuY2xvbmUoKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbmRleDogaW5kZXgsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmFjZTogbnVsbCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRvYmplY3Q6IG9iamVjdFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdH0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYXR0cmlidXRlcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXM7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHBvc2l0aW9ucyA9IGF0dHJpYnV0ZXMucG9zaXRpb24uYXJyYXk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBpbmRleCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgaW5kaWNlcyA9IGluZGV4LmFycmF5O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBpbmRpY2VzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBhID0gaW5kaWNlc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLmZyb21BcnJheSggcG9zaXRpb25zLCBhICogMyApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRlc3RQb2ludCggcG9zaXRpb24sIGEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoIC8gMzsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb24uZnJvbUFycmF5KCBwb3NpdGlvbnMsIGkgKiAzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGVzdFBvaW50KCBwb3NpdGlvbiwgaSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdmVydGljZXMgPSBnZW9tZXRyeS52ZXJ0aWNlcztcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB2ZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRlc3RQb2ludCggdmVydGljZXNbIGkgXSwgaSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCkgKSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvciggdGhpcy5nZW9tZXRyeSwgdGhpcy5tYXRlcmlhbCApLmNvcHkoIHRoaXMgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gR3JvdXAoKSB7XFxuXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdHcm91cCc7XFxuXFxuXFx0fVxcblxcblxcdEdyb3VwLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IEdyb3VwLFxcblxcblxcdFxcdGlzR3JvdXA6IHRydWVcXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBWaWRlb1RleHR1cmUoIHZpZGVvLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKSB7XFxuXFxuXFx0XFx0VGV4dHVyZS5jYWxsKCB0aGlzLCB2aWRlbywgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5ICk7XFxuXFxuXFx0XFx0dGhpcy5nZW5lcmF0ZU1pcG1hcHMgPSBmYWxzZTtcXG5cXG5cXHRcXHQvLyBTZXQgbmVlZHNVcGRhdGUgd2hlbiBmaXJzdCBmcmFtZSBpcyByZWFkeVxcblxcblxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxuXFxuXFx0XFx0ZnVuY3Rpb24gb25Mb2FkZWQoKSB7XFxuXFxuXFx0XFx0XFx0dmlkZW8ucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2xvYWRlZGRhdGEnLCBvbkxvYWRlZCwgZmFsc2UgKTtcXG5cXHRcXHRcXHRzY29wZS5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHZpZGVvLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkZWRkYXRhJywgb25Mb2FkZWQsIGZhbHNlICk7XFxuXFxuXFx0fVxcblxcblxcdFZpZGVvVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBUZXh0dXJlLnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IFZpZGVvVGV4dHVyZSxcXG5cXG5cXHRcXHRpc1ZpZGVvVGV4dHVyZTogdHJ1ZSxcXG5cXG5cXHRcXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdmlkZW8gPSB0aGlzLmltYWdlO1xcblxcblxcdFxcdFxcdGlmICggdmlkZW8ucmVhZHlTdGF0ZSA+PSB2aWRlby5IQVZFX0NVUlJFTlRfREFUQSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIENvbXByZXNzZWRUZXh0dXJlKCBtaXBtYXBzLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHksIGVuY29kaW5nICkge1xcblxcblxcdFxcdFRleHR1cmUuY2FsbCggdGhpcywgbnVsbCwgbWFwcGluZywgd3JhcFMsIHdyYXBULCBtYWdGaWx0ZXIsIG1pbkZpbHRlciwgZm9ybWF0LCB0eXBlLCBhbmlzb3Ryb3B5LCBlbmNvZGluZyApO1xcblxcblxcdFxcdHRoaXMuaW1hZ2UgPSB7IHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQgfTtcXG5cXHRcXHR0aGlzLm1pcG1hcHMgPSBtaXBtYXBzO1xcblxcblxcdFxcdC8vIG5vIGZsaXBwaW5nIGZvciBjdWJlIHRleHR1cmVzXFxuXFx0XFx0Ly8gKGFsc28gZmxpcHBpbmcgZG9lc24ndCB3b3JrIGZvciBjb21wcmVzc2VkIHRleHR1cmVzIClcXG5cXG5cXHRcXHR0aGlzLmZsaXBZID0gZmFsc2U7XFxuXFxuXFx0XFx0Ly8gY2FuJ3QgZ2VuZXJhdGUgbWlwbWFwcyBmb3IgY29tcHJlc3NlZCB0ZXh0dXJlc1xcblxcdFxcdC8vIG1pcHMgbXVzdCBiZSBlbWJlZGRlZCBpbiBERFMgZmlsZXNcXG5cXG5cXHRcXHR0aGlzLmdlbmVyYXRlTWlwbWFwcyA9IGZhbHNlO1xcblxcblxcdH1cXG5cXG5cXHRDb21wcmVzc2VkVGV4dHVyZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBUZXh0dXJlLnByb3RvdHlwZSApO1xcblxcdENvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbXByZXNzZWRUZXh0dXJlO1xcblxcblxcdENvbXByZXNzZWRUZXh0dXJlLnByb3RvdHlwZS5pc0NvbXByZXNzZWRUZXh0dXJlID0gdHJ1ZTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIE1hdHQgRGVzTGF1cmllcnMgLyBAbWF0dGRlc2xcXG5cXHQgKiBAYXV0aG9yIGF0aXggLyBhcnRodXJzaWxiZXIuZGVcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBEZXB0aFRleHR1cmUoIHdpZHRoLCBoZWlnaHQsIHR5cGUsIG1hcHBpbmcsIHdyYXBTLCB3cmFwVCwgbWFnRmlsdGVyLCBtaW5GaWx0ZXIsIGFuaXNvdHJvcHksIGZvcm1hdCApIHtcXG5cXG5cXHRcXHRmb3JtYXQgPSBmb3JtYXQgIT09IHVuZGVmaW5lZCA/IGZvcm1hdCA6IERlcHRoRm9ybWF0O1xcblxcblxcdFxcdGlmICggZm9ybWF0ICE9PSBEZXB0aEZvcm1hdCAmJiBmb3JtYXQgIT09IERlcHRoU3RlbmNpbEZvcm1hdCApIHtcXG5cXG5cXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoICdEZXB0aFRleHR1cmUgZm9ybWF0IG11c3QgYmUgZWl0aGVyIFRIUkVFLkRlcHRoRm9ybWF0IG9yIFRIUkVFLkRlcHRoU3RlbmNpbEZvcm1hdCcgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCB0eXBlID09PSB1bmRlZmluZWQgJiYgZm9ybWF0ID09PSBEZXB0aEZvcm1hdCApIHR5cGUgPSBVbnNpZ25lZFNob3J0VHlwZTtcXG5cXHRcXHRpZiAoIHR5cGUgPT09IHVuZGVmaW5lZCAmJiBmb3JtYXQgPT09IERlcHRoU3RlbmNpbEZvcm1hdCApIHR5cGUgPSBVbnNpZ25lZEludDI0OFR5cGU7XFxuXFxuXFx0XFx0VGV4dHVyZS5jYWxsKCB0aGlzLCBudWxsLCBtYXBwaW5nLCB3cmFwUywgd3JhcFQsIG1hZ0ZpbHRlciwgbWluRmlsdGVyLCBmb3JtYXQsIHR5cGUsIGFuaXNvdHJvcHkgKTtcXG5cXG5cXHRcXHR0aGlzLmltYWdlID0geyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH07XFxuXFxuXFx0XFx0dGhpcy5tYWdGaWx0ZXIgPSBtYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1hZ0ZpbHRlciA6IE5lYXJlc3RGaWx0ZXI7XFxuXFx0XFx0dGhpcy5taW5GaWx0ZXIgPSBtaW5GaWx0ZXIgIT09IHVuZGVmaW5lZCA/IG1pbkZpbHRlciA6IE5lYXJlc3RGaWx0ZXI7XFxuXFxuXFx0XFx0dGhpcy5mbGlwWSA9IGZhbHNlO1xcblxcdFxcdHRoaXMuZ2VuZXJhdGVNaXBtYXBzXFx0PSBmYWxzZTtcXG5cXG5cXHR9XFxuXFxuXFx0RGVwdGhUZXh0dXJlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFRleHR1cmUucHJvdG90eXBlICk7XFxuXFx0RGVwdGhUZXh0dXJlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERlcHRoVGV4dHVyZTtcXG5cXHREZXB0aFRleHR1cmUucHJvdG90eXBlLmlzRGVwdGhUZXh0dXJlID0gdHJ1ZTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gV2lyZWZyYW1lR2VvbWV0cnkoIGdlb21ldHJ5ICkge1xcblxcblxcdFxcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnV2lyZWZyYW1lR2VvbWV0cnknO1xcblxcblxcdFxcdC8vIGJ1ZmZlclxcblxcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdO1xcblxcblxcdFxcdC8vIGhlbHBlciB2YXJpYWJsZXNcXG5cXG5cXHRcXHR2YXIgaSwgaiwgbCwgbywgb2w7XFxuXFx0XFx0dmFyIGVkZ2UgPSBbIDAsIDAgXSwgZWRnZXMgPSB7fSwgZSwgZWRnZTEsIGVkZ2UyO1xcblxcdFxcdHZhciBrZXksIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcXG5cXHRcXHR2YXIgdmVydGV4O1xcblxcblxcdFxcdC8vIGRpZmZlcmVudCBsb2dpYyBmb3IgR2VvbWV0cnkgYW5kIEJ1ZmZlckdlb21ldHJ5XFxuXFxuXFx0XFx0aWYgKCBnZW9tZXRyeSAmJiBnZW9tZXRyeS5pc0dlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdC8vIGNyZWF0ZSBhIGRhdGEgc3RydWN0dXJlIHRoYXQgY29udGFpbnMgYWxsIGVkZ2VzIHdpdGhvdXQgZHVwbGljYXRlc1xcblxcblxcdFxcdFxcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaiA9IDA7IGogPCAzOyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGVkZ2UxID0gZmFjZVsga2V5c1sgaiBdIF07XFxuXFx0XFx0XFx0XFx0XFx0ZWRnZTIgPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcXG5cXHRcXHRcXHRcXHRcXHRlZGdlWyAwIF0gPSBNYXRoLm1pbiggZWRnZTEsIGVkZ2UyICk7IC8vIHNvcnRpbmcgcHJldmVudHMgZHVwbGljYXRlc1xcblxcdFxcdFxcdFxcdFxcdGVkZ2VbIDEgXSA9IE1hdGgubWF4KCBlZGdlMSwgZWRnZTIgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRrZXkgPSBlZGdlWyAwIF0gKyAnLCcgKyBlZGdlWyAxIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBlZGdlc1sga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRlZGdlc1sga2V5IF0gPSB7IGluZGV4MTogZWRnZVsgMCBdLCBpbmRleDI6IGVkZ2VbIDEgXSB9O1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGdlbmVyYXRlIHZlcnRpY2VzXFxuXFxuXFx0XFx0XFx0Zm9yICgga2V5IGluIGVkZ2VzICkge1xcblxcblxcdFxcdFxcdFxcdGUgPSBlZGdlc1sga2V5IF07XFxuXFxuXFx0XFx0XFx0XFx0dmVydGV4ID0gZ2VvbWV0cnkudmVydGljZXNbIGUuaW5kZXgxIF07XFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xcblxcblxcdFxcdFxcdFxcdHZlcnRleCA9IGdlb21ldHJ5LnZlcnRpY2VzWyBlLmluZGV4MiBdO1xcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSBlbHNlIGlmICggZ2VvbWV0cnkgJiYgZ2VvbWV0cnkuaXNCdWZmZXJHZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcG9zaXRpb24sIGluZGljZXMsIGdyb3VwcztcXG5cXHRcXHRcXHR2YXIgZ3JvdXAsIHN0YXJ0LCBjb3VudDtcXG5cXHRcXHRcXHR2YXIgaW5kZXgxLCBpbmRleDI7XFxuXFxuXFx0XFx0XFx0dmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmluZGV4ICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGluZGV4ZWQgQnVmZmVyR2VvbWV0cnlcXG5cXG5cXHRcXHRcXHRcXHRwb3NpdGlvbiA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XFxuXFx0XFx0XFx0XFx0aW5kaWNlcyA9IGdlb21ldHJ5LmluZGV4O1xcblxcdFxcdFxcdFxcdGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3VwcztcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGdyb3Vwcy5sZW5ndGggPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z3JvdXBzID0gWyB7IHN0YXJ0OiAwLCBjb3VudDogaW5kaWNlcy5jb3VudCwgbWF0ZXJpYWxJbmRleDogMCB9IF07XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIGNyZWF0ZSBhIGRhdGEgc3RydWN0dXJlIHRoYXQgY29udGFpbnMgYWxsIGVnZXMgd2l0aG91dCBkdXBsaWNhdGVzXFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggbyA9IDAsIG9sID0gZ3JvdXBzLmxlbmd0aDsgbyA8IG9sOyArKyBvICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGdyb3VwID0gZ3JvdXBzWyBvIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0c3RhcnQgPSBncm91cC5zdGFydDtcXG5cXHRcXHRcXHRcXHRcXHRjb3VudCA9IGdyb3VwLmNvdW50O1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIGkgPSBzdGFydCwgbCA9ICggc3RhcnQgKyBjb3VudCApOyBpIDwgbDsgaSArPSAzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIGogPSAwOyBqIDwgMzsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlZGdlMSA9IGluZGljZXMuZ2V0WCggaSArIGogKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlZGdlMiA9IGluZGljZXMuZ2V0WCggaSArICggaiArIDEgKSAlIDMgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlZGdlWyAwIF0gPSBNYXRoLm1pbiggZWRnZTEsIGVkZ2UyICk7IC8vIHNvcnRpbmcgcHJldmVudHMgZHVwbGljYXRlc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVkZ2VbIDEgXSA9IE1hdGgubWF4KCBlZGdlMSwgZWRnZTIgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRrZXkgPSBlZGdlWyAwIF0gKyAnLCcgKyBlZGdlWyAxIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBlZGdlc1sga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRlZGdlc1sga2V5IF0gPSB7IGluZGV4MTogZWRnZVsgMCBdLCBpbmRleDI6IGVkZ2VbIDEgXSB9O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlc1xcblxcblxcdFxcdFxcdFxcdGZvciAoIGtleSBpbiBlZGdlcyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRlID0gZWRnZXNbIGtleSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdHZlcnRleC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgZS5pbmRleDEgKTtcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4LmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBlLmluZGV4MiApO1xcblxcdFxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBub24taW5kZXhlZCBCdWZmZXJHZW9tZXRyeVxcblxcblxcdFxcdFxcdFxcdHBvc2l0aW9uID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMCwgbCA9ICggcG9zaXRpb24uY291bnQgLyAzICk7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIGogPSAwOyBqIDwgMzsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB0aHJlZSBlZGdlcyBwZXIgdHJpYW5nbGUsIGFuIGVkZ2UgaXMgcmVwcmVzZW50ZWQgYXMgKGluZGV4MSwgaW5kZXgyKVxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGUuZy4gdGhlIGZpcnN0IHRyaWFuZ2xlIGhhcyB0aGUgZm9sbG93aW5nIGVkZ2VzOiAoMCwxKSwoMSwyKSwoMiwwKVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGluZGV4MSA9IDMgKiBpICsgajtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2ZXJ0ZXguZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGluZGV4MSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpbmRleDIgPSAzICogaSArICggKCBqICsgMSApICUgMyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZlcnRleC5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgaW5kZXgyICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBidWlsZCBnZW9tZXRyeVxcblxcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xcblxcblxcdH1cXG5cXG5cXHRXaXJlZnJhbWVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRXaXJlZnJhbWVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBXaXJlZnJhbWVHZW9tZXRyeTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxuXFx0ICpcXG5cXHQgKiBQYXJhbWV0cmljIFN1cmZhY2VzIEdlb21ldHJ5XFxuXFx0ICogYmFzZWQgb24gdGhlIGJyaWxsaWFudCBhcnRpY2xlIGJ5IEBwcmlkZW91dCBodHRwOi8vcHJpZGVvdXQubmV0L2Jsb2cvP3A9NDRcXG5cXHQgKi9cXG5cXG5cXHQvLyBQYXJhbWV0cmljR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBQYXJhbWV0cmljR2VvbWV0cnkoIGZ1bmMsIHNsaWNlcywgc3RhY2tzICkge1xcblxcblxcdFxcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnUGFyYW1ldHJpY0dlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0ZnVuYzogZnVuYyxcXG5cXHRcXHRcXHRzbGljZXM6IHNsaWNlcyxcXG5cXHRcXHRcXHRzdGFja3M6IHN0YWNrc1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnkoIGZ1bmMsIHNsaWNlcywgc3RhY2tzICkgKTtcXG5cXHRcXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcXG5cXG5cXHR9XFxuXFxuXFx0UGFyYW1ldHJpY0dlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdFBhcmFtZXRyaWNHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBQYXJhbWV0cmljR2VvbWV0cnk7XFxuXFxuXFx0Ly8gUGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gUGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5KCBmdW5jLCBzbGljZXMsIHN0YWNrcyApIHtcXG5cXG5cXHRcXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1BhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdGZ1bmM6IGZ1bmMsXFxuXFx0XFx0XFx0c2xpY2VzOiBzbGljZXMsXFxuXFx0XFx0XFx0c3RhY2tzOiBzdGFja3NcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIGJ1ZmZlcnNcXG5cXG5cXHRcXHR2YXIgaW5kaWNlcyA9IFtdO1xcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdO1xcblxcdFxcdHZhciBub3JtYWxzID0gW107XFxuXFx0XFx0dmFyIHV2cyA9IFtdO1xcblxcblxcdFxcdHZhciBFUFMgPSAwLjAwMDAxO1xcblxcblxcdFxcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdHZhciBwMCA9IG5ldyBWZWN0b3IzKCksIHAxID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR2YXIgcHUgPSBuZXcgVmVjdG9yMygpLCBwdiA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0dmFyIGksIGo7XFxuXFxuXFx0XFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xcblxcblxcdFxcdHZhciBzbGljZUNvdW50ID0gc2xpY2VzICsgMTtcXG5cXG5cXHRcXHRmb3IgKCBpID0gMDsgaSA8PSBzdGFja3M7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHYgPSBpIC8gc3RhY2tzO1xcblxcblxcdFxcdFxcdGZvciAoIGogPSAwOyBqIDw9IHNsaWNlczsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdSA9IGogLyBzbGljZXM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdmVydGV4XFxuXFxuXFx0XFx0XFx0XFx0cDAgPSBmdW5jKCB1LCB2LCBwMCApO1xcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHAwLngsIHAwLnksIHAwLnogKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBub3JtYWxcXG5cXG5cXHRcXHRcXHRcXHQvLyBhcHByb3hpbWF0ZSB0YW5nZW50IHZlY3RvcnMgdmlhIGZpbml0ZSBkaWZmZXJlbmNlc1xcblxcblxcdFxcdFxcdFxcdGlmICggdSAtIEVQUyA+PSAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHAxID0gZnVuYyggdSAtIEVQUywgdiwgcDEgKTtcXG5cXHRcXHRcXHRcXHRcXHRwdS5zdWJWZWN0b3JzKCBwMCwgcDEgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHAxID0gZnVuYyggdSArIEVQUywgdiwgcDEgKTtcXG5cXHRcXHRcXHRcXHRcXHRwdS5zdWJWZWN0b3JzKCBwMSwgcDAgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB2IC0gRVBTID49IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cDEgPSBmdW5jKCB1LCB2IC0gRVBTLCBwMSApO1xcblxcdFxcdFxcdFxcdFxcdHB2LnN1YlZlY3RvcnMoIHAwLCBwMSApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cDEgPSBmdW5jKCB1LCB2ICsgRVBTLCBwMSApO1xcblxcdFxcdFxcdFxcdFxcdHB2LnN1YlZlY3RvcnMoIHAxLCBwMCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBjcm9zcyBwcm9kdWN0IG9mIHRhbmdlbnQgdmVjdG9ycyByZXR1cm5zIHN1cmZhY2Ugbm9ybWFsXFxuXFxuXFx0XFx0XFx0XFx0bm9ybWFsLmNyb3NzVmVjdG9ycyggcHUsIHB2ICkubm9ybWFsaXplKCk7XFxuXFx0XFx0XFx0XFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdXZcXG5cXG5cXHRcXHRcXHRcXHR1dnMucHVzaCggdSwgdiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xcblxcblxcdFxcdGZvciAoIGkgPSAwOyBpIDwgc3RhY2tzOyBpICsrICkge1xcblxcblxcdFxcdFxcdGZvciAoIGogPSAwOyBqIDwgc2xpY2VzOyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBhID0gaSAqIHNsaWNlQ291bnQgKyBqO1xcblxcdFxcdFxcdFxcdHZhciBiID0gaSAqIHNsaWNlQ291bnQgKyBqICsgMTtcXG5cXHRcXHRcXHRcXHR2YXIgYyA9ICggaSArIDEgKSAqIHNsaWNlQ291bnQgKyBqICsgMTtcXG5cXHRcXHRcXHRcXHR2YXIgZCA9ICggaSArIDEgKSAqIHNsaWNlQ291bnQgKyBqO1xcblxcblxcdFxcdFxcdFxcdC8vIGZhY2VzIG9uZSBhbmQgdHdvXFxuXFxuXFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XFxuXFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBidWlsZCBnZW9tZXRyeVxcblxcblxcdFxcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XFxuXFxuXFx0fVxcblxcblxcdFBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgY2xvY2t3b3JrZ2VlayAvIGh0dHBzOi8vZ2l0aHViLmNvbS9jbG9ja3dvcmtnZWVrXFxuXFx0ICogQGF1dGhvciB0aW1vdGh5cHJhdGxleSAvIGh0dHBzOi8vZ2l0aHViLmNvbS90aW1vdGh5cHJhdGxleVxcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxuXFx0ICovXFxuXFxuXFx0Ly8gUG9seWhlZHJvbkdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gUG9seWhlZHJvbkdlb21ldHJ5KCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKSB7XFxuXFxuXFx0XFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdQb2x5aGVkcm9uR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHR2ZXJ0aWNlczogdmVydGljZXMsXFxuXFx0XFx0XFx0aW5kaWNlczogaW5kaWNlcyxcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXG5cXHRcXHRcXHRkZXRhaWw6IGRldGFpbFxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkoIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApICk7XFxuXFx0XFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XFxuXFxuXFx0fVxcblxcblxcdFBvbHloZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRQb2x5aGVkcm9uR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9seWhlZHJvbkdlb21ldHJ5O1xcblxcblxcdC8vIFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeSggdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICkge1xcblxcblxcdFxcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0dmVydGljZXM6IHZlcnRpY2VzLFxcblxcdFxcdFxcdGluZGljZXM6IGluZGljZXMsXFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxuXFx0XFx0XFx0ZGV0YWlsOiBkZXRhaWxcXG5cXHRcXHR9O1xcblxcblxcdFxcdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xcblxcdFxcdGRldGFpbCA9IGRldGFpbCB8fCAwO1xcblxcblxcdFxcdC8vIGRlZmF1bHQgYnVmZmVyIGRhdGFcXG5cXG5cXHRcXHR2YXIgdmVydGV4QnVmZmVyID0gW107XFxuXFx0XFx0dmFyIHV2QnVmZmVyID0gW107XFxuXFxuXFx0XFx0Ly8gdGhlIHN1YmRpdmlzaW9uIGNyZWF0ZXMgdGhlIHZlcnRleCBidWZmZXIgZGF0YVxcblxcblxcdFxcdHN1YmRpdmlkZSggZGV0YWlsICk7XFxuXFxuXFx0XFx0Ly8gYWxsIHZlcnRpY2VzIHNob3VsZCBsaWUgb24gYSBjb25jZXB0dWFsIHNwaGVyZSB3aXRoIGEgZ2l2ZW4gcmFkaXVzXFxuXFxuXFx0XFx0YXBwcGx5UmFkaXVzKCByYWRpdXMgKTtcXG5cXG5cXHRcXHQvLyBmaW5hbGx5LCBjcmVhdGUgdGhlIHV2IGRhdGFcXG5cXG5cXHRcXHRnZW5lcmF0ZVVWcygpO1xcblxcblxcdFxcdC8vIGJ1aWxkIG5vbi1pbmRleGVkIGdlb21ldHJ5XFxuXFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0ZXhCdWZmZXIsIDMgKSApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRleEJ1ZmZlci5zbGljZSgpLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2QnVmZmVyLCAyICkgKTtcXG5cXG5cXHRcXHRpZiAoIGRldGFpbCA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmNvbXB1dGVWZXJ0ZXhOb3JtYWxzKCk7IC8vIGZsYXQgbm9ybWFsc1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5ub3JtYWxpemVOb3JtYWxzKCk7IC8vIHNtb290aCBub3JtYWxzXFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGhlbHBlciBmdW5jdGlvbnNcXG5cXG5cXHRcXHRmdW5jdGlvbiBzdWJkaXZpZGUoIGRldGFpbCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYSA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIGIgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciBjID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHQvLyBpdGVyYXRlIG92ZXIgYWxsIGZhY2VzIGFuZCBhcHBseSBhIHN1YmRpdmlzb24gd2l0aCB0aGUgZ2l2ZW4gZGV0YWlsIHZhbHVlXFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkgKz0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBnZXQgdGhlIHZlcnRpY2VzIG9mIHRoZSBmYWNlXFxuXFxuXFx0XFx0XFx0XFx0Z2V0VmVydGV4QnlJbmRleCggaW5kaWNlc1sgaSArIDAgXSwgYSApO1xcblxcdFxcdFxcdFxcdGdldFZlcnRleEJ5SW5kZXgoIGluZGljZXNbIGkgKyAxIF0sIGIgKTtcXG5cXHRcXHRcXHRcXHRnZXRWZXJ0ZXhCeUluZGV4KCBpbmRpY2VzWyBpICsgMiBdLCBjICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gcGVyZm9ybSBzdWJkaXZpc2lvblxcblxcblxcdFxcdFxcdFxcdHN1YmRpdmlkZUZhY2UoIGEsIGIsIGMsIGRldGFpbCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gc3ViZGl2aWRlRmFjZSggYSwgYiwgYywgZGV0YWlsICkge1xcblxcblxcdFxcdFxcdHZhciBjb2xzID0gTWF0aC5wb3coIDIsIGRldGFpbCApO1xcblxcblxcdFxcdFxcdC8vIHdlIHVzZSB0aGlzIG11bHRpZGltZW5zaW9uYWwgYXJyYXkgYXMgYSBkYXRhIHN0cnVjdHVyZSBmb3IgY3JlYXRpbmcgdGhlIHN1YmRpdmlzaW9uXFxuXFxuXFx0XFx0XFx0dmFyIHYgPSBbXTtcXG5cXG5cXHRcXHRcXHR2YXIgaSwgajtcXG5cXG5cXHRcXHRcXHQvLyBjb25zdHJ1Y3QgYWxsIG9mIHRoZSB2ZXJ0aWNlcyBmb3IgdGhpcyBzdWJkaXZpc2lvblxcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDw9IGNvbHM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dlsgaSBdID0gW107XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGFqID0gYS5jbG9uZSgpLmxlcnAoIGMsIGkgLyBjb2xzICk7XFxuXFx0XFx0XFx0XFx0dmFyIGJqID0gYi5jbG9uZSgpLmxlcnAoIGMsIGkgLyBjb2xzICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHJvd3MgPSBjb2xzIC0gaTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBqID0gMDsgaiA8PSByb3dzOyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggaiA9PT0gMCAmJiBpID09PSBjb2xzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZbIGkgXVsgaiBdID0gYWo7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2WyBpIF1bIGogXSA9IGFqLmNsb25lKCkubGVycCggYmosIGogLyByb3dzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gY29uc3RydWN0IGFsbCBvZiB0aGUgZmFjZXNcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IGNvbHM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaiA9IDA7IGogPCAyICogKCBjb2xzIC0gaSApIC0gMTsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgayA9IE1hdGguZmxvb3IoIGogLyAyICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBqICUgMiA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRwdXNoVmVydGV4KCB2WyBpIF1bIGsgKyAxIF0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwdXNoVmVydGV4KCB2WyBpICsgMSBdWyBrIF0gKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwdXNoVmVydGV4KCB2WyBpIF1bIGsgXSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cHVzaFZlcnRleCggdlsgaSBdWyBrICsgMSBdICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cHVzaFZlcnRleCggdlsgaSArIDEgXVsgayArIDEgXSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHB1c2hWZXJ0ZXgoIHZbIGkgKyAxIF1bIGsgXSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBhcHBwbHlSYWRpdXMoIHJhZGl1cyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHQvLyBpdGVyYXRlIG92ZXIgdGhlIGVudGlyZSBidWZmZXIgYW5kIGFwcGx5IHRoZSByYWRpdXMgdG8gZWFjaCB2ZXJ0ZXhcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB2ZXJ0ZXhCdWZmZXIubGVuZ3RoOyBpICs9IDMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmVydGV4LnggPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAwIF07XFxuXFx0XFx0XFx0XFx0dmVydGV4LnkgPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF07XFxuXFx0XFx0XFx0XFx0dmVydGV4LnogPSB2ZXJ0ZXhCdWZmZXJbIGkgKyAyIF07XFxuXFxuXFx0XFx0XFx0XFx0dmVydGV4Lm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCByYWRpdXMgKTtcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0ZXhCdWZmZXJbIGkgKyAwIF0gPSB2ZXJ0ZXgueDtcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXhCdWZmZXJbIGkgKyAxIF0gPSB2ZXJ0ZXgueTtcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXhCdWZmZXJbIGkgKyAyIF0gPSB2ZXJ0ZXguejtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGdlbmVyYXRlVVZzKCkge1xcblxcblxcdFxcdFxcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IHZlcnRleEJ1ZmZlci5sZW5ndGg7IGkgKz0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueCA9IHZlcnRleEJ1ZmZlclsgaSArIDAgXTtcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueSA9IHZlcnRleEJ1ZmZlclsgaSArIDEgXTtcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueiA9IHZlcnRleEJ1ZmZlclsgaSArIDIgXTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdSA9IGF6aW11dGgoIHZlcnRleCApIC8gMiAvIE1hdGguUEkgKyAwLjU7XFxuXFx0XFx0XFx0XFx0dmFyIHYgPSBpbmNsaW5hdGlvbiggdmVydGV4ICkgLyBNYXRoLlBJICsgMC41O1xcblxcdFxcdFxcdFxcdHV2QnVmZmVyLnB1c2goIHUsIDEgLSB2ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGNvcnJlY3RVVnMoKTtcXG5cXG5cXHRcXHRcXHRjb3JyZWN0U2VhbSgpO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBjb3JyZWN0U2VhbSgpIHtcXG5cXG5cXHRcXHRcXHQvLyBoYW5kbGUgY2FzZSB3aGVuIGZhY2Ugc3RyYWRkbGVzIHRoZSBzZWFtLCBzZWUgIzMyNjlcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB1dkJ1ZmZlci5sZW5ndGg7IGkgKz0gNiApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyB1diBkYXRhIG9mIGEgc2luZ2xlIGZhY2VcXG5cXG5cXHRcXHRcXHRcXHR2YXIgeDAgPSB1dkJ1ZmZlclsgaSArIDAgXTtcXG5cXHRcXHRcXHRcXHR2YXIgeDEgPSB1dkJ1ZmZlclsgaSArIDIgXTtcXG5cXHRcXHRcXHRcXHR2YXIgeDIgPSB1dkJ1ZmZlclsgaSArIDQgXTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbWF4ID0gTWF0aC5tYXgoIHgwLCB4MSwgeDIgKTtcXG5cXHRcXHRcXHRcXHR2YXIgbWluID0gTWF0aC5taW4oIHgwLCB4MSwgeDIgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyAwLjkgaXMgc29tZXdoYXQgYXJiaXRyYXJ5XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtYXggPiAwLjkgJiYgbWluIDwgMC4xICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggeDAgPCAwLjIgKSB1dkJ1ZmZlclsgaSArIDAgXSArPSAxO1xcblxcdFxcdFxcdFxcdFxcdGlmICggeDEgPCAwLjIgKSB1dkJ1ZmZlclsgaSArIDIgXSArPSAxO1xcblxcdFxcdFxcdFxcdFxcdGlmICggeDIgPCAwLjIgKSB1dkJ1ZmZlclsgaSArIDQgXSArPSAxO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHB1c2hWZXJ0ZXgoIHZlcnRleCApIHtcXG5cXG5cXHRcXHRcXHR2ZXJ0ZXhCdWZmZXIucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBnZXRWZXJ0ZXhCeUluZGV4KCBpbmRleCwgdmVydGV4ICkge1xcblxcblxcdFxcdFxcdHZhciBzdHJpZGUgPSBpbmRleCAqIDM7XFxuXFxuXFx0XFx0XFx0dmVydGV4LnggPSB2ZXJ0aWNlc1sgc3RyaWRlICsgMCBdO1xcblxcdFxcdFxcdHZlcnRleC55ID0gdmVydGljZXNbIHN0cmlkZSArIDEgXTtcXG5cXHRcXHRcXHR2ZXJ0ZXgueiA9IHZlcnRpY2VzWyBzdHJpZGUgKyAyIF07XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGNvcnJlY3RVVnMoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGEgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciBiID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgYyA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0dmFyIGNlbnRyb2lkID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHR2YXIgdXZBID0gbmV3IFZlY3RvcjIoKTtcXG5cXHRcXHRcXHR2YXIgdXZCID0gbmV3IFZlY3RvcjIoKTtcXG5cXHRcXHRcXHR2YXIgdXZDID0gbmV3IFZlY3RvcjIoKTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGogPSAwOyBpIDwgdmVydGV4QnVmZmVyLmxlbmd0aDsgaSArPSA5LCBqICs9IDYgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YS5zZXQoIHZlcnRleEJ1ZmZlclsgaSArIDAgXSwgdmVydGV4QnVmZmVyWyBpICsgMSBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyAyIF0gKTtcXG5cXHRcXHRcXHRcXHRiLnNldCggdmVydGV4QnVmZmVyWyBpICsgMyBdLCB2ZXJ0ZXhCdWZmZXJbIGkgKyA0IF0sIHZlcnRleEJ1ZmZlclsgaSArIDUgXSApO1xcblxcdFxcdFxcdFxcdGMuc2V0KCB2ZXJ0ZXhCdWZmZXJbIGkgKyA2IF0sIHZlcnRleEJ1ZmZlclsgaSArIDcgXSwgdmVydGV4QnVmZmVyWyBpICsgOCBdICk7XFxuXFxuXFx0XFx0XFx0XFx0dXZBLnNldCggdXZCdWZmZXJbIGogKyAwIF0sIHV2QnVmZmVyWyBqICsgMSBdICk7XFxuXFx0XFx0XFx0XFx0dXZCLnNldCggdXZCdWZmZXJbIGogKyAyIF0sIHV2QnVmZmVyWyBqICsgMyBdICk7XFxuXFx0XFx0XFx0XFx0dXZDLnNldCggdXZCdWZmZXJbIGogKyA0IF0sIHV2QnVmZmVyWyBqICsgNSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0Y2VudHJvaWQuY29weSggYSApLmFkZCggYiApLmFkZCggYyApLmRpdmlkZVNjYWxhciggMyApO1xcblxcblxcdFxcdFxcdFxcdHZhciBhemkgPSBhemltdXRoKCBjZW50cm9pZCApO1xcblxcblxcdFxcdFxcdFxcdGNvcnJlY3RVViggdXZBLCBqICsgMCwgYSwgYXppICk7XFxuXFx0XFx0XFx0XFx0Y29ycmVjdFVWKCB1dkIsIGogKyAyLCBiLCBhemkgKTtcXG5cXHRcXHRcXHRcXHRjb3JyZWN0VVYoIHV2QywgaiArIDQsIGMsIGF6aSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gY29ycmVjdFVWKCB1diwgc3RyaWRlLCB2ZWN0b3IsIGF6aW11dGggKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCAoIGF6aW11dGggPCAwICkgJiYgKCB1di54ID09PSAxICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dXZCdWZmZXJbIHN0cmlkZSBdID0gdXYueCAtIDE7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggKCB2ZWN0b3IueCA9PT0gMCApICYmICggdmVjdG9yLnogPT09IDAgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHR1dkJ1ZmZlclsgc3RyaWRlIF0gPSBhemltdXRoIC8gMiAvIE1hdGguUEkgKyAwLjU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBBbmdsZSBhcm91bmQgdGhlIFkgYXhpcywgY291bnRlci1jbG9ja3dpc2Ugd2hlbiBsb29raW5nIGZyb20gYWJvdmUuXFxuXFxuXFx0XFx0ZnVuY3Rpb24gYXppbXV0aCggdmVjdG9yICkge1xcblxcblxcdFxcdFxcdHJldHVybiBNYXRoLmF0YW4yKCB2ZWN0b3IueiwgLSB2ZWN0b3IueCApO1xcblxcblxcdFxcdH1cXG5cXG5cXG5cXHRcXHQvLyBBbmdsZSBhYm92ZSB0aGUgWFogcGxhbmUuXFxuXFxuXFx0XFx0ZnVuY3Rpb24gaW5jbGluYXRpb24oIHZlY3RvciApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gTWF0aC5hdGFuMiggLSB2ZWN0b3IueSwgTWF0aC5zcXJ0KCAoIHZlY3Rvci54ICogdmVjdG9yLnggKSArICggdmVjdG9yLnogKiB2ZWN0b3IueiApICkgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqL1xcblxcblxcdC8vIFRldHJhaGVkcm9uR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBUZXRyYWhlZHJvbkdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApIHtcXG5cXG5cXHRcXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1RldHJhaGVkcm9uR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXG5cXHRcXHRcXHRkZXRhaWw6IGRldGFpbFxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApICk7XFxuXFx0XFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XFxuXFxuXFx0fVxcblxcblxcdFRldHJhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0VGV0cmFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXRyYWhlZHJvbkdlb21ldHJ5O1xcblxcblxcdC8vIFRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApIHtcXG5cXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXFxuXFx0XFx0XFx0MSwgMSwgMSwgXFx0LSAxLCAtIDEsIDEsIFxcdC0gMSwgMSwgLSAxLCBcXHQxLCAtIDEsIC0gMVxcblxcdFxcdF07XFxuXFxuXFx0XFx0dmFyIGluZGljZXMgPSBbXFxuXFx0XFx0XFx0MiwgMSwgMCwgXFx0MCwgMywgMixcXHQxLCAzLCAwLFxcdDIsIDMsIDFcXG5cXHRcXHRdO1xcblxcblxcdFxcdFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzLCB2ZXJ0aWNlcywgaW5kaWNlcywgcmFkaXVzLCBkZXRhaWwgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcblxcdFxcdFxcdGRldGFpbDogZGV0YWlsXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0VGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0VGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqL1xcblxcblxcdC8vIE9jdGFoZWRyb25HZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIE9jdGFoZWRyb25HZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSB7XFxuXFxuXFx0XFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdPY3RhaGVkcm9uR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXG5cXHRcXHRcXHRkZXRhaWw6IGRldGFpbFxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkgKTtcXG5cXHRcXHR0aGlzLm1lcmdlVmVydGljZXMoKTtcXG5cXG5cXHR9XFxuXFxuXFx0T2N0YWhlZHJvbkdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdE9jdGFoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBPY3RhaGVkcm9uR2VvbWV0cnk7XFxuXFxuXFx0Ly8gT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApIHtcXG5cXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXFxuXFx0XFx0XFx0MSwgMCwgMCwgXFx0LSAxLCAwLCAwLFxcdDAsIDEsIDAsXFxuXFx0XFx0XFx0MCwgLSAxLCAwLCBcXHQwLCAwLCAxLFxcdDAsIDAsIC0gMVxcblxcdFxcdF07XFxuXFxuXFx0XFx0dmFyIGluZGljZXMgPSBbXFxuXFx0XFx0XFx0MCwgMiwgNCxcXHQwLCA0LCAzLFxcdDAsIDMsIDUsXFxuXFx0XFx0XFx0MCwgNSwgMixcXHQxLCAyLCA1LFxcdDEsIDUsIDMsXFxuXFx0XFx0XFx0MSwgMywgNCxcXHQxLCA0LCAyXFxuXFx0XFx0XTtcXG5cXG5cXHRcXHRQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcywgdmVydGljZXMsIGluZGljZXMsIHJhZGl1cywgZGV0YWlsICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ09jdGFoZWRyb25CdWZmZXJHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcblxcdFxcdFxcdGRldGFpbDogZGV0YWlsXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0T2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgdGltb3RoeXByYXRsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vdGltb3RoeXByYXRsZXlcXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqL1xcblxcblxcdC8vIEljb3NhaGVkcm9uR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBJY29zYWhlZHJvbkdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApIHtcXG5cXG5cXHRcXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0ljb3NhaGVkcm9uR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXG5cXHRcXHRcXHRkZXRhaWw6IGRldGFpbFxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApICk7XFxuXFx0XFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XFxuXFxuXFx0fVxcblxcblxcdEljb3NhaGVkcm9uR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0SWNvc2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJY29zYWhlZHJvbkdlb21ldHJ5O1xcblxcblxcdC8vIEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApIHtcXG5cXG5cXHRcXHR2YXIgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xcblxcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtcXG5cXHRcXHRcXHQtIDEsIHQsIDAsIFxcdDEsIHQsIDAsIFxcdC0gMSwgLSB0LCAwLCBcXHQxLCAtIHQsIDAsXFxuXFx0XFx0XFx0IDAsIC0gMSwgdCwgXFx0MCwgMSwgdCxcXHQwLCAtIDEsIC0gdCwgXFx0MCwgMSwgLSB0LFxcblxcdFxcdFxcdCB0LCAwLCAtIDEsIFxcdHQsIDAsIDEsIFxcdC0gdCwgMCwgLSAxLCBcXHQtIHQsIDAsIDFcXG5cXHRcXHRdO1xcblxcblxcdFxcdHZhciBpbmRpY2VzID0gW1xcblxcdFxcdFxcdCAwLCAxMSwgNSwgXFx0MCwgNSwgMSwgXFx0MCwgMSwgNywgXFx0MCwgNywgMTAsIFxcdDAsIDEwLCAxMSxcXG5cXHRcXHRcXHQgMSwgNSwgOSwgXFx0NSwgMTEsIDQsXFx0MTEsIDEwLCAyLFxcdDEwLCA3LCA2LFxcdDcsIDEsIDgsXFxuXFx0XFx0XFx0IDMsIDksIDQsIFxcdDMsIDQsIDIsXFx0MywgMiwgNixcXHQzLCA2LCA4LFxcdDMsIDgsIDksXFxuXFx0XFx0XFx0IDQsIDksIDUsIFxcdDIsIDQsIDExLFxcdDYsIDIsIDEwLFxcdDgsIDYsIDcsXFx0OSwgOCwgMVxcblxcdFxcdF07XFxuXFxuXFx0XFx0UG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxuXFx0XFx0XFx0ZGV0YWlsOiBkZXRhaWxcXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHRJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBBYmUgUGF6b3MgLyBodHRwczovL2hhbW9pZC5jb21cXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqL1xcblxcblxcdC8vIERvZGVjYWhlZHJvbkdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gRG9kZWNhaGVkcm9uR2VvbWV0cnkoIHJhZGl1cywgZGV0YWlsICkge1xcblxcblxcdFxcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnRG9kZWNhaGVkcm9uR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXG5cXHRcXHRcXHRkZXRhaWw6IGRldGFpbFxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeSggcmFkaXVzLCBkZXRhaWwgKSApO1xcblxcdFxcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xcblxcblxcdH1cXG5cXG5cXHREb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHREb2RlY2FoZWRyb25HZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEb2RlY2FoZWRyb25HZW9tZXRyeTtcXG5cXG5cXHQvLyBEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIGRldGFpbCApIHtcXG5cXG5cXHRcXHR2YXIgdCA9ICggMSArIE1hdGguc3FydCggNSApICkgLyAyO1xcblxcdFxcdHZhciByID0gMSAvIHQ7XFxuXFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW1xcblxcblxcdFxcdFxcdC8vICjCsTEsIMKxMSwgwrExKVxcblxcdFxcdFxcdC0gMSwgLSAxLCAtIDEsXFx0LSAxLCAtIDEsIDEsXFxuXFx0XFx0XFx0LSAxLCAxLCAtIDEsIC0gMSwgMSwgMSxcXG5cXHRcXHRcXHQxLCAtIDEsIC0gMSwgMSwgLSAxLCAxLFxcblxcdFxcdFxcdDEsIDEsIC0gMSwgMSwgMSwgMSxcXG5cXG5cXHRcXHRcXHQvLyAoMCwgwrExL8+GLCDCsc+GKVxcblxcdFxcdFxcdCAwLCAtIHIsIC0gdCwgMCwgLSByLCB0LFxcblxcdFxcdFxcdCAwLCByLCAtIHQsIDAsIHIsIHQsXFxuXFxuXFx0XFx0XFx0Ly8gKMKxMS/PhiwgwrHPhiwgMClcXG5cXHRcXHRcXHQtIHIsIC0gdCwgMCwgLSByLCB0LCAwLFxcblxcdFxcdFxcdCByLCAtIHQsIDAsIHIsIHQsIDAsXFxuXFxuXFx0XFx0XFx0Ly8gKMKxz4YsIDAsIMKxMS/PhilcXG5cXHRcXHRcXHQtIHQsIDAsIC0gciwgdCwgMCwgLSByLFxcblxcdFxcdFxcdC0gdCwgMCwgciwgdCwgMCwgclxcblxcdFxcdF07XFxuXFxuXFx0XFx0dmFyIGluZGljZXMgPSBbXFxuXFx0XFx0XFx0MywgMTEsIDcsIFxcdDMsIDcsIDE1LCBcXHQzLCAxNSwgMTMsXFxuXFx0XFx0XFx0NywgMTksIDE3LCBcXHQ3LCAxNywgNiwgXFx0NywgNiwgMTUsXFxuXFx0XFx0XFx0MTcsIDQsIDgsIFxcdDE3LCA4LCAxMCwgXFx0MTcsIDEwLCA2LFxcblxcdFxcdFxcdDgsIDAsIDE2LCBcXHQ4LCAxNiwgMiwgXFx0OCwgMiwgMTAsXFxuXFx0XFx0XFx0MCwgMTIsIDEsIFxcdDAsIDEsIDE4LCBcXHQwLCAxOCwgMTYsXFxuXFx0XFx0XFx0NiwgMTAsIDIsIFxcdDYsIDIsIDEzLCBcXHQ2LCAxMywgMTUsXFxuXFx0XFx0XFx0MiwgMTYsIDE4LCBcXHQyLCAxOCwgMywgXFx0MiwgMywgMTMsXFxuXFx0XFx0XFx0MTgsIDEsIDksIFxcdDE4LCA5LCAxMSwgXFx0MTgsIDExLCAzLFxcblxcdFxcdFxcdDQsIDE0LCAxMiwgXFx0NCwgMTIsIDAsIFxcdDQsIDAsIDgsXFxuXFx0XFx0XFx0MTEsIDksIDUsIFxcdDExLCA1LCAxOSwgXFx0MTEsIDE5LCA3LFxcblxcdFxcdFxcdDE5LCA1LCAxNCwgXFx0MTksIDE0LCA0LCBcXHQxOSwgNCwgMTcsXFxuXFx0XFx0XFx0MSwgMTIsIDE0LCBcXHQxLCAxNCwgNSwgXFx0MSwgNSwgOVxcblxcdFxcdF07XFxuXFxuXFx0XFx0UG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMsIHZlcnRpY2VzLCBpbmRpY2VzLCByYWRpdXMsIGRldGFpbCApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdEb2RlY2FoZWRyb25CdWZmZXJHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcblxcdFxcdFxcdGRldGFpbDogZGV0YWlsXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0RG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3Igb29zbW94aWVjb2RlIC8gaHR0cHM6Ly9naXRodWIuY29tL29vc21veGllY29kZVxcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwczovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXG5cXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxcblxcdCAqIEBhdXRob3IgbWluaW5nb2xkIC8gaHR0cHM6Ly9naXRodWIuY29tL21pbmluZ29sZFxcblxcdCAqIEBhdXRob3Igam9ub2JyMSAvIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25vYnIxXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cHM6Ly9naXRodWIuY29tL011Z2VuODdcXG5cXHQgKlxcblxcdCAqL1xcblxcblxcdC8vIFR1YmVHZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIFR1YmVHZW9tZXRyeSggcGF0aCwgdHVidWxhclNlZ21lbnRzLCByYWRpdXMsIHJhZGlhbFNlZ21lbnRzLCBjbG9zZWQsIHRhcGVyICkge1xcblxcblxcdFxcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnVHViZUdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0cGF0aDogcGF0aCxcXG5cXHRcXHRcXHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXG5cXHRcXHRcXHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXFxuXFx0XFx0XFx0Y2xvc2VkOiBjbG9zZWRcXG5cXHRcXHR9O1xcblxcblxcdFxcdGlmICggdGFwZXIgIT09IHVuZGVmaW5lZCApIGNvbnNvbGUud2FybiggJ1RIUkVFLlR1YmVHZW9tZXRyeTogdGFwZXIgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0dmFyIGJ1ZmZlckdlb21ldHJ5ID0gbmV3IFR1YmVCdWZmZXJHZW9tZXRyeSggcGF0aCwgdHVidWxhclNlZ21lbnRzLCByYWRpdXMsIHJhZGlhbFNlZ21lbnRzLCBjbG9zZWQgKTtcXG5cXG5cXHRcXHQvLyBleHBvc2UgaW50ZXJuYWxzXFxuXFxuXFx0XFx0dGhpcy50YW5nZW50cyA9IGJ1ZmZlckdlb21ldHJ5LnRhbmdlbnRzO1xcblxcdFxcdHRoaXMubm9ybWFscyA9IGJ1ZmZlckdlb21ldHJ5Lm5vcm1hbHM7XFxuXFx0XFx0dGhpcy5iaW5vcm1hbHMgPSBidWZmZXJHZW9tZXRyeS5iaW5vcm1hbHM7XFxuXFxuXFx0XFx0Ly8gY3JlYXRlIGdlb21ldHJ5XFxuXFxuXFx0XFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIGJ1ZmZlckdlb21ldHJ5ICk7XFxuXFx0XFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XFxuXFxuXFx0fVxcblxcblxcdFR1YmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRUdWJlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVHViZUdlb21ldHJ5O1xcblxcblxcdC8vIFR1YmVCdWZmZXJHZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIFR1YmVCdWZmZXJHZW9tZXRyeSggcGF0aCwgdHVidWxhclNlZ21lbnRzLCByYWRpdXMsIHJhZGlhbFNlZ21lbnRzLCBjbG9zZWQgKSB7XFxuXFxuXFx0XFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdUdWJlQnVmZmVyR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRwYXRoOiBwYXRoLFxcblxcdFxcdFxcdHR1YnVsYXJTZWdtZW50czogdHVidWxhclNlZ21lbnRzLFxcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcblxcdFxcdFxcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcXG5cXHRcXHRcXHRjbG9zZWQ6IGNsb3NlZFxcblxcdFxcdH07XFxuXFxuXFx0XFx0dHVidWxhclNlZ21lbnRzID0gdHVidWxhclNlZ21lbnRzIHx8IDY0O1xcblxcdFxcdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xcblxcdFxcdHJhZGlhbFNlZ21lbnRzID0gcmFkaWFsU2VnbWVudHMgfHwgODtcXG5cXHRcXHRjbG9zZWQgPSBjbG9zZWQgfHwgZmFsc2U7XFxuXFxuXFx0XFx0dmFyIGZyYW1lcyA9IHBhdGguY29tcHV0ZUZyZW5ldEZyYW1lcyggdHVidWxhclNlZ21lbnRzLCBjbG9zZWQgKTtcXG5cXG5cXHRcXHQvLyBleHBvc2UgaW50ZXJuYWxzXFxuXFxuXFx0XFx0dGhpcy50YW5nZW50cyA9IGZyYW1lcy50YW5nZW50cztcXG5cXHRcXHR0aGlzLm5vcm1hbHMgPSBmcmFtZXMubm9ybWFscztcXG5cXHRcXHR0aGlzLmJpbm9ybWFscyA9IGZyYW1lcy5iaW5vcm1hbHM7XFxuXFxuXFx0XFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xcblxcblxcdFxcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHZhciBub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHZhciB1diA9IG5ldyBWZWN0b3IyKCk7XFxuXFx0XFx0dmFyIFAgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdHZhciBpLCBqO1xcblxcblxcdFxcdC8vIGJ1ZmZlclxcblxcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdO1xcblxcdFxcdHZhciBub3JtYWxzID0gW107XFxuXFx0XFx0dmFyIHV2cyA9IFtdO1xcblxcdFxcdHZhciBpbmRpY2VzID0gW107XFxuXFxuXFx0XFx0Ly8gY3JlYXRlIGJ1ZmZlciBkYXRhXFxuXFxuXFx0XFx0Z2VuZXJhdGVCdWZmZXJEYXRhKCk7XFxuXFxuXFx0XFx0Ly8gYnVpbGQgZ2VvbWV0cnlcXG5cXG5cXHRcXHR0aGlzLnNldEluZGV4KCBpbmRpY2VzICk7XFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICdub3JtYWwnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFscywgMyApICk7XFxuXFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dnMsIDIgKSApO1xcblxcblxcdFxcdC8vIGZ1bmN0aW9uc1xcblxcblxcdFxcdGZ1bmN0aW9uIGdlbmVyYXRlQnVmZmVyRGF0YSgpIHtcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRnZW5lcmF0ZVNlZ21lbnQoIGkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gaWYgdGhlIGdlb21ldHJ5IGlzIG5vdCBjbG9zZWQsIGdlbmVyYXRlIHRoZSBsYXN0IHJvdyBvZiB2ZXJ0aWNlcyBhbmQgbm9ybWFsc1xcblxcdFxcdFxcdC8vIGF0IHRoZSByZWd1bGFyIHBvc2l0aW9uIG9uIHRoZSBnaXZlbiBwYXRoXFxuXFx0XFx0XFx0Ly9cXG5cXHRcXHRcXHQvLyBpZiB0aGUgZ2VvbWV0cnkgaXMgY2xvc2VkLCBkdXBsaWNhdGUgdGhlIGZpcnN0IHJvdyBvZiB2ZXJ0aWNlcyBhbmQgbm9ybWFscyAodXZzIHdpbGwgZGlmZmVyKVxcblxcblxcdFxcdFxcdGdlbmVyYXRlU2VnbWVudCggKCBjbG9zZWQgPT09IGZhbHNlICkgPyB0dWJ1bGFyU2VnbWVudHMgOiAwICk7XFxuXFxuXFx0XFx0XFx0Ly8gdXZzIGFyZSBnZW5lcmF0ZWQgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbi5cXG5cXHRcXHRcXHQvLyB0aGlzIG1ha2VzIGl0IGVhc3kgY29tcHV0ZSBjb3JyZWN0IHZhbHVlcyBmb3IgY2xvc2VkIGdlb21ldHJpZXNcXG5cXG5cXHRcXHRcXHRnZW5lcmF0ZVVWcygpO1xcblxcblxcdFxcdFxcdC8vIGZpbmFsbHkgY3JlYXRlIGZhY2VzXFxuXFxuXFx0XFx0XFx0Z2VuZXJhdGVJbmRpY2VzKCk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGdlbmVyYXRlU2VnbWVudCggaSApIHtcXG5cXG5cXHRcXHRcXHQvLyB3ZSB1c2UgZ2V0UG9pbnRBdCB0byBzYW1wbGUgZXZlbmx5IGRpc3RyaWJ1dGVkIHBvaW50cyBmcm9tIHRoZSBnaXZlbiBwYXRoXFxuXFxuXFx0XFx0XFx0UCA9IHBhdGguZ2V0UG9pbnRBdCggaSAvIHR1YnVsYXJTZWdtZW50cywgUCApO1xcblxcblxcdFxcdFxcdC8vIHJldHJpZXZlIGNvcnJlc3BvbmRpbmcgbm9ybWFsIGFuZCBiaW5vcm1hbFxcblxcblxcdFxcdFxcdHZhciBOID0gZnJhbWVzLm5vcm1hbHNbIGkgXTtcXG5cXHRcXHRcXHR2YXIgQiA9IGZyYW1lcy5iaW5vcm1hbHNbIGkgXTtcXG5cXG5cXHRcXHRcXHQvLyBnZW5lcmF0ZSBub3JtYWxzIGFuZCB2ZXJ0aWNlcyBmb3IgdGhlIGN1cnJlbnQgc2VnbWVudFxcblxcblxcdFxcdFxcdGZvciAoIGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHNpbiA9IE1hdGguc2luKCB2ICk7XFxuXFx0XFx0XFx0XFx0dmFyIGNvcyA9IC0gTWF0aC5jb3MoIHYgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBub3JtYWxcXG5cXG5cXHRcXHRcXHRcXHRub3JtYWwueCA9ICggY29zICogTi54ICsgc2luICogQi54ICk7XFxuXFx0XFx0XFx0XFx0bm9ybWFsLnkgPSAoIGNvcyAqIE4ueSArIHNpbiAqIEIueSApO1xcblxcdFxcdFxcdFxcdG5vcm1hbC56ID0gKCBjb3MgKiBOLnogKyBzaW4gKiBCLnogKTtcXG5cXHRcXHRcXHRcXHRub3JtYWwubm9ybWFsaXplKCk7XFxuXFxuXFx0XFx0XFx0XFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdmVydGV4XFxuXFxuXFx0XFx0XFx0XFx0dmVydGV4LnggPSBQLnggKyByYWRpdXMgKiBub3JtYWwueDtcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueSA9IFAueSArIHJhZGl1cyAqIG5vcm1hbC55O1xcblxcdFxcdFxcdFxcdHZlcnRleC56ID0gUC56ICsgcmFkaXVzICogbm9ybWFsLno7XFxuXFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZ2VuZXJhdGVJbmRpY2VzKCkge1xcblxcblxcdFxcdFxcdGZvciAoIGogPSAxOyBqIDw9IHR1YnVsYXJTZWdtZW50czsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMTsgaSA8PSByYWRpYWxTZWdtZW50czsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgYSA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyAoIGkgLSAxICk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGIgPSAoIHJhZGlhbFNlZ21lbnRzICsgMSApICogaiArICggaSAtIDEgKTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgYyA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiBqICsgaTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZCA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiAoIGogLSAxICkgKyBpO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGZhY2VzXFxuXFxuXFx0XFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XFxuXFx0XFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZ2VuZXJhdGVVVnMoKSB7XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGZvciAoIGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHV2LnggPSBpIC8gdHVidWxhclNlZ21lbnRzO1xcblxcdFxcdFxcdFxcdFxcdHV2LnkgPSBqIC8gcmFkaWFsU2VnbWVudHM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0VHViZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdFR1YmVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUdWJlQnVmZmVyR2VvbWV0cnk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBvb3Ntb3hpZWNvZGVcXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqXFxuXFx0ICogYmFzZWQgb24gaHR0cDovL3d3dy5ibGFja3Bhd24uY29tL3RleHRzL3BxdG9ydXMvXFxuXFx0ICovXFxuXFxuXFx0Ly8gVG9ydXNLbm90R2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBUb3J1c0tub3RHZW9tZXRyeSggcmFkaXVzLCB0dWJlLCB0dWJ1bGFyU2VnbWVudHMsIHJhZGlhbFNlZ21lbnRzLCBwLCBxLCBoZWlnaHRTY2FsZSApIHtcXG5cXG5cXHRcXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1RvcnVzS25vdEdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxuXFx0XFx0XFx0dHViZTogdHViZSxcXG5cXHRcXHRcXHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcXG5cXHRcXHRcXHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXFxuXFx0XFx0XFx0cDogcCxcXG5cXHRcXHRcXHRxOiBxXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRpZiAoIGhlaWdodFNjYWxlICE9PSB1bmRlZmluZWQgKSBjb25zb2xlLndhcm4oICdUSFJFRS5Ub3J1c0tub3RHZW9tZXRyeTogaGVpZ2h0U2NhbGUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC5zY2FsZSggeCwgeSwgeiApIGluc3RlYWQuJyApO1xcblxcblxcdFxcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgVG9ydXNLbm90QnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgdHViZSwgdHVidWxhclNlZ21lbnRzLCByYWRpYWxTZWdtZW50cywgcCwgcSApICk7XFxuXFx0XFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XFxuXFxuXFx0fVxcblxcblxcdFRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdFRvcnVzS25vdEdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvcnVzS25vdEdlb21ldHJ5O1xcblxcblxcdC8vIFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gVG9ydXNLbm90QnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgdHViZSwgdHVidWxhclNlZ21lbnRzLCByYWRpYWxTZWdtZW50cywgcCwgcSApIHtcXG5cXG5cXHRcXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1RvcnVzS25vdEJ1ZmZlckdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxuXFx0XFx0XFx0dHViZTogdHViZSxcXG5cXHRcXHRcXHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcXG5cXHRcXHRcXHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXFxuXFx0XFx0XFx0cDogcCxcXG5cXHRcXHRcXHRxOiBxXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRyYWRpdXMgPSByYWRpdXMgfHwgMTtcXG5cXHRcXHR0dWJlID0gdHViZSB8fCAwLjQ7XFxuXFx0XFx0dHVidWxhclNlZ21lbnRzID0gTWF0aC5mbG9vciggdHVidWxhclNlZ21lbnRzICkgfHwgNjQ7XFxuXFx0XFx0cmFkaWFsU2VnbWVudHMgPSBNYXRoLmZsb29yKCByYWRpYWxTZWdtZW50cyApIHx8IDg7XFxuXFx0XFx0cCA9IHAgfHwgMjtcXG5cXHRcXHRxID0gcSB8fCAzO1xcblxcblxcdFxcdC8vIGJ1ZmZlcnNcXG5cXG5cXHRcXHR2YXIgaW5kaWNlcyA9IFtdO1xcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdO1xcblxcdFxcdHZhciBub3JtYWxzID0gW107XFxuXFx0XFx0dmFyIHV2cyA9IFtdO1xcblxcblxcdFxcdC8vIGhlbHBlciB2YXJpYWJsZXNcXG5cXG5cXHRcXHR2YXIgaSwgajtcXG5cXG5cXHRcXHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHR2YXIgUDEgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHZhciBQMiA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0dmFyIEIgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHZhciBUID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR2YXIgTiA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xcblxcblxcdFxcdGZvciAoIGkgPSAwOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHQvLyB0aGUgcmFkaWFuIFxcXCJ1XFxcIiBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgcG9zaXRpb24gb24gdGhlIHRvcnVzIGN1cnZlIG9mIHRoZSBjdXJyZW50IHR1YnVsYXIgc2VnZW1lbnRcXG5cXG5cXHRcXHRcXHR2YXIgdSA9IGkgLyB0dWJ1bGFyU2VnbWVudHMgKiBwICogTWF0aC5QSSAqIDI7XFxuXFxuXFx0XFx0XFx0Ly8gbm93IHdlIGNhbGN1bGF0ZSB0d28gcG9pbnRzLiBQMSBpcyBvdXIgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgY3VydmUsIFAyIGlzIGEgbGl0dGxlIGZhcnRoZXIgYWhlYWQuXFxuXFx0XFx0XFx0Ly8gdGhlc2UgcG9pbnRzIGFyZSB1c2VkIHRvIGNyZWF0ZSBhIHNwZWNpYWwgXFxcImNvb3JkaW5hdGUgc3BhY2VcXFwiLCB3aGljaCBpcyBuZWNlc3NhcnkgdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHZlcnRleCBwb3NpdGlvbnNcXG5cXG5cXHRcXHRcXHRjYWxjdWxhdGVQb3NpdGlvbk9uQ3VydmUoIHUsIHAsIHEsIHJhZGl1cywgUDEgKTtcXG5cXHRcXHRcXHRjYWxjdWxhdGVQb3NpdGlvbk9uQ3VydmUoIHUgKyAwLjAxLCBwLCBxLCByYWRpdXMsIFAyICk7XFxuXFxuXFx0XFx0XFx0Ly8gY2FsY3VsYXRlIG9ydGhvbm9ybWFsIGJhc2lzXFxuXFxuXFx0XFx0XFx0VC5zdWJWZWN0b3JzKCBQMiwgUDEgKTtcXG5cXHRcXHRcXHROLmFkZFZlY3RvcnMoIFAyLCBQMSApO1xcblxcdFxcdFxcdEIuY3Jvc3NWZWN0b3JzKCBULCBOICk7XFxuXFx0XFx0XFx0Ti5jcm9zc1ZlY3RvcnMoIEIsIFQgKTtcXG5cXG5cXHRcXHRcXHQvLyBub3JtYWxpemUgQiwgTi4gVCBjYW4gYmUgaWdub3JlZCwgd2UgZG9uJ3QgdXNlIGl0XFxuXFxuXFx0XFx0XFx0Qi5ub3JtYWxpemUoKTtcXG5cXHRcXHRcXHROLm5vcm1hbGl6ZSgpO1xcblxcblxcdFxcdFxcdGZvciAoIGogPSAwOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyArKyBqICkge1xcblxcblxcdFxcdFxcdFxcdC8vIG5vdyBjYWxjdWxhdGUgdGhlIHZlcnRpY2VzLiB0aGV5IGFyZSBub3RoaW5nIG1vcmUgdGhhbiBhbiBleHRydXNpb24gb2YgdGhlIHRvcnVzIGN1cnZlLlxcblxcdFxcdFxcdFxcdC8vIGJlY2F1c2Ugd2UgZXh0cnVkZSBhIHNoYXBlIGluIHRoZSB4eS1wbGFuZSwgdGhlcmUgaXMgbm8gbmVlZCB0byBjYWxjdWxhdGUgYSB6LXZhbHVlLlxcblxcblxcdFxcdFxcdFxcdHZhciB2ID0gaiAvIHJhZGlhbFNlZ21lbnRzICogTWF0aC5QSSAqIDI7XFxuXFx0XFx0XFx0XFx0dmFyIGN4ID0gLSB0dWJlICogTWF0aC5jb3MoIHYgKTtcXG5cXHRcXHRcXHRcXHR2YXIgY3kgPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBub3cgY2FsY3VsYXRlIHRoZSBmaW5hbCB2ZXJ0ZXggcG9zaXRpb24uXFxuXFx0XFx0XFx0XFx0Ly8gZmlyc3Qgd2Ugb3JpZW50IHRoZSBleHRydXNpb24gd2l0aCBvdXIgYmFzaXMgdmVjdG9zLCB0aGVuIHdlIGFkZCBpdCB0byB0aGUgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgY3VydmVcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueCA9IFAxLnggKyAoIGN4ICogTi54ICsgY3kgKiBCLnggKTtcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueSA9IFAxLnkgKyAoIGN4ICogTi55ICsgY3kgKiBCLnkgKTtcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueiA9IFAxLnogKyAoIGN4ICogTi56ICsgY3kgKiBCLnogKTtcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbm9ybWFsIChQMSBpcyBhbHdheXMgdGhlIGNlbnRlci9vcmlnaW4gb2YgdGhlIGV4dHJ1c2lvbiwgdGh1cyB3ZSBjYW4gdXNlIGl0IHRvIGNhbGN1bGF0ZSB0aGUgbm9ybWFsKVxcblxcblxcdFxcdFxcdFxcdG5vcm1hbC5zdWJWZWN0b3JzKCB2ZXJ0ZXgsIFAxICkubm9ybWFsaXplKCk7XFxuXFxuXFx0XFx0XFx0XFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdXZcXG5cXG5cXHRcXHRcXHRcXHR1dnMucHVzaCggaSAvIHR1YnVsYXJTZWdtZW50cyApO1xcblxcdFxcdFxcdFxcdHV2cy5wdXNoKCBqIC8gcmFkaWFsU2VnbWVudHMgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGdlbmVyYXRlIGluZGljZXNcXG5cXG5cXHRcXHRmb3IgKCBqID0gMTsgaiA8PSB0dWJ1bGFyU2VnbWVudHM7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDE7IGkgPD0gcmFkaWFsU2VnbWVudHM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gaW5kaWNlc1xcblxcblxcdFxcdFxcdFxcdHZhciBhID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArICggaSAtIDEgKTtcXG5cXHRcXHRcXHRcXHR2YXIgYiA9ICggcmFkaWFsU2VnbWVudHMgKyAxICkgKiBqICsgKCBpIC0gMSApO1xcblxcdFxcdFxcdFxcdHZhciBjID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqIGogKyBpO1xcblxcdFxcdFxcdFxcdHZhciBkID0gKCByYWRpYWxTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gZmFjZXNcXG5cXG5cXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcXG5cXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGJ1aWxkIGdlb21ldHJ5XFxuXFxuXFx0XFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcXG5cXG5cXHRcXHQvLyB0aGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIGN1cnJlbnQgcG9zaXRpb24gb24gdGhlIHRvcnVzIGN1cnZlXFxuXFxuXFx0XFx0ZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25PbkN1cnZlKCB1LCBwLCBxLCByYWRpdXMsIHBvc2l0aW9uICkge1xcblxcblxcdFxcdFxcdHZhciBjdSA9IE1hdGguY29zKCB1ICk7XFxuXFx0XFx0XFx0dmFyIHN1ID0gTWF0aC5zaW4oIHUgKTtcXG5cXHRcXHRcXHR2YXIgcXVPdmVyUCA9IHEgLyBwICogdTtcXG5cXHRcXHRcXHR2YXIgY3MgPSBNYXRoLmNvcyggcXVPdmVyUCApO1xcblxcblxcdFxcdFxcdHBvc2l0aW9uLnggPSByYWRpdXMgKiAoIDIgKyBjcyApICogMC41ICogY3U7XFxuXFx0XFx0XFx0cG9zaXRpb24ueSA9IHJhZGl1cyAqICggMiArIGNzICkgKiBzdSAqIDAuNTtcXG5cXHRcXHRcXHRwb3NpdGlvbi56ID0gcmFkaXVzICogTWF0aC5zaW4oIHF1T3ZlclAgKSAqIDAuNTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRvcnVzS25vdEJ1ZmZlckdlb21ldHJ5O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3Igb29zbW94aWVjb2RlXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqL1xcblxcblxcdC8vIFRvcnVzR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBUb3J1c0dlb21ldHJ5KCByYWRpdXMsIHR1YmUsIHJhZGlhbFNlZ21lbnRzLCB0dWJ1bGFyU2VnbWVudHMsIGFyYyApIHtcXG5cXG5cXHRcXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1RvcnVzR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXG5cXHRcXHRcXHR0dWJlOiB0dWJlLFxcblxcdFxcdFxcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcXG5cXHRcXHRcXHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcXG5cXHRcXHRcXHRhcmM6IGFyY1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBUb3J1c0J1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHR1YmUsIHJhZGlhbFNlZ21lbnRzLCB0dWJ1bGFyU2VnbWVudHMsIGFyYyApICk7XFxuXFx0XFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XFxuXFxuXFx0fVxcblxcblxcdFRvcnVzR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0VG9ydXNHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb3J1c0dlb21ldHJ5O1xcblxcblxcdC8vIFRvcnVzQnVmZmVyR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBUb3J1c0J1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHR1YmUsIHJhZGlhbFNlZ21lbnRzLCB0dWJ1bGFyU2VnbWVudHMsIGFyYyApIHtcXG5cXG5cXHRcXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1RvcnVzQnVmZmVyR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXG5cXHRcXHRcXHR0dWJlOiB0dWJlLFxcblxcdFxcdFxcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcXG5cXHRcXHRcXHR0dWJ1bGFyU2VnbWVudHM6IHR1YnVsYXJTZWdtZW50cyxcXG5cXHRcXHRcXHRhcmM6IGFyY1xcblxcdFxcdH07XFxuXFxuXFx0XFx0cmFkaXVzID0gcmFkaXVzIHx8IDE7XFxuXFx0XFx0dHViZSA9IHR1YmUgfHwgMC40O1xcblxcdFxcdHJhZGlhbFNlZ21lbnRzID0gTWF0aC5mbG9vciggcmFkaWFsU2VnbWVudHMgKSB8fCA4O1xcblxcdFxcdHR1YnVsYXJTZWdtZW50cyA9IE1hdGguZmxvb3IoIHR1YnVsYXJTZWdtZW50cyApIHx8IDY7XFxuXFx0XFx0YXJjID0gYXJjIHx8IE1hdGguUEkgKiAyO1xcblxcblxcdFxcdC8vIGJ1ZmZlcnNcXG5cXG5cXHRcXHR2YXIgaW5kaWNlcyA9IFtdO1xcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdO1xcblxcdFxcdHZhciBub3JtYWxzID0gW107XFxuXFx0XFx0dmFyIHV2cyA9IFtdO1xcblxcblxcdFxcdC8vIGhlbHBlciB2YXJpYWJsZXNcXG5cXG5cXHRcXHR2YXIgY2VudGVyID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHR2YXIgaiwgaTtcXG5cXG5cXHRcXHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXFxuXFxuXFx0XFx0Zm9yICggaiA9IDA7IGogPD0gcmFkaWFsU2VnbWVudHM7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPD0gdHVidWxhclNlZ21lbnRzOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB1ID0gaSAvIHR1YnVsYXJTZWdtZW50cyAqIGFyYztcXG5cXHRcXHRcXHRcXHR2YXIgdiA9IGogLyByYWRpYWxTZWdtZW50cyAqIE1hdGguUEkgKiAyO1xcblxcblxcdFxcdFxcdFxcdC8vIHZlcnRleFxcblxcblxcdFxcdFxcdFxcdHZlcnRleC54ID0gKCByYWRpdXMgKyB0dWJlICogTWF0aC5jb3MoIHYgKSApICogTWF0aC5jb3MoIHUgKTtcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueSA9ICggcmFkaXVzICsgdHViZSAqIE1hdGguY29zKCB2ICkgKSAqIE1hdGguc2luKCB1ICk7XFxuXFx0XFx0XFx0XFx0dmVydGV4LnogPSB0dWJlICogTWF0aC5zaW4oIHYgKTtcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbm9ybWFsXFxuXFxuXFx0XFx0XFx0XFx0Y2VudGVyLnggPSByYWRpdXMgKiBNYXRoLmNvcyggdSApO1xcblxcdFxcdFxcdFxcdGNlbnRlci55ID0gcmFkaXVzICogTWF0aC5zaW4oIHUgKTtcXG5cXHRcXHRcXHRcXHRub3JtYWwuc3ViVmVjdG9ycyggdmVydGV4LCBjZW50ZXIgKS5ub3JtYWxpemUoKTtcXG5cXG5cXHRcXHRcXHRcXHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyB1dlxcblxcblxcdFxcdFxcdFxcdHV2cy5wdXNoKCBpIC8gdHVidWxhclNlZ21lbnRzICk7XFxuXFx0XFx0XFx0XFx0dXZzLnB1c2goIGogLyByYWRpYWxTZWdtZW50cyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gZ2VuZXJhdGUgaW5kaWNlc1xcblxcblxcdFxcdGZvciAoIGogPSAxOyBqIDw9IHJhZGlhbFNlZ21lbnRzOyBqICsrICkge1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAxOyBpIDw9IHR1YnVsYXJTZWdtZW50czsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpbmRpY2VzXFxuXFxuXFx0XFx0XFx0XFx0dmFyIGEgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpIC0gMTtcXG5cXHRcXHRcXHRcXHR2YXIgYiA9ICggdHVidWxhclNlZ21lbnRzICsgMSApICogKCBqIC0gMSApICsgaSAtIDE7XFxuXFx0XFx0XFx0XFx0dmFyIGMgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqICggaiAtIDEgKSArIGk7XFxuXFx0XFx0XFx0XFx0dmFyIGQgPSAoIHR1YnVsYXJTZWdtZW50cyArIDEgKSAqIGogKyBpO1xcblxcblxcdFxcdFxcdFxcdC8vIGZhY2VzXFxuXFxuXFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBkICk7XFxuXFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBiLCBjLCBkICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBidWlsZCBnZW9tZXRyeVxcblxcblxcdFxcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XFxuXFxuXFx0fVxcblxcblxcdFRvcnVzQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0VG9ydXNCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb3J1c0J1ZmZlckdlb21ldHJ5O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxuXFx0ICogUG9ydCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvZWFyY3V0ICh2Mi4xLjIpXFxuXFx0ICovXFxuXFxuXFx0dmFyIEVhcmN1dCA9IHtcXG5cXG5cXHRcXHR0cmlhbmd1bGF0ZTogZnVuY3Rpb24gKCBkYXRhLCBob2xlSW5kaWNlcywgZGltICkge1xcblxcblxcdFxcdFxcdGRpbSA9IGRpbSB8fCAyO1xcblxcblxcdFxcdFxcdHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbIDAgXSAqIGRpbSA6IGRhdGEubGVuZ3RoLFxcblxcdFxcdFxcdFxcdG91dGVyTm9kZSA9IGxpbmtlZExpc3QoIGRhdGEsIDAsIG91dGVyTGVuLCBkaW0sIHRydWUgKSxcXG5cXHRcXHRcXHRcXHR0cmlhbmdsZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRpZiAoICEgb3V0ZXJOb2RlICkgcmV0dXJuIHRyaWFuZ2xlcztcXG5cXG5cXHRcXHRcXHR2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgeCwgeSwgaW52U2l6ZTtcXG5cXG5cXHRcXHRcXHRpZiAoIGhhc0hvbGVzICkgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMoIGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSApO1xcblxcblxcdFxcdFxcdC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxcblxcblxcdFxcdFxcdGlmICggZGF0YS5sZW5ndGggPiA4MCAqIGRpbSApIHtcXG5cXG5cXHRcXHRcXHRcXHRtaW5YID0gbWF4WCA9IGRhdGFbIDAgXTtcXG5cXHRcXHRcXHRcXHRtaW5ZID0gbWF4WSA9IGRhdGFbIDEgXTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IGRpbTsgaSA8IG91dGVyTGVuOyBpICs9IGRpbSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR4ID0gZGF0YVsgaSBdO1xcblxcdFxcdFxcdFxcdFxcdHkgPSBkYXRhWyBpICsgMSBdO1xcblxcdFxcdFxcdFxcdFxcdGlmICggeCA8IG1pblggKSBtaW5YID0geDtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHkgPCBtaW5ZICkgbWluWSA9IHk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB4ID4gbWF4WCApIG1heFggPSB4O1xcblxcdFxcdFxcdFxcdFxcdGlmICggeSA+IG1heFkgKSBtYXhZID0geTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbWluWCwgbWluWSBhbmQgaW52U2l6ZSBhcmUgbGF0ZXIgdXNlZCB0byB0cmFuc2Zvcm0gY29vcmRzIGludG8gaW50ZWdlcnMgZm9yIHotb3JkZXIgY2FsY3VsYXRpb25cXG5cXG5cXHRcXHRcXHRcXHRpbnZTaXplID0gTWF0aC5tYXgoIG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSApO1xcblxcdFxcdFxcdFxcdGludlNpemUgPSBpbnZTaXplICE9PSAwID8gMSAvIGludlNpemUgOiAwO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRlYXJjdXRMaW5rZWQoIG91dGVyTm9kZSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdHJpYW5nbGVzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9O1xcblxcblxcdC8vIGNyZWF0ZSBhIGNpcmN1bGFyIGRvdWJseSBsaW5rZWQgbGlzdCBmcm9tIHBvbHlnb24gcG9pbnRzIGluIHRoZSBzcGVjaWZpZWQgd2luZGluZyBvcmRlclxcblxcblxcdGZ1bmN0aW9uIGxpbmtlZExpc3QoIGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgY2xvY2t3aXNlICkge1xcblxcblxcdFxcdHZhciBpLCBsYXN0O1xcblxcblxcdFxcdGlmICggY2xvY2t3aXNlID09PSAoIHNpZ25lZEFyZWEoIGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSApID4gMCApICkge1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBkaW0gKSBsYXN0ID0gaW5zZXJ0Tm9kZSggaSwgZGF0YVsgaSBdLCBkYXRhWyBpICsgMSBdLCBsYXN0ICk7XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSApIGxhc3QgPSBpbnNlcnROb2RlKCBpLCBkYXRhWyBpIF0sIGRhdGFbIGkgKyAxIF0sIGxhc3QgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCBsYXN0ICYmIGVxdWFscyggbGFzdCwgbGFzdC5uZXh0ICkgKSB7XFxuXFxuXFx0XFx0XFx0cmVtb3ZlTm9kZSggbGFzdCApO1xcblxcdFxcdFxcdGxhc3QgPSBsYXN0Lm5leHQ7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBsYXN0O1xcblxcblxcdH1cXG5cXG5cXHQvLyBlbGltaW5hdGUgY29saW5lYXIgb3IgZHVwbGljYXRlIHBvaW50c1xcblxcblxcdGZ1bmN0aW9uIGZpbHRlclBvaW50cyggc3RhcnQsIGVuZCApIHtcXG5cXG5cXHRcXHRpZiAoICEgc3RhcnQgKSByZXR1cm4gc3RhcnQ7XFxuXFx0XFx0aWYgKCAhIGVuZCApIGVuZCA9IHN0YXJ0O1xcblxcblxcdFxcdHZhciBwID0gc3RhcnQsIGFnYWluO1xcblxcblxcdFxcdGRvIHtcXG5cXG5cXHRcXHRcXHRhZ2FpbiA9IGZhbHNlO1xcblxcblxcdFxcdFxcdGlmICggISBwLnN0ZWluZXIgJiYgKCBlcXVhbHMoIHAsIHAubmV4dCApIHx8IGFyZWEoIHAucHJldiwgcCwgcC5uZXh0ICkgPT09IDAgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZW1vdmVOb2RlKCBwICk7XFxuXFx0XFx0XFx0XFx0cCA9IGVuZCA9IHAucHJldjtcXG5cXHRcXHRcXHRcXHRpZiAoIHAgPT09IHAubmV4dCApIGJyZWFrO1xcblxcdFxcdFxcdFxcdGFnYWluID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHAgPSBwLm5leHQ7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0gd2hpbGUgKCBhZ2FpbiB8fCBwICE9PSBlbmQgKTtcXG5cXG5cXHRcXHRyZXR1cm4gZW5kO1xcblxcblxcdH1cXG5cXG5cXHQvLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcXG5cXG5cXHRmdW5jdGlvbiBlYXJjdXRMaW5rZWQoIGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIHBhc3MgKSB7XFxuXFxuXFx0XFx0aWYgKCAhIGVhciApIHJldHVybjtcXG5cXG5cXHRcXHQvLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXFxuXFxuXFx0XFx0aWYgKCAhIHBhc3MgJiYgaW52U2l6ZSApIGluZGV4Q3VydmUoIGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSApO1xcblxcblxcdFxcdHZhciBzdG9wID0gZWFyLCBwcmV2LCBuZXh0O1xcblxcblxcdFxcdC8vIGl0ZXJhdGUgdGhyb3VnaCBlYXJzLCBzbGljaW5nIHRoZW0gb25lIGJ5IG9uZVxcblxcblxcdFxcdHdoaWxlICggZWFyLnByZXYgIT09IGVhci5uZXh0ICkge1xcblxcblxcdFxcdFxcdHByZXYgPSBlYXIucHJldjtcXG5cXHRcXHRcXHRuZXh0ID0gZWFyLm5leHQ7XFxuXFxuXFx0XFx0XFx0aWYgKCBpbnZTaXplID8gaXNFYXJIYXNoZWQoIGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSApIDogaXNFYXIoIGVhciApICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXFxuXFx0XFx0XFx0XFx0dHJpYW5nbGVzLnB1c2goIHByZXYuaSAvIGRpbSApO1xcblxcdFxcdFxcdFxcdHRyaWFuZ2xlcy5wdXNoKCBlYXIuaSAvIGRpbSApO1xcblxcdFxcdFxcdFxcdHRyaWFuZ2xlcy5wdXNoKCBuZXh0LmkgLyBkaW0gKTtcXG5cXG5cXHRcXHRcXHRcXHRyZW1vdmVOb2RlKCBlYXIgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBza2lwcGluZyB0aGUgbmV4dCB2ZXJ0aWNlIGxlYWRzIHRvIGxlc3Mgc2xpdmVyIHRyaWFuZ2xlc1xcblxcdFxcdFxcdFxcdGVhciA9IG5leHQubmV4dDtcXG5cXHRcXHRcXHRcXHRzdG9wID0gbmV4dC5uZXh0O1xcblxcblxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRlYXIgPSBuZXh0O1xcblxcblxcdFxcdFxcdC8vIGlmIHdlIGxvb3BlZCB0aHJvdWdoIHRoZSB3aG9sZSByZW1haW5pbmcgcG9seWdvbiBhbmQgY2FuJ3QgZmluZCBhbnkgbW9yZSBlYXJzXFxuXFxuXFx0XFx0XFx0aWYgKCBlYXIgPT09IHN0b3AgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIHNsaWNpbmcgYWdhaW5cXG5cXG5cXHRcXHRcXHRcXHRpZiAoICEgcGFzcyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRlYXJjdXRMaW5rZWQoIGZpbHRlclBvaW50cyggZWFyICksIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCAxICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaWYgdGhpcyBkaWRuJ3Qgd29yaywgdHJ5IGN1cmluZyBhbGwgc21hbGwgc2VsZi1pbnRlcnNlY3Rpb25zIGxvY2FsbHlcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBwYXNzID09PSAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGVhciA9IGN1cmVMb2NhbEludGVyc2VjdGlvbnMoIGVhciwgdHJpYW5nbGVzLCBkaW0gKTtcXG5cXHRcXHRcXHRcXHRcXHRlYXJjdXRMaW5rZWQoIGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDIgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBhcyBhIGxhc3QgcmVzb3J0LCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIHBhc3MgPT09IDIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c3BsaXRFYXJjdXQoIGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHR9XFxuXFxuXFx0Ly8gY2hlY2sgd2hldGhlciBhIHBvbHlnb24gbm9kZSBmb3JtcyBhIHZhbGlkIGVhciB3aXRoIGFkamFjZW50IG5vZGVzXFxuXFxuXFx0ZnVuY3Rpb24gaXNFYXIoIGVhciApIHtcXG5cXG5cXHRcXHR2YXIgYSA9IGVhci5wcmV2LFxcblxcdFxcdFxcdGIgPSBlYXIsXFxuXFx0XFx0XFx0YyA9IGVhci5uZXh0O1xcblxcblxcdFxcdGlmICggYXJlYSggYSwgYiwgYyApID49IDAgKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXFxuXFxuXFx0XFx0Ly8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcXG5cXHRcXHR2YXIgcCA9IGVhci5uZXh0Lm5leHQ7XFxuXFxuXFx0XFx0d2hpbGUgKCBwICE9PSBlYXIucHJldiApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHBvaW50SW5UcmlhbmdsZSggYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkgKSAmJiBhcmVhKCBwLnByZXYsIHAsIHAubmV4dCApID49IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRwID0gcC5uZXh0O1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdHJ1ZTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gaXNFYXJIYXNoZWQoIGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSApIHtcXG5cXG5cXHRcXHR2YXIgYSA9IGVhci5wcmV2LFxcblxcdFxcdFxcdGIgPSBlYXIsXFxuXFx0XFx0XFx0YyA9IGVhci5uZXh0O1xcblxcblxcdFxcdGlmICggYXJlYSggYSwgYiwgYyApID49IDAgKSByZXR1cm4gZmFsc2U7IC8vIHJlZmxleCwgY2FuJ3QgYmUgYW4gZWFyXFxuXFxuXFx0XFx0Ly8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcXG5cXG5cXHRcXHR2YXIgbWluVFggPSBhLnggPCBiLnggPyAoIGEueCA8IGMueCA/IGEueCA6IGMueCApIDogKCBiLnggPCBjLnggPyBiLnggOiBjLnggKSxcXG5cXHRcXHRcXHRtaW5UWSA9IGEueSA8IGIueSA/ICggYS55IDwgYy55ID8gYS55IDogYy55ICkgOiAoIGIueSA8IGMueSA/IGIueSA6IGMueSApLFxcblxcdFxcdFxcdG1heFRYID0gYS54ID4gYi54ID8gKCBhLnggPiBjLnggPyBhLnggOiBjLnggKSA6ICggYi54ID4gYy54ID8gYi54IDogYy54ICksXFxuXFx0XFx0XFx0bWF4VFkgPSBhLnkgPiBiLnkgPyAoIGEueSA+IGMueSA/IGEueSA6IGMueSApIDogKCBiLnkgPiBjLnkgPyBiLnkgOiBjLnkgKTtcXG5cXG5cXHRcXHQvLyB6LW9yZGVyIHJhbmdlIGZvciB0aGUgY3VycmVudCB0cmlhbmdsZSBiYm94O1xcblxcblxcdFxcdHZhciBtaW5aID0gek9yZGVyKCBtaW5UWCwgbWluVFksIG1pblgsIG1pblksIGludlNpemUgKSxcXG5cXHRcXHRcXHRtYXhaID0gek9yZGVyKCBtYXhUWCwgbWF4VFksIG1pblgsIG1pblksIGludlNpemUgKTtcXG5cXG5cXHRcXHQvLyBmaXJzdCBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBpbiBpbmNyZWFzaW5nIHotb3JkZXJcXG5cXG5cXHRcXHR2YXIgcCA9IGVhci5uZXh0WjtcXG5cXG5cXHRcXHR3aGlsZSAoIHAgJiYgcC56IDw9IG1heFogKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJlxcblxcdFxcdFxcdFxcdFxcdHBvaW50SW5UcmlhbmdsZSggYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkgKSAmJlxcblxcdFxcdFxcdFxcdFxcdGFyZWEoIHAucHJldiwgcCwgcC5uZXh0ICkgPj0gMCApIHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRwID0gcC5uZXh0WjtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gdGhlbiBsb29rIGZvciBwb2ludHMgaW4gZGVjcmVhc2luZyB6LW9yZGVyXFxuXFxuXFx0XFx0cCA9IGVhci5wcmV2WjtcXG5cXG5cXHRcXHR3aGlsZSAoIHAgJiYgcC56ID49IG1pblogKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJlxcblxcdFxcdFxcdFxcdFxcdHBvaW50SW5UcmlhbmdsZSggYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkgKSAmJlxcblxcdFxcdFxcdFxcdFxcdGFyZWEoIHAucHJldiwgcCwgcC5uZXh0ICkgPj0gMCApIHJldHVybiBmYWxzZTtcXG5cXG5cXHRcXHRcXHRwID0gcC5wcmV2WjtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRydWU7XFxuXFxuXFx0fVxcblxcblxcdC8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXFxuXFxuXFx0ZnVuY3Rpb24gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyggc3RhcnQsIHRyaWFuZ2xlcywgZGltICkge1xcblxcblxcdFxcdHZhciBwID0gc3RhcnQ7XFxuXFxuXFx0XFx0ZG8ge1xcblxcblxcdFxcdFxcdHZhciBhID0gcC5wcmV2LCBiID0gcC5uZXh0Lm5leHQ7XFxuXFxuXFx0XFx0XFx0aWYgKCAhIGVxdWFscyggYSwgYiApICYmIGludGVyc2VjdHMoIGEsIHAsIHAubmV4dCwgYiApICYmIGxvY2FsbHlJbnNpZGUoIGEsIGIgKSAmJiBsb2NhbGx5SW5zaWRlKCBiLCBhICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dHJpYW5nbGVzLnB1c2goIGEuaSAvIGRpbSApO1xcblxcdFxcdFxcdFxcdHRyaWFuZ2xlcy5wdXNoKCBwLmkgLyBkaW0gKTtcXG5cXHRcXHRcXHRcXHR0cmlhbmdsZXMucHVzaCggYi5pIC8gZGltICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gcmVtb3ZlIHR3byBub2RlcyBpbnZvbHZlZFxcblxcblxcdFxcdFxcdFxcdHJlbW92ZU5vZGUoIHAgKTtcXG5cXHRcXHRcXHRcXHRyZW1vdmVOb2RlKCBwLm5leHQgKTtcXG5cXG5cXHRcXHRcXHRcXHRwID0gc3RhcnQgPSBiO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRwID0gcC5uZXh0O1xcblxcblxcdFxcdH0gd2hpbGUgKCBwICE9PSBzdGFydCApO1xcblxcblxcdFxcdHJldHVybiBwO1xcblxcblxcdH1cXG5cXG5cXHQvLyB0cnkgc3BsaXR0aW5nIHBvbHlnb24gaW50byB0d28gYW5kIHRyaWFuZ3VsYXRlIHRoZW0gaW5kZXBlbmRlbnRseVxcblxcblxcdGZ1bmN0aW9uIHNwbGl0RWFyY3V0KCBzdGFydCwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKSB7XFxuXFxuXFx0XFx0Ly8gbG9vayBmb3IgYSB2YWxpZCBkaWFnb25hbCB0aGF0IGRpdmlkZXMgdGhlIHBvbHlnb24gaW50byB0d29cXG5cXG5cXHRcXHR2YXIgYSA9IHN0YXJ0O1xcblxcblxcdFxcdGRvIHtcXG5cXG5cXHRcXHRcXHR2YXIgYiA9IGEubmV4dC5uZXh0O1xcblxcblxcdFxcdFxcdHdoaWxlICggYiAhPT0gYS5wcmV2ICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggYS5pICE9PSBiLmkgJiYgaXNWYWxpZERpYWdvbmFsKCBhLCBiICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gc3BsaXQgdGhlIHBvbHlnb24gaW4gdHdvIGJ5IHRoZSBkaWFnb25hbFxcblxcblxcdFxcdFxcdFxcdFxcdHZhciBjID0gc3BsaXRQb2x5Z29uKCBhLCBiICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZmlsdGVyIGNvbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcXG5cXG5cXHRcXHRcXHRcXHRcXHRhID0gZmlsdGVyUG9pbnRzKCBhLCBhLm5leHQgKTtcXG5cXHRcXHRcXHRcXHRcXHRjID0gZmlsdGVyUG9pbnRzKCBjLCBjLm5leHQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBydW4gZWFyY3V0IG9uIGVhY2ggaGFsZlxcblxcblxcdFxcdFxcdFxcdFxcdGVhcmN1dExpbmtlZCggYSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUgKTtcXG5cXHRcXHRcXHRcXHRcXHRlYXJjdXRMaW5rZWQoIGMsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRiID0gYi5uZXh0O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRhID0gYS5uZXh0O1xcblxcblxcdFxcdH0gd2hpbGUgKCBhICE9PSBzdGFydCApO1xcblxcblxcdH1cXG5cXG5cXHQvLyBsaW5rIGV2ZXJ5IGhvbGUgaW50byB0aGUgb3V0ZXIgbG9vcCwgcHJvZHVjaW5nIGEgc2luZ2xlLXJpbmcgcG9seWdvbiB3aXRob3V0IGhvbGVzXFxuXFxuXFx0ZnVuY3Rpb24gZWxpbWluYXRlSG9sZXMoIGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSApIHtcXG5cXG5cXHRcXHR2YXIgcXVldWUgPSBbXSwgaSwgbGVuLCBzdGFydCwgZW5kLCBsaXN0O1xcblxcblxcdFxcdGZvciAoIGkgPSAwLCBsZW4gPSBob2xlSW5kaWNlcy5sZW5ndGg7IGkgPCBsZW47IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0c3RhcnQgPSBob2xlSW5kaWNlc1sgaSBdICogZGltO1xcblxcdFxcdFxcdGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbIGkgKyAxIF0gKiBkaW0gOiBkYXRhLmxlbmd0aDtcXG5cXHRcXHRcXHRsaXN0ID0gbGlua2VkTGlzdCggZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBmYWxzZSApO1xcblxcdFxcdFxcdGlmICggbGlzdCA9PT0gbGlzdC5uZXh0ICkgbGlzdC5zdGVpbmVyID0gdHJ1ZTtcXG5cXHRcXHRcXHRxdWV1ZS5wdXNoKCBnZXRMZWZ0bW9zdCggbGlzdCApICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHF1ZXVlLnNvcnQoIGNvbXBhcmVYICk7XFxuXFxuXFx0XFx0Ly8gcHJvY2VzcyBob2xlcyBmcm9tIGxlZnQgdG8gcmlnaHRcXG5cXG5cXHRcXHRmb3IgKCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRlbGltaW5hdGVIb2xlKCBxdWV1ZVsgaSBdLCBvdXRlck5vZGUgKTtcXG5cXHRcXHRcXHRvdXRlck5vZGUgPSBmaWx0ZXJQb2ludHMoIG91dGVyTm9kZSwgb3V0ZXJOb2RlLm5leHQgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIG91dGVyTm9kZTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gY29tcGFyZVgoIGEsIGIgKSB7XFxuXFxuXFx0XFx0cmV0dXJuIGEueCAtIGIueDtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gZmluZCBhIGJyaWRnZSBiZXR3ZWVuIHZlcnRpY2VzIHRoYXQgY29ubmVjdHMgaG9sZSB3aXRoIGFuIG91dGVyIHJpbmcgYW5kIGFuZCBsaW5rIGl0XFxuXFxuXFx0ZnVuY3Rpb24gZWxpbWluYXRlSG9sZSggaG9sZSwgb3V0ZXJOb2RlICkge1xcblxcblxcdFxcdG91dGVyTm9kZSA9IGZpbmRIb2xlQnJpZGdlKCBob2xlLCBvdXRlck5vZGUgKTtcXG5cXG5cXHRcXHRpZiAoIG91dGVyTm9kZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYiA9IHNwbGl0UG9seWdvbiggb3V0ZXJOb2RlLCBob2xlICk7XFxuXFxuXFx0XFx0XFx0ZmlsdGVyUG9pbnRzKCBiLCBiLm5leHQgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdC8vIERhdmlkIEViZXJseSdzIGFsZ29yaXRobSBmb3IgZmluZGluZyBhIGJyaWRnZSBiZXR3ZWVuIGhvbGUgYW5kIG91dGVyIHBvbHlnb25cXG5cXG5cXHRmdW5jdGlvbiBmaW5kSG9sZUJyaWRnZSggaG9sZSwgb3V0ZXJOb2RlICkge1xcblxcblxcdFxcdHZhciBwID0gb3V0ZXJOb2RlLFxcblxcdFxcdFxcdGh4ID0gaG9sZS54LFxcblxcdFxcdFxcdGh5ID0gaG9sZS55LFxcblxcdFxcdFxcdHF4ID0gLSBJbmZpbml0eSxcXG5cXHRcXHRcXHRtO1xcblxcblxcdFxcdC8vIGZpbmQgYSBzZWdtZW50IGludGVyc2VjdGVkIGJ5IGEgcmF5IGZyb20gdGhlIGhvbGUncyBsZWZ0bW9zdCBwb2ludCB0byB0aGUgbGVmdDtcXG5cXHRcXHQvLyBzZWdtZW50J3MgZW5kcG9pbnQgd2l0aCBsZXNzZXIgeCB3aWxsIGJlIHBvdGVudGlhbCBjb25uZWN0aW9uIHBvaW50XFxuXFxuXFx0XFx0ZG8ge1xcblxcblxcdFxcdFxcdGlmICggaHkgPD0gcC55ICYmIGh5ID49IHAubmV4dC55ICYmIHAubmV4dC55ICE9PSBwLnkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHggPSBwLnggKyAoIGh5IC0gcC55ICkgKiAoIHAubmV4dC54IC0gcC54ICkgLyAoIHAubmV4dC55IC0gcC55ICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB4IDw9IGh4ICYmIHggPiBxeCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRxeCA9IHg7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB4ID09PSBoeCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGh5ID09PSBwLnkgKSByZXR1cm4gcDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGh5ID09PSBwLm5leHQueSApIHJldHVybiBwLm5leHQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdG0gPSBwLnggPCBwLm5leHQueCA/IHAgOiBwLm5leHQ7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRwID0gcC5uZXh0O1xcblxcblxcdFxcdH0gd2hpbGUgKCBwICE9PSBvdXRlck5vZGUgKTtcXG5cXG5cXHRcXHRpZiAoICEgbSApIHJldHVybiBudWxsO1xcblxcblxcdFxcdGlmICggaHggPT09IHF4ICkgcmV0dXJuIG0ucHJldjsgLy8gaG9sZSB0b3VjaGVzIG91dGVyIHNlZ21lbnQ7IHBpY2sgbG93ZXIgZW5kcG9pbnRcXG5cXG5cXHRcXHQvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBvZiBob2xlIHBvaW50LCBzZWdtZW50IGludGVyc2VjdGlvbiBhbmQgZW5kcG9pbnQ7XFxuXFx0XFx0Ly8gaWYgdGhlcmUgYXJlIG5vIHBvaW50cyBmb3VuZCwgd2UgaGF2ZSBhIHZhbGlkIGNvbm5lY3Rpb247XFxuXFx0XFx0Ly8gb3RoZXJ3aXNlIGNob29zZSB0aGUgcG9pbnQgb2YgdGhlIG1pbmltdW0gYW5nbGUgd2l0aCB0aGUgcmF5IGFzIGNvbm5lY3Rpb24gcG9pbnRcXG5cXG5cXHRcXHR2YXIgc3RvcCA9IG0sXFxuXFx0XFx0XFx0bXggPSBtLngsXFxuXFx0XFx0XFx0bXkgPSBtLnksXFxuXFx0XFx0XFx0dGFuTWluID0gSW5maW5pdHksXFxuXFx0XFx0XFx0dGFuO1xcblxcblxcdFxcdHAgPSBtLm5leHQ7XFxuXFxuXFx0XFx0d2hpbGUgKCBwICE9PSBzdG9wICkge1xcblxcblxcdFxcdFxcdGlmICggaHggPj0gcC54ICYmIHAueCA+PSBteCAmJiBoeCAhPT0gcC54ICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cG9pbnRJblRyaWFuZ2xlKCBoeSA8IG15ID8gaHggOiBxeCwgaHksIG14LCBteSwgaHkgPCBteSA/IHF4IDogaHgsIGh5LCBwLngsIHAueSApICkge1xcblxcblxcdFxcdFxcdFxcdHRhbiA9IE1hdGguYWJzKCBoeSAtIHAueSApIC8gKCBoeCAtIHAueCApOyAvLyB0YW5nZW50aWFsXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAoIHRhbiA8IHRhbk1pbiB8fCAoIHRhbiA9PT0gdGFuTWluICYmIHAueCA+IG0ueCApICkgJiYgbG9jYWxseUluc2lkZSggcCwgaG9sZSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG0gPSBwO1xcblxcdFxcdFxcdFxcdFxcdHRhbk1pbiA9IHRhbjtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHAgPSBwLm5leHQ7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBtO1xcblxcblxcdH1cXG5cXG5cXHQvLyBpbnRlcmxpbmsgcG9seWdvbiBub2RlcyBpbiB6LW9yZGVyXFxuXFxuXFx0ZnVuY3Rpb24gaW5kZXhDdXJ2ZSggc3RhcnQsIG1pblgsIG1pblksIGludlNpemUgKSB7XFxuXFxuXFx0XFx0dmFyIHAgPSBzdGFydDtcXG5cXG5cXHRcXHRkbyB7XFxuXFxuXFx0XFx0XFx0aWYgKCBwLnogPT09IG51bGwgKSBwLnogPSB6T3JkZXIoIHAueCwgcC55LCBtaW5YLCBtaW5ZLCBpbnZTaXplICk7XFxuXFx0XFx0XFx0cC5wcmV2WiA9IHAucHJldjtcXG5cXHRcXHRcXHRwLm5leHRaID0gcC5uZXh0O1xcblxcdFxcdFxcdHAgPSBwLm5leHQ7XFxuXFxuXFx0XFx0fSB3aGlsZSAoIHAgIT09IHN0YXJ0ICk7XFxuXFxuXFx0XFx0cC5wcmV2Wi5uZXh0WiA9IG51bGw7XFxuXFx0XFx0cC5wcmV2WiA9IG51bGw7XFxuXFxuXFx0XFx0c29ydExpbmtlZCggcCApO1xcblxcblxcdH1cXG5cXG5cXHQvLyBTaW1vbiBUYXRoYW0ncyBsaW5rZWQgbGlzdCBtZXJnZSBzb3J0IGFsZ29yaXRobVxcblxcdC8vIGh0dHA6Ly93d3cuY2hpYXJrLmdyZWVuZW5kLm9yZy51ay9+c2d0YXRoYW0vYWxnb3JpdGhtcy9saXN0c29ydC5odG1sXFxuXFxuXFx0ZnVuY3Rpb24gc29ydExpbmtlZCggbGlzdCApIHtcXG5cXG5cXHRcXHR2YXIgaSwgcCwgcSwgZSwgdGFpbCwgbnVtTWVyZ2VzLCBwU2l6ZSwgcVNpemUsIGluU2l6ZSA9IDE7XFxuXFxuXFx0XFx0ZG8ge1xcblxcblxcdFxcdFxcdHAgPSBsaXN0O1xcblxcdFxcdFxcdGxpc3QgPSBudWxsO1xcblxcdFxcdFxcdHRhaWwgPSBudWxsO1xcblxcdFxcdFxcdG51bU1lcmdlcyA9IDA7XFxuXFxuXFx0XFx0XFx0d2hpbGUgKCBwICkge1xcblxcblxcdFxcdFxcdFxcdG51bU1lcmdlcyArKztcXG5cXHRcXHRcXHRcXHRxID0gcDtcXG5cXHRcXHRcXHRcXHRwU2l6ZSA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCBpblNpemU7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cFNpemUgKys7XFxuXFx0XFx0XFx0XFx0XFx0cSA9IHEubmV4dFo7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhIHEgKSBicmVhaztcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cVNpemUgPSBpblNpemU7XFxuXFxuXFx0XFx0XFx0XFx0d2hpbGUgKCBwU2l6ZSA+IDAgfHwgKCBxU2l6ZSA+IDAgJiYgcSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggcFNpemUgIT09IDAgJiYgKCBxU2l6ZSA9PT0gMCB8fCAhIHEgfHwgcC56IDw9IHEueiApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGUgPSBwO1xcblxcdFxcdFxcdFxcdFxcdFxcdHAgPSBwLm5leHRaO1xcblxcdFxcdFxcdFxcdFxcdFxcdHBTaXplIC0tO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZSA9IHE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cSA9IHEubmV4dFo7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cVNpemUgLS07XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdGFpbCApIHRhaWwubmV4dFogPSBlO1xcblxcdFxcdFxcdFxcdFxcdGVsc2UgbGlzdCA9IGU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZS5wcmV2WiA9IHRhaWw7XFxuXFx0XFx0XFx0XFx0XFx0dGFpbCA9IGU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHAgPSBxO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0YWlsLm5leHRaID0gbnVsbDtcXG5cXHRcXHRcXHRpblNpemUgKj0gMjtcXG5cXG5cXHRcXHR9IHdoaWxlICggbnVtTWVyZ2VzID4gMSApO1xcblxcblxcdFxcdHJldHVybiBsaXN0O1xcblxcblxcdH1cXG5cXG5cXHQvLyB6LW9yZGVyIG9mIGEgcG9pbnQgZ2l2ZW4gY29vcmRzIGFuZCBpbnZlcnNlIG9mIHRoZSBsb25nZXIgc2lkZSBvZiBkYXRhIGJib3hcXG5cXG5cXHRmdW5jdGlvbiB6T3JkZXIoIHgsIHksIG1pblgsIG1pblksIGludlNpemUgKSB7XFxuXFxuXFx0XFx0Ly8gY29vcmRzIGFyZSB0cmFuc2Zvcm1lZCBpbnRvIG5vbi1uZWdhdGl2ZSAxNS1iaXQgaW50ZWdlciByYW5nZVxcblxcblxcdFxcdHggPSAzMjc2NyAqICggeCAtIG1pblggKSAqIGludlNpemU7XFxuXFx0XFx0eSA9IDMyNzY3ICogKCB5IC0gbWluWSApICogaW52U2l6ZTtcXG5cXG5cXHRcXHR4ID0gKCB4IHwgKCB4IDw8IDggKSApICYgMHgwMEZGMDBGRjtcXG5cXHRcXHR4ID0gKCB4IHwgKCB4IDw8IDQgKSApICYgMHgwRjBGMEYwRjtcXG5cXHRcXHR4ID0gKCB4IHwgKCB4IDw8IDIgKSApICYgMHgzMzMzMzMzMztcXG5cXHRcXHR4ID0gKCB4IHwgKCB4IDw8IDEgKSApICYgMHg1NTU1NTU1NTtcXG5cXG5cXHRcXHR5ID0gKCB5IHwgKCB5IDw8IDggKSApICYgMHgwMEZGMDBGRjtcXG5cXHRcXHR5ID0gKCB5IHwgKCB5IDw8IDQgKSApICYgMHgwRjBGMEYwRjtcXG5cXHRcXHR5ID0gKCB5IHwgKCB5IDw8IDIgKSApICYgMHgzMzMzMzMzMztcXG5cXHRcXHR5ID0gKCB5IHwgKCB5IDw8IDEgKSApICYgMHg1NTU1NTU1NTtcXG5cXG5cXHRcXHRyZXR1cm4geCB8ICggeSA8PCAxICk7XFxuXFxuXFx0fVxcblxcblxcdC8vIGZpbmQgdGhlIGxlZnRtb3N0IG5vZGUgb2YgYSBwb2x5Z29uIHJpbmdcXG5cXG5cXHRmdW5jdGlvbiBnZXRMZWZ0bW9zdCggc3RhcnQgKSB7XFxuXFxuXFx0XFx0dmFyIHAgPSBzdGFydCwgbGVmdG1vc3QgPSBzdGFydDtcXG5cXG5cXHRcXHRkbyB7XFxuXFxuXFx0XFx0XFx0aWYgKCBwLnggPCBsZWZ0bW9zdC54ICkgbGVmdG1vc3QgPSBwO1xcblxcdFxcdFxcdHAgPSBwLm5leHQ7XFxuXFxuXFx0XFx0fSB3aGlsZSAoIHAgIT09IHN0YXJ0ICk7XFxuXFxuXFx0XFx0cmV0dXJuIGxlZnRtb3N0O1xcblxcblxcdH1cXG5cXG5cXHQvLyBjaGVjayBpZiBhIHBvaW50IGxpZXMgd2l0aGluIGEgY29udmV4IHRyaWFuZ2xlXFxuXFxuXFx0ZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlKCBheCwgYXksIGJ4LCBieSwgY3gsIGN5LCBweCwgcHkgKSB7XFxuXFxuXFx0XFx0cmV0dXJuICggY3ggLSBweCApICogKCBheSAtIHB5ICkgLSAoIGF4IC0gcHggKSAqICggY3kgLSBweSApID49IDAgJiZcXG5cXHRcXHQgKCBheCAtIHB4ICkgKiAoIGJ5IC0gcHkgKSAtICggYnggLSBweCApICogKCBheSAtIHB5ICkgPj0gMCAmJlxcblxcdFxcdCAoIGJ4IC0gcHggKSAqICggY3kgLSBweSApIC0gKCBjeCAtIHB4ICkgKiAoIGJ5IC0gcHkgKSA+PSAwO1xcblxcblxcdH1cXG5cXG5cXHQvLyBjaGVjayBpZiBhIGRpYWdvbmFsIGJldHdlZW4gdHdvIHBvbHlnb24gbm9kZXMgaXMgdmFsaWQgKGxpZXMgaW4gcG9seWdvbiBpbnRlcmlvcilcXG5cXG5cXHRmdW5jdGlvbiBpc1ZhbGlkRGlhZ29uYWwoIGEsIGIgKSB7XFxuXFxuXFx0XFx0cmV0dXJuIGEubmV4dC5pICE9PSBiLmkgJiYgYS5wcmV2LmkgIT09IGIuaSAmJiAhIGludGVyc2VjdHNQb2x5Z29uKCBhLCBiICkgJiZcXG5cXHRcXHRcXHRsb2NhbGx5SW5zaWRlKCBhLCBiICkgJiYgbG9jYWxseUluc2lkZSggYiwgYSApICYmIG1pZGRsZUluc2lkZSggYSwgYiApO1xcblxcblxcdH1cXG5cXG5cXHQvLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXFxuXFxuXFx0ZnVuY3Rpb24gYXJlYSggcCwgcSwgciApIHtcXG5cXG5cXHRcXHRyZXR1cm4gKCBxLnkgLSBwLnkgKSAqICggci54IC0gcS54ICkgLSAoIHEueCAtIHAueCApICogKCByLnkgLSBxLnkgKTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gY2hlY2sgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWxcXG5cXG5cXHRmdW5jdGlvbiBlcXVhbHMoIHAxLCBwMiApIHtcXG5cXG5cXHRcXHRyZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xcblxcblxcdH1cXG5cXG5cXHQvLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XFxuXFxuXFx0ZnVuY3Rpb24gaW50ZXJzZWN0cyggcDEsIHExLCBwMiwgcTIgKSB7XFxuXFxuXFx0XFx0aWYgKCAoIGVxdWFscyggcDEsIHExICkgJiYgZXF1YWxzKCBwMiwgcTIgKSApIHx8XFxuXFx0XFx0XFx0XFx0KCBlcXVhbHMoIHAxLCBxMiApICYmIGVxdWFscyggcDIsIHExICkgKSApIHJldHVybiB0cnVlO1xcblxcblxcdFxcdHJldHVybiBhcmVhKCBwMSwgcTEsIHAyICkgPiAwICE9PSBhcmVhKCBwMSwgcTEsIHEyICkgPiAwICYmXFxuXFx0XFx0XFx0XFx0XFx0IGFyZWEoIHAyLCBxMiwgcDEgKSA+IDAgIT09IGFyZWEoIHAyLCBxMiwgcTEgKSA+IDA7XFxuXFxuXFx0fVxcblxcblxcdC8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpbnRlcnNlY3RzIGFueSBwb2x5Z29uIHNlZ21lbnRzXFxuXFxuXFx0ZnVuY3Rpb24gaW50ZXJzZWN0c1BvbHlnb24oIGEsIGIgKSB7XFxuXFxuXFx0XFx0dmFyIHAgPSBhO1xcblxcblxcdFxcdGRvIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGludGVyc2VjdHMoIHAsIHAubmV4dCwgYSwgYiApICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRwID0gcC5uZXh0O1xcblxcblxcdFxcdH0gd2hpbGUgKCBwICE9PSBhICk7XFxuXFxuXFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcblxcdH1cXG5cXG5cXHQvLyBjaGVjayBpZiBhIHBvbHlnb24gZGlhZ29uYWwgaXMgbG9jYWxseSBpbnNpZGUgdGhlIHBvbHlnb25cXG5cXG5cXHRmdW5jdGlvbiBsb2NhbGx5SW5zaWRlKCBhLCBiICkge1xcblxcblxcdFxcdHJldHVybiBhcmVhKCBhLnByZXYsIGEsIGEubmV4dCApIDwgMCA/XFxuXFx0XFx0XFx0YXJlYSggYSwgYiwgYS5uZXh0ICkgPj0gMCAmJiBhcmVhKCBhLCBhLnByZXYsIGIgKSA+PSAwIDpcXG5cXHRcXHRcXHRhcmVhKCBhLCBiLCBhLnByZXYgKSA8IDAgfHwgYXJlYSggYSwgYS5uZXh0LCBiICkgPCAwO1xcblxcblxcdH1cXG5cXG5cXHQvLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cXG5cXG5cXHRmdW5jdGlvbiBtaWRkbGVJbnNpZGUoIGEsIGIgKSB7XFxuXFxuXFx0XFx0dmFyIHAgPSBhLFxcblxcdFxcdFxcdGluc2lkZSA9IGZhbHNlLFxcblxcdFxcdFxcdHB4ID0gKCBhLnggKyBiLnggKSAvIDIsXFxuXFx0XFx0XFx0cHkgPSAoIGEueSArIGIueSApIC8gMjtcXG5cXG5cXHRcXHRkbyB7XFxuXFxuXFx0XFx0XFx0aWYgKCAoICggcC55ID4gcHkgKSAhPT0gKCBwLm5leHQueSA+IHB5ICkgKSAmJiBwLm5leHQueSAhPT0gcC55ICYmXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KCBweCA8ICggcC5uZXh0LnggLSBwLnggKSAqICggcHkgLSBwLnkgKSAvICggcC5uZXh0LnkgLSBwLnkgKSArIHAueCApICkge1xcblxcblxcdFxcdFxcdFxcdGluc2lkZSA9ICEgaW5zaWRlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRwID0gcC5uZXh0O1xcblxcblxcdFxcdH0gd2hpbGUgKCBwICE9PSBhICk7XFxuXFxuXFx0XFx0cmV0dXJuIGluc2lkZTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gbGluayB0d28gcG9seWdvbiB2ZXJ0aWNlcyB3aXRoIGEgYnJpZGdlOyBpZiB0aGUgdmVydGljZXMgYmVsb25nIHRvIHRoZSBzYW1lIHJpbmcsIGl0IHNwbGl0cyBwb2x5Z29uIGludG8gdHdvO1xcblxcdC8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xcblxcblxcdGZ1bmN0aW9uIHNwbGl0UG9seWdvbiggYSwgYiApIHtcXG5cXG5cXHRcXHR2YXIgYTIgPSBuZXcgTm9kZSggYS5pLCBhLngsIGEueSApLFxcblxcdFxcdFxcdGIyID0gbmV3IE5vZGUoIGIuaSwgYi54LCBiLnkgKSxcXG5cXHRcXHRcXHRhbiA9IGEubmV4dCxcXG5cXHRcXHRcXHRicCA9IGIucHJldjtcXG5cXG5cXHRcXHRhLm5leHQgPSBiO1xcblxcdFxcdGIucHJldiA9IGE7XFxuXFxuXFx0XFx0YTIubmV4dCA9IGFuO1xcblxcdFxcdGFuLnByZXYgPSBhMjtcXG5cXG5cXHRcXHRiMi5uZXh0ID0gYTI7XFxuXFx0XFx0YTIucHJldiA9IGIyO1xcblxcblxcdFxcdGJwLm5leHQgPSBiMjtcXG5cXHRcXHRiMi5wcmV2ID0gYnA7XFxuXFxuXFx0XFx0cmV0dXJuIGIyO1xcblxcblxcdH1cXG5cXG5cXHQvLyBjcmVhdGUgYSBub2RlIGFuZCBvcHRpb25hbGx5IGxpbmsgaXQgd2l0aCBwcmV2aW91cyBvbmUgKGluIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0KVxcblxcblxcdGZ1bmN0aW9uIGluc2VydE5vZGUoIGksIHgsIHksIGxhc3QgKSB7XFxuXFxuXFx0XFx0dmFyIHAgPSBuZXcgTm9kZSggaSwgeCwgeSApO1xcblxcblxcdFxcdGlmICggISBsYXN0ICkge1xcblxcblxcdFxcdFxcdHAucHJldiA9IHA7XFxuXFx0XFx0XFx0cC5uZXh0ID0gcDtcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdHAubmV4dCA9IGxhc3QubmV4dDtcXG5cXHRcXHRcXHRwLnByZXYgPSBsYXN0O1xcblxcdFxcdFxcdGxhc3QubmV4dC5wcmV2ID0gcDtcXG5cXHRcXHRcXHRsYXN0Lm5leHQgPSBwO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gcDtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gcmVtb3ZlTm9kZSggcCApIHtcXG5cXG5cXHRcXHRwLm5leHQucHJldiA9IHAucHJldjtcXG5cXHRcXHRwLnByZXYubmV4dCA9IHAubmV4dDtcXG5cXG5cXHRcXHRpZiAoIHAucHJldlogKSBwLnByZXZaLm5leHRaID0gcC5uZXh0WjtcXG5cXHRcXHRpZiAoIHAubmV4dFogKSBwLm5leHRaLnByZXZaID0gcC5wcmV2WjtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gTm9kZSggaSwgeCwgeSApIHtcXG5cXG5cXHRcXHQvLyB2ZXJ0aWNlIGluZGV4IGluIGNvb3JkaW5hdGVzIGFycmF5XFxuXFx0XFx0dGhpcy5pID0gaTtcXG5cXG5cXHRcXHQvLyB2ZXJ0ZXggY29vcmRpbmF0ZXNcXG5cXHRcXHR0aGlzLnggPSB4O1xcblxcdFxcdHRoaXMueSA9IHk7XFxuXFxuXFx0XFx0Ly8gcHJldmlvdXMgYW5kIG5leHQgdmVydGljZSBub2RlcyBpbiBhIHBvbHlnb24gcmluZ1xcblxcdFxcdHRoaXMucHJldiA9IG51bGw7XFxuXFx0XFx0dGhpcy5uZXh0ID0gbnVsbDtcXG5cXG5cXHRcXHQvLyB6LW9yZGVyIGN1cnZlIHZhbHVlXFxuXFx0XFx0dGhpcy56ID0gbnVsbDtcXG5cXG5cXHRcXHQvLyBwcmV2aW91cyBhbmQgbmV4dCBub2RlcyBpbiB6LW9yZGVyXFxuXFx0XFx0dGhpcy5wcmV2WiA9IG51bGw7XFxuXFx0XFx0dGhpcy5uZXh0WiA9IG51bGw7XFxuXFxuXFx0XFx0Ly8gaW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhIHN0ZWluZXIgcG9pbnRcXG5cXHRcXHR0aGlzLnN0ZWluZXIgPSBmYWxzZTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gc2lnbmVkQXJlYSggZGF0YSwgc3RhcnQsIGVuZCwgZGltICkge1xcblxcblxcdFxcdHZhciBzdW0gPSAwO1xcblxcblxcdFxcdGZvciAoIHZhciBpID0gc3RhcnQsIGogPSBlbmQgLSBkaW07IGkgPCBlbmQ7IGkgKz0gZGltICkge1xcblxcblxcdFxcdFxcdHN1bSArPSAoIGRhdGFbIGogXSAtIGRhdGFbIGkgXSApICogKCBkYXRhWyBpICsgMSBdICsgZGF0YVsgaiArIDEgXSApO1xcblxcdFxcdFxcdGogPSBpO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gc3VtO1xcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXFxuXFx0ICovXFxuXFxuXFx0dmFyIFNoYXBlVXRpbHMgPSB7XFxuXFxuXFx0XFx0Ly8gY2FsY3VsYXRlIGFyZWEgb2YgdGhlIGNvbnRvdXIgcG9seWdvblxcblxcblxcdFxcdGFyZWE6IGZ1bmN0aW9uICggY29udG91ciApIHtcXG5cXG5cXHRcXHRcXHR2YXIgbiA9IGNvbnRvdXIubGVuZ3RoO1xcblxcdFxcdFxcdHZhciBhID0gMC4wO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBwID0gbiAtIDEsIHEgPSAwOyBxIDwgbjsgcCA9IHEgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YSArPSBjb250b3VyWyBwIF0ueCAqIGNvbnRvdXJbIHEgXS55IC0gY29udG91clsgcSBdLnggKiBjb250b3VyWyBwIF0ueTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGEgKiAwLjU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpc0Nsb2NrV2lzZTogZnVuY3Rpb24gKCBwdHMgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIFNoYXBlVXRpbHMuYXJlYSggcHRzICkgPCAwO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dHJpYW5ndWxhdGVTaGFwZTogZnVuY3Rpb24gKCBjb250b3VyLCBob2xlcyApIHtcXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiByZW1vdmVEdXBFbmRQdHMoIHBvaW50cyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbCA9IHBvaW50cy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBsID4gMiAmJiBwb2ludHNbIGwgLSAxIF0uZXF1YWxzKCBwb2ludHNbIDAgXSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHBvaW50cy5wb3AoKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGFkZENvbnRvdXIoIHZlcnRpY2VzLCBjb250b3VyICkge1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGNvbnRvdXIubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIGNvbnRvdXJbIGkgXS54ICk7XFxuXFx0XFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggY29udG91clsgaSBdLnkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdOyAvLyBmbGF0IGFycmF5IG9mIHZlcnRpY2VzIGxpa2UgWyB4MCx5MCwgeDEseTEsIHgyLHkyLCAuLi4gXVxcblxcdFxcdFxcdHZhciBob2xlSW5kaWNlcyA9IFtdOyAvLyBhcnJheSBvZiBob2xlIGluZGljZXNcXG5cXHRcXHRcXHR2YXIgZmFjZXMgPSBbXTsgLy8gZmluYWwgYXJyYXkgb2YgdmVydGV4IGluZGljZXMgbGlrZSBbIFsgYSxiLGQgXSwgWyBiLGMsZCBdIF1cXG5cXG5cXHRcXHRcXHRyZW1vdmVEdXBFbmRQdHMoIGNvbnRvdXIgKTtcXG5cXHRcXHRcXHRhZGRDb250b3VyKCB2ZXJ0aWNlcywgY29udG91ciApO1xcblxcblxcdFxcdFxcdC8vXFxuXFxuXFx0XFx0XFx0dmFyIGhvbGVJbmRleCA9IGNvbnRvdXIubGVuZ3RoO1xcblxcdFxcdFxcdGhvbGVzLmZvckVhY2goIHJlbW92ZUR1cEVuZFB0cyApO1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgaG9sZXMubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGhvbGVJbmRpY2VzLnB1c2goIGhvbGVJbmRleCApO1xcblxcdFxcdFxcdFxcdGhvbGVJbmRleCArPSBob2xlc1sgaSBdLmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRhZGRDb250b3VyKCB2ZXJ0aWNlcywgaG9sZXNbIGkgXSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdHZhciB0cmlhbmdsZXMgPSBFYXJjdXQudHJpYW5ndWxhdGUoIHZlcnRpY2VzLCBob2xlSW5kaWNlcyApO1xcblxcblxcdFxcdFxcdC8vXFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSArPSAzICkge1xcblxcblxcdFxcdFxcdFxcdGZhY2VzLnB1c2goIHRyaWFuZ2xlcy5zbGljZSggaSwgaSArIDMgKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZmFjZXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xcblxcdCAqXFxuXFx0ICogQ3JlYXRlcyBleHRydWRlZCBnZW9tZXRyeSBmcm9tIGEgcGF0aCBzaGFwZS5cXG5cXHQgKlxcblxcdCAqIHBhcmFtZXRlcnMgPSB7XFxuXFx0ICpcXG5cXHQgKiAgY3VydmVTZWdtZW50czogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgb24gdGhlIGN1cnZlc1xcblxcdCAqICBzdGVwczogPGludD4sIC8vIG51bWJlciBvZiBwb2ludHMgZm9yIHotc2lkZSBleHRydXNpb25zIC8gdXNlZCBmb3Igc3ViZGl2aWRpbmcgc2VnbWVudHMgb2YgZXh0cnVkZSBzcGxpbmUgdG9vXFxuXFx0ICogIGFtb3VudDogPGludD4sIC8vIERlcHRoIHRvIGV4dHJ1ZGUgdGhlIHNoYXBlXFxuXFx0ICpcXG5cXHQgKiAgYmV2ZWxFbmFibGVkOiA8Ym9vbD4sIC8vIHR1cm4gb24gYmV2ZWxcXG5cXHQgKiAgYmV2ZWxUaGlja25lc3M6IDxmbG9hdD4sIC8vIGhvdyBkZWVwIGludG8gdGhlIG9yaWdpbmFsIHNoYXBlIGJldmVsIGdvZXNcXG5cXHQgKiAgYmV2ZWxTaXplOiA8ZmxvYXQ+LCAvLyBob3cgZmFyIGZyb20gc2hhcGUgb3V0bGluZSBpcyBiZXZlbFxcblxcdCAqICBiZXZlbFNlZ21lbnRzOiA8aW50PiwgLy8gbnVtYmVyIG9mIGJldmVsIGxheWVyc1xcblxcdCAqXFxuXFx0ICogIGV4dHJ1ZGVQYXRoOiA8VEhSRUUuQ3VydmU+IC8vIGN1cnZlIHRvIGV4dHJ1ZGUgc2hhcGUgYWxvbmdcXG5cXHQgKiAgZnJhbWVzOiA8T2JqZWN0PiAvLyBjb250YWluaW5nIGFycmF5cyBvZiB0YW5nZW50cywgbm9ybWFscywgYmlub3JtYWxzXFxuXFx0ICpcXG5cXHQgKiAgVVZHZW5lcmF0b3I6IDxPYmplY3Q+IC8vIG9iamVjdCB0aGF0IHByb3ZpZGVzIFVWIGdlbmVyYXRvciBmdW5jdGlvbnNcXG5cXHQgKlxcblxcdCAqIH1cXG5cXHQgKi9cXG5cXG5cXHQvLyBFeHRydWRlR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBFeHRydWRlR2VvbWV0cnkoIHNoYXBlcywgb3B0aW9ucyApIHtcXG5cXG5cXHRcXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0V4dHJ1ZGVHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHNoYXBlczogc2hhcGVzLFxcblxcdFxcdFxcdG9wdGlvbnM6IG9wdGlvbnNcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgRXh0cnVkZUJ1ZmZlckdlb21ldHJ5KCBzaGFwZXMsIG9wdGlvbnMgKSApO1xcblxcdFxcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xcblxcblxcdH1cXG5cXG5cXHRFeHRydWRlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0RXh0cnVkZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV4dHJ1ZGVHZW9tZXRyeTtcXG5cXG5cXHQvLyBFeHRydWRlQnVmZmVyR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBFeHRydWRlQnVmZmVyR2VvbWV0cnkoIHNoYXBlcywgb3B0aW9ucyApIHtcXG5cXG5cXHRcXHRpZiAoIHR5cGVvZiAoIHNoYXBlcyApID09PSBcXFwidW5kZWZpbmVkXFxcIiApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnRXh0cnVkZUJ1ZmZlckdlb21ldHJ5JztcXG5cXG5cXHRcXHRzaGFwZXMgPSBBcnJheS5pc0FycmF5KCBzaGFwZXMgKSA/IHNoYXBlcyA6IFsgc2hhcGVzIF07XFxuXFxuXFx0XFx0dGhpcy5hZGRTaGFwZUxpc3QoIHNoYXBlcywgb3B0aW9ucyApO1xcblxcblxcdFxcdHRoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcXG5cXG5cXHRcXHQvLyBjYW4ndCByZWFsbHkgdXNlIGF1dG9tYXRpYyB2ZXJ0ZXggbm9ybWFsc1xcblxcdFxcdC8vIGFzIHRoZW4gZnJvbnQgYW5kIGJhY2sgc2lkZXMgZ2V0IHNtb290aGVkIHRvb1xcblxcdFxcdC8vIHNob3VsZCBkbyBzZXBhcmF0ZSBzbW9vdGhpbmcganVzdCBmb3Igc2lkZXNcXG5cXG5cXHRcXHQvL3RoaXMuY29tcHV0ZVZlcnRleE5vcm1hbHMoKTtcXG5cXG5cXHRcXHQvL2NvbnNvbGUubG9nKCBcXFwidG9va1xcXCIsICggRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSApICk7XFxuXFxuXFx0fVxcblxcblxcdEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRFeHRydWRlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRXh0cnVkZUJ1ZmZlckdlb21ldHJ5O1xcblxcblxcdEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuZ2V0QXJyYXlzID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdHZhciBwb3NpdGlvbkF0dHJpYnV0ZSA9IHRoaXMuZ2V0QXR0cmlidXRlKCBcXFwicG9zaXRpb25cXFwiICk7XFxuXFx0XFx0dmFyIHZlcnRpY2VzQXJyYXkgPSBwb3NpdGlvbkF0dHJpYnV0ZSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBwb3NpdGlvbkF0dHJpYnV0ZS5hcnJheSApIDogW107XFxuXFxuXFx0XFx0dmFyIHV2QXR0cmlidXRlID0gdGhpcy5nZXRBdHRyaWJ1dGUoIFxcXCJ1dlxcXCIgKTtcXG5cXHRcXHR2YXIgdXZBcnJheSA9IHV2QXR0cmlidXRlID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIHV2QXR0cmlidXRlLmFycmF5ICkgOiBbXTtcXG5cXG5cXHRcXHR2YXIgSW5kZXhBdHRyaWJ1dGUgPSB0aGlzLmluZGV4O1xcblxcdFxcdHZhciBpbmRpY2VzQXJyYXkgPSBJbmRleEF0dHJpYnV0ZSA/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKCBJbmRleEF0dHJpYnV0ZS5hcnJheSApIDogW107XFxuXFxuXFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRwb3NpdGlvbjogdmVydGljZXNBcnJheSxcXG5cXHRcXHRcXHR1djogdXZBcnJheSxcXG5cXHRcXHRcXHRpbmRleDogaW5kaWNlc0FycmF5XFxuXFx0XFx0fTtcXG5cXG5cXHR9O1xcblxcblxcdEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGVMaXN0ID0gZnVuY3Rpb24gKCBzaGFwZXMsIG9wdGlvbnMgKSB7XFxuXFxuXFx0XFx0dmFyIHNsID0gc2hhcGVzLmxlbmd0aDtcXG5cXHRcXHRvcHRpb25zLmFycmF5cyA9IHRoaXMuZ2V0QXJyYXlzKCk7XFxuXFxuXFx0XFx0Zm9yICggdmFyIHMgPSAwOyBzIDwgc2w7IHMgKysgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHNoYXBlID0gc2hhcGVzWyBzIF07XFxuXFx0XFx0XFx0dGhpcy5hZGRTaGFwZSggc2hhcGUsIG9wdGlvbnMgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5zZXRJbmRleCggb3B0aW9ucy5hcnJheXMuaW5kZXggKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG9wdGlvbnMuYXJyYXlzLnBvc2l0aW9uLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG9wdGlvbnMuYXJyYXlzLnV2LCAyICkgKTtcXG5cXG5cXHR9O1xcblxcblxcdEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoIHNoYXBlLCBvcHRpb25zICkge1xcblxcblxcdFxcdHZhciBhcnJheXMgPSBvcHRpb25zLmFycmF5cyA/IG9wdGlvbnMuYXJyYXlzIDogdGhpcy5nZXRBcnJheXMoKTtcXG5cXHRcXHR2YXIgdmVydGljZXNBcnJheSA9IGFycmF5cy5wb3NpdGlvbjtcXG5cXHRcXHR2YXIgaW5kaWNlc0FycmF5ID0gYXJyYXlzLmluZGV4O1xcblxcdFxcdHZhciB1dkFycmF5ID0gYXJyYXlzLnV2O1xcblxcblxcdFxcdHZhciBwbGFjZWhvbGRlciA9IFtdO1xcblxcblxcblxcdFxcdHZhciBhbW91bnQgPSBvcHRpb25zLmFtb3VudCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5hbW91bnQgOiAxMDA7XFxuXFxuXFx0XFx0dmFyIGJldmVsVGhpY2tuZXNzID0gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbFRoaWNrbmVzcyA6IDY7IC8vIDEwXFxuXFx0XFx0dmFyIGJldmVsU2l6ZSA9IG9wdGlvbnMuYmV2ZWxTaXplICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2l6ZSA6IGJldmVsVGhpY2tuZXNzIC0gMjsgLy8gOFxcblxcdFxcdHZhciBiZXZlbFNlZ21lbnRzID0gb3B0aW9ucy5iZXZlbFNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmJldmVsU2VnbWVudHMgOiAzO1xcblxcblxcdFxcdHZhciBiZXZlbEVuYWJsZWQgPSBvcHRpb25zLmJldmVsRW5hYmxlZCAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5iZXZlbEVuYWJsZWQgOiB0cnVlOyAvLyBmYWxzZVxcblxcblxcdFxcdHZhciBjdXJ2ZVNlZ21lbnRzID0gb3B0aW9ucy5jdXJ2ZVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmN1cnZlU2VnbWVudHMgOiAxMjtcXG5cXG5cXHRcXHR2YXIgc3RlcHMgPSBvcHRpb25zLnN0ZXBzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLnN0ZXBzIDogMTtcXG5cXG5cXHRcXHR2YXIgZXh0cnVkZVBhdGggPSBvcHRpb25zLmV4dHJ1ZGVQYXRoO1xcblxcdFxcdHZhciBleHRydWRlUHRzLCBleHRydWRlQnlQYXRoID0gZmFsc2U7XFxuXFxuXFx0XFx0Ly8gVXNlIGRlZmF1bHQgV29ybGRVVkdlbmVyYXRvciBpZiBubyBVViBnZW5lcmF0b3JzIGFyZSBzcGVjaWZpZWQuXFxuXFx0XFx0dmFyIHV2Z2VuID0gb3B0aW9ucy5VVkdlbmVyYXRvciAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5VVkdlbmVyYXRvciA6IEV4dHJ1ZGVHZW9tZXRyeS5Xb3JsZFVWR2VuZXJhdG9yO1xcblxcblxcdFxcdHZhciBzcGxpbmVUdWJlLCBiaW5vcm1hbCwgbm9ybWFsLCBwb3NpdGlvbjI7XFxuXFx0XFx0aWYgKCBleHRydWRlUGF0aCApIHtcXG5cXG5cXHRcXHRcXHRleHRydWRlUHRzID0gZXh0cnVkZVBhdGguZ2V0U3BhY2VkUG9pbnRzKCBzdGVwcyApO1xcblxcblxcdFxcdFxcdGV4dHJ1ZGVCeVBhdGggPSB0cnVlO1xcblxcdFxcdFxcdGJldmVsRW5hYmxlZCA9IGZhbHNlOyAvLyBiZXZlbHMgbm90IHN1cHBvcnRlZCBmb3IgcGF0aCBleHRydXNpb25cXG5cXG5cXHRcXHRcXHQvLyBTRVRVUCBUTkIgdmFyaWFibGVzXFxuXFxuXFx0XFx0XFx0Ly8gVE9ETzEgLSBoYXZlIGEgLmlzQ2xvc2VkIGluIHNwbGluZT9cXG5cXG5cXHRcXHRcXHRzcGxpbmVUdWJlID0gb3B0aW9ucy5mcmFtZXMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZnJhbWVzIDogZXh0cnVkZVBhdGguY29tcHV0ZUZyZW5ldEZyYW1lcyggc3RlcHMsIGZhbHNlICk7XFxuXFxuXFx0XFx0XFx0Ly8gY29uc29sZS5sb2coc3BsaW5lVHViZSwgJ3NwbGluZVR1YmUnLCBzcGxpbmVUdWJlLm5vcm1hbHMubGVuZ3RoLCAnc3RlcHMnLCBzdGVwcywgJ2V4dHJ1ZGVQdHMnLCBleHRydWRlUHRzLmxlbmd0aCk7XFxuXFxuXFx0XFx0XFx0Ymlub3JtYWwgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0cG9zaXRpb24yID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gU2FmZWd1YXJkcyBpZiBiZXZlbHMgYXJlIG5vdCBlbmFibGVkXFxuXFxuXFx0XFx0aWYgKCAhIGJldmVsRW5hYmxlZCApIHtcXG5cXG5cXHRcXHRcXHRiZXZlbFNlZ21lbnRzID0gMDtcXG5cXHRcXHRcXHRiZXZlbFRoaWNrbmVzcyA9IDA7XFxuXFx0XFx0XFx0YmV2ZWxTaXplID0gMDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gVmFyaWFibGVzIGluaXRpYWxpemF0aW9uXFxuXFxuXFx0XFx0dmFyIGFob2xlLCBoLCBobDsgLy8gbG9vcGluZyBvZiBob2xlc1xcblxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxuXFxuXFx0XFx0dmFyIHNoYXBlUG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyggY3VydmVTZWdtZW50cyApO1xcblxcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IHNoYXBlUG9pbnRzLnNoYXBlO1xcblxcdFxcdHZhciBob2xlcyA9IHNoYXBlUG9pbnRzLmhvbGVzO1xcblxcblxcdFxcdHZhciByZXZlcnNlID0gISBTaGFwZVV0aWxzLmlzQ2xvY2tXaXNlKCB2ZXJ0aWNlcyApO1xcblxcblxcdFxcdGlmICggcmV2ZXJzZSApIHtcXG5cXG5cXHRcXHRcXHR2ZXJ0aWNlcyA9IHZlcnRpY2VzLnJldmVyc2UoKTtcXG5cXG5cXHRcXHRcXHQvLyBNYXliZSB3ZSBzaG91bGQgYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvbiwganVzdCB0byBiZSBzYWZlIC4uLlxcblxcblxcdFxcdFxcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xcblxcblxcdFxcdFxcdFxcdGFob2xlID0gaG9sZXNbIGggXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIGFob2xlICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aG9sZXNbIGggXSA9IGFob2xlLnJldmVyc2UoKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXG5cXHRcXHR2YXIgZmFjZXMgPSBTaGFwZVV0aWxzLnRyaWFuZ3VsYXRlU2hhcGUoIHZlcnRpY2VzLCBob2xlcyApO1xcblxcblxcdFxcdC8qIFZlcnRpY2VzICovXFxuXFxuXFx0XFx0dmFyIGNvbnRvdXIgPSB2ZXJ0aWNlczsgLy8gdmVydGljZXMgaGFzIGFsbCBwb2ludHMgYnV0IGNvbnRvdXIgaGFzIG9ubHkgcG9pbnRzIG9mIGNpcmN1bWZlcmVuY2VcXG5cXG5cXHRcXHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcXG5cXG5cXHRcXHRcXHRhaG9sZSA9IGhvbGVzWyBoIF07XFxuXFxuXFx0XFx0XFx0dmVydGljZXMgPSB2ZXJ0aWNlcy5jb25jYXQoIGFob2xlICk7XFxuXFxuXFx0XFx0fVxcblxcblxcblxcdFxcdGZ1bmN0aW9uIHNjYWxlUHQyKCBwdCwgdmVjLCBzaXplICkge1xcblxcblxcdFxcdFxcdGlmICggISB2ZWMgKSBjb25zb2xlLmVycm9yKCBcXFwiVEhSRUUuRXh0cnVkZUdlb21ldHJ5OiB2ZWMgZG9lcyBub3QgZXhpc3RcXFwiICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHZlYy5jbG9uZSgpLm11bHRpcGx5U2NhbGFyKCBzaXplICkuYWRkKCBwdCApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgYiwgYnMsIHQsIHosXFxuXFx0XFx0XFx0dmVydCwgdmxlbiA9IHZlcnRpY2VzLmxlbmd0aCxcXG5cXHRcXHRcXHRmYWNlLCBmbGVuID0gZmFjZXMubGVuZ3RoO1xcblxcblxcblxcdFxcdC8vIEZpbmQgZGlyZWN0aW9ucyBmb3IgcG9pbnQgbW92ZW1lbnRcXG5cXG5cXG5cXHRcXHRmdW5jdGlvbiBnZXRCZXZlbFZlYyggaW5QdCwgaW5QcmV2LCBpbk5leHQgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gY29tcHV0ZXMgZm9yIGluUHQgdGhlIGNvcnJlc3BvbmRpbmcgcG9pbnQgaW5QdCcgb24gYSBuZXcgY29udG91clxcblxcdFxcdFxcdC8vICAgc2hpZnRlZCBieSAxIHVuaXQgKGxlbmd0aCBvZiBub3JtYWxpemVkIHZlY3RvcikgdG8gdGhlIGxlZnRcXG5cXHRcXHRcXHQvLyBpZiB3ZSB3YWxrIGFsb25nIGNvbnRvdXIgY2xvY2t3aXNlLCB0aGlzIG5ldyBjb250b3VyIGlzIG91dHNpZGUgdGhlIG9sZCBvbmVcXG5cXHRcXHRcXHQvL1xcblxcdFxcdFxcdC8vIGluUHQnIGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byBsaW5lcyBwYXJhbGxlbCB0byB0aGUgdHdvXFxuXFx0XFx0XFx0Ly8gIGFkamFjZW50IGVkZ2VzIG9mIGluUHQgYXQgYSBkaXN0YW5jZSBvZiAxIHVuaXQgb24gdGhlIGxlZnQgc2lkZS5cXG5cXG5cXHRcXHRcXHR2YXIgdl90cmFuc194LCB2X3RyYW5zX3ksIHNocmlua19ieTsgLy8gcmVzdWx0aW5nIHRyYW5zbGF0aW9uIHZlY3RvciBmb3IgaW5QdFxcblxcblxcdFxcdFxcdC8vIGdvb2QgcmVhZGluZyBmb3IgZ2VvbWV0cnkgYWxnb3JpdGhtcyAoaGVyZTogbGluZS1saW5lIGludGVyc2VjdGlvbilcXG5cXHRcXHRcXHQvLyBodHRwOi8vZ2VvbWFsZ29yaXRobXMuY29tL2EwNS1faW50ZXJzZWN0LTEuaHRtbFxcblxcblxcdFxcdFxcdHZhciB2X3ByZXZfeCA9IGluUHQueCAtIGluUHJldi54LFxcblxcdFxcdFxcdFxcdHZfcHJldl95ID0gaW5QdC55IC0gaW5QcmV2Lnk7XFxuXFx0XFx0XFx0dmFyIHZfbmV4dF94ID0gaW5OZXh0LnggLSBpblB0LngsXFxuXFx0XFx0XFx0XFx0dl9uZXh0X3kgPSBpbk5leHQueSAtIGluUHQueTtcXG5cXG5cXHRcXHRcXHR2YXIgdl9wcmV2X2xlbnNxID0gKCB2X3ByZXZfeCAqIHZfcHJldl94ICsgdl9wcmV2X3kgKiB2X3ByZXZfeSApO1xcblxcblxcdFxcdFxcdC8vIGNoZWNrIGZvciBjb2xsaW5lYXIgZWRnZXNcXG5cXHRcXHRcXHR2YXIgY29sbGluZWFyMCA9ICggdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3ggKTtcXG5cXG5cXHRcXHRcXHRpZiAoIE1hdGguYWJzKCBjb2xsaW5lYXIwICkgPiBOdW1iZXIuRVBTSUxPTiApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBub3QgY29sbGluZWFyXFxuXFxuXFx0XFx0XFx0XFx0Ly8gbGVuZ3RoIG9mIHZlY3RvcnMgZm9yIG5vcm1hbGl6aW5nXFxuXFxuXFx0XFx0XFx0XFx0dmFyIHZfcHJldl9sZW4gPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSApO1xcblxcdFxcdFxcdFxcdHZhciB2X25leHRfbGVuID0gTWF0aC5zcXJ0KCB2X25leHRfeCAqIHZfbmV4dF94ICsgdl9uZXh0X3kgKiB2X25leHRfeSApO1xcblxcblxcdFxcdFxcdFxcdC8vIHNoaWZ0IGFkamFjZW50IHBvaW50cyBieSB1bml0IHZlY3RvcnMgdG8gdGhlIGxlZnRcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcHRQcmV2U2hpZnRfeCA9ICggaW5QcmV2LnggLSB2X3ByZXZfeSAvIHZfcHJldl9sZW4gKTtcXG5cXHRcXHRcXHRcXHR2YXIgcHRQcmV2U2hpZnRfeSA9ICggaW5QcmV2LnkgKyB2X3ByZXZfeCAvIHZfcHJldl9sZW4gKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcHROZXh0U2hpZnRfeCA9ICggaW5OZXh0LnggLSB2X25leHRfeSAvIHZfbmV4dF9sZW4gKTtcXG5cXHRcXHRcXHRcXHR2YXIgcHROZXh0U2hpZnRfeSA9ICggaW5OZXh0LnkgKyB2X25leHRfeCAvIHZfbmV4dF9sZW4gKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBzY2FsaW5nIGZhY3RvciBmb3Igdl9wcmV2IHRvIGludGVyc2VjdGlvbiBwb2ludFxcblxcblxcdFxcdFxcdFxcdHZhciBzZiA9ICggKCBwdE5leHRTaGlmdF94IC0gcHRQcmV2U2hpZnRfeCApICogdl9uZXh0X3kgLVxcblxcdFxcdFxcdFxcdFxcdFxcdCggcHROZXh0U2hpZnRfeSAtIHB0UHJldlNoaWZ0X3kgKSAqIHZfbmV4dF94ICkgL1xcblxcdFxcdFxcdFxcdFxcdCggdl9wcmV2X3ggKiB2X25leHRfeSAtIHZfcHJldl95ICogdl9uZXh0X3ggKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyB2ZWN0b3IgZnJvbSBpblB0IHRvIGludGVyc2VjdGlvbiBwb2ludFxcblxcblxcdFxcdFxcdFxcdHZfdHJhbnNfeCA9ICggcHRQcmV2U2hpZnRfeCArIHZfcHJldl94ICogc2YgLSBpblB0LnggKTtcXG5cXHRcXHRcXHRcXHR2X3RyYW5zX3kgPSAoIHB0UHJldlNoaWZ0X3kgKyB2X3ByZXZfeSAqIHNmIC0gaW5QdC55ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gRG9uJ3Qgbm9ybWFsaXplISwgb3RoZXJ3aXNlIHNoYXJwIGNvcm5lcnMgYmVjb21lIHVnbHlcXG5cXHRcXHRcXHRcXHQvLyAgYnV0IHByZXZlbnQgY3Jhenkgc3Bpa2VzXFxuXFx0XFx0XFx0XFx0dmFyIHZfdHJhbnNfbGVuc3EgPSAoIHZfdHJhbnNfeCAqIHZfdHJhbnNfeCArIHZfdHJhbnNfeSAqIHZfdHJhbnNfeSApO1xcblxcdFxcdFxcdFxcdGlmICggdl90cmFuc19sZW5zcSA8PSAyICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBuZXcgVmVjdG9yMiggdl90cmFuc194LCB2X3RyYW5zX3kgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHNocmlua19ieSA9IE1hdGguc3FydCggdl90cmFuc19sZW5zcSAvIDIgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBoYW5kbGUgc3BlY2lhbCBjYXNlIG9mIGNvbGxpbmVhciBlZGdlc1xcblxcblxcdFxcdFxcdFxcdHZhciBkaXJlY3Rpb25fZXEgPSBmYWxzZTsgLy8gYXNzdW1lczogb3Bwb3NpdGVcXG5cXHRcXHRcXHRcXHRpZiAoIHZfcHJldl94ID4gTnVtYmVyLkVQU0lMT04gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB2X25leHRfeCA+IE51bWJlci5FUFNJTE9OICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGRpcmVjdGlvbl9lcSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB2X3ByZXZfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB2X25leHRfeCA8IC0gTnVtYmVyLkVQU0lMT04gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGlyZWN0aW9uX2VxID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIE1hdGguc2lnbiggdl9wcmV2X3kgKSA9PT0gTWF0aC5zaWduKCB2X25leHRfeSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRpcmVjdGlvbl9lcSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBkaXJlY3Rpb25fZXEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gY29uc29sZS5sb2coXFxcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNlcXVlbmNlXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0dl90cmFuc194ID0gLSB2X3ByZXZfeTtcXG5cXHRcXHRcXHRcXHRcXHR2X3RyYW5zX3kgPSB2X3ByZXZfeDtcXG5cXHRcXHRcXHRcXHRcXHRzaHJpbmtfYnkgPSBNYXRoLnNxcnQoIHZfcHJldl9sZW5zcSApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gY29uc29sZS5sb2coXFxcIldhcm5pbmc6IGxpbmVzIGFyZSBhIHN0cmFpZ2h0IHNwaWtlXFxcIik7XFxuXFx0XFx0XFx0XFx0XFx0dl90cmFuc194ID0gdl9wcmV2X3g7XFxuXFx0XFx0XFx0XFx0XFx0dl90cmFuc195ID0gdl9wcmV2X3k7XFxuXFx0XFx0XFx0XFx0XFx0c2hyaW5rX2J5ID0gTWF0aC5zcXJ0KCB2X3ByZXZfbGVuc3EgLyAyICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IFZlY3RvcjIoIHZfdHJhbnNfeCAvIHNocmlua19ieSwgdl90cmFuc195IC8gc2hyaW5rX2J5ICk7XFxuXFxuXFx0XFx0fVxcblxcblxcblxcdFxcdHZhciBjb250b3VyTW92ZW1lbnRzID0gW107XFxuXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoLCBqID0gaWwgLSAxLCBrID0gaSArIDE7IGkgPCBpbDsgaSArKywgaiArKywgayArKyApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGogPT09IGlsICkgaiA9IDA7XFxuXFx0XFx0XFx0aWYgKCBrID09PSBpbCApIGsgPSAwO1xcblxcblxcdFxcdFxcdC8vICAoaiktLS0oaSktLS0oaylcXG5cXHRcXHRcXHQvLyBjb25zb2xlLmxvZygnaSxqLGsnLCBpLCBqICwgaylcXG5cXG5cXHRcXHRcXHRjb250b3VyTW92ZW1lbnRzWyBpIF0gPSBnZXRCZXZlbFZlYyggY29udG91clsgaSBdLCBjb250b3VyWyBqIF0sIGNvbnRvdXJbIGsgXSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgaG9sZXNNb3ZlbWVudHMgPSBbXSxcXG5cXHRcXHRcXHRvbmVIb2xlTW92ZW1lbnRzLCB2ZXJ0aWNlc01vdmVtZW50cyA9IGNvbnRvdXJNb3ZlbWVudHMuY29uY2F0KCk7XFxuXFxuXFx0XFx0Zm9yICggaCA9IDAsIGhsID0gaG9sZXMubGVuZ3RoOyBoIDwgaGw7IGggKysgKSB7XFxuXFxuXFx0XFx0XFx0YWhvbGUgPSBob2xlc1sgaCBdO1xcblxcblxcdFxcdFxcdG9uZUhvbGVNb3ZlbWVudHMgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGgsIGogPSBpbCAtIDEsIGsgPSBpICsgMTsgaSA8IGlsOyBpICsrLCBqICsrLCBrICsrICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggaiA9PT0gaWwgKSBqID0gMDtcXG5cXHRcXHRcXHRcXHRpZiAoIGsgPT09IGlsICkgayA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gIChqKS0tLShpKS0tLShrKVxcblxcdFxcdFxcdFxcdG9uZUhvbGVNb3ZlbWVudHNbIGkgXSA9IGdldEJldmVsVmVjKCBhaG9sZVsgaSBdLCBhaG9sZVsgaiBdLCBhaG9sZVsgayBdICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGhvbGVzTW92ZW1lbnRzLnB1c2goIG9uZUhvbGVNb3ZlbWVudHMgKTtcXG5cXHRcXHRcXHR2ZXJ0aWNlc01vdmVtZW50cyA9IHZlcnRpY2VzTW92ZW1lbnRzLmNvbmNhdCggb25lSG9sZU1vdmVtZW50cyApO1xcblxcblxcdFxcdH1cXG5cXG5cXG5cXHRcXHQvLyBMb29wIGJldmVsU2VnbWVudHMsIDEgZm9yIHRoZSBmcm9udCwgMSBmb3IgdGhlIGJhY2tcXG5cXG5cXHRcXHRmb3IgKCBiID0gMDsgYiA8IGJldmVsU2VnbWVudHM7IGIgKysgKSB7XFxuXFxuXFx0XFx0XFx0Ly9mb3IgKCBiID0gYmV2ZWxTZWdtZW50czsgYiA+IDA7IGIgLS0gKSB7XFxuXFxuXFx0XFx0XFx0dCA9IGIgLyBiZXZlbFNlZ21lbnRzO1xcblxcdFxcdFxcdHogPSBiZXZlbFRoaWNrbmVzcyAqIE1hdGguY29zKCB0ICogTWF0aC5QSSAvIDIgKTtcXG5cXHRcXHRcXHRicyA9IGJldmVsU2l6ZSAqIE1hdGguc2luKCB0ICogTWF0aC5QSSAvIDIgKTtcXG5cXG5cXHRcXHRcXHQvLyBjb250cmFjdCBzaGFwZVxcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBpbCA9IGNvbnRvdXIubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmVydCA9IHNjYWxlUHQyKCBjb250b3VyWyBpIF0sIGNvbnRvdXJNb3ZlbWVudHNbIGkgXSwgYnMgKTtcXG5cXG5cXHRcXHRcXHRcXHR2KCB2ZXJ0LngsIHZlcnQueSwgLSB6ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGV4cGFuZCBob2xlc1xcblxcblxcdFxcdFxcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xcblxcblxcdFxcdFxcdFxcdGFob2xlID0gaG9sZXNbIGggXTtcXG5cXHRcXHRcXHRcXHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2KCB2ZXJ0LngsIHZlcnQueSwgLSB6ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0YnMgPSBiZXZlbFNpemU7XFxuXFxuXFx0XFx0Ly8gQmFjayBmYWNpbmcgdmVydGljZXNcXG5cXG5cXHRcXHRmb3IgKCBpID0gMDsgaSA8IHZsZW47IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0dmVydCA9IGJldmVsRW5hYmxlZCA/IHNjYWxlUHQyKCB2ZXJ0aWNlc1sgaSBdLCB2ZXJ0aWNlc01vdmVtZW50c1sgaSBdLCBicyApIDogdmVydGljZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2KCB2ZXJ0LngsIHZlcnQueSwgMCApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyAwIF0ueSwgZXh0cnVkZVB0c1sgMCBdLnggKTtcXG5cXG5cXHRcXHRcXHRcXHRub3JtYWwuY29weSggc3BsaW5lVHViZS5ub3JtYWxzWyAwIF0gKS5tdWx0aXBseVNjYWxhciggdmVydC54ICk7XFxuXFx0XFx0XFx0XFx0Ymlub3JtYWwuY29weSggc3BsaW5lVHViZS5iaW5vcm1hbHNbIDAgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnkgKTtcXG5cXG5cXHRcXHRcXHRcXHRwb3NpdGlvbjIuY29weSggZXh0cnVkZVB0c1sgMCBdICkuYWRkKCBub3JtYWwgKS5hZGQoIGJpbm9ybWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0diggcG9zaXRpb24yLngsIHBvc2l0aW9uMi55LCBwb3NpdGlvbjIueiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gQWRkIHN0ZXBwZWQgdmVydGljZXMuLi5cXG5cXHRcXHQvLyBJbmNsdWRpbmcgZnJvbnQgZmFjaW5nIHZlcnRpY2VzXFxuXFxuXFx0XFx0dmFyIHM7XFxuXFxuXFx0XFx0Zm9yICggcyA9IDE7IHMgPD0gc3RlcHM7IHMgKysgKSB7XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCB2bGVuOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZlcnQgPSBiZXZlbEVuYWJsZWQgPyBzY2FsZVB0MiggdmVydGljZXNbIGkgXSwgdmVydGljZXNNb3ZlbWVudHNbIGkgXSwgYnMgKSA6IHZlcnRpY2VzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAhIGV4dHJ1ZGVCeVBhdGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0diggdmVydC54LCB2ZXJ0LnksIGFtb3VudCAvIHN0ZXBzICogcyApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdiggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzIC0gMSBdLnksIGV4dHJ1ZGVQdHNbIHMgLSAxIF0ueCApO1xcblxcblxcdFxcdFxcdFxcdFxcdG5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLm5vcm1hbHNbIHMgXSApLm11bHRpcGx5U2NhbGFyKCB2ZXJ0LnggKTtcXG5cXHRcXHRcXHRcXHRcXHRiaW5vcm1hbC5jb3B5KCBzcGxpbmVUdWJlLmJpbm9ybWFsc1sgcyBdICkubXVsdGlwbHlTY2FsYXIoIHZlcnQueSApO1xcblxcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uMi5jb3B5KCBleHRydWRlUHRzWyBzIF0gKS5hZGQoIG5vcm1hbCApLmFkZCggYmlub3JtYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2KCBwb3NpdGlvbjIueCwgcG9zaXRpb24yLnksIHBvc2l0aW9uMi56ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFxuXFx0XFx0Ly8gQWRkIGJldmVsIHNlZ21lbnRzIHBsYW5lc1xcblxcblxcdFxcdC8vZm9yICggYiA9IDE7IGIgPD0gYmV2ZWxTZWdtZW50czsgYiArKyApIHtcXG5cXHRcXHRmb3IgKCBiID0gYmV2ZWxTZWdtZW50cyAtIDE7IGIgPj0gMDsgYiAtLSApIHtcXG5cXG5cXHRcXHRcXHR0ID0gYiAvIGJldmVsU2VnbWVudHM7XFxuXFx0XFx0XFx0eiA9IGJldmVsVGhpY2tuZXNzICogTWF0aC5jb3MoIHQgKiBNYXRoLlBJIC8gMiApO1xcblxcdFxcdFxcdGJzID0gYmV2ZWxTaXplICogTWF0aC5zaW4oIHQgKiBNYXRoLlBJIC8gMiApO1xcblxcblxcdFxcdFxcdC8vIGNvbnRyYWN0IHNoYXBlXFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGlsID0gY29udG91ci5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0ID0gc2NhbGVQdDIoIGNvbnRvdXJbIGkgXSwgY29udG91ck1vdmVtZW50c1sgaSBdLCBicyApO1xcblxcdFxcdFxcdFxcdHYoIHZlcnQueCwgdmVydC55LCBhbW91bnQgKyB6ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGV4cGFuZCBob2xlc1xcblxcblxcdFxcdFxcdGZvciAoIGggPSAwLCBobCA9IGhvbGVzLmxlbmd0aDsgaCA8IGhsOyBoICsrICkge1xcblxcblxcdFxcdFxcdFxcdGFob2xlID0gaG9sZXNbIGggXTtcXG5cXHRcXHRcXHRcXHRvbmVIb2xlTW92ZW1lbnRzID0gaG9sZXNNb3ZlbWVudHNbIGggXTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMCwgaWwgPSBhaG9sZS5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ID0gc2NhbGVQdDIoIGFob2xlWyBpIF0sIG9uZUhvbGVNb3ZlbWVudHNbIGkgXSwgYnMgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoICEgZXh0cnVkZUJ5UGF0aCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2KCB2ZXJ0LngsIHZlcnQueSwgYW1vdW50ICsgeiApO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0diggdmVydC54LCB2ZXJ0LnkgKyBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS55LCBleHRydWRlUHRzWyBzdGVwcyAtIDEgXS54ICsgeiApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvKiBGYWNlcyAqL1xcblxcblxcdFxcdC8vIFRvcCBhbmQgYm90dG9tIGZhY2VzXFxuXFxuXFx0XFx0YnVpbGRMaWRGYWNlcygpO1xcblxcblxcdFxcdC8vIFNpZGVzIGZhY2VzXFxuXFxuXFx0XFx0YnVpbGRTaWRlRmFjZXMoKTtcXG5cXG5cXG5cXHRcXHQvLy8vLyAgSW50ZXJuYWwgZnVuY3Rpb25zXFxuXFxuXFx0XFx0ZnVuY3Rpb24gYnVpbGRMaWRGYWNlcygpIHtcXG5cXG5cXHRcXHRcXHR2YXIgc3RhcnQgPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDM7XFxuXFxuXFx0XFx0XFx0aWYgKCBiZXZlbEVuYWJsZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGxheWVyID0gMDsgLy8gc3RlcHMgKyAxXFxuXFx0XFx0XFx0XFx0dmFyIG9mZnNldCA9IHZsZW4gKiBsYXllcjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBCb3R0b20gZmFjZXNcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZSA9IGZhY2VzWyBpIF07XFxuXFx0XFx0XFx0XFx0XFx0ZjMoIGZhY2VbIDIgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAwIF0gKyBvZmZzZXQgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0bGF5ZXIgPSBzdGVwcyArIGJldmVsU2VnbWVudHMgKiAyO1xcblxcdFxcdFxcdFxcdG9mZnNldCA9IHZsZW4gKiBsYXllcjtcXG5cXG5cXHRcXHRcXHRcXHQvLyBUb3AgZmFjZXNcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZSA9IGZhY2VzWyBpIF07XFxuXFx0XFx0XFx0XFx0XFx0ZjMoIGZhY2VbIDAgXSArIG9mZnNldCwgZmFjZVsgMSBdICsgb2Zmc2V0LCBmYWNlWyAyIF0gKyBvZmZzZXQgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBCb3R0b20gZmFjZXNcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IGZsZW47IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZSA9IGZhY2VzWyBpIF07XFxuXFx0XFx0XFx0XFx0XFx0ZjMoIGZhY2VbIDIgXSwgZmFjZVsgMSBdLCBmYWNlWyAwIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ly8gVG9wIGZhY2VzXFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCBmbGVuOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGZhY2UgPSBmYWNlc1sgaSBdO1xcblxcdFxcdFxcdFxcdFxcdGYzKCBmYWNlWyAwIF0gKyB2bGVuICogc3RlcHMsIGZhY2VbIDEgXSArIHZsZW4gKiBzdGVwcywgZmFjZVsgMiBdICsgdmxlbiAqIHN0ZXBzICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRzY29wZS5hZGRHcm91cCggc3RhcnQsIHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMyAtIHN0YXJ0LCBvcHRpb25zLm1hdGVyaWFsICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1hdGVyaWFsIDogMCApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBDcmVhdGUgZmFjZXMgZm9yIHRoZSB6LXNpZGVzIG9mIHRoZSBzaGFwZVxcblxcblxcdFxcdGZ1bmN0aW9uIGJ1aWxkU2lkZUZhY2VzKCkge1xcblxcblxcdFxcdFxcdHZhciBzdGFydCA9IHZlcnRpY2VzQXJyYXkubGVuZ3RoIC8gMztcXG5cXHRcXHRcXHR2YXIgbGF5ZXJvZmZzZXQgPSAwO1xcblxcdFxcdFxcdHNpZGV3YWxscyggY29udG91ciwgbGF5ZXJvZmZzZXQgKTtcXG5cXHRcXHRcXHRsYXllcm9mZnNldCArPSBjb250b3VyLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRmb3IgKCBoID0gMCwgaGwgPSBob2xlcy5sZW5ndGg7IGggPCBobDsgaCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRhaG9sZSA9IGhvbGVzWyBoIF07XFxuXFx0XFx0XFx0XFx0c2lkZXdhbGxzKCBhaG9sZSwgbGF5ZXJvZmZzZXQgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLywgdHJ1ZVxcblxcdFxcdFxcdFxcdGxheWVyb2Zmc2V0ICs9IGFob2xlLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFxuXFx0XFx0XFx0c2NvcGUuYWRkR3JvdXAoIHN0YXJ0LCB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDMgLSBzdGFydCwgb3B0aW9ucy5leHRydWRlTWF0ZXJpYWwgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuZXh0cnVkZU1hdGVyaWFsIDogMSApO1xcblxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmdW5jdGlvbiBzaWRld2FsbHMoIGNvbnRvdXIsIGxheWVyb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdHZhciBqLCBrO1xcblxcdFxcdFxcdGkgPSBjb250b3VyLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHR3aGlsZSAoIC0tIGkgPj0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRqID0gaTtcXG5cXHRcXHRcXHRcXHRrID0gaSAtIDE7XFxuXFx0XFx0XFx0XFx0aWYgKCBrIDwgMCApIGsgPSBjb250b3VyLmxlbmd0aCAtIDE7XFxuXFxuXFx0XFx0XFx0XFx0Ly9jb25zb2xlLmxvZygnYicsIGksaiwgaS0xLCBrLHZlcnRpY2VzLmxlbmd0aCk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHMgPSAwLFxcblxcdFxcdFxcdFxcdFxcdHNsID0gc3RlcHMgKyBiZXZlbFNlZ21lbnRzICogMjtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCBzID0gMDsgcyA8IHNsOyBzICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBzbGVuMSA9IHZsZW4gKiBzO1xcblxcdFxcdFxcdFxcdFxcdHZhciBzbGVuMiA9IHZsZW4gKiAoIHMgKyAxICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGEgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRiID0gbGF5ZXJvZmZzZXQgKyBrICsgc2xlbjEsXFxuXFx0XFx0XFx0XFx0XFx0XFx0YyA9IGxheWVyb2Zmc2V0ICsgayArIHNsZW4yLFxcblxcdFxcdFxcdFxcdFxcdFxcdGQgPSBsYXllcm9mZnNldCArIGogKyBzbGVuMjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmNCggYSwgYiwgYywgZCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIHYoIHgsIHksIHogKSB7XFxuXFxuXFx0XFx0XFx0cGxhY2Vob2xkZXIucHVzaCggeCApO1xcblxcdFxcdFxcdHBsYWNlaG9sZGVyLnB1c2goIHkgKTtcXG5cXHRcXHRcXHRwbGFjZWhvbGRlci5wdXNoKCB6ICk7XFxuXFxuXFx0XFx0fVxcblxcblxcblxcdFxcdGZ1bmN0aW9uIGYzKCBhLCBiLCBjICkge1xcblxcblxcdFxcdFxcdGFkZFZlcnRleCggYSApO1xcblxcdFxcdFxcdGFkZFZlcnRleCggYiApO1xcblxcdFxcdFxcdGFkZFZlcnRleCggYyApO1xcblxcblxcdFxcdFxcdHZhciBuZXh0SW5kZXggPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDM7XFxuXFx0XFx0XFx0dmFyIHV2cyA9IHV2Z2VuLmdlbmVyYXRlVG9wVVYoIHNjb3BlLCB2ZXJ0aWNlc0FycmF5LCBuZXh0SW5kZXggLSAzLCBuZXh0SW5kZXggLSAyLCBuZXh0SW5kZXggLSAxICk7XFxuXFxuXFx0XFx0XFx0YWRkVVYoIHV2c1sgMCBdICk7XFxuXFx0XFx0XFx0YWRkVVYoIHV2c1sgMSBdICk7XFxuXFx0XFx0XFx0YWRkVVYoIHV2c1sgMiBdICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGY0KCBhLCBiLCBjLCBkICkge1xcblxcblxcdFxcdFxcdGFkZFZlcnRleCggYSApO1xcblxcdFxcdFxcdGFkZFZlcnRleCggYiApO1xcblxcdFxcdFxcdGFkZFZlcnRleCggZCApO1xcblxcblxcdFxcdFxcdGFkZFZlcnRleCggYiApO1xcblxcdFxcdFxcdGFkZFZlcnRleCggYyApO1xcblxcdFxcdFxcdGFkZFZlcnRleCggZCApO1xcblxcblxcblxcdFxcdFxcdHZhciBuZXh0SW5kZXggPSB2ZXJ0aWNlc0FycmF5Lmxlbmd0aCAvIDM7XFxuXFx0XFx0XFx0dmFyIHV2cyA9IHV2Z2VuLmdlbmVyYXRlU2lkZVdhbGxVViggc2NvcGUsIHZlcnRpY2VzQXJyYXksIG5leHRJbmRleCAtIDYsIG5leHRJbmRleCAtIDMsIG5leHRJbmRleCAtIDIsIG5leHRJbmRleCAtIDEgKTtcXG5cXG5cXHRcXHRcXHRhZGRVViggdXZzWyAwIF0gKTtcXG5cXHRcXHRcXHRhZGRVViggdXZzWyAxIF0gKTtcXG5cXHRcXHRcXHRhZGRVViggdXZzWyAzIF0gKTtcXG5cXG5cXHRcXHRcXHRhZGRVViggdXZzWyAxIF0gKTtcXG5cXHRcXHRcXHRhZGRVViggdXZzWyAyIF0gKTtcXG5cXHRcXHRcXHRhZGRVViggdXZzWyAzIF0gKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gYWRkVmVydGV4KCBpbmRleCApIHtcXG5cXG5cXHRcXHRcXHRpbmRpY2VzQXJyYXkucHVzaCggdmVydGljZXNBcnJheS5sZW5ndGggLyAzICk7XFxuXFx0XFx0XFx0dmVydGljZXNBcnJheS5wdXNoKCBwbGFjZWhvbGRlclsgaW5kZXggKiAzICsgMCBdICk7XFxuXFx0XFx0XFx0dmVydGljZXNBcnJheS5wdXNoKCBwbGFjZWhvbGRlclsgaW5kZXggKiAzICsgMSBdICk7XFxuXFx0XFx0XFx0dmVydGljZXNBcnJheS5wdXNoKCBwbGFjZWhvbGRlclsgaW5kZXggKiAzICsgMiBdICk7XFxuXFxuXFx0XFx0fVxcblxcblxcblxcdFxcdGZ1bmN0aW9uIGFkZFVWKCB2ZWN0b3IyICkge1xcblxcblxcdFxcdFxcdHV2QXJyYXkucHVzaCggdmVjdG9yMi54ICk7XFxuXFx0XFx0XFx0dXZBcnJheS5wdXNoKCB2ZWN0b3IyLnkgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCAhIG9wdGlvbnMuYXJyYXlzICkge1xcblxcblxcdFxcdFxcdHRoaXMuc2V0SW5kZXgoIGluZGljZXNBcnJheSApO1xcblxcdFxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXNBcnJheSwgMyApICk7XFxuXFx0XFx0XFx0dGhpcy5hZGRBdHRyaWJ1dGUoICd1dicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB1dkFycmF5LCAyICkgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fTtcXG5cXG5cXHRFeHRydWRlR2VvbWV0cnkuV29ybGRVVkdlbmVyYXRvciA9IHtcXG5cXG5cXHRcXHRnZW5lcmF0ZVRvcFVWOiBmdW5jdGlvbiAoIGdlb21ldHJ5LCB2ZXJ0aWNlcywgaW5kZXhBLCBpbmRleEIsIGluZGV4QyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYV94ID0gdmVydGljZXNbIGluZGV4QSAqIDMgXTtcXG5cXHRcXHRcXHR2YXIgYV95ID0gdmVydGljZXNbIGluZGV4QSAqIDMgKyAxIF07XFxuXFx0XFx0XFx0dmFyIGJfeCA9IHZlcnRpY2VzWyBpbmRleEIgKiAzIF07XFxuXFx0XFx0XFx0dmFyIGJfeSA9IHZlcnRpY2VzWyBpbmRleEIgKiAzICsgMSBdO1xcblxcdFxcdFxcdHZhciBjX3ggPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyBdO1xcblxcdFxcdFxcdHZhciBjX3kgPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyArIDEgXTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gW1xcblxcdFxcdFxcdFxcdG5ldyBWZWN0b3IyKCBhX3gsIGFfeSApLFxcblxcdFxcdFxcdFxcdG5ldyBWZWN0b3IyKCBiX3gsIGJfeSApLFxcblxcdFxcdFxcdFxcdG5ldyBWZWN0b3IyKCBjX3gsIGNfeSApXFxuXFx0XFx0XFx0XTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdlbmVyYXRlU2lkZVdhbGxVVjogZnVuY3Rpb24gKCBnZW9tZXRyeSwgdmVydGljZXMsIGluZGV4QSwgaW5kZXhCLCBpbmRleEMsIGluZGV4RCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYV94ID0gdmVydGljZXNbIGluZGV4QSAqIDMgXTtcXG5cXHRcXHRcXHR2YXIgYV95ID0gdmVydGljZXNbIGluZGV4QSAqIDMgKyAxIF07XFxuXFx0XFx0XFx0dmFyIGFfeiA9IHZlcnRpY2VzWyBpbmRleEEgKiAzICsgMiBdO1xcblxcdFxcdFxcdHZhciBiX3ggPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyBdO1xcblxcdFxcdFxcdHZhciBiX3kgPSB2ZXJ0aWNlc1sgaW5kZXhCICogMyArIDEgXTtcXG5cXHRcXHRcXHR2YXIgYl96ID0gdmVydGljZXNbIGluZGV4QiAqIDMgKyAyIF07XFxuXFx0XFx0XFx0dmFyIGNfeCA9IHZlcnRpY2VzWyBpbmRleEMgKiAzIF07XFxuXFx0XFx0XFx0dmFyIGNfeSA9IHZlcnRpY2VzWyBpbmRleEMgKiAzICsgMSBdO1xcblxcdFxcdFxcdHZhciBjX3ogPSB2ZXJ0aWNlc1sgaW5kZXhDICogMyArIDIgXTtcXG5cXHRcXHRcXHR2YXIgZF94ID0gdmVydGljZXNbIGluZGV4RCAqIDMgXTtcXG5cXHRcXHRcXHR2YXIgZF95ID0gdmVydGljZXNbIGluZGV4RCAqIDMgKyAxIF07XFxuXFx0XFx0XFx0dmFyIGRfeiA9IHZlcnRpY2VzWyBpbmRleEQgKiAzICsgMiBdO1xcblxcblxcdFxcdFxcdGlmICggTWF0aC5hYnMoIGFfeSAtIGJfeSApIDwgMC4wMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gW1xcblxcdFxcdFxcdFxcdFxcdG5ldyBWZWN0b3IyKCBhX3gsIDEgLSBhX3ogKSxcXG5cXHRcXHRcXHRcXHRcXHRuZXcgVmVjdG9yMiggYl94LCAxIC0gYl96ICksXFxuXFx0XFx0XFx0XFx0XFx0bmV3IFZlY3RvcjIoIGNfeCwgMSAtIGNfeiApLFxcblxcdFxcdFxcdFxcdFxcdG5ldyBWZWN0b3IyKCBkX3gsIDEgLSBkX3ogKVxcblxcdFxcdFxcdFxcdF07XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gW1xcblxcdFxcdFxcdFxcdFxcdG5ldyBWZWN0b3IyKCBhX3ksIDEgLSBhX3ogKSxcXG5cXHRcXHRcXHRcXHRcXHRuZXcgVmVjdG9yMiggYl95LCAxIC0gYl96ICksXFxuXFx0XFx0XFx0XFx0XFx0bmV3IFZlY3RvcjIoIGNfeSwgMSAtIGNfeiApLFxcblxcdFxcdFxcdFxcdFxcdG5ldyBWZWN0b3IyKCBkX3ksIDEgLSBkX3ogKVxcblxcdFxcdFxcdFxcdF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqXFxuXFx0ICogVGV4dCA9IDNEIFRleHRcXG5cXHQgKlxcblxcdCAqIHBhcmFtZXRlcnMgPSB7XFxuXFx0ICogIGZvbnQ6IDxUSFJFRS5Gb250PiwgLy8gZm9udFxcblxcdCAqXFxuXFx0ICogIHNpemU6IDxmbG9hdD4sIC8vIHNpemUgb2YgdGhlIHRleHRcXG5cXHQgKiAgaGVpZ2h0OiA8ZmxvYXQ+LCAvLyB0aGlja25lc3MgdG8gZXh0cnVkZSB0ZXh0XFxuXFx0ICogIGN1cnZlU2VnbWVudHM6IDxpbnQ+LCAvLyBudW1iZXIgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZXNcXG5cXHQgKlxcblxcdCAqICBiZXZlbEVuYWJsZWQ6IDxib29sPiwgLy8gdHVybiBvbiBiZXZlbFxcblxcdCAqICBiZXZlbFRoaWNrbmVzczogPGZsb2F0PiwgLy8gaG93IGRlZXAgaW50byB0ZXh0IGJldmVsIGdvZXNcXG5cXHQgKiAgYmV2ZWxTaXplOiA8ZmxvYXQ+IC8vIGhvdyBmYXIgZnJvbSB0ZXh0IG91dGxpbmUgaXMgYmV2ZWxcXG5cXHQgKiB9XFxuXFx0ICovXFxuXFxuXFx0Ly8gVGV4dEdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gVGV4dEdlb21ldHJ5KCB0ZXh0LCBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnVGV4dEdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0dGV4dDogdGV4dCxcXG5cXHRcXHRcXHRwYXJhbWV0ZXJzOiBwYXJhbWV0ZXJzXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFRleHRCdWZmZXJHZW9tZXRyeSggdGV4dCwgcGFyYW1ldGVycyApICk7XFxuXFx0XFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XFxuXFxuXFx0fVxcblxcblxcdFRleHRHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRUZXh0R2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVGV4dEdlb21ldHJ5O1xcblxcblxcdC8vIFRleHRCdWZmZXJHZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIFRleHRCdWZmZXJHZW9tZXRyeSggdGV4dCwgcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHRwYXJhbWV0ZXJzID0gcGFyYW1ldGVycyB8fCB7fTtcXG5cXG5cXHRcXHR2YXIgZm9udCA9IHBhcmFtZXRlcnMuZm9udDtcXG5cXG5cXHRcXHRpZiAoICEgKCBmb250ICYmIGZvbnQuaXNGb250ICkgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlRleHRHZW9tZXRyeTogZm9udCBwYXJhbWV0ZXIgaXMgbm90IGFuIGluc3RhbmNlIG9mIFRIUkVFLkZvbnQuJyApO1xcblxcdFxcdFxcdHJldHVybiBuZXcgR2VvbWV0cnkoKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dmFyIHNoYXBlcyA9IGZvbnQuZ2VuZXJhdGVTaGFwZXMoIHRleHQsIHBhcmFtZXRlcnMuc2l6ZSwgcGFyYW1ldGVycy5jdXJ2ZVNlZ21lbnRzICk7XFxuXFxuXFx0XFx0Ly8gdHJhbnNsYXRlIHBhcmFtZXRlcnMgdG8gRXh0cnVkZUdlb21ldHJ5IEFQSVxcblxcblxcdFxcdHBhcmFtZXRlcnMuYW1vdW50ID0gcGFyYW1ldGVycy5oZWlnaHQgIT09IHVuZGVmaW5lZCA/IHBhcmFtZXRlcnMuaGVpZ2h0IDogNTA7XFxuXFxuXFx0XFx0Ly8gZGVmYXVsdHNcXG5cXG5cXHRcXHRpZiAoIHBhcmFtZXRlcnMuYmV2ZWxUaGlja25lc3MgPT09IHVuZGVmaW5lZCApIHBhcmFtZXRlcnMuYmV2ZWxUaGlja25lc3MgPSAxMDtcXG5cXHRcXHRpZiAoIHBhcmFtZXRlcnMuYmV2ZWxTaXplID09PSB1bmRlZmluZWQgKSBwYXJhbWV0ZXJzLmJldmVsU2l6ZSA9IDg7XFxuXFx0XFx0aWYgKCBwYXJhbWV0ZXJzLmJldmVsRW5hYmxlZCA9PT0gdW5kZWZpbmVkICkgcGFyYW1ldGVycy5iZXZlbEVuYWJsZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHRFeHRydWRlQnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcywgc2hhcGVzLCBwYXJhbWV0ZXJzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1RleHRCdWZmZXJHZW9tZXRyeSc7XFxuXFxuXFx0fVxcblxcblxcdFRleHRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFeHRydWRlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0VGV4dEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRleHRCdWZmZXJHZW9tZXRyeTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxuXFx0ICovXFxuXFxuXFx0Ly8gU3BoZXJlR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBTcGhlcmVHZW9tZXRyeSggcmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XFxuXFxuXFx0XFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdTcGhlcmVHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcblxcdFxcdFxcdHdpZHRoU2VnbWVudHM6IHdpZHRoU2VnbWVudHMsXFxuXFx0XFx0XFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxcblxcdFxcdFxcdHBoaVN0YXJ0OiBwaGlTdGFydCxcXG5cXHRcXHRcXHRwaGlMZW5ndGg6IHBoaUxlbmd0aCxcXG5cXHRcXHRcXHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxcblxcdFxcdFxcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBTcGhlcmVCdWZmZXJHZW9tZXRyeSggcmFkaXVzLCB3aWR0aFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSApO1xcblxcdFxcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xcblxcblxcdH1cXG5cXG5cXHRTcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRTcGhlcmVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTcGhlcmVHZW9tZXRyeTtcXG5cXG5cXHQvLyBTcGhlcmVCdWZmZXJHZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIFNwaGVyZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHdpZHRoU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcXG5cXG5cXHRcXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1NwaGVyZUJ1ZmZlckdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxuXFx0XFx0XFx0d2lkdGhTZWdtZW50czogd2lkdGhTZWdtZW50cyxcXG5cXHRcXHRcXHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXFxuXFx0XFx0XFx0cGhpU3RhcnQ6IHBoaVN0YXJ0LFxcblxcdFxcdFxcdHBoaUxlbmd0aDogcGhpTGVuZ3RoLFxcblxcdFxcdFxcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXFxuXFx0XFx0XFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRyYWRpdXMgPSByYWRpdXMgfHwgMTtcXG5cXG5cXHRcXHR3aWR0aFNlZ21lbnRzID0gTWF0aC5tYXgoIDMsIE1hdGguZmxvb3IoIHdpZHRoU2VnbWVudHMgKSB8fCA4ICk7XFxuXFx0XFx0aGVpZ2h0U2VnbWVudHMgPSBNYXRoLm1heCggMiwgTWF0aC5mbG9vciggaGVpZ2h0U2VnbWVudHMgKSB8fCA2ICk7XFxuXFxuXFx0XFx0cGhpU3RhcnQgPSBwaGlTdGFydCAhPT0gdW5kZWZpbmVkID8gcGhpU3RhcnQgOiAwO1xcblxcdFxcdHBoaUxlbmd0aCA9IHBoaUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gcGhpTGVuZ3RoIDogTWF0aC5QSSAqIDI7XFxuXFxuXFx0XFx0dGhldGFTdGFydCA9IHRoZXRhU3RhcnQgIT09IHVuZGVmaW5lZCA/IHRoZXRhU3RhcnQgOiAwO1xcblxcdFxcdHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSTtcXG5cXG5cXHRcXHR2YXIgdGhldGFFbmQgPSB0aGV0YVN0YXJ0ICsgdGhldGFMZW5ndGg7XFxuXFxuXFx0XFx0dmFyIGl4LCBpeTtcXG5cXG5cXHRcXHR2YXIgaW5kZXggPSAwO1xcblxcdFxcdHZhciBncmlkID0gW107XFxuXFxuXFx0XFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0Ly8gYnVmZmVyc1xcblxcblxcdFxcdHZhciBpbmRpY2VzID0gW107XFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW107XFxuXFx0XFx0dmFyIG5vcm1hbHMgPSBbXTtcXG5cXHRcXHR2YXIgdXZzID0gW107XFxuXFxuXFx0XFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMsIG5vcm1hbHMgYW5kIHV2c1xcblxcblxcdFxcdGZvciAoIGl5ID0gMDsgaXkgPD0gaGVpZ2h0U2VnbWVudHM7IGl5ICsrICkge1xcblxcblxcdFxcdFxcdHZhciB2ZXJ0aWNlc1JvdyA9IFtdO1xcblxcblxcdFxcdFxcdHZhciB2ID0gaXkgLyBoZWlnaHRTZWdtZW50cztcXG5cXG5cXHRcXHRcXHRmb3IgKCBpeCA9IDA7IGl4IDw9IHdpZHRoU2VnbWVudHM7IGl4ICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB1ID0gaXggLyB3aWR0aFNlZ21lbnRzO1xcblxcblxcdFxcdFxcdFxcdC8vIHZlcnRleFxcblxcblxcdFxcdFxcdFxcdHZlcnRleC54ID0gLSByYWRpdXMgKiBNYXRoLmNvcyggcGhpU3RhcnQgKyB1ICogcGhpTGVuZ3RoICkgKiBNYXRoLnNpbiggdGhldGFTdGFydCArIHYgKiB0aGV0YUxlbmd0aCApO1xcblxcdFxcdFxcdFxcdHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5jb3MoIHRoZXRhU3RhcnQgKyB2ICogdGhldGFMZW5ndGggKTtcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIE1hdGguc2luKCBwaGlTdGFydCArIHUgKiBwaGlMZW5ndGggKSAqIE1hdGguc2luKCB0aGV0YVN0YXJ0ICsgdiAqIHRoZXRhTGVuZ3RoICk7XFxuXFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xcblxcblxcdFxcdFxcdFxcdC8vIG5vcm1hbFxcblxcblxcdFxcdFxcdFxcdG5vcm1hbC5zZXQoIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKS5ub3JtYWxpemUoKTtcXG5cXHRcXHRcXHRcXHRub3JtYWxzLnB1c2goIG5vcm1hbC54LCBub3JtYWwueSwgbm9ybWFsLnogKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyB1dlxcblxcblxcdFxcdFxcdFxcdHV2cy5wdXNoKCB1LCAxIC0gdiApO1xcblxcblxcdFxcdFxcdFxcdHZlcnRpY2VzUm93LnB1c2goIGluZGV4ICsrICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGdyaWQucHVzaCggdmVydGljZXNSb3cgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gaW5kaWNlc1xcblxcblxcdFxcdGZvciAoIGl5ID0gMDsgaXkgPCBoZWlnaHRTZWdtZW50czsgaXkgKysgKSB7XFxuXFxuXFx0XFx0XFx0Zm9yICggaXggPSAwOyBpeCA8IHdpZHRoU2VnbWVudHM7IGl4ICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBhID0gZ3JpZFsgaXkgXVsgaXggKyAxIF07XFxuXFx0XFx0XFx0XFx0dmFyIGIgPSBncmlkWyBpeSBdWyBpeCBdO1xcblxcdFxcdFxcdFxcdHZhciBjID0gZ3JpZFsgaXkgKyAxIF1bIGl4IF07XFxuXFx0XFx0XFx0XFx0dmFyIGQgPSBncmlkWyBpeSArIDEgXVsgaXggKyAxIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpeSAhPT0gMCB8fCB0aGV0YVN0YXJ0ID4gMCApIGluZGljZXMucHVzaCggYSwgYiwgZCApO1xcblxcdFxcdFxcdFxcdGlmICggaXkgIT09IGhlaWdodFNlZ21lbnRzIC0gMSB8fCB0aGV0YUVuZCA8IE1hdGguUEkgKSBpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGJ1aWxkIGdlb21ldHJ5XFxuXFxuXFx0XFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcXG5cXG5cXHR9XFxuXFxuXFx0U3BoZXJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0U3BoZXJlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3BoZXJlQnVmZmVyR2VvbWV0cnk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBLYWxlYiBNdXJwaHlcXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqL1xcblxcblxcdC8vIFJpbmdHZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIFJpbmdHZW9tZXRyeSggaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCB0aGV0YVNlZ21lbnRzLCBwaGlTZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XFxuXFxuXFx0XFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdSaW5nR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRpbm5lclJhZGl1czogaW5uZXJSYWRpdXMsXFxuXFx0XFx0XFx0b3V0ZXJSYWRpdXM6IG91dGVyUmFkaXVzLFxcblxcdFxcdFxcdHRoZXRhU2VnbWVudHM6IHRoZXRhU2VnbWVudHMsXFxuXFx0XFx0XFx0cGhpU2VnbWVudHM6IHBoaVNlZ21lbnRzLFxcblxcdFxcdFxcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXFxuXFx0XFx0XFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IFJpbmdCdWZmZXJHZW9tZXRyeSggaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCB0aGV0YVNlZ21lbnRzLCBwaGlTZWdtZW50cywgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSApO1xcblxcdFxcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xcblxcblxcdH1cXG5cXG5cXHRSaW5nR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0UmluZ0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJpbmdHZW9tZXRyeTtcXG5cXG5cXHQvLyBSaW5nQnVmZmVyR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBSaW5nQnVmZmVyR2VvbWV0cnkoIGlubmVyUmFkaXVzLCBvdXRlclJhZGl1cywgdGhldGFTZWdtZW50cywgcGhpU2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xcblxcblxcdFxcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnUmluZ0J1ZmZlckdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0aW5uZXJSYWRpdXM6IGlubmVyUmFkaXVzLFxcblxcdFxcdFxcdG91dGVyUmFkaXVzOiBvdXRlclJhZGl1cyxcXG5cXHRcXHRcXHR0aGV0YVNlZ21lbnRzOiB0aGV0YVNlZ21lbnRzLFxcblxcdFxcdFxcdHBoaVNlZ21lbnRzOiBwaGlTZWdtZW50cyxcXG5cXHRcXHRcXHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxcblxcdFxcdFxcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxcblxcdFxcdH07XFxuXFxuXFx0XFx0aW5uZXJSYWRpdXMgPSBpbm5lclJhZGl1cyB8fCAwLjU7XFxuXFx0XFx0b3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyB8fCAxO1xcblxcblxcdFxcdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMDtcXG5cXHRcXHR0aGV0YUxlbmd0aCA9IHRoZXRhTGVuZ3RoICE9PSB1bmRlZmluZWQgPyB0aGV0YUxlbmd0aCA6IE1hdGguUEkgKiAyO1xcblxcblxcdFxcdHRoZXRhU2VnbWVudHMgPSB0aGV0YVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMywgdGhldGFTZWdtZW50cyApIDogODtcXG5cXHRcXHRwaGlTZWdtZW50cyA9IHBoaVNlZ21lbnRzICE9PSB1bmRlZmluZWQgPyBNYXRoLm1heCggMSwgcGhpU2VnbWVudHMgKSA6IDE7XFxuXFxuXFx0XFx0Ly8gYnVmZmVyc1xcblxcblxcdFxcdHZhciBpbmRpY2VzID0gW107XFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW107XFxuXFx0XFx0dmFyIG5vcm1hbHMgPSBbXTtcXG5cXHRcXHR2YXIgdXZzID0gW107XFxuXFxuXFx0XFx0Ly8gc29tZSBoZWxwZXIgdmFyaWFibGVzXFxuXFxuXFx0XFx0dmFyIHNlZ21lbnQ7XFxuXFx0XFx0dmFyIHJhZGl1cyA9IGlubmVyUmFkaXVzO1xcblxcdFxcdHZhciByYWRpdXNTdGVwID0gKCAoIG91dGVyUmFkaXVzIC0gaW5uZXJSYWRpdXMgKSAvIHBoaVNlZ21lbnRzICk7XFxuXFx0XFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dmFyIHV2ID0gbmV3IFZlY3RvcjIoKTtcXG5cXHRcXHR2YXIgaiwgaTtcXG5cXG5cXHRcXHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlcywgbm9ybWFscyBhbmQgdXZzXFxuXFxuXFx0XFx0Zm9yICggaiA9IDA7IGogPD0gcGhpU2VnbWVudHM7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPD0gdGhldGFTZWdtZW50czsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyB2YWx1ZXMgYXJlIGdlbmVyYXRlIGZyb20gdGhlIGluc2lkZSBvZiB0aGUgcmluZyB0byB0aGUgb3V0c2lkZVxcblxcblxcdFxcdFxcdFxcdHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgaSAvIHRoZXRhU2VnbWVudHMgKiB0aGV0YUxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHQvLyB2ZXJ0ZXhcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIE1hdGguY29zKCBzZWdtZW50ICk7XFxuXFx0XFx0XFx0XFx0dmVydGV4LnkgPSByYWRpdXMgKiBNYXRoLnNpbiggc2VnbWVudCApO1xcblxcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBub3JtYWxcXG5cXG5cXHRcXHRcXHRcXHRub3JtYWxzLnB1c2goIDAsIDAsIDEgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyB1dlxcblxcblxcdFxcdFxcdFxcdHV2LnggPSAoIHZlcnRleC54IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyO1xcblxcdFxcdFxcdFxcdHV2LnkgPSAoIHZlcnRleC55IC8gb3V0ZXJSYWRpdXMgKyAxICkgLyAyO1xcblxcblxcdFxcdFxcdFxcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGluY3JlYXNlIHRoZSByYWRpdXMgZm9yIG5leHQgcm93IG9mIHZlcnRpY2VzXFxuXFxuXFx0XFx0XFx0cmFkaXVzICs9IHJhZGl1c1N0ZXA7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGluZGljZXNcXG5cXG5cXHRcXHRmb3IgKCBqID0gMDsgaiA8IHBoaVNlZ21lbnRzOyBqICsrICkge1xcblxcblxcdFxcdFxcdHZhciB0aGV0YVNlZ21lbnRMZXZlbCA9IGogKiAoIHRoZXRhU2VnbWVudHMgKyAxICk7XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCB0aGV0YVNlZ21lbnRzOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHNlZ21lbnQgPSBpICsgdGhldGFTZWdtZW50TGV2ZWw7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGEgPSBzZWdtZW50O1xcblxcdFxcdFxcdFxcdHZhciBiID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAxO1xcblxcdFxcdFxcdFxcdHZhciBjID0gc2VnbWVudCArIHRoZXRhU2VnbWVudHMgKyAyO1xcblxcdFxcdFxcdFxcdHZhciBkID0gc2VnbWVudCArIDE7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gZmFjZXNcXG5cXG5cXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcXG5cXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGJ1aWxkIGdlb21ldHJ5XFxuXFxuXFx0XFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcXG5cXG5cXHR9XFxuXFxuXFx0UmluZ0J1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdFJpbmdCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSaW5nQnVmZmVyR2VvbWV0cnk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhc3Ryb2R1ZCAvIGh0dHA6Ly9hc3Ryb2R1ZC5pc2dyZWF0Lm9yZy9cXG5cXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwczovL2dpdGh1Yi5jb20veno4NVxcblxcdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW9cXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqL1xcblxcblxcdC8vIExhdGhlR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBMYXRoZUdlb21ldHJ5KCBwb2ludHMsIHNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoICkge1xcblxcblxcdFxcdEdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnTGF0aGVHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHBvaW50czogcG9pbnRzLFxcblxcdFxcdFxcdHNlZ21lbnRzOiBzZWdtZW50cyxcXG5cXHRcXHRcXHRwaGlTdGFydDogcGhpU3RhcnQsXFxuXFx0XFx0XFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGhcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuZnJvbUJ1ZmZlckdlb21ldHJ5KCBuZXcgTGF0aGVCdWZmZXJHZW9tZXRyeSggcG9pbnRzLCBzZWdtZW50cywgcGhpU3RhcnQsIHBoaUxlbmd0aCApICk7XFxuXFx0XFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XFxuXFxuXFx0fVxcblxcblxcdExhdGhlR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0TGF0aGVHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMYXRoZUdlb21ldHJ5O1xcblxcblxcdC8vIExhdGhlQnVmZmVyR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBMYXRoZUJ1ZmZlckdlb21ldHJ5KCBwb2ludHMsIHNlZ21lbnRzLCBwaGlTdGFydCwgcGhpTGVuZ3RoICkge1xcblxcblxcdFxcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnTGF0aGVCdWZmZXJHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHBvaW50czogcG9pbnRzLFxcblxcdFxcdFxcdHNlZ21lbnRzOiBzZWdtZW50cyxcXG5cXHRcXHRcXHRwaGlTdGFydDogcGhpU3RhcnQsXFxuXFx0XFx0XFx0cGhpTGVuZ3RoOiBwaGlMZW5ndGhcXG5cXHRcXHR9O1xcblxcblxcdFxcdHNlZ21lbnRzID0gTWF0aC5mbG9vciggc2VnbWVudHMgKSB8fCAxMjtcXG5cXHRcXHRwaGlTdGFydCA9IHBoaVN0YXJ0IHx8IDA7XFxuXFx0XFx0cGhpTGVuZ3RoID0gcGhpTGVuZ3RoIHx8IE1hdGguUEkgKiAyO1xcblxcblxcdFxcdC8vIGNsYW1wIHBoaUxlbmd0aCBzbyBpdCdzIGluIHJhbmdlIG9mIFsgMCwgMlBJIF1cXG5cXG5cXHRcXHRwaGlMZW5ndGggPSBfTWF0aC5jbGFtcCggcGhpTGVuZ3RoLCAwLCBNYXRoLlBJICogMiApO1xcblxcblxcblxcdFxcdC8vIGJ1ZmZlcnNcXG5cXG5cXHRcXHR2YXIgaW5kaWNlcyA9IFtdO1xcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdO1xcblxcdFxcdHZhciB1dnMgPSBbXTtcXG5cXG5cXHRcXHQvLyBoZWxwZXIgdmFyaWFibGVzXFxuXFxuXFx0XFx0dmFyIGJhc2U7XFxuXFx0XFx0dmFyIGludmVyc2VTZWdtZW50cyA9IDEuMCAvIHNlZ21lbnRzO1xcblxcdFxcdHZhciB2ZXJ0ZXggPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHZhciB1diA9IG5ldyBWZWN0b3IyKCk7XFxuXFx0XFx0dmFyIGksIGo7XFxuXFxuXFx0XFx0Ly8gZ2VuZXJhdGUgdmVydGljZXMgYW5kIHV2c1xcblxcblxcdFxcdGZvciAoIGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xcblxcblxcdFxcdFxcdHZhciBwaGkgPSBwaGlTdGFydCArIGkgKiBpbnZlcnNlU2VnbWVudHMgKiBwaGlMZW5ndGg7XFxuXFxuXFx0XFx0XFx0dmFyIHNpbiA9IE1hdGguc2luKCBwaGkgKTtcXG5cXHRcXHRcXHR2YXIgY29zID0gTWF0aC5jb3MoIHBoaSApO1xcblxcblxcdFxcdFxcdGZvciAoIGogPSAwOyBqIDw9ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyB2ZXJ0ZXhcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueCA9IHBvaW50c1sgaiBdLnggKiBzaW47XFxuXFx0XFx0XFx0XFx0dmVydGV4LnkgPSBwb2ludHNbIGogXS55O1xcblxcdFxcdFxcdFxcdHZlcnRleC56ID0gcG9pbnRzWyBqIF0ueCAqIGNvcztcXG5cXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdXZcXG5cXG5cXHRcXHRcXHRcXHR1di54ID0gaSAvIHNlZ21lbnRzO1xcblxcdFxcdFxcdFxcdHV2LnkgPSBqIC8gKCBwb2ludHMubGVuZ3RoIC0gMSApO1xcblxcblxcdFxcdFxcdFxcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XFxuXFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBpbmRpY2VzXFxuXFxuXFx0XFx0Zm9yICggaSA9IDA7IGkgPCBzZWdtZW50czsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRmb3IgKCBqID0gMDsgaiA8ICggcG9pbnRzLmxlbmd0aCAtIDEgKTsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRiYXNlID0gaiArIGkgKiBwb2ludHMubGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdHZhciBhID0gYmFzZTtcXG5cXHRcXHRcXHRcXHR2YXIgYiA9IGJhc2UgKyBwb2ludHMubGVuZ3RoO1xcblxcdFxcdFxcdFxcdHZhciBjID0gYmFzZSArIHBvaW50cy5sZW5ndGggKyAxO1xcblxcdFxcdFxcdFxcdHZhciBkID0gYmFzZSArIDE7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gZmFjZXNcXG5cXG5cXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGEsIGIsIGQgKTtcXG5cXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGIsIGMsIGQgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGJ1aWxkIGdlb21ldHJ5XFxuXFxuXFx0XFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcXG5cXG5cXHRcXHQvLyBnZW5lcmF0ZSBub3JtYWxzXFxuXFxuXFx0XFx0dGhpcy5jb21wdXRlVmVydGV4Tm9ybWFscygpO1xcblxcblxcdFxcdC8vIGlmIHRoZSBnZW9tZXRyeSBpcyBjbG9zZWQsIHdlIG5lZWQgdG8gYXZlcmFnZSB0aGUgbm9ybWFscyBhbG9uZyB0aGUgc2VhbS5cXG5cXHRcXHQvLyBiZWNhdXNlIHRoZSBjb3JyZXNwb25kaW5nIHZlcnRpY2VzIGFyZSBpZGVudGljYWwgKGJ1dCBzdGlsbCBoYXZlIGRpZmZlcmVudCBVVnMpLlxcblxcblxcdFxcdGlmICggcGhpTGVuZ3RoID09PSBNYXRoLlBJICogMiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgbm9ybWFscyA9IHRoaXMuYXR0cmlidXRlcy5ub3JtYWwuYXJyYXk7XFxuXFx0XFx0XFx0dmFyIG4xID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgbjIgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciBuID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHQvLyB0aGlzIGlzIHRoZSBidWZmZXIgb2Zmc2V0IGZvciB0aGUgbGFzdCBsaW5lIG9mIHZlcnRpY2VzXFxuXFxuXFx0XFx0XFx0YmFzZSA9IHNlZ21lbnRzICogcG9pbnRzLmxlbmd0aCAqIDM7XFxuXFxuXFx0XFx0XFx0Zm9yICggaSA9IDAsIGogPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSArKywgaiArPSAzICkge1xcblxcblxcdFxcdFxcdFxcdC8vIHNlbGVjdCB0aGUgbm9ybWFsIG9mIHRoZSB2ZXJ0ZXggaW4gdGhlIGZpcnN0IGxpbmVcXG5cXG5cXHRcXHRcXHRcXHRuMS54ID0gbm9ybWFsc1sgaiArIDAgXTtcXG5cXHRcXHRcXHRcXHRuMS55ID0gbm9ybWFsc1sgaiArIDEgXTtcXG5cXHRcXHRcXHRcXHRuMS56ID0gbm9ybWFsc1sgaiArIDIgXTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBzZWxlY3QgdGhlIG5vcm1hbCBvZiB0aGUgdmVydGV4IGluIHRoZSBsYXN0IGxpbmVcXG5cXG5cXHRcXHRcXHRcXHRuMi54ID0gbm9ybWFsc1sgYmFzZSArIGogKyAwIF07XFxuXFx0XFx0XFx0XFx0bjIueSA9IG5vcm1hbHNbIGJhc2UgKyBqICsgMSBdO1xcblxcdFxcdFxcdFxcdG4yLnogPSBub3JtYWxzWyBiYXNlICsgaiArIDIgXTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBhdmVyYWdlIG5vcm1hbHNcXG5cXG5cXHRcXHRcXHRcXHRuLmFkZFZlY3RvcnMoIG4xLCBuMiApLm5vcm1hbGl6ZSgpO1xcblxcblxcdFxcdFxcdFxcdC8vIGFzc2lnbiB0aGUgbmV3IHZhbHVlcyB0byBib3RoIG5vcm1hbHNcXG5cXG5cXHRcXHRcXHRcXHRub3JtYWxzWyBqICsgMCBdID0gbm9ybWFsc1sgYmFzZSArIGogKyAwIF0gPSBuLng7XFxuXFx0XFx0XFx0XFx0bm9ybWFsc1sgaiArIDEgXSA9IG5vcm1hbHNbIGJhc2UgKyBqICsgMSBdID0gbi55O1xcblxcdFxcdFxcdFxcdG5vcm1hbHNbIGogKyAyIF0gPSBub3JtYWxzWyBiYXNlICsgaiArIDIgXSA9IG4uejtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHRMYXRoZUJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdExhdGhlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGF0aGVCdWZmZXJHZW9tZXRyeTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGpvbm9icjEgLyBodHRwOi8vam9ub2JyMS5jb21cXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqL1xcblxcblxcdC8vIFNoYXBlR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBTaGFwZUdlb21ldHJ5KCBzaGFwZXMsIGN1cnZlU2VnbWVudHMgKSB7XFxuXFxuXFx0XFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdTaGFwZUdlb21ldHJ5JztcXG5cXG5cXHRcXHRpZiAoIHR5cGVvZiBjdXJ2ZVNlZ21lbnRzID09PSAnb2JqZWN0JyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5TaGFwZUdlb21ldHJ5OiBPcHRpb25zIHBhcmFtZXRlciBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHRcXHRcXHRjdXJ2ZVNlZ21lbnRzID0gY3VydmVTZWdtZW50cy5jdXJ2ZVNlZ21lbnRzO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0c2hhcGVzOiBzaGFwZXMsXFxuXFx0XFx0XFx0Y3VydmVTZWdtZW50czogY3VydmVTZWdtZW50c1xcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBTaGFwZUJ1ZmZlckdlb21ldHJ5KCBzaGFwZXMsIGN1cnZlU2VnbWVudHMgKSApO1xcblxcdFxcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xcblxcblxcdH1cXG5cXG5cXHRTaGFwZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdFNoYXBlR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2hhcGVHZW9tZXRyeTtcXG5cXG5cXHRTaGFwZUdlb21ldHJ5LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dmFyIGRhdGEgPSBHZW9tZXRyeS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR2YXIgc2hhcGVzID0gdGhpcy5wYXJhbWV0ZXJzLnNoYXBlcztcXG5cXG5cXHRcXHRyZXR1cm4gdG9KU09OKCBzaGFwZXMsIGRhdGEgKTtcXG5cXG5cXHR9O1xcblxcblxcdC8vIFNoYXBlQnVmZmVyR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBTaGFwZUJ1ZmZlckdlb21ldHJ5KCBzaGFwZXMsIGN1cnZlU2VnbWVudHMgKSB7XFxuXFxuXFx0XFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdTaGFwZUJ1ZmZlckdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0c2hhcGVzOiBzaGFwZXMsXFxuXFx0XFx0XFx0Y3VydmVTZWdtZW50czogY3VydmVTZWdtZW50c1xcblxcdFxcdH07XFxuXFxuXFx0XFx0Y3VydmVTZWdtZW50cyA9IGN1cnZlU2VnbWVudHMgfHwgMTI7XFxuXFxuXFx0XFx0Ly8gYnVmZmVyc1xcblxcblxcdFxcdHZhciBpbmRpY2VzID0gW107XFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW107XFxuXFx0XFx0dmFyIG5vcm1hbHMgPSBbXTtcXG5cXHRcXHR2YXIgdXZzID0gW107XFxuXFxuXFx0XFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xcblxcblxcdFxcdHZhciBncm91cFN0YXJ0ID0gMDtcXG5cXHRcXHR2YXIgZ3JvdXBDb3VudCA9IDA7XFxuXFxuXFx0XFx0Ly8gYWxsb3cgc2luZ2xlIGFuZCBhcnJheSB2YWx1ZXMgZm9yIFxcXCJzaGFwZXNcXFwiIHBhcmFtZXRlclxcblxcblxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdGFkZFNoYXBlKCBzaGFwZXMgKTtcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IHNoYXBlcy5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YWRkU2hhcGUoIHNoYXBlc1sgaSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5hZGRHcm91cCggZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgaSApOyAvLyBlbmFibGVzIE11bHRpTWF0ZXJpYWwgc3VwcG9ydFxcblxcblxcdFxcdFxcdFxcdGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcXG5cXHRcXHRcXHRcXHRncm91cENvdW50ID0gMDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGJ1aWxkIGdlb21ldHJ5XFxuXFxuXFx0XFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcXG5cXG5cXG5cXHRcXHQvLyBoZWxwZXIgZnVuY3Rpb25zXFxuXFxuXFx0XFx0ZnVuY3Rpb24gYWRkU2hhcGUoIHNoYXBlICkge1xcblxcblxcdFxcdFxcdHZhciBpLCBsLCBzaGFwZUhvbGU7XFxuXFxuXFx0XFx0XFx0dmFyIGluZGV4T2Zmc2V0ID0gdmVydGljZXMubGVuZ3RoIC8gMztcXG5cXHRcXHRcXHR2YXIgcG9pbnRzID0gc2hhcGUuZXh0cmFjdFBvaW50cyggY3VydmVTZWdtZW50cyApO1xcblxcblxcdFxcdFxcdHZhciBzaGFwZVZlcnRpY2VzID0gcG9pbnRzLnNoYXBlO1xcblxcdFxcdFxcdHZhciBzaGFwZUhvbGVzID0gcG9pbnRzLmhvbGVzO1xcblxcblxcdFxcdFxcdC8vIGNoZWNrIGRpcmVjdGlvbiBvZiB2ZXJ0aWNlc1xcblxcblxcdFxcdFxcdGlmICggU2hhcGVVdGlscy5pc0Nsb2NrV2lzZSggc2hhcGVWZXJ0aWNlcyApID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRzaGFwZVZlcnRpY2VzID0gc2hhcGVWZXJ0aWNlcy5yZXZlcnNlKCk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gYWxzbyBjaGVjayBpZiBob2xlcyBhcmUgaW4gdGhlIG9wcG9zaXRlIGRpcmVjdGlvblxcblxcblxcdFxcdFxcdFxcdGZvciAoIGkgPSAwLCBsID0gc2hhcGVIb2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHNoYXBlSG9sZSA9IHNoYXBlSG9sZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIFNoYXBlVXRpbHMuaXNDbG9ja1dpc2UoIHNoYXBlSG9sZSApID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHNoYXBlSG9sZXNbIGkgXSA9IHNoYXBlSG9sZS5yZXZlcnNlKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGZhY2VzID0gU2hhcGVVdGlscy50cmlhbmd1bGF0ZVNoYXBlKCBzaGFwZVZlcnRpY2VzLCBzaGFwZUhvbGVzICk7XFxuXFxuXFx0XFx0XFx0Ly8gam9pbiB2ZXJ0aWNlcyBvZiBpbm5lciBhbmQgb3V0ZXIgcGF0aHMgdG8gYSBzaW5nbGUgYXJyYXlcXG5cXG5cXHRcXHRcXHRmb3IgKCBpID0gMCwgbCA9IHNoYXBlSG9sZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRzaGFwZUhvbGUgPSBzaGFwZUhvbGVzWyBpIF07XFxuXFx0XFx0XFx0XFx0c2hhcGVWZXJ0aWNlcyA9IHNoYXBlVmVydGljZXMuY29uY2F0KCBzaGFwZUhvbGUgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gdmVydGljZXMsIG5vcm1hbHMsIHV2c1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBsID0gc2hhcGVWZXJ0aWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB2ZXJ0ZXggPSBzaGFwZVZlcnRpY2VzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCAwICk7XFxuXFx0XFx0XFx0XFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XFxuXFx0XFx0XFx0XFx0dXZzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSApOyAvLyB3b3JsZCB1dnNcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gaW5jaWRlc1xcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGEgPSBmYWNlWyAwIF0gKyBpbmRleE9mZnNldDtcXG5cXHRcXHRcXHRcXHR2YXIgYiA9IGZhY2VbIDEgXSArIGluZGV4T2Zmc2V0O1xcblxcdFxcdFxcdFxcdHZhciBjID0gZmFjZVsgMiBdICsgaW5kZXhPZmZzZXQ7XFxuXFxuXFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBhLCBiLCBjICk7XFxuXFx0XFx0XFx0XFx0Z3JvdXBDb3VudCArPSAzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0fVxcblxcblxcdFNoYXBlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0U2hhcGVCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTaGFwZUJ1ZmZlckdlb21ldHJ5O1xcblxcblxcdFNoYXBlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHR2YXIgZGF0YSA9IEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHZhciBzaGFwZXMgPSB0aGlzLnBhcmFtZXRlcnMuc2hhcGVzO1xcblxcblxcdFxcdHJldHVybiB0b0pTT04oIHNoYXBlcywgZGF0YSApO1xcblxcblxcdH07XFxuXFxuXFx0Ly9cXG5cXG5cXHRmdW5jdGlvbiB0b0pTT04oIHNoYXBlcywgZGF0YSApIHtcXG5cXG5cXHRcXHRkYXRhLnNoYXBlcyA9IFtdO1xcblxcblxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggc2hhcGVzICkgKSB7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc2hhcGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHNoYXBlID0gc2hhcGVzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0ZGF0YS5zaGFwZXMucHVzaCggc2hhcGUudXVpZCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdGRhdGEuc2hhcGVzLnB1c2goIHNoYXBlcy51dWlkICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBkYXRhO1xcblxcblxcdH1cXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEVkZ2VzR2VvbWV0cnkoIGdlb21ldHJ5LCB0aHJlc2hvbGRBbmdsZSApIHtcXG5cXG5cXHRcXHRCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0VkZ2VzR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHR0aHJlc2hvbGRBbmdsZTogdGhyZXNob2xkQW5nbGVcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRocmVzaG9sZEFuZ2xlID0gKCB0aHJlc2hvbGRBbmdsZSAhPT0gdW5kZWZpbmVkICkgPyB0aHJlc2hvbGRBbmdsZSA6IDE7XFxuXFxuXFx0XFx0Ly8gYnVmZmVyXFxuXFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW107XFxuXFxuXFx0XFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xcblxcblxcdFxcdHZhciB0aHJlc2hvbGREb3QgPSBNYXRoLmNvcyggX01hdGguREVHMlJBRCAqIHRocmVzaG9sZEFuZ2xlICk7XFxuXFx0XFx0dmFyIGVkZ2UgPSBbIDAsIDAgXSwgZWRnZXMgPSB7fSwgZWRnZTEsIGVkZ2UyO1xcblxcdFxcdHZhciBrZXksIGtleXMgPSBbICdhJywgJ2InLCAnYycgXTtcXG5cXG5cXHRcXHQvLyBwcmVwYXJlIHNvdXJjZSBnZW9tZXRyeVxcblxcblxcdFxcdHZhciBnZW9tZXRyeTI7XFxuXFxuXFx0XFx0aWYgKCBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdGdlb21ldHJ5MiA9IG5ldyBHZW9tZXRyeSgpO1xcblxcdFxcdFxcdGdlb21ldHJ5Mi5mcm9tQnVmZmVyR2VvbWV0cnkoIGdlb21ldHJ5ICk7XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRnZW9tZXRyeTIgPSBnZW9tZXRyeS5jbG9uZSgpO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRnZW9tZXRyeTIubWVyZ2VWZXJ0aWNlcygpO1xcblxcdFxcdGdlb21ldHJ5Mi5jb21wdXRlRmFjZU5vcm1hbHMoKTtcXG5cXG5cXHRcXHR2YXIgc291cmNlVmVydGljZXMgPSBnZW9tZXRyeTIudmVydGljZXM7XFxuXFx0XFx0dmFyIGZhY2VzID0gZ2VvbWV0cnkyLmZhY2VzO1xcblxcblxcdFxcdC8vIG5vdyBjcmVhdGUgYSBkYXRhIHN0cnVjdHVyZSB3aGVyZSBlYWNoIGVudHJ5IHJlcHJlc2VudHMgYW4gZWRnZSB3aXRoIGl0cyBhZGpvaW5pbmcgZmFjZXNcXG5cXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBmYWNlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdHZhciBmYWNlID0gZmFjZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDA7IGogPCAzOyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdGVkZ2UxID0gZmFjZVsga2V5c1sgaiBdIF07XFxuXFx0XFx0XFx0XFx0ZWRnZTIgPSBmYWNlWyBrZXlzWyAoIGogKyAxICkgJSAzIF0gXTtcXG5cXHRcXHRcXHRcXHRlZGdlWyAwIF0gPSBNYXRoLm1pbiggZWRnZTEsIGVkZ2UyICk7XFxuXFx0XFx0XFx0XFx0ZWRnZVsgMSBdID0gTWF0aC5tYXgoIGVkZ2UxLCBlZGdlMiApO1xcblxcblxcdFxcdFxcdFxcdGtleSA9IGVkZ2VbIDAgXSArICcsJyArIGVkZ2VbIDEgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGVkZ2VzWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGVkZ2VzWyBrZXkgXSA9IHsgaW5kZXgxOiBlZGdlWyAwIF0sIGluZGV4MjogZWRnZVsgMSBdLCBmYWNlMTogaSwgZmFjZTI6IHVuZGVmaW5lZCB9O1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZWRnZXNbIGtleSBdLmZhY2UyID0gaTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBnZW5lcmF0ZSB2ZXJ0aWNlc1xcblxcblxcdFxcdGZvciAoIGtleSBpbiBlZGdlcyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZSA9IGVkZ2VzWyBrZXkgXTtcXG5cXG5cXHRcXHRcXHQvLyBhbiBlZGdlIGlzIG9ubHkgcmVuZGVyZWQgaWYgdGhlIGFuZ2xlIChpbiBkZWdyZWVzKSBiZXR3ZWVuIHRoZSBmYWNlIG5vcm1hbHMgb2YgdGhlIGFkam9pbmluZyBmYWNlcyBleGNlZWRzIHRoaXMgdmFsdWUuIGRlZmF1bHQgPSAxIGRlZ3JlZS5cXG5cXG5cXHRcXHRcXHRpZiAoIGUuZmFjZTIgPT09IHVuZGVmaW5lZCB8fCBmYWNlc1sgZS5mYWNlMSBdLm5vcm1hbC5kb3QoIGZhY2VzWyBlLmZhY2UyIF0ubm9ybWFsICkgPD0gdGhyZXNob2xkRG90ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB2ZXJ0ZXggPSBzb3VyY2VWZXJ0aWNlc1sgZS5pbmRleDEgXTtcXG5cXHRcXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XFxuXFxuXFx0XFx0XFx0XFx0dmVydGV4ID0gc291cmNlVmVydGljZXNbIGUuaW5kZXgyIF07XFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggdmVydGV4LngsIHZlcnRleC55LCB2ZXJ0ZXgueiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gYnVpbGQgZ2VvbWV0cnlcXG5cXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcXG5cXG5cXHR9XFxuXFxuXFx0RWRnZXNHZW9tZXRyeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRFZGdlc0dlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEVkZ2VzR2VvbWV0cnk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqL1xcblxcblxcdC8vIEN5bGluZGVyR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBDeWxpbmRlckdlb21ldHJ5KCByYWRpdXNUb3AsIHJhZGl1c0JvdHRvbSwgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XFxuXFxuXFx0XFx0R2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdDeWxpbmRlckdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0cmFkaXVzVG9wOiByYWRpdXNUb3AsXFxuXFx0XFx0XFx0cmFkaXVzQm90dG9tOiByYWRpdXNCb3R0b20sXFxuXFx0XFx0XFx0aGVpZ2h0OiBoZWlnaHQsXFxuXFx0XFx0XFx0cmFkaWFsU2VnbWVudHM6IHJhZGlhbFNlZ21lbnRzLFxcblxcdFxcdFxcdGhlaWdodFNlZ21lbnRzOiBoZWlnaHRTZWdtZW50cyxcXG5cXHRcXHRcXHRvcGVuRW5kZWQ6IG9wZW5FbmRlZCxcXG5cXHRcXHRcXHR0aGV0YVN0YXJ0OiB0aGV0YVN0YXJ0LFxcblxcdFxcdFxcdHRoZXRhTGVuZ3RoOiB0aGV0YUxlbmd0aFxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5mcm9tQnVmZmVyR2VvbWV0cnkoIG5ldyBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5KCByYWRpdXNUb3AsIHJhZGl1c0JvdHRvbSwgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSApO1xcblxcdFxcdHRoaXMubWVyZ2VWZXJ0aWNlcygpO1xcblxcblxcdH1cXG5cXG5cXHRDeWxpbmRlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdEN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3lsaW5kZXJHZW9tZXRyeTtcXG5cXG5cXHQvLyBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSggcmFkaXVzVG9wLCByYWRpdXNCb3R0b20sIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xcblxcblxcdFxcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHJhZGl1c1RvcDogcmFkaXVzVG9wLFxcblxcdFxcdFxcdHJhZGl1c0JvdHRvbTogcmFkaXVzQm90dG9tLFxcblxcdFxcdFxcdGhlaWdodDogaGVpZ2h0LFxcblxcdFxcdFxcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcXG5cXHRcXHRcXHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXFxuXFx0XFx0XFx0b3BlbkVuZGVkOiBvcGVuRW5kZWQsXFxuXFx0XFx0XFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcXG5cXHRcXHRcXHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcXG5cXHRcXHR9O1xcblxcblxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxuXFxuXFx0XFx0cmFkaXVzVG9wID0gcmFkaXVzVG9wICE9PSB1bmRlZmluZWQgPyByYWRpdXNUb3AgOiAxO1xcblxcdFxcdHJhZGl1c0JvdHRvbSA9IHJhZGl1c0JvdHRvbSAhPT0gdW5kZWZpbmVkID8gcmFkaXVzQm90dG9tIDogMTtcXG5cXHRcXHRoZWlnaHQgPSBoZWlnaHQgfHwgMTtcXG5cXG5cXHRcXHRyYWRpYWxTZWdtZW50cyA9IE1hdGguZmxvb3IoIHJhZGlhbFNlZ21lbnRzICkgfHwgODtcXG5cXHRcXHRoZWlnaHRTZWdtZW50cyA9IE1hdGguZmxvb3IoIGhlaWdodFNlZ21lbnRzICkgfHwgMTtcXG5cXG5cXHRcXHRvcGVuRW5kZWQgPSBvcGVuRW5kZWQgIT09IHVuZGVmaW5lZCA/IG9wZW5FbmRlZCA6IGZhbHNlO1xcblxcdFxcdHRoZXRhU3RhcnQgPSB0aGV0YVN0YXJ0ICE9PSB1bmRlZmluZWQgPyB0aGV0YVN0YXJ0IDogMC4wO1xcblxcdFxcdHRoZXRhTGVuZ3RoID0gdGhldGFMZW5ndGggIT09IHVuZGVmaW5lZCA/IHRoZXRhTGVuZ3RoIDogTWF0aC5QSSAqIDI7XFxuXFxuXFx0XFx0Ly8gYnVmZmVyc1xcblxcblxcdFxcdHZhciBpbmRpY2VzID0gW107XFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW107XFxuXFx0XFx0dmFyIG5vcm1hbHMgPSBbXTtcXG5cXHRcXHR2YXIgdXZzID0gW107XFxuXFxuXFx0XFx0Ly8gaGVscGVyIHZhcmlhYmxlc1xcblxcblxcdFxcdHZhciBpbmRleCA9IDA7XFxuXFx0XFx0dmFyIGluZGV4QXJyYXkgPSBbXTtcXG5cXHRcXHR2YXIgaGFsZkhlaWdodCA9IGhlaWdodCAvIDI7XFxuXFx0XFx0dmFyIGdyb3VwU3RhcnQgPSAwO1xcblxcblxcdFxcdC8vIGdlbmVyYXRlIGdlb21ldHJ5XFxuXFxuXFx0XFx0Z2VuZXJhdGVUb3JzbygpO1xcblxcblxcdFxcdGlmICggb3BlbkVuZGVkID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHJhZGl1c1RvcCA+IDAgKSBnZW5lcmF0ZUNhcCggdHJ1ZSApO1xcblxcdFxcdFxcdGlmICggcmFkaXVzQm90dG9tID4gMCApIGdlbmVyYXRlQ2FwKCBmYWxzZSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBidWlsZCBnZW9tZXRyeVxcblxcblxcdFxcdHRoaXMuc2V0SW5kZXgoIGluZGljZXMgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ25vcm1hbCcsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBub3JtYWxzLCAzICkgKTtcXG5cXHRcXHR0aGlzLmFkZEF0dHJpYnV0ZSggJ3V2JywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHV2cywgMiApICk7XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZ2VuZXJhdGVUb3JzbygpIHtcXG5cXG5cXHRcXHRcXHR2YXIgeCwgeTtcXG5cXHRcXHRcXHR2YXIgbm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHR2YXIgZ3JvdXBDb3VudCA9IDA7XFxuXFxuXFx0XFx0XFx0Ly8gdGhpcyB3aWxsIGJlIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBub3JtYWxcXG5cXHRcXHRcXHR2YXIgc2xvcGUgPSAoIHJhZGl1c0JvdHRvbSAtIHJhZGl1c1RvcCApIC8gaGVpZ2h0O1xcblxcblxcdFxcdFxcdC8vIGdlbmVyYXRlIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcXG5cXG5cXHRcXHRcXHRmb3IgKCB5ID0gMDsgeSA8PSBoZWlnaHRTZWdtZW50czsgeSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgaW5kZXhSb3cgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdiA9IHkgLyBoZWlnaHRTZWdtZW50cztcXG5cXG5cXHRcXHRcXHRcXHQvLyBjYWxjdWxhdGUgdGhlIHJhZGl1cyBvZiB0aGUgY3VycmVudCByb3dcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcmFkaXVzID0gdiAqICggcmFkaXVzQm90dG9tIC0gcmFkaXVzVG9wICkgKyByYWRpdXNUb3A7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggeCA9IDA7IHggPD0gcmFkaWFsU2VnbWVudHM7IHggKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHUgPSB4IC8gcmFkaWFsU2VnbWVudHM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHRoZXRhID0gdSAqIHRoZXRhTGVuZ3RoICsgdGhldGFTdGFydDtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgc2luVGhldGEgPSBNYXRoLnNpbiggdGhldGEgKTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgY29zVGhldGEgPSBNYXRoLmNvcyggdGhldGEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyB2ZXJ0ZXhcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXgueCA9IHJhZGl1cyAqIHNpblRoZXRhO1xcblxcdFxcdFxcdFxcdFxcdHZlcnRleC55ID0gLSB2ICogaGVpZ2h0ICsgaGFsZkhlaWdodDtcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIGNvc1RoZXRhO1xcblxcdFxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBub3JtYWxcXG5cXG5cXHRcXHRcXHRcXHRcXHRub3JtYWwuc2V0KCBzaW5UaGV0YSwgc2xvcGUsIGNvc1RoZXRhICkubm9ybWFsaXplKCk7XFxuXFx0XFx0XFx0XFx0XFx0bm9ybWFscy5wdXNoKCBub3JtYWwueCwgbm9ybWFsLnksIG5vcm1hbC56ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdXZcXG5cXG5cXHRcXHRcXHRcXHRcXHR1dnMucHVzaCggdSwgMSAtIHYgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBzYXZlIGluZGV4IG9mIHZlcnRleCBpbiByZXNwZWN0aXZlIHJvd1xcblxcblxcdFxcdFxcdFxcdFxcdGluZGV4Um93LnB1c2goIGluZGV4ICsrICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIG5vdyBzYXZlIHZlcnRpY2VzIG9mIHRoZSByb3cgaW4gb3VyIGluZGV4IGFycmF5XFxuXFxuXFx0XFx0XFx0XFx0aW5kZXhBcnJheS5wdXNoKCBpbmRleFJvdyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBnZW5lcmF0ZSBpbmRpY2VzXFxuXFxuXFx0XFx0XFx0Zm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB5ID0gMDsgeSA8IGhlaWdodFNlZ21lbnRzOyB5ICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHdlIHVzZSB0aGUgaW5kZXggYXJyYXkgdG8gYWNjZXNzIHRoZSBjb3JyZWN0IGluZGljZXNcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgYSA9IGluZGV4QXJyYXlbIHkgXVsgeCBdO1xcblxcdFxcdFxcdFxcdFxcdHZhciBiID0gaW5kZXhBcnJheVsgeSArIDEgXVsgeCBdO1xcblxcdFxcdFxcdFxcdFxcdHZhciBjID0gaW5kZXhBcnJheVsgeSArIDEgXVsgeCArIDEgXTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgZCA9IGluZGV4QXJyYXlbIHkgXVsgeCArIDEgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBmYWNlc1xcblxcblxcdFxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYSwgYiwgZCApO1xcblxcdFxcdFxcdFxcdFxcdGluZGljZXMucHVzaCggYiwgYywgZCApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHVwZGF0ZSBncm91cCBjb3VudGVyXFxuXFxuXFx0XFx0XFx0XFx0XFx0Z3JvdXBDb3VudCArPSA2O1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcXG5cXG5cXHRcXHRcXHRzY29wZS5hZGRHcm91cCggZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgMCApO1xcblxcblxcdFxcdFxcdC8vIGNhbGN1bGF0ZSBuZXcgc3RhcnQgdmFsdWUgZm9yIGdyb3Vwc1xcblxcblxcdFxcdFxcdGdyb3VwU3RhcnQgKz0gZ3JvdXBDb3VudDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZnVuY3Rpb24gZ2VuZXJhdGVDYXAoIHRvcCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgeCwgY2VudGVySW5kZXhTdGFydCwgY2VudGVySW5kZXhFbmQ7XFxuXFxuXFx0XFx0XFx0dmFyIHV2ID0gbmV3IFZlY3RvcjIoKTtcXG5cXHRcXHRcXHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRcXHR2YXIgZ3JvdXBDb3VudCA9IDA7XFxuXFxuXFx0XFx0XFx0dmFyIHJhZGl1cyA9ICggdG9wID09PSB0cnVlICkgPyByYWRpdXNUb3AgOiByYWRpdXNCb3R0b207XFxuXFx0XFx0XFx0dmFyIHNpZ24gPSAoIHRvcCA9PT0gdHJ1ZSApID8gMSA6IC0gMTtcXG5cXG5cXHRcXHRcXHQvLyBzYXZlIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2VudGVyIHZlcnRleFxcblxcdFxcdFxcdGNlbnRlckluZGV4U3RhcnQgPSBpbmRleDtcXG5cXG5cXHRcXHRcXHQvLyBmaXJzdCB3ZSBnZW5lcmF0ZSB0aGUgY2VudGVyIHZlcnRleCBkYXRhIG9mIHRoZSBjYXAuXFxuXFx0XFx0XFx0Ly8gYmVjYXVzZSB0aGUgZ2VvbWV0cnkgbmVlZHMgb25lIHNldCBvZiB1dnMgcGVyIGZhY2UsXFxuXFx0XFx0XFx0Ly8gd2UgbXVzdCBnZW5lcmF0ZSBhIGNlbnRlciB2ZXJ0ZXggcGVyIGZhY2Uvc2VnbWVudFxcblxcblxcdFxcdFxcdGZvciAoIHggPSAxOyB4IDw9IHJhZGlhbFNlZ21lbnRzOyB4ICsrICkge1xcblxcblxcdFxcdFxcdFxcdC8vIHZlcnRleFxcblxcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIDAsIGhhbGZIZWlnaHQgKiBzaWduLCAwICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbm9ybWFsXFxuXFxuXFx0XFx0XFx0XFx0bm9ybWFscy5wdXNoKCAwLCBzaWduLCAwICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gdXZcXG5cXG5cXHRcXHRcXHRcXHR1dnMucHVzaCggMC41LCAwLjUgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpbmNyZWFzZSBpbmRleFxcblxcblxcdFxcdFxcdFxcdGluZGV4ICsrO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBzYXZlIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBjZW50ZXIgdmVydGV4XFxuXFxuXFx0XFx0XFx0Y2VudGVySW5kZXhFbmQgPSBpbmRleDtcXG5cXG5cXHRcXHRcXHQvLyBub3cgd2UgZ2VuZXJhdGUgdGhlIHN1cnJvdW5kaW5nIHZlcnRpY2VzLCBub3JtYWxzIGFuZCB1dnNcXG5cXG5cXHRcXHRcXHRmb3IgKCB4ID0gMDsgeCA8PSByYWRpYWxTZWdtZW50czsgeCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdSA9IHggLyByYWRpYWxTZWdtZW50cztcXG5cXHRcXHRcXHRcXHR2YXIgdGhldGEgPSB1ICogdGhldGFMZW5ndGggKyB0aGV0YVN0YXJ0O1xcblxcblxcdFxcdFxcdFxcdHZhciBjb3NUaGV0YSA9IE1hdGguY29zKCB0aGV0YSApO1xcblxcdFxcdFxcdFxcdHZhciBzaW5UaGV0YSA9IE1hdGguc2luKCB0aGV0YSApO1xcblxcblxcdFxcdFxcdFxcdC8vIHZlcnRleFxcblxcblxcdFxcdFxcdFxcdHZlcnRleC54ID0gcmFkaXVzICogc2luVGhldGE7XFxuXFx0XFx0XFx0XFx0dmVydGV4LnkgPSBoYWxmSGVpZ2h0ICogc2lnbjtcXG5cXHRcXHRcXHRcXHR2ZXJ0ZXgueiA9IHJhZGl1cyAqIGNvc1RoZXRhO1xcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIHZlcnRleC54LCB2ZXJ0ZXgueSwgdmVydGV4LnogKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBub3JtYWxcXG5cXG5cXHRcXHRcXHRcXHRub3JtYWxzLnB1c2goIDAsIHNpZ24sIDAgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyB1dlxcblxcblxcdFxcdFxcdFxcdHV2LnggPSAoIGNvc1RoZXRhICogMC41ICkgKyAwLjU7XFxuXFx0XFx0XFx0XFx0dXYueSA9ICggc2luVGhldGEgKiAwLjUgKiBzaWduICkgKyAwLjU7XFxuXFx0XFx0XFx0XFx0dXZzLnB1c2goIHV2LngsIHV2LnkgKTtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpbmNyZWFzZSBpbmRleFxcblxcblxcdFxcdFxcdFxcdGluZGV4ICsrO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBnZW5lcmF0ZSBpbmRpY2VzXFxuXFxuXFx0XFx0XFx0Zm9yICggeCA9IDA7IHggPCByYWRpYWxTZWdtZW50czsgeCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYyA9IGNlbnRlckluZGV4U3RhcnQgKyB4O1xcblxcdFxcdFxcdFxcdHZhciBpID0gY2VudGVySW5kZXhFbmQgKyB4O1xcblxcblxcdFxcdFxcdFxcdGlmICggdG9wID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGZhY2UgdG9wXFxuXFxuXFx0XFx0XFx0XFx0XFx0aW5kaWNlcy5wdXNoKCBpLCBpICsgMSwgYyApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZmFjZSBib3R0b21cXG5cXG5cXHRcXHRcXHRcXHRcXHRpbmRpY2VzLnB1c2goIGkgKyAxLCBpLCBjICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGdyb3VwQ291bnQgKz0gMztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gYWRkIGEgZ3JvdXAgdG8gdGhlIGdlb21ldHJ5LiB0aGlzIHdpbGwgZW5zdXJlIG11bHRpIG1hdGVyaWFsIHN1cHBvcnRcXG5cXG5cXHRcXHRcXHRzY29wZS5hZGRHcm91cCggZ3JvdXBTdGFydCwgZ3JvdXBDb3VudCwgdG9wID09PSB0cnVlID8gMSA6IDIgKTtcXG5cXG5cXHRcXHRcXHQvLyBjYWxjdWxhdGUgbmV3IHN0YXJ0IHZhbHVlIGZvciBncm91cHNcXG5cXG5cXHRcXHRcXHRncm91cFN0YXJ0ICs9IGdyb3VwQ291bnQ7XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHRDeWxpbmRlckJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdEN5bGluZGVyQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGFiZWxuYXRpb24gLyBodHRwOi8vZ2l0aHViLmNvbS9hYmVsbmF0aW9uXFxuXFx0ICovXFxuXFxuXFx0Ly8gQ29uZUdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gQ29uZUdlb21ldHJ5KCByYWRpdXMsIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xcblxcblxcdFxcdEN5bGluZGVyR2VvbWV0cnkuY2FsbCggdGhpcywgMCwgcmFkaXVzLCBoZWlnaHQsIHJhZGlhbFNlZ21lbnRzLCBoZWlnaHRTZWdtZW50cywgb3BlbkVuZGVkLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdDb25lR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXG5cXHRcXHRcXHRoZWlnaHQ6IGhlaWdodCxcXG5cXHRcXHRcXHRyYWRpYWxTZWdtZW50czogcmFkaWFsU2VnbWVudHMsXFxuXFx0XFx0XFx0aGVpZ2h0U2VnbWVudHM6IGhlaWdodFNlZ21lbnRzLFxcblxcdFxcdFxcdG9wZW5FbmRlZDogb3BlbkVuZGVkLFxcblxcdFxcdFxcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXFxuXFx0XFx0XFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXFxuXFx0XFx0fTtcXG5cXG5cXHR9XFxuXFxuXFx0Q29uZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN5bGluZGVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0Q29uZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbmVHZW9tZXRyeTtcXG5cXG5cXHQvLyBDb25lQnVmZmVyR2VvbWV0cnlcXG5cXG5cXHRmdW5jdGlvbiBDb25lQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgaGVpZ2h0LCByYWRpYWxTZWdtZW50cywgaGVpZ2h0U2VnbWVudHMsIG9wZW5FbmRlZCwgdGhldGFTdGFydCwgdGhldGFMZW5ndGggKSB7XFxuXFxuXFx0XFx0Q3lsaW5kZXJCdWZmZXJHZW9tZXRyeS5jYWxsKCB0aGlzLCAwLCByYWRpdXMsIGhlaWdodCwgcmFkaWFsU2VnbWVudHMsIGhlaWdodFNlZ21lbnRzLCBvcGVuRW5kZWQsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0NvbmVCdWZmZXJHZW9tZXRyeSc7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJzID0ge1xcblxcdFxcdFxcdHJhZGl1czogcmFkaXVzLFxcblxcdFxcdFxcdGhlaWdodDogaGVpZ2h0LFxcblxcdFxcdFxcdHJhZGlhbFNlZ21lbnRzOiByYWRpYWxTZWdtZW50cyxcXG5cXHRcXHRcXHRoZWlnaHRTZWdtZW50czogaGVpZ2h0U2VnbWVudHMsXFxuXFx0XFx0XFx0b3BlbkVuZGVkOiBvcGVuRW5kZWQsXFxuXFx0XFx0XFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcXG5cXHRcXHRcXHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHRDb25lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUgKTtcXG5cXHRDb25lQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uZUJ1ZmZlckdlb21ldHJ5O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxuXFx0ICogQGF1dGhvciBodWdoZXNcXG5cXHQgKi9cXG5cXG5cXHQvLyBDaXJjbGVHZW9tZXRyeVxcblxcblxcdGZ1bmN0aW9uIENpcmNsZUdlb21ldHJ5KCByYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApIHtcXG5cXG5cXHRcXHRHZW9tZXRyeS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0NpcmNsZUdlb21ldHJ5JztcXG5cXG5cXHRcXHR0aGlzLnBhcmFtZXRlcnMgPSB7XFxuXFx0XFx0XFx0cmFkaXVzOiByYWRpdXMsXFxuXFx0XFx0XFx0c2VnbWVudHM6IHNlZ21lbnRzLFxcblxcdFxcdFxcdHRoZXRhU3RhcnQ6IHRoZXRhU3RhcnQsXFxuXFx0XFx0XFx0dGhldGFMZW5ndGg6IHRoZXRhTGVuZ3RoXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aGlzLmZyb21CdWZmZXJHZW9tZXRyeSggbmV3IENpcmNsZUJ1ZmZlckdlb21ldHJ5KCByYWRpdXMsIHNlZ21lbnRzLCB0aGV0YVN0YXJ0LCB0aGV0YUxlbmd0aCApICk7XFxuXFx0XFx0dGhpcy5tZXJnZVZlcnRpY2VzKCk7XFxuXFxuXFx0fVxcblxcblxcdENpcmNsZUdlb21ldHJ5LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5LnByb3RvdHlwZSApO1xcblxcdENpcmNsZUdlb21ldHJ5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENpcmNsZUdlb21ldHJ5O1xcblxcblxcdC8vIENpcmNsZUJ1ZmZlckdlb21ldHJ5XFxuXFxuXFx0ZnVuY3Rpb24gQ2lyY2xlQnVmZmVyR2VvbWV0cnkoIHJhZGl1cywgc2VnbWVudHMsIHRoZXRhU3RhcnQsIHRoZXRhTGVuZ3RoICkge1xcblxcblxcdFxcdEJ1ZmZlckdlb21ldHJ5LmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnQ2lyY2xlQnVmZmVyR2VvbWV0cnknO1xcblxcblxcdFxcdHRoaXMucGFyYW1ldGVycyA9IHtcXG5cXHRcXHRcXHRyYWRpdXM6IHJhZGl1cyxcXG5cXHRcXHRcXHRzZWdtZW50czogc2VnbWVudHMsXFxuXFx0XFx0XFx0dGhldGFTdGFydDogdGhldGFTdGFydCxcXG5cXHRcXHRcXHR0aGV0YUxlbmd0aDogdGhldGFMZW5ndGhcXG5cXHRcXHR9O1xcblxcblxcdFxcdHJhZGl1cyA9IHJhZGl1cyB8fCAxO1xcblxcdFxcdHNlZ21lbnRzID0gc2VnbWVudHMgIT09IHVuZGVmaW5lZCA/IE1hdGgubWF4KCAzLCBzZWdtZW50cyApIDogODtcXG5cXG5cXHRcXHR0aGV0YVN0YXJ0ID0gdGhldGFTdGFydCAhPT0gdW5kZWZpbmVkID8gdGhldGFTdGFydCA6IDA7XFxuXFx0XFx0dGhldGFMZW5ndGggPSB0aGV0YUxlbmd0aCAhPT0gdW5kZWZpbmVkID8gdGhldGFMZW5ndGggOiBNYXRoLlBJICogMjtcXG5cXG5cXHRcXHQvLyBidWZmZXJzXFxuXFxuXFx0XFx0dmFyIGluZGljZXMgPSBbXTtcXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXTtcXG5cXHRcXHR2YXIgbm9ybWFscyA9IFtdO1xcblxcdFxcdHZhciB1dnMgPSBbXTtcXG5cXG5cXHRcXHQvLyBoZWxwZXIgdmFyaWFibGVzXFxuXFxuXFx0XFx0dmFyIGksIHM7XFxuXFx0XFx0dmFyIHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dmFyIHV2ID0gbmV3IFZlY3RvcjIoKTtcXG5cXG5cXHRcXHQvLyBjZW50ZXIgcG9pbnRcXG5cXG5cXHRcXHR2ZXJ0aWNlcy5wdXNoKCAwLCAwLCAwICk7XFxuXFx0XFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XFxuXFx0XFx0dXZzLnB1c2goIDAuNSwgMC41ICk7XFxuXFxuXFx0XFx0Zm9yICggcyA9IDAsIGkgPSAzOyBzIDw9IHNlZ21lbnRzOyBzICsrLCBpICs9IDMgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHNlZ21lbnQgPSB0aGV0YVN0YXJ0ICsgcyAvIHNlZ21lbnRzICogdGhldGFMZW5ndGg7XFxuXFxuXFx0XFx0XFx0Ly8gdmVydGV4XFxuXFxuXFx0XFx0XFx0dmVydGV4LnggPSByYWRpdXMgKiBNYXRoLmNvcyggc2VnbWVudCApO1xcblxcdFxcdFxcdHZlcnRleC55ID0gcmFkaXVzICogTWF0aC5zaW4oIHNlZ21lbnQgKTtcXG5cXG5cXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB2ZXJ0ZXgueCwgdmVydGV4LnksIHZlcnRleC56ICk7XFxuXFxuXFx0XFx0XFx0Ly8gbm9ybWFsXFxuXFxuXFx0XFx0XFx0bm9ybWFscy5wdXNoKCAwLCAwLCAxICk7XFxuXFxuXFx0XFx0XFx0Ly8gdXZzXFxuXFxuXFx0XFx0XFx0dXYueCA9ICggdmVydGljZXNbIGkgXSAvIHJhZGl1cyArIDEgKSAvIDI7XFxuXFx0XFx0XFx0dXYueSA9ICggdmVydGljZXNbIGkgKyAxIF0gLyByYWRpdXMgKyAxICkgLyAyO1xcblxcblxcdFxcdFxcdHV2cy5wdXNoKCB1di54LCB1di55ICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGluZGljZXNcXG5cXG5cXHRcXHRmb3IgKCBpID0gMTsgaSA8PSBzZWdtZW50czsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRpbmRpY2VzLnB1c2goIGksIGkgKyAxLCAwICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGJ1aWxkIGdlb21ldHJ5XFxuXFxuXFx0XFx0dGhpcy5zZXRJbmRleCggaW5kaWNlcyApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdmVydGljZXMsIDMgKSApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAnbm9ybWFsJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbHMsIDMgKSApO1xcblxcdFxcdHRoaXMuYWRkQXR0cmlidXRlKCAndXYnLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggdXZzLCAyICkgKTtcXG5cXG5cXHR9XFxuXFxuXFx0Q2lyY2xlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICk7XFxuXFx0Q2lyY2xlQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2lyY2xlQnVmZmVyR2VvbWV0cnk7XFxuXFxuXFxuXFxuXFx0dmFyIEdlb21ldHJpZXMgPSBPYmplY3QuZnJlZXplKHtcXG5cXHRcXHRXaXJlZnJhbWVHZW9tZXRyeTogV2lyZWZyYW1lR2VvbWV0cnksXFxuXFx0XFx0UGFyYW1ldHJpY0dlb21ldHJ5OiBQYXJhbWV0cmljR2VvbWV0cnksXFxuXFx0XFx0UGFyYW1ldHJpY0J1ZmZlckdlb21ldHJ5OiBQYXJhbWV0cmljQnVmZmVyR2VvbWV0cnksXFxuXFx0XFx0VGV0cmFoZWRyb25HZW9tZXRyeTogVGV0cmFoZWRyb25HZW9tZXRyeSxcXG5cXHRcXHRUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5OiBUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LFxcblxcdFxcdE9jdGFoZWRyb25HZW9tZXRyeTogT2N0YWhlZHJvbkdlb21ldHJ5LFxcblxcdFxcdE9jdGFoZWRyb25CdWZmZXJHZW9tZXRyeTogT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5LFxcblxcdFxcdEljb3NhaGVkcm9uR2VvbWV0cnk6IEljb3NhaGVkcm9uR2VvbWV0cnksXFxuXFx0XFx0SWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeTogSWNvc2FoZWRyb25CdWZmZXJHZW9tZXRyeSxcXG5cXHRcXHREb2RlY2FoZWRyb25HZW9tZXRyeTogRG9kZWNhaGVkcm9uR2VvbWV0cnksXFxuXFx0XFx0RG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnk6IERvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5LFxcblxcdFxcdFBvbHloZWRyb25HZW9tZXRyeTogUG9seWhlZHJvbkdlb21ldHJ5LFxcblxcdFxcdFBvbHloZWRyb25CdWZmZXJHZW9tZXRyeTogUG9seWhlZHJvbkJ1ZmZlckdlb21ldHJ5LFxcblxcdFxcdFR1YmVHZW9tZXRyeTogVHViZUdlb21ldHJ5LFxcblxcdFxcdFR1YmVCdWZmZXJHZW9tZXRyeTogVHViZUJ1ZmZlckdlb21ldHJ5LFxcblxcdFxcdFRvcnVzS25vdEdlb21ldHJ5OiBUb3J1c0tub3RHZW9tZXRyeSxcXG5cXHRcXHRUb3J1c0tub3RCdWZmZXJHZW9tZXRyeTogVG9ydXNLbm90QnVmZmVyR2VvbWV0cnksXFxuXFx0XFx0VG9ydXNHZW9tZXRyeTogVG9ydXNHZW9tZXRyeSxcXG5cXHRcXHRUb3J1c0J1ZmZlckdlb21ldHJ5OiBUb3J1c0J1ZmZlckdlb21ldHJ5LFxcblxcdFxcdFRleHRHZW9tZXRyeTogVGV4dEdlb21ldHJ5LFxcblxcdFxcdFRleHRCdWZmZXJHZW9tZXRyeTogVGV4dEJ1ZmZlckdlb21ldHJ5LFxcblxcdFxcdFNwaGVyZUdlb21ldHJ5OiBTcGhlcmVHZW9tZXRyeSxcXG5cXHRcXHRTcGhlcmVCdWZmZXJHZW9tZXRyeTogU3BoZXJlQnVmZmVyR2VvbWV0cnksXFxuXFx0XFx0UmluZ0dlb21ldHJ5OiBSaW5nR2VvbWV0cnksXFxuXFx0XFx0UmluZ0J1ZmZlckdlb21ldHJ5OiBSaW5nQnVmZmVyR2VvbWV0cnksXFxuXFx0XFx0UGxhbmVHZW9tZXRyeTogUGxhbmVHZW9tZXRyeSxcXG5cXHRcXHRQbGFuZUJ1ZmZlckdlb21ldHJ5OiBQbGFuZUJ1ZmZlckdlb21ldHJ5LFxcblxcdFxcdExhdGhlR2VvbWV0cnk6IExhdGhlR2VvbWV0cnksXFxuXFx0XFx0TGF0aGVCdWZmZXJHZW9tZXRyeTogTGF0aGVCdWZmZXJHZW9tZXRyeSxcXG5cXHRcXHRTaGFwZUdlb21ldHJ5OiBTaGFwZUdlb21ldHJ5LFxcblxcdFxcdFNoYXBlQnVmZmVyR2VvbWV0cnk6IFNoYXBlQnVmZmVyR2VvbWV0cnksXFxuXFx0XFx0RXh0cnVkZUdlb21ldHJ5OiBFeHRydWRlR2VvbWV0cnksXFxuXFx0XFx0RXh0cnVkZUJ1ZmZlckdlb21ldHJ5OiBFeHRydWRlQnVmZmVyR2VvbWV0cnksXFxuXFx0XFx0RWRnZXNHZW9tZXRyeTogRWRnZXNHZW9tZXRyeSxcXG5cXHRcXHRDb25lR2VvbWV0cnk6IENvbmVHZW9tZXRyeSxcXG5cXHRcXHRDb25lQnVmZmVyR2VvbWV0cnk6IENvbmVCdWZmZXJHZW9tZXRyeSxcXG5cXHRcXHRDeWxpbmRlckdlb21ldHJ5OiBDeWxpbmRlckdlb21ldHJ5LFxcblxcdFxcdEN5bGluZGVyQnVmZmVyR2VvbWV0cnk6IEN5bGluZGVyQnVmZmVyR2VvbWV0cnksXFxuXFx0XFx0Q2lyY2xlR2VvbWV0cnk6IENpcmNsZUdlb21ldHJ5LFxcblxcdFxcdENpcmNsZUJ1ZmZlckdlb21ldHJ5OiBDaXJjbGVCdWZmZXJHZW9tZXRyeSxcXG5cXHRcXHRCb3hHZW9tZXRyeTogQm94R2VvbWV0cnksXFxuXFx0XFx0Qm94QnVmZmVyR2VvbWV0cnk6IEJveEJ1ZmZlckdlb21ldHJ5XFxuXFx0fSk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKlxcblxcdCAqIHBhcmFtZXRlcnMgPSB7XFxuXFx0ICogIGNvbG9yOiA8VEhSRUUuQ29sb3I+LFxcblxcdCAqICBvcGFjaXR5OiA8ZmxvYXQ+XFxuXFx0ICogfVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFNoYWRvd01hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnU2hhZG93TWF0ZXJpYWwnO1xcblxcblxcdFxcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4MDAwMDAwICk7XFxuXFx0XFx0dGhpcy5vcGFjaXR5ID0gMS4wO1xcblxcblxcdFxcdHRoaXMubGlnaHRzID0gdHJ1ZTtcXG5cXHRcXHR0aGlzLnRyYW5zcGFyZW50ID0gdHJ1ZTtcXG5cXG5cXHRcXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xcblxcblxcdH1cXG5cXG5cXHRTaGFkb3dNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcXG5cXHRTaGFkb3dNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTaGFkb3dNYXRlcmlhbDtcXG5cXG5cXHRTaGFkb3dNYXRlcmlhbC5wcm90b3R5cGUuaXNTaGFkb3dNYXRlcmlhbCA9IHRydWU7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBSYXdTaGFkZXJNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHRTaGFkZXJNYXRlcmlhbC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1Jhd1NoYWRlck1hdGVyaWFsJztcXG5cXG5cXHR9XFxuXFxuXFx0UmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggU2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlICk7XFxuXFx0UmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmF3U2hhZGVyTWF0ZXJpYWw7XFxuXFxuXFx0UmF3U2hhZGVyTWF0ZXJpYWwucHJvdG90eXBlLmlzUmF3U2hhZGVyTWF0ZXJpYWwgPSB0cnVlO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcblxcdCAqXFxuXFx0ICogcGFyYW1ldGVycyA9IHtcXG5cXHQgKiAgY29sb3I6IDxoZXg+LFxcblxcdCAqICByb3VnaG5lc3M6IDxmbG9hdD4sXFxuXFx0ICogIG1ldGFsbmVzczogPGZsb2F0PixcXG5cXHQgKiAgb3BhY2l0eTogPGZsb2F0PixcXG5cXHQgKlxcblxcdCAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICpcXG5cXHQgKiAgbGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XFxuXFx0ICpcXG5cXHQgKiAgYW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XFxuXFx0ICpcXG5cXHQgKiAgZW1pc3NpdmU6IDxoZXg+LFxcblxcdCAqICBlbWlzc2l2ZUludGVuc2l0eTogPGZsb2F0PlxcblxcdCAqICBlbWlzc2l2ZU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKlxcblxcdCAqICBidW1wTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqICBidW1wU2NhbGU6IDxmbG9hdD4sXFxuXFx0ICpcXG5cXHQgKiAgbm9ybWFsTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqICBub3JtYWxTY2FsZTogPFZlY3RvcjI+LFxcblxcdCAqXFxuXFx0ICogIGRpc3BsYWNlbWVudE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKiAgZGlzcGxhY2VtZW50U2NhbGU6IDxmbG9hdD4sXFxuXFx0ICogIGRpc3BsYWNlbWVudEJpYXM6IDxmbG9hdD4sXFxuXFx0ICpcXG5cXHQgKiAgcm91Z2huZXNzTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqXFxuXFx0ICogIG1ldGFsbmVzc01hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKlxcblxcdCAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKlxcblxcdCAqICBlbnZNYXA6IG5ldyBUSFJFRS5DdWJlVGV4dHVyZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXFxuXFx0ICogIGVudk1hcEludGVuc2l0eTogPGZsb2F0PlxcblxcdCAqXFxuXFx0ICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcXG5cXHQgKlxcblxcdCAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcXG5cXHQgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxcblxcdCAqXFxuXFx0ICogIHNraW5uaW5nOiA8Ym9vbD4sXFxuXFx0ICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxcblxcdCAqICBtb3JwaE5vcm1hbHM6IDxib29sPlxcblxcdCAqIH1cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBNZXNoU3RhbmRhcmRNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy5kZWZpbmVzID0geyAnU1RBTkRBUkQnOiAnJyB9O1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdNZXNoU3RhbmRhcmRNYXRlcmlhbCc7XFxuXFxuXFx0XFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxcblxcdFxcdHRoaXMucm91Z2huZXNzID0gMC41O1xcblxcdFxcdHRoaXMubWV0YWxuZXNzID0gMC41O1xcblxcblxcdFxcdHRoaXMubWFwID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcXG5cXHRcXHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xcblxcblxcdFxcdHRoaXMuYW9NYXAgPSBudWxsO1xcblxcdFxcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XFxuXFxuXFx0XFx0dGhpcy5lbWlzc2l2ZSA9IG5ldyBDb2xvciggMHgwMDAwMDAgKTtcXG5cXHRcXHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xcblxcdFxcdHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsO1xcblxcblxcdFxcdHRoaXMuYnVtcE1hcCA9IG51bGw7XFxuXFx0XFx0dGhpcy5idW1wU2NhbGUgPSAxO1xcblxcblxcdFxcdHRoaXMubm9ybWFsTWFwID0gbnVsbDtcXG5cXHRcXHR0aGlzLm5vcm1hbFNjYWxlID0gbmV3IFZlY3RvcjIoIDEsIDEgKTtcXG5cXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IG51bGw7XFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IDE7XFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRCaWFzID0gMDtcXG5cXG5cXHRcXHR0aGlzLnJvdWdobmVzc01hcCA9IG51bGw7XFxuXFxuXFx0XFx0dGhpcy5tZXRhbG5lc3NNYXAgPSBudWxsO1xcblxcblxcdFxcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xcblxcblxcdFxcdHRoaXMuZW52TWFwID0gbnVsbDtcXG5cXHRcXHR0aGlzLmVudk1hcEludGVuc2l0eSA9IDEuMDtcXG5cXG5cXHRcXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IDAuOTg7XFxuXFxuXFx0XFx0dGhpcy53aXJlZnJhbWUgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmV3aWR0aCA9IDE7XFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5lY2FwID0gJ3JvdW5kJztcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gJ3JvdW5kJztcXG5cXG5cXHRcXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XFxuXFxuXFx0fVxcblxcblxcdE1lc2hTdGFuZGFyZE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xcblxcdE1lc2hTdGFuZGFyZE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hTdGFuZGFyZE1hdGVyaWFsO1xcblxcblxcdE1lc2hTdGFuZGFyZE1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hTdGFuZGFyZE1hdGVyaWFsID0gdHJ1ZTtcXG5cXG5cXHRNZXNoU3RhbmRhcmRNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdHRoaXMuZGVmaW5lcyA9IHsgJ1NUQU5EQVJEJzogJycgfTtcXG5cXG5cXHRcXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xcblxcdFxcdHRoaXMucm91Z2huZXNzID0gc291cmNlLnJvdWdobmVzcztcXG5cXHRcXHR0aGlzLm1ldGFsbmVzcyA9IHNvdXJjZS5tZXRhbG5lc3M7XFxuXFxuXFx0XFx0dGhpcy5tYXAgPSBzb3VyY2UubWFwO1xcblxcblxcdFxcdHRoaXMubGlnaHRNYXAgPSBzb3VyY2UubGlnaHRNYXA7XFxuXFx0XFx0dGhpcy5saWdodE1hcEludGVuc2l0eSA9IHNvdXJjZS5saWdodE1hcEludGVuc2l0eTtcXG5cXG5cXHRcXHR0aGlzLmFvTWFwID0gc291cmNlLmFvTWFwO1xcblxcdFxcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSBzb3VyY2UuYW9NYXBJbnRlbnNpdHk7XFxuXFxuXFx0XFx0dGhpcy5lbWlzc2l2ZS5jb3B5KCBzb3VyY2UuZW1pc3NpdmUgKTtcXG5cXHRcXHR0aGlzLmVtaXNzaXZlTWFwID0gc291cmNlLmVtaXNzaXZlTWFwO1xcblxcdFxcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSBzb3VyY2UuZW1pc3NpdmVJbnRlbnNpdHk7XFxuXFxuXFx0XFx0dGhpcy5idW1wTWFwID0gc291cmNlLmJ1bXBNYXA7XFxuXFx0XFx0dGhpcy5idW1wU2NhbGUgPSBzb3VyY2UuYnVtcFNjYWxlO1xcblxcblxcdFxcdHRoaXMubm9ybWFsTWFwID0gc291cmNlLm5vcm1hbE1hcDtcXG5cXHRcXHR0aGlzLm5vcm1hbFNjYWxlLmNvcHkoIHNvdXJjZS5ub3JtYWxTY2FsZSApO1xcblxcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gc291cmNlLmRpc3BsYWNlbWVudE1hcDtcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gc291cmNlLmRpc3BsYWNlbWVudFNjYWxlO1xcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50QmlhcyA9IHNvdXJjZS5kaXNwbGFjZW1lbnRCaWFzO1xcblxcblxcdFxcdHRoaXMucm91Z2huZXNzTWFwID0gc291cmNlLnJvdWdobmVzc01hcDtcXG5cXG5cXHRcXHR0aGlzLm1ldGFsbmVzc01hcCA9IHNvdXJjZS5tZXRhbG5lc3NNYXA7XFxuXFxuXFx0XFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcXG5cXG5cXHRcXHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XFxuXFx0XFx0dGhpcy5lbnZNYXBJbnRlbnNpdHkgPSBzb3VyY2UuZW52TWFwSW50ZW5zaXR5O1xcblxcblxcdFxcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcXG5cXG5cXHRcXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XFxuXFxuXFx0XFx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcXG5cXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XFxuXFx0XFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxuXFx0ICpcXG5cXHQgKiBwYXJhbWV0ZXJzID0ge1xcblxcdCAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD5cXG5cXHQgKiB9XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gTWVzaFBoeXNpY2FsTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XFxuXFxuXFx0XFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWwuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMuZGVmaW5lcyA9IHsgJ1BIWVNJQ0FMJzogJycgfTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnTWVzaFBoeXNpY2FsTWF0ZXJpYWwnO1xcblxcblxcdFxcdHRoaXMucmVmbGVjdGl2aXR5ID0gMC41OyAvLyBtYXBzIHRvIEYwID0gMC4wNFxcblxcblxcdFxcdHRoaXMuY2xlYXJDb2F0ID0gMC4wO1xcblxcdFxcdHRoaXMuY2xlYXJDb2F0Um91Z2huZXNzID0gMC4wO1xcblxcblxcdFxcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XFxuXFxuXFx0fVxcblxcblxcdE1lc2hQaHlzaWNhbE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1lc2hTdGFuZGFyZE1hdGVyaWFsLnByb3RvdHlwZSApO1xcblxcdE1lc2hQaHlzaWNhbE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hQaHlzaWNhbE1hdGVyaWFsO1xcblxcblxcdE1lc2hQaHlzaWNhbE1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hQaHlzaWNhbE1hdGVyaWFsID0gdHJ1ZTtcXG5cXG5cXHRNZXNoUGh5c2ljYWxNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdE1lc2hTdGFuZGFyZE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdHRoaXMuZGVmaW5lcyA9IHsgJ1BIWVNJQ0FMJzogJycgfTtcXG5cXG5cXHRcXHR0aGlzLnJlZmxlY3Rpdml0eSA9IHNvdXJjZS5yZWZsZWN0aXZpdHk7XFxuXFxuXFx0XFx0dGhpcy5jbGVhckNvYXQgPSBzb3VyY2UuY2xlYXJDb2F0O1xcblxcdFxcdHRoaXMuY2xlYXJDb2F0Um91Z2huZXNzID0gc291cmNlLmNsZWFyQ29hdFJvdWdobmVzcztcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKlxcblxcdCAqIHBhcmFtZXRlcnMgPSB7XFxuXFx0ICogIGNvbG9yOiA8aGV4PixcXG5cXHQgKiAgc3BlY3VsYXI6IDxoZXg+LFxcblxcdCAqICBzaGluaW5lc3M6IDxmbG9hdD4sXFxuXFx0ICogIG9wYWNpdHk6IDxmbG9hdD4sXFxuXFx0ICpcXG5cXHQgKiAgbWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqXFxuXFx0ICogIGxpZ2h0TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqICBsaWdodE1hcEludGVuc2l0eTogPGZsb2F0PlxcblxcdCAqXFxuXFx0ICogIGFvTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqICBhb01hcEludGVuc2l0eTogPGZsb2F0PlxcblxcdCAqXFxuXFx0ICogIGVtaXNzaXZlOiA8aGV4PixcXG5cXHQgKiAgZW1pc3NpdmVJbnRlbnNpdHk6IDxmbG9hdD5cXG5cXHQgKiAgZW1pc3NpdmVNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICpcXG5cXHQgKiAgYnVtcE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKiAgYnVtcFNjYWxlOiA8ZmxvYXQ+LFxcblxcdCAqXFxuXFx0ICogIG5vcm1hbE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKiAgbm9ybWFsU2NhbGU6IDxWZWN0b3IyPixcXG5cXHQgKlxcblxcdCAqICBkaXNwbGFjZW1lbnRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICogIGRpc3BsYWNlbWVudFNjYWxlOiA8ZmxvYXQ+LFxcblxcdCAqICBkaXNwbGFjZW1lbnRCaWFzOiA8ZmxvYXQ+LFxcblxcdCAqXFxuXFx0ICogIHNwZWN1bGFyTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqXFxuXFx0ICogIGFscGhhTWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqXFxuXFx0ICogIGVudk1hcDogbmV3IFRIUkVFLlRleHR1cmVDdWJlKCBbcG9zeCwgbmVneCwgcG9zeSwgbmVneSwgcG9zeiwgbmVnel0gKSxcXG5cXHQgKiAgY29tYmluZTogVEhSRUUuTXVsdGlwbHksXFxuXFx0ICogIHJlZmxlY3Rpdml0eTogPGZsb2F0PixcXG5cXHQgKiAgcmVmcmFjdGlvblJhdGlvOiA8ZmxvYXQ+LFxcblxcdCAqXFxuXFx0ICogIHdpcmVmcmFtZTogPGJvb2xlYW4+LFxcblxcdCAqICB3aXJlZnJhbWVMaW5ld2lkdGg6IDxmbG9hdD4sXFxuXFx0ICpcXG5cXHQgKiAgc2tpbm5pbmc6IDxib29sPixcXG5cXHQgKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXFxuXFx0ICogIG1vcnBoTm9ybWFsczogPGJvb2w+XFxuXFx0ICogfVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIE1lc2hQaG9uZ01hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnTWVzaFBob25nTWF0ZXJpYWwnO1xcblxcblxcdFxcdHRoaXMuY29sb3IgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7IC8vIGRpZmZ1c2VcXG5cXHRcXHR0aGlzLnNwZWN1bGFyID0gbmV3IENvbG9yKCAweDExMTExMSApO1xcblxcdFxcdHRoaXMuc2hpbmluZXNzID0gMzA7XFxuXFxuXFx0XFx0dGhpcy5tYXAgPSBudWxsO1xcblxcblxcdFxcdHRoaXMubGlnaHRNYXAgPSBudWxsO1xcblxcdFxcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSAxLjA7XFxuXFxuXFx0XFx0dGhpcy5hb01hcCA9IG51bGw7XFxuXFx0XFx0dGhpcy5hb01hcEludGVuc2l0eSA9IDEuMDtcXG5cXG5cXHRcXHR0aGlzLmVtaXNzaXZlID0gbmV3IENvbG9yKCAweDAwMDAwMCApO1xcblxcdFxcdHRoaXMuZW1pc3NpdmVJbnRlbnNpdHkgPSAxLjA7XFxuXFx0XFx0dGhpcy5lbWlzc2l2ZU1hcCA9IG51bGw7XFxuXFxuXFx0XFx0dGhpcy5idW1wTWFwID0gbnVsbDtcXG5cXHRcXHR0aGlzLmJ1bXBTY2FsZSA9IDE7XFxuXFxuXFx0XFx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xcblxcdFxcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xcblxcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xcblxcblxcdFxcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xcblxcblxcdFxcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xcblxcblxcdFxcdHRoaXMuZW52TWFwID0gbnVsbDtcXG5cXHRcXHR0aGlzLmNvbWJpbmUgPSBNdWx0aXBseU9wZXJhdGlvbjtcXG5cXHRcXHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XFxuXFx0XFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xcblxcblxcdFxcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XFxuXFxuXFx0XFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xcblxcdFxcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xcblxcblxcdH1cXG5cXG5cXHRNZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcXG5cXHRNZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNZXNoUGhvbmdNYXRlcmlhbDtcXG5cXG5cXHRNZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoUGhvbmdNYXRlcmlhbCA9IHRydWU7XFxuXFxuXFx0TWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xcblxcdFxcdHRoaXMuc3BlY3VsYXIuY29weSggc291cmNlLnNwZWN1bGFyICk7XFxuXFx0XFx0dGhpcy5zaGluaW5lc3MgPSBzb3VyY2Uuc2hpbmluZXNzO1xcblxcblxcdFxcdHRoaXMubWFwID0gc291cmNlLm1hcDtcXG5cXG5cXHRcXHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xcblxcdFxcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XFxuXFxuXFx0XFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcXG5cXHRcXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xcblxcblxcdFxcdHRoaXMuZW1pc3NpdmUuY29weSggc291cmNlLmVtaXNzaXZlICk7XFxuXFx0XFx0dGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcXG5cXHRcXHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xcblxcblxcdFxcdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xcblxcdFxcdHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcXG5cXG5cXHRcXHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XFxuXFx0XFx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcXG5cXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcXG5cXG5cXHRcXHR0aGlzLnNwZWN1bGFyTWFwID0gc291cmNlLnNwZWN1bGFyTWFwO1xcblxcblxcdFxcdHRoaXMuYWxwaGFNYXAgPSBzb3VyY2UuYWxwaGFNYXA7XFxuXFxuXFx0XFx0dGhpcy5lbnZNYXAgPSBzb3VyY2UuZW52TWFwO1xcblxcdFxcdHRoaXMuY29tYmluZSA9IHNvdXJjZS5jb21iaW5lO1xcblxcdFxcdHRoaXMucmVmbGVjdGl2aXR5ID0gc291cmNlLnJlZmxlY3Rpdml0eTtcXG5cXHRcXHR0aGlzLnJlZnJhY3Rpb25SYXRpbyA9IHNvdXJjZS5yZWZyYWN0aW9uUmF0aW87XFxuXFxuXFx0XFx0dGhpcy53aXJlZnJhbWUgPSBzb3VyY2Uud2lyZWZyYW1lO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZXdpZHRoID0gc291cmNlLndpcmVmcmFtZUxpbmV3aWR0aDtcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmVjYXAgPSBzb3VyY2Uud2lyZWZyYW1lTGluZWNhcDtcXG5cXHRcXHR0aGlzLndpcmVmcmFtZUxpbmVqb2luID0gc291cmNlLndpcmVmcmFtZUxpbmVqb2luO1xcblxcblxcdFxcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XFxuXFx0XFx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xcblxcdFxcdHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgdGFrYWhpcm94IC8gaHR0cDovL2dpdGh1Yi5jb20vdGFrYWhpcm94XFxuXFx0ICpcXG5cXHQgKiBwYXJhbWV0ZXJzID0ge1xcblxcdCAqICBncmFkaWVudE1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKVxcblxcdCAqIH1cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBNZXNoVG9vbk1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdE1lc2hQaG9uZ01hdGVyaWFsLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLmRlZmluZXMgPSB7ICdUT09OJzogJycgfTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnTWVzaFRvb25NYXRlcmlhbCc7XFxuXFxuXFx0XFx0dGhpcy5ncmFkaWVudE1hcCA9IG51bGw7XFxuXFxuXFx0XFx0dGhpcy5zZXRWYWx1ZXMoIHBhcmFtZXRlcnMgKTtcXG5cXG5cXHR9XFxuXFxuXFx0TWVzaFRvb25NYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNZXNoUGhvbmdNYXRlcmlhbC5wcm90b3R5cGUgKTtcXG5cXHRNZXNoVG9vbk1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1lc2hUb29uTWF0ZXJpYWw7XFxuXFxuXFx0TWVzaFRvb25NYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoVG9vbk1hdGVyaWFsID0gdHJ1ZTtcXG5cXG5cXHRNZXNoVG9vbk1hdGVyaWFsLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0TWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0dGhpcy5ncmFkaWVudE1hcCA9IHNvdXJjZS5ncmFkaWVudE1hcDtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxuXFx0ICpcXG5cXHQgKiBwYXJhbWV0ZXJzID0ge1xcblxcdCAqICBvcGFjaXR5OiA8ZmxvYXQ+LFxcblxcdCAqXFxuXFx0ICogIGJ1bXBNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICogIGJ1bXBTY2FsZTogPGZsb2F0PixcXG5cXHQgKlxcblxcdCAqICBub3JtYWxNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICogIG5vcm1hbFNjYWxlOiA8VmVjdG9yMj4sXFxuXFx0ICpcXG5cXHQgKiAgZGlzcGxhY2VtZW50TWFwOiBuZXcgVEhSRUUuVGV4dHVyZSggPEltYWdlPiApLFxcblxcdCAqICBkaXNwbGFjZW1lbnRTY2FsZTogPGZsb2F0PixcXG5cXHQgKiAgZGlzcGxhY2VtZW50QmlhczogPGZsb2F0PixcXG5cXHQgKlxcblxcdCAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcXG5cXHQgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+XFxuXFx0ICpcXG5cXHQgKiAgc2tpbm5pbmc6IDxib29sPixcXG5cXHQgKiAgbW9ycGhUYXJnZXRzOiA8Ym9vbD4sXFxuXFx0ICogIG1vcnBoTm9ybWFsczogPGJvb2w+XFxuXFx0ICogfVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIE1lc2hOb3JtYWxNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHRNYXRlcmlhbC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ01lc2hOb3JtYWxNYXRlcmlhbCc7XFxuXFxuXFx0XFx0dGhpcy5idW1wTWFwID0gbnVsbDtcXG5cXHRcXHR0aGlzLmJ1bXBTY2FsZSA9IDE7XFxuXFxuXFx0XFx0dGhpcy5ub3JtYWxNYXAgPSBudWxsO1xcblxcdFxcdHRoaXMubm9ybWFsU2NhbGUgPSBuZXcgVmVjdG9yMiggMSwgMSApO1xcblxcblxcdFxcdHRoaXMuZGlzcGxhY2VtZW50TWFwID0gbnVsbDtcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudFNjYWxlID0gMTtcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSAwO1xcblxcblxcdFxcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xcblxcblxcdFxcdHRoaXMuZm9nID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5saWdodHMgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLnNraW5uaW5nID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5tb3JwaFRhcmdldHMgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLm1vcnBoTm9ybWFscyA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMuc2V0VmFsdWVzKCBwYXJhbWV0ZXJzICk7XFxuXFxuXFx0fVxcblxcblxcdE1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXRlcmlhbC5wcm90b3R5cGUgKTtcXG5cXHRNZXNoTm9ybWFsTWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaE5vcm1hbE1hdGVyaWFsO1xcblxcblxcdE1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuaXNNZXNoTm9ybWFsTWF0ZXJpYWwgPSB0cnVlO1xcblxcblxcdE1lc2hOb3JtYWxNYXRlcmlhbC5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdE1hdGVyaWFsLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdHRoaXMuYnVtcE1hcCA9IHNvdXJjZS5idW1wTWFwO1xcblxcdFxcdHRoaXMuYnVtcFNjYWxlID0gc291cmNlLmJ1bXBTY2FsZTtcXG5cXG5cXHRcXHR0aGlzLm5vcm1hbE1hcCA9IHNvdXJjZS5ub3JtYWxNYXA7XFxuXFx0XFx0dGhpcy5ub3JtYWxTY2FsZS5jb3B5KCBzb3VyY2Uubm9ybWFsU2NhbGUgKTtcXG5cXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudE1hcCA9IHNvdXJjZS5kaXNwbGFjZW1lbnRNYXA7XFxuXFx0XFx0dGhpcy5kaXNwbGFjZW1lbnRTY2FsZSA9IHNvdXJjZS5kaXNwbGFjZW1lbnRTY2FsZTtcXG5cXHRcXHR0aGlzLmRpc3BsYWNlbWVudEJpYXMgPSBzb3VyY2UuZGlzcGxhY2VtZW50QmlhcztcXG5cXG5cXHRcXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xcblxcblxcdFxcdHRoaXMuc2tpbm5pbmcgPSBzb3VyY2Uuc2tpbm5pbmc7XFxuXFx0XFx0dGhpcy5tb3JwaFRhcmdldHMgPSBzb3VyY2UubW9ycGhUYXJnZXRzO1xcblxcdFxcdHRoaXMubW9ycGhOb3JtYWxzID0gc291cmNlLm1vcnBoTm9ybWFscztcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKlxcblxcdCAqIHBhcmFtZXRlcnMgPSB7XFxuXFx0ICogIGNvbG9yOiA8aGV4PixcXG5cXHQgKiAgb3BhY2l0eTogPGZsb2F0PixcXG5cXHQgKlxcblxcdCAqICBtYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICpcXG5cXHQgKiAgbGlnaHRNYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICogIGxpZ2h0TWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XFxuXFx0ICpcXG5cXHQgKiAgYW9NYXA6IG5ldyBUSFJFRS5UZXh0dXJlKCA8SW1hZ2U+ICksXFxuXFx0ICogIGFvTWFwSW50ZW5zaXR5OiA8ZmxvYXQ+XFxuXFx0ICpcXG5cXHQgKiAgZW1pc3NpdmU6IDxoZXg+LFxcblxcdCAqICBlbWlzc2l2ZUludGVuc2l0eTogPGZsb2F0PlxcblxcdCAqICBlbWlzc2l2ZU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKlxcblxcdCAqICBzcGVjdWxhck1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKlxcblxcdCAqICBhbHBoYU1hcDogbmV3IFRIUkVFLlRleHR1cmUoIDxJbWFnZT4gKSxcXG5cXHQgKlxcblxcdCAqICBlbnZNYXA6IG5ldyBUSFJFRS5UZXh0dXJlQ3ViZSggW3Bvc3gsIG5lZ3gsIHBvc3ksIG5lZ3ksIHBvc3osIG5lZ3pdICksXFxuXFx0ICogIGNvbWJpbmU6IFRIUkVFLk11bHRpcGx5LFxcblxcdCAqICByZWZsZWN0aXZpdHk6IDxmbG9hdD4sXFxuXFx0ICogIHJlZnJhY3Rpb25SYXRpbzogPGZsb2F0PixcXG5cXHQgKlxcblxcdCAqICB3aXJlZnJhbWU6IDxib29sZWFuPixcXG5cXHQgKiAgd2lyZWZyYW1lTGluZXdpZHRoOiA8ZmxvYXQ+LFxcblxcdCAqXFxuXFx0ICogIHNraW5uaW5nOiA8Ym9vbD4sXFxuXFx0ICogIG1vcnBoVGFyZ2V0czogPGJvb2w+LFxcblxcdCAqICBtb3JwaE5vcm1hbHM6IDxib29sPlxcblxcdCAqIH1cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBNZXNoTGFtYmVydE1hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdE1hdGVyaWFsLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnTWVzaExhbWJlcnRNYXRlcmlhbCc7XFxuXFxuXFx0XFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggMHhmZmZmZmYgKTsgLy8gZGlmZnVzZVxcblxcblxcdFxcdHRoaXMubWFwID0gbnVsbDtcXG5cXG5cXHRcXHR0aGlzLmxpZ2h0TWFwID0gbnVsbDtcXG5cXHRcXHR0aGlzLmxpZ2h0TWFwSW50ZW5zaXR5ID0gMS4wO1xcblxcblxcdFxcdHRoaXMuYW9NYXAgPSBudWxsO1xcblxcdFxcdHRoaXMuYW9NYXBJbnRlbnNpdHkgPSAxLjA7XFxuXFxuXFx0XFx0dGhpcy5lbWlzc2l2ZSA9IG5ldyBDb2xvciggMHgwMDAwMDAgKTtcXG5cXHRcXHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gMS4wO1xcblxcdFxcdHRoaXMuZW1pc3NpdmVNYXAgPSBudWxsO1xcblxcblxcdFxcdHRoaXMuc3BlY3VsYXJNYXAgPSBudWxsO1xcblxcblxcdFxcdHRoaXMuYWxwaGFNYXAgPSBudWxsO1xcblxcblxcdFxcdHRoaXMuZW52TWFwID0gbnVsbDtcXG5cXHRcXHR0aGlzLmNvbWJpbmUgPSBNdWx0aXBseU9wZXJhdGlvbjtcXG5cXHRcXHR0aGlzLnJlZmxlY3Rpdml0eSA9IDE7XFxuXFx0XFx0dGhpcy5yZWZyYWN0aW9uUmF0aW8gPSAwLjk4O1xcblxcblxcdFxcdHRoaXMud2lyZWZyYW1lID0gZmFsc2U7XFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSAxO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9ICdyb3VuZCc7XFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5lam9pbiA9ICdyb3VuZCc7XFxuXFxuXFx0XFx0dGhpcy5za2lubmluZyA9IGZhbHNlO1xcblxcdFxcdHRoaXMubW9ycGhUYXJnZXRzID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBmYWxzZTtcXG5cXG5cXHRcXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xcblxcblxcdH1cXG5cXG5cXHRNZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hdGVyaWFsLnByb3RvdHlwZSApO1xcblxcdE1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTWVzaExhbWJlcnRNYXRlcmlhbDtcXG5cXG5cXHRNZXNoTGFtYmVydE1hdGVyaWFsLnByb3RvdHlwZS5pc01lc2hMYW1iZXJ0TWF0ZXJpYWwgPSB0cnVlO1xcblxcblxcdE1lc2hMYW1iZXJ0TWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHR0aGlzLmNvbG9yLmNvcHkoIHNvdXJjZS5jb2xvciApO1xcblxcblxcdFxcdHRoaXMubWFwID0gc291cmNlLm1hcDtcXG5cXG5cXHRcXHR0aGlzLmxpZ2h0TWFwID0gc291cmNlLmxpZ2h0TWFwO1xcblxcdFxcdHRoaXMubGlnaHRNYXBJbnRlbnNpdHkgPSBzb3VyY2UubGlnaHRNYXBJbnRlbnNpdHk7XFxuXFxuXFx0XFx0dGhpcy5hb01hcCA9IHNvdXJjZS5hb01hcDtcXG5cXHRcXHR0aGlzLmFvTWFwSW50ZW5zaXR5ID0gc291cmNlLmFvTWFwSW50ZW5zaXR5O1xcblxcblxcdFxcdHRoaXMuZW1pc3NpdmUuY29weSggc291cmNlLmVtaXNzaXZlICk7XFxuXFx0XFx0dGhpcy5lbWlzc2l2ZU1hcCA9IHNvdXJjZS5lbWlzc2l2ZU1hcDtcXG5cXHRcXHR0aGlzLmVtaXNzaXZlSW50ZW5zaXR5ID0gc291cmNlLmVtaXNzaXZlSW50ZW5zaXR5O1xcblxcblxcdFxcdHRoaXMuc3BlY3VsYXJNYXAgPSBzb3VyY2Uuc3BlY3VsYXJNYXA7XFxuXFxuXFx0XFx0dGhpcy5hbHBoYU1hcCA9IHNvdXJjZS5hbHBoYU1hcDtcXG5cXG5cXHRcXHR0aGlzLmVudk1hcCA9IHNvdXJjZS5lbnZNYXA7XFxuXFx0XFx0dGhpcy5jb21iaW5lID0gc291cmNlLmNvbWJpbmU7XFxuXFx0XFx0dGhpcy5yZWZsZWN0aXZpdHkgPSBzb3VyY2UucmVmbGVjdGl2aXR5O1xcblxcdFxcdHRoaXMucmVmcmFjdGlvblJhdGlvID0gc291cmNlLnJlZnJhY3Rpb25SYXRpbztcXG5cXG5cXHRcXHR0aGlzLndpcmVmcmFtZSA9IHNvdXJjZS53aXJlZnJhbWU7XFxuXFx0XFx0dGhpcy53aXJlZnJhbWVMaW5ld2lkdGggPSBzb3VyY2Uud2lyZWZyYW1lTGluZXdpZHRoO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZWNhcCA9IHNvdXJjZS53aXJlZnJhbWVMaW5lY2FwO1xcblxcdFxcdHRoaXMud2lyZWZyYW1lTGluZWpvaW4gPSBzb3VyY2Uud2lyZWZyYW1lTGluZWpvaW47XFxuXFxuXFx0XFx0dGhpcy5za2lubmluZyA9IHNvdXJjZS5za2lubmluZztcXG5cXHRcXHR0aGlzLm1vcnBoVGFyZ2V0cyA9IHNvdXJjZS5tb3JwaFRhcmdldHM7XFxuXFx0XFx0dGhpcy5tb3JwaE5vcm1hbHMgPSBzb3VyY2UubW9ycGhOb3JtYWxzO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKlxcblxcdCAqIHBhcmFtZXRlcnMgPSB7XFxuXFx0ICogIGNvbG9yOiA8aGV4PixcXG5cXHQgKiAgb3BhY2l0eTogPGZsb2F0PixcXG5cXHQgKlxcblxcdCAqICBsaW5ld2lkdGg6IDxmbG9hdD4sXFxuXFx0ICpcXG5cXHQgKiAgc2NhbGU6IDxmbG9hdD4sXFxuXFx0ICogIGRhc2hTaXplOiA8ZmxvYXQ+LFxcblxcdCAqICBnYXBTaXplOiA8ZmxvYXQ+XFxuXFx0ICogfVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIExpbmVEYXNoZWRNYXRlcmlhbCggcGFyYW1ldGVycyApIHtcXG5cXG5cXHRcXHRMaW5lQmFzaWNNYXRlcmlhbC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0xpbmVEYXNoZWRNYXRlcmlhbCc7XFxuXFxuXFx0XFx0dGhpcy5zY2FsZSA9IDE7XFxuXFx0XFx0dGhpcy5kYXNoU2l6ZSA9IDM7XFxuXFx0XFx0dGhpcy5nYXBTaXplID0gMTtcXG5cXG5cXHRcXHR0aGlzLnNldFZhbHVlcyggcGFyYW1ldGVycyApO1xcblxcblxcdH1cXG5cXG5cXHRMaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZUJhc2ljTWF0ZXJpYWwucHJvdG90eXBlICk7XFxuXFx0TGluZURhc2hlZE1hdGVyaWFsLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVEYXNoZWRNYXRlcmlhbDtcXG5cXG5cXHRMaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmlzTGluZURhc2hlZE1hdGVyaWFsID0gdHJ1ZTtcXG5cXG5cXHRMaW5lRGFzaGVkTWF0ZXJpYWwucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRMaW5lQmFzaWNNYXRlcmlhbC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHR0aGlzLnNjYWxlID0gc291cmNlLnNjYWxlO1xcblxcdFxcdHRoaXMuZGFzaFNpemUgPSBzb3VyY2UuZGFzaFNpemU7XFxuXFx0XFx0dGhpcy5nYXBTaXplID0gc291cmNlLmdhcFNpemU7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXG5cXG5cXHR2YXIgTWF0ZXJpYWxzID0gT2JqZWN0LmZyZWV6ZSh7XFxuXFx0XFx0U2hhZG93TWF0ZXJpYWw6IFNoYWRvd01hdGVyaWFsLFxcblxcdFxcdFNwcml0ZU1hdGVyaWFsOiBTcHJpdGVNYXRlcmlhbCxcXG5cXHRcXHRSYXdTaGFkZXJNYXRlcmlhbDogUmF3U2hhZGVyTWF0ZXJpYWwsXFxuXFx0XFx0U2hhZGVyTWF0ZXJpYWw6IFNoYWRlck1hdGVyaWFsLFxcblxcdFxcdFBvaW50c01hdGVyaWFsOiBQb2ludHNNYXRlcmlhbCxcXG5cXHRcXHRNZXNoUGh5c2ljYWxNYXRlcmlhbDogTWVzaFBoeXNpY2FsTWF0ZXJpYWwsXFxuXFx0XFx0TWVzaFN0YW5kYXJkTWF0ZXJpYWw6IE1lc2hTdGFuZGFyZE1hdGVyaWFsLFxcblxcdFxcdE1lc2hQaG9uZ01hdGVyaWFsOiBNZXNoUGhvbmdNYXRlcmlhbCxcXG5cXHRcXHRNZXNoVG9vbk1hdGVyaWFsOiBNZXNoVG9vbk1hdGVyaWFsLFxcblxcdFxcdE1lc2hOb3JtYWxNYXRlcmlhbDogTWVzaE5vcm1hbE1hdGVyaWFsLFxcblxcdFxcdE1lc2hMYW1iZXJ0TWF0ZXJpYWw6IE1lc2hMYW1iZXJ0TWF0ZXJpYWwsXFxuXFx0XFx0TWVzaERlcHRoTWF0ZXJpYWw6IE1lc2hEZXB0aE1hdGVyaWFsLFxcblxcdFxcdE1lc2hEaXN0YW5jZU1hdGVyaWFsOiBNZXNoRGlzdGFuY2VNYXRlcmlhbCxcXG5cXHRcXHRNZXNoQmFzaWNNYXRlcmlhbDogTWVzaEJhc2ljTWF0ZXJpYWwsXFxuXFx0XFx0TGluZURhc2hlZE1hdGVyaWFsOiBMaW5lRGFzaGVkTWF0ZXJpYWwsXFxuXFx0XFx0TGluZUJhc2ljTWF0ZXJpYWw6IExpbmVCYXNpY01hdGVyaWFsLFxcblxcdFxcdE1hdGVyaWFsOiBNYXRlcmlhbFxcblxcdH0pO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0dmFyIENhY2hlID0ge1xcblxcblxcdFxcdGVuYWJsZWQ6IGZhbHNlLFxcblxcblxcdFxcdGZpbGVzOiB7fSxcXG5cXG5cXHRcXHRhZGQ6IGZ1bmN0aW9uICgga2V5LCBmaWxlICkge1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5lbmFibGVkID09PSBmYWxzZSApIHJldHVybjtcXG5cXG5cXHRcXHRcXHQvLyBjb25zb2xlLmxvZyggJ1RIUkVFLkNhY2hlJywgJ0FkZGluZyBrZXk6Jywga2V5ICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5maWxlc1sga2V5IF0gPSBmaWxlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0OiBmdW5jdGlvbiAoIGtleSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuZW5hYmxlZCA9PT0gZmFsc2UgKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0Ly8gY29uc29sZS5sb2coICdUSFJFRS5DYWNoZScsICdDaGVja2luZyBrZXk6Jywga2V5ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZmlsZXNbIGtleSBdO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cmVtb3ZlOiBmdW5jdGlvbiAoIGtleSApIHtcXG5cXG5cXHRcXHRcXHRkZWxldGUgdGhpcy5maWxlc1sga2V5IF07XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbGVhcjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMuZmlsZXMgPSB7fTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIExvYWRpbmdNYW5hZ2VyKCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XFxuXFxuXFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXG5cXG5cXHRcXHR2YXIgaXNMb2FkaW5nID0gZmFsc2U7XFxuXFx0XFx0dmFyIGl0ZW1zTG9hZGVkID0gMDtcXG5cXHRcXHR2YXIgaXRlbXNUb3RhbCA9IDA7XFxuXFx0XFx0dmFyIHVybE1vZGlmaWVyID0gdW5kZWZpbmVkO1xcblxcblxcdFxcdHRoaXMub25TdGFydCA9IHVuZGVmaW5lZDtcXG5cXHRcXHR0aGlzLm9uTG9hZCA9IG9uTG9hZDtcXG5cXHRcXHR0aGlzLm9uUHJvZ3Jlc3MgPSBvblByb2dyZXNzO1xcblxcdFxcdHRoaXMub25FcnJvciA9IG9uRXJyb3I7XFxuXFxuXFx0XFx0dGhpcy5pdGVtU3RhcnQgPSBmdW5jdGlvbiAoIHVybCApIHtcXG5cXG5cXHRcXHRcXHRpdGVtc1RvdGFsICsrO1xcblxcblxcdFxcdFxcdGlmICggaXNMb2FkaW5nID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHNjb3BlLm9uU3RhcnQgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzY29wZS5vblN0YXJ0KCB1cmwsIGl0ZW1zTG9hZGVkLCBpdGVtc1RvdGFsICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpc0xvYWRpbmcgPSB0cnVlO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5pdGVtRW5kID0gZnVuY3Rpb24gKCB1cmwgKSB7XFxuXFxuXFx0XFx0XFx0aXRlbXNMb2FkZWQgKys7XFxuXFxuXFx0XFx0XFx0aWYgKCBzY29wZS5vblByb2dyZXNzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c2NvcGUub25Qcm9ncmVzcyggdXJsLCBpdGVtc0xvYWRlZCwgaXRlbXNUb3RhbCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGl0ZW1zTG9hZGVkID09PSBpdGVtc1RvdGFsICkge1xcblxcblxcdFxcdFxcdFxcdGlzTG9hZGluZyA9IGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdGlmICggc2NvcGUub25Mb2FkICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2NvcGUub25Mb2FkKCk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuaXRlbUVycm9yID0gZnVuY3Rpb24gKCB1cmwgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBzY29wZS5vbkVycm9yICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c2NvcGUub25FcnJvciggdXJsICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5yZXNvbHZlVVJMID0gZnVuY3Rpb24gKCB1cmwgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB1cmxNb2RpZmllciApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdXJsTW9kaWZpZXIoIHVybCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdXJsO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5zZXRVUkxNb2RpZmllciA9IGZ1bmN0aW9uICggdHJhbnNmb3JtICkge1xcblxcblxcdFxcdFxcdHVybE1vZGlmaWVyID0gdHJhbnNmb3JtO1xcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdHZhciBEZWZhdWx0TG9hZGluZ01hbmFnZXIgPSBuZXcgTG9hZGluZ01hbmFnZXIoKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdHZhciBsb2FkaW5nID0ge307XFxuXFxuXFx0ZnVuY3Rpb24gRmlsZUxvYWRlciggbWFuYWdlciApIHtcXG5cXG5cXHRcXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggRmlsZUxvYWRlci5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xcblxcblxcdFxcdFxcdGlmICggdXJsID09PSB1bmRlZmluZWQgKSB1cmwgPSAnJztcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMucGF0aCAhPT0gdW5kZWZpbmVkICkgdXJsID0gdGhpcy5wYXRoICsgdXJsO1xcblxcblxcdFxcdFxcdHVybCA9IHRoaXMubWFuYWdlci5yZXNvbHZlVVJMKCB1cmwgKTtcXG5cXG5cXHRcXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcblxcblxcdFxcdFxcdHZhciBjYWNoZWQgPSBDYWNoZS5nZXQoIHVybCApO1xcblxcblxcdFxcdFxcdGlmICggY2FjaGVkICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xcblxcblxcdFxcdFxcdFxcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG9uTG9hZCApIG9uTG9hZCggY2FjaGVkICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcXG5cXG5cXHRcXHRcXHRcXHR9LCAwICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNhY2hlZDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gQ2hlY2sgaWYgcmVxdWVzdCBpcyBkdXBsaWNhdGVcXG5cXG5cXHRcXHRcXHRpZiAoIGxvYWRpbmdbIHVybCBdICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bG9hZGluZ1sgdXJsIF0ucHVzaCgge1xcblxcblxcdFxcdFxcdFxcdFxcdG9uTG9hZDogb25Mb2FkLFxcblxcdFxcdFxcdFxcdFxcdG9uUHJvZ3Jlc3M6IG9uUHJvZ3Jlc3MsXFxuXFx0XFx0XFx0XFx0XFx0b25FcnJvcjogb25FcnJvclxcblxcblxcdFxcdFxcdFxcdH0gKTtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIENoZWNrIGZvciBkYXRhOiBVUklcXG5cXHRcXHRcXHR2YXIgZGF0YVVyaVJlZ2V4ID0gL15kYXRhOiguKj8pKDtiYXNlNjQpPywoLiopJC87XFxuXFx0XFx0XFx0dmFyIGRhdGFVcmlSZWdleFJlc3VsdCA9IHVybC5tYXRjaCggZGF0YVVyaVJlZ2V4ICk7XFxuXFxuXFx0XFx0XFx0Ly8gU2FmYXJpIGNhbiBub3QgaGFuZGxlIERhdGEgVVJJcyB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0IHNvIHByb2Nlc3MgbWFudWFsbHlcXG5cXHRcXHRcXHRpZiAoIGRhdGFVcmlSZWdleFJlc3VsdCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbWltZVR5cGUgPSBkYXRhVXJpUmVnZXhSZXN1bHRbIDEgXTtcXG5cXHRcXHRcXHRcXHR2YXIgaXNCYXNlNjQgPSAhISBkYXRhVXJpUmVnZXhSZXN1bHRbIDIgXTtcXG5cXHRcXHRcXHRcXHR2YXIgZGF0YSA9IGRhdGFVcmlSZWdleFJlc3VsdFsgMyBdO1xcblxcblxcdFxcdFxcdFxcdGRhdGEgPSB3aW5kb3cuZGVjb2RlVVJJQ29tcG9uZW50KCBkYXRhICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpc0Jhc2U2NCApIGRhdGEgPSB3aW5kb3cuYXRvYiggZGF0YSApO1xcblxcblxcdFxcdFxcdFxcdHRyeSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHJlc3BvbnNlO1xcblxcdFxcdFxcdFxcdFxcdHZhciByZXNwb25zZVR5cGUgPSAoIHRoaXMucmVzcG9uc2VUeXBlIHx8ICcnICkudG9Mb3dlckNhc2UoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzd2l0Y2ggKCByZXNwb25zZVR5cGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnYXJyYXlidWZmZXInOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ2Jsb2InOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoIGRhdGEubGVuZ3RoICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dmlld1sgaSBdID0gZGF0YS5jaGFyQ29kZUF0KCBpICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggcmVzcG9uc2VUeXBlID09PSAnYmxvYicgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmVzcG9uc2UgPSBuZXcgQmxvYiggWyB2aWV3LmJ1ZmZlciBdLCB7IHR5cGU6IG1pbWVUeXBlIH0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc3BvbnNlID0gdmlldy5idWZmZXI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ2RvY3VtZW50JzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJlc3BvbnNlID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgbWltZVR5cGUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdqc29uJzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNwb25zZSA9IEpTT04ucGFyc2UoIGRhdGEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRkZWZhdWx0OiAvLyAndGV4dCcgb3Igb3RoZXJcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXNwb25zZSA9IGRhdGE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIFdhaXQgZm9yIG5leHQgYnJvd3NlciB0aWNrIGxpa2Ugc3RhbmRhcmQgWE1MSHR0cFJlcXVlc3QgZXZlbnQgZGlzcGF0Y2hpbmcgZG9lc1xcblxcdFxcdFxcdFxcdFxcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHJlc3BvbnNlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9LCAwICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBjYXRjaCAoIGVycm9yICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIFdhaXQgZm9yIG5leHQgYnJvd3NlciB0aWNrIGxpa2Ugc3RhbmRhcmQgWE1MSHR0cFJlcXVlc3QgZXZlbnQgZGlzcGF0Y2hpbmcgZG9lc1xcblxcdFxcdFxcdFxcdFxcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBvbkVycm9yICkgb25FcnJvciggZXJyb3IgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9LCAwICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSW5pdGlhbGlzZSBhcnJheSBmb3IgZHVwbGljYXRlIHJlcXVlc3RzXFxuXFxuXFx0XFx0XFx0XFx0bG9hZGluZ1sgdXJsIF0gPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRsb2FkaW5nWyB1cmwgXS5wdXNoKCB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0b25Mb2FkOiBvbkxvYWQsXFxuXFx0XFx0XFx0XFx0XFx0b25Qcm9ncmVzczogb25Qcm9ncmVzcyxcXG5cXHRcXHRcXHRcXHRcXHRvbkVycm9yOiBvbkVycm9yXFxuXFxuXFx0XFx0XFx0XFx0fSApO1xcblxcblxcdFxcdFxcdFxcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XFxuXFxuXFx0XFx0XFx0XFx0cmVxdWVzdC5vcGVuKCAnR0VUJywgdXJsLCB0cnVlICk7XFxuXFxuXFx0XFx0XFx0XFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGZ1bmN0aW9uICggZXZlbnQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHJlc3BvbnNlID0gdGhpcy5yZXNwb25zZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRDYWNoZS5hZGQoIHVybCwgcmVzcG9uc2UgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgY2FsbGJhY2tzID0gbG9hZGluZ1sgdXJsIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZGVsZXRlIGxvYWRpbmdbIHVybCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdGhpcy5zdGF0dXMgPT09IDIwMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc1sgaSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggY2FsbGJhY2sub25Mb2FkICkgY2FsbGJhY2sub25Mb2FkKCByZXNwb25zZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoIHRoaXMuc3RhdHVzID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFNvbWUgYnJvd3NlcnMgcmV0dXJuIEhUVFAgU3RhdHVzIDAgd2hlbiB1c2luZyBub24taHR0cCBwcm90b2NvbFxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGUuZy4gJ2ZpbGU6Ly8nIG9yICdkYXRhOi8vJy4gSGFuZGxlIGFzIHN1Y2Nlc3MuXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmlsZUxvYWRlcjogSFRUUCBTdGF0dXMgMCByZWNlaXZlZC4nICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3NbIGkgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGNhbGxiYWNrLm9uTG9hZCApIGNhbGxiYWNrLm9uTG9hZCggcmVzcG9uc2UgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGNhbGxiYWNrID0gY2FsbGJhY2tzWyBpIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBjYWxsYmFjay5vbkVycm9yICkgY2FsbGJhY2sub25FcnJvciggZXZlbnQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0sIGZhbHNlICk7XFxuXFxuXFx0XFx0XFx0XFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAncHJvZ3Jlc3MnLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBjYWxsYmFja3MgPSBsb2FkaW5nWyB1cmwgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc1sgaSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggY2FsbGJhY2sub25Qcm9ncmVzcyApIGNhbGxiYWNrLm9uUHJvZ3Jlc3MoIGV2ZW50ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0sIGZhbHNlICk7XFxuXFxuXFx0XFx0XFx0XFx0cmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCAnZXJyb3InLCBmdW5jdGlvbiAoIGV2ZW50ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBjYWxsYmFja3MgPSBsb2FkaW5nWyB1cmwgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRkZWxldGUgbG9hZGluZ1sgdXJsIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3NbIGkgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGNhbGxiYWNrLm9uRXJyb3IgKSBjYWxsYmFjay5vbkVycm9yKCBldmVudCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xcblxcdFxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcXG5cXG5cXHRcXHRcXHRcXHR9LCBmYWxzZSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggdGhpcy5yZXNwb25zZVR5cGUgIT09IHVuZGVmaW5lZCApIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdGhpcy5yZXNwb25zZVR5cGU7XFxuXFx0XFx0XFx0XFx0aWYgKCB0aGlzLndpdGhDcmVkZW50aWFscyAhPT0gdW5kZWZpbmVkICkgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0aGlzLndpdGhDcmVkZW50aWFscztcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSApIHJlcXVlc3Qub3ZlcnJpZGVNaW1lVHlwZSggdGhpcy5taW1lVHlwZSAhPT0gdW5kZWZpbmVkID8gdGhpcy5taW1lVHlwZSA6ICd0ZXh0L3BsYWluJyApO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBoZWFkZXIgaW4gdGhpcy5yZXF1ZXN0SGVhZGVyICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlciggaGVhZGVyLCB0aGlzLnJlcXVlc3RIZWFkZXJbIGhlYWRlciBdICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJlcXVlc3Quc2VuZCggbnVsbCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1TdGFydCggdXJsICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHJlcXVlc3Q7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMucGF0aCA9IHZhbHVlO1xcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0UmVzcG9uc2VUeXBlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMucmVzcG9uc2VUeXBlID0gdmFsdWU7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRXaXRoQ3JlZGVudGlhbHM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSB2YWx1ZTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldE1pbWVUeXBlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMubWltZVR5cGUgPSB2YWx1ZTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFJlcXVlc3RIZWFkZXI6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5yZXF1ZXN0SGVhZGVyID0gdmFsdWU7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqXFxuXFx0ICogQWJzdHJhY3QgQmFzZSBjbGFzcyB0byBibG9jayBiYXNlZCB0ZXh0dXJlcyBsb2FkZXIgKGRkcywgcHZyLCAuLi4pXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKSB7XFxuXFxuXFx0XFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XFxuXFxuXFx0XFx0Ly8gb3ZlcnJpZGUgaW4gc3ViIGNsYXNzZXNcXG5cXHRcXHR0aGlzLl9wYXJzZXIgPSBudWxsO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBDb21wcmVzc2VkVGV4dHVyZUxvYWRlci5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xcblxcblxcdFxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxuXFxuXFx0XFx0XFx0dmFyIGltYWdlcyA9IFtdO1xcblxcblxcdFxcdFxcdHZhciB0ZXh0dXJlID0gbmV3IENvbXByZXNzZWRUZXh0dXJlKCk7XFxuXFx0XFx0XFx0dGV4dHVyZS5pbWFnZSA9IGltYWdlcztcXG5cXG5cXHRcXHRcXHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xcblxcdFxcdFxcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcXG5cXHRcXHRcXHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gbG9hZFRleHR1cmUoIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0bG9hZGVyLmxvYWQoIHVybFsgaSBdLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdGV4RGF0YXMgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIsIHRydWUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpbWFnZXNbIGkgXSA9IHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR3aWR0aDogdGV4RGF0YXMud2lkdGgsXFxuXFx0XFx0XFx0XFx0XFx0XFx0aGVpZ2h0OiB0ZXhEYXRhcy5oZWlnaHQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9ybWF0OiB0ZXhEYXRhcy5mb3JtYXQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0bWlwbWFwczogdGV4RGF0YXMubWlwbWFwc1xcblxcdFxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0XFx0bG9hZGVkICs9IDE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBsb2FkZWQgPT09IDYgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSApXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5taW5GaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIHVybCApICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBsb2FkZWQgPSAwO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgaWwgPSB1cmwubGVuZ3RoOyBpIDwgaWw7ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bG9hZFRleHR1cmUoIGkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBjb21wcmVzc2VkIGN1YmVtYXAgdGV4dHVyZSBzdG9yZWQgaW4gYSBzaW5nbGUgRERTIGZpbGVcXG5cXG5cXHRcXHRcXHRcXHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdGV4RGF0YXMgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIsIHRydWUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRleERhdGFzLmlzQ3ViZW1hcCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgZmFjZXMgPSB0ZXhEYXRhcy5taXBtYXBzLmxlbmd0aCAvIHRleERhdGFzLm1pcG1hcENvdW50O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBmID0gMDsgZiA8IGZhY2VzOyBmICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGltYWdlc1sgZiBdID0geyBtaXBtYXBzOiBbXSB9O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IHRleERhdGFzLm1pcG1hcENvdW50OyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGltYWdlc1sgZiBdLm1pcG1hcHMucHVzaCggdGV4RGF0YXMubWlwbWFwc1sgZiAqIHRleERhdGFzLm1pcG1hcENvdW50ICsgaSBdICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW1hZ2VzWyBmIF0uZm9ybWF0ID0gdGV4RGF0YXMuZm9ybWF0O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGltYWdlc1sgZiBdLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aW1hZ2VzWyBmIF0uaGVpZ2h0ID0gdGV4RGF0YXMuaGVpZ2h0O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YXMud2lkdGg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5pbWFnZS5oZWlnaHQgPSB0ZXhEYXRhcy5oZWlnaHQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5taXBtYXBzID0gdGV4RGF0YXMubWlwbWFwcztcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0ZXhEYXRhcy5taXBtYXBDb3VudCA9PT0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLm1pbkZpbHRlciA9IExpbmVhckZpbHRlcjtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5mb3JtYXQgPSB0ZXhEYXRhcy5mb3JtYXQ7XFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcXG5cXG5cXHRcXHRcXHRcXHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0UGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnBhdGggPSB2YWx1ZTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgTmlrb3MgTS4gLyBodHRwczovL2dpdGh1Yi5jb20vZm9vMTIzL1xcblxcdCAqXFxuXFx0ICogQWJzdHJhY3QgQmFzZSBjbGFzcyB0byBsb2FkIGdlbmVyaWMgYmluYXJ5IHRleHR1cmVzIGZvcm1hdHMgKHJnYmUsIGhkciwgLi4uKVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIERhdGFUZXh0dXJlTG9hZGVyKCBtYW5hZ2VyICkge1xcblxcblxcdFxcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xcblxcblxcdFxcdC8vIG92ZXJyaWRlIGluIHN1YiBjbGFzc2VzXFxuXFx0XFx0dGhpcy5fcGFyc2VyID0gbnVsbDtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggRGF0YVRleHR1cmVMb2FkZXIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcXG5cXG5cXHRcXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcblxcblxcdFxcdFxcdHZhciB0ZXh0dXJlID0gbmV3IERhdGFUZXh0dXJlKCk7XFxuXFxuXFx0XFx0XFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCB0aGlzLm1hbmFnZXIgKTtcXG5cXHRcXHRcXHRsb2FkZXIuc2V0UmVzcG9uc2VUeXBlKCAnYXJyYXlidWZmZXInICk7XFxuXFxuXFx0XFx0XFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCBidWZmZXIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHRleERhdGEgPSBzY29wZS5fcGFyc2VyKCBidWZmZXIgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoICEgdGV4RGF0YSApIHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5pbWFnZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLmltYWdlID0gdGV4RGF0YS5pbWFnZTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuZGF0YSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLmltYWdlLndpZHRoID0gdGV4RGF0YS53aWR0aDtcXG5cXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLmltYWdlLmhlaWdodCA9IHRleERhdGEuaGVpZ2h0O1xcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUuaW1hZ2UuZGF0YSA9IHRleERhdGEuZGF0YTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dGV4dHVyZS53cmFwUyA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS53cmFwUyA/IHRleERhdGEud3JhcFMgOiBDbGFtcFRvRWRnZVdyYXBwaW5nO1xcblxcdFxcdFxcdFxcdHRleHR1cmUud3JhcFQgPSB1bmRlZmluZWQgIT09IHRleERhdGEud3JhcFQgPyB0ZXhEYXRhLndyYXBUIDogQ2xhbXBUb0VkZ2VXcmFwcGluZztcXG5cXG5cXHRcXHRcXHRcXHR0ZXh0dXJlLm1hZ0ZpbHRlciA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5tYWdGaWx0ZXIgPyB0ZXhEYXRhLm1hZ0ZpbHRlciA6IExpbmVhckZpbHRlcjtcXG5cXHRcXHRcXHRcXHR0ZXh0dXJlLm1pbkZpbHRlciA9IHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5taW5GaWx0ZXIgPyB0ZXhEYXRhLm1pbkZpbHRlciA6IExpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcXG5cXG5cXHRcXHRcXHRcXHR0ZXh0dXJlLmFuaXNvdHJvcHkgPSB1bmRlZmluZWQgIT09IHRleERhdGEuYW5pc290cm9weSA/IHRleERhdGEuYW5pc290cm9weSA6IDE7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB1bmRlZmluZWQgIT09IHRleERhdGEuZm9ybWF0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUuZm9ybWF0ID0gdGV4RGF0YS5mb3JtYXQ7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGlmICggdW5kZWZpbmVkICE9PSB0ZXhEYXRhLnR5cGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZS50eXBlID0gdGV4RGF0YS50eXBlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHVuZGVmaW5lZCAhPT0gdGV4RGF0YS5taXBtYXBzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUubWlwbWFwcyA9IHRleERhdGEubWlwbWFwcztcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAxID09PSB0ZXhEYXRhLm1pcG1hcENvdW50ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUubWluRmlsdGVyID0gTGluZWFyRmlsdGVyO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0ZXh0dXJlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGV4dHVyZSwgdGV4RGF0YSApO1xcblxcblxcdFxcdFxcdH0sIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKTtcXG5cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gSW1hZ2VMb2FkZXIoIG1hbmFnZXIgKSB7XFxuXFxuXFx0XFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIEltYWdlTG9hZGVyLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGNyb3NzT3JpZ2luOiAnQW5vbnltb3VzJyxcXG5cXG5cXHRcXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xcblxcblxcdFxcdFxcdGlmICggdXJsID09PSB1bmRlZmluZWQgKSB1cmwgPSAnJztcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMucGF0aCAhPT0gdW5kZWZpbmVkICkgdXJsID0gdGhpcy5wYXRoICsgdXJsO1xcblxcblxcdFxcdFxcdHVybCA9IHRoaXMubWFuYWdlci5yZXNvbHZlVVJMKCB1cmwgKTtcXG5cXG5cXHRcXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcblxcblxcdFxcdFxcdHZhciBjYWNoZWQgPSBDYWNoZS5nZXQoIHVybCApO1xcblxcblxcdFxcdFxcdGlmICggY2FjaGVkICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xcblxcblxcdFxcdFxcdFxcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG9uTG9hZCApIG9uTG9hZCggY2FjaGVkICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcXG5cXG5cXHRcXHRcXHRcXHR9LCAwICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNhY2hlZDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdpbWcnICk7XFxuXFxuXFx0XFx0XFx0aW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0Q2FjaGUuYWRkKCB1cmwsIHRoaXMgKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG9uTG9hZCApIG9uTG9hZCggdGhpcyApO1xcblxcblxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XFxuXFxuXFx0XFx0XFx0fSwgZmFsc2UgKTtcXG5cXG5cXHRcXHRcXHQvKlxcblxcdFxcdFxcdGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoICdwcm9ncmVzcycsIGZ1bmN0aW9uICggZXZlbnQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBvblByb2dyZXNzICkgb25Qcm9ncmVzcyggZXZlbnQgKTtcXG5cXG5cXHRcXHRcXHR9LCBmYWxzZSApO1xcblxcdFxcdFxcdCovXFxuXFxuXFx0XFx0XFx0aW1hZ2UuYWRkRXZlbnRMaXN0ZW5lciggJ2Vycm9yJywgZnVuY3Rpb24gKCBldmVudCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBldmVudCApO1xcblxcblxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVuZCggdXJsICk7XFxuXFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRXJyb3IoIHVybCApO1xcblxcblxcdFxcdFxcdH0sIGZhbHNlICk7XFxuXFxuXFx0XFx0XFx0aWYgKCB1cmwuc3Vic3RyKCAwLCA1ICkgIT09ICdkYXRhOicgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0aGlzLmNyb3NzT3JpZ2luICE9PSB1bmRlZmluZWQgKSBpbWFnZS5jcm9zc09yaWdpbiA9IHRoaXMuY3Jvc3NPcmlnaW47XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbVN0YXJ0KCB1cmwgKTtcXG5cXG5cXHRcXHRcXHRpbWFnZS5zcmMgPSB1cmw7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGltYWdlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0UGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnBhdGggPSB2YWx1ZTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gQ3ViZVRleHR1cmVMb2FkZXIoIG1hbmFnZXIgKSB7XFxuXFxuXFx0XFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIEN1YmVUZXh0dXJlTG9hZGVyLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGNyb3NzT3JpZ2luOiAnQW5vbnltb3VzJyxcXG5cXG5cXHRcXHRsb2FkOiBmdW5jdGlvbiAoIHVybHMsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGV4dHVyZSA9IG5ldyBDdWJlVGV4dHVyZSgpO1xcblxcblxcdFxcdFxcdHZhciBsb2FkZXIgPSBuZXcgSW1hZ2VMb2FkZXIoIHRoaXMubWFuYWdlciApO1xcblxcdFxcdFxcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xcblxcdFxcdFxcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcXG5cXG5cXHRcXHRcXHR2YXIgbG9hZGVkID0gMDtcXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBsb2FkVGV4dHVyZSggaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRsb2FkZXIubG9hZCggdXJsc1sgaSBdLCBmdW5jdGlvbiAoIGltYWdlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmUuaW1hZ2VzWyBpIF0gPSBpbWFnZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRsb2FkZWQgKys7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBsb2FkZWQgPT09IDYgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIHRleHR1cmUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fSwgdW5kZWZpbmVkLCBvbkVycm9yICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IHVybHMubGVuZ3RoOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdGxvYWRUZXh0dXJlKCBpICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0UGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnBhdGggPSB2YWx1ZTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gVGV4dHVyZUxvYWRlciggbWFuYWdlciApIHtcXG5cXG5cXHRcXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggVGV4dHVyZUxvYWRlci5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRjcm9zc09yaWdpbjogJ0Fub255bW91cycsXFxuXFxuXFx0XFx0bG9hZDogZnVuY3Rpb24gKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGV4dHVyZSA9IG5ldyBUZXh0dXJlKCk7XFxuXFxuXFx0XFx0XFx0dmFyIGxvYWRlciA9IG5ldyBJbWFnZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XFxuXFx0XFx0XFx0bG9hZGVyLnNldENyb3NzT3JpZ2luKCB0aGlzLmNyb3NzT3JpZ2luICk7XFxuXFx0XFx0XFx0bG9hZGVyLnNldFBhdGgoIHRoaXMucGF0aCApO1xcblxcblxcdFxcdFxcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggaW1hZ2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGV4dHVyZS5pbWFnZSA9IGltYWdlO1xcblxcblxcdFxcdFxcdFxcdC8vIEpQRUdzIGNhbid0IGhhdmUgYW4gYWxwaGEgY2hhbm5lbCwgc28gbWVtb3J5IGNhbiBiZSBzYXZlZCBieSBzdG9yaW5nIHRoZW0gYXMgUkdCLlxcblxcdFxcdFxcdFxcdHZhciBpc0pQRUcgPSB1cmwuc2VhcmNoKCAvXFxcXC4oanBnfGpwZWcpJC8gKSA+IDAgfHwgdXJsLnNlYXJjaCggL15kYXRhXFxcXDppbWFnZVxcXFwvanBlZy8gKSA9PT0gMDtcXG5cXG5cXHRcXHRcXHRcXHR0ZXh0dXJlLmZvcm1hdCA9IGlzSlBFRyA/IFJHQkZvcm1hdCA6IFJHQkFGb3JtYXQ7XFxuXFx0XFx0XFx0XFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBvbkxvYWQgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRvbkxvYWQoIHRleHR1cmUgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xcblxcblxcdFxcdFxcdHJldHVybiB0ZXh0dXJlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0UGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnBhdGggPSB2YWx1ZTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcXG5cXHQgKiBFeHRlbnNpYmxlIGN1cnZlIG9iamVjdFxcblxcdCAqXFxuXFx0ICogU29tZSBjb21tb24gb2YgY3VydmUgbWV0aG9kczpcXG5cXHQgKiAuZ2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ICksIC5nZXRUYW5nZW50KCB0IClcXG5cXHQgKiAuZ2V0UG9pbnRBdCggdSwgb3B0aW9uYWxUYXJnZXQgKSwgLmdldFRhbmdlbnRBdCggdSApXFxuXFx0ICogLmdldFBvaW50cygpLCAuZ2V0U3BhY2VkUG9pbnRzKClcXG5cXHQgKiAuZ2V0TGVuZ3RoKClcXG5cXHQgKiAudXBkYXRlQXJjTGVuZ3RocygpXFxuXFx0ICpcXG5cXHQgKiBUaGlzIGZvbGxvd2luZyBjdXJ2ZXMgaW5oZXJpdCBmcm9tIFRIUkVFLkN1cnZlOlxcblxcdCAqXFxuXFx0ICogLS0gMkQgY3VydmVzIC0tXFxuXFx0ICogVEhSRUUuQXJjQ3VydmVcXG5cXHQgKiBUSFJFRS5DdWJpY0JlemllckN1cnZlXFxuXFx0ICogVEhSRUUuRWxsaXBzZUN1cnZlXFxuXFx0ICogVEhSRUUuTGluZUN1cnZlXFxuXFx0ICogVEhSRUUuUXVhZHJhdGljQmV6aWVyQ3VydmVcXG5cXHQgKiBUSFJFRS5TcGxpbmVDdXJ2ZVxcblxcdCAqXFxuXFx0ICogLS0gM0QgY3VydmVzIC0tXFxuXFx0ICogVEhSRUUuQ2F0bXVsbFJvbUN1cnZlM1xcblxcdCAqIFRIUkVFLkN1YmljQmV6aWVyQ3VydmUzXFxuXFx0ICogVEhSRUUuTGluZUN1cnZlM1xcblxcdCAqIFRIUkVFLlF1YWRyYXRpY0JlemllckN1cnZlM1xcblxcdCAqXFxuXFx0ICogQSBzZXJpZXMgb2YgY3VydmVzIGNhbiBiZSByZXByZXNlbnRlZCBhcyBhIFRIUkVFLkN1cnZlUGF0aC5cXG5cXHQgKlxcblxcdCAqKi9cXG5cXG5cXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG5cXHQgKlxcdEFic3RyYWN0IEN1cnZlIGJhc2UgY2xhc3NcXG5cXHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXFxuXFxuXFx0ZnVuY3Rpb24gQ3VydmUoKSB7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0N1cnZlJztcXG5cXG5cXHRcXHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IDIwMDtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggQ3VydmUucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0Ly8gVmlydHVhbCBiYXNlIGNsYXNzIG1ldGhvZCB0byBvdmVyd3JpdGUgYW5kIGltcGxlbWVudCBpbiBzdWJjbGFzc2VzXFxuXFx0XFx0Ly9cXHQtIHQgWzAgLi4gMV1cXG5cXG5cXHRcXHRnZXRQb2ludDogZnVuY3Rpb24gKCAvKiB0LCBvcHRpb25hbFRhcmdldCAqLyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5DdXJ2ZTogLmdldFBvaW50KCkgbm90IGltcGxlbWVudGVkLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIEdldCBwb2ludCBhdCByZWxhdGl2ZSBwb3NpdGlvbiBpbiBjdXJ2ZSBhY2NvcmRpbmcgdG8gYXJjIGxlbmd0aFxcblxcdFxcdC8vIC0gdSBbMCAuLiAxXVxcblxcblxcdFxcdGdldFBvaW50QXQ6IGZ1bmN0aW9uICggdSwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHQgPSB0aGlzLmdldFV0b1RtYXBwaW5nKCB1ICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQoIHQsIG9wdGlvbmFsVGFyZ2V0ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBHZXQgc2VxdWVuY2Ugb2YgcG9pbnRzIHVzaW5nIGdldFBvaW50KCB0IClcXG5cXG5cXHRcXHRnZXRQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xcblxcblxcdFxcdFxcdGlmICggZGl2aXNpb25zID09PSB1bmRlZmluZWQgKSBkaXZpc2lvbnMgPSA1O1xcblxcblxcdFxcdFxcdHZhciBwb2ludHMgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgZCA9IDA7IGQgPD0gZGl2aXNpb25zOyBkICsrICkge1xcblxcblxcdFxcdFxcdFxcdHBvaW50cy5wdXNoKCB0aGlzLmdldFBvaW50KCBkIC8gZGl2aXNpb25zICkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHBvaW50cztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIEdldCBzZXF1ZW5jZSBvZiBwb2ludHMgdXNpbmcgZ2V0UG9pbnRBdCggdSApXFxuXFxuXFx0XFx0Z2V0U3BhY2VkUG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGRpdmlzaW9ucyA9PT0gdW5kZWZpbmVkICkgZGl2aXNpb25zID0gNTtcXG5cXG5cXHRcXHRcXHR2YXIgcG9pbnRzID0gW107XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGQgPSAwOyBkIDw9IGRpdmlzaW9uczsgZCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRwb2ludHMucHVzaCggdGhpcy5nZXRQb2ludEF0KCBkIC8gZGl2aXNpb25zICkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHBvaW50cztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIEdldCB0b3RhbCBjdXJ2ZSBhcmMgbGVuZ3RoXFxuXFxuXFx0XFx0Z2V0TGVuZ3RoOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGxlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcXG5cXHRcXHRcXHRyZXR1cm4gbGVuZ3Roc1sgbGVuZ3Rocy5sZW5ndGggLSAxIF07XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBHZXQgbGlzdCBvZiBjdW11bGF0aXZlIHNlZ21lbnQgbGVuZ3Roc1xcblxcblxcdFxcdGdldExlbmd0aHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xcblxcblxcdFxcdFxcdGlmICggZGl2aXNpb25zID09PSB1bmRlZmluZWQgKSBkaXZpc2lvbnMgPSB0aGlzLmFyY0xlbmd0aERpdmlzaW9ucztcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuY2FjaGVBcmNMZW5ndGhzICYmXFxuXFx0XFx0XFx0XFx0KCB0aGlzLmNhY2hlQXJjTGVuZ3Rocy5sZW5ndGggPT09IGRpdmlzaW9ucyArIDEgKSAmJlxcblxcdFxcdFxcdFxcdCEgdGhpcy5uZWVkc1VwZGF0ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5jYWNoZUFyY0xlbmd0aHM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHR2YXIgY2FjaGUgPSBbXTtcXG5cXHRcXHRcXHR2YXIgY3VycmVudCwgbGFzdCA9IHRoaXMuZ2V0UG9pbnQoIDAgKTtcXG5cXHRcXHRcXHR2YXIgcCwgc3VtID0gMDtcXG5cXG5cXHRcXHRcXHRjYWNoZS5wdXNoKCAwICk7XFxuXFxuXFx0XFx0XFx0Zm9yICggcCA9IDE7IHAgPD0gZGl2aXNpb25zOyBwICsrICkge1xcblxcblxcdFxcdFxcdFxcdGN1cnJlbnQgPSB0aGlzLmdldFBvaW50KCBwIC8gZGl2aXNpb25zICk7XFxuXFx0XFx0XFx0XFx0c3VtICs9IGN1cnJlbnQuZGlzdGFuY2VUbyggbGFzdCApO1xcblxcdFxcdFxcdFxcdGNhY2hlLnB1c2goIHN1bSApO1xcblxcdFxcdFxcdFxcdGxhc3QgPSBjdXJyZW50O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmNhY2hlQXJjTGVuZ3RocyA9IGNhY2hlO1xcblxcblxcdFxcdFxcdHJldHVybiBjYWNoZTsgLy8geyBzdW1zOiBjYWNoZSwgc3VtOiBzdW0gfTsgU3VtIGlzIGluIHRoZSBsYXN0IGVsZW1lbnQuXFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR1cGRhdGVBcmNMZW5ndGhzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFx0XFx0XFx0dGhpcy5nZXRMZW5ndGhzKCk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBHaXZlbiB1ICggMCAuLiAxICksIGdldCBhIHQgdG8gZmluZCBwLiBUaGlzIGdpdmVzIHlvdSBwb2ludHMgd2hpY2ggYXJlIGVxdWlkaXN0YW50XFxuXFxuXFx0XFx0Z2V0VXRvVG1hcHBpbmc6IGZ1bmN0aW9uICggdSwgZGlzdGFuY2UgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGFyY0xlbmd0aHMgPSB0aGlzLmdldExlbmd0aHMoKTtcXG5cXG5cXHRcXHRcXHR2YXIgaSA9IDAsIGlsID0gYXJjTGVuZ3Rocy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0dmFyIHRhcmdldEFyY0xlbmd0aDsgLy8gVGhlIHRhcmdldGVkIHUgZGlzdGFuY2UgdmFsdWUgdG8gZ2V0XFxuXFxuXFx0XFx0XFx0aWYgKCBkaXN0YW5jZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0YXJnZXRBcmNMZW5ndGggPSBkaXN0YW5jZTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHRhcmdldEFyY0xlbmd0aCA9IHUgKiBhcmNMZW5ndGhzWyBpbCAtIDEgXTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gYmluYXJ5IHNlYXJjaCBmb3IgdGhlIGluZGV4IHdpdGggbGFyZ2VzdCB2YWx1ZSBzbWFsbGVyIHRoYW4gdGFyZ2V0IHUgZGlzdGFuY2VcXG5cXG5cXHRcXHRcXHR2YXIgbG93ID0gMCwgaGlnaCA9IGlsIC0gMSwgY29tcGFyaXNvbjtcXG5cXG5cXHRcXHRcXHR3aGlsZSAoIGxvdyA8PSBoaWdoICkge1xcblxcblxcdFxcdFxcdFxcdGkgPSBNYXRoLmZsb29yKCBsb3cgKyAoIGhpZ2ggLSBsb3cgKSAvIDIgKTsgLy8gbGVzcyBsaWtlbHkgdG8gb3ZlcmZsb3csIHRob3VnaCBwcm9iYWJseSBub3QgaXNzdWUgaGVyZSwgSlMgZG9lc24ndCByZWFsbHkgaGF2ZSBpbnRlZ2VycywgYWxsIG51bWJlcnMgYXJlIGZsb2F0c1xcblxcblxcdFxcdFxcdFxcdGNvbXBhcmlzb24gPSBhcmNMZW5ndGhzWyBpIF0gLSB0YXJnZXRBcmNMZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBjb21wYXJpc29uIDwgMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRsb3cgPSBpICsgMTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBjb21wYXJpc29uID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRoaWdoID0gaSAtIDE7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRoaWdoID0gaTtcXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBET05FXFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpID0gaGlnaDtcXG5cXG5cXHRcXHRcXHRpZiAoIGFyY0xlbmd0aHNbIGkgXSA9PT0gdGFyZ2V0QXJjTGVuZ3RoICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBpIC8gKCBpbCAtIDEgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gd2UgY291bGQgZ2V0IGZpbmVyIGdyYWluIGF0IGxlbmd0aHMsIG9yIHVzZSBzaW1wbGUgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIHR3byBwb2ludHNcXG5cXG5cXHRcXHRcXHR2YXIgbGVuZ3RoQmVmb3JlID0gYXJjTGVuZ3Roc1sgaSBdO1xcblxcdFxcdFxcdHZhciBsZW5ndGhBZnRlciA9IGFyY0xlbmd0aHNbIGkgKyAxIF07XFxuXFxuXFx0XFx0XFx0dmFyIHNlZ21lbnRMZW5ndGggPSBsZW5ndGhBZnRlciAtIGxlbmd0aEJlZm9yZTtcXG5cXG5cXHRcXHRcXHQvLyBkZXRlcm1pbmUgd2hlcmUgd2UgYXJlIGJldHdlZW4gdGhlICdiZWZvcmUnIGFuZCAnYWZ0ZXInIHBvaW50c1xcblxcblxcdFxcdFxcdHZhciBzZWdtZW50RnJhY3Rpb24gPSAoIHRhcmdldEFyY0xlbmd0aCAtIGxlbmd0aEJlZm9yZSApIC8gc2VnbWVudExlbmd0aDtcXG5cXG5cXHRcXHRcXHQvLyBhZGQgdGhhdCBmcmFjdGlvbmFsIGFtb3VudCB0byB0XFxuXFxuXFx0XFx0XFx0dmFyIHQgPSAoIGkgKyBzZWdtZW50RnJhY3Rpb24gKSAvICggaWwgLSAxICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHQ7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBSZXR1cm5zIGEgdW5pdCB2ZWN0b3IgdGFuZ2VudCBhdCB0XFxuXFx0XFx0Ly8gSW4gY2FzZSBhbnkgc3ViIGN1cnZlIGRvZXMgbm90IGltcGxlbWVudCBpdHMgdGFuZ2VudCBkZXJpdmF0aW9uLFxcblxcdFxcdC8vIDIgcG9pbnRzIGEgc21hbGwgZGVsdGEgYXBhcnQgd2lsbCBiZSB1c2VkIHRvIGZpbmQgaXRzIGdyYWRpZW50XFxuXFx0XFx0Ly8gd2hpY2ggc2VlbXMgdG8gZ2l2ZSBhIHJlYXNvbmFibGUgYXBwcm94aW1hdGlvblxcblxcblxcdFxcdGdldFRhbmdlbnQ6IGZ1bmN0aW9uICggdCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZGVsdGEgPSAwLjAwMDE7XFxuXFx0XFx0XFx0dmFyIHQxID0gdCAtIGRlbHRhO1xcblxcdFxcdFxcdHZhciB0MiA9IHQgKyBkZWx0YTtcXG5cXG5cXHRcXHRcXHQvLyBDYXBwaW5nIGluIGNhc2Ugb2YgZGFuZ2VyXFxuXFxuXFx0XFx0XFx0aWYgKCB0MSA8IDAgKSB0MSA9IDA7XFxuXFx0XFx0XFx0aWYgKCB0MiA+IDEgKSB0MiA9IDE7XFxuXFxuXFx0XFx0XFx0dmFyIHB0MSA9IHRoaXMuZ2V0UG9pbnQoIHQxICk7XFxuXFx0XFx0XFx0dmFyIHB0MiA9IHRoaXMuZ2V0UG9pbnQoIHQyICk7XFxuXFxuXFx0XFx0XFx0dmFyIHZlYyA9IHB0Mi5jbG9uZSgpLnN1YiggcHQxICk7XFxuXFx0XFx0XFx0cmV0dXJuIHZlYy5ub3JtYWxpemUoKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldFRhbmdlbnRBdDogZnVuY3Rpb24gKCB1ICkge1xcblxcblxcdFxcdFxcdHZhciB0ID0gdGhpcy5nZXRVdG9UbWFwcGluZyggdSApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmdldFRhbmdlbnQoIHQgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvbXB1dGVGcmVuZXRGcmFtZXM6IGZ1bmN0aW9uICggc2VnbWVudHMsIGNsb3NlZCApIHtcXG5cXG5cXHRcXHRcXHQvLyBzZWUgaHR0cDovL3d3dy5jcy5pbmRpYW5hLmVkdS9wdWIvdGVjaHJlcG9ydHMvVFI0MjUucGRmXFxuXFxuXFx0XFx0XFx0dmFyIG5vcm1hbCA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0dmFyIHRhbmdlbnRzID0gW107XFxuXFx0XFx0XFx0dmFyIG5vcm1hbHMgPSBbXTtcXG5cXHRcXHRcXHR2YXIgYmlub3JtYWxzID0gW107XFxuXFxuXFx0XFx0XFx0dmFyIHZlYyA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0XFx0dmFyIG1hdCA9IG5ldyBNYXRyaXg0KCk7XFxuXFxuXFx0XFx0XFx0dmFyIGksIHUsIHRoZXRhO1xcblxcblxcdFxcdFxcdC8vIGNvbXB1dGUgdGhlIHRhbmdlbnQgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBjdXJ2ZVxcblxcblxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHUgPSBpIC8gc2VnbWVudHM7XFxuXFxuXFx0XFx0XFx0XFx0dGFuZ2VudHNbIGkgXSA9IHRoaXMuZ2V0VGFuZ2VudEF0KCB1ICk7XFxuXFx0XFx0XFx0XFx0dGFuZ2VudHNbIGkgXS5ub3JtYWxpemUoKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gc2VsZWN0IGFuIGluaXRpYWwgbm9ybWFsIHZlY3RvciBwZXJwZW5kaWN1bGFyIHRvIHRoZSBmaXJzdCB0YW5nZW50IHZlY3RvcixcXG5cXHRcXHRcXHQvLyBhbmQgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbWluaW11bSB0YW5nZW50IHh5eiBjb21wb25lbnRcXG5cXG5cXHRcXHRcXHRub3JtYWxzWyAwIF0gPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdGJpbm9ybWFsc1sgMCBdID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHR2YXIgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcXG5cXHRcXHRcXHR2YXIgdHggPSBNYXRoLmFicyggdGFuZ2VudHNbIDAgXS54ICk7XFxuXFx0XFx0XFx0dmFyIHR5ID0gTWF0aC5hYnMoIHRhbmdlbnRzWyAwIF0ueSApO1xcblxcdFxcdFxcdHZhciB0eiA9IE1hdGguYWJzKCB0YW5nZW50c1sgMCBdLnogKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHR4IDw9IG1pbiApIHtcXG5cXG5cXHRcXHRcXHRcXHRtaW4gPSB0eDtcXG5cXHRcXHRcXHRcXHRub3JtYWwuc2V0KCAxLCAwLCAwICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdHkgPD0gbWluICkge1xcblxcblxcdFxcdFxcdFxcdG1pbiA9IHR5O1xcblxcdFxcdFxcdFxcdG5vcm1hbC5zZXQoIDAsIDEsIDAgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB0eiA8PSBtaW4gKSB7XFxuXFxuXFx0XFx0XFx0XFx0bm9ybWFsLnNldCggMCwgMCwgMSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2ZWMuY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCBub3JtYWwgKS5ub3JtYWxpemUoKTtcXG5cXG5cXHRcXHRcXHRub3JtYWxzWyAwIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgMCBdLCB2ZWMgKTtcXG5cXHRcXHRcXHRiaW5vcm1hbHNbIDAgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyAwIF0sIG5vcm1hbHNbIDAgXSApO1xcblxcblxcblxcdFxcdFxcdC8vIGNvbXB1dGUgdGhlIHNsb3dseS12YXJ5aW5nIG5vcm1hbCBhbmQgYmlub3JtYWwgdmVjdG9ycyBmb3IgZWFjaCBzZWdtZW50IG9uIHRoZSBjdXJ2ZVxcblxcblxcdFxcdFxcdGZvciAoIGkgPSAxOyBpIDw9IHNlZ21lbnRzOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdG5vcm1hbHNbIGkgXSA9IG5vcm1hbHNbIGkgLSAxIF0uY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHRcXHRiaW5vcm1hbHNbIGkgXSA9IGJpbm9ybWFsc1sgaSAtIDEgXS5jbG9uZSgpO1xcblxcblxcdFxcdFxcdFxcdHZlYy5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIC0gMSBdLCB0YW5nZW50c1sgaSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB2ZWMubGVuZ3RoKCkgPiBOdW1iZXIuRVBTSUxPTiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZWMubm9ybWFsaXplKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhldGEgPSBNYXRoLmFjb3MoIF9NYXRoLmNsYW1wKCB0YW5nZW50c1sgaSAtIDEgXS5kb3QoIHRhbmdlbnRzWyBpIF0gKSwgLSAxLCAxICkgKTsgLy8gY2xhbXAgZm9yIGZsb2F0aW5nIHB0IGVycm9yc1xcblxcblxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIGkgXS5hcHBseU1hdHJpeDQoIG1hdC5tYWtlUm90YXRpb25BeGlzKCB2ZWMsIHRoZXRhICkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Ymlub3JtYWxzWyBpIF0uY3Jvc3NWZWN0b3JzKCB0YW5nZW50c1sgaSBdLCBub3JtYWxzWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gaWYgdGhlIGN1cnZlIGlzIGNsb3NlZCwgcG9zdHByb2Nlc3MgdGhlIHZlY3RvcnMgc28gdGhlIGZpcnN0IGFuZCBsYXN0IG5vcm1hbCB2ZWN0b3JzIGFyZSB0aGUgc2FtZVxcblxcblxcdFxcdFxcdGlmICggY2xvc2VkID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdHRoZXRhID0gTWF0aC5hY29zKCBfTWF0aC5jbGFtcCggbm9ybWFsc1sgMCBdLmRvdCggbm9ybWFsc1sgc2VnbWVudHMgXSApLCAtIDEsIDEgKSApO1xcblxcdFxcdFxcdFxcdHRoZXRhIC89IHNlZ21lbnRzO1xcblxcblxcdFxcdFxcdFxcdGlmICggdGFuZ2VudHNbIDAgXS5kb3QoIHZlYy5jcm9zc1ZlY3RvcnMoIG5vcm1hbHNbIDAgXSwgbm9ybWFsc1sgc2VnbWVudHMgXSApICkgPiAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoZXRhID0gLSB0aGV0YTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggaSA9IDE7IGkgPD0gc2VnbWVudHM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdHdpc3QgYSBsaXR0bGUuLi5cXG5cXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBpIF0uYXBwbHlNYXRyaXg0KCBtYXQubWFrZVJvdGF0aW9uQXhpcyggdGFuZ2VudHNbIGkgXSwgdGhldGEgKiBpICkgKTtcXG5cXHRcXHRcXHRcXHRcXHRiaW5vcm1hbHNbIGkgXS5jcm9zc1ZlY3RvcnMoIHRhbmdlbnRzWyBpIF0sIG5vcm1hbHNbIGkgXSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHR0YW5nZW50czogdGFuZ2VudHMsXFxuXFx0XFx0XFx0XFx0bm9ybWFsczogbm9ybWFscyxcXG5cXHRcXHRcXHRcXHRiaW5vcm1hbHM6IGJpbm9ybWFsc1xcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdFxcdHRoaXMuYXJjTGVuZ3RoRGl2aXNpb25zID0gc291cmNlLmFyY0xlbmd0aERpdmlzaW9ucztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBkYXRhID0ge1xcblxcdFxcdFxcdFxcdG1ldGFkYXRhOiB7XFxuXFx0XFx0XFx0XFx0XFx0dmVyc2lvbjogNC41LFxcblxcdFxcdFxcdFxcdFxcdHR5cGU6ICdDdXJ2ZScsXFxuXFx0XFx0XFx0XFx0XFx0Z2VuZXJhdG9yOiAnQ3VydmUudG9KU09OJ1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdGRhdGEuYXJjTGVuZ3RoRGl2aXNpb25zID0gdGhpcy5hcmNMZW5ndGhEaXZpc2lvbnM7XFxuXFx0XFx0XFx0ZGF0YS50eXBlID0gdGhpcy50eXBlO1xcblxcblxcdFxcdFxcdHJldHVybiBkYXRhO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZnJvbUpTT046IGZ1bmN0aW9uICgganNvbiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmFyY0xlbmd0aERpdmlzaW9ucyA9IGpzb24uYXJjTGVuZ3RoRGl2aXNpb25zO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0ZnVuY3Rpb24gRWxsaXBzZUN1cnZlKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcXG5cXG5cXHRcXHRDdXJ2ZS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0VsbGlwc2VDdXJ2ZSc7XFxuXFxuXFx0XFx0dGhpcy5hWCA9IGFYIHx8IDA7XFxuXFx0XFx0dGhpcy5hWSA9IGFZIHx8IDA7XFxuXFxuXFx0XFx0dGhpcy54UmFkaXVzID0geFJhZGl1cyB8fCAxO1xcblxcdFxcdHRoaXMueVJhZGl1cyA9IHlSYWRpdXMgfHwgMTtcXG5cXG5cXHRcXHR0aGlzLmFTdGFydEFuZ2xlID0gYVN0YXJ0QW5nbGUgfHwgMDtcXG5cXHRcXHR0aGlzLmFFbmRBbmdsZSA9IGFFbmRBbmdsZSB8fCAyICogTWF0aC5QSTtcXG5cXG5cXHRcXHR0aGlzLmFDbG9ja3dpc2UgPSBhQ2xvY2t3aXNlIHx8IGZhbHNlO1xcblxcblxcdFxcdHRoaXMuYVJvdGF0aW9uID0gYVJvdGF0aW9uIHx8IDA7XFxuXFxuXFx0fVxcblxcblxcdEVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcXG5cXHRFbGxpcHNlQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRWxsaXBzZUN1cnZlO1xcblxcblxcdEVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuaXNFbGxpcHNlQ3VydmUgPSB0cnVlO1xcblxcblxcdEVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IyKCk7XFxuXFxuXFx0XFx0dmFyIHR3b1BpID0gTWF0aC5QSSAqIDI7XFxuXFx0XFx0dmFyIGRlbHRhQW5nbGUgPSB0aGlzLmFFbmRBbmdsZSAtIHRoaXMuYVN0YXJ0QW5nbGU7XFxuXFx0XFx0dmFyIHNhbWVQb2ludHMgPSBNYXRoLmFicyggZGVsdGFBbmdsZSApIDwgTnVtYmVyLkVQU0lMT047XFxuXFxuXFx0XFx0Ly8gZW5zdXJlcyB0aGF0IGRlbHRhQW5nbGUgaXMgMCAuLiAyIFBJXFxuXFx0XFx0d2hpbGUgKCBkZWx0YUFuZ2xlIDwgMCApIGRlbHRhQW5nbGUgKz0gdHdvUGk7XFxuXFx0XFx0d2hpbGUgKCBkZWx0YUFuZ2xlID4gdHdvUGkgKSBkZWx0YUFuZ2xlIC09IHR3b1BpO1xcblxcblxcdFxcdGlmICggZGVsdGFBbmdsZSA8IE51bWJlci5FUFNJTE9OICkge1xcblxcblxcdFxcdFxcdGlmICggc2FtZVBvaW50cyApIHtcXG5cXG5cXHRcXHRcXHRcXHRkZWx0YUFuZ2xlID0gMDtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdGRlbHRhQW5nbGUgPSB0d29QaTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICggdGhpcy5hQ2xvY2t3aXNlID09PSB0cnVlICYmICEgc2FtZVBvaW50cyApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIGRlbHRhQW5nbGUgPT09IHR3b1BpICkge1xcblxcblxcdFxcdFxcdFxcdGRlbHRhQW5nbGUgPSAtIHR3b1BpO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0ZGVsdGFBbmdsZSA9IGRlbHRhQW5nbGUgLSB0d29QaTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHZhciBhbmdsZSA9IHRoaXMuYVN0YXJ0QW5nbGUgKyB0ICogZGVsdGFBbmdsZTtcXG5cXHRcXHR2YXIgeCA9IHRoaXMuYVggKyB0aGlzLnhSYWRpdXMgKiBNYXRoLmNvcyggYW5nbGUgKTtcXG5cXHRcXHR2YXIgeSA9IHRoaXMuYVkgKyB0aGlzLnlSYWRpdXMgKiBNYXRoLnNpbiggYW5nbGUgKTtcXG5cXG5cXHRcXHRpZiAoIHRoaXMuYVJvdGF0aW9uICE9PSAwICkge1xcblxcblxcdFxcdFxcdHZhciBjb3MgPSBNYXRoLmNvcyggdGhpcy5hUm90YXRpb24gKTtcXG5cXHRcXHRcXHR2YXIgc2luID0gTWF0aC5zaW4oIHRoaXMuYVJvdGF0aW9uICk7XFxuXFxuXFx0XFx0XFx0dmFyIHR4ID0geCAtIHRoaXMuYVg7XFxuXFx0XFx0XFx0dmFyIHR5ID0geSAtIHRoaXMuYVk7XFxuXFxuXFx0XFx0XFx0Ly8gUm90YXRlIHRoZSBwb2ludCBhYm91dCB0aGUgY2VudGVyIG9mIHRoZSBlbGxpcHNlLlxcblxcdFxcdFxcdHggPSB0eCAqIGNvcyAtIHR5ICogc2luICsgdGhpcy5hWDtcXG5cXHRcXHRcXHR5ID0gdHggKiBzaW4gKyB0eSAqIGNvcyArIHRoaXMuYVk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBwb2ludC5zZXQoIHgsIHkgKTtcXG5cXG5cXHR9O1xcblxcblxcdEVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdHRoaXMuYVggPSBzb3VyY2UuYVg7XFxuXFx0XFx0dGhpcy5hWSA9IHNvdXJjZS5hWTtcXG5cXG5cXHRcXHR0aGlzLnhSYWRpdXMgPSBzb3VyY2UueFJhZGl1cztcXG5cXHRcXHR0aGlzLnlSYWRpdXMgPSBzb3VyY2UueVJhZGl1cztcXG5cXG5cXHRcXHR0aGlzLmFTdGFydEFuZ2xlID0gc291cmNlLmFTdGFydEFuZ2xlO1xcblxcdFxcdHRoaXMuYUVuZEFuZ2xlID0gc291cmNlLmFFbmRBbmdsZTtcXG5cXG5cXHRcXHR0aGlzLmFDbG9ja3dpc2UgPSBzb3VyY2UuYUNsb2Nrd2lzZTtcXG5cXG5cXHRcXHR0aGlzLmFSb3RhdGlvbiA9IHNvdXJjZS5hUm90YXRpb247XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXG5cXHRFbGxpcHNlQ3VydmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xcblxcblxcdFxcdGRhdGEuYVggPSB0aGlzLmFYO1xcblxcdFxcdGRhdGEuYVkgPSB0aGlzLmFZO1xcblxcblxcdFxcdGRhdGEueFJhZGl1cyA9IHRoaXMueFJhZGl1cztcXG5cXHRcXHRkYXRhLnlSYWRpdXMgPSB0aGlzLnlSYWRpdXM7XFxuXFxuXFx0XFx0ZGF0YS5hU3RhcnRBbmdsZSA9IHRoaXMuYVN0YXJ0QW5nbGU7XFxuXFx0XFx0ZGF0YS5hRW5kQW5nbGUgPSB0aGlzLmFFbmRBbmdsZTtcXG5cXG5cXHRcXHRkYXRhLmFDbG9ja3dpc2UgPSB0aGlzLmFDbG9ja3dpc2U7XFxuXFxuXFx0XFx0ZGF0YS5hUm90YXRpb24gPSB0aGlzLmFSb3RhdGlvbjtcXG5cXG5cXHRcXHRyZXR1cm4gZGF0YTtcXG5cXG5cXHR9O1xcblxcblxcdEVsbGlwc2VDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XFxuXFxuXFx0XFx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcXG5cXG5cXHRcXHR0aGlzLmFYID0ganNvbi5hWDtcXG5cXHRcXHR0aGlzLmFZID0ganNvbi5hWTtcXG5cXG5cXHRcXHR0aGlzLnhSYWRpdXMgPSBqc29uLnhSYWRpdXM7XFxuXFx0XFx0dGhpcy55UmFkaXVzID0ganNvbi55UmFkaXVzO1xcblxcblxcdFxcdHRoaXMuYVN0YXJ0QW5nbGUgPSBqc29uLmFTdGFydEFuZ2xlO1xcblxcdFxcdHRoaXMuYUVuZEFuZ2xlID0ganNvbi5hRW5kQW5nbGU7XFxuXFxuXFx0XFx0dGhpcy5hQ2xvY2t3aXNlID0ganNvbi5hQ2xvY2t3aXNlO1xcblxcblxcdFxcdHRoaXMuYVJvdGF0aW9uID0ganNvbi5hUm90YXRpb247XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBBcmNDdXJ2ZSggYVgsIGFZLCBhUmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlICkge1xcblxcblxcdFxcdEVsbGlwc2VDdXJ2ZS5jYWxsKCB0aGlzLCBhWCwgYVksIGFSYWRpdXMsIGFSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnQXJjQ3VydmUnO1xcblxcblxcdH1cXG5cXG5cXHRBcmNDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFbGxpcHNlQ3VydmUucHJvdG90eXBlICk7XFxuXFx0QXJjQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXJjQ3VydmU7XFxuXFxuXFx0QXJjQ3VydmUucHJvdG90eXBlLmlzQXJjQ3VydmUgPSB0cnVlO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3Igeno4NSBodHRwczovL2dpdGh1Yi5jb20veno4NVxcblxcdCAqXFxuXFx0ICogQ2VudHJpcGV0YWwgQ2F0bXVsbFJvbSBDdXJ2ZSAtIHdoaWNoIGlzIHVzZWZ1bCBmb3IgYXZvaWRpbmdcXG5cXHQgKiBjdXNwcyBhbmQgc2VsZi1pbnRlcnNlY3Rpb25zIGluIG5vbi11bmlmb3JtIGNhdG11bGwgcm9tIGN1cnZlcy5cXG5cXHQgKiBodHRwOi8vd3d3LmNlbXl1a3NlbC5jb20vcmVzZWFyY2gvY2F0bXVsbHJvbV9wYXJhbS9jYXRtdWxscm9tLnBkZlxcblxcdCAqXFxuXFx0ICogY3VydmUudHlwZSBhY2NlcHRzIGNlbnRyaXBldGFsKGRlZmF1bHQpLCBjaG9yZGFsIGFuZCBjYXRtdWxscm9tXFxuXFx0ICogY3VydmUudGVuc2lvbiBpcyB1c2VkIGZvciBjYXRtdWxscm9tIHdoaWNoIGRlZmF1bHRzIHRvIDAuNVxcblxcdCAqL1xcblxcblxcblxcdC8qXFxuXFx0QmFzZWQgb24gYW4gb3B0aW1pemVkIGMrKyBzb2x1dGlvbiBpblxcblxcdCAtIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTQ4OTczNi9jYXRtdWxsLXJvbS1jdXJ2ZS13aXRoLW5vLWN1c3BzLWFuZC1uby1zZWxmLWludGVyc2VjdGlvbnMvXFxuXFx0IC0gaHR0cDovL2lkZW9uZS5jb20vTm9FYlZNXFxuXFxuXFx0VGhpcyBDdWJpY1BvbHkgY2xhc3MgY291bGQgYmUgdXNlZCBmb3IgcmV1c2luZyBzb21lIHZhcmlhYmxlcyBhbmQgY2FsY3VsYXRpb25zLFxcblxcdGJ1dCBmb3IgdGhyZWUuanMgY3VydmUgdXNlLCBpdCBjb3VsZCBiZSBwb3NzaWJsZSBpbmxpbmVkIGFuZCBmbGF0dGVuIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gY2FsbFxcblxcdHdoaWNoIGNhbiBiZSBwbGFjZWQgaW4gQ3VydmVVdGlscy5cXG5cXHQqL1xcblxcblxcdGZ1bmN0aW9uIEN1YmljUG9seSgpIHtcXG5cXG5cXHRcXHR2YXIgYzAgPSAwLCBjMSA9IDAsIGMyID0gMCwgYzMgPSAwO1xcblxcblxcdFxcdC8qXFxuXFx0XFx0ICogQ29tcHV0ZSBjb2VmZmljaWVudHMgZm9yIGEgY3ViaWMgcG9seW5vbWlhbFxcblxcdFxcdCAqICAgcChzKSA9IGMwICsgYzEqcyArIGMyKnNeMiArIGMzKnNeM1xcblxcdFxcdCAqIHN1Y2ggdGhhdFxcblxcdFxcdCAqICAgcCgwKSA9IHgwLCBwKDEpID0geDFcXG5cXHRcXHQgKiAgYW5kXFxuXFx0XFx0ICogICBwJygwKSA9IHQwLCBwJygxKSA9IHQxLlxcblxcdFxcdCAqL1xcblxcdFxcdGZ1bmN0aW9uIGluaXQoIHgwLCB4MSwgdDAsIHQxICkge1xcblxcblxcdFxcdFxcdGMwID0geDA7XFxuXFx0XFx0XFx0YzEgPSB0MDtcXG5cXHRcXHRcXHRjMiA9IC0gMyAqIHgwICsgMyAqIHgxIC0gMiAqIHQwIC0gdDE7XFxuXFx0XFx0XFx0YzMgPSAyICogeDAgLSAyICogeDEgKyB0MCArIHQxO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4ge1xcblxcblxcdFxcdFxcdGluaXRDYXRtdWxsUm9tOiBmdW5jdGlvbiAoIHgwLCB4MSwgeDIsIHgzLCB0ZW5zaW9uICkge1xcblxcblxcdFxcdFxcdFxcdGluaXQoIHgxLCB4MiwgdGVuc2lvbiAqICggeDIgLSB4MCApLCB0ZW5zaW9uICogKCB4MyAtIHgxICkgKTtcXG5cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdGluaXROb251bmlmb3JtQ2F0bXVsbFJvbTogZnVuY3Rpb24gKCB4MCwgeDEsIHgyLCB4MywgZHQwLCBkdDEsIGR0MiApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBjb21wdXRlIHRhbmdlbnRzIHdoZW4gcGFyYW1ldGVyaXplZCBpbiBbdDEsdDJdXFxuXFx0XFx0XFx0XFx0dmFyIHQxID0gKCB4MSAtIHgwICkgLyBkdDAgLSAoIHgyIC0geDAgKSAvICggZHQwICsgZHQxICkgKyAoIHgyIC0geDEgKSAvIGR0MTtcXG5cXHRcXHRcXHRcXHR2YXIgdDIgPSAoIHgyIC0geDEgKSAvIGR0MSAtICggeDMgLSB4MSApIC8gKCBkdDEgKyBkdDIgKSArICggeDMgLSB4MiApIC8gZHQyO1xcblxcblxcdFxcdFxcdFxcdC8vIHJlc2NhbGUgdGFuZ2VudHMgZm9yIHBhcmFtZXRyaXphdGlvbiBpbiBbMCwxXVxcblxcdFxcdFxcdFxcdHQxICo9IGR0MTtcXG5cXHRcXHRcXHRcXHR0MiAqPSBkdDE7XFxuXFxuXFx0XFx0XFx0XFx0aW5pdCggeDEsIHgyLCB0MSwgdDIgKTtcXG5cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdGNhbGM6IGZ1bmN0aW9uICggdCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdDIgPSB0ICogdDtcXG5cXHRcXHRcXHRcXHR2YXIgdDMgPSB0MiAqIHQ7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGMwICsgYzEgKiB0ICsgYzIgKiB0MiArIGMzICogdDM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdC8vXFxuXFxuXFx0dmFyIHRtcCA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0dmFyIHB4ID0gbmV3IEN1YmljUG9seSgpO1xcblxcdHZhciBweSA9IG5ldyBDdWJpY1BvbHkoKTtcXG5cXHR2YXIgcHogPSBuZXcgQ3ViaWNQb2x5KCk7XFxuXFxuXFx0ZnVuY3Rpb24gQ2F0bXVsbFJvbUN1cnZlMyggcG9pbnRzLCBjbG9zZWQsIGN1cnZlVHlwZSwgdGVuc2lvbiApIHtcXG5cXG5cXHRcXHRDdXJ2ZS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0NhdG11bGxSb21DdXJ2ZTMnO1xcblxcblxcdFxcdHRoaXMucG9pbnRzID0gcG9pbnRzIHx8IFtdO1xcblxcdFxcdHRoaXMuY2xvc2VkID0gY2xvc2VkIHx8IGZhbHNlO1xcblxcdFxcdHRoaXMuY3VydmVUeXBlID0gY3VydmVUeXBlIHx8ICdjZW50cmlwZXRhbCc7XFxuXFx0XFx0dGhpcy50ZW5zaW9uID0gdGVuc2lvbiB8fCAwLjU7XFxuXFxuXFx0fVxcblxcblxcdENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XFxuXFx0Q2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYXRtdWxsUm9tQ3VydmUzO1xcblxcblxcdENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlLmlzQ2F0bXVsbFJvbUN1cnZlMyA9IHRydWU7XFxuXFxuXFx0Q2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzO1xcblxcdFxcdHZhciBsID0gcG9pbnRzLmxlbmd0aDtcXG5cXG5cXHRcXHR2YXIgcCA9ICggbCAtICggdGhpcy5jbG9zZWQgPyAwIDogMSApICkgKiB0O1xcblxcdFxcdHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHAgKTtcXG5cXHRcXHR2YXIgd2VpZ2h0ID0gcCAtIGludFBvaW50O1xcblxcblxcdFxcdGlmICggdGhpcy5jbG9zZWQgKSB7XFxuXFxuXFx0XFx0XFx0aW50UG9pbnQgKz0gaW50UG9pbnQgPiAwID8gMCA6ICggTWF0aC5mbG9vciggTWF0aC5hYnMoIGludFBvaW50ICkgLyBwb2ludHMubGVuZ3RoICkgKyAxICkgKiBwb2ludHMubGVuZ3RoO1xcblxcblxcdFxcdH0gZWxzZSBpZiAoIHdlaWdodCA9PT0gMCAmJiBpbnRQb2ludCA9PT0gbCAtIDEgKSB7XFxuXFxuXFx0XFx0XFx0aW50UG9pbnQgPSBsIC0gMjtcXG5cXHRcXHRcXHR3ZWlnaHQgPSAxO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgcDAsIHAxLCBwMiwgcDM7IC8vIDQgcG9pbnRzXFxuXFxuXFx0XFx0aWYgKCB0aGlzLmNsb3NlZCB8fCBpbnRQb2ludCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0cDAgPSBwb2ludHNbICggaW50UG9pbnQgLSAxICkgJSBsIF07XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHQvLyBleHRyYXBvbGF0ZSBmaXJzdCBwb2ludFxcblxcdFxcdFxcdHRtcC5zdWJWZWN0b3JzKCBwb2ludHNbIDAgXSwgcG9pbnRzWyAxIF0gKS5hZGQoIHBvaW50c1sgMCBdICk7XFxuXFx0XFx0XFx0cDAgPSB0bXA7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHAxID0gcG9pbnRzWyBpbnRQb2ludCAlIGwgXTtcXG5cXHRcXHRwMiA9IHBvaW50c1sgKCBpbnRQb2ludCArIDEgKSAlIGwgXTtcXG5cXG5cXHRcXHRpZiAoIHRoaXMuY2xvc2VkIHx8IGludFBvaW50ICsgMiA8IGwgKSB7XFxuXFxuXFx0XFx0XFx0cDMgPSBwb2ludHNbICggaW50UG9pbnQgKyAyICkgJSBsIF07XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHQvLyBleHRyYXBvbGF0ZSBsYXN0IHBvaW50XFxuXFx0XFx0XFx0dG1wLnN1YlZlY3RvcnMoIHBvaW50c1sgbCAtIDEgXSwgcG9pbnRzWyBsIC0gMiBdICkuYWRkKCBwb2ludHNbIGwgLSAxIF0gKTtcXG5cXHRcXHRcXHRwMyA9IHRtcDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCB0aGlzLmN1cnZlVHlwZSA9PT0gJ2NlbnRyaXBldGFsJyB8fCB0aGlzLmN1cnZlVHlwZSA9PT0gJ2Nob3JkYWwnICkge1xcblxcblxcdFxcdFxcdC8vIGluaXQgQ2VudHJpcGV0YWwgLyBDaG9yZGFsIENhdG11bGwtUm9tXFxuXFx0XFx0XFx0dmFyIHBvdyA9IHRoaXMuY3VydmVUeXBlID09PSAnY2hvcmRhbCcgPyAwLjUgOiAwLjI1O1xcblxcdFxcdFxcdHZhciBkdDAgPSBNYXRoLnBvdyggcDAuZGlzdGFuY2VUb1NxdWFyZWQoIHAxICksIHBvdyApO1xcblxcdFxcdFxcdHZhciBkdDEgPSBNYXRoLnBvdyggcDEuZGlzdGFuY2VUb1NxdWFyZWQoIHAyICksIHBvdyApO1xcblxcdFxcdFxcdHZhciBkdDIgPSBNYXRoLnBvdyggcDIuZGlzdGFuY2VUb1NxdWFyZWQoIHAzICksIHBvdyApO1xcblxcblxcdFxcdFxcdC8vIHNhZmV0eSBjaGVjayBmb3IgcmVwZWF0ZWQgcG9pbnRzXFxuXFx0XFx0XFx0aWYgKCBkdDEgPCAxZS00ICkgZHQxID0gMS4wO1xcblxcdFxcdFxcdGlmICggZHQwIDwgMWUtNCApIGR0MCA9IGR0MTtcXG5cXHRcXHRcXHRpZiAoIGR0MiA8IDFlLTQgKSBkdDIgPSBkdDE7XFxuXFxuXFx0XFx0XFx0cHguaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC54LCBwMS54LCBwMi54LCBwMy54LCBkdDAsIGR0MSwgZHQyICk7XFxuXFx0XFx0XFx0cHkuaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC55LCBwMS55LCBwMi55LCBwMy55LCBkdDAsIGR0MSwgZHQyICk7XFxuXFx0XFx0XFx0cHouaW5pdE5vbnVuaWZvcm1DYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCBkdDAsIGR0MSwgZHQyICk7XFxuXFxuXFx0XFx0fSBlbHNlIGlmICggdGhpcy5jdXJ2ZVR5cGUgPT09ICdjYXRtdWxscm9tJyApIHtcXG5cXG5cXHRcXHRcXHRweC5pbml0Q2F0bXVsbFJvbSggcDAueCwgcDEueCwgcDIueCwgcDMueCwgdGhpcy50ZW5zaW9uICk7XFxuXFx0XFx0XFx0cHkuaW5pdENhdG11bGxSb20oIHAwLnksIHAxLnksIHAyLnksIHAzLnksIHRoaXMudGVuc2lvbiApO1xcblxcdFxcdFxcdHB6LmluaXRDYXRtdWxsUm9tKCBwMC56LCBwMS56LCBwMi56LCBwMy56LCB0aGlzLnRlbnNpb24gKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cG9pbnQuc2V0KFxcblxcdFxcdFxcdHB4LmNhbGMoIHdlaWdodCApLFxcblxcdFxcdFxcdHB5LmNhbGMoIHdlaWdodCApLFxcblxcdFxcdFxcdHB6LmNhbGMoIHdlaWdodCApXFxuXFx0XFx0KTtcXG5cXG5cXHRcXHRyZXR1cm4gcG9pbnQ7XFxuXFxuXFx0fTtcXG5cXG5cXHRDYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0Q3VydmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0dGhpcy5wb2ludHMgPSBbXTtcXG5cXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzb3VyY2UucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHBvaW50ID0gc291cmNlLnBvaW50c1sgaSBdO1xcblxcblxcdFxcdFxcdHRoaXMucG9pbnRzLnB1c2goIHBvaW50LmNsb25lKCkgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5jbG9zZWQgPSBzb3VyY2UuY2xvc2VkO1xcblxcdFxcdHRoaXMuY3VydmVUeXBlID0gc291cmNlLmN1cnZlVHlwZTtcXG5cXHRcXHR0aGlzLnRlbnNpb24gPSBzb3VyY2UudGVuc2lvbjtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xcblxcblxcdFxcdGRhdGEucG9pbnRzID0gW107XFxuXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcG9pbnQgPSB0aGlzLnBvaW50c1sgaSBdO1xcblxcdFxcdFxcdGRhdGEucG9pbnRzLnB1c2goIHBvaW50LnRvQXJyYXkoKSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRkYXRhLmNsb3NlZCA9IHRoaXMuY2xvc2VkO1xcblxcdFxcdGRhdGEuY3VydmVUeXBlID0gdGhpcy5jdXJ2ZVR5cGU7XFxuXFx0XFx0ZGF0YS50ZW5zaW9uID0gdGhpcy50ZW5zaW9uO1xcblxcblxcdFxcdHJldHVybiBkYXRhO1xcblxcblxcdH07XFxuXFxuXFx0Q2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XFxuXFxuXFx0XFx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcXG5cXG5cXHRcXHR0aGlzLnBvaW50cyA9IFtdO1xcblxcblxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ucG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHBvaW50ID0ganNvbi5wb2ludHNbIGkgXTtcXG5cXHRcXHRcXHR0aGlzLnBvaW50cy5wdXNoKCBuZXcgVmVjdG9yMygpLmZyb21BcnJheSggcG9pbnQgKSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLmNsb3NlZCA9IGpzb24uY2xvc2VkO1xcblxcdFxcdHRoaXMuY3VydmVUeXBlID0ganNvbi5jdXJ2ZVR5cGU7XFxuXFx0XFx0dGhpcy50ZW5zaW9uID0ganNvbi50ZW5zaW9uO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xcblxcdCAqXFxuXFx0ICogQmV6aWVyIEN1cnZlcyBmb3JtdWxhcyBvYnRhaW5lZCBmcm9tXFxuXFx0ICogaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Cw6l6aWVyX2N1cnZlXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gQ2F0bXVsbFJvbSggdCwgcDAsIHAxLCBwMiwgcDMgKSB7XFxuXFxuXFx0XFx0dmFyIHYwID0gKCBwMiAtIHAwICkgKiAwLjU7XFxuXFx0XFx0dmFyIHYxID0gKCBwMyAtIHAxICkgKiAwLjU7XFxuXFx0XFx0dmFyIHQyID0gdCAqIHQ7XFxuXFx0XFx0dmFyIHQzID0gdCAqIHQyO1xcblxcdFxcdHJldHVybiAoIDIgKiBwMSAtIDIgKiBwMiArIHYwICsgdjEgKSAqIHQzICsgKCAtIDMgKiBwMSArIDMgKiBwMiAtIDIgKiB2MCAtIHYxICkgKiB0MiArIHYwICogdCArIHAxO1xcblxcblxcdH1cXG5cXG5cXHQvL1xcblxcblxcdGZ1bmN0aW9uIFF1YWRyYXRpY0JlemllclAwKCB0LCBwICkge1xcblxcblxcdFxcdHZhciBrID0gMSAtIHQ7XFxuXFx0XFx0cmV0dXJuIGsgKiBrICogcDtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyUDEoIHQsIHAgKSB7XFxuXFxuXFx0XFx0cmV0dXJuIDIgKiAoIDEgLSB0ICkgKiB0ICogcDtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyUDIoIHQsIHAgKSB7XFxuXFxuXFx0XFx0cmV0dXJuIHQgKiB0ICogcDtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyKCB0LCBwMCwgcDEsIHAyICkge1xcblxcblxcdFxcdHJldHVybiBRdWFkcmF0aWNCZXppZXJQMCggdCwgcDAgKSArIFF1YWRyYXRpY0JlemllclAxKCB0LCBwMSApICtcXG5cXHRcXHRcXHRRdWFkcmF0aWNCZXppZXJQMiggdCwgcDIgKTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly9cXG5cXG5cXHRmdW5jdGlvbiBDdWJpY0JlemllclAwKCB0LCBwICkge1xcblxcblxcdFxcdHZhciBrID0gMSAtIHQ7XFxuXFx0XFx0cmV0dXJuIGsgKiBrICogayAqIHA7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIEN1YmljQmV6aWVyUDEoIHQsIHAgKSB7XFxuXFxuXFx0XFx0dmFyIGsgPSAxIC0gdDtcXG5cXHRcXHRyZXR1cm4gMyAqIGsgKiBrICogdCAqIHA7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIEN1YmljQmV6aWVyUDIoIHQsIHAgKSB7XFxuXFxuXFx0XFx0cmV0dXJuIDMgKiAoIDEgLSB0ICkgKiB0ICogdCAqIHA7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIEN1YmljQmV6aWVyUDMoIHQsIHAgKSB7XFxuXFxuXFx0XFx0cmV0dXJuIHQgKiB0ICogdCAqIHA7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIEN1YmljQmV6aWVyKCB0LCBwMCwgcDEsIHAyLCBwMyApIHtcXG5cXG5cXHRcXHRyZXR1cm4gQ3ViaWNCZXppZXJQMCggdCwgcDAgKSArIEN1YmljQmV6aWVyUDEoIHQsIHAxICkgKyBDdWJpY0JlemllclAyKCB0LCBwMiApICtcXG5cXHRcXHRcXHRDdWJpY0JlemllclAzKCB0LCBwMyApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBDdWJpY0JlemllckN1cnZlKCB2MCwgdjEsIHYyLCB2MyApIHtcXG5cXG5cXHRcXHRDdXJ2ZS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0N1YmljQmV6aWVyQ3VydmUnO1xcblxcblxcdFxcdHRoaXMudjAgPSB2MCB8fCBuZXcgVmVjdG9yMigpO1xcblxcdFxcdHRoaXMudjEgPSB2MSB8fCBuZXcgVmVjdG9yMigpO1xcblxcdFxcdHRoaXMudjIgPSB2MiB8fCBuZXcgVmVjdG9yMigpO1xcblxcdFxcdHRoaXMudjMgPSB2MyB8fCBuZXcgVmVjdG9yMigpO1xcblxcblxcdH1cXG5cXG5cXHRDdWJpY0JlemllckN1cnZlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xcblxcdEN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3ViaWNCZXppZXJDdXJ2ZTtcXG5cXG5cXHRDdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5pc0N1YmljQmV6aWVyQ3VydmUgPSB0cnVlO1xcblxcblxcdEN1YmljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xcblxcblxcdFxcdHZhciB2MCA9IHRoaXMudjAsIHYxID0gdGhpcy52MSwgdjIgPSB0aGlzLnYyLCB2MyA9IHRoaXMudjM7XFxuXFxuXFx0XFx0cG9pbnQuc2V0KFxcblxcdFxcdFxcdEN1YmljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54LCB2My54ICksXFxuXFx0XFx0XFx0Q3ViaWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnksIHYzLnkgKVxcblxcdFxcdCk7XFxuXFxuXFx0XFx0cmV0dXJuIHBvaW50O1xcblxcblxcdH07XFxuXFxuXFx0Q3ViaWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdHRoaXMudjAuY29weSggc291cmNlLnYwICk7XFxuXFx0XFx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcXG5cXHRcXHR0aGlzLnYyLmNvcHkoIHNvdXJjZS52MiApO1xcblxcdFxcdHRoaXMudjMuY29weSggc291cmNlLnYzICk7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHRDdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XFxuXFx0XFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xcblxcdFxcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcXG5cXHRcXHRkYXRhLnYzID0gdGhpcy52My50b0FycmF5KCk7XFxuXFxuXFx0XFx0cmV0dXJuIGRhdGE7XFxuXFxuXFx0fTtcXG5cXG5cXHRDdWJpY0JlemllckN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcXG5cXG5cXHRcXHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xcblxcblxcdFxcdHRoaXMudjAuZnJvbUFycmF5KCBqc29uLnYwICk7XFxuXFx0XFx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcXG5cXHRcXHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xcblxcdFxcdHRoaXMudjMuZnJvbUFycmF5KCBqc29uLnYzICk7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBDdWJpY0JlemllckN1cnZlMyggdjAsIHYxLCB2MiwgdjMgKSB7XFxuXFxuXFx0XFx0Q3VydmUuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdDdWJpY0JlemllckN1cnZlMyc7XFxuXFxuXFx0XFx0dGhpcy52MCA9IHYwIHx8IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dGhpcy52MSA9IHYxIHx8IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dGhpcy52MiA9IHYyIHx8IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dGhpcy52MyA9IHYzIHx8IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0fVxcblxcblxcdEN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xcblxcdEN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEN1YmljQmV6aWVyQ3VydmUzO1xcblxcblxcdEN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5pc0N1YmljQmV6aWVyQ3VydmUzID0gdHJ1ZTtcXG5cXG5cXHRDdWJpY0JlemllckN1cnZlMy5wcm90b3R5cGUuZ2V0UG9pbnQgPSBmdW5jdGlvbiAoIHQsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdHZhciBwb2ludCA9IG9wdGlvbmFsVGFyZ2V0IHx8IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0dmFyIHYwID0gdGhpcy52MCwgdjEgPSB0aGlzLnYxLCB2MiA9IHRoaXMudjIsIHYzID0gdGhpcy52MztcXG5cXG5cXHRcXHRwb2ludC5zZXQoXFxuXFx0XFx0XFx0Q3ViaWNCZXppZXIoIHQsIHYwLngsIHYxLngsIHYyLngsIHYzLnggKSxcXG5cXHRcXHRcXHRDdWJpY0JlemllciggdCwgdjAueSwgdjEueSwgdjIueSwgdjMueSApLFxcblxcdFxcdFxcdEN1YmljQmV6aWVyKCB0LCB2MC56LCB2MS56LCB2Mi56LCB2My56IClcXG5cXHRcXHQpO1xcblxcblxcdFxcdHJldHVybiBwb2ludDtcXG5cXG5cXHR9O1xcblxcblxcdEN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0Q3VydmUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0dGhpcy52MC5jb3B5KCBzb3VyY2UudjAgKTtcXG5cXHRcXHR0aGlzLnYxLmNvcHkoIHNvdXJjZS52MSApO1xcblxcdFxcdHRoaXMudjIuY29weSggc291cmNlLnYyICk7XFxuXFx0XFx0dGhpcy52My5jb3B5KCBzb3VyY2UudjMgKTtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdEN1YmljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XFxuXFx0XFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xcblxcdFxcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcXG5cXHRcXHRkYXRhLnYzID0gdGhpcy52My50b0FycmF5KCk7XFxuXFxuXFx0XFx0cmV0dXJuIGRhdGE7XFxuXFxuXFx0fTtcXG5cXG5cXHRDdWJpY0JlemllckN1cnZlMy5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XFxuXFxuXFx0XFx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcXG5cXG5cXHRcXHR0aGlzLnYwLmZyb21BcnJheSgganNvbi52MCApO1xcblxcdFxcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XFxuXFx0XFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcXG5cXHRcXHR0aGlzLnYzLmZyb21BcnJheSgganNvbi52MyApO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFx0ZnVuY3Rpb24gTGluZUN1cnZlKCB2MSwgdjIgKSB7XFxuXFxuXFx0XFx0Q3VydmUuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdMaW5lQ3VydmUnO1xcblxcblxcdFxcdHRoaXMudjEgPSB2MSB8fCBuZXcgVmVjdG9yMigpO1xcblxcdFxcdHRoaXMudjIgPSB2MiB8fCBuZXcgVmVjdG9yMigpO1xcblxcblxcdH1cXG5cXG5cXHRMaW5lQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XFxuXFx0TGluZUN1cnZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVDdXJ2ZTtcXG5cXG5cXHRMaW5lQ3VydmUucHJvdG90eXBlLmlzTGluZUN1cnZlID0gdHJ1ZTtcXG5cXG5cXHRMaW5lQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xcblxcblxcdFxcdGlmICggdCA9PT0gMSApIHtcXG5cXG5cXHRcXHRcXHRwb2ludC5jb3B5KCB0aGlzLnYyICk7XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRwb2ludC5jb3B5KCB0aGlzLnYyICkuc3ViKCB0aGlzLnYxICk7XFxuXFx0XFx0XFx0cG9pbnQubXVsdGlwbHlTY2FsYXIoIHQgKS5hZGQoIHRoaXMudjEgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHBvaW50O1xcblxcblxcdH07XFxuXFxuXFx0Ly8gTGluZSBjdXJ2ZSBpcyBsaW5lYXIsIHNvIHdlIGNhbiBvdmVyd3JpdGUgZGVmYXVsdCBnZXRQb2ludEF0XFxuXFxuXFx0TGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludEF0ID0gZnVuY3Rpb24gKCB1LCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5nZXRQb2ludCggdSwgb3B0aW9uYWxUYXJnZXQgKTtcXG5cXG5cXHR9O1xcblxcblxcdExpbmVDdXJ2ZS5wcm90b3R5cGUuZ2V0VGFuZ2VudCA9IGZ1bmN0aW9uICggLyogdCAqLyApIHtcXG5cXG5cXHRcXHR2YXIgdGFuZ2VudCA9IHRoaXMudjIuY2xvbmUoKS5zdWIoIHRoaXMudjEgKTtcXG5cXG5cXHRcXHRyZXR1cm4gdGFuZ2VudC5ub3JtYWxpemUoKTtcXG5cXG5cXHR9O1xcblxcblxcdExpbmVDdXJ2ZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XFxuXFx0XFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdExpbmVDdXJ2ZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xcblxcdFxcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcXG5cXG5cXHRcXHRyZXR1cm4gZGF0YTtcXG5cXG5cXHR9O1xcblxcblxcdExpbmVDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XFxuXFxuXFx0XFx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcXG5cXG5cXHRcXHR0aGlzLnYxLmZyb21BcnJheSgganNvbi52MSApO1xcblxcdFxcdHRoaXMudjIuZnJvbUFycmF5KCBqc29uLnYyICk7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBMaW5lQ3VydmUzKCB2MSwgdjIgKSB7XFxuXFxuXFx0XFx0Q3VydmUuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdMaW5lQ3VydmUzJztcXG5cXG5cXHRcXHR0aGlzLnYxID0gdjEgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR0aGlzLnYyID0gdjIgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHR9XFxuXFxuXFx0TGluZUN1cnZlMy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcXG5cXHRMaW5lQ3VydmUzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExpbmVDdXJ2ZTM7XFxuXFxuXFx0TGluZUN1cnZlMy5wcm90b3R5cGUuaXNMaW5lQ3VydmUzID0gdHJ1ZTtcXG5cXG5cXHRMaW5lQ3VydmUzLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRpZiAoIHQgPT09IDEgKSB7XFxuXFxuXFx0XFx0XFx0cG9pbnQuY29weSggdGhpcy52MiApO1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0cG9pbnQuY29weSggdGhpcy52MiApLnN1YiggdGhpcy52MSApO1xcblxcdFxcdFxcdHBvaW50Lm11bHRpcGx5U2NhbGFyKCB0ICkuYWRkKCB0aGlzLnYxICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBwb2ludDtcXG5cXG5cXHR9O1xcblxcblxcdC8vIExpbmUgY3VydmUgaXMgbGluZWFyLCBzbyB3ZSBjYW4gb3ZlcndyaXRlIGRlZmF1bHQgZ2V0UG9pbnRBdFxcblxcblxcdExpbmVDdXJ2ZTMucHJvdG90eXBlLmdldFBvaW50QXQgPSBmdW5jdGlvbiAoIHUsIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdHJldHVybiB0aGlzLmdldFBvaW50KCB1LCBvcHRpb25hbFRhcmdldCApO1xcblxcblxcdH07XFxuXFxuXFx0TGluZUN1cnZlMy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XFxuXFx0XFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdExpbmVDdXJ2ZTMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xcblxcblxcdFxcdGRhdGEudjEgPSB0aGlzLnYxLnRvQXJyYXkoKTtcXG5cXHRcXHRkYXRhLnYyID0gdGhpcy52Mi50b0FycmF5KCk7XFxuXFxuXFx0XFx0cmV0dXJuIGRhdGE7XFxuXFxuXFx0fTtcXG5cXG5cXHRMaW5lQ3VydmUzLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcXG5cXG5cXHRcXHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xcblxcblxcdFxcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XFxuXFx0XFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIFF1YWRyYXRpY0JlemllckN1cnZlKCB2MCwgdjEsIHYyICkge1xcblxcblxcdFxcdEN1cnZlLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnUXVhZHJhdGljQmV6aWVyQ3VydmUnO1xcblxcblxcdFxcdHRoaXMudjAgPSB2MCB8fCBuZXcgVmVjdG9yMigpO1xcblxcdFxcdHRoaXMudjEgPSB2MSB8fCBuZXcgVmVjdG9yMigpO1xcblxcdFxcdHRoaXMudjIgPSB2MiB8fCBuZXcgVmVjdG9yMigpO1xcblxcblxcdH1cXG5cXG5cXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcXG5cXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBRdWFkcmF0aWNCZXppZXJDdXJ2ZTtcXG5cXG5cXHRRdWFkcmF0aWNCZXppZXJDdXJ2ZS5wcm90b3R5cGUuaXNRdWFkcmF0aWNCZXppZXJDdXJ2ZSA9IHRydWU7XFxuXFxuXFx0UXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmdldFBvaW50ID0gZnVuY3Rpb24gKCB0LCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHR2YXIgcG9pbnQgPSBvcHRpb25hbFRhcmdldCB8fCBuZXcgVmVjdG9yMigpO1xcblxcblxcdFxcdHZhciB2MCA9IHRoaXMudjAsIHYxID0gdGhpcy52MSwgdjIgPSB0aGlzLnYyO1xcblxcblxcdFxcdHBvaW50LnNldChcXG5cXHRcXHRcXHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLngsIHYxLngsIHYyLnggKSxcXG5cXHRcXHRcXHRRdWFkcmF0aWNCZXppZXIoIHQsIHYwLnksIHYxLnksIHYyLnkgKVxcblxcdFxcdCk7XFxuXFxuXFx0XFx0cmV0dXJuIHBvaW50O1xcblxcblxcdH07XFxuXFxuXFx0UXVhZHJhdGljQmV6aWVyQ3VydmUucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRDdXJ2ZS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHR0aGlzLnYwLmNvcHkoIHNvdXJjZS52MCApO1xcblxcdFxcdHRoaXMudjEuY29weSggc291cmNlLnYxICk7XFxuXFx0XFx0dGhpcy52Mi5jb3B5KCBzb3VyY2UudjIgKTtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdFF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XFxuXFx0XFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xcblxcdFxcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcXG5cXG5cXHRcXHRyZXR1cm4gZGF0YTtcXG5cXG5cXHR9O1xcblxcblxcdFF1YWRyYXRpY0JlemllckN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcXG5cXG5cXHRcXHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xcblxcblxcdFxcdHRoaXMudjAuZnJvbUFycmF5KCBqc29uLnYwICk7XFxuXFx0XFx0dGhpcy52MS5mcm9tQXJyYXkoIGpzb24udjEgKTtcXG5cXHRcXHR0aGlzLnYyLmZyb21BcnJheSgganNvbi52MiApO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFx0ZnVuY3Rpb24gUXVhZHJhdGljQmV6aWVyQ3VydmUzKCB2MCwgdjEsIHYyICkge1xcblxcblxcdFxcdEN1cnZlLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnUXVhZHJhdGljQmV6aWVyQ3VydmUzJztcXG5cXG5cXHRcXHR0aGlzLnYwID0gdjAgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR0aGlzLnYxID0gdjEgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR0aGlzLnYyID0gdjIgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHR9XFxuXFxuXFx0UXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApO1xcblxcdFF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBRdWFkcmF0aWNCZXppZXJDdXJ2ZTM7XFxuXFxuXFx0UXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5pc1F1YWRyYXRpY0JlemllckN1cnZlMyA9IHRydWU7XFxuXFxuXFx0UXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHR2YXIgdjAgPSB0aGlzLnYwLCB2MSA9IHRoaXMudjEsIHYyID0gdGhpcy52MjtcXG5cXG5cXHRcXHRwb2ludC5zZXQoXFxuXFx0XFx0XFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC54LCB2MS54LCB2Mi54ICksXFxuXFx0XFx0XFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC55LCB2MS55LCB2Mi55ICksXFxuXFx0XFx0XFx0UXVhZHJhdGljQmV6aWVyKCB0LCB2MC56LCB2MS56LCB2Mi56IClcXG5cXHRcXHQpO1xcblxcblxcdFxcdHJldHVybiBwb2ludDtcXG5cXG5cXHR9O1xcblxcblxcdFF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdHRoaXMudjAuY29weSggc291cmNlLnYwICk7XFxuXFx0XFx0dGhpcy52MS5jb3B5KCBzb3VyY2UudjEgKTtcXG5cXHRcXHR0aGlzLnYyLmNvcHkoIHNvdXJjZS52MiApO1xcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFx0UXVhZHJhdGljQmV6aWVyQ3VydmUzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dmFyIGRhdGEgPSBDdXJ2ZS5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHRkYXRhLnYwID0gdGhpcy52MC50b0FycmF5KCk7XFxuXFx0XFx0ZGF0YS52MSA9IHRoaXMudjEudG9BcnJheSgpO1xcblxcdFxcdGRhdGEudjIgPSB0aGlzLnYyLnRvQXJyYXkoKTtcXG5cXG5cXHRcXHRyZXR1cm4gZGF0YTtcXG5cXG5cXHR9O1xcblxcblxcdFF1YWRyYXRpY0JlemllckN1cnZlMy5wcm90b3R5cGUuZnJvbUpTT04gPSBmdW5jdGlvbiAoIGpzb24gKSB7XFxuXFxuXFx0XFx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcXG5cXG5cXHRcXHR0aGlzLnYwLmZyb21BcnJheSgganNvbi52MCApO1xcblxcdFxcdHRoaXMudjEuZnJvbUFycmF5KCBqc29uLnYxICk7XFxuXFx0XFx0dGhpcy52Mi5mcm9tQXJyYXkoIGpzb24udjIgKTtcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIFNwbGluZUN1cnZlKCBwb2ludHMgLyogYXJyYXkgb2YgVmVjdG9yMiAqLyApIHtcXG5cXG5cXHRcXHRDdXJ2ZS5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1NwbGluZUN1cnZlJztcXG5cXG5cXHRcXHR0aGlzLnBvaW50cyA9IHBvaW50cyB8fCBbXTtcXG5cXG5cXHR9XFxuXFxuXFx0U3BsaW5lQ3VydmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ3VydmUucHJvdG90eXBlICk7XFxuXFx0U3BsaW5lQ3VydmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3BsaW5lQ3VydmU7XFxuXFxuXFx0U3BsaW5lQ3VydmUucHJvdG90eXBlLmlzU3BsaW5lQ3VydmUgPSB0cnVlO1xcblxcblxcdFNwbGluZUN1cnZlLnByb3RvdHlwZS5nZXRQb2ludCA9IGZ1bmN0aW9uICggdCwgb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0dmFyIHBvaW50ID0gb3B0aW9uYWxUYXJnZXQgfHwgbmV3IFZlY3RvcjIoKTtcXG5cXG5cXHRcXHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHM7XFxuXFx0XFx0dmFyIHAgPSAoIHBvaW50cy5sZW5ndGggLSAxICkgKiB0O1xcblxcblxcdFxcdHZhciBpbnRQb2ludCA9IE1hdGguZmxvb3IoIHAgKTtcXG5cXHRcXHR2YXIgd2VpZ2h0ID0gcCAtIGludFBvaW50O1xcblxcblxcdFxcdHZhciBwMCA9IHBvaW50c1sgaW50UG9pbnQgPT09IDAgPyBpbnRQb2ludCA6IGludFBvaW50IC0gMSBdO1xcblxcdFxcdHZhciBwMSA9IHBvaW50c1sgaW50UG9pbnQgXTtcXG5cXHRcXHR2YXIgcDIgPSBwb2ludHNbIGludFBvaW50ID4gcG9pbnRzLmxlbmd0aCAtIDIgPyBwb2ludHMubGVuZ3RoIC0gMSA6IGludFBvaW50ICsgMSBdO1xcblxcdFxcdHZhciBwMyA9IHBvaW50c1sgaW50UG9pbnQgPiBwb2ludHMubGVuZ3RoIC0gMyA/IHBvaW50cy5sZW5ndGggLSAxIDogaW50UG9pbnQgKyAyIF07XFxuXFxuXFx0XFx0cG9pbnQuc2V0KFxcblxcdFxcdFxcdENhdG11bGxSb20oIHdlaWdodCwgcDAueCwgcDEueCwgcDIueCwgcDMueCApLFxcblxcdFxcdFxcdENhdG11bGxSb20oIHdlaWdodCwgcDAueSwgcDEueSwgcDIueSwgcDMueSApXFxuXFx0XFx0KTtcXG5cXG5cXHRcXHRyZXR1cm4gcG9pbnQ7XFxuXFxuXFx0fTtcXG5cXG5cXHRTcGxpbmVDdXJ2ZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdHRoaXMucG9pbnRzID0gW107XFxuXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc291cmNlLnBvaW50cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdHZhciBwb2ludCA9IHNvdXJjZS5wb2ludHNbIGkgXTtcXG5cXG5cXHRcXHRcXHR0aGlzLnBvaW50cy5wdXNoKCBwb2ludC5jbG9uZSgpICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFx0U3BsaW5lQ3VydmUucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHR2YXIgZGF0YSA9IEN1cnZlLnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcyApO1xcblxcblxcdFxcdGRhdGEucG9pbnRzID0gW107XFxuXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gdGhpcy5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcG9pbnQgPSB0aGlzLnBvaW50c1sgaSBdO1xcblxcdFxcdFxcdGRhdGEucG9pbnRzLnB1c2goIHBvaW50LnRvQXJyYXkoKSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gZGF0YTtcXG5cXG5cXHR9O1xcblxcblxcdFNwbGluZUN1cnZlLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uICgganNvbiApIHtcXG5cXG5cXHRcXHRDdXJ2ZS5wcm90b3R5cGUuZnJvbUpTT04uY2FsbCggdGhpcywganNvbiApO1xcblxcblxcdFxcdHRoaXMucG9pbnRzID0gW107XFxuXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5wb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcG9pbnQgPSBqc29uLnBvaW50c1sgaSBdO1xcblxcdFxcdFxcdHRoaXMucG9pbnRzLnB1c2goIG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KCBwb2ludCApICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdH07XFxuXFxuXFxuXFxuXFx0dmFyIEN1cnZlcyA9IE9iamVjdC5mcmVlemUoe1xcblxcdFxcdEFyY0N1cnZlOiBBcmNDdXJ2ZSxcXG5cXHRcXHRDYXRtdWxsUm9tQ3VydmUzOiBDYXRtdWxsUm9tQ3VydmUzLFxcblxcdFxcdEN1YmljQmV6aWVyQ3VydmU6IEN1YmljQmV6aWVyQ3VydmUsXFxuXFx0XFx0Q3ViaWNCZXppZXJDdXJ2ZTM6IEN1YmljQmV6aWVyQ3VydmUzLFxcblxcdFxcdEVsbGlwc2VDdXJ2ZTogRWxsaXBzZUN1cnZlLFxcblxcdFxcdExpbmVDdXJ2ZTogTGluZUN1cnZlLFxcblxcdFxcdExpbmVDdXJ2ZTM6IExpbmVDdXJ2ZTMsXFxuXFx0XFx0UXVhZHJhdGljQmV6aWVyQ3VydmU6IFF1YWRyYXRpY0JlemllckN1cnZlLFxcblxcdFxcdFF1YWRyYXRpY0JlemllckN1cnZlMzogUXVhZHJhdGljQmV6aWVyQ3VydmUzLFxcblxcdFxcdFNwbGluZUN1cnZlOiBTcGxpbmVDdXJ2ZVxcblxcdH0pO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcXG5cXHQgKlxcblxcdCAqKi9cXG5cXG5cXHQvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG5cXHQgKlxcdEN1cnZlZCBQYXRoIC0gYSBjdXJ2ZSBwYXRoIGlzIHNpbXBseSBhIGFycmF5IG9mIGNvbm5lY3RlZFxcblxcdCAqICBjdXJ2ZXMsIGJ1dCByZXRhaW5zIHRoZSBhcGkgb2YgYSBjdXJ2ZVxcblxcdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG5cXG5cXHRmdW5jdGlvbiBDdXJ2ZVBhdGgoKSB7XFxuXFxuXFx0XFx0Q3VydmUuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdDdXJ2ZVBhdGgnO1xcblxcblxcdFxcdHRoaXMuY3VydmVzID0gW107XFxuXFx0XFx0dGhpcy5hdXRvQ2xvc2UgPSBmYWxzZTsgLy8gQXV0b21hdGljYWxseSBjbG9zZXMgdGhlIHBhdGhcXG5cXG5cXHR9XFxuXFxuXFx0Q3VydmVQYXRoLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEN1cnZlLnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IEN1cnZlUGF0aCxcXG5cXG5cXHRcXHRhZGQ6IGZ1bmN0aW9uICggY3VydmUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb3NlUGF0aDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIEFkZCBhIGxpbmUgY3VydmUgaWYgc3RhcnQgYW5kIGVuZCBvZiBsaW5lcyBhcmUgbm90IGNvbm5lY3RlZFxcblxcdFxcdFxcdHZhciBzdGFydFBvaW50ID0gdGhpcy5jdXJ2ZXNbIDAgXS5nZXRQb2ludCggMCApO1xcblxcdFxcdFxcdHZhciBlbmRQb2ludCA9IHRoaXMuY3VydmVzWyB0aGlzLmN1cnZlcy5sZW5ndGggLSAxIF0uZ2V0UG9pbnQoIDEgKTtcXG5cXG5cXHRcXHRcXHRpZiAoICEgc3RhcnRQb2ludC5lcXVhbHMoIGVuZFBvaW50ICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5jdXJ2ZXMucHVzaCggbmV3IExpbmVDdXJ2ZSggZW5kUG9pbnQsIHN0YXJ0UG9pbnQgKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIFRvIGdldCBhY2N1cmF0ZSBwb2ludCB3aXRoIHJlZmVyZW5jZSB0b1xcblxcdFxcdC8vIGVudGlyZSBwYXRoIGRpc3RhbmNlIGF0IHRpbWUgdCxcXG5cXHRcXHQvLyBmb2xsb3dpbmcgaGFzIHRvIGJlIGRvbmU6XFxuXFxuXFx0XFx0Ly8gMS4gTGVuZ3RoIG9mIGVhY2ggc3ViIHBhdGggaGF2ZSB0byBiZSBrbm93blxcblxcdFxcdC8vIDIuIExvY2F0ZSBhbmQgaWRlbnRpZnkgdHlwZSBvZiBjdXJ2ZVxcblxcdFxcdC8vIDMuIEdldCB0IGZvciB0aGUgY3VydmVcXG5cXHRcXHQvLyA0LiBSZXR1cm4gY3VydmUuZ2V0UG9pbnRBdCh0JylcXG5cXG5cXHRcXHRnZXRQb2ludDogZnVuY3Rpb24gKCB0ICkge1xcblxcblxcdFxcdFxcdHZhciBkID0gdCAqIHRoaXMuZ2V0TGVuZ3RoKCk7XFxuXFx0XFx0XFx0dmFyIGN1cnZlTGVuZ3RocyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XFxuXFx0XFx0XFx0dmFyIGkgPSAwO1xcblxcblxcdFxcdFxcdC8vIFRvIHRoaW5rIGFib3V0IGJvdW5kYXJpZXMgcG9pbnRzLlxcblxcblxcdFxcdFxcdHdoaWxlICggaSA8IGN1cnZlTGVuZ3Rocy5sZW5ndGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBjdXJ2ZUxlbmd0aHNbIGkgXSA+PSBkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBkaWZmID0gY3VydmVMZW5ndGhzWyBpIF0gLSBkO1xcblxcdFxcdFxcdFxcdFxcdHZhciBjdXJ2ZSA9IHRoaXMuY3VydmVzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHNlZ21lbnRMZW5ndGggPSBjdXJ2ZS5nZXRMZW5ndGgoKTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdSA9IHNlZ21lbnRMZW5ndGggPT09IDAgPyAwIDogMSAtIGRpZmYgLyBzZWdtZW50TGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBjdXJ2ZS5nZXRQb2ludEF0KCB1ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGkgKys7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBudWxsO1xcblxcblxcdFxcdFxcdC8vIGxvb3Agd2hlcmUgc3VtICE9IDAsIHN1bSA+IGQgLCBzdW0rMSA8ZFxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gV2UgY2Fubm90IHVzZSB0aGUgZGVmYXVsdCBUSFJFRS5DdXJ2ZSBnZXRQb2ludCgpIHdpdGggZ2V0TGVuZ3RoKCkgYmVjYXVzZSBpblxcblxcdFxcdC8vIFRIUkVFLkN1cnZlLCBnZXRMZW5ndGgoKSBkZXBlbmRzIG9uIGdldFBvaW50KCkgYnV0IGluIFRIUkVFLkN1cnZlUGF0aFxcblxcdFxcdC8vIGdldFBvaW50KCkgZGVwZW5kcyBvbiBnZXRMZW5ndGhcXG5cXG5cXHRcXHRnZXRMZW5ndGg6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgbGVucyA9IHRoaXMuZ2V0Q3VydmVMZW5ndGhzKCk7XFxuXFx0XFx0XFx0cmV0dXJuIGxlbnNbIGxlbnMubGVuZ3RoIC0gMSBdO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gY2FjaGVMZW5ndGhzIG11c3QgYmUgcmVjYWxjdWxhdGVkLlxcblxcdFxcdHVwZGF0ZUFyY0xlbmd0aHM6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXHRcXHRcXHR0aGlzLmNhY2hlTGVuZ3RocyA9IG51bGw7XFxuXFx0XFx0XFx0dGhpcy5nZXRDdXJ2ZUxlbmd0aHMoKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIENvbXB1dGUgbGVuZ3RocyBhbmQgY2FjaGUgdGhlbVxcblxcdFxcdC8vIFdlIGNhbm5vdCBvdmVyd3JpdGUgZ2V0TGVuZ3RocygpIGJlY2F1c2UgVXRvVCBtYXBwaW5nIHVzZXMgaXQuXFxuXFxuXFx0XFx0Z2V0Q3VydmVMZW5ndGhzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Ly8gV2UgdXNlIGNhY2hlIHZhbHVlcyBpZiBjdXJ2ZXMgYW5kIGNhY2hlIGFycmF5IGFyZSBzYW1lIGxlbmd0aFxcblxcblxcdFxcdFxcdGlmICggdGhpcy5jYWNoZUxlbmd0aHMgJiYgdGhpcy5jYWNoZUxlbmd0aHMubGVuZ3RoID09PSB0aGlzLmN1cnZlcy5sZW5ndGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuY2FjaGVMZW5ndGhzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBHZXQgbGVuZ3RoIG9mIHN1Yi1jdXJ2ZVxcblxcdFxcdFxcdC8vIFB1c2ggc3VtcyBpbnRvIGNhY2hlZCBhcnJheVxcblxcblxcdFxcdFxcdHZhciBsZW5ndGhzID0gW10sIHN1bXMgPSAwO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c3VtcyArPSB0aGlzLmN1cnZlc1sgaSBdLmdldExlbmd0aCgpO1xcblxcdFxcdFxcdFxcdGxlbmd0aHMucHVzaCggc3VtcyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmNhY2hlTGVuZ3RocyA9IGxlbmd0aHM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGxlbmd0aHM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRTcGFjZWRQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xcblxcblxcdFxcdFxcdGlmICggZGl2aXNpb25zID09PSB1bmRlZmluZWQgKSBkaXZpc2lvbnMgPSA0MDtcXG5cXG5cXHRcXHRcXHR2YXIgcG9pbnRzID0gW107XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDw9IGRpdmlzaW9uczsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRwb2ludHMucHVzaCggdGhpcy5nZXRQb2ludCggaSAvIGRpdmlzaW9ucyApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdGhpcy5hdXRvQ2xvc2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cG9pbnRzLnB1c2goIHBvaW50c1sgMCBdICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBwb2ludHM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRQb2ludHM6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xcblxcblxcdFxcdFxcdGRpdmlzaW9ucyA9IGRpdmlzaW9ucyB8fCAxMjtcXG5cXG5cXHRcXHRcXHR2YXIgcG9pbnRzID0gW10sIGxhc3Q7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBjdXJ2ZXMgPSB0aGlzLmN1cnZlczsgaSA8IGN1cnZlcy5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGN1cnZlID0gY3VydmVzWyBpIF07XFxuXFx0XFx0XFx0XFx0dmFyIHJlc29sdXRpb24gPSAoIGN1cnZlICYmIGN1cnZlLmlzRWxsaXBzZUN1cnZlICkgPyBkaXZpc2lvbnMgKiAyXFxuXFx0XFx0XFx0XFx0XFx0OiAoIGN1cnZlICYmIGN1cnZlLmlzTGluZUN1cnZlICkgPyAxXFxuXFx0XFx0XFx0XFx0XFx0XFx0OiAoIGN1cnZlICYmIGN1cnZlLmlzU3BsaW5lQ3VydmUgKSA/IGRpdmlzaW9ucyAqIGN1cnZlLnBvaW50cy5sZW5ndGhcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQ6IGRpdmlzaW9ucztcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcHRzID0gY3VydmUuZ2V0UG9pbnRzKCByZXNvbHV0aW9uICk7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwOyBqIDwgcHRzLmxlbmd0aDsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgcG9pbnQgPSBwdHNbIGogXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGxhc3QgJiYgbGFzdC5lcXVhbHMoIHBvaW50ICkgKSBjb250aW51ZTsgLy8gZW5zdXJlcyBubyBjb25zZWN1dGl2ZSBwb2ludHMgYXJlIGR1cGxpY2F0ZXNcXG5cXG5cXHRcXHRcXHRcXHRcXHRwb2ludHMucHVzaCggcG9pbnQgKTtcXG5cXHRcXHRcXHRcXHRcXHRsYXN0ID0gcG9pbnQ7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuYXV0b0Nsb3NlICYmIHBvaW50cy5sZW5ndGggPiAxICYmICEgcG9pbnRzWyBwb2ludHMubGVuZ3RoIC0gMSBdLmVxdWFscyggcG9pbnRzWyAwIF0gKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRwb2ludHMucHVzaCggcG9pbnRzWyAwIF0gKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHBvaW50cztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdFxcdEN1cnZlLnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdFxcdHRoaXMuY3VydmVzID0gW107XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gc291cmNlLmN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBjdXJ2ZSA9IHNvdXJjZS5jdXJ2ZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZS5jbG9uZSgpICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuYXV0b0Nsb3NlID0gc291cmNlLmF1dG9DbG9zZTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRvSlNPTjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBkYXRhID0gQ3VydmUucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0XFx0ZGF0YS5hdXRvQ2xvc2UgPSB0aGlzLmF1dG9DbG9zZTtcXG5cXHRcXHRcXHRkYXRhLmN1cnZlcyA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGN1cnZlID0gdGhpcy5jdXJ2ZXNbIGkgXTtcXG5cXHRcXHRcXHRcXHRkYXRhLmN1cnZlcy5wdXNoKCBjdXJ2ZS50b0pTT04oKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gZGF0YTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGZyb21KU09OOiBmdW5jdGlvbiAoIGpzb24gKSB7XFxuXFxuXFx0XFx0XFx0Q3VydmUucHJvdG90eXBlLmZyb21KU09OLmNhbGwoIHRoaXMsIGpzb24gKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmF1dG9DbG9zZSA9IGpzb24uYXV0b0Nsb3NlO1xcblxcdFxcdFxcdHRoaXMuY3VydmVzID0gW107XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgY3VydmUgPSBqc29uLmN1cnZlc1sgaSBdO1xcblxcdFxcdFxcdFxcdHRoaXMuY3VydmVzLnB1c2goIG5ldyBDdXJ2ZXNbIGN1cnZlLnR5cGUgXSgpLmZyb21KU09OKCBjdXJ2ZSApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xcblxcdCAqIENyZWF0ZXMgZnJlZSBmb3JtIDJkIHBhdGggdXNpbmcgc2VyaWVzIG9mIHBvaW50cywgbGluZXMgb3IgY3VydmVzLlxcblxcdCAqKi9cXG5cXG5cXHRmdW5jdGlvbiBQYXRoKCBwb2ludHMgKSB7XFxuXFxuXFx0XFx0Q3VydmVQYXRoLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnUGF0aCc7XFxuXFxuXFx0XFx0dGhpcy5jdXJyZW50UG9pbnQgPSBuZXcgVmVjdG9yMigpO1xcblxcblxcdFxcdGlmICggcG9pbnRzICkge1xcblxcblxcdFxcdFxcdHRoaXMuc2V0RnJvbVBvaW50cyggcG9pbnRzICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHRQYXRoLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEN1cnZlUGF0aC5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBQYXRoLFxcblxcblxcdFxcdHNldEZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xcblxcblxcdFxcdFxcdHRoaXMubW92ZVRvKCBwb2ludHNbIDAgXS54LCBwb2ludHNbIDAgXS55ICk7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAxLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5saW5lVG8oIHBvaW50c1sgaSBdLngsIHBvaW50c1sgaSBdLnkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRtb3ZlVG86IGZ1bmN0aW9uICggeCwgeSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmN1cnJlbnRQb2ludC5zZXQoIHgsIHkgKTsgLy8gVE9ETyBjb25zaWRlciByZWZlcmVuY2luZyB2ZWN0b3JzIGluc3RlYWQgb2YgY29weWluZz9cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGxpbmVUbzogZnVuY3Rpb24gKCB4LCB5ICkge1xcblxcblxcdFxcdFxcdHZhciBjdXJ2ZSA9IG5ldyBMaW5lQ3VydmUoIHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksIG5ldyBWZWN0b3IyKCB4LCB5ICkgKTtcXG5cXHRcXHRcXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xcblxcblxcdFxcdFxcdHRoaXMuY3VycmVudFBvaW50LnNldCggeCwgeSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24gKCBhQ1B4LCBhQ1B5LCBhWCwgYVkgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGN1cnZlID0gbmV3IFF1YWRyYXRpY0JlemllckN1cnZlKFxcblxcdFxcdFxcdFxcdHRoaXMuY3VycmVudFBvaW50LmNsb25lKCksXFxuXFx0XFx0XFx0XFx0bmV3IFZlY3RvcjIoIGFDUHgsIGFDUHkgKSxcXG5cXHRcXHRcXHRcXHRuZXcgVmVjdG9yMiggYVgsIGFZIClcXG5cXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdHRoaXMuY3VydmVzLnB1c2goIGN1cnZlICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5jdXJyZW50UG9pbnQuc2V0KCBhWCwgYVkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGJlemllckN1cnZlVG86IGZ1bmN0aW9uICggYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgY3VydmUgPSBuZXcgQ3ViaWNCZXppZXJDdXJ2ZShcXG5cXHRcXHRcXHRcXHR0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpLFxcblxcdFxcdFxcdFxcdG5ldyBWZWN0b3IyKCBhQ1AxeCwgYUNQMXkgKSxcXG5cXHRcXHRcXHRcXHRuZXcgVmVjdG9yMiggYUNQMngsIGFDUDJ5ICksXFxuXFx0XFx0XFx0XFx0bmV3IFZlY3RvcjIoIGFYLCBhWSApXFxuXFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xcblxcblxcdFxcdFxcdHRoaXMuY3VycmVudFBvaW50LnNldCggYVgsIGFZICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzcGxpbmVUaHJ1OiBmdW5jdGlvbiAoIHB0cyAvKkFycmF5IG9mIFZlY3RvciovICkge1xcblxcblxcdFxcdFxcdHZhciBucHRzID0gWyB0aGlzLmN1cnJlbnRQb2ludC5jbG9uZSgpIF0uY29uY2F0KCBwdHMgKTtcXG5cXG5cXHRcXHRcXHR2YXIgY3VydmUgPSBuZXcgU3BsaW5lQ3VydmUoIG5wdHMgKTtcXG5cXHRcXHRcXHR0aGlzLmN1cnZlcy5wdXNoKCBjdXJ2ZSApO1xcblxcblxcdFxcdFxcdHRoaXMuY3VycmVudFBvaW50LmNvcHkoIHB0c1sgcHRzLmxlbmd0aCAtIDEgXSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YXJjOiBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgeDAgPSB0aGlzLmN1cnJlbnRQb2ludC54O1xcblxcdFxcdFxcdHZhciB5MCA9IHRoaXMuY3VycmVudFBvaW50Lnk7XFxuXFxuXFx0XFx0XFx0dGhpcy5hYnNhcmMoIGFYICsgeDAsIGFZICsgeTAsIGFSYWRpdXMsXFxuXFx0XFx0XFx0XFx0YVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YWJzYXJjOiBmdW5jdGlvbiAoIGFYLCBhWSwgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmFic2VsbGlwc2UoIGFYLCBhWSwgYVJhZGl1cywgYVJhZGl1cywgYVN0YXJ0QW5nbGUsIGFFbmRBbmdsZSwgYUNsb2Nrd2lzZSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZWxsaXBzZTogZnVuY3Rpb24gKCBhWCwgYVksIHhSYWRpdXMsIHlSYWRpdXMsIGFTdGFydEFuZ2xlLCBhRW5kQW5nbGUsIGFDbG9ja3dpc2UsIGFSb3RhdGlvbiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgeDAgPSB0aGlzLmN1cnJlbnRQb2ludC54O1xcblxcdFxcdFxcdHZhciB5MCA9IHRoaXMuY3VycmVudFBvaW50Lnk7XFxuXFxuXFx0XFx0XFx0dGhpcy5hYnNlbGxpcHNlKCBhWCArIHgwLCBhWSArIHkwLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGFic2VsbGlwc2U6IGZ1bmN0aW9uICggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGN1cnZlID0gbmV3IEVsbGlwc2VDdXJ2ZSggYVgsIGFZLCB4UmFkaXVzLCB5UmFkaXVzLCBhU3RhcnRBbmdsZSwgYUVuZEFuZ2xlLCBhQ2xvY2t3aXNlLCBhUm90YXRpb24gKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuY3VydmVzLmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gaWYgYSBwcmV2aW91cyBjdXJ2ZSBpcyBwcmVzZW50LCBhdHRlbXB0IHRvIGpvaW5cXG5cXHRcXHRcXHRcXHR2YXIgZmlyc3RQb2ludCA9IGN1cnZlLmdldFBvaW50KCAwICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCAhIGZpcnN0UG9pbnQuZXF1YWxzKCB0aGlzLmN1cnJlbnRQb2ludCApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMubGluZVRvKCBmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5jdXJ2ZXMucHVzaCggY3VydmUgKTtcXG5cXG5cXHRcXHRcXHR2YXIgbGFzdFBvaW50ID0gY3VydmUuZ2V0UG9pbnQoIDEgKTtcXG5cXHRcXHRcXHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KCBsYXN0UG9pbnQgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdFxcdEN1cnZlUGF0aC5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmN1cnJlbnRQb2ludC5jb3B5KCBzb3VyY2UuY3VycmVudFBvaW50ICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgZGF0YSA9IEN1cnZlUGF0aC5wcm90b3R5cGUudG9KU09OLmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHRcXHRkYXRhLmN1cnJlbnRQb2ludCA9IHRoaXMuY3VycmVudFBvaW50LnRvQXJyYXkoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZGF0YTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGZyb21KU09OOiBmdW5jdGlvbiAoIGpzb24gKSB7XFxuXFxuXFx0XFx0XFx0Q3VydmVQYXRoLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5jdXJyZW50UG9pbnQuZnJvbUFycmF5KCBqc29uLmN1cnJlbnRQb2ludCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciB6ejg1IC8gaHR0cDovL3d3dy5sYWI0Z2FtZXMubmV0L3p6ODUvYmxvZ1xcblxcdCAqIERlZmluZXMgYSAyZCBzaGFwZSBwbGFuZSB1c2luZyBwYXRocy5cXG5cXHQgKiovXFxuXFxuXFx0Ly8gU1RFUCAxIENyZWF0ZSBhIHBhdGguXFxuXFx0Ly8gU1RFUCAyIFR1cm4gcGF0aCBpbnRvIHNoYXBlLlxcblxcdC8vIFNURVAgMyBFeHRydWRlR2VvbWV0cnkgdGFrZXMgaW4gU2hhcGUvU2hhcGVzXFxuXFx0Ly8gU1RFUCAzYSAtIEV4dHJhY3QgcG9pbnRzIGZyb20gZWFjaCBzaGFwZSwgdHVybiB0byB2ZXJ0aWNlc1xcblxcdC8vIFNURVAgM2IgLSBUcmlhbmd1bGF0ZSBlYWNoIHNoYXBlLCBhZGQgZmFjZXMuXFxuXFxuXFx0ZnVuY3Rpb24gU2hhcGUoIHBvaW50cyApIHtcXG5cXG5cXHRcXHRQYXRoLmNhbGwoIHRoaXMsIHBvaW50cyApO1xcblxcblxcdFxcdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdTaGFwZSc7XFxuXFxuXFx0XFx0dGhpcy5ob2xlcyA9IFtdO1xcblxcblxcdH1cXG5cXG5cXHRTaGFwZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBQYXRoLnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IFNoYXBlLFxcblxcblxcdFxcdGdldFBvaW50c0hvbGVzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgaG9sZXNQdHMgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aG9sZXNQdHNbIGkgXSA9IHRoaXMuaG9sZXNbIGkgXS5nZXRQb2ludHMoIGRpdmlzaW9ucyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gaG9sZXNQdHM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBnZXQgcG9pbnRzIG9mIHNoYXBlIGFuZCBob2xlcyAoa2V5cG9pbnRzIGJhc2VkIG9uIHNlZ21lbnRzIHBhcmFtZXRlcilcXG5cXG5cXHRcXHRleHRyYWN0UG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4ge1xcblxcblxcdFxcdFxcdFxcdHNoYXBlOiB0aGlzLmdldFBvaW50cyggZGl2aXNpb25zICksXFxuXFx0XFx0XFx0XFx0aG9sZXM6IHRoaXMuZ2V0UG9pbnRzSG9sZXMoIGRpdmlzaW9ucyApXFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdFxcdFBhdGgucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5ob2xlcyA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHNvdXJjZS5ob2xlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBob2xlID0gc291cmNlLmhvbGVzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5ob2xlcy5wdXNoKCBob2xlLmNsb25lKCkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgZGF0YSA9IFBhdGgucHJvdG90eXBlLnRvSlNPTi5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0XFx0ZGF0YS51dWlkID0gdGhpcy51dWlkO1xcblxcdFxcdFxcdGRhdGEuaG9sZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSB0aGlzLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGhvbGUgPSB0aGlzLmhvbGVzWyBpIF07XFxuXFx0XFx0XFx0XFx0ZGF0YS5ob2xlcy5wdXNoKCBob2xlLnRvSlNPTigpICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBkYXRhO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZnJvbUpTT046IGZ1bmN0aW9uICgganNvbiApIHtcXG5cXG5cXHRcXHRcXHRQYXRoLnByb3RvdHlwZS5mcm9tSlNPTi5jYWxsKCB0aGlzLCBqc29uICk7XFxuXFxuXFx0XFx0XFx0dGhpcy51dWlkID0ganNvbi51dWlkO1xcblxcdFxcdFxcdHRoaXMuaG9sZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLmhvbGVzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGhvbGUgPSBqc29uLmhvbGVzWyBpIF07XFxuXFx0XFx0XFx0XFx0dGhpcy5ob2xlcy5wdXNoKCBuZXcgUGF0aCgpLmZyb21KU09OKCBob2xlICkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gTGlnaHQoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XFxuXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdMaWdodCc7XFxuXFxuXFx0XFx0dGhpcy5jb2xvciA9IG5ldyBDb2xvciggY29sb3IgKTtcXG5cXHRcXHR0aGlzLmludGVuc2l0eSA9IGludGVuc2l0eSAhPT0gdW5kZWZpbmVkID8gaW50ZW5zaXR5IDogMTtcXG5cXG5cXHRcXHR0aGlzLnJlY2VpdmVTaGFkb3cgPSB1bmRlZmluZWQ7XFxuXFxuXFx0fVxcblxcblxcdExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IExpZ2h0LFxcblxcblxcdFxcdGlzTGlnaHQ6IHRydWUsXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0XFx0T2JqZWN0M0QucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5jb2xvci5jb3B5KCBzb3VyY2UuY29sb3IgKTtcXG5cXHRcXHRcXHR0aGlzLmludGVuc2l0eSA9IHNvdXJjZS5pbnRlbnNpdHk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZGF0YSA9IE9iamVjdDNELnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xcblxcblxcdFxcdFxcdGRhdGEub2JqZWN0LmNvbG9yID0gdGhpcy5jb2xvci5nZXRIZXgoKTtcXG5cXHRcXHRcXHRkYXRhLm9iamVjdC5pbnRlbnNpdHkgPSB0aGlzLmludGVuc2l0eTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuZ3JvdW5kQ29sb3IgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0Lmdyb3VuZENvbG9yID0gdGhpcy5ncm91bmRDb2xvci5nZXRIZXgoKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuZGlzdGFuY2UgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmRpc3RhbmNlID0gdGhpcy5kaXN0YW5jZTtcXG5cXHRcXHRcXHRpZiAoIHRoaXMuYW5nbGUgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmFuZ2xlID0gdGhpcy5hbmdsZTtcXG5cXHRcXHRcXHRpZiAoIHRoaXMuZGVjYXkgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LmRlY2F5ID0gdGhpcy5kZWNheTtcXG5cXHRcXHRcXHRpZiAoIHRoaXMucGVudW1icmEgIT09IHVuZGVmaW5lZCApIGRhdGEub2JqZWN0LnBlbnVtYnJhID0gdGhpcy5wZW51bWJyYTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuc2hhZG93ICE9PSB1bmRlZmluZWQgKSBkYXRhLm9iamVjdC5zaGFkb3cgPSB0aGlzLnNoYWRvdy50b0pTT04oKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZGF0YTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gSGVtaXNwaGVyZUxpZ2h0KCBza3lDb2xvciwgZ3JvdW5kQ29sb3IsIGludGVuc2l0eSApIHtcXG5cXG5cXHRcXHRMaWdodC5jYWxsKCB0aGlzLCBza3lDb2xvciwgaW50ZW5zaXR5ICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0hlbWlzcGhlcmVMaWdodCc7XFxuXFxuXFx0XFx0dGhpcy5jYXN0U2hhZG93ID0gdW5kZWZpbmVkO1xcblxcblxcdFxcdHRoaXMucG9zaXRpb24uY29weSggT2JqZWN0M0QuRGVmYXVsdFVwICk7XFxuXFx0XFx0dGhpcy51cGRhdGVNYXRyaXgoKTtcXG5cXG5cXHRcXHR0aGlzLmdyb3VuZENvbG9yID0gbmV3IENvbG9yKCBncm91bmRDb2xvciApO1xcblxcblxcdH1cXG5cXG5cXHRIZW1pc3BoZXJlTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHQucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogSGVtaXNwaGVyZUxpZ2h0LFxcblxcblxcdFxcdGlzSGVtaXNwaGVyZUxpZ2h0OiB0cnVlLFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdFxcdExpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdFxcdHRoaXMuZ3JvdW5kQ29sb3IuY29weSggc291cmNlLmdyb3VuZENvbG9yICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIExpZ2h0U2hhZG93KCBjYW1lcmEgKSB7XFxuXFxuXFx0XFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XFxuXFxuXFx0XFx0dGhpcy5iaWFzID0gMDtcXG5cXHRcXHR0aGlzLnJhZGl1cyA9IDE7XFxuXFxuXFx0XFx0dGhpcy5tYXBTaXplID0gbmV3IFZlY3RvcjIoIDUxMiwgNTEyICk7XFxuXFxuXFx0XFx0dGhpcy5tYXAgPSBudWxsO1xcblxcdFxcdHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggTGlnaHRTaGFkb3cucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jYW1lcmEgPSBzb3VyY2UuY2FtZXJhLmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5iaWFzID0gc291cmNlLmJpYXM7XFxuXFx0XFx0XFx0dGhpcy5yYWRpdXMgPSBzb3VyY2UucmFkaXVzO1xcblxcblxcdFxcdFxcdHRoaXMubWFwU2l6ZS5jb3B5KCBzb3VyY2UubWFwU2l6ZSApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0pTT046IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgb2JqZWN0ID0ge307XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmJpYXMgIT09IDAgKSBvYmplY3QuYmlhcyA9IHRoaXMuYmlhcztcXG5cXHRcXHRcXHRpZiAoIHRoaXMucmFkaXVzICE9PSAxICkgb2JqZWN0LnJhZGl1cyA9IHRoaXMucmFkaXVzO1xcblxcdFxcdFxcdGlmICggdGhpcy5tYXBTaXplLnggIT09IDUxMiB8fCB0aGlzLm1hcFNpemUueSAhPT0gNTEyICkgb2JqZWN0Lm1hcFNpemUgPSB0aGlzLm1hcFNpemUudG9BcnJheSgpO1xcblxcblxcdFxcdFxcdG9iamVjdC5jYW1lcmEgPSB0aGlzLmNhbWVyYS50b0pTT04oIGZhbHNlICkub2JqZWN0O1xcblxcdFxcdFxcdGRlbGV0ZSBvYmplY3QuY2FtZXJhLm1hdHJpeDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gb2JqZWN0O1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBTcG90TGlnaHRTaGFkb3coKSB7XFxuXFxuXFx0XFx0TGlnaHRTaGFkb3cuY2FsbCggdGhpcywgbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCA1MCwgMSwgMC41LCA1MDAgKSApO1xcblxcblxcdH1cXG5cXG5cXHRTcG90TGlnaHRTaGFkb3cucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHRTaGFkb3cucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogU3BvdExpZ2h0U2hhZG93LFxcblxcblxcdFxcdGlzU3BvdExpZ2h0U2hhZG93OiB0cnVlLFxcblxcblxcdFxcdHVwZGF0ZTogZnVuY3Rpb24gKCBsaWdodCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgY2FtZXJhID0gdGhpcy5jYW1lcmE7XFxuXFxuXFx0XFx0XFx0dmFyIGZvdiA9IF9NYXRoLlJBRDJERUcgKiAyICogbGlnaHQuYW5nbGU7XFxuXFx0XFx0XFx0dmFyIGFzcGVjdCA9IHRoaXMubWFwU2l6ZS53aWR0aCAvIHRoaXMubWFwU2l6ZS5oZWlnaHQ7XFxuXFx0XFx0XFx0dmFyIGZhciA9IGxpZ2h0LmRpc3RhbmNlIHx8IGNhbWVyYS5mYXI7XFxuXFxuXFx0XFx0XFx0aWYgKCBmb3YgIT09IGNhbWVyYS5mb3YgfHwgYXNwZWN0ICE9PSBjYW1lcmEuYXNwZWN0IHx8IGZhciAhPT0gY2FtZXJhLmZhciApIHtcXG5cXG5cXHRcXHRcXHRcXHRjYW1lcmEuZm92ID0gZm92O1xcblxcdFxcdFxcdFxcdGNhbWVyYS5hc3BlY3QgPSBhc3BlY3Q7XFxuXFx0XFx0XFx0XFx0Y2FtZXJhLmZhciA9IGZhcjtcXG5cXHRcXHRcXHRcXHRjYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gU3BvdExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5LCBkaXN0YW5jZSwgYW5nbGUsIHBlbnVtYnJhLCBkZWNheSApIHtcXG5cXG5cXHRcXHRMaWdodC5jYWxsKCB0aGlzLCBjb2xvciwgaW50ZW5zaXR5ICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1Nwb3RMaWdodCc7XFxuXFxuXFx0XFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBPYmplY3QzRC5EZWZhdWx0VXAgKTtcXG5cXHRcXHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xcblxcblxcdFxcdHRoaXMudGFyZ2V0ID0gbmV3IE9iamVjdDNEKCk7XFxuXFxuXFx0XFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAncG93ZXInLCB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gaW50ZW5zaXR5ID0gcG93ZXIgcGVyIHNvbGlkIGFuZ2xlLlxcblxcdFxcdFxcdFxcdC8vIHJlZjogZXF1YXRpb24gKDE3KSBmcm9tIGh0dHA6Ly93d3cuZnJvc3RiaXRlLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNC8xMS9jb3Vyc2Vfbm90ZXNfbW92aW5nX2Zyb3N0Yml0ZV90b19wYnIucGRmXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuaW50ZW5zaXR5ICogTWF0aC5QSTtcXG5cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCBwb3dlciApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpbnRlbnNpdHkgPSBwb3dlciBwZXIgc29saWQgYW5nbGUuXFxuXFx0XFx0XFx0XFx0Ly8gcmVmOiBlcXVhdGlvbiAoMTcpIGZyb20gaHR0cDovL3d3dy5mcm9zdGJpdGUuY29tL3dwLWNvbnRlbnQvdXBsb2Fkcy8yMDE0LzExL2NvdXJzZV9ub3Rlc19tb3ZpbmdfZnJvc3RiaXRlX3RvX3Bici5wZGZcXG5cXHRcXHRcXHRcXHR0aGlzLmludGVuc2l0eSA9IHBvd2VyIC8gTWF0aC5QSTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSApO1xcblxcblxcdFxcdHRoaXMuZGlzdGFuY2UgPSAoIGRpc3RhbmNlICE9PSB1bmRlZmluZWQgKSA/IGRpc3RhbmNlIDogMDtcXG5cXHRcXHR0aGlzLmFuZ2xlID0gKCBhbmdsZSAhPT0gdW5kZWZpbmVkICkgPyBhbmdsZSA6IE1hdGguUEkgLyAzO1xcblxcdFxcdHRoaXMucGVudW1icmEgPSAoIHBlbnVtYnJhICE9PSB1bmRlZmluZWQgKSA/IHBlbnVtYnJhIDogMDtcXG5cXHRcXHR0aGlzLmRlY2F5ID0gKCBkZWNheSAhPT0gdW5kZWZpbmVkICkgPyBkZWNheSA6IDE7XFx0Ly8gZm9yIHBoeXNpY2FsbHkgY29ycmVjdCBsaWdodHMsIHNob3VsZCBiZSAyLlxcblxcblxcdFxcdHRoaXMuc2hhZG93ID0gbmV3IFNwb3RMaWdodFNoYWRvdygpO1xcblxcblxcdH1cXG5cXG5cXHRTcG90TGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHQucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogU3BvdExpZ2h0LFxcblxcblxcdFxcdGlzU3BvdExpZ2h0OiB0cnVlLFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdFxcdExpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdFxcdHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XFxuXFx0XFx0XFx0dGhpcy5hbmdsZSA9IHNvdXJjZS5hbmdsZTtcXG5cXHRcXHRcXHR0aGlzLnBlbnVtYnJhID0gc291cmNlLnBlbnVtYnJhO1xcblxcdFxcdFxcdHRoaXMuZGVjYXkgPSBzb3VyY2UuZGVjYXk7XFxuXFxuXFx0XFx0XFx0dGhpcy50YXJnZXQgPSBzb3VyY2UudGFyZ2V0LmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0dGhpcy5zaGFkb3cgPSBzb3VyY2Uuc2hhZG93LmNsb25lKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcblxcdGZ1bmN0aW9uIFBvaW50TGlnaHQoIGNvbG9yLCBpbnRlbnNpdHksIGRpc3RhbmNlLCBkZWNheSApIHtcXG5cXG5cXHRcXHRMaWdodC5jYWxsKCB0aGlzLCBjb2xvciwgaW50ZW5zaXR5ICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1BvaW50TGlnaHQnO1xcblxcblxcdFxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgJ3Bvd2VyJywge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdC8vIGludGVuc2l0eSA9IHBvd2VyIHBlciBzb2xpZCBhbmdsZS5cXG5cXHRcXHRcXHRcXHQvLyByZWY6IGVxdWF0aW9uICgxNSkgZnJvbSBodHRwOi8vd3d3LmZyb3N0Yml0ZS5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTQvMTEvY291cnNlX25vdGVzX21vdmluZ19mcm9zdGJpdGVfdG9fcGJyLnBkZlxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmludGVuc2l0eSAqIDQgKiBNYXRoLlBJO1xcblxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHBvd2VyICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGludGVuc2l0eSA9IHBvd2VyIHBlciBzb2xpZCBhbmdsZS5cXG5cXHRcXHRcXHRcXHQvLyByZWY6IGVxdWF0aW9uICgxNSkgZnJvbSBodHRwOi8vd3d3LmZyb3N0Yml0ZS5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMTQvMTEvY291cnNlX25vdGVzX21vdmluZ19mcm9zdGJpdGVfdG9fcGJyLnBkZlxcblxcdFxcdFxcdFxcdHRoaXMuaW50ZW5zaXR5ID0gcG93ZXIgLyAoIDQgKiBNYXRoLlBJICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXG5cXHRcXHR0aGlzLmRpc3RhbmNlID0gKCBkaXN0YW5jZSAhPT0gdW5kZWZpbmVkICkgPyBkaXN0YW5jZSA6IDA7XFxuXFx0XFx0dGhpcy5kZWNheSA9ICggZGVjYXkgIT09IHVuZGVmaW5lZCApID8gZGVjYXkgOiAxO1xcdC8vIGZvciBwaHlzaWNhbGx5IGNvcnJlY3QgbGlnaHRzLCBzaG91bGQgYmUgMi5cXG5cXG5cXHRcXHR0aGlzLnNoYWRvdyA9IG5ldyBMaWdodFNoYWRvdyggbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCA5MCwgMSwgMC41LCA1MDAgKSApO1xcblxcblxcdH1cXG5cXG5cXHRQb2ludExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0LnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IFBvaW50TGlnaHQsXFxuXFxuXFx0XFx0aXNQb2ludExpZ2h0OiB0cnVlLFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdFxcdExpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdFxcdHRoaXMuZGlzdGFuY2UgPSBzb3VyY2UuZGlzdGFuY2U7XFxuXFx0XFx0XFx0dGhpcy5kZWNheSA9IHNvdXJjZS5kZWNheTtcXG5cXG5cXHRcXHRcXHR0aGlzLnNoYWRvdyA9IHNvdXJjZS5zaGFkb3cuY2xvbmUoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gRGlyZWN0aW9uYWxMaWdodFNoYWRvdyggKSB7XFxuXFxuXFx0XFx0TGlnaHRTaGFkb3cuY2FsbCggdGhpcywgbmV3IE9ydGhvZ3JhcGhpY0NhbWVyYSggLSA1LCA1LCA1LCAtIDUsIDAuNSwgNTAwICkgKTtcXG5cXG5cXHR9XFxuXFxuXFx0RGlyZWN0aW9uYWxMaWdodFNoYWRvdy5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBMaWdodFNoYWRvdy5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBEaXJlY3Rpb25hbExpZ2h0U2hhZG93XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBEaXJlY3Rpb25hbExpZ2h0KCBjb2xvciwgaW50ZW5zaXR5ICkge1xcblxcblxcdFxcdExpZ2h0LmNhbGwoIHRoaXMsIGNvbG9yLCBpbnRlbnNpdHkgKTtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnRGlyZWN0aW9uYWxMaWdodCc7XFxuXFxuXFx0XFx0dGhpcy5wb3NpdGlvbi5jb3B5KCBPYmplY3QzRC5EZWZhdWx0VXAgKTtcXG5cXHRcXHR0aGlzLnVwZGF0ZU1hdHJpeCgpO1xcblxcblxcdFxcdHRoaXMudGFyZ2V0ID0gbmV3IE9iamVjdDNEKCk7XFxuXFxuXFx0XFx0dGhpcy5zaGFkb3cgPSBuZXcgRGlyZWN0aW9uYWxMaWdodFNoYWRvdygpO1xcblxcblxcdH1cXG5cXG5cXHREaXJlY3Rpb25hbExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0LnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IERpcmVjdGlvbmFsTGlnaHQsXFxuXFxuXFx0XFx0aXNEaXJlY3Rpb25hbExpZ2h0OiB0cnVlLFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggc291cmNlICkge1xcblxcblxcdFxcdFxcdExpZ2h0LnByb3RvdHlwZS5jb3B5LmNhbGwoIHRoaXMsIHNvdXJjZSApO1xcblxcblxcdFxcdFxcdHRoaXMudGFyZ2V0ID0gc291cmNlLnRhcmdldC5jbG9uZSgpO1xcblxcblxcdFxcdFxcdHRoaXMuc2hhZG93ID0gc291cmNlLnNoYWRvdy5jbG9uZSgpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBBbWJpZW50TGlnaHQoIGNvbG9yLCBpbnRlbnNpdHkgKSB7XFxuXFxuXFx0XFx0TGlnaHQuY2FsbCggdGhpcywgY29sb3IsIGludGVuc2l0eSApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdBbWJpZW50TGlnaHQnO1xcblxcblxcdFxcdHRoaXMuY2FzdFNoYWRvdyA9IHVuZGVmaW5lZDtcXG5cXG5cXHR9XFxuXFxuXFx0QW1iaWVudExpZ2h0LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIExpZ2h0LnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IEFtYmllbnRMaWdodCxcXG5cXG5cXHRcXHRpc0FtYmllbnRMaWdodDogdHJ1ZVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGFiZWxuYXRpb24gLyBodHRwOi8vZ2l0aHViLmNvbS9hYmVsbmF0aW9uXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gUmVjdEFyZWFMaWdodCggY29sb3IsIGludGVuc2l0eSwgd2lkdGgsIGhlaWdodCApIHtcXG5cXG5cXHRcXHRMaWdodC5jYWxsKCB0aGlzLCBjb2xvciwgaW50ZW5zaXR5ICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1JlY3RBcmVhTGlnaHQnO1xcblxcblxcdFxcdHRoaXMucG9zaXRpb24uc2V0KCAwLCAxLCAwICk7XFxuXFx0XFx0dGhpcy51cGRhdGVNYXRyaXgoKTtcXG5cXG5cXHRcXHR0aGlzLndpZHRoID0gKCB3aWR0aCAhPT0gdW5kZWZpbmVkICkgPyB3aWR0aCA6IDEwO1xcblxcdFxcdHRoaXMuaGVpZ2h0ID0gKCBoZWlnaHQgIT09IHVuZGVmaW5lZCApID8gaGVpZ2h0IDogMTA7XFxuXFxuXFx0XFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IGRpc3RhbmNlL2RlY2F5XFxuXFxuXFx0XFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IHVwZGF0ZSBtZXRob2QgZm9yIFJlY3RBcmVhTGlnaHQgdG8gdXBkYXRlIHRyYW5zZm9ybSB0byBsb29rYXQgdGFyZ2V0XFxuXFxuXFx0XFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IHNoYWRvd3NcXG5cXG5cXHR9XFxuXFxuXFx0Ly8gVE9ETyAoYWJlbG5hdGlvbik6IFJlY3RBcmVhTGlnaHQgdXBkYXRlIHdoZW4gbGlnaHQgc2hhcGUgaXMgY2hhbmdlZFxcblxcdFJlY3RBcmVhTGlnaHQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggTGlnaHQucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogUmVjdEFyZWFMaWdodCxcXG5cXG5cXHRcXHRpc1JlY3RBcmVhTGlnaHQ6IHRydWUsXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0XFx0TGlnaHQucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0XFx0dGhpcy53aWR0aCA9IHNvdXJjZS53aWR0aDtcXG5cXHRcXHRcXHR0aGlzLmhlaWdodCA9IHNvdXJjZS5oZWlnaHQ7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0pTT046IGZ1bmN0aW9uICggbWV0YSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZGF0YSA9IExpZ2h0LnByb3RvdHlwZS50b0pTT04uY2FsbCggdGhpcywgbWV0YSApO1xcblxcblxcdFxcdFxcdGRhdGEub2JqZWN0LndpZHRoID0gdGhpcy53aWR0aDtcXG5cXHRcXHRcXHRkYXRhLm9iamVjdC5oZWlnaHQgPSB0aGlzLmhlaWdodDtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZGF0YTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqXFxuXFx0ICogQSBUcmFjayB0aGF0IGludGVycG9sYXRlcyBTdHJpbmdzXFxuXFx0ICpcXG5cXHQgKlxcblxcdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXFxuXFx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFN0cmluZ0tleWZyYW1lVHJhY2soIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKSB7XFxuXFxuXFx0XFx0S2V5ZnJhbWVUcmFjay5jYWxsKCB0aGlzLCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICk7XFxuXFxuXFx0fVxcblxcblxcdFN0cmluZ0tleWZyYW1lVHJhY2sucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBTdHJpbmdLZXlmcmFtZVRyYWNrLFxcblxcblxcdFxcdFZhbHVlVHlwZU5hbWU6ICdzdHJpbmcnLFxcblxcdFxcdFZhbHVlQnVmZmVyVHlwZTogQXJyYXksXFxuXFxuXFx0XFx0RGVmYXVsdEludGVycG9sYXRpb246IEludGVycG9sYXRlRGlzY3JldGUsXFxuXFxuXFx0XFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kTGluZWFyOiB1bmRlZmluZWQsXFxuXFxuXFx0XFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOiB1bmRlZmluZWRcXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICpcXG5cXHQgKiBBIFRyYWNrIG9mIEJvb2xlYW4ga2V5ZnJhbWUgdmFsdWVzLlxcblxcdCAqXFxuXFx0ICpcXG5cXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xcblxcdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xcblxcdCAqIEBhdXRob3IgdHNjaHdcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBCb29sZWFuS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcyApIHtcXG5cXG5cXHRcXHRLZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMgKTtcXG5cXG5cXHR9XFxuXFxuXFx0Qm9vbGVhbktleWZyYW1lVHJhY2sucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBCb29sZWFuS2V5ZnJhbWVUcmFjayxcXG5cXG5cXHRcXHRWYWx1ZVR5cGVOYW1lOiAnYm9vbCcsXFxuXFx0XFx0VmFsdWVCdWZmZXJUeXBlOiBBcnJheSxcXG5cXG5cXHRcXHREZWZhdWx0SW50ZXJwb2xhdGlvbjogSW50ZXJwb2xhdGVEaXNjcmV0ZSxcXG5cXG5cXHRcXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI6IHVuZGVmaW5lZCxcXG5cXHRcXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6IHVuZGVmaW5lZFxcblxcblxcdFxcdC8vIE5vdGU6IEFjdHVhbGx5IHRoaXMgdHJhY2sgY291bGQgaGF2ZSBhIG9wdGltaXplZCAvIGNvbXByZXNzZWRcXG5cXHRcXHQvLyByZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSB2YWx1ZSBhbmQgYSBjdXN0b20gaW50ZXJwb2xhbnQgdGhhdFxcblxcdFxcdC8vIGNvbXB1dGVzIFxcXCJmaXJzdFZhbHVlIF4gaXNPZGQoIGluZGV4IClcXFwiLlxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBBYnN0cmFjdCBiYXNlIGNsYXNzIG9mIGludGVycG9sYW50cyBvdmVyIHBhcmFtZXRyaWMgc2FtcGxlcy5cXG5cXHQgKlxcblxcdCAqIFRoZSBwYXJhbWV0ZXIgZG9tYWluIGlzIG9uZSBkaW1lbnNpb25hbCwgdHlwaWNhbGx5IHRoZSB0aW1lIG9yIGEgcGF0aFxcblxcdCAqIGFsb25nIGEgY3VydmUgZGVmaW5lZCBieSB0aGUgZGF0YS5cXG5cXHQgKlxcblxcdCAqIFRoZSBzYW1wbGUgdmFsdWVzIGNhbiBoYXZlIGFueSBkaW1lbnNpb25hbGl0eSBhbmQgZGVyaXZlZCBjbGFzc2VzIG1heVxcblxcdCAqIGFwcGx5IHNwZWNpYWwgaW50ZXJwcmV0YXRpb25zIHRvIHRoZSBkYXRhLlxcblxcdCAqXFxuXFx0ICogVGhpcyBjbGFzcyBwcm92aWRlcyB0aGUgaW50ZXJ2YWwgc2VlayBpbiBhIFRlbXBsYXRlIE1ldGhvZCwgZGVmZXJyaW5nXFxuXFx0ICogdGhlIGFjdHVhbCBpbnRlcnBvbGF0aW9uIHRvIGRlcml2ZWQgY2xhc3Nlcy5cXG5cXHQgKlxcblxcdCAqIFRpbWUgY29tcGxleGl0eSBpcyBPKDEpIGZvciBsaW5lYXIgYWNjZXNzIGNyb3NzaW5nIGF0IG1vc3QgdHdvIHBvaW50c1xcblxcdCAqIGFuZCBPKGxvZyBOKSBmb3IgcmFuZG9tIGFjY2Vzcywgd2hlcmUgTiBpcyB0aGUgbnVtYmVyIG9mIHBvc2l0aW9ucy5cXG5cXHQgKlxcblxcdCAqIFJlZmVyZW5jZXM6XFxuXFx0ICpcXG5cXHQgKiBcXHRcXHRodHRwOi8vd3d3Lm9vZGVzaWduLmNvbS90ZW1wbGF0ZS1tZXRob2QtcGF0dGVybi5odG1sXFxuXFx0ICpcXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gSW50ZXJwb2xhbnQoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XFxuXFxuXFx0XFx0dGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnMgPSBwYXJhbWV0ZXJQb3NpdGlvbnM7XFxuXFx0XFx0dGhpcy5fY2FjaGVkSW5kZXggPSAwO1xcblxcblxcdFxcdHRoaXMucmVzdWx0QnVmZmVyID0gcmVzdWx0QnVmZmVyICE9PSB1bmRlZmluZWQgP1xcblxcdFxcdFxcdHJlc3VsdEJ1ZmZlciA6IG5ldyBzYW1wbGVWYWx1ZXMuY29uc3RydWN0b3IoIHNhbXBsZVNpemUgKTtcXG5cXHRcXHR0aGlzLnNhbXBsZVZhbHVlcyA9IHNhbXBsZVZhbHVlcztcXG5cXHRcXHR0aGlzLnZhbHVlU2l6ZSA9IHNhbXBsZVNpemU7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIEludGVycG9sYW50LnByb3RvdHlwZSwge1xcblxcblxcdFxcdGV2YWx1YXRlOiBmdW5jdGlvbiAoIHQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHBwID0gdGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnMsXFxuXFx0XFx0XFx0XFx0aTEgPSB0aGlzLl9jYWNoZWRJbmRleCxcXG5cXG5cXHRcXHRcXHRcXHR0MSA9IHBwWyBpMSBdLFxcblxcdFxcdFxcdFxcdHQwID0gcHBbIGkxIC0gMSBdO1xcblxcblxcdFxcdFxcdHZhbGlkYXRlX2ludGVydmFsOiB7XFxuXFxuXFx0XFx0XFx0XFx0c2Vlazoge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciByaWdodDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRsaW5lYXJfc2Nhbjoge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vLSBTZWUgaHR0cDovL2pzcGVyZi5jb20vY29tcGFyaXNvbi10by11bmRlZmluZWQvM1xcblxcdFxcdFxcdFxcdFxcdFxcdC8vLSBzbG93ZXIgY29kZTpcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLy1cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLy0gXFx0XFx0XFx0XFx0aWYgKCB0ID49IHQxIHx8IHQxID09PSB1bmRlZmluZWQgKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yd2FyZF9zY2FuOiBpZiAoICEgKCB0IDwgdDEgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgZ2l2ZVVwQXQgPSBpMSArIDI7IDsgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0MSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdCA8IHQwICkgYnJlYWsgZm9yd2FyZF9zY2FuO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGFmdGVyIGVuZFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGkxID0gcHAubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2NhY2hlZEluZGV4ID0gaTE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuYWZ0ZXJFbmRfKCBpMSAtIDEsIHQsIHQwICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaTEgPT09IGdpdmVVcEF0ICkgYnJlYWs7IC8vIHRoaXMgbG9vcFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHQwID0gdDE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dDEgPSBwcFsgKysgaTEgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHQgPCB0MSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyB3ZSBoYXZlIGFycml2ZWQgYXQgdGhlIHNvdWdodCBpbnRlcnZhbFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrIHNlZWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBwcmVwYXJlIGJpbmFyeSBzZWFyY2ggb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGluZGV4XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmlnaHQgPSBwcC5sZW5ndGg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWsgbGluZWFyX3NjYW47XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vLSBzbG93ZXIgY29kZTpcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLy1cXHRcXHRcXHRcXHRcXHRpZiAoIHQgPCB0MCB8fCB0MCA9PT0gdW5kZWZpbmVkICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggISAoIHQgPj0gdDAgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBsb29waW5nP1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciB0MWdsb2JhbCA9IHBwWyAxIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0IDwgdDFnbG9iYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aTEgPSAyOyAvLyArIDEsIHVzaW5nIHRoZSBzY2FuIGZvciB0aGUgZGV0YWlsc1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHQwID0gdDFnbG9iYWw7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGxpbmVhciByZXZlcnNlIHNjYW5cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgZ2l2ZVVwQXQgPSBpMSAtIDI7IDsgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0MCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGJlZm9yZSBzdGFydFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2NhY2hlZEluZGV4ID0gMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5iZWZvcmVTdGFydF8oIDAsIHQsIHQxICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaTEgPT09IGdpdmVVcEF0ICkgYnJlYWs7IC8vIHRoaXMgbG9vcFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHQxID0gdDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dDAgPSBwcFsgLS0gaTEgLSAxIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0ID49IHQwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHdlIGhhdmUgYXJyaXZlZCBhdCB0aGUgc291Z2h0IGludGVydmFsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWsgc2VlaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIHByZXBhcmUgYmluYXJ5IHNlYXJjaCBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBpbmRleFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJpZ2h0ID0gaTE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aTEgPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrIGxpbmVhcl9zY2FuO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB0aGUgaW50ZXJ2YWwgaXMgdmFsaWRcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhayB2YWxpZGF0ZV9pbnRlcnZhbDtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IC8vIGxpbmVhciBzY2FuXFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gYmluYXJ5IHNlYXJjaFxcblxcblxcdFxcdFxcdFxcdFxcdHdoaWxlICggaTEgPCByaWdodCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgbWlkID0gKCBpMSArIHJpZ2h0ICkgPj4+IDE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0IDwgcHBbIG1pZCBdICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJpZ2h0ID0gbWlkO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aTEgPSBtaWQgKyAxO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dDEgPSBwcFsgaTEgXTtcXG5cXHRcXHRcXHRcXHRcXHR0MCA9IHBwWyBpMSAtIDEgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBjaGVjayBib3VuZGFyeSBjYXNlcywgYWdhaW5cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHQwID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fY2FjaGVkSW5kZXggPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmJlZm9yZVN0YXJ0XyggMCwgdCwgdDEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0MSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGkxID0gcHAubGVuZ3RoO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX2NhY2hlZEluZGV4ID0gaTE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuYWZ0ZXJFbmRfKCBpMSAtIDEsIHQwLCB0ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0gLy8gc2Vla1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX2NhY2hlZEluZGV4ID0gaTE7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5pbnRlcnZhbENoYW5nZWRfKCBpMSwgdDAsIHQxICk7XFxuXFxuXFx0XFx0XFx0fSAvLyB2YWxpZGF0ZV9pbnRlcnZhbFxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmludGVycG9sYXRlXyggaTEsIHQwLCB0LCB0MSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0dGluZ3M6IG51bGwsIC8vIG9wdGlvbmFsLCBzdWJjbGFzcy1zcGVjaWZpYyBzZXR0aW5ncyBzdHJ1Y3R1cmVcXG5cXHRcXHQvLyBOb3RlOiBUaGUgaW5kaXJlY3Rpb24gYWxsb3dzIGNlbnRyYWwgY29udHJvbCBvZiBtYW55IGludGVycG9sYW50cy5cXG5cXG5cXHRcXHQvLyAtLS0gUHJvdGVjdGVkIGludGVyZmFjZVxcblxcblxcdFxcdERlZmF1bHRTZXR0aW5nc186IHt9LFxcblxcblxcdFxcdGdldFNldHRpbmdzXzogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLnNldHRpbmdzIHx8IHRoaXMuRGVmYXVsdFNldHRpbmdzXztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHlTYW1wbGVWYWx1ZV86IGZ1bmN0aW9uICggaW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0Ly8gY29waWVzIGEgc2FtcGxlIHZhbHVlIHRvIHRoZSByZXN1bHQgYnVmZmVyXFxuXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxcblxcdFxcdFxcdFxcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxcblxcdFxcdFxcdFxcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxcblxcdFxcdFxcdFxcdG9mZnNldCA9IGluZGV4ICogc3RyaWRlO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gc3RyaWRlOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdHJlc3VsdFsgaSBdID0gdmFsdWVzWyBvZmZzZXQgKyBpIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBUZW1wbGF0ZSBtZXRob2RzIGZvciBkZXJpdmVkIGNsYXNzZXM6XFxuXFxuXFx0XFx0aW50ZXJwb2xhdGVfOiBmdW5jdGlvbiAoIC8qIGkxLCB0MCwgdCwgdDEgKi8gKSB7XFxuXFxuXFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCAnY2FsbCB0byBhYnN0cmFjdCBtZXRob2QnICk7XFxuXFx0XFx0XFx0Ly8gaW1wbGVtZW50YXRpb25zIHNoYWxsIHJldHVybiB0aGlzLnJlc3VsdEJ1ZmZlclxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0aW50ZXJ2YWxDaGFuZ2VkXzogZnVuY3Rpb24gKCAvKiBpMSwgdDAsIHQxICovICkge1xcblxcblxcdFxcdFxcdC8vIGVtcHR5XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvLyFcXFxcIERFQ0xBUkUgQUxJQVMgQUZURVIgYXNzaWduIHByb3RvdHlwZSAhXFxuXFx0T2JqZWN0LmFzc2lnbiggSW50ZXJwb2xhbnQucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0Ly8oIDAsIHQsIHQwICksIHJldHVybnMgdGhpcy5yZXN1bHRCdWZmZXJcXG5cXHRcXHRiZWZvcmVTdGFydF86IEludGVycG9sYW50LnByb3RvdHlwZS5jb3B5U2FtcGxlVmFsdWVfLFxcblxcblxcdFxcdC8vKCBOLTEsIHROLTEsIHQgKSwgcmV0dXJucyB0aGlzLnJlc3VsdEJ1ZmZlclxcblxcdFxcdGFmdGVyRW5kXzogSW50ZXJwb2xhbnQucHJvdG90eXBlLmNvcHlTYW1wbGVWYWx1ZV8sXFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIFNwaGVyaWNhbCBsaW5lYXIgdW5pdCBxdWF0ZXJuaW9uIGludGVycG9sYW50LlxcblxcdCAqXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudCggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcXG5cXG5cXHRcXHRJbnRlcnBvbGFudC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XFxuXFxuXFx0fVxcblxcblxcdFF1YXRlcm5pb25MaW5lYXJJbnRlcnBvbGFudC5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBJbnRlcnBvbGFudC5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBRdWF0ZXJuaW9uTGluZWFySW50ZXJwb2xhbnQsXFxuXFxuXFx0XFx0aW50ZXJwb2xhdGVfOiBmdW5jdGlvbiAoIGkxLCB0MCwgdCwgdDEgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0QnVmZmVyLFxcblxcdFxcdFxcdFxcdHZhbHVlcyA9IHRoaXMuc2FtcGxlVmFsdWVzLFxcblxcdFxcdFxcdFxcdHN0cmlkZSA9IHRoaXMudmFsdWVTaXplLFxcblxcblxcdFxcdFxcdFxcdG9mZnNldCA9IGkxICogc3RyaWRlLFxcblxcblxcdFxcdFxcdFxcdGFscGhhID0gKCB0IC0gdDAgKSAvICggdDEgLSB0MCApO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBlbmQgPSBvZmZzZXQgKyBzdHJpZGU7IG9mZnNldCAhPT0gZW5kOyBvZmZzZXQgKz0gNCApIHtcXG5cXG5cXHRcXHRcXHRcXHRRdWF0ZXJuaW9uLnNsZXJwRmxhdCggcmVzdWx0LCAwLCB2YWx1ZXMsIG9mZnNldCAtIHN0cmlkZSwgdmFsdWVzLCBvZmZzZXQsIGFscGhhICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKlxcblxcdCAqIEEgVHJhY2sgb2YgcXVhdGVybmlvbiBrZXlmcmFtZSB2YWx1ZXMuXFxuXFx0ICpcXG5cXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xcblxcdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xcblxcdCAqIEBhdXRob3IgdHNjaHdcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcXG5cXG5cXHRcXHRLZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcXG5cXG5cXHR9XFxuXFxuXFx0UXVhdGVybmlvbktleWZyYW1lVHJhY2sucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjayxcXG5cXG5cXHRcXHRWYWx1ZVR5cGVOYW1lOiAncXVhdGVybmlvbicsXFxuXFxuXFx0XFx0Ly8gVmFsdWVCdWZmZXJUeXBlIGlzIGluaGVyaXRlZFxcblxcblxcdFxcdERlZmF1bHRJbnRlcnBvbGF0aW9uOiBJbnRlcnBvbGF0ZUxpbmVhcixcXG5cXG5cXHRcXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI6IGZ1bmN0aW9uICggcmVzdWx0ICkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50KCB0aGlzLnRpbWVzLCB0aGlzLnZhbHVlcywgdGhpcy5nZXRWYWx1ZVNpemUoKSwgcmVzdWx0ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRJbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6IHVuZGVmaW5lZCAvLyBub3QgeWV0IGltcGxlbWVudGVkXFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqXFxuXFx0ICogQSBUcmFjayBvZiBrZXlmcmFtZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgY29sb3IuXFxuXFx0ICpcXG5cXHQgKlxcblxcdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXFxuXFx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIENvbG9yS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcXG5cXG5cXHRcXHRLZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcXG5cXG5cXHR9XFxuXFxuXFx0Q29sb3JLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEtleWZyYW1lVHJhY2sucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogQ29sb3JLZXlmcmFtZVRyYWNrLFxcblxcblxcdFxcdFZhbHVlVHlwZU5hbWU6ICdjb2xvcidcXG5cXG5cXHRcXHQvLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXFxuXFxuXFx0XFx0Ly8gRGVmYXVsdEludGVycG9sYXRpb24gaXMgaW5oZXJpdGVkXFxuXFxuXFx0XFx0Ly8gTm90ZTogVmVyeSBiYXNpYyBpbXBsZW1lbnRhdGlvbiBhbmQgbm90aGluZyBzcGVjaWFsIHlldC5cXG5cXHRcXHQvLyBIb3dldmVyLCB0aGlzIGlzIHRoZSBwbGFjZSBmb3IgY29sb3Igc3BhY2UgcGFyYW1ldGVyaXphdGlvbi5cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICpcXG5cXHQgKiBBIFRyYWNrIG9mIG51bWVyaWMga2V5ZnJhbWUgdmFsdWVzLlxcblxcdCAqXFxuXFx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cXG5cXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gTnVtYmVyS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcXG5cXG5cXHRcXHRLZXlmcmFtZVRyYWNrLmNhbGwoIHRoaXMsIG5hbWUsIHRpbWVzLCB2YWx1ZXMsIGludGVycG9sYXRpb24gKTtcXG5cXG5cXHR9XFxuXFxuXFx0TnVtYmVyS2V5ZnJhbWVUcmFjay5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IE51bWJlcktleWZyYW1lVHJhY2ssXFxuXFxuXFx0XFx0VmFsdWVUeXBlTmFtZTogJ251bWJlcidcXG5cXG5cXHRcXHQvLyBWYWx1ZUJ1ZmZlclR5cGUgaXMgaW5oZXJpdGVkXFxuXFxuXFx0XFx0Ly8gRGVmYXVsdEludGVycG9sYXRpb24gaXMgaW5oZXJpdGVkXFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEZhc3QgYW5kIHNpbXBsZSBjdWJpYyBzcGxpbmUgaW50ZXJwb2xhbnQuXFxuXFx0ICpcXG5cXHQgKiBJdCB3YXMgZGVyaXZlZCBmcm9tIGEgSGVybWl0aWFuIGNvbnN0cnVjdGlvbiBzZXR0aW5nIHRoZSBmaXJzdCBkZXJpdmF0aXZlXFxuXFx0ICogYXQgZWFjaCBzYW1wbGUgcG9zaXRpb24gdG8gdGhlIGxpbmVhciBzbG9wZSBiZXR3ZWVuIG5laWdoYm9yaW5nIHBvc2l0aW9uc1xcblxcdCAqIG92ZXIgdGhlaXIgcGFyYW1ldGVyIGludGVydmFsLlxcblxcdCAqXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEN1YmljSW50ZXJwb2xhbnQoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XFxuXFxuXFx0XFx0SW50ZXJwb2xhbnQuY2FsbCggdGhpcywgcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xcblxcblxcdFxcdHRoaXMuX3dlaWdodFByZXYgPSAtIDA7XFxuXFx0XFx0dGhpcy5fb2Zmc2V0UHJldiA9IC0gMDtcXG5cXHRcXHR0aGlzLl93ZWlnaHROZXh0ID0gLSAwO1xcblxcdFxcdHRoaXMuX29mZnNldE5leHQgPSAtIDA7XFxuXFxuXFx0fVxcblxcblxcdEN1YmljSW50ZXJwb2xhbnQucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggSW50ZXJwb2xhbnQucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogQ3ViaWNJbnRlcnBvbGFudCxcXG5cXG5cXHRcXHREZWZhdWx0U2V0dGluZ3NfOiB7XFxuXFxuXFx0XFx0XFx0ZW5kaW5nU3RhcnQ6IFplcm9DdXJ2YXR1cmVFbmRpbmcsXFxuXFx0XFx0XFx0ZW5kaW5nRW5kOiBaZXJvQ3VydmF0dXJlRW5kaW5nXFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpbnRlcnZhbENoYW5nZWRfOiBmdW5jdGlvbiAoIGkxLCB0MCwgdDEgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHBwID0gdGhpcy5wYXJhbWV0ZXJQb3NpdGlvbnMsXFxuXFx0XFx0XFx0XFx0aVByZXYgPSBpMSAtIDIsXFxuXFx0XFx0XFx0XFx0aU5leHQgPSBpMSArIDEsXFxuXFxuXFx0XFx0XFx0XFx0dFByZXYgPSBwcFsgaVByZXYgXSxcXG5cXHRcXHRcXHRcXHR0TmV4dCA9IHBwWyBpTmV4dCBdO1xcblxcblxcdFxcdFxcdGlmICggdFByZXYgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRzd2l0Y2ggKCB0aGlzLmdldFNldHRpbmdzXygpLmVuZGluZ1N0YXJ0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgWmVyb1Nsb3BlRW5kaW5nOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGYnKHQwKSA9IDBcXG5cXHRcXHRcXHRcXHRcXHRcXHRpUHJldiA9IGkxO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRQcmV2ID0gMiAqIHQwIC0gdDE7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSBXcmFwQXJvdW5kRW5kaW5nOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIHVzZSB0aGUgb3RoZXIgZW5kIG9mIHRoZSBjdXJ2ZVxcblxcdFxcdFxcdFxcdFxcdFxcdGlQcmV2ID0gcHAubGVuZ3RoIC0gMjtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0UHJldiA9IHQwICsgcHBbIGlQcmV2IF0gLSBwcFsgaVByZXYgKyAxIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZGVmYXVsdDogLy8gWmVyb0N1cnZhdHVyZUVuZGluZ1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGYnJyh0MCkgPSAwIGEuay5hLiBOYXR1cmFsIFNwbGluZVxcblxcdFxcdFxcdFxcdFxcdFxcdGlQcmV2ID0gaTE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dFByZXYgPSB0MTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdE5leHQgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRzd2l0Y2ggKCB0aGlzLmdldFNldHRpbmdzXygpLmVuZGluZ0VuZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlIFplcm9TbG9wZUVuZGluZzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBmJyh0TikgPSAwXFxuXFx0XFx0XFx0XFx0XFx0XFx0aU5leHQgPSBpMTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0TmV4dCA9IDIgKiB0MSAtIHQwO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgV3JhcEFyb3VuZEVuZGluZzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB1c2UgdGhlIG90aGVyIGVuZCBvZiB0aGUgY3VydmVcXG5cXHRcXHRcXHRcXHRcXHRcXHRpTmV4dCA9IDE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dE5leHQgPSB0MSArIHBwWyAxIF0gLSBwcFsgMCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGRlZmF1bHQ6IC8vIFplcm9DdXJ2YXR1cmVFbmRpbmdcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBmJycodE4pID0gMCwgYS5rLmEuIE5hdHVyYWwgU3BsaW5lXFxuXFx0XFx0XFx0XFx0XFx0XFx0aU5leHQgPSBpMSAtIDE7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dE5leHQgPSB0MDtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBoYWxmRHQgPSAoIHQxIC0gdDAgKSAqIDAuNSxcXG5cXHRcXHRcXHRcXHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZTtcXG5cXG5cXHRcXHRcXHR0aGlzLl93ZWlnaHRQcmV2ID0gaGFsZkR0IC8gKCB0MCAtIHRQcmV2ICk7XFxuXFx0XFx0XFx0dGhpcy5fd2VpZ2h0TmV4dCA9IGhhbGZEdCAvICggdE5leHQgLSB0MSApO1xcblxcdFxcdFxcdHRoaXMuX29mZnNldFByZXYgPSBpUHJldiAqIHN0cmlkZTtcXG5cXHRcXHRcXHR0aGlzLl9vZmZzZXROZXh0ID0gaU5leHQgKiBzdHJpZGU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpbnRlcnBvbGF0ZV86IGZ1bmN0aW9uICggaTEsIHQwLCB0LCB0MSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gdGhpcy5yZXN1bHRCdWZmZXIsXFxuXFx0XFx0XFx0XFx0dmFsdWVzID0gdGhpcy5zYW1wbGVWYWx1ZXMsXFxuXFx0XFx0XFx0XFx0c3RyaWRlID0gdGhpcy52YWx1ZVNpemUsXFxuXFxuXFx0XFx0XFx0XFx0bzEgPSBpMSAqIHN0cmlkZSxcXHRcXHRvMCA9IG8xIC0gc3RyaWRlLFxcblxcdFxcdFxcdFxcdG9QID0gdGhpcy5fb2Zmc2V0UHJldiwgXFx0b04gPSB0aGlzLl9vZmZzZXROZXh0LFxcblxcdFxcdFxcdFxcdHdQID0gdGhpcy5fd2VpZ2h0UHJldixcXHR3TiA9IHRoaXMuX3dlaWdodE5leHQsXFxuXFxuXFx0XFx0XFx0XFx0cCA9ICggdCAtIHQwICkgLyAoIHQxIC0gdDAgKSxcXG5cXHRcXHRcXHRcXHRwcCA9IHAgKiBwLFxcblxcdFxcdFxcdFxcdHBwcCA9IHBwICogcDtcXG5cXG5cXHRcXHRcXHQvLyBldmFsdWF0ZSBwb2x5bm9taWFsc1xcblxcblxcdFxcdFxcdHZhciBzUCA9IC0gd1AgKiBwcHAgKyAyICogd1AgKiBwcCAtIHdQICogcDtcXG5cXHRcXHRcXHR2YXIgczAgPSAoIDEgKyB3UCApICogcHBwICsgKCAtIDEuNSAtIDIgKiB3UCApICogcHAgKyAoIC0gMC41ICsgd1AgKSAqIHAgKyAxO1xcblxcdFxcdFxcdHZhciBzMSA9ICggLSAxIC0gd04gKSAqIHBwcCArICggMS41ICsgd04gKSAqIHBwICsgMC41ICogcDtcXG5cXHRcXHRcXHR2YXIgc04gPSB3TiAqIHBwcCAtIHdOICogcHA7XFxuXFxuXFx0XFx0XFx0Ly8gY29tYmluZSBkYXRhIGxpbmVhcmx5XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmVzdWx0WyBpIF0gPVxcblxcdFxcdFxcdFxcdFxcdFxcdHNQICogdmFsdWVzWyBvUCArIGkgXSArXFxuXFx0XFx0XFx0XFx0XFx0XFx0czAgKiB2YWx1ZXNbIG8wICsgaSBdICtcXG5cXHRcXHRcXHRcXHRcXHRcXHRzMSAqIHZhbHVlc1sgbzEgKyBpIF0gK1xcblxcdFxcdFxcdFxcdFxcdFxcdHNOICogdmFsdWVzWyBvTiArIGkgXTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgdHNjaHdcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBMaW5lYXJJbnRlcnBvbGFudCggcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApIHtcXG5cXG5cXHRcXHRJbnRlcnBvbGFudC5jYWxsKCB0aGlzLCBwYXJhbWV0ZXJQb3NpdGlvbnMsIHNhbXBsZVZhbHVlcywgc2FtcGxlU2l6ZSwgcmVzdWx0QnVmZmVyICk7XFxuXFxuXFx0fVxcblxcblxcdExpbmVhckludGVycG9sYW50LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEludGVycG9sYW50LnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IExpbmVhckludGVycG9sYW50LFxcblxcblxcdFxcdGludGVycG9sYXRlXzogZnVuY3Rpb24gKCBpMSwgdDAsIHQsIHQxICkge1xcblxcblxcdFxcdFxcdHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdEJ1ZmZlcixcXG5cXHRcXHRcXHRcXHR2YWx1ZXMgPSB0aGlzLnNhbXBsZVZhbHVlcyxcXG5cXHRcXHRcXHRcXHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcXG5cXG5cXHRcXHRcXHRcXHRvZmZzZXQxID0gaTEgKiBzdHJpZGUsXFxuXFx0XFx0XFx0XFx0b2Zmc2V0MCA9IG9mZnNldDEgLSBzdHJpZGUsXFxuXFxuXFx0XFx0XFx0XFx0d2VpZ2h0MSA9ICggdCAtIHQwICkgLyAoIHQxIC0gdDAgKSxcXG5cXHRcXHRcXHRcXHR3ZWlnaHQwID0gMSAtIHdlaWdodDE7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmVzdWx0WyBpIF0gPVxcblxcdFxcdFxcdFxcdFxcdFxcdHZhbHVlc1sgb2Zmc2V0MCArIGkgXSAqIHdlaWdodDAgK1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhbHVlc1sgb2Zmc2V0MSArIGkgXSAqIHdlaWdodDE7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKlxcblxcdCAqIEludGVycG9sYW50IHRoYXQgZXZhbHVhdGVzIHRvIHRoZSBzYW1wbGUgdmFsdWUgYXQgdGhlIHBvc2l0aW9uIHByZWNlZWRpbmdcXG5cXHQgKiB0aGUgcGFyYW1ldGVyLlxcblxcdCAqXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIERpc2NyZXRlSW50ZXJwb2xhbnQoIHBhcmFtZXRlclBvc2l0aW9ucywgc2FtcGxlVmFsdWVzLCBzYW1wbGVTaXplLCByZXN1bHRCdWZmZXIgKSB7XFxuXFxuXFx0XFx0SW50ZXJwb2xhbnQuY2FsbCggdGhpcywgcGFyYW1ldGVyUG9zaXRpb25zLCBzYW1wbGVWYWx1ZXMsIHNhbXBsZVNpemUsIHJlc3VsdEJ1ZmZlciApO1xcblxcblxcdH1cXG5cXG5cXHREaXNjcmV0ZUludGVycG9sYW50LnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEludGVycG9sYW50LnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IERpc2NyZXRlSW50ZXJwb2xhbnQsXFxuXFxuXFx0XFx0aW50ZXJwb2xhdGVfOiBmdW5jdGlvbiAoIGkxIC8qLCB0MCwgdCwgdDEgKi8gKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuY29weVNhbXBsZVZhbHVlXyggaTEgLSAxICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxuXFx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cXG5cXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cXG5cXHQgKi9cXG5cXG5cXHR2YXIgQW5pbWF0aW9uVXRpbHMgPSB7XFxuXFxuXFx0XFx0Ly8gc2FtZSBhcyBBcnJheS5wcm90b3R5cGUuc2xpY2UsIGJ1dCBhbHNvIHdvcmtzIG9uIHR5cGVkIGFycmF5c1xcblxcdFxcdGFycmF5U2xpY2U6IGZ1bmN0aW9uICggYXJyYXksIGZyb20sIHRvICkge1xcblxcblxcdFxcdFxcdGlmICggQW5pbWF0aW9uVXRpbHMuaXNUeXBlZEFycmF5KCBhcnJheSApICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGluIGlvczkgYXJyYXkuc3ViYXJyYXkoZnJvbSwgdW5kZWZpbmVkKSB3aWxsIHJldHVybiBlbXB0eSBhcnJheVxcblxcdFxcdFxcdFxcdC8vIGJ1dCBhcnJheS5zdWJhcnJheShmcm9tKSBvciBhcnJheS5zdWJhcnJheShmcm9tLCBsZW4pIGlzIGNvcnJlY3RcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbmV3IGFycmF5LmNvbnN0cnVjdG9yKCBhcnJheS5zdWJhcnJheSggZnJvbSwgdG8gIT09IHVuZGVmaW5lZCA/IHRvIDogYXJyYXkubGVuZ3RoICkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGFycmF5LnNsaWNlKCBmcm9tLCB0byApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gY29udmVydHMgYW4gYXJyYXkgdG8gYSBzcGVjaWZpYyB0eXBlXFxuXFx0XFx0Y29udmVydEFycmF5OiBmdW5jdGlvbiAoIGFycmF5LCB0eXBlLCBmb3JjZUNsb25lICkge1xcblxcblxcdFxcdFxcdGlmICggISBhcnJheSB8fCAvLyBsZXQgJ3VuZGVmaW5lZCcgYW5kICdudWxsJyBwYXNzXFxuXFx0XFx0XFx0XFx0XFx0ISBmb3JjZUNsb25lICYmIGFycmF5LmNvbnN0cnVjdG9yID09PSB0eXBlICkgcmV0dXJuIGFycmF5O1xcblxcblxcdFxcdFxcdGlmICggdHlwZW9mIHR5cGUuQllURVNfUEVSX0VMRU1FTlQgPT09ICdudW1iZXInICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBuZXcgdHlwZSggYXJyYXkgKTsgLy8gY3JlYXRlIHR5cGVkIGFycmF5XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJyYXkgKTsgLy8gY3JlYXRlIEFycmF5XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRpc1R5cGVkQXJyYXk6IGZ1bmN0aW9uICggb2JqZWN0ICkge1xcblxcblxcdFxcdFxcdHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoIG9iamVjdCApICYmXFxuXFx0XFx0XFx0XFx0XFx0ISAoIG9iamVjdCBpbnN0YW5jZW9mIERhdGFWaWV3ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyByZXR1cm5zIGFuIGFycmF5IGJ5IHdoaWNoIHRpbWVzIGFuZCB2YWx1ZXMgY2FuIGJlIHNvcnRlZFxcblxcdFxcdGdldEtleWZyYW1lT3JkZXI6IGZ1bmN0aW9uICggdGltZXMgKSB7XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gY29tcGFyZVRpbWUoIGksIGogKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRpbWVzWyBpIF0gLSB0aW1lc1sgaiBdO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgbiA9IHRpbWVzLmxlbmd0aDtcXG5cXHRcXHRcXHR2YXIgcmVzdWx0ID0gbmV3IEFycmF5KCBuICk7XFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuOyArKyBpICkgcmVzdWx0WyBpIF0gPSBpO1xcblxcblxcdFxcdFxcdHJlc3VsdC5zb3J0KCBjb21wYXJlVGltZSApO1xcblxcblxcdFxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyB1c2VzIHRoZSBhcnJheSBwcmV2aW91c2x5IHJldHVybmVkIGJ5ICdnZXRLZXlmcmFtZU9yZGVyJyB0byBzb3J0IGRhdGFcXG5cXHRcXHRzb3J0ZWRBcnJheTogZnVuY3Rpb24gKCB2YWx1ZXMsIHN0cmlkZSwgb3JkZXIgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG5WYWx1ZXMgPSB2YWx1ZXMubGVuZ3RoO1xcblxcdFxcdFxcdHZhciByZXN1bHQgPSBuZXcgdmFsdWVzLmNvbnN0cnVjdG9yKCBuVmFsdWVzICk7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBkc3RPZmZzZXQgPSAwOyBkc3RPZmZzZXQgIT09IG5WYWx1ZXM7ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHNyY09mZnNldCA9IG9yZGVyWyBpIF0gKiBzdHJpZGU7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmVzdWx0WyBkc3RPZmZzZXQgKysgXSA9IHZhbHVlc1sgc3JjT2Zmc2V0ICsgaiBdO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIGZ1bmN0aW9uIGZvciBwYXJzaW5nIEFPUyBrZXlmcmFtZSBmb3JtYXRzXFxuXFx0XFx0ZmxhdHRlbkpTT046IGZ1bmN0aW9uICgganNvbktleXMsIHRpbWVzLCB2YWx1ZXMsIHZhbHVlUHJvcGVydHlOYW1lICkge1xcblxcblxcdFxcdFxcdHZhciBpID0gMSwga2V5ID0ganNvbktleXNbIDAgXTtcXG5cXG5cXHRcXHRcXHR3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICYmIGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGtleSA9IGpzb25LZXlzWyBpICsrIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICgga2V5ID09PSB1bmRlZmluZWQgKSByZXR1cm47IC8vIG5vIGRhdGFcXG5cXG5cXHRcXHRcXHR2YXIgdmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XFxuXFx0XFx0XFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgcmV0dXJuOyAvLyBubyBkYXRhXFxuXFxuXFx0XFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xcblxcblxcdFxcdFxcdFxcdGRvIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGltZXMucHVzaCgga2V5LnRpbWUgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZXMucHVzaC5hcHBseSggdmFsdWVzLCB2YWx1ZSApOyAvLyBwdXNoIGFsbCBlbGVtZW50c1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRrZXkgPSBqc29uS2V5c1sgaSArKyBdO1xcblxcblxcdFxcdFxcdFxcdH0gd2hpbGUgKCBrZXkgIT09IHVuZGVmaW5lZCApO1xcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIHZhbHVlLnRvQXJyYXkgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyAuLi5hc3N1bWUgVEhSRUUuTWF0aC1pc2hcXG5cXG5cXHRcXHRcXHRcXHRkbyB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFsdWUgPSBrZXlbIHZhbHVlUHJvcGVydHlOYW1lIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRpbWVzLnB1c2goIGtleS50aW1lICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFsdWUudG9BcnJheSggdmFsdWVzLCB2YWx1ZXMubGVuZ3RoICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGtleSA9IGpzb25LZXlzWyBpICsrIF07XFxuXFxuXFx0XFx0XFx0XFx0fSB3aGlsZSAoIGtleSAhPT0gdW5kZWZpbmVkICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBvdGhlcndpc2UgcHVzaCBhcy1pc1xcblxcblxcdFxcdFxcdFxcdGRvIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZSA9IGtleVsgdmFsdWVQcm9wZXJ0eU5hbWUgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGltZXMucHVzaCgga2V5LnRpbWUgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZXMucHVzaCggdmFsdWUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0a2V5ID0ganNvbktleXNbIGkgKysgXTtcXG5cXG5cXHRcXHRcXHRcXHR9IHdoaWxlICgga2V5ICE9PSB1bmRlZmluZWQgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICpcXG5cXHQgKiBBIHRpbWVkIHNlcXVlbmNlIG9mIGtleWZyYW1lcyBmb3IgYSBzcGVjaWZpYyBwcm9wZXJ0eS5cXG5cXHQgKlxcblxcdCAqXFxuXFx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cXG5cXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gS2V5ZnJhbWVUcmFjayggbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApIHtcXG5cXG5cXHRcXHRpZiAoIG5hbWUgPT09IHVuZGVmaW5lZCApIHRocm93IG5ldyBFcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IHRyYWNrIG5hbWUgaXMgdW5kZWZpbmVkJyApO1xcblxcdFxcdGlmICggdGltZXMgPT09IHVuZGVmaW5lZCB8fCB0aW1lcy5sZW5ndGggPT09IDAgKSB0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBubyBrZXlmcmFtZXMgaW4gdHJhY2sgbmFtZWQgJyArIG5hbWUgKTtcXG5cXG5cXHRcXHR0aGlzLm5hbWUgPSBuYW1lO1xcblxcblxcdFxcdHRoaXMudGltZXMgPSBBbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkoIHRpbWVzLCB0aGlzLlRpbWVCdWZmZXJUeXBlICk7XFxuXFx0XFx0dGhpcy52YWx1ZXMgPSBBbmltYXRpb25VdGlscy5jb252ZXJ0QXJyYXkoIHZhbHVlcywgdGhpcy5WYWx1ZUJ1ZmZlclR5cGUgKTtcXG5cXG5cXHRcXHR0aGlzLnNldEludGVycG9sYXRpb24oIGludGVycG9sYXRpb24gfHwgdGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbiApO1xcblxcblxcdFxcdHRoaXMudmFsaWRhdGUoKTtcXG5cXHRcXHR0aGlzLm9wdGltaXplKCk7XFxuXFxuXFx0fVxcblxcblxcdC8vIFN0YXRpYyBtZXRob2RzOlxcblxcblxcdE9iamVjdC5hc3NpZ24oIEtleWZyYW1lVHJhY2ssIHtcXG5cXG5cXHRcXHQvLyBTZXJpYWxpemF0aW9uIChpbiBzdGF0aWMgY29udGV4dCwgYmVjYXVzZSBvZiBjb25zdHJ1Y3RvciBpbnZvY2F0aW9uXFxuXFx0XFx0Ly8gYW5kIGF1dG9tYXRpYyBpbnZvY2F0aW9uIG9mIC50b0pTT04pOlxcblxcblxcdFxcdHBhcnNlOiBmdW5jdGlvbiAoIGpzb24gKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uLnR5cGUgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiB0cmFjayB0eXBlIHVuZGVmaW5lZCwgY2FuIG5vdCBwYXJzZScgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIHRyYWNrVHlwZSA9IEtleWZyYW1lVHJhY2suX2dldFRyYWNrVHlwZUZvclZhbHVlVHlwZU5hbWUoIGpzb24udHlwZSApO1xcblxcblxcdFxcdFxcdGlmICgganNvbi50aW1lcyA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB0aW1lcyA9IFtdLCB2YWx1ZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRBbmltYXRpb25VdGlscy5mbGF0dGVuSlNPTigganNvbi5rZXlzLCB0aW1lcywgdmFsdWVzLCAndmFsdWUnICk7XFxuXFxuXFx0XFx0XFx0XFx0anNvbi50aW1lcyA9IHRpbWVzO1xcblxcdFxcdFxcdFxcdGpzb24udmFsdWVzID0gdmFsdWVzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBkZXJpdmVkIGNsYXNzZXMgY2FuIGRlZmluZSBhIHN0YXRpYyBwYXJzZSBtZXRob2RcXG5cXHRcXHRcXHRpZiAoIHRyYWNrVHlwZS5wYXJzZSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0cmFja1R5cGUucGFyc2UoIGpzb24gKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdC8vIGJ5IGRlZmF1bHQsIHdlIGFzc3VtZSBhIGNvbnN0cnVjdG9yIGNvbXBhdGlibGUgd2l0aCB0aGUgYmFzZVxcblxcdFxcdFxcdFxcdHJldHVybiBuZXcgdHJhY2tUeXBlKCBqc29uLm5hbWUsIGpzb24udGltZXMsIGpzb24udmFsdWVzLCBqc29uLmludGVycG9sYXRpb24gKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR0b0pTT046IGZ1bmN0aW9uICggdHJhY2sgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRyYWNrVHlwZSA9IHRyYWNrLmNvbnN0cnVjdG9yO1xcblxcblxcdFxcdFxcdHZhciBqc29uO1xcblxcblxcdFxcdFxcdC8vIGRlcml2ZWQgY2xhc3NlcyBjYW4gZGVmaW5lIGEgc3RhdGljIHRvSlNPTiBtZXRob2RcXG5cXHRcXHRcXHRpZiAoIHRyYWNrVHlwZS50b0pTT04gIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRqc29uID0gdHJhY2tUeXBlLnRvSlNPTiggdHJhY2sgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdC8vIGJ5IGRlZmF1bHQsIHdlIGFzc3VtZSB0aGUgZGF0YSBjYW4gYmUgc2VyaWFsaXplZCBhcy1pc1xcblxcdFxcdFxcdFxcdGpzb24gPSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0J25hbWUnOiB0cmFjay5uYW1lLFxcblxcdFxcdFxcdFxcdFxcdCd0aW1lcyc6IEFuaW1hdGlvblV0aWxzLmNvbnZlcnRBcnJheSggdHJhY2sudGltZXMsIEFycmF5ICksXFxuXFx0XFx0XFx0XFx0XFx0J3ZhbHVlcyc6IEFuaW1hdGlvblV0aWxzLmNvbnZlcnRBcnJheSggdHJhY2sudmFsdWVzLCBBcnJheSApXFxuXFxuXFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgaW50ZXJwb2xhdGlvbiA9IHRyYWNrLmdldEludGVycG9sYXRpb24oKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGludGVycG9sYXRpb24gIT09IHRyYWNrLkRlZmF1bHRJbnRlcnBvbGF0aW9uICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGpzb24uaW50ZXJwb2xhdGlvbiA9IGludGVycG9sYXRpb247XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRqc29uLnR5cGUgPSB0cmFjay5WYWx1ZVR5cGVOYW1lOyAvLyBtYW5kYXRvcnlcXG5cXG5cXHRcXHRcXHRyZXR1cm4ganNvbjtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9nZXRUcmFja1R5cGVGb3JWYWx1ZVR5cGVOYW1lOiBmdW5jdGlvbiAoIHR5cGVOYW1lICkge1xcblxcblxcdFxcdFxcdHN3aXRjaCAoIHR5cGVOYW1lLnRvTG93ZXJDYXNlKCkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSAnc2NhbGFyJzpcXG5cXHRcXHRcXHRcXHRjYXNlICdkb3VibGUnOlxcblxcdFxcdFxcdFxcdGNhc2UgJ2Zsb2F0JzpcXG5cXHRcXHRcXHRcXHRjYXNlICdudW1iZXInOlxcblxcdFxcdFxcdFxcdGNhc2UgJ2ludGVnZXInOlxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBOdW1iZXJLZXlmcmFtZVRyYWNrO1xcblxcblxcdFxcdFxcdFxcdGNhc2UgJ3ZlY3Rvcic6XFxuXFx0XFx0XFx0XFx0Y2FzZSAndmVjdG9yMic6XFxuXFx0XFx0XFx0XFx0Y2FzZSAndmVjdG9yMyc6XFxuXFx0XFx0XFx0XFx0Y2FzZSAndmVjdG9yNCc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIFZlY3RvcktleWZyYW1lVHJhY2s7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSAnY29sb3InOlxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBDb2xvcktleWZyYW1lVHJhY2s7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSAncXVhdGVybmlvbic6XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIFF1YXRlcm5pb25LZXlmcmFtZVRyYWNrO1xcblxcblxcdFxcdFxcdFxcdGNhc2UgJ2Jvb2wnOlxcblxcdFxcdFxcdFxcdGNhc2UgJ2Jvb2xlYW4nOlxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBCb29sZWFuS2V5ZnJhbWVUcmFjaztcXG5cXG5cXHRcXHRcXHRcXHRjYXNlICdzdHJpbmcnOlxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBTdHJpbmdLZXlmcmFtZVRyYWNrO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBVbnN1cHBvcnRlZCB0eXBlTmFtZTogJyArIHR5cGVOYW1lICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuYXNzaWduKCBLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBLZXlmcmFtZVRyYWNrLFxcblxcblxcdFxcdFRpbWVCdWZmZXJUeXBlOiBGbG9hdDMyQXJyYXksXFxuXFxuXFx0XFx0VmFsdWVCdWZmZXJUeXBlOiBGbG9hdDMyQXJyYXksXFxuXFxuXFx0XFx0RGVmYXVsdEludGVycG9sYXRpb246IEludGVycG9sYXRlTGluZWFyLFxcblxcblxcdFxcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlOiBmdW5jdGlvbiAoIHJlc3VsdCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IERpc2NyZXRlSW50ZXJwb2xhbnQoIHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdEludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjogZnVuY3Rpb24gKCByZXN1bHQgKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBMaW5lYXJJbnRlcnBvbGFudCggdGhpcy50aW1lcywgdGhpcy52YWx1ZXMsIHRoaXMuZ2V0VmFsdWVTaXplKCksIHJlc3VsdCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0SW50ZXJwb2xhbnRGYWN0b3J5TWV0aG9kU21vb3RoOiBmdW5jdGlvbiAoIHJlc3VsdCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IEN1YmljSW50ZXJwb2xhbnQoIHRoaXMudGltZXMsIHRoaXMudmFsdWVzLCB0aGlzLmdldFZhbHVlU2l6ZSgpLCByZXN1bHQgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEludGVycG9sYXRpb246IGZ1bmN0aW9uICggaW50ZXJwb2xhdGlvbiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZmFjdG9yeU1ldGhvZDtcXG5cXG5cXHRcXHRcXHRzd2l0Y2ggKCBpbnRlcnBvbGF0aW9uICkge1xcblxcblxcdFxcdFxcdFxcdGNhc2UgSW50ZXJwb2xhdGVEaXNjcmV0ZTpcXG5cXG5cXHRcXHRcXHRcXHRcXHRmYWN0b3J5TWV0aG9kID0gdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2REaXNjcmV0ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIEludGVycG9sYXRlTGluZWFyOlxcblxcblxcdFxcdFxcdFxcdFxcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZExpbmVhcjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRjYXNlIEludGVycG9sYXRlU21vb3RoOlxcblxcblxcdFxcdFxcdFxcdFxcdGZhY3RvcnlNZXRob2QgPSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZFNtb290aDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBmYWN0b3J5TWV0aG9kID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG1lc3NhZ2UgPSBcXFwidW5zdXBwb3J0ZWQgaW50ZXJwb2xhdGlvbiBmb3IgXFxcIiArXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5WYWx1ZVR5cGVOYW1lICsgXFxcIiBrZXlmcmFtZSB0cmFjayBuYW1lZCBcXFwiICsgdGhpcy5uYW1lO1xcblxcblxcdFxcdFxcdFxcdGlmICggdGhpcy5jcmVhdGVJbnRlcnBvbGFudCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGZhbGwgYmFjayB0byBkZWZhdWx0LCB1bmxlc3MgdGhlIGRlZmF1bHQgaXRzZWxmIGlzIG1lc3NlZCB1cFxcblxcdFxcdFxcdFxcdFxcdGlmICggaW50ZXJwb2xhdGlvbiAhPT0gdGhpcy5EZWZhdWx0SW50ZXJwb2xhdGlvbiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnNldEludGVycG9sYXRpb24oIHRoaXMuRGVmYXVsdEludGVycG9sYXRpb24gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggbWVzc2FnZSApOyAvLyBmYXRhbCwgaW4gdGhpcyBjYXNlXFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5LZXlmcmFtZVRyYWNrOicsIG1lc3NhZ2UgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQgPSBmYWN0b3J5TWV0aG9kO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0SW50ZXJwb2xhdGlvbjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHN3aXRjaCAoIHRoaXMuY3JlYXRlSW50ZXJwb2xhbnQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y2FzZSB0aGlzLkludGVycG9sYW50RmFjdG9yeU1ldGhvZERpc2NyZXRlOlxcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBJbnRlcnBvbGF0ZURpc2NyZXRlO1xcblxcblxcdFxcdFxcdFxcdGNhc2UgdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RMaW5lYXI6XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIEludGVycG9sYXRlTGluZWFyO1xcblxcblxcdFxcdFxcdFxcdGNhc2UgdGhpcy5JbnRlcnBvbGFudEZhY3RvcnlNZXRob2RTbW9vdGg6XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIEludGVycG9sYXRlU21vb3RoO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldFZhbHVlU2l6ZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLnZhbHVlcy5sZW5ndGggLyB0aGlzLnRpbWVzLmxlbmd0aDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIG1vdmUgYWxsIGtleWZyYW1lcyBlaXRoZXIgZm9yd2FyZHMgb3IgYmFja3dhcmRzIGluIHRpbWVcXG5cXHRcXHRzaGlmdDogZnVuY3Rpb24gKCB0aW1lT2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdGlmICggdGltZU9mZnNldCAhPT0gMC4wICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB0aW1lcyA9IHRoaXMudGltZXM7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gdGltZXMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRpbWVzWyBpIF0gKz0gdGltZU9mZnNldDtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gc2NhbGUgYWxsIGtleWZyYW1lIHRpbWVzIGJ5IGEgZmFjdG9yICh1c2VmdWwgZm9yIGZyYW1lIDwtPiBzZWNvbmRzIGNvbnZlcnNpb25zKVxcblxcdFxcdHNjYWxlOiBmdW5jdGlvbiAoIHRpbWVTY2FsZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRpbWVTY2FsZSAhPT0gMS4wICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB0aW1lcyA9IHRoaXMudGltZXM7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gdGltZXMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRpbWVzWyBpIF0gKj0gdGltZVNjYWxlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyByZW1vdmVzIGtleWZyYW1lcyBiZWZvcmUgYW5kIGFmdGVyIGFuaW1hdGlvbiB3aXRob3V0IGNoYW5naW5nIGFueSB2YWx1ZXMgd2l0aGluIHRoZSByYW5nZSBbc3RhcnRUaW1lLCBlbmRUaW1lXS5cXG5cXHRcXHQvLyBJTVBPUlRBTlQ6IFdlIGRvIG5vdCBzaGlmdCBhcm91bmQga2V5cyB0byB0aGUgc3RhcnQgb2YgdGhlIHRyYWNrIHRpbWUsIGJlY2F1c2UgZm9yIGludGVycG9sYXRlZCBrZXlzIHRoaXMgd2lsbCBjaGFuZ2UgdGhlaXIgdmFsdWVzXFxuXFx0XFx0dHJpbTogZnVuY3Rpb24gKCBzdGFydFRpbWUsIGVuZFRpbWUgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRpbWVzID0gdGhpcy50aW1lcyxcXG5cXHRcXHRcXHRcXHRuS2V5cyA9IHRpbWVzLmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRmcm9tID0gMCxcXG5cXHRcXHRcXHRcXHR0byA9IG5LZXlzIC0gMTtcXG5cXG5cXHRcXHRcXHR3aGlsZSAoIGZyb20gIT09IG5LZXlzICYmIHRpbWVzWyBmcm9tIF0gPCBzdGFydFRpbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0KysgZnJvbTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0d2hpbGUgKCB0byAhPT0gLSAxICYmIHRpbWVzWyB0byBdID4gZW5kVGltZSApIHtcXG5cXG5cXHRcXHRcXHRcXHQtLSB0bztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0KysgdG87IC8vIGluY2x1c2l2ZSAtPiBleGNsdXNpdmUgYm91bmRcXG5cXG5cXHRcXHRcXHRpZiAoIGZyb20gIT09IDAgfHwgdG8gIT09IG5LZXlzICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGVtcHR5IHRyYWNrcyBhcmUgZm9yYmlkZGVuLCBzbyBrZWVwIGF0IGxlYXN0IG9uZSBrZXlmcmFtZVxcblxcdFxcdFxcdFxcdGlmICggZnJvbSA+PSB0byApIHRvID0gTWF0aC5tYXgoIHRvLCAxICksIGZyb20gPSB0byAtIDE7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHN0cmlkZSA9IHRoaXMuZ2V0VmFsdWVTaXplKCk7XFxuXFx0XFx0XFx0XFx0dGhpcy50aW1lcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UoIHRpbWVzLCBmcm9tLCB0byApO1xcblxcdFxcdFxcdFxcdHRoaXMudmFsdWVzID0gQW5pbWF0aW9uVXRpbHMuYXJyYXlTbGljZSggdGhpcy52YWx1ZXMsIGZyb20gKiBzdHJpZGUsIHRvICogc3RyaWRlICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gZW5zdXJlIHdlIGRvIG5vdCBnZXQgYSBHYXJiYWdlSW5HYXJiYWdlT3V0IHNpdHVhdGlvbiwgbWFrZSBzdXJlIHRyYWNrcyBhcmUgYXQgbGVhc3QgbWluaW1hbGx5IHZpYWJsZVxcblxcdFxcdHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHZhbGlkID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR2YXIgdmFsdWVTaXplID0gdGhpcy5nZXRWYWx1ZVNpemUoKTtcXG5cXHRcXHRcXHRpZiAoIHZhbHVlU2l6ZSAtIE1hdGguZmxvb3IoIHZhbHVlU2l6ZSApICE9PSAwICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5LZXlmcmFtZVRyYWNrOiBJbnZhbGlkIHZhbHVlIHNpemUgaW4gdHJhY2suJywgdGhpcyApO1xcblxcdFxcdFxcdFxcdHZhbGlkID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciB0aW1lcyA9IHRoaXMudGltZXMsXFxuXFx0XFx0XFx0XFx0dmFsdWVzID0gdGhpcy52YWx1ZXMsXFxuXFxuXFx0XFx0XFx0XFx0bktleXMgPSB0aW1lcy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0aWYgKCBuS2V5cyA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogVHJhY2sgaXMgZW1wdHkuJywgdGhpcyApO1xcblxcdFxcdFxcdFxcdHZhbGlkID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBwcmV2VGltZSA9IG51bGw7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBuS2V5czsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgY3VyclRpbWUgPSB0aW1lc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggdHlwZW9mIGN1cnJUaW1lID09PSAnbnVtYmVyJyAmJiBpc05hTiggY3VyclRpbWUgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogVGltZSBpcyBub3QgYSB2YWxpZCBudW1iZXIuJywgdGhpcywgaSwgY3VyclRpbWUgKTtcXG5cXHRcXHRcXHRcXHRcXHR2YWxpZCA9IGZhbHNlO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHByZXZUaW1lICE9PSBudWxsICYmIHByZXZUaW1lID4gY3VyclRpbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLktleWZyYW1lVHJhY2s6IE91dCBvZiBvcmRlciBrZXlzLicsIHRoaXMsIGksIGN1cnJUaW1lLCBwcmV2VGltZSApO1xcblxcdFxcdFxcdFxcdFxcdHZhbGlkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHByZXZUaW1lID0gY3VyclRpbWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdmFsdWVzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBBbmltYXRpb25VdGlscy5pc1R5cGVkQXJyYXkoIHZhbHVlcyApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IHZhbHVlcy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHZhbHVlID0gdmFsdWVzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpc05hTiggdmFsdWUgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuS2V5ZnJhbWVUcmFjazogVmFsdWUgaXMgbm90IGEgdmFsaWQgbnVtYmVyLicsIHRoaXMsIGksIHZhbHVlICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFsaWQgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHZhbGlkO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gcmVtb3ZlcyBlcXVpdmFsZW50IHNlcXVlbnRpYWwga2V5cyBhcyBjb21tb24gaW4gbW9ycGggdGFyZ2V0IHNlcXVlbmNlc1xcblxcdFxcdC8vICgwLDAsMCwwLDEsMSwxLDAsMCwwLDAsMCwwLDApIC0tPiAoMCwwLDEsMSwwLDApXFxuXFx0XFx0b3B0aW1pemU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGltZXMgPSB0aGlzLnRpbWVzLFxcblxcdFxcdFxcdFxcdHZhbHVlcyA9IHRoaXMudmFsdWVzLFxcblxcdFxcdFxcdFxcdHN0cmlkZSA9IHRoaXMuZ2V0VmFsdWVTaXplKCksXFxuXFxuXFx0XFx0XFx0XFx0c21vb3RoSW50ZXJwb2xhdGlvbiA9IHRoaXMuZ2V0SW50ZXJwb2xhdGlvbigpID09PSBJbnRlcnBvbGF0ZVNtb290aCxcXG5cXG5cXHRcXHRcXHRcXHR3cml0ZUluZGV4ID0gMSxcXG5cXHRcXHRcXHRcXHRsYXN0SW5kZXggPSB0aW1lcy5sZW5ndGggLSAxO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMTsgaSA8IGxhc3RJbmRleDsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIga2VlcCA9IGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdHZhciB0aW1lID0gdGltZXNbIGkgXTtcXG5cXHRcXHRcXHRcXHR2YXIgdGltZU5leHQgPSB0aW1lc1sgaSArIDEgXTtcXG5cXG5cXHRcXHRcXHRcXHQvLyByZW1vdmUgYWRqYWNlbnQga2V5ZnJhbWVzIHNjaGVkdWxlZCBhdCB0aGUgc2FtZSB0aW1lXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0aW1lICE9PSB0aW1lTmV4dCAmJiAoIGkgIT09IDEgfHwgdGltZSAhPT0gdGltZVsgMCBdICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhIHNtb290aEludGVycG9sYXRpb24gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gcmVtb3ZlIHVubmVjZXNzYXJ5IGtleWZyYW1lcyBzYW1lIGFzIHRoZWlyIG5laWdoYm9yc1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBvZmZzZXQgPSBpICogc3RyaWRlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG9mZnNldFAgPSBvZmZzZXQgLSBzdHJpZGUsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0b2Zmc2V0TiA9IG9mZnNldCArIHN0cmlkZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDA7IGogIT09IHN0cmlkZTsgKysgaiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgdmFsdWUgPSB2YWx1ZXNbIG9mZnNldCArIGogXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHZhbHVlICE9PSB2YWx1ZXNbIG9mZnNldFAgKyBqIF0gfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZSAhPT0gdmFsdWVzWyBvZmZzZXROICsgaiBdICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGtlZXAgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRrZWVwID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdC8vIGluLXBsYWNlIGNvbXBhY3Rpb25cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGtlZXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBpICE9PSB3cml0ZUluZGV4ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRpbWVzWyB3cml0ZUluZGV4IF0gPSB0aW1lc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciByZWFkT2Zmc2V0ID0gaSAqIHN0cmlkZSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR3cml0ZU9mZnNldCA9IHdyaXRlSW5kZXggKiBzdHJpZGU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFsdWVzWyB3cml0ZU9mZnNldCArIGogXSA9IHZhbHVlc1sgcmVhZE9mZnNldCArIGogXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdCsrIHdyaXRlSW5kZXg7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBmbHVzaCBsYXN0IGtleWZyYW1lIChjb21wYWN0aW9uIGxvb2tzIGFoZWFkKVxcblxcblxcdFxcdFxcdGlmICggbGFzdEluZGV4ID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aW1lc1sgd3JpdGVJbmRleCBdID0gdGltZXNbIGxhc3RJbmRleCBdO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciByZWFkT2Zmc2V0ID0gbGFzdEluZGV4ICogc3RyaWRlLCB3cml0ZU9mZnNldCA9IHdyaXRlSW5kZXggKiBzdHJpZGUsIGogPSAwOyBqICE9PSBzdHJpZGU7ICsrIGogKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFsdWVzWyB3cml0ZU9mZnNldCArIGogXSA9IHZhbHVlc1sgcmVhZE9mZnNldCArIGogXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Kysgd3JpdGVJbmRleDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB3cml0ZUluZGV4ICE9PSB0aW1lcy5sZW5ndGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy50aW1lcyA9IEFuaW1hdGlvblV0aWxzLmFycmF5U2xpY2UoIHRpbWVzLCAwLCB3cml0ZUluZGV4ICk7XFxuXFx0XFx0XFx0XFx0dGhpcy52YWx1ZXMgPSBBbmltYXRpb25VdGlscy5hcnJheVNsaWNlKCB2YWx1ZXMsIDAsIHdyaXRlSW5kZXggKiBzdHJpZGUgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKlxcblxcdCAqIEEgVHJhY2sgb2YgdmVjdG9yZWQga2V5ZnJhbWUgdmFsdWVzLlxcblxcdCAqXFxuXFx0ICpcXG5cXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xcblxcdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xcblxcdCAqIEBhdXRob3IgdHNjaHdcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBWZWN0b3JLZXlmcmFtZVRyYWNrKCBuYW1lLCB0aW1lcywgdmFsdWVzLCBpbnRlcnBvbGF0aW9uICkge1xcblxcblxcdFxcdEtleWZyYW1lVHJhY2suY2FsbCggdGhpcywgbmFtZSwgdGltZXMsIHZhbHVlcywgaW50ZXJwb2xhdGlvbiApO1xcblxcblxcdH1cXG5cXG5cXHRWZWN0b3JLZXlmcmFtZVRyYWNrLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEtleWZyYW1lVHJhY2sucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogVmVjdG9yS2V5ZnJhbWVUcmFjayxcXG5cXG5cXHRcXHRWYWx1ZVR5cGVOYW1lOiAndmVjdG9yJ1xcblxcblxcdFxcdC8vIFZhbHVlQnVmZmVyVHlwZSBpcyBpbmhlcml0ZWRcXG5cXG5cXHRcXHQvLyBEZWZhdWx0SW50ZXJwb2xhdGlvbiBpcyBpbmhlcml0ZWRcXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICpcXG5cXHQgKiBSZXVzYWJsZSBzZXQgb2YgVHJhY2tzIHRoYXQgcmVwcmVzZW50IGFuIGFuaW1hdGlvbi5cXG5cXHQgKlxcblxcdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXFxuXFx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gQW5pbWF0aW9uQ2xpcCggbmFtZSwgZHVyYXRpb24sIHRyYWNrcyApIHtcXG5cXG5cXHRcXHR0aGlzLm5hbWUgPSBuYW1lO1xcblxcdFxcdHRoaXMudHJhY2tzID0gdHJhY2tzO1xcblxcdFxcdHRoaXMuZHVyYXRpb24gPSAoIGR1cmF0aW9uICE9PSB1bmRlZmluZWQgKSA/IGR1cmF0aW9uIDogLSAxO1xcblxcblxcdFxcdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xcblxcblxcdFxcdC8vIHRoaXMgbWVhbnMgaXQgc2hvdWxkIGZpZ3VyZSBvdXQgaXRzIGR1cmF0aW9uIGJ5IHNjYW5uaW5nIHRoZSB0cmFja3NcXG5cXHRcXHRpZiAoIHRoaXMuZHVyYXRpb24gPCAwICkge1xcblxcblxcdFxcdFxcdHRoaXMucmVzZXREdXJhdGlvbigpO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLm9wdGltaXplKCk7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIEFuaW1hdGlvbkNsaXAsIHtcXG5cXG5cXHRcXHRwYXJzZTogZnVuY3Rpb24gKCBqc29uICkge1xcblxcblxcdFxcdFxcdHZhciB0cmFja3MgPSBbXSxcXG5cXHRcXHRcXHRcXHRqc29uVHJhY2tzID0ganNvbi50cmFja3MsXFxuXFx0XFx0XFx0XFx0ZnJhbWVUaW1lID0gMS4wIC8gKCBqc29uLmZwcyB8fCAxLjAgKTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBqc29uVHJhY2tzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0cmFja3MucHVzaCggS2V5ZnJhbWVUcmFjay5wYXJzZSgganNvblRyYWNrc1sgaSBdICkuc2NhbGUoIGZyYW1lVGltZSApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBuZXcgQW5pbWF0aW9uQ2xpcCgganNvbi5uYW1lLCBqc29uLmR1cmF0aW9uLCB0cmFja3MgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRvSlNPTjogZnVuY3Rpb24gKCBjbGlwICkge1xcblxcblxcdFxcdFxcdHZhciB0cmFja3MgPSBbXSxcXG5cXHRcXHRcXHRcXHRjbGlwVHJhY2tzID0gY2xpcC50cmFja3M7XFxuXFxuXFx0XFx0XFx0dmFyIGpzb24gPSB7XFxuXFxuXFx0XFx0XFx0XFx0J25hbWUnOiBjbGlwLm5hbWUsXFxuXFx0XFx0XFx0XFx0J2R1cmF0aW9uJzogY2xpcC5kdXJhdGlvbixcXG5cXHRcXHRcXHRcXHQndHJhY2tzJzogdHJhY2tzXFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBjbGlwVHJhY2tzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0cmFja3MucHVzaCggS2V5ZnJhbWVUcmFjay50b0pTT04oIGNsaXBUcmFja3NbIGkgXSApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBqc29uO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Q3JlYXRlRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2U6IGZ1bmN0aW9uICggbmFtZSwgbW9ycGhUYXJnZXRTZXF1ZW5jZSwgZnBzLCBub0xvb3AgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG51bU1vcnBoVGFyZ2V0cyA9IG1vcnBoVGFyZ2V0U2VxdWVuY2UubGVuZ3RoO1xcblxcdFxcdFxcdHZhciB0cmFja3MgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBudW1Nb3JwaFRhcmdldHM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHRpbWVzID0gW107XFxuXFx0XFx0XFx0XFx0dmFyIHZhbHVlcyA9IFtdO1xcblxcblxcdFxcdFxcdFxcdHRpbWVzLnB1c2goXFxuXFx0XFx0XFx0XFx0XFx0KCBpICsgbnVtTW9ycGhUYXJnZXRzIC0gMSApICUgbnVtTW9ycGhUYXJnZXRzLFxcblxcdFxcdFxcdFxcdFxcdGksXFxuXFx0XFx0XFx0XFx0XFx0KCBpICsgMSApICUgbnVtTW9ycGhUYXJnZXRzICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFsdWVzLnB1c2goIDAsIDEsIDAgKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgb3JkZXIgPSBBbmltYXRpb25VdGlscy5nZXRLZXlmcmFtZU9yZGVyKCB0aW1lcyApO1xcblxcdFxcdFxcdFxcdHRpbWVzID0gQW5pbWF0aW9uVXRpbHMuc29ydGVkQXJyYXkoIHRpbWVzLCAxLCBvcmRlciApO1xcblxcdFxcdFxcdFxcdHZhbHVlcyA9IEFuaW1hdGlvblV0aWxzLnNvcnRlZEFycmF5KCB2YWx1ZXMsIDEsIG9yZGVyICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gaWYgdGhlcmUgaXMgYSBrZXkgYXQgdGhlIGZpcnN0IGZyYW1lLCBkdXBsaWNhdGUgaXQgYXMgdGhlXFxuXFx0XFx0XFx0XFx0Ly8gbGFzdCBmcmFtZSBhcyB3ZWxsIGZvciBwZXJmZWN0IGxvb3AuXFxuXFx0XFx0XFx0XFx0aWYgKCAhIG5vTG9vcCAmJiB0aW1lc1sgMCBdID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRpbWVzLnB1c2goIG51bU1vcnBoVGFyZ2V0cyApO1xcblxcdFxcdFxcdFxcdFxcdHZhbHVlcy5wdXNoKCB2YWx1ZXNbIDAgXSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR0cmFja3MucHVzaChcXG5cXHRcXHRcXHRcXHRcXHRuZXcgTnVtYmVyS2V5ZnJhbWVUcmFjayhcXG5cXHRcXHRcXHRcXHRcXHRcXHQnLm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1snICsgbW9ycGhUYXJnZXRTZXF1ZW5jZVsgaSBdLm5hbWUgKyAnXScsXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGltZXMsIHZhbHVlc1xcblxcdFxcdFxcdFxcdFxcdCkuc2NhbGUoIDEuMCAvIGZwcyApICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBuZXcgQW5pbWF0aW9uQ2xpcCggbmFtZSwgLSAxLCB0cmFja3MgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGZpbmRCeU5hbWU6IGZ1bmN0aW9uICggb2JqZWN0T3JDbGlwQXJyYXksIG5hbWUgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGNsaXBBcnJheSA9IG9iamVjdE9yQ2xpcEFycmF5O1xcblxcblxcdFxcdFxcdGlmICggISBBcnJheS5pc0FycmF5KCBvYmplY3RPckNsaXBBcnJheSApICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBvID0gb2JqZWN0T3JDbGlwQXJyYXk7XFxuXFx0XFx0XFx0XFx0Y2xpcEFycmF5ID0gby5nZW9tZXRyeSAmJiBvLmdlb21ldHJ5LmFuaW1hdGlvbnMgfHwgby5hbmltYXRpb25zO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBjbGlwQXJyYXkubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggY2xpcEFycmF5WyBpIF0ubmFtZSA9PT0gbmFtZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gY2xpcEFycmF5WyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdENyZWF0ZUNsaXBzRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2VzOiBmdW5jdGlvbiAoIG1vcnBoVGFyZ2V0cywgZnBzLCBub0xvb3AgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzID0ge307XFxuXFxuXFx0XFx0XFx0Ly8gdGVzdGVkIHdpdGggaHR0cHM6Ly9yZWdleDEwMS5jb20vIG9uIHRyaWNrIHNlcXVlbmNlc1xcblxcdFxcdFxcdC8vIHN1Y2ggZmxhbWluZ29fZmx5QV8wMDMsIGZsYW1pbmdvX3J1bjFfMDAzLCBjcmRlYXRoMDA1OVxcblxcdFxcdFxcdHZhciBwYXR0ZXJuID0gL14oW1xcXFx3LV0qPykoW1xcXFxkXSspJC87XFxuXFxuXFx0XFx0XFx0Ly8gc29ydCBtb3JwaCB0YXJnZXQgbmFtZXMgaW50byBhbmltYXRpb24gZ3JvdXBzIGJhc2VkXFxuXFx0XFx0XFx0Ly8gcGF0dGVybnMgbGlrZSBXYWxrXzAwMSwgV2Fsa18wMDIsIFJ1bl8wMDEsIFJ1bl8wMDJcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gbW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBtb3JwaFRhcmdldCA9IG1vcnBoVGFyZ2V0c1sgaSBdO1xcblxcdFxcdFxcdFxcdHZhciBwYXJ0cyA9IG1vcnBoVGFyZ2V0Lm5hbWUubWF0Y2goIHBhdHRlcm4gKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHBhcnRzICYmIHBhcnRzLmxlbmd0aCA+IDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG5hbWUgPSBwYXJ0c1sgMSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBhbmltYXRpb25Nb3JwaFRhcmdldHMgPSBhbmltYXRpb25Ub01vcnBoVGFyZ2V0c1sgbmFtZSBdO1xcblxcdFxcdFxcdFxcdFxcdGlmICggISBhbmltYXRpb25Nb3JwaFRhcmdldHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YW5pbWF0aW9uVG9Nb3JwaFRhcmdldHNbIG5hbWUgXSA9IGFuaW1hdGlvbk1vcnBoVGFyZ2V0cyA9IFtdO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRhbmltYXRpb25Nb3JwaFRhcmdldHMucHVzaCggbW9ycGhUYXJnZXQgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBjbGlwcyA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBuYW1lIGluIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzICkge1xcblxcblxcdFxcdFxcdFxcdGNsaXBzLnB1c2goIEFuaW1hdGlvbkNsaXAuQ3JlYXRlRnJvbU1vcnBoVGFyZ2V0U2VxdWVuY2UoIG5hbWUsIGFuaW1hdGlvblRvTW9ycGhUYXJnZXRzWyBuYW1lIF0sIGZwcywgbm9Mb29wICkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGNsaXBzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gcGFyc2UgdGhlIGFuaW1hdGlvbi5oaWVyYXJjaHkgZm9ybWF0XFxuXFx0XFx0cGFyc2VBbmltYXRpb246IGZ1bmN0aW9uICggYW5pbWF0aW9uLCBib25lcyApIHtcXG5cXG5cXHRcXHRcXHRpZiAoICEgYW5pbWF0aW9uICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5BbmltYXRpb25DbGlwOiBObyBhbmltYXRpb24gaW4gSlNPTkxvYWRlciBkYXRhLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGFkZE5vbmVtcHR5VHJhY2sgPSBmdW5jdGlvbiAoIHRyYWNrVHlwZSwgdHJhY2tOYW1lLCBhbmltYXRpb25LZXlzLCBwcm9wZXJ0eU5hbWUsIGRlc3RUcmFja3MgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gb25seSByZXR1cm4gdHJhY2sgaWYgdGhlcmUgYXJlIGFjdHVhbGx5IGtleXMuXFxuXFx0XFx0XFx0XFx0aWYgKCBhbmltYXRpb25LZXlzLmxlbmd0aCAhPT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdGltZXMgPSBbXTtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgdmFsdWVzID0gW107XFxuXFxuXFx0XFx0XFx0XFx0XFx0QW5pbWF0aW9uVXRpbHMuZmxhdHRlbkpTT04oIGFuaW1hdGlvbktleXMsIHRpbWVzLCB2YWx1ZXMsIHByb3BlcnR5TmFtZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGVtcHR5IGtleXMgYXJlIGZpbHRlcmVkIG91dCwgc28gY2hlY2sgYWdhaW5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRpbWVzLmxlbmd0aCAhPT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRkZXN0VHJhY2tzLnB1c2goIG5ldyB0cmFja1R5cGUoIHRyYWNrTmFtZSwgdGltZXMsIHZhbHVlcyApICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdHZhciB0cmFja3MgPSBbXTtcXG5cXG5cXHRcXHRcXHR2YXIgY2xpcE5hbWUgPSBhbmltYXRpb24ubmFtZSB8fCAnZGVmYXVsdCc7XFxuXFx0XFx0XFx0Ly8gYXV0b21hdGljIGxlbmd0aCBkZXRlcm1pbmF0aW9uIGluIEFuaW1hdGlvbkNsaXAuXFxuXFx0XFx0XFx0dmFyIGR1cmF0aW9uID0gYW5pbWF0aW9uLmxlbmd0aCB8fCAtIDE7XFxuXFx0XFx0XFx0dmFyIGZwcyA9IGFuaW1hdGlvbi5mcHMgfHwgMzA7XFxuXFxuXFx0XFx0XFx0dmFyIGhpZXJhcmNoeVRyYWNrcyA9IGFuaW1hdGlvbi5oaWVyYXJjaHkgfHwgW107XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGggPSAwOyBoIDwgaGllcmFyY2h5VHJhY2tzLmxlbmd0aDsgaCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYW5pbWF0aW9uS2V5cyA9IGhpZXJhcmNoeVRyYWNrc1sgaCBdLmtleXM7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gc2tpcCBlbXB0eSB0cmFja3NcXG5cXHRcXHRcXHRcXHRpZiAoICEgYW5pbWF0aW9uS2V5cyB8fCBhbmltYXRpb25LZXlzLmxlbmd0aCA9PT0gMCApIGNvbnRpbnVlO1xcblxcblxcdFxcdFxcdFxcdC8vIHByb2Nlc3MgbW9ycGggdGFyZ2V0c1xcblxcdFxcdFxcdFxcdGlmICggYW5pbWF0aW9uS2V5c1sgMCBdLm1vcnBoVGFyZ2V0cyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBmaWd1cmUgb3V0IGFsbCBtb3JwaCB0YXJnZXRzIHVzZWQgaW4gdGhpcyB0cmFja1xcblxcdFxcdFxcdFxcdFxcdHZhciBtb3JwaFRhcmdldE5hbWVzID0ge307XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGsgPSAwOyBrIDwgYW5pbWF0aW9uS2V5cy5sZW5ndGg7IGsgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBhbmltYXRpb25LZXlzWyBrIF0ubW9ycGhUYXJnZXRzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBtID0gMDsgbSA8IGFuaW1hdGlvbktleXNbIGsgXS5tb3JwaFRhcmdldHMubGVuZ3RoOyBtICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG1vcnBoVGFyZ2V0TmFtZXNbIGFuaW1hdGlvbktleXNbIGsgXS5tb3JwaFRhcmdldHNbIG0gXSBdID0gLSAxO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdC8vIGNyZWF0ZSBhIHRyYWNrIGZvciBlYWNoIG1vcnBoIHRhcmdldCB3aXRoIGFsbCB6ZXJvXFxuXFx0XFx0XFx0XFx0XFx0Ly8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGV4Y2VwdCBmb3IgdGhlIGtleXMgaW4gd2hpY2hcXG5cXHRcXHRcXHRcXHRcXHQvLyB0aGUgbW9ycGhUYXJnZXQgaXMgbmFtZWQuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIG1vcnBoVGFyZ2V0TmFtZSBpbiBtb3JwaFRhcmdldE5hbWVzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciB0aW1lcyA9IFtdO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciB2YWx1ZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgbSA9IDA7IG0gIT09IGFuaW1hdGlvbktleXNbIGsgXS5tb3JwaFRhcmdldHMubGVuZ3RoOyArKyBtICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBhbmltYXRpb25LZXkgPSBhbmltYXRpb25LZXlzWyBrIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGltZXMucHVzaCggYW5pbWF0aW9uS2V5LnRpbWUgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YWx1ZXMucHVzaCggKCBhbmltYXRpb25LZXkubW9ycGhUYXJnZXQgPT09IG1vcnBoVGFyZ2V0TmFtZSApID8gMSA6IDAgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dHJhY2tzLnB1c2goIG5ldyBOdW1iZXJLZXlmcmFtZVRyYWNrKCAnLm1vcnBoVGFyZ2V0SW5mbHVlbmNlWycgKyBtb3JwaFRhcmdldE5hbWUgKyAnXScsIHRpbWVzLCB2YWx1ZXMgKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRkdXJhdGlvbiA9IG1vcnBoVGFyZ2V0TmFtZXMubGVuZ3RoICogKCBmcHMgfHwgMS4wICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyAuLi5hc3N1bWUgc2tlbGV0YWwgYW5pbWF0aW9uXFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGJvbmVOYW1lID0gJy5ib25lc1snICsgYm9uZXNbIGggXS5uYW1lICsgJ10nO1xcblxcblxcdFxcdFxcdFxcdFxcdGFkZE5vbmVtcHR5VHJhY2soXFxuXFx0XFx0XFx0XFx0XFx0XFx0VmVjdG9yS2V5ZnJhbWVUcmFjaywgYm9uZU5hbWUgKyAnLnBvc2l0aW9uJyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRhbmltYXRpb25LZXlzLCAncG9zJywgdHJhY2tzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YWRkTm9uZW1wdHlUcmFjayhcXG5cXHRcXHRcXHRcXHRcXHRcXHRRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaywgYm9uZU5hbWUgKyAnLnF1YXRlcm5pb24nLFxcblxcdFxcdFxcdFxcdFxcdFxcdGFuaW1hdGlvbktleXMsICdyb3QnLCB0cmFja3MgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRhZGROb25lbXB0eVRyYWNrKFxcblxcdFxcdFxcdFxcdFxcdFxcdFZlY3RvcktleWZyYW1lVHJhY2ssIGJvbmVOYW1lICsgJy5zY2FsZScsXFxuXFx0XFx0XFx0XFx0XFx0XFx0YW5pbWF0aW9uS2V5cywgJ3NjbCcsIHRyYWNrcyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB0cmFja3MubGVuZ3RoID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBudWxsO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgY2xpcCA9IG5ldyBBbmltYXRpb25DbGlwKCBjbGlwTmFtZSwgZHVyYXRpb24sIHRyYWNrcyApO1xcblxcblxcdFxcdFxcdHJldHVybiBjbGlwO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggQW5pbWF0aW9uQ2xpcC5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRyZXNldER1cmF0aW9uOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRyYWNrcyA9IHRoaXMudHJhY2tzLCBkdXJhdGlvbiA9IDA7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gdHJhY2tzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdHJhY2sgPSB0aGlzLnRyYWNrc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdGR1cmF0aW9uID0gTWF0aC5tYXgoIGR1cmF0aW9uLCB0cmFjay50aW1lc1sgdHJhY2sudGltZXMubGVuZ3RoIC0gMSBdICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuZHVyYXRpb24gPSBkdXJhdGlvbjtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRyaW06IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy50cmFja3NbIGkgXS50cmltKCAwLCB0aGlzLmR1cmF0aW9uICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0b3B0aW1pemU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnRyYWNrcy5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy50cmFja3NbIGkgXS5vcHRpbWl6ZSgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gTWF0ZXJpYWxMb2FkZXIoIG1hbmFnZXIgKSB7XFxuXFxuXFx0XFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XFxuXFx0XFx0dGhpcy50ZXh0dXJlcyA9IHt9O1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBNYXRlcmlhbExvYWRlci5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xcblxcblxcdFxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxuXFxuXFx0XFx0XFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XFxuXFx0XFx0XFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xcblxcblxcdFxcdFxcdFxcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XFxuXFxuXFx0XFx0XFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0VGV4dHVyZXM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy50ZXh0dXJlcyA9IHZhbHVlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGV4dHVyZXMgPSB0aGlzLnRleHR1cmVzO1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGdldFRleHR1cmUoIG5hbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0ZXh0dXJlc1sgbmFtZSBdID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0ZXJpYWxMb2FkZXI6IFVuZGVmaW5lZCB0ZXh0dXJlJywgbmFtZSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGV4dHVyZXNbIG5hbWUgXTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIG1hdGVyaWFsID0gbmV3IE1hdGVyaWFsc1sganNvbi50eXBlIF0oKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24udXVpZCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwudXVpZCA9IGpzb24udXVpZDtcXG5cXHRcXHRcXHRpZiAoIGpzb24ubmFtZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubmFtZSA9IGpzb24ubmFtZTtcXG5cXHRcXHRcXHRpZiAoIGpzb24uY29sb3IgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmNvbG9yLnNldEhleCgganNvbi5jb2xvciApO1xcblxcdFxcdFxcdGlmICgganNvbi5yb3VnaG5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJvdWdobmVzcyA9IGpzb24ucm91Z2huZXNzO1xcblxcdFxcdFxcdGlmICgganNvbi5tZXRhbG5lc3MgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLm1ldGFsbmVzcyA9IGpzb24ubWV0YWxuZXNzO1xcblxcdFxcdFxcdGlmICgganNvbi5lbWlzc2l2ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmUuc2V0SGV4KCBqc29uLmVtaXNzaXZlICk7XFxuXFx0XFx0XFx0aWYgKCBqc29uLnNwZWN1bGFyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zcGVjdWxhci5zZXRIZXgoIGpzb24uc3BlY3VsYXIgKTtcXG5cXHRcXHRcXHRpZiAoIGpzb24uc2hpbmluZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaGluaW5lc3MgPSBqc29uLnNoaW5pbmVzcztcXG5cXHRcXHRcXHRpZiAoIGpzb24uY2xlYXJDb2F0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jbGVhckNvYXQgPSBqc29uLmNsZWFyQ29hdDtcXG5cXHRcXHRcXHRpZiAoIGpzb24uY2xlYXJDb2F0Um91Z2huZXNzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5jbGVhckNvYXRSb3VnaG5lc3MgPSBqc29uLmNsZWFyQ29hdFJvdWdobmVzcztcXG5cXHRcXHRcXHRpZiAoIGpzb24udW5pZm9ybXMgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnVuaWZvcm1zID0ganNvbi51bmlmb3JtcztcXG5cXHRcXHRcXHRpZiAoIGpzb24udmVydGV4U2hhZGVyICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhTaGFkZXIgPSBqc29uLnZlcnRleFNoYWRlcjtcXG5cXHRcXHRcXHRpZiAoIGpzb24uZnJhZ21lbnRTaGFkZXIgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmZyYWdtZW50U2hhZGVyID0ganNvbi5mcmFnbWVudFNoYWRlcjtcXG5cXHRcXHRcXHRpZiAoIGpzb24udmVydGV4Q29sb3JzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBqc29uLnZlcnRleENvbG9ycztcXG5cXHRcXHRcXHRpZiAoIGpzb24uZm9nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mb2cgPSBqc29uLmZvZztcXG5cXHRcXHRcXHRpZiAoIGpzb24uZmxhdFNoYWRpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmZsYXRTaGFkaW5nID0ganNvbi5mbGF0U2hhZGluZztcXG5cXHRcXHRcXHRpZiAoIGpzb24uYmxlbmRpbmcgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmJsZW5kaW5nID0ganNvbi5ibGVuZGluZztcXG5cXHRcXHRcXHRpZiAoIGpzb24uc2lkZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2lkZSA9IGpzb24uc2lkZTtcXG5cXHRcXHRcXHRpZiAoIGpzb24ub3BhY2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwub3BhY2l0eSA9IGpzb24ub3BhY2l0eTtcXG5cXHRcXHRcXHRpZiAoIGpzb24udHJhbnNwYXJlbnQgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnRyYW5zcGFyZW50ID0ganNvbi50cmFuc3BhcmVudDtcXG5cXHRcXHRcXHRpZiAoIGpzb24uYWxwaGFUZXN0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hbHBoYVRlc3QgPSBqc29uLmFscGhhVGVzdDtcXG5cXHRcXHRcXHRpZiAoIGpzb24uZGVwdGhUZXN0ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kZXB0aFRlc3QgPSBqc29uLmRlcHRoVGVzdDtcXG5cXHRcXHRcXHRpZiAoIGpzb24uZGVwdGhXcml0ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGVwdGhXcml0ZSA9IGpzb24uZGVwdGhXcml0ZTtcXG5cXHRcXHRcXHRpZiAoIGpzb24uY29sb3JXcml0ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuY29sb3JXcml0ZSA9IGpzb24uY29sb3JXcml0ZTtcXG5cXHRcXHRcXHRpZiAoIGpzb24ud2lyZWZyYW1lICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWUgPSBqc29uLndpcmVmcmFtZTtcXG5cXHRcXHRcXHRpZiAoIGpzb24ud2lyZWZyYW1lTGluZXdpZHRoICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC53aXJlZnJhbWVMaW5ld2lkdGggPSBqc29uLndpcmVmcmFtZUxpbmV3aWR0aDtcXG5cXHRcXHRcXHRpZiAoIGpzb24ud2lyZWZyYW1lTGluZWNhcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwud2lyZWZyYW1lTGluZWNhcCA9IGpzb24ud2lyZWZyYW1lTGluZWNhcDtcXG5cXHRcXHRcXHRpZiAoIGpzb24ud2lyZWZyYW1lTGluZWpvaW4gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLndpcmVmcmFtZUxpbmVqb2luID0ganNvbi53aXJlZnJhbWVMaW5lam9pbjtcXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24ucm90YXRpb24gIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJvdGF0aW9uID0ganNvbi5yb3RhdGlvbjtcXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24ubGluZXdpZHRoICE9PSAxICkgbWF0ZXJpYWwubGluZXdpZHRoID0ganNvbi5saW5ld2lkdGg7XFxuXFx0XFx0XFx0aWYgKCBqc29uLmRhc2hTaXplICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kYXNoU2l6ZSA9IGpzb24uZGFzaFNpemU7XFxuXFx0XFx0XFx0aWYgKCBqc29uLmdhcFNpemUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmdhcFNpemUgPSBqc29uLmdhcFNpemU7XFxuXFx0XFx0XFx0aWYgKCBqc29uLnNjYWxlICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zY2FsZSA9IGpzb24uc2NhbGU7XFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uLnNraW5uaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5za2lubmluZyA9IGpzb24uc2tpbm5pbmc7XFxuXFx0XFx0XFx0aWYgKCBqc29uLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubW9ycGhUYXJnZXRzID0ganNvbi5tb3JwaFRhcmdldHM7XFxuXFx0XFx0XFx0aWYgKCBqc29uLmRpdGhlcmluZyAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGl0aGVyaW5nID0ganNvbi5kaXRoZXJpbmc7XFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uLnZpc2libGUgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnZpc2libGUgPSBqc29uLnZpc2libGU7XFxuXFx0XFx0XFx0aWYgKCBqc29uLnVzZXJEYXRhICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC51c2VyRGF0YSA9IGpzb24udXNlckRhdGE7XFxuXFxuXFx0XFx0XFx0Ly8gRGVwcmVjYXRlZFxcblxcblxcdFxcdFxcdGlmICgganNvbi5zaGFkaW5nICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5mbGF0U2hhZGluZyA9IGpzb24uc2hhZGluZyA9PT0gMTsgLy8gVEhSRUUuRmxhdFNoYWRpbmdcXG5cXG5cXHRcXHRcXHQvLyBmb3IgUG9pbnRzTWF0ZXJpYWxcXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24uc2l6ZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc2l6ZSA9IGpzb24uc2l6ZTtcXG5cXHRcXHRcXHRpZiAoIGpzb24uc2l6ZUF0dGVudWF0aW9uICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5zaXplQXR0ZW51YXRpb24gPSBqc29uLnNpemVBdHRlbnVhdGlvbjtcXG5cXG5cXHRcXHRcXHQvLyBtYXBzXFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uLm1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubWFwID0gZ2V0VGV4dHVyZSgganNvbi5tYXAgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24uYWxwaGFNYXAgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRtYXRlcmlhbC5hbHBoYU1hcCA9IGdldFRleHR1cmUoIGpzb24uYWxwaGFNYXAgKTtcXG5cXHRcXHRcXHRcXHRtYXRlcmlhbC50cmFuc3BhcmVudCA9IHRydWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICgganNvbi5idW1wTWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5idW1wTWFwID0gZ2V0VGV4dHVyZSgganNvbi5idW1wTWFwICk7XFxuXFx0XFx0XFx0aWYgKCBqc29uLmJ1bXBTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYnVtcFNjYWxlID0ganNvbi5idW1wU2NhbGU7XFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uLm5vcm1hbE1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubm9ybWFsTWFwID0gZ2V0VGV4dHVyZSgganNvbi5ub3JtYWxNYXAgKTtcXG5cXHRcXHRcXHRpZiAoIGpzb24ubm9ybWFsU2NhbGUgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbm9ybWFsU2NhbGUgPSBqc29uLm5vcm1hbFNjYWxlO1xcblxcblxcdFxcdFxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggbm9ybWFsU2NhbGUgKSA9PT0gZmFsc2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gQmxlbmRlciBleHBvcnRlciB1c2VkIHRvIGV4cG9ydCBhIHNjYWxhci4gU2VlICM3NDU5XFxuXFxuXFx0XFx0XFx0XFx0XFx0bm9ybWFsU2NhbGUgPSBbIG5vcm1hbFNjYWxlLCBub3JtYWxTY2FsZSBdO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRtYXRlcmlhbC5ub3JtYWxTY2FsZSA9IG5ldyBWZWN0b3IyKCkuZnJvbUFycmF5KCBub3JtYWxTY2FsZSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24uZGlzcGxhY2VtZW50TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRNYXAgPSBnZXRUZXh0dXJlKCBqc29uLmRpc3BsYWNlbWVudE1hcCApO1xcblxcdFxcdFxcdGlmICgganNvbi5kaXNwbGFjZW1lbnRTY2FsZSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZGlzcGxhY2VtZW50U2NhbGUgPSBqc29uLmRpc3BsYWNlbWVudFNjYWxlO1xcblxcdFxcdFxcdGlmICgganNvbi5kaXNwbGFjZW1lbnRCaWFzICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5kaXNwbGFjZW1lbnRCaWFzID0ganNvbi5kaXNwbGFjZW1lbnRCaWFzO1xcblxcblxcdFxcdFxcdGlmICgganNvbi5yb3VnaG5lc3NNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLnJvdWdobmVzc01hcCA9IGdldFRleHR1cmUoIGpzb24ucm91Z2huZXNzTWFwICk7XFxuXFx0XFx0XFx0aWYgKCBqc29uLm1ldGFsbmVzc01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubWV0YWxuZXNzTWFwID0gZ2V0VGV4dHVyZSgganNvbi5tZXRhbG5lc3NNYXAgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24uZW1pc3NpdmVNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmVtaXNzaXZlTWFwID0gZ2V0VGV4dHVyZSgganNvbi5lbWlzc2l2ZU1hcCApO1xcblxcdFxcdFxcdGlmICgganNvbi5lbWlzc2l2ZUludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW1pc3NpdmVJbnRlbnNpdHkgPSBqc29uLmVtaXNzaXZlSW50ZW5zaXR5O1xcblxcblxcdFxcdFxcdGlmICgganNvbi5zcGVjdWxhck1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuc3BlY3VsYXJNYXAgPSBnZXRUZXh0dXJlKCBqc29uLnNwZWN1bGFyTWFwICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uLmVudk1hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuZW52TWFwID0gZ2V0VGV4dHVyZSgganNvbi5lbnZNYXAgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24ucmVmbGVjdGl2aXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5yZWZsZWN0aXZpdHkgPSBqc29uLnJlZmxlY3Rpdml0eTtcXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24ubGlnaHRNYXAgIT09IHVuZGVmaW5lZCApIG1hdGVyaWFsLmxpZ2h0TWFwID0gZ2V0VGV4dHVyZSgganNvbi5saWdodE1hcCApO1xcblxcdFxcdFxcdGlmICgganNvbi5saWdodE1hcEludGVuc2l0eSAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwubGlnaHRNYXBJbnRlbnNpdHkgPSBqc29uLmxpZ2h0TWFwSW50ZW5zaXR5O1xcblxcblxcdFxcdFxcdGlmICgganNvbi5hb01hcCAhPT0gdW5kZWZpbmVkICkgbWF0ZXJpYWwuYW9NYXAgPSBnZXRUZXh0dXJlKCBqc29uLmFvTWFwICk7XFxuXFx0XFx0XFx0aWYgKCBqc29uLmFvTWFwSW50ZW5zaXR5ICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5hb01hcEludGVuc2l0eSA9IGpzb24uYW9NYXBJbnRlbnNpdHk7XFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uLmdyYWRpZW50TWFwICE9PSB1bmRlZmluZWQgKSBtYXRlcmlhbC5ncmFkaWVudE1hcCA9IGdldFRleHR1cmUoIGpzb24uZ3JhZGllbnRNYXAgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbWF0ZXJpYWw7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEJ1ZmZlckdlb21ldHJ5TG9hZGVyKCBtYW5hZ2VyICkge1xcblxcblxcdFxcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBCdWZmZXJHZW9tZXRyeUxvYWRlci5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xcblxcblxcdFxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxuXFxuXFx0XFx0XFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XFxuXFx0XFx0XFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xcblxcblxcdFxcdFxcdFxcdG9uTG9hZCggc2NvcGUucGFyc2UoIEpTT04ucGFyc2UoIHRleHQgKSApICk7XFxuXFxuXFx0XFx0XFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXG5cXG5cXHRcXHRcXHR2YXIgaW5kZXggPSBqc29uLmRhdGEuaW5kZXg7XFxuXFxuXFx0XFx0XFx0aWYgKCBpbmRleCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHZhciB0eXBlZEFycmF5ID0gbmV3IFRZUEVEX0FSUkFZU1sgaW5kZXgudHlwZSBdKCBpbmRleC5hcnJheSApO1xcblxcdFxcdFxcdFxcdGdlb21ldHJ5LnNldEluZGV4KCBuZXcgQnVmZmVyQXR0cmlidXRlKCB0eXBlZEFycmF5LCAxICkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIGF0dHJpYnV0ZXMgPSBqc29uLmRhdGEuYXR0cmlidXRlcztcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIga2V5IGluIGF0dHJpYnV0ZXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXNbIGtleSBdO1xcblxcdFxcdFxcdFxcdHZhciB0eXBlZEFycmF5ID0gbmV3IFRZUEVEX0FSUkFZU1sgYXR0cmlidXRlLnR5cGUgXSggYXR0cmlidXRlLmFycmF5ICk7XFxuXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCBrZXksIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHR5cGVkQXJyYXksIGF0dHJpYnV0ZS5pdGVtU2l6ZSwgYXR0cmlidXRlLm5vcm1hbGl6ZWQgKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgZ3JvdXBzID0ganNvbi5kYXRhLmdyb3VwcyB8fCBqc29uLmRhdGEuZHJhd2NhbGxzIHx8IGpzb24uZGF0YS5vZmZzZXRzO1xcblxcblxcdFxcdFxcdGlmICggZ3JvdXBzICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gZ3JvdXBzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZ3JvdXAgPSBncm91cHNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5hZGRHcm91cCggZ3JvdXAuc3RhcnQsIGdyb3VwLmNvdW50LCBncm91cC5tYXRlcmlhbEluZGV4ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgYm91bmRpbmdTcGhlcmUgPSBqc29uLmRhdGEuYm91bmRpbmdTcGhlcmU7XFxuXFxuXFx0XFx0XFx0aWYgKCBib3VuZGluZ1NwaGVyZSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBjZW50ZXIgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdFxcdGlmICggYm91bmRpbmdTcGhlcmUuY2VudGVyICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2VudGVyLmZyb21BcnJheSggYm91bmRpbmdTcGhlcmUuY2VudGVyICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGdlb21ldHJ5LmJvdW5kaW5nU3BoZXJlID0gbmV3IFNwaGVyZSggY2VudGVyLCBib3VuZGluZ1NwaGVyZS5yYWRpdXMgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGdlb21ldHJ5O1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0dmFyIFRZUEVEX0FSUkFZUyA9IHtcXG5cXHRcXHRJbnQ4QXJyYXk6IEludDhBcnJheSxcXG5cXHRcXHRVaW50OEFycmF5OiBVaW50OEFycmF5LFxcblxcdFxcdC8vIFdvcmthcm91bmQgZm9yIElFMTEgcHJlIEtCMjkyOTQzNy4gU2VlICMxMTQ0MFxcblxcdFxcdFVpbnQ4Q2xhbXBlZEFycmF5OiB0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhDbGFtcGVkQXJyYXkgOiBVaW50OEFycmF5LFxcblxcdFxcdEludDE2QXJyYXk6IEludDE2QXJyYXksXFxuXFx0XFx0VWludDE2QXJyYXk6IFVpbnQxNkFycmF5LFxcblxcdFxcdEludDMyQXJyYXk6IEludDMyQXJyYXksXFxuXFx0XFx0VWludDMyQXJyYXk6IFVpbnQzMkFycmF5LFxcblxcdFxcdEZsb2F0MzJBcnJheTogRmxvYXQzMkFycmF5LFxcblxcdFxcdEZsb2F0NjRBcnJheTogRmxvYXQ2NEFycmF5XFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIExvYWRlcigpIHtcXG5cXG5cXHRcXHR0aGlzLm9uTG9hZFN0YXJ0ID0gZnVuY3Rpb24gKCkge307XFxuXFx0XFx0dGhpcy5vbkxvYWRQcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHt9O1xcblxcdFxcdHRoaXMub25Mb2FkQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7fTtcXG5cXG5cXHR9XFxuXFxuXFx0TG9hZGVyLkhhbmRsZXJzID0ge1xcblxcblxcdFxcdGhhbmRsZXJzOiBbXSxcXG5cXG5cXHRcXHRhZGQ6IGZ1bmN0aW9uICggcmVnZXgsIGxvYWRlciApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmhhbmRsZXJzLnB1c2goIHJlZ2V4LCBsb2FkZXIgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldDogZnVuY3Rpb24gKCBmaWxlICkge1xcblxcblxcdFxcdFxcdHZhciBoYW5kbGVycyA9IHRoaXMuaGFuZGxlcnM7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSArPSAyICkge1xcblxcblxcdFxcdFxcdFxcdHZhciByZWdleCA9IGhhbmRsZXJzWyBpIF07XFxuXFx0XFx0XFx0XFx0dmFyIGxvYWRlciA9IGhhbmRsZXJzWyBpICsgMSBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggcmVnZXgudGVzdCggZmlsZSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBsb2FkZXI7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fTtcXG5cXG5cXHRPYmplY3QuYXNzaWduKCBMb2FkZXIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0Y3Jvc3NPcmlnaW46IHVuZGVmaW5lZCxcXG5cXG5cXHRcXHRpbml0TWF0ZXJpYWxzOiBmdW5jdGlvbiAoIG1hdGVyaWFscywgdGV4dHVyZVBhdGgsIGNyb3NzT3JpZ2luICkge1xcblxcblxcdFxcdFxcdHZhciBhcnJheSA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IG1hdGVyaWFscy5sZW5ndGg7ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YXJyYXlbIGkgXSA9IHRoaXMuY3JlYXRlTWF0ZXJpYWwoIG1hdGVyaWFsc1sgaSBdLCB0ZXh0dXJlUGF0aCwgY3Jvc3NPcmlnaW4gKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGFycmF5O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y3JlYXRlTWF0ZXJpYWw6ICggZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBCbGVuZGluZ01vZGUgPSB7XFxuXFx0XFx0XFx0XFx0Tm9CbGVuZGluZzogTm9CbGVuZGluZyxcXG5cXHRcXHRcXHRcXHROb3JtYWxCbGVuZGluZzogTm9ybWFsQmxlbmRpbmcsXFxuXFx0XFx0XFx0XFx0QWRkaXRpdmVCbGVuZGluZzogQWRkaXRpdmVCbGVuZGluZyxcXG5cXHRcXHRcXHRcXHRTdWJ0cmFjdGl2ZUJsZW5kaW5nOiBTdWJ0cmFjdGl2ZUJsZW5kaW5nLFxcblxcdFxcdFxcdFxcdE11bHRpcGx5QmxlbmRpbmc6IE11bHRpcGx5QmxlbmRpbmcsXFxuXFx0XFx0XFx0XFx0Q3VzdG9tQmxlbmRpbmc6IEN1c3RvbUJsZW5kaW5nXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHR2YXIgY29sb3IgPSBuZXcgQ29sb3IoKTtcXG5cXHRcXHRcXHR2YXIgdGV4dHVyZUxvYWRlciA9IG5ldyBUZXh0dXJlTG9hZGVyKCk7XFxuXFx0XFx0XFx0dmFyIG1hdGVyaWFsTG9hZGVyID0gbmV3IE1hdGVyaWFsTG9hZGVyKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZU1hdGVyaWFsKCBtLCB0ZXh0dXJlUGF0aCwgY3Jvc3NPcmlnaW4gKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gY29udmVydCBmcm9tIG9sZCBtYXRlcmlhbCBmb3JtYXRcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdGV4dHVyZXMgPSB7fTtcXG5cXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBsb2FkVGV4dHVyZSggcGF0aCwgcmVwZWF0LCBvZmZzZXQsIHdyYXAsIGFuaXNvdHJvcHkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGZ1bGxQYXRoID0gdGV4dHVyZVBhdGggKyBwYXRoO1xcblxcdFxcdFxcdFxcdFxcdHZhciBsb2FkZXIgPSBMb2FkZXIuSGFuZGxlcnMuZ2V0KCBmdWxsUGF0aCApO1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB0ZXh0dXJlO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggbG9hZGVyICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmUgPSBsb2FkZXIubG9hZCggZnVsbFBhdGggKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmVMb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIGNyb3NzT3JpZ2luICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGV4dHVyZSA9IHRleHR1cmVMb2FkZXIubG9hZCggZnVsbFBhdGggKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCByZXBlYXQgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLnJlcGVhdC5mcm9tQXJyYXkoIHJlcGVhdCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggcmVwZWF0WyAwIF0gIT09IDEgKSB0ZXh0dXJlLndyYXBTID0gUmVwZWF0V3JhcHBpbmc7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCByZXBlYXRbIDEgXSAhPT0gMSApIHRleHR1cmUud3JhcFQgPSBSZXBlYXRXcmFwcGluZztcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBvZmZzZXQgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLm9mZnNldC5mcm9tQXJyYXkoIG9mZnNldCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHdyYXAgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHdyYXBbIDAgXSA9PT0gJ3JlcGVhdCcgKSB0ZXh0dXJlLndyYXBTID0gUmVwZWF0V3JhcHBpbmc7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB3cmFwWyAwIF0gPT09ICdtaXJyb3InICkgdGV4dHVyZS53cmFwUyA9IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB3cmFwWyAxIF0gPT09ICdyZXBlYXQnICkgdGV4dHVyZS53cmFwVCA9IFJlcGVhdFdyYXBwaW5nO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggd3JhcFsgMSBdID09PSAnbWlycm9yJyApIHRleHR1cmUud3JhcFQgPSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0ZXh0dXJlLmFuaXNvdHJvcHkgPSBhbmlzb3Ryb3B5O1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmVzWyB1dWlkIF0gPSB0ZXh0dXJlO1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB1dWlkO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdFxcdHZhciBqc29uID0ge1xcblxcdFxcdFxcdFxcdFxcdHV1aWQ6IF9NYXRoLmdlbmVyYXRlVVVJRCgpLFxcblxcdFxcdFxcdFxcdFxcdHR5cGU6ICdNZXNoTGFtYmVydE1hdGVyaWFsJ1xcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIG5hbWUgaW4gbSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgdmFsdWUgPSBtWyBuYW1lIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0c3dpdGNoICggbmFtZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdEYmdDb2xvcic6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnRGJnSW5kZXgnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ29wdGljYWxEZW5zaXR5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdpbGx1bWluYXRpb24nOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0RiZ05hbWUnOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24ubmFtZSA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ2JsZW5kaW5nJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLmJsZW5kaW5nID0gQmxlbmRpbmdNb2RlWyB2YWx1ZSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ2NvbG9yQW1iaWVudCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwQW1iaWVudCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTG9hZGVyLmNyZWF0ZU1hdGVyaWFsOicsIG5hbWUsICdpcyBubyBsb25nZXIgc3VwcG9ydGVkLicgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdjb2xvckRpZmZ1c2UnOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24uY29sb3IgPSBjb2xvci5mcm9tQXJyYXkoIHZhbHVlICkuZ2V0SGV4KCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnY29sb3JTcGVjdWxhcic6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5zcGVjdWxhciA9IGNvbG9yLmZyb21BcnJheSggdmFsdWUgKS5nZXRIZXgoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdjb2xvckVtaXNzaXZlJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLmVtaXNzaXZlID0gY29sb3IuZnJvbUFycmF5KCB2YWx1ZSApLmdldEhleCgpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ3NwZWN1bGFyQ29lZic6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5zaGluaW5lc3MgPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdzaGFkaW5nJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09ICdiYXNpYycgKSBqc29uLnR5cGUgPSAnTWVzaEJhc2ljTWF0ZXJpYWwnO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gJ3Bob25nJyApIGpzb24udHlwZSA9ICdNZXNoUGhvbmdNYXRlcmlhbCc7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAnc3RhbmRhcmQnICkganNvbi50eXBlID0gJ01lc2hTdGFuZGFyZE1hdGVyaWFsJztcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBEaWZmdXNlJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLm1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBEaWZmdXNlUmVwZWF0LCBtLm1hcERpZmZ1c2VPZmZzZXQsIG0ubWFwRGlmZnVzZVdyYXAsIG0ubWFwRGlmZnVzZUFuaXNvdHJvcHkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBEaWZmdXNlUmVwZWF0JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBEaWZmdXNlT2Zmc2V0JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBEaWZmdXNlV3JhcCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwRGlmZnVzZUFuaXNvdHJvcHknOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEVtaXNzaXZlJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLmVtaXNzaXZlTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcEVtaXNzaXZlUmVwZWF0LCBtLm1hcEVtaXNzaXZlT2Zmc2V0LCBtLm1hcEVtaXNzaXZlV3JhcCwgbS5tYXBFbWlzc2l2ZUFuaXNvdHJvcHkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBFbWlzc2l2ZVJlcGVhdCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwRW1pc3NpdmVPZmZzZXQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEVtaXNzaXZlV3JhcCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwRW1pc3NpdmVBbmlzb3Ryb3B5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBMaWdodCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5saWdodE1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBMaWdodFJlcGVhdCwgbS5tYXBMaWdodE9mZnNldCwgbS5tYXBMaWdodFdyYXAsIG0ubWFwTGlnaHRBbmlzb3Ryb3B5ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwTGlnaHRSZXBlYXQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcExpZ2h0T2Zmc2V0JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBMaWdodFdyYXAnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcExpZ2h0QW5pc290cm9weSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwQU8nOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24uYW9NYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwQU9SZXBlYXQsIG0ubWFwQU9PZmZzZXQsIG0ubWFwQU9XcmFwLCBtLm1hcEFPQW5pc290cm9weSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEFPUmVwZWF0JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBBT09mZnNldCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwQU9XcmFwJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBBT0FuaXNvdHJvcHknOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEJ1bXAnOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24uYnVtcE1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBCdW1wUmVwZWF0LCBtLm1hcEJ1bXBPZmZzZXQsIG0ubWFwQnVtcFdyYXAsIG0ubWFwQnVtcEFuaXNvdHJvcHkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBCdW1wU2NhbGUnOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24uYnVtcFNjYWxlID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwQnVtcFJlcGVhdCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwQnVtcE9mZnNldCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwQnVtcFdyYXAnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEJ1bXBBbmlzb3Ryb3B5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBOb3JtYWwnOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24ubm9ybWFsTWFwID0gbG9hZFRleHR1cmUoIHZhbHVlLCBtLm1hcE5vcm1hbFJlcGVhdCwgbS5tYXBOb3JtYWxPZmZzZXQsIG0ubWFwTm9ybWFsV3JhcCwgbS5tYXBOb3JtYWxBbmlzb3Ryb3B5ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwTm9ybWFsRmFjdG9yJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLm5vcm1hbFNjYWxlID0gWyB2YWx1ZSwgdmFsdWUgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBOb3JtYWxSZXBlYXQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcE5vcm1hbE9mZnNldCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwTm9ybWFsV3JhcCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwTm9ybWFsQW5pc290cm9weSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwU3BlY3VsYXInOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGpzb24uc3BlY3VsYXJNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwU3BlY3VsYXJSZXBlYXQsIG0ubWFwU3BlY3VsYXJPZmZzZXQsIG0ubWFwU3BlY3VsYXJXcmFwLCBtLm1hcFNwZWN1bGFyQW5pc290cm9weSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcFNwZWN1bGFyUmVwZWF0JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBTcGVjdWxhck9mZnNldCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwU3BlY3VsYXJXcmFwJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBTcGVjdWxhckFuaXNvdHJvcHknOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcE1ldGFsbmVzcyc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5tZXRhbG5lc3NNYXAgPSBsb2FkVGV4dHVyZSggdmFsdWUsIG0ubWFwTWV0YWxuZXNzUmVwZWF0LCBtLm1hcE1ldGFsbmVzc09mZnNldCwgbS5tYXBNZXRhbG5lc3NXcmFwLCBtLm1hcE1ldGFsbmVzc0FuaXNvdHJvcHkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBNZXRhbG5lc3NSZXBlYXQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcE1ldGFsbmVzc09mZnNldCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwTWV0YWxuZXNzV3JhcCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwTWV0YWxuZXNzQW5pc290cm9weSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwUm91Z2huZXNzJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLnJvdWdobmVzc01hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBSb3VnaG5lc3NSZXBlYXQsIG0ubWFwUm91Z2huZXNzT2Zmc2V0LCBtLm1hcFJvdWdobmVzc1dyYXAsIG0ubWFwUm91Z2huZXNzQW5pc290cm9weSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcFJvdWdobmVzc1JlcGVhdCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwUm91Z2huZXNzT2Zmc2V0JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBSb3VnaG5lc3NXcmFwJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBSb3VnaG5lc3NBbmlzb3Ryb3B5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBBbHBoYSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5hbHBoYU1hcCA9IGxvYWRUZXh0dXJlKCB2YWx1ZSwgbS5tYXBBbHBoYVJlcGVhdCwgbS5tYXBBbHBoYU9mZnNldCwgbS5tYXBBbHBoYVdyYXAsIG0ubWFwQWxwaGFBbmlzb3Ryb3B5ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWFwQWxwaGFSZXBlYXQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEFscGhhT2Zmc2V0JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdtYXBBbHBoYVdyYXAnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ21hcEFscGhhQW5pc290cm9weSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnZmxpcFNpZGVkJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLnNpZGUgPSBCYWNrU2lkZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdkb3VibGVTaWRlZCc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvbi5zaWRlID0gRG91YmxlU2lkZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICd0cmFuc3BhcmVuY3knOlxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxvYWRlci5jcmVhdGVNYXRlcmlhbDogdHJhbnNwYXJlbmN5IGhhcyBiZWVuIHJlbmFtZWQgdG8gb3BhY2l0eScgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRqc29uLm9wYWNpdHkgPSB2YWx1ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdkZXB0aFRlc3QnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ2RlcHRoV3JpdGUnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ2NvbG9yV3JpdGUnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ29wYWNpdHknOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ3JlZmxlY3Rpdml0eSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAndHJhbnNwYXJlbnQnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ3Zpc2libGUnOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ3dpcmVmcmFtZSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0anNvblsgbmFtZSBdID0gdmFsdWU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAndmVydGV4Q29sb3JzJzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHZhbHVlID09PSB0cnVlICkganNvbi52ZXJ0ZXhDb2xvcnMgPSBWZXJ0ZXhDb2xvcnM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB2YWx1ZSA9PT0gJ2ZhY2UnICkganNvbi52ZXJ0ZXhDb2xvcnMgPSBGYWNlQ29sb3JzO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkxvYWRlci5jcmVhdGVNYXRlcmlhbDogVW5zdXBwb3J0ZWQnLCBuYW1lLCB2YWx1ZSApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBqc29uLnR5cGUgPT09ICdNZXNoQmFzaWNNYXRlcmlhbCcgKSBkZWxldGUganNvbi5lbWlzc2l2ZTtcXG5cXHRcXHRcXHRcXHRpZiAoIGpzb24udHlwZSAhPT0gJ01lc2hQaG9uZ01hdGVyaWFsJyApIGRlbGV0ZSBqc29uLnNwZWN1bGFyO1xcblxcblxcdFxcdFxcdFxcdGlmICgganNvbi5vcGFjaXR5IDwgMSApIGpzb24udHJhbnNwYXJlbnQgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdG1hdGVyaWFsTG9hZGVyLnNldFRleHR1cmVzKCB0ZXh0dXJlcyApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBtYXRlcmlhbExvYWRlci5wYXJzZSgganNvbiApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSApKClcXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBEb24gTWNDdXJkeSAvIGh0dHBzOi8vd3d3LmRvbm1jY3VyZHkuY29tXFxuXFx0ICovXFxuXFxuXFx0dmFyIExvYWRlclV0aWxzID0ge1xcblxcblxcdFxcdGRlY29kZVRleHQ6IGZ1bmN0aW9uICggYXJyYXkgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0eXBlb2YgVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoIGFycmF5ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIEF2b2lkIHRoZSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGFycmF5KSBzaG9ydGN1dCwgd2hpY2hcXG5cXHRcXHRcXHQvLyB0aHJvd3MgYSBcXFwibWF4aW11bSBjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcXFwiIGVycm9yIGZvciBsYXJnZSBhcnJheXMuXFxuXFxuXFx0XFx0XFx0dmFyIHMgPSAnJztcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGlsID0gYXJyYXkubGVuZ3RoOyBpIDwgaWw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gSW1wbGljaXRseSBhc3N1bWVzIGxpdHRsZS1lbmRpYW4uXFxuXFx0XFx0XFx0XFx0cyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCBhcnJheVsgaSBdICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZXh0cmFjdFVybEJhc2U6IGZ1bmN0aW9uICggdXJsICkge1xcblxcblxcdFxcdFxcdHZhciBwYXJ0cyA9IHVybC5zcGxpdCggJy8nICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBwYXJ0cy5sZW5ndGggPT09IDEgKSByZXR1cm4gJy4vJztcXG5cXG5cXHRcXHRcXHRwYXJ0cy5wb3AoKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gcGFydHMuam9pbiggJy8nICkgKyAnLyc7XFxuXFxuXFx0XFx0fVxcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEpTT05Mb2FkZXIoIG1hbmFnZXIgKSB7XFxuXFxuXFx0XFx0aWYgKCB0eXBlb2YgbWFuYWdlciA9PT0gJ2Jvb2xlYW4nICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkpTT05Mb2FkZXI6IHNob3dTdGF0dXMgcGFyYW1ldGVyIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBjb25zdHJ1Y3Rvci4nICk7XFxuXFx0XFx0XFx0bWFuYWdlciA9IHVuZGVmaW5lZDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5tYW5hZ2VyID0gKCBtYW5hZ2VyICE9PSB1bmRlZmluZWQgKSA/IG1hbmFnZXIgOiBEZWZhdWx0TG9hZGluZ01hbmFnZXI7XFxuXFxuXFx0XFx0dGhpcy53aXRoQ3JlZGVudGlhbHMgPSBmYWxzZTtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggSlNPTkxvYWRlci5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xcblxcblxcdFxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxuXFxuXFx0XFx0XFx0dmFyIHRleHR1cmVQYXRoID0gdGhpcy50ZXh0dXJlUGF0aCAmJiAoIHR5cGVvZiB0aGlzLnRleHR1cmVQYXRoID09PSAnc3RyaW5nJyApID8gdGhpcy50ZXh0dXJlUGF0aCA6IExvYWRlclV0aWxzLmV4dHJhY3RVcmxCYXNlKCB1cmwgKTtcXG5cXG5cXHRcXHRcXHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xcblxcdFxcdFxcdGxvYWRlci5zZXRXaXRoQ3JlZGVudGlhbHMoIHRoaXMud2l0aENyZWRlbnRpYWxzICk7XFxuXFx0XFx0XFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBqc29uID0gSlNPTi5wYXJzZSggdGV4dCApO1xcblxcdFxcdFxcdFxcdHZhciBtZXRhZGF0YSA9IGpzb24ubWV0YWRhdGE7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBtZXRhZGF0YSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB0eXBlID0gbWV0YWRhdGEudHlwZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHR5cGUgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ29iamVjdCcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkpTT05Mb2FkZXI6ICcgKyB1cmwgKyAnIHNob3VsZCBiZSBsb2FkZWQgd2l0aCBUSFJFRS5PYmplY3RMb2FkZXIgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3NjZW5lJyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuSlNPTkxvYWRlcjogJyArIHVybCArICcgc2hvdWxkIGJlIGxvYWRlZCB3aXRoIFRIUkVFLlNjZW5lTG9hZGVyIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgb2JqZWN0ID0gc2NvcGUucGFyc2UoIGpzb24sIHRleHR1cmVQYXRoICk7XFxuXFx0XFx0XFx0XFx0b25Mb2FkKCBvYmplY3QuZ2VvbWV0cnksIG9iamVjdC5tYXRlcmlhbHMgKTtcXG5cXG5cXHRcXHRcXHR9LCBvblByb2dyZXNzLCBvbkVycm9yICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRUZXh0dXJlUGF0aDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnRleHR1cmVQYXRoID0gdmFsdWU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwYXJzZTogKCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gcGFyc2VNb2RlbCgganNvbiwgZ2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gaXNCaXRTZXQoIHZhbHVlLCBwb3NpdGlvbiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gdmFsdWUgJiAoIDEgPDwgcG9zaXRpb24gKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGksIGosIGZpLFxcblxcblxcdFxcdFxcdFxcdFxcdG9mZnNldCwgekxlbmd0aCxcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb2xvckluZGV4LCBub3JtYWxJbmRleCwgdXZJbmRleCwgbWF0ZXJpYWxJbmRleCxcXG5cXG5cXHRcXHRcXHRcXHRcXHR0eXBlLFxcblxcdFxcdFxcdFxcdFxcdGlzUXVhZCxcXG5cXHRcXHRcXHRcXHRcXHRoYXNNYXRlcmlhbCxcXG5cXHRcXHRcXHRcXHRcXHRoYXNGYWNlVmVydGV4VXYsXFxuXFx0XFx0XFx0XFx0XFx0aGFzRmFjZU5vcm1hbCwgaGFzRmFjZVZlcnRleE5vcm1hbCxcXG5cXHRcXHRcXHRcXHRcXHRoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcixcXG5cXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXgsIGZhY2UsIGZhY2VBLCBmYWNlQiwgaGV4LCBub3JtYWwsXFxuXFxuXFx0XFx0XFx0XFx0XFx0dXZMYXllciwgdXYsIHUsIHYsXFxuXFxuXFx0XFx0XFx0XFx0XFx0ZmFjZXMgPSBqc29uLmZhY2VzLFxcblxcdFxcdFxcdFxcdFxcdHZlcnRpY2VzID0ganNvbi52ZXJ0aWNlcyxcXG5cXHRcXHRcXHRcXHRcXHRub3JtYWxzID0ganNvbi5ub3JtYWxzLFxcblxcdFxcdFxcdFxcdFxcdGNvbG9ycyA9IGpzb24uY29sb3JzLFxcblxcblxcdFxcdFxcdFxcdFxcdHNjYWxlID0ganNvbi5zY2FsZSxcXG5cXG5cXHRcXHRcXHRcXHRcXHRuVXZMYXllcnMgPSAwO1xcblxcblxcblxcdFxcdFxcdFxcdGlmICgganNvbi51dnMgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBkaXNyZWdhcmQgZW1wdHkgYXJyYXlzXFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCBqc29uLnV2cy5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBqc29uLnV2c1sgaSBdLmxlbmd0aCApIG5VdkxheWVycyArKztcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCBuVXZMYXllcnM7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkuZmFjZVZlcnRleFV2c1sgaSBdID0gW107XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRvZmZzZXQgPSAwO1xcblxcdFxcdFxcdFxcdHpMZW5ndGggPSB2ZXJ0aWNlcy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0d2hpbGUgKCBvZmZzZXQgPCB6TGVuZ3RoICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZlcnRleCA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmVydGV4LnggPSB2ZXJ0aWNlc1sgb2Zmc2V0ICsrIF0gKiBzY2FsZTtcXG5cXHRcXHRcXHRcXHRcXHR2ZXJ0ZXgueSA9IHZlcnRpY2VzWyBvZmZzZXQgKysgXSAqIHNjYWxlO1xcblxcdFxcdFxcdFxcdFxcdHZlcnRleC56ID0gdmVydGljZXNbIG9mZnNldCArKyBdICogc2NhbGU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkudmVydGljZXMucHVzaCggdmVydGV4ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdG9mZnNldCA9IDA7XFxuXFx0XFx0XFx0XFx0ekxlbmd0aCA9IGZhY2VzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHR3aGlsZSAoIG9mZnNldCA8IHpMZW5ndGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dHlwZSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpc1F1YWQgPSBpc0JpdFNldCggdHlwZSwgMCApO1xcblxcdFxcdFxcdFxcdFxcdGhhc01hdGVyaWFsID0gaXNCaXRTZXQoIHR5cGUsIDEgKTtcXG5cXHRcXHRcXHRcXHRcXHRoYXNGYWNlVmVydGV4VXYgPSBpc0JpdFNldCggdHlwZSwgMyApO1xcblxcdFxcdFxcdFxcdFxcdGhhc0ZhY2VOb3JtYWwgPSBpc0JpdFNldCggdHlwZSwgNCApO1xcblxcdFxcdFxcdFxcdFxcdGhhc0ZhY2VWZXJ0ZXhOb3JtYWwgPSBpc0JpdFNldCggdHlwZSwgNSApO1xcblxcdFxcdFxcdFxcdFxcdGhhc0ZhY2VDb2xvciA9IGlzQml0U2V0KCB0eXBlLCA2ICk7XFxuXFx0XFx0XFx0XFx0XFx0aGFzRmFjZVZlcnRleENvbG9yID0gaXNCaXRTZXQoIHR5cGUsIDcgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBjb25zb2xlLmxvZyhcXFwidHlwZVxcXCIsIHR5cGUsIFxcXCJiaXRzXFxcIiwgaXNRdWFkLCBoYXNNYXRlcmlhbCwgaGFzRmFjZVZlcnRleFV2LCBoYXNGYWNlTm9ybWFsLCBoYXNGYWNlVmVydGV4Tm9ybWFsLCBoYXNGYWNlQ29sb3IsIGhhc0ZhY2VWZXJ0ZXhDb2xvcik7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBpc1F1YWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmFjZUEgPSBuZXcgRmFjZTMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmYWNlQS5hID0gZmFjZXNbIG9mZnNldCBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdGZhY2VBLmIgPSBmYWNlc1sgb2Zmc2V0ICsgMSBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdGZhY2VBLmMgPSBmYWNlc1sgb2Zmc2V0ICsgMyBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZhY2VCID0gbmV3IEZhY2UzKCk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmFjZUIuYSA9IGZhY2VzWyBvZmZzZXQgKyAxIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmFjZUIuYiA9IGZhY2VzWyBvZmZzZXQgKyAyIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmFjZUIuYyA9IGZhY2VzWyBvZmZzZXQgKyAzIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2Zmc2V0ICs9IDQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBoYXNNYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRtYXRlcmlhbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZhY2VBLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZhY2VCLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB0byBnZXQgZmFjZSA8PT4gdXYgaW5kZXggY29ycmVzcG9uZGVuY2VcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmaSA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR1dkxheWVyID0ganNvbi51dnNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0gPSBbXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpICsgMSBdID0gW107XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggaiA9IDA7IGogPCA0OyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHV2SW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dSA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0diA9IHV2TGF5ZXJbIHV2SW5kZXggKiAyICsgMSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHV2ID0gbmV3IFZlY3RvcjIoIHUsIHYgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGogIT09IDIgKSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0ucHVzaCggdXYgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGogIT09IDAgKSBnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpICsgMSBdLnB1c2goIHV2ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBoYXNGYWNlTm9ybWFsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbEluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdICogMztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmYWNlQS5ub3JtYWwuc2V0KFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBub3JtYWxJbmRleCBdXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmYWNlQi5ub3JtYWwuY29weSggZmFjZUEubm9ybWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaGFzRmFjZVZlcnRleE5vcm1hbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsSW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF0gKiAzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbCA9IG5ldyBWZWN0b3IzKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBub3JtYWxJbmRleCBdXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGkgIT09IDIgKSBmYWNlQS52ZXJ0ZXhOb3JtYWxzLnB1c2goIG5vcm1hbCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaSAhPT0gMCApIGZhY2VCLnZlcnRleE5vcm1hbHMucHVzaCggbm9ybWFsICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGhhc0ZhY2VDb2xvciApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGhleCA9IGNvbG9yc1sgY29sb3JJbmRleCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZhY2VBLmNvbG9yLnNldEhleCggaGV4ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmFjZUIuY29sb3Iuc2V0SGV4KCBoZXggKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBoYXNGYWNlVmVydGV4Q29sb3IgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggaSA9IDA7IGkgPCA0OyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aGV4ID0gY29sb3JzWyBjb2xvckluZGV4IF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpICE9PSAyICkgZmFjZUEudmVydGV4Q29sb3JzLnB1c2goIG5ldyBDb2xvciggaGV4ICkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGkgIT09IDAgKSBmYWNlQi52ZXJ0ZXhDb2xvcnMucHVzaCggbmV3IENvbG9yKCBoZXggKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZUEgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5mYWNlcy5wdXNoKCBmYWNlQiApO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmFjZSA9IG5ldyBGYWNlMygpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGZhY2UuYSA9IGZhY2VzWyBvZmZzZXQgKysgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRmYWNlLmIgPSBmYWNlc1sgb2Zmc2V0ICsrIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0ZmFjZS5jID0gZmFjZXNbIG9mZnNldCArKyBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaGFzTWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bWF0ZXJpYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmYWNlLm1hdGVyaWFsSW5kZXggPSBtYXRlcmlhbEluZGV4O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB0byBnZXQgZmFjZSA8PT4gdXYgaW5kZXggY29ycmVzcG9uZGVuY2VcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmaSA9IGdlb21ldHJ5LmZhY2VzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGhhc0ZhY2VWZXJ0ZXhVdiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCBpID0gMDsgaSA8IG5VdkxheWVyczsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR1dkxheWVyID0ganNvbi51dnNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5mYWNlVmVydGV4VXZzWyBpIF1bIGZpIF0gPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCBqID0gMDsgaiA8IDM7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dXZJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR1ID0gdXZMYXllclsgdXZJbmRleCAqIDIgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR2ID0gdXZMYXllclsgdXZJbmRleCAqIDIgKyAxIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0dXYgPSBuZXcgVmVjdG9yMiggdSwgdiApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5LmZhY2VWZXJ0ZXhVdnNbIGkgXVsgZmkgXS5wdXNoKCB1diApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaGFzRmFjZU5vcm1hbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmFjZS5ub3JtYWwuc2V0KFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIG5vcm1hbEluZGV4ICsrIF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBub3JtYWxJbmRleCBdXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBoYXNGYWNlVmVydGV4Tm9ybWFsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxJbmRleCA9IGZhY2VzWyBvZmZzZXQgKysgXSAqIDM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsID0gbmV3IFZlY3RvcjMoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bm9ybWFsc1sgbm9ybWFsSW5kZXggKysgXSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRub3JtYWxzWyBub3JtYWxJbmRleCArKyBdLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG5vcm1hbHNbIG5vcm1hbEluZGV4IF1cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZhY2UudmVydGV4Tm9ybWFscy5wdXNoKCBub3JtYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaGFzRmFjZUNvbG9yICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbG9ySW5kZXggPSBmYWNlc1sgb2Zmc2V0ICsrIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmFjZS5jb2xvci5zZXRIZXgoIGNvbG9yc1sgY29sb3JJbmRleCBdICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggaGFzRmFjZVZlcnRleENvbG9yICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIGkgPSAwOyBpIDwgMzsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjb2xvckluZGV4ID0gZmFjZXNbIG9mZnNldCArKyBdO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGZhY2UudmVydGV4Q29sb3JzLnB1c2goIG5ldyBDb2xvciggY29sb3JzWyBjb2xvckluZGV4IF0gKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkuZmFjZXMucHVzaCggZmFjZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZ1bmN0aW9uIHBhcnNlU2tpbigganNvbiwgZ2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPSAoIGpzb24uaW5mbHVlbmNlc1BlclZlcnRleCAhPT0gdW5kZWZpbmVkICkgPyBqc29uLmluZmx1ZW5jZXNQZXJWZXJ0ZXggOiAyO1xcblxcblxcdFxcdFxcdFxcdGlmICgganNvbi5za2luV2VpZ2h0cyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBqc29uLnNraW5XZWlnaHRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gaW5mbHVlbmNlc1BlclZlcnRleCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgeCA9IGpzb24uc2tpbldlaWdodHNbIGkgXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgeSA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDEgKSA/IGpzb24uc2tpbldlaWdodHNbIGkgKyAxIF0gOiAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciB6ID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMiApID8ganNvbi5za2luV2VpZ2h0c1sgaSArIDIgXSA6IDA7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHcgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAzICkgPyBqc29uLnNraW5XZWlnaHRzWyBpICsgMyBdIDogMDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5za2luV2VpZ2h0cy5wdXNoKCBuZXcgVmVjdG9yNCggeCwgeSwgeiwgdyApICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGpzb24uc2tpbkluZGljZXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5za2luSW5kaWNlcy5sZW5ndGg7IGkgPCBsOyBpICs9IGluZmx1ZW5jZXNQZXJWZXJ0ZXggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGEgPSBqc29uLnNraW5JbmRpY2VzWyBpIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGIgPSAoIGluZmx1ZW5jZXNQZXJWZXJ0ZXggPiAxICkgPyBqc29uLnNraW5JbmRpY2VzWyBpICsgMSBdIDogMDtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgYyA9ICggaW5mbHVlbmNlc1BlclZlcnRleCA+IDIgKSA/IGpzb24uc2tpbkluZGljZXNbIGkgKyAyIF0gOiAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBkID0gKCBpbmZsdWVuY2VzUGVyVmVydGV4ID4gMyApID8ganNvbi5za2luSW5kaWNlc1sgaSArIDMgXSA6IDA7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkuc2tpbkluZGljZXMucHVzaCggbmV3IFZlY3RvcjQoIGEsIGIsIGMsIGQgKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkuYm9uZXMgPSBqc29uLmJvbmVzO1xcblxcblxcdFxcdFxcdFxcdGlmICggZ2VvbWV0cnkuYm9uZXMgJiYgZ2VvbWV0cnkuYm9uZXMubGVuZ3RoID4gMCAmJiAoIGdlb21ldHJ5LnNraW5XZWlnaHRzLmxlbmd0aCAhPT0gZ2VvbWV0cnkuc2tpbkluZGljZXMubGVuZ3RoIHx8IGdlb21ldHJ5LnNraW5JbmRpY2VzLmxlbmd0aCAhPT0gZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnV2hlbiBza2lubmluZywgbnVtYmVyIG9mIHZlcnRpY2VzICgnICsgZ2VvbWV0cnkudmVydGljZXMubGVuZ3RoICsgJyksIHNraW5JbmRpY2VzICgnICtcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5za2luSW5kaWNlcy5sZW5ndGggKyAnKSwgYW5kIHNraW5XZWlnaHRzICgnICsgZ2VvbWV0cnkuc2tpbldlaWdodHMubGVuZ3RoICsgJykgc2hvdWxkIG1hdGNoLicgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZ1bmN0aW9uIHBhcnNlTW9ycGhpbmcoIGpzb24sIGdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBzY2FsZSA9IGpzb24uc2NhbGU7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBqc29uLm1vcnBoVGFyZ2V0cyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubW9ycGhUYXJnZXRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0gPSB7fTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeS5tb3JwaFRhcmdldHNbIGkgXS5uYW1lID0ganNvbi5tb3JwaFRhcmdldHNbIGkgXS5uYW1lO1xcblxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLnZlcnRpY2VzID0gW107XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGRzdFZlcnRpY2VzID0gZ2VvbWV0cnkubW9ycGhUYXJnZXRzWyBpIF0udmVydGljZXM7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIHNyY1ZlcnRpY2VzID0ganNvbi5tb3JwaFRhcmdldHNbIGkgXS52ZXJ0aWNlcztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgdiA9IDAsIHZsID0gc3JjVmVydGljZXMubGVuZ3RoOyB2IDwgdmw7IHYgKz0gMyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgdmVydGV4ID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2ZXJ0ZXgueCA9IHNyY1ZlcnRpY2VzWyB2IF0gKiBzY2FsZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2ZXJ0ZXgueSA9IHNyY1ZlcnRpY2VzWyB2ICsgMSBdICogc2NhbGU7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmVydGV4LnogPSBzcmNWZXJ0aWNlc1sgdiArIDIgXSAqIHNjYWxlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRzdFZlcnRpY2VzLnB1c2goIHZlcnRleCApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICgganNvbi5tb3JwaENvbG9ycyAhPT0gdW5kZWZpbmVkICYmIGpzb24ubW9ycGhDb2xvcnMubGVuZ3RoID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5KU09OTG9hZGVyOiBcXFwibW9ycGhDb2xvcnNcXFwiIG5vIGxvbmdlciBzdXBwb3J0ZWQuIFVzaW5nIHRoZW0gYXMgZmFjZSBjb2xvcnMuJyApO1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBmYWNlcyA9IGdlb21ldHJ5LmZhY2VzO1xcblxcdFxcdFxcdFxcdFxcdHZhciBtb3JwaENvbG9ycyA9IGpzb24ubW9ycGhDb2xvcnNbIDAgXS5jb2xvcnM7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmYWNlc1sgaSBdLmNvbG9yLmZyb21BcnJheSggbW9ycGhDb2xvcnMsIGkgKiAzICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gcGFyc2VBbmltYXRpb25zKCBqc29uLCBnZW9tZXRyeSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgb3V0cHV0QW5pbWF0aW9ucyA9IFtdO1xcblxcblxcdFxcdFxcdFxcdC8vIHBhcnNlIG9sZCBzdHlsZSBCb25lL0hpZXJhcmNoeSBhbmltYXRpb25zXFxuXFx0XFx0XFx0XFx0dmFyIGFuaW1hdGlvbnMgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGpzb24uYW5pbWF0aW9uICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YW5pbWF0aW9ucy5wdXNoKCBqc29uLmFuaW1hdGlvbiApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGpzb24uYW5pbWF0aW9ucyAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICgganNvbi5hbmltYXRpb25zLmxlbmd0aCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRhbmltYXRpb25zID0gYW5pbWF0aW9ucy5jb25jYXQoIGpzb24uYW5pbWF0aW9ucyApO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YW5pbWF0aW9ucy5wdXNoKCBqc29uLmFuaW1hdGlvbnMgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGFuaW1hdGlvbnMubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBjbGlwID0gQW5pbWF0aW9uQ2xpcC5wYXJzZUFuaW1hdGlvbiggYW5pbWF0aW9uc1sgaSBdLCBnZW9tZXRyeS5ib25lcyApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggY2xpcCApIG91dHB1dEFuaW1hdGlvbnMucHVzaCggY2xpcCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBwYXJzZSBpbXBsaWNpdCBtb3JwaCBhbmltYXRpb25zXFxuXFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyeS5tb3JwaFRhcmdldHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gVE9ETzogRmlndXJlIG91dCB3aGF0IGFuIGFwcHJvcHJhaXRlIEZQUyBpcyBmb3IgbW9ycGggdGFyZ2V0IGFuaW1hdGlvbnMgLS0gZGVmYXVsdGluZyB0byAxMCwgYnV0IHJlYWxseSBpdCBpcyBjb21wbGV0ZWx5IGFyYml0cmFyeS5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgbW9ycGhBbmltYXRpb25DbGlwcyA9IEFuaW1hdGlvbkNsaXAuQ3JlYXRlQ2xpcHNGcm9tTW9ycGhUYXJnZXRTZXF1ZW5jZXMoIGdlb21ldHJ5Lm1vcnBoVGFyZ2V0cywgMTAgKTtcXG5cXHRcXHRcXHRcXHRcXHRvdXRwdXRBbmltYXRpb25zID0gb3V0cHV0QW5pbWF0aW9ucy5jb25jYXQoIG1vcnBoQW5pbWF0aW9uQ2xpcHMgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBvdXRwdXRBbmltYXRpb25zLmxlbmd0aCA+IDAgKSBnZW9tZXRyeS5hbmltYXRpb25zID0gb3V0cHV0QW5pbWF0aW9ucztcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uICgganNvbiwgdGV4dHVyZVBhdGggKSB7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBqc29uLmRhdGEgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBHZW9tZXRyeSA0LjAgc3BlY1xcblxcdFxcdFxcdFxcdFxcdGpzb24gPSBqc29uLmRhdGE7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICgganNvbi5zY2FsZSAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGpzb24uc2NhbGUgPSAxLjAgLyBqc29uLnNjYWxlO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0anNvbi5zY2FsZSA9IDEuMDtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGdlb21ldHJ5ID0gbmV3IEdlb21ldHJ5KCk7XFxuXFxuXFx0XFx0XFx0XFx0cGFyc2VNb2RlbCgganNvbiwgZ2VvbWV0cnkgKTtcXG5cXHRcXHRcXHRcXHRwYXJzZVNraW4oIGpzb24sIGdlb21ldHJ5ICk7XFxuXFx0XFx0XFx0XFx0cGFyc2VNb3JwaGluZygganNvbiwgZ2VvbWV0cnkgKTtcXG5cXHRcXHRcXHRcXHRwYXJzZUFuaW1hdGlvbnMoIGpzb24sIGdlb21ldHJ5ICk7XFxuXFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkuY29tcHV0ZUZhY2VOb3JtYWxzKCk7XFxuXFx0XFx0XFx0XFx0Z2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nU3BoZXJlKCk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBqc29uLm1hdGVyaWFscyA9PT0gdW5kZWZpbmVkIHx8IGpzb24ubWF0ZXJpYWxzLmxlbmd0aCA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4geyBnZW9tZXRyeTogZ2VvbWV0cnkgfTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBtYXRlcmlhbHMgPSBMb2FkZXIucHJvdG90eXBlLmluaXRNYXRlcmlhbHMoIGpzb24ubWF0ZXJpYWxzLCB0ZXh0dXJlUGF0aCwgdGhpcy5jcm9zc09yaWdpbiApO1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiB7IGdlb21ldHJ5OiBnZW9tZXRyeSwgbWF0ZXJpYWxzOiBtYXRlcmlhbHMgfTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9ICkoKVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIE9iamVjdExvYWRlciggbWFuYWdlciApIHtcXG5cXG5cXHRcXHR0aGlzLm1hbmFnZXIgPSAoIG1hbmFnZXIgIT09IHVuZGVmaW5lZCApID8gbWFuYWdlciA6IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcXG5cXHRcXHR0aGlzLnRleHR1cmVQYXRoID0gJyc7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIE9iamVjdExvYWRlci5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xcblxcblxcdFxcdFxcdGlmICggdGhpcy50ZXh0dXJlUGF0aCA9PT0gJycgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy50ZXh0dXJlUGF0aCA9IHVybC5zdWJzdHJpbmcoIDAsIHVybC5sYXN0SW5kZXhPZiggJy8nICkgKyAxICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxuXFxuXFx0XFx0XFx0dmFyIGxvYWRlciA9IG5ldyBGaWxlTG9hZGVyKCBzY29wZS5tYW5hZ2VyICk7XFxuXFx0XFx0XFx0bG9hZGVyLmxvYWQoIHVybCwgZnVuY3Rpb24gKCB0ZXh0ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBqc29uID0gbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHR0cnkge1xcblxcblxcdFxcdFxcdFxcdFxcdGpzb24gPSBKU09OLnBhcnNlKCB0ZXh0ICk7XFxuXFxuXFx0XFx0XFx0XFx0fSBjYXRjaCAoIGVycm9yICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggb25FcnJvciAhPT0gdW5kZWZpbmVkICkgb25FcnJvciggZXJyb3IgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUU6T2JqZWN0TG9hZGVyOiBDYW5cXFxcJ3QgcGFyc2UgJyArIHVybCArICcuJywgZXJyb3IubWVzc2FnZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG1ldGFkYXRhID0ganNvbi5tZXRhZGF0YTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG1ldGFkYXRhID09PSB1bmRlZmluZWQgfHwgbWV0YWRhdGEudHlwZSA9PT0gdW5kZWZpbmVkIHx8IG1ldGFkYXRhLnR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ2dlb21ldHJ5JyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBDYW5cXFxcJ3QgbG9hZCAnICsgdXJsICsgJy4gVXNlIFRIUkVFLkpTT05Mb2FkZXIgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRzY29wZS5wYXJzZSgganNvbiwgb25Mb2FkICk7XFxuXFxuXFx0XFx0XFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0VGV4dHVyZVBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy50ZXh0dXJlUGF0aCA9IHZhbHVlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jcm9zc09yaWdpbiA9IHZhbHVlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiwgb25Mb2FkICkge1xcblxcblxcdFxcdFxcdHZhciBzaGFwZXMgPSB0aGlzLnBhcnNlU2hhcGUoIGpzb24uc2hhcGVzICk7XFxuXFx0XFx0XFx0dmFyIGdlb21ldHJpZXMgPSB0aGlzLnBhcnNlR2VvbWV0cmllcygganNvbi5nZW9tZXRyaWVzLCBzaGFwZXMgKTtcXG5cXG5cXHRcXHRcXHR2YXIgaW1hZ2VzID0gdGhpcy5wYXJzZUltYWdlcygganNvbi5pbWFnZXMsIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcXG5cXG5cXHRcXHRcXHR9ICk7XFxuXFxuXFx0XFx0XFx0dmFyIHRleHR1cmVzID0gdGhpcy5wYXJzZVRleHR1cmVzKCBqc29uLnRleHR1cmVzLCBpbWFnZXMgKTtcXG5cXHRcXHRcXHR2YXIgbWF0ZXJpYWxzID0gdGhpcy5wYXJzZU1hdGVyaWFscygganNvbi5tYXRlcmlhbHMsIHRleHR1cmVzICk7XFxuXFxuXFx0XFx0XFx0dmFyIG9iamVjdCA9IHRoaXMucGFyc2VPYmplY3QoIGpzb24ub2JqZWN0LCBnZW9tZXRyaWVzLCBtYXRlcmlhbHMgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24uYW5pbWF0aW9ucyApIHtcXG5cXG5cXHRcXHRcXHRcXHRvYmplY3QuYW5pbWF0aW9ucyA9IHRoaXMucGFyc2VBbmltYXRpb25zKCBqc29uLmFuaW1hdGlvbnMgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uLmltYWdlcyA9PT0gdW5kZWZpbmVkIHx8IGpzb24uaW1hZ2VzLmxlbmd0aCA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG9uTG9hZCAhPT0gdW5kZWZpbmVkICkgb25Mb2FkKCBvYmplY3QgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG9iamVjdDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHBhcnNlU2hhcGU6IGZ1bmN0aW9uICgganNvbiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgc2hhcGVzID0ge307XFxuXFxuXFx0XFx0XFx0aWYgKCBqc29uICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBzaGFwZSA9IG5ldyBTaGFwZSgpLmZyb21KU09OKCBqc29uWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzaGFwZXNbIHNoYXBlLnV1aWQgXSA9IHNoYXBlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHNoYXBlcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHBhcnNlR2VvbWV0cmllczogZnVuY3Rpb24gKCBqc29uLCBzaGFwZXMgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGdlb21ldHJpZXMgPSB7fTtcXG5cXG5cXHRcXHRcXHRpZiAoIGpzb24gIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZ2VvbWV0cnlMb2FkZXIgPSBuZXcgSlNPTkxvYWRlcigpO1xcblxcdFxcdFxcdFxcdHZhciBidWZmZXJHZW9tZXRyeUxvYWRlciA9IG5ldyBCdWZmZXJHZW9tZXRyeUxvYWRlcigpO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZ2VvbWV0cnk7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGRhdGEgPSBqc29uWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0c3dpdGNoICggZGF0YS50eXBlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ1BsYW5lR2VvbWV0cnknOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ1BsYW5lQnVmZmVyR2VvbWV0cnknOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEud2lkdGgsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5oZWlnaHQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuaGVpZ2h0U2VnbWVudHNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0JveEdlb21ldHJ5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdCb3hCdWZmZXJHZW9tZXRyeSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnQ3ViZUdlb21ldHJ5JzogLy8gYmFja3dhcmRzIGNvbXBhdGlibGVcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLndpZHRoLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuaGVpZ2h0LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuZGVwdGgsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS53aWR0aFNlZ21lbnRzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuaGVpZ2h0U2VnbWVudHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5kZXB0aFNlZ21lbnRzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdDaXJjbGVHZW9tZXRyeSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnQ2lyY2xlQnVmZmVyR2VvbWV0cnknOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucmFkaXVzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuc2VnbWVudHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS50aGV0YVN0YXJ0LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEudGhldGFMZW5ndGhcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0N5bGluZGVyR2VvbWV0cnknOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0N5bGluZGVyQnVmZmVyR2VvbWV0cnknOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucmFkaXVzVG9wLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucmFkaXVzQm90dG9tLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuaGVpZ2h0LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucmFkaWFsU2VnbWVudHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLm9wZW5FbmRlZCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnRoZXRhU3RhcnQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS50aGV0YUxlbmd0aFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnQ29uZUdlb21ldHJ5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdDb25lQnVmZmVyR2VvbWV0cnknOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucmFkaXVzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuaGVpZ2h0LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucmFkaWFsU2VnbWVudHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLm9wZW5FbmRlZCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnRoZXRhU3RhcnQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS50aGV0YUxlbmd0aFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnU3BoZXJlR2VvbWV0cnknOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ1NwaGVyZUJ1ZmZlckdlb21ldHJ5JzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnJhZGl1cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLndpZHRoU2VnbWVudHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5oZWlnaHRTZWdtZW50cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnBoaVN0YXJ0LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucGhpTGVuZ3RoLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEudGhldGFTdGFydCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnRoZXRhTGVuZ3RoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdEb2RlY2FoZWRyb25HZW9tZXRyeSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnknOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0ljb3NhaGVkcm9uR2VvbWV0cnknOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ0ljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnknOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ09jdGFoZWRyb25HZW9tZXRyeSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnT2N0YWhlZHJvbkJ1ZmZlckdlb21ldHJ5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdUZXRyYWhlZHJvbkdlb21ldHJ5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdUZXRyYWhlZHJvbkJ1ZmZlckdlb21ldHJ5JzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRnZW9tZXRyeSA9IG5ldyBHZW9tZXRyaWVzWyBkYXRhLnR5cGUgXShcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnJhZGl1cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmRldGFpbFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnUmluZ0dlb21ldHJ5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdSaW5nQnVmZmVyR2VvbWV0cnknOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuaW5uZXJSYWRpdXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5vdXRlclJhZGl1cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnRoZXRhU2VnbWVudHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5waGlTZWdtZW50cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnRoZXRhU3RhcnQsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS50aGV0YUxlbmd0aFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnVG9ydXNHZW9tZXRyeSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnVG9ydXNCdWZmZXJHZW9tZXRyeSc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5yYWRpdXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS50dWJlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucmFkaWFsU2VnbWVudHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS50dWJ1bGFyU2VnbWVudHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5hcmNcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ1RvcnVzS25vdEdlb21ldHJ5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdUb3J1c0tub3RCdWZmZXJHZW9tZXRyeSc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5yYWRpdXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS50dWJlLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEudHVidWxhclNlZ21lbnRzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucmFkaWFsU2VnbWVudHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5wLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnTGF0aGVHZW9tZXRyeSc6XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnTGF0aGVCdWZmZXJHZW9tZXRyeSc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5wb2ludHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5zZWdtZW50cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLnBoaVN0YXJ0LFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEucGhpTGVuZ3RoXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdQb2x5aGVkcm9uR2VvbWV0cnknOlxcblxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ1BvbHloZWRyb25CdWZmZXJHZW9tZXRyeSc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkgPSBuZXcgR2VvbWV0cmllc1sgZGF0YS50eXBlIF0oXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS52ZXJ0aWNlcyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRkYXRhLmluZGljZXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5yYWRpdXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YS5kZXRhaWxzXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0KTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdTaGFwZUdlb21ldHJ5JzpcXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdTaGFwZUJ1ZmZlckdlb21ldHJ5JzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgZ2VvbWV0cnlTaGFwZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBkYXRhLnNoYXBlcy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBzaGFwZSA9IHNoYXBlc1sgZGF0YS5zaGFwZXNbIGkgXSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5U2hhcGVzLnB1c2goIHNoYXBlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5ID0gbmV3IEdlb21ldHJpZXNbIGRhdGEudHlwZSBdKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5U2hhcGVzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGEuY3VydmVTZWdtZW50c1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnQnVmZmVyR2VvbWV0cnknOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5ID0gYnVmZmVyR2VvbWV0cnlMb2FkZXIucGFyc2UoIGRhdGEgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdHZW9tZXRyeSc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Z2VvbWV0cnkgPSBnZW9tZXRyeUxvYWRlci5wYXJzZSggZGF0YSwgdGhpcy50ZXh0dXJlUGF0aCApLmdlb21ldHJ5O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlIFxcXCInICsgZGF0YS50eXBlICsgJ1xcXCInICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29udGludWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGdlb21ldHJ5LnV1aWQgPSBkYXRhLnV1aWQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIGdlb21ldHJ5Lm5hbWUgPSBkYXRhLm5hbWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Z2VvbWV0cmllc1sgZGF0YS51dWlkIF0gPSBnZW9tZXRyeTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBnZW9tZXRyaWVzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cGFyc2VNYXRlcmlhbHM6IGZ1bmN0aW9uICgganNvbiwgdGV4dHVyZXMgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG1hdGVyaWFscyA9IHt9O1xcblxcblxcdFxcdFxcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBsb2FkZXIgPSBuZXcgTWF0ZXJpYWxMb2FkZXIoKTtcXG5cXHRcXHRcXHRcXHRsb2FkZXIuc2V0VGV4dHVyZXMoIHRleHR1cmVzICk7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBkYXRhID0ganNvblsgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS50eXBlID09PSAnTXVsdGlNYXRlcmlhbCcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gRGVwcmVjYXRlZFxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBhcnJheSA9IFtdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMDsgaiA8IGRhdGEubWF0ZXJpYWxzLmxlbmd0aDsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRhcnJheS5wdXNoKCBsb2FkZXIucGFyc2UoIGRhdGEubWF0ZXJpYWxzWyBqIF0gKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRlcmlhbHNbIGRhdGEudXVpZCBdID0gYXJyYXk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRtYXRlcmlhbHNbIGRhdGEudXVpZCBdID0gbG9hZGVyLnBhcnNlKCBkYXRhICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG1hdGVyaWFscztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHBhcnNlQW5pbWF0aW9uczogZnVuY3Rpb24gKCBqc29uICkge1xcblxcblxcdFxcdFxcdHZhciBhbmltYXRpb25zID0gW107XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwganNvbi5sZW5ndGg7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGNsaXAgPSBBbmltYXRpb25DbGlwLnBhcnNlKCBqc29uWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHRhbmltYXRpb25zLnB1c2goIGNsaXAgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGFuaW1hdGlvbnM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwYXJzZUltYWdlczogZnVuY3Rpb24gKCBqc29uLCBvbkxvYWQgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXG5cXHRcXHRcXHR2YXIgaW1hZ2VzID0ge307XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gbG9hZEltYWdlKCB1cmwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcXG5cXG5cXHRcXHRcXHRcXHR9LCB1bmRlZmluZWQsIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FbmQoIHVybCApO1xcblxcdFxcdFxcdFxcdFxcdHNjb3BlLm1hbmFnZXIuaXRlbUVycm9yKCB1cmwgKTtcXG5cXG5cXHRcXHRcXHRcXHR9ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICYmIGpzb24ubGVuZ3RoID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbWFuYWdlciA9IG5ldyBMb2FkaW5nTWFuYWdlciggb25Mb2FkICk7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGxvYWRlciA9IG5ldyBJbWFnZUxvYWRlciggbWFuYWdlciApO1xcblxcdFxcdFxcdFxcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgaW1hZ2UgPSBqc29uWyBpIF07XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHBhdGggPSAvXihcXFxcL1xcXFwvKXwoW2Etel0rOihcXFxcL1xcXFwvKT8pL2kudGVzdCggaW1hZ2UudXJsICkgPyBpbWFnZS51cmwgOiBzY29wZS50ZXh0dXJlUGF0aCArIGltYWdlLnVybDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpbWFnZXNbIGltYWdlLnV1aWQgXSA9IGxvYWRJbWFnZSggcGF0aCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGltYWdlcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHBhcnNlVGV4dHVyZXM6IGZ1bmN0aW9uICgganNvbiwgaW1hZ2VzICkge1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIHBhcnNlQ29uc3RhbnQoIHZhbHVlLCB0eXBlICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyApIHJldHVybiB2YWx1ZTtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXIucGFyc2VUZXh0dXJlOiBDb25zdGFudCBzaG91bGQgYmUgaW4gbnVtZXJpYyBmb3JtLicsIHZhbHVlICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHR5cGVbIHZhbHVlIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciB0ZXh0dXJlcyA9IHt9O1xcblxcblxcdFxcdFxcdGlmICgganNvbiAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGpzb24ubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZGF0YSA9IGpzb25bIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEuaW1hZ2UgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IE5vIFxcXCJpbWFnZVxcXCIgc3BlY2lmaWVkIGZvcicsIGRhdGEudXVpZCApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGltYWdlc1sgZGF0YS5pbWFnZSBdID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgaW1hZ2UnLCBkYXRhLmltYWdlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHZhciB0ZXh0dXJlID0gbmV3IFRleHR1cmUoIGltYWdlc1sgZGF0YS5pbWFnZSBdICk7XFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZS5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGV4dHVyZS51dWlkID0gZGF0YS51dWlkO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5uYW1lICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm5hbWUgPSBkYXRhLm5hbWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLm1hcHBpbmcgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFwcGluZyA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWFwcGluZywgVEVYVFVSRV9NQVBQSU5HICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLm9mZnNldCAhPT0gdW5kZWZpbmVkICkgdGV4dHVyZS5vZmZzZXQuZnJvbUFycmF5KCBkYXRhLm9mZnNldCApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5yZXBlYXQgIT09IHVuZGVmaW5lZCApIHRleHR1cmUucmVwZWF0LmZyb21BcnJheSggZGF0YS5yZXBlYXQgKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEuY2VudGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLmNlbnRlci5mcm9tQXJyYXkoIGRhdGEuY2VudGVyICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLnJvdGF0aW9uID0gZGF0YS5yb3RhdGlvbjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEud3JhcCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmUud3JhcFMgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDAgXSwgVEVYVFVSRV9XUkFQUElORyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHRleHR1cmUud3JhcFQgPSBwYXJzZUNvbnN0YW50KCBkYXRhLndyYXBbIDEgXSwgVEVYVFVSRV9XUkFQUElORyApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEubWluRmlsdGVyICE9PSB1bmRlZmluZWQgKSB0ZXh0dXJlLm1pbkZpbHRlciA9IHBhcnNlQ29uc3RhbnQoIGRhdGEubWluRmlsdGVyLCBURVhUVVJFX0ZJTFRFUiApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5tYWdGaWx0ZXIgIT09IHVuZGVmaW5lZCApIHRleHR1cmUubWFnRmlsdGVyID0gcGFyc2VDb25zdGFudCggZGF0YS5tYWdGaWx0ZXIsIFRFWFRVUkVfRklMVEVSICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLmFuaXNvdHJvcHkgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuYW5pc290cm9weSA9IGRhdGEuYW5pc290cm9weTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEuZmxpcFkgIT09IHVuZGVmaW5lZCApIHRleHR1cmUuZmxpcFkgPSBkYXRhLmZsaXBZO1xcblxcblxcdFxcdFxcdFxcdFxcdHRleHR1cmVzWyBkYXRhLnV1aWQgXSA9IHRleHR1cmU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwYXJzZU9iamVjdDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4NCgpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiBwYXJzZU9iamVjdCggZGF0YSwgZ2VvbWV0cmllcywgbWF0ZXJpYWxzICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBvYmplY3Q7XFxuXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gZ2V0R2VvbWV0cnkoIG5hbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBnZW9tZXRyaWVzWyBuYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3RMb2FkZXI6IFVuZGVmaW5lZCBnZW9tZXRyeScsIG5hbWUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGdlb21ldHJpZXNbIG5hbWUgXTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gZ2V0TWF0ZXJpYWwoIG5hbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBuYW1lID09PSB1bmRlZmluZWQgKSByZXR1cm4gdW5kZWZpbmVkO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBhcnJheSA9IFtdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IG5hbWUubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgdXVpZCA9IG5hbWVbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIG1hdGVyaWFsc1sgdXVpZCBdID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyOiBVbmRlZmluZWQgbWF0ZXJpYWwnLCB1dWlkICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGFycmF5LnB1c2goIG1hdGVyaWFsc1sgdXVpZCBdICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBhcnJheTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBtYXRlcmlhbHNbIG5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdExvYWRlcjogVW5kZWZpbmVkIG1hdGVyaWFsJywgbmFtZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gbWF0ZXJpYWxzWyBuYW1lIF07XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHN3aXRjaCAoIGRhdGEudHlwZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdTY2VuZSc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0ID0gbmV3IFNjZW5lKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLmJhY2tncm91bmQgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIE51bWJlci5pc0ludGVnZXIoIGRhdGEuYmFja2dyb3VuZCApICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdC5iYWNrZ3JvdW5kID0gbmV3IENvbG9yKCBkYXRhLmJhY2tncm91bmQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5mb2cgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEuZm9nLnR5cGUgPT09ICdGb2cnICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdC5mb2cgPSBuZXcgRm9nKCBkYXRhLmZvZy5jb2xvciwgZGF0YS5mb2cubmVhciwgZGF0YS5mb2cuZmFyICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggZGF0YS5mb2cudHlwZSA9PT0gJ0ZvZ0V4cDInICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdC5mb2cgPSBuZXcgRm9nRXhwMiggZGF0YS5mb2cuY29sb3IsIGRhdGEuZm9nLmRlbnNpdHkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ1BlcnNwZWN0aXZlQ2FtZXJhJzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGRhdGEuZm92LCBkYXRhLmFzcGVjdCwgZGF0YS5uZWFyLCBkYXRhLmZhciApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5mb2N1cyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmZvY3VzID0gZGF0YS5mb2N1cztcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEuem9vbSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0Lnpvb20gPSBkYXRhLnpvb207XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLmZpbG1HYXVnZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LmZpbG1HYXVnZSA9IGRhdGEuZmlsbUdhdWdlO1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5maWxtT2Zmc2V0ICE9PSB1bmRlZmluZWQgKSBvYmplY3QuZmlsbU9mZnNldCA9IGRhdGEuZmlsbU9mZnNldDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEudmlldyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnZpZXcgPSBPYmplY3QuYXNzaWduKCB7fSwgZGF0YS52aWV3ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnT3J0aG9ncmFwaGljQ2FtZXJhJzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QgPSBuZXcgT3J0aG9ncmFwaGljQ2FtZXJhKCBkYXRhLmxlZnQsIGRhdGEucmlnaHQsIGRhdGEudG9wLCBkYXRhLmJvdHRvbSwgZGF0YS5uZWFyLCBkYXRhLmZhciApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ0FtYmllbnRMaWdodCc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0ID0gbmV3IEFtYmllbnRMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdEaXJlY3Rpb25hbExpZ2h0JzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QgPSBuZXcgRGlyZWN0aW9uYWxMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdQb2ludExpZ2h0JzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QgPSBuZXcgUG9pbnRMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEuZGlzdGFuY2UsIGRhdGEuZGVjYXkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdSZWN0QXJlYUxpZ2h0JzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QgPSBuZXcgUmVjdEFyZWFMaWdodCggZGF0YS5jb2xvciwgZGF0YS5pbnRlbnNpdHksIGRhdGEud2lkdGgsIGRhdGEuaGVpZ2h0ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnU3BvdExpZ2h0JzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QgPSBuZXcgU3BvdExpZ2h0KCBkYXRhLmNvbG9yLCBkYXRhLmludGVuc2l0eSwgZGF0YS5kaXN0YW5jZSwgZGF0YS5hbmdsZSwgZGF0YS5wZW51bWJyYSwgZGF0YS5kZWNheSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ0hlbWlzcGhlcmVMaWdodCc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0ID0gbmV3IEhlbWlzcGhlcmVMaWdodCggZGF0YS5jb2xvciwgZGF0YS5ncm91bmRDb2xvciwgZGF0YS5pbnRlbnNpdHkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdTa2lubmVkTWVzaCc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0TG9hZGVyLnBhcnNlT2JqZWN0KCkgZG9lcyBub3Qgc3VwcG9ydCBTa2lubmVkTWVzaCB5ZXQuJyApO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ01lc2gnOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIG1hdGVyaWFsID0gZ2V0TWF0ZXJpYWwoIGRhdGEubWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGdlb21ldHJ5LmJvbmVzICYmIGdlb21ldHJ5LmJvbmVzLmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0ID0gbmV3IFNraW5uZWRNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdCA9IG5ldyBNZXNoKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnTE9EJzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QgPSBuZXcgTE9EKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnTGluZSc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0ID0gbmV3IExpbmUoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICksIGRhdGEubW9kZSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ0xpbmVMb29wJzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QgPSBuZXcgTGluZUxvb3AoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdMaW5lU2VnbWVudHMnOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdCA9IG5ldyBMaW5lU2VnbWVudHMoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdQb2ludENsb3VkJzpcXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdQb2ludHMnOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdCA9IG5ldyBQb2ludHMoIGdldEdlb21ldHJ5KCBkYXRhLmdlb21ldHJ5ICksIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdTcHJpdGUnOlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdCA9IG5ldyBTcHJpdGUoIGdldE1hdGVyaWFsKCBkYXRhLm1hdGVyaWFsICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRjYXNlICdHcm91cCc6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0ID0gbmV3IEdyb3VwKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZGVmYXVsdDpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3QgPSBuZXcgT2JqZWN0M0QoKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0b2JqZWN0LnV1aWQgPSBkYXRhLnV1aWQ7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBkYXRhLm5hbWUgIT09IHVuZGVmaW5lZCApIG9iamVjdC5uYW1lID0gZGF0YS5uYW1lO1xcblxcdFxcdFxcdFxcdGlmICggZGF0YS5tYXRyaXggIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRtYXRyaXguZnJvbUFycmF5KCBkYXRhLm1hdHJpeCApO1xcblxcdFxcdFxcdFxcdFxcdG1hdHJpeC5kZWNvbXBvc2UoIG9iamVjdC5wb3NpdGlvbiwgb2JqZWN0LnF1YXRlcm5pb24sIG9iamVjdC5zY2FsZSApO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLnBvc2l0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3QucG9zaXRpb24uZnJvbUFycmF5KCBkYXRhLnBvc2l0aW9uICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLnJvdGF0aW9uICE9PSB1bmRlZmluZWQgKSBvYmplY3Qucm90YXRpb24uZnJvbUFycmF5KCBkYXRhLnJvdGF0aW9uICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLnF1YXRlcm5pb24gIT09IHVuZGVmaW5lZCApIG9iamVjdC5xdWF0ZXJuaW9uLmZyb21BcnJheSggZGF0YS5xdWF0ZXJuaW9uICk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLnNjYWxlICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2NhbGUuZnJvbUFycmF5KCBkYXRhLnNjYWxlICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmICggZGF0YS5jYXN0U2hhZG93ICE9PSB1bmRlZmluZWQgKSBvYmplY3QuY2FzdFNoYWRvdyA9IGRhdGEuY2FzdFNoYWRvdztcXG5cXHRcXHRcXHRcXHRpZiAoIGRhdGEucmVjZWl2ZVNoYWRvdyAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnJlY2VpdmVTaGFkb3cgPSBkYXRhLnJlY2VpdmVTaGFkb3c7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBkYXRhLnNoYWRvdyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGRhdGEuc2hhZG93LmJpYXMgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zaGFkb3cuYmlhcyA9IGRhdGEuc2hhZG93LmJpYXM7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkYXRhLnNoYWRvdy5yYWRpdXMgIT09IHVuZGVmaW5lZCApIG9iamVjdC5zaGFkb3cucmFkaXVzID0gZGF0YS5zaGFkb3cucmFkaXVzO1xcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5zaGFkb3cubWFwU2l6ZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnNoYWRvdy5tYXBTaXplLmZyb21BcnJheSggZGF0YS5zaGFkb3cubWFwU2l6ZSApO1xcblxcdFxcdFxcdFxcdFxcdGlmICggZGF0YS5zaGFkb3cuY2FtZXJhICE9PSB1bmRlZmluZWQgKSBvYmplY3Quc2hhZG93LmNhbWVyYSA9IHRoaXMucGFyc2VPYmplY3QoIGRhdGEuc2hhZG93LmNhbWVyYSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGRhdGEudmlzaWJsZSAhPT0gdW5kZWZpbmVkICkgb2JqZWN0LnZpc2libGUgPSBkYXRhLnZpc2libGU7XFxuXFx0XFx0XFx0XFx0aWYgKCBkYXRhLnVzZXJEYXRhICE9PSB1bmRlZmluZWQgKSBvYmplY3QudXNlckRhdGEgPSBkYXRhLnVzZXJEYXRhO1xcblxcblxcdFxcdFxcdFxcdGlmICggZGF0YS5jaGlsZHJlbiAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBjaGlsZHJlbiA9IGRhdGEuY2hpbGRyZW47XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdC5hZGQoIHRoaXMucGFyc2VPYmplY3QoIGNoaWxkcmVuWyBpIF0sIGdlb21ldHJpZXMsIG1hdGVyaWFscyApICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGRhdGEudHlwZSA9PT0gJ0xPRCcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGxldmVscyA9IGRhdGEubGV2ZWxzO1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBsID0gMDsgbCA8IGxldmVscy5sZW5ndGg7IGwgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGxldmVsID0gbGV2ZWxzWyBsIF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGNoaWxkID0gb2JqZWN0LmdldE9iamVjdEJ5UHJvcGVydHkoICd1dWlkJywgbGV2ZWwub2JqZWN0ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBjaGlsZCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdC5hZGRMZXZlbCggY2hpbGQsIGxldmVsLmRpc3RhbmNlICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIG9iamVjdDtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKVxcblxcblxcdH0gKTtcXG5cXG5cXHR2YXIgVEVYVFVSRV9NQVBQSU5HID0ge1xcblxcdFxcdFVWTWFwcGluZzogVVZNYXBwaW5nLFxcblxcdFxcdEN1YmVSZWZsZWN0aW9uTWFwcGluZzogQ3ViZVJlZmxlY3Rpb25NYXBwaW5nLFxcblxcdFxcdEN1YmVSZWZyYWN0aW9uTWFwcGluZzogQ3ViZVJlZnJhY3Rpb25NYXBwaW5nLFxcblxcdFxcdEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nOiBFcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyxcXG5cXHRcXHRFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZzogRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcsXFxuXFx0XFx0U3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmc6IFNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nLFxcblxcdFxcdEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nOiBDdWJlVVZSZWZsZWN0aW9uTWFwcGluZyxcXG5cXHRcXHRDdWJlVVZSZWZyYWN0aW9uTWFwcGluZzogQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmdcXG5cXHR9O1xcblxcblxcdHZhciBURVhUVVJFX1dSQVBQSU5HID0ge1xcblxcdFxcdFJlcGVhdFdyYXBwaW5nOiBSZXBlYXRXcmFwcGluZyxcXG5cXHRcXHRDbGFtcFRvRWRnZVdyYXBwaW5nOiBDbGFtcFRvRWRnZVdyYXBwaW5nLFxcblxcdFxcdE1pcnJvcmVkUmVwZWF0V3JhcHBpbmc6IE1pcnJvcmVkUmVwZWF0V3JhcHBpbmdcXG5cXHR9O1xcblxcblxcdHZhciBURVhUVVJFX0ZJTFRFUiA9IHtcXG5cXHRcXHROZWFyZXN0RmlsdGVyOiBOZWFyZXN0RmlsdGVyLFxcblxcdFxcdE5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyOiBOZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlcixcXG5cXHRcXHROZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyOiBOZWFyZXN0TWlwTWFwTGluZWFyRmlsdGVyLFxcblxcdFxcdExpbmVhckZpbHRlcjogTGluZWFyRmlsdGVyLFxcblxcdFxcdExpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXI6IExpbmVhck1pcE1hcE5lYXJlc3RGaWx0ZXIsXFxuXFx0XFx0TGluZWFyTWlwTWFwTGluZWFyRmlsdGVyOiBMaW5lYXJNaXBNYXBMaW5lYXJGaWx0ZXJcXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgdGhlc3BpdGUgLyBodHRwOi8vY2xpY2t0b3JlbGVhc2UuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEltYWdlQml0bWFwTG9hZGVyKCBtYW5hZ2VyICkge1xcblxcblxcdFxcdGlmICggdHlwZW9mIGNyZWF0ZUltYWdlQml0bWFwID09PSAndW5kZWZpbmVkJyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5JbWFnZUJpdG1hcExvYWRlcjogY3JlYXRlSW1hZ2VCaXRtYXAoKSBub3Qgc3VwcG9ydGVkLicgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCB0eXBlb2YgZmV0Y2ggPT09ICd1bmRlZmluZWQnICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlQml0bWFwTG9hZGVyOiBmZXRjaCgpIG5vdCBzdXBwb3J0ZWQuJyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyICE9PSB1bmRlZmluZWQgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xcblxcdFxcdHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcXG5cXG5cXHR9XFxuXFxuXFx0SW1hZ2VCaXRtYXBMb2FkZXIucHJvdG90eXBlID0ge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBJbWFnZUJpdG1hcExvYWRlcixcXG5cXG5cXHRcXHRzZXRPcHRpb25zOiBmdW5jdGlvbiBzZXRPcHRpb25zKCBvcHRpb25zICkge1xcblxcblxcdFxcdFxcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRsb2FkOiBmdW5jdGlvbiBsb2FkKCB1cmwsIG9uTG9hZCwgb25Qcm9ncmVzcywgb25FcnJvciApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHVybCA9PT0gdW5kZWZpbmVkICkgdXJsID0gJyc7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnBhdGggIT09IHVuZGVmaW5lZCApIHVybCA9IHRoaXMucGF0aCArIHVybDtcXG5cXG5cXHRcXHRcXHR2YXIgc2NvcGUgPSB0aGlzO1xcblxcblxcdFxcdFxcdHZhciBjYWNoZWQgPSBDYWNoZS5nZXQoIHVybCApO1xcblxcblxcdFxcdFxcdGlmICggY2FjaGVkICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtU3RhcnQoIHVybCApO1xcblxcblxcdFxcdFxcdFxcdHNldFRpbWVvdXQoIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIG9uTG9hZCApIG9uTG9hZCggY2FjaGVkICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcXG5cXG5cXHRcXHRcXHRcXHR9LCAwICk7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNhY2hlZDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZmV0Y2goIHVybCApLnRoZW4oIGZ1bmN0aW9uICggcmVzICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiByZXMuYmxvYigpO1xcblxcblxcdFxcdFxcdH0gKS50aGVuKCBmdW5jdGlvbiAoIGJsb2IgKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGNyZWF0ZUltYWdlQml0bWFwKCBibG9iLCBzY29wZS5vcHRpb25zICk7XFxuXFxuXFx0XFx0XFx0fSApLnRoZW4oIGZ1bmN0aW9uICggaW1hZ2VCaXRtYXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Q2FjaGUuYWRkKCB1cmwsIGltYWdlQml0bWFwICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBvbkxvYWQgKSBvbkxvYWQoIGltYWdlQml0bWFwICk7XFxuXFxuXFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcXG5cXG5cXHRcXHRcXHR9ICkuY2F0Y2goIGZ1bmN0aW9uICggZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG9uRXJyb3IgKSBvbkVycm9yKCBlICk7XFxuXFxuXFx0XFx0XFx0XFx0c2NvcGUubWFuYWdlci5pdGVtRW5kKCB1cmwgKTtcXG5cXHRcXHRcXHRcXHRzY29wZS5tYW5hZ2VyLml0ZW1FcnJvciggdXJsICk7XFxuXFxuXFx0XFx0XFx0fSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uICggLyogdmFsdWUgKi8gKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRQYXRoOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMucGF0aCA9IHZhbHVlO1xcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly93d3cubGFiNGdhbWVzLm5ldC96ejg1L2Jsb2dcXG5cXHQgKiBtaW5pbWFsIGNsYXNzIGZvciBwcm94aW5nIGZ1bmN0aW9ucyB0byBQYXRoLiBSZXBsYWNlcyBvbGQgXFxcImV4dHJhY3RTdWJwYXRocygpXFxcIlxcblxcdCAqKi9cXG5cXG5cXHRmdW5jdGlvbiBTaGFwZVBhdGgoKSB7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1NoYXBlUGF0aCc7XFxuXFxuXFx0XFx0dGhpcy5zdWJQYXRocyA9IFtdO1xcblxcdFxcdHRoaXMuY3VycmVudFBhdGggPSBudWxsO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBTaGFwZVBhdGgucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0bW92ZVRvOiBmdW5jdGlvbiAoIHgsIHkgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jdXJyZW50UGF0aCA9IG5ldyBQYXRoKCk7XFxuXFx0XFx0XFx0dGhpcy5zdWJQYXRocy5wdXNoKCB0aGlzLmN1cnJlbnRQYXRoICk7XFxuXFx0XFx0XFx0dGhpcy5jdXJyZW50UGF0aC5tb3ZlVG8oIHgsIHkgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGxpbmVUbzogZnVuY3Rpb24gKCB4LCB5ICkge1xcblxcblxcdFxcdFxcdHRoaXMuY3VycmVudFBhdGgubGluZVRvKCB4LCB5ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoIGFDUHgsIGFDUHksIGFYLCBhWSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmN1cnJlbnRQYXRoLnF1YWRyYXRpY0N1cnZlVG8oIGFDUHgsIGFDUHksIGFYLCBhWSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YmV6aWVyQ3VydmVUbzogZnVuY3Rpb24gKCBhQ1AxeCwgYUNQMXksIGFDUDJ4LCBhQ1AyeSwgYVgsIGFZICkge1xcblxcblxcdFxcdFxcdHRoaXMuY3VycmVudFBhdGguYmV6aWVyQ3VydmVUbyggYUNQMXgsIGFDUDF5LCBhQ1AyeCwgYUNQMnksIGFYLCBhWSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3BsaW5lVGhydTogZnVuY3Rpb24gKCBwdHMgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5jdXJyZW50UGF0aC5zcGxpbmVUaHJ1KCBwdHMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHRvU2hhcGVzOiBmdW5jdGlvbiAoIGlzQ0NXLCBub0hvbGVzICkge1xcblxcblxcdFxcdFxcdGZ1bmN0aW9uIHRvU2hhcGVzTm9Ib2xlcyggaW5TdWJwYXRocyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgc2hhcGVzID0gW107XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gaW5TdWJwYXRocy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB0bXBQYXRoID0gaW5TdWJwYXRoc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciB0bXBTaGFwZSA9IG5ldyBTaGFwZSgpO1xcblxcdFxcdFxcdFxcdFxcdHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xcblxcblxcdFxcdFxcdFxcdFxcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gc2hhcGVzO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmdW5jdGlvbiBpc1BvaW50SW5zaWRlUG9seWdvbiggaW5QdCwgaW5Qb2x5Z29uICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBwb2x5TGVuID0gaW5Qb2x5Z29uLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpblB0IG9uIHBvbHlnb24gY29udG91ciA9PiBpbW1lZGlhdGUgc3VjY2VzcyAgICBvclxcblxcdFxcdFxcdFxcdC8vIHRvZ2dsaW5nIG9mIGluc2lkZS9vdXRzaWRlIGF0IGV2ZXJ5IHNpbmdsZSEgaW50ZXJzZWN0aW9uIHBvaW50IG9mIGFuIGVkZ2VcXG5cXHRcXHRcXHRcXHQvLyAgd2l0aCB0aGUgaG9yaXpvbnRhbCBsaW5lIHRocm91Z2ggaW5QdCwgbGVmdCBvZiBpblB0XFxuXFx0XFx0XFx0XFx0Ly8gIG5vdCBjb3VudGluZyBsb3dlclkgZW5kcG9pbnRzIG9mIGVkZ2VzIGFuZCB3aG9sZSBlZGdlcyBvbiB0aGF0IGxpbmVcXG5cXHRcXHRcXHRcXHR2YXIgaW5zaWRlID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIHAgPSBwb2x5TGVuIC0gMSwgcSA9IDA7IHEgPCBwb2x5TGVuOyBwID0gcSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZWRnZUxvd1B0ID0gaW5Qb2x5Z29uWyBwIF07XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGVkZ2VIaWdoUHQgPSBpblBvbHlnb25bIHEgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZWRnZUR4ID0gZWRnZUhpZ2hQdC54IC0gZWRnZUxvd1B0Lng7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGVkZ2VEeSA9IGVkZ2VIaWdoUHQueSAtIGVkZ2VMb3dQdC55O1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggTWF0aC5hYnMoIGVkZ2VEeSApID4gTnVtYmVyLkVQU0lMT04gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gbm90IHBhcmFsbGVsXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBlZGdlRHkgPCAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGVkZ2VMb3dQdCA9IGluUG9seWdvblsgcSBdOyBlZGdlRHggPSAtIGVkZ2VEeDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRlZGdlSGlnaFB0ID0gaW5Qb2x5Z29uWyBwIF07IGVkZ2VEeSA9IC0gZWRnZUR5O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoICggaW5QdC55IDwgZWRnZUxvd1B0LnkgKSB8fCAoIGluUHQueSA+IGVkZ2VIaWdoUHQueSApICkgXFx0XFx0Y29udGludWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBpblB0LnkgPT09IGVkZ2VMb3dQdC55ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaW5QdC54ID09PSBlZGdlTG93UHQueCApXFx0XFx0cmV0dXJuXFx0dHJ1ZTtcXHRcXHQvLyBpblB0IGlzIG9uIGNvbnRvdXIgP1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGNvbnRpbnVlO1xcdFxcdFxcdFxcdC8vIG5vIGludGVyc2VjdGlvbiBvciBlZGdlTG93UHQgPT4gZG9lc24ndCBjb3VudCAhISFcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBwZXJwRWRnZSA9IGVkZ2VEeSAqICggaW5QdC54IC0gZWRnZUxvd1B0LnggKSAtIGVkZ2VEeCAqICggaW5QdC55IC0gZWRnZUxvd1B0LnkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHBlcnBFZGdlID09PSAwIClcXHRcXHRcXHRcXHRyZXR1cm5cXHR0cnVlO1xcdFxcdC8vIGluUHQgaXMgb24gY29udG91ciA/XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBwZXJwRWRnZSA8IDAgKSBcXHRcXHRcXHRcXHRjb250aW51ZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpbnNpZGUgPSAhIGluc2lkZTtcXHRcXHQvLyB0cnVlIGludGVyc2VjdGlvbiBsZWZ0IG9mIGluUHRcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBwYXJhbGxlbCBvciBjb2xsaW5lYXJcXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGluUHQueSAhPT0gZWRnZUxvd1B0LnkgKSBcXHRcXHRjb250aW51ZTtcXHRcXHRcXHQvLyBwYXJhbGxlbFxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIGVkZ2UgbGllcyBvbiB0aGUgc2FtZSBob3Jpem9udGFsIGxpbmUgYXMgaW5QdFxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggKCAoIGVkZ2VIaWdoUHQueCA8PSBpblB0LnggKSAmJiAoIGluUHQueCA8PSBlZGdlTG93UHQueCApICkgfHxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQgKCAoIGVkZ2VMb3dQdC54IDw9IGluUHQueCApICYmICggaW5QdC54IDw9IGVkZ2VIaWdoUHQueCApICkgKVxcdFxcdHJldHVyblxcdHRydWU7XFx0Ly8gaW5QdDogUG9pbnQgb24gY29udG91ciAhXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gY29udGludWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm5cXHRpbnNpZGU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBpc0Nsb2NrV2lzZSA9IFNoYXBlVXRpbHMuaXNDbG9ja1dpc2U7XFxuXFxuXFx0XFx0XFx0dmFyIHN1YlBhdGhzID0gdGhpcy5zdWJQYXRocztcXG5cXHRcXHRcXHRpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PT0gMCApIHJldHVybiBbXTtcXG5cXG5cXHRcXHRcXHRpZiAoIG5vSG9sZXMgPT09IHRydWUgKVxcdHJldHVyblxcdHRvU2hhcGVzTm9Ib2xlcyggc3ViUGF0aHMgKTtcXG5cXG5cXG5cXHRcXHRcXHR2YXIgc29saWQsIHRtcFBhdGgsIHRtcFNoYXBlLCBzaGFwZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRpZiAoIHN1YlBhdGhzLmxlbmd0aCA9PT0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0bXBQYXRoID0gc3ViUGF0aHNbIDAgXTtcXG5cXHRcXHRcXHRcXHR0bXBTaGFwZSA9IG5ldyBTaGFwZSgpO1xcblxcdFxcdFxcdFxcdHRtcFNoYXBlLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xcblxcdFxcdFxcdFxcdHNoYXBlcy5wdXNoKCB0bXBTaGFwZSApO1xcblxcdFxcdFxcdFxcdHJldHVybiBzaGFwZXM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBob2xlc0ZpcnN0ID0gISBpc0Nsb2NrV2lzZSggc3ViUGF0aHNbIDAgXS5nZXRQb2ludHMoKSApO1xcblxcdFxcdFxcdGhvbGVzRmlyc3QgPSBpc0NDVyA/ICEgaG9sZXNGaXJzdCA6IGhvbGVzRmlyc3Q7XFxuXFxuXFx0XFx0XFx0Ly8gY29uc29sZS5sb2coXFxcIkhvbGVzIGZpcnN0XFxcIiwgaG9sZXNGaXJzdCk7XFxuXFxuXFx0XFx0XFx0dmFyIGJldHRlclNoYXBlSG9sZXMgPSBbXTtcXG5cXHRcXHRcXHR2YXIgbmV3U2hhcGVzID0gW107XFxuXFx0XFx0XFx0dmFyIG5ld1NoYXBlSG9sZXMgPSBbXTtcXG5cXHRcXHRcXHR2YXIgbWFpbklkeCA9IDA7XFxuXFx0XFx0XFx0dmFyIHRtcFBvaW50cztcXG5cXG5cXHRcXHRcXHRuZXdTaGFwZXNbIG1haW5JZHggXSA9IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHRuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0gPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBzdWJQYXRocy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdHRtcFBhdGggPSBzdWJQYXRoc1sgaSBdO1xcblxcdFxcdFxcdFxcdHRtcFBvaW50cyA9IHRtcFBhdGguZ2V0UG9pbnRzKCk7XFxuXFx0XFx0XFx0XFx0c29saWQgPSBpc0Nsb2NrV2lzZSggdG1wUG9pbnRzICk7XFxuXFx0XFx0XFx0XFx0c29saWQgPSBpc0NDVyA/ICEgc29saWQgOiBzb2xpZDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHNvbGlkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggKCAhIGhvbGVzRmlyc3QgKSAmJiAoIG5ld1NoYXBlc1sgbWFpbklkeCBdICkgKVxcdG1haW5JZHggKys7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bmV3U2hhcGVzWyBtYWluSWR4IF0gPSB7IHM6IG5ldyBTaGFwZSgpLCBwOiB0bXBQb2ludHMgfTtcXG5cXHRcXHRcXHRcXHRcXHRuZXdTaGFwZXNbIG1haW5JZHggXS5zLmN1cnZlcyA9IHRtcFBhdGguY3VydmVzO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggaG9sZXNGaXJzdCApXFx0bWFpbklkeCArKztcXG5cXHRcXHRcXHRcXHRcXHRuZXdTaGFwZUhvbGVzWyBtYWluSWR4IF0gPSBbXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvL2NvbnNvbGUubG9nKCdjdycsIGkpO1xcblxcblxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0bmV3U2hhcGVIb2xlc1sgbWFpbklkeCBdLnB1c2goIHsgaDogdG1wUGF0aCwgcDogdG1wUG9pbnRzWyAwIF0gfSApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vY29uc29sZS5sb2coJ2NjdycsIGkpO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gb25seSBIb2xlcz8gLT4gcHJvYmFibHkgYWxsIFNoYXBlcyB3aXRoIHdyb25nIG9yaWVudGF0aW9uXFxuXFx0XFx0XFx0aWYgKCAhIG5ld1NoYXBlc1sgMCBdIClcXHRyZXR1cm5cXHR0b1NoYXBlc05vSG9sZXMoIHN1YlBhdGhzICk7XFxuXFxuXFxuXFx0XFx0XFx0aWYgKCBuZXdTaGFwZXMubGVuZ3RoID4gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYW1iaWd1b3VzID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0dmFyIHRvQ2hhbmdlID0gW107XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIHNJZHggPSAwLCBzTGVuID0gbmV3U2hhcGVzLmxlbmd0aDsgc0lkeCA8IHNMZW47IHNJZHggKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YmV0dGVyU2hhcGVIb2xlc1sgc0lkeCBdID0gW107XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBzSWR4ID0gMCwgc0xlbiA9IG5ld1NoYXBlcy5sZW5ndGg7IHNJZHggPCBzTGVuOyBzSWR4ICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBzaG8gPSBuZXdTaGFwZUhvbGVzWyBzSWR4IF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGhJZHggPSAwOyBoSWR4IDwgc2hvLmxlbmd0aDsgaElkeCArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgaG8gPSBzaG9bIGhJZHggXTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgaG9sZV91bmFzc2lnbmVkID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgczJJZHggPSAwOyBzMklkeCA8IG5ld1NoYXBlcy5sZW5ndGg7IHMySWR4ICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggaXNQb2ludEluc2lkZVBvbHlnb24oIGhvLnAsIG5ld1NoYXBlc1sgczJJZHggXS5wICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBzSWR4ICE9PSBzMklkeCApXFx0dG9DaGFuZ2UucHVzaCggeyBmcm9tczogc0lkeCwgdG9zOiBzMklkeCwgaG9sZTogaElkeCB9ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBob2xlX3VuYXNzaWduZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aG9sZV91bmFzc2lnbmVkID0gZmFsc2U7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YmV0dGVyU2hhcGVIb2xlc1sgczJJZHggXS5wdXNoKCBobyApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YW1iaWd1b3VzID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGhvbGVfdW5hc3NpZ25lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiZXR0ZXJTaGFwZUhvbGVzWyBzSWR4IF0ucHVzaCggaG8gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHQvLyBjb25zb2xlLmxvZyhcXFwiYW1iaWd1b3VzOiBcXFwiLCBhbWJpZ3VvdXMpO1xcblxcdFxcdFxcdFxcdGlmICggdG9DaGFuZ2UubGVuZ3RoID4gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBjb25zb2xlLmxvZyhcXFwidG8gY2hhbmdlOiBcXFwiLCB0b0NoYW5nZSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAhIGFtYmlndW91cyApXFx0bmV3U2hhcGVIb2xlcyA9IGJldHRlclNoYXBlSG9sZXM7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgdG1wSG9sZXM7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBpbCA9IG5ld1NoYXBlcy5sZW5ndGg7IGkgPCBpbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0bXBTaGFwZSA9IG5ld1NoYXBlc1sgaSBdLnM7XFxuXFx0XFx0XFx0XFx0c2hhcGVzLnB1c2goIHRtcFNoYXBlICk7XFxuXFx0XFx0XFx0XFx0dG1wSG9sZXMgPSBuZXdTaGFwZUhvbGVzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IHRtcEhvbGVzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRtcFNoYXBlLmhvbGVzLnB1c2goIHRtcEhvbGVzWyBqIF0uaCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly9jb25zb2xlLmxvZyhcXFwic2hhcGVcXFwiLCBzaGFwZXMpO1xcblxcblxcdFxcdFxcdHJldHVybiBzaGFwZXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIHp6ODUgLyBodHRwOi8vd3d3LmxhYjRnYW1lcy5uZXQveno4NS9ibG9nXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBGb250KCBkYXRhICkge1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdGb250JztcXG5cXG5cXHRcXHR0aGlzLmRhdGEgPSBkYXRhO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBGb250LnByb3RvdHlwZSwge1xcblxcblxcdFxcdGlzRm9udDogdHJ1ZSxcXG5cXG5cXHRcXHRnZW5lcmF0ZVNoYXBlczogZnVuY3Rpb24gKCB0ZXh0LCBzaXplLCBkaXZpc2lvbnMgKSB7XFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gY3JlYXRlUGF0aHMoIHRleHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGNoYXJzID0gU3RyaW5nKCB0ZXh0ICkuc3BsaXQoICcnICk7XFxuXFx0XFx0XFx0XFx0dmFyIHNjYWxlID0gc2l6ZSAvIGRhdGEucmVzb2x1dGlvbjtcXG5cXHRcXHRcXHRcXHR2YXIgbGluZV9oZWlnaHQgPSAoIGRhdGEuYm91bmRpbmdCb3gueU1heCAtIGRhdGEuYm91bmRpbmdCb3gueU1pbiArIGRhdGEudW5kZXJsaW5lVGhpY2tuZXNzICkgKiBzY2FsZTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgb2Zmc2V0WCA9IDAsIG9mZnNldFkgPSAwO1xcblxcblxcdFxcdFxcdFxcdHZhciBwYXRocyA9IFtdO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgY2hhciA9IGNoYXJzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBjaGFyID09PSAnXFxcXG4nICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdG9mZnNldFggPSAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdG9mZnNldFkgLT0gbGluZV9oZWlnaHQ7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgcmV0ID0gY3JlYXRlUGF0aCggY2hhciwgc2NhbGUsIG9mZnNldFgsIG9mZnNldFkgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRvZmZzZXRYICs9IHJldC5vZmZzZXRYO1xcblxcdFxcdFxcdFxcdFxcdFxcdHBhdGhzLnB1c2goIHJldC5wYXRoICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gcGF0aHM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGNyZWF0ZVBhdGgoIGMsIHNjYWxlLCBvZmZzZXRYLCBvZmZzZXRZICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBnbHlwaCA9IGRhdGEuZ2x5cGhzWyBjIF0gfHwgZGF0YS5nbHlwaHNbICc/JyBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggISBnbHlwaCApIHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcGF0aCA9IG5ldyBTaGFwZVBhdGgoKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcHRzID0gW107XFxuXFx0XFx0XFx0XFx0dmFyIHgsIHksIGNweCwgY3B5LCBjcHgwLCBjcHkwLCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCBsYXN0ZTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGdseXBoLm8gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIG91dGxpbmUgPSBnbHlwaC5fY2FjaGVkT3V0bGluZSB8fCAoIGdseXBoLl9jYWNoZWRPdXRsaW5lID0gZ2x5cGguby5zcGxpdCggJyAnICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBvdXRsaW5lLmxlbmd0aDsgaSA8IGw7ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBhY3Rpb24gPSBvdXRsaW5lWyBpICsrIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0c3dpdGNoICggYWN0aW9uICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNhc2UgJ20nOiAvLyBtb3ZlVG9cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR4ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRYO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHkgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cGF0aC5tb3ZlVG8oIHgsIHkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjYXNlICdsJzogLy8gbGluZVRvXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0eCA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRZO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHBhdGgubGluZVRvKCB4LCB5ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAncSc6IC8vIHF1YWRyYXRpY0N1cnZlVG9cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjcHggPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3B5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRZO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNweDEgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3B5MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRwYXRoLnF1YWRyYXRpY0N1cnZlVG8oIGNweDEsIGNweTEsIGNweCwgY3B5ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bGFzdGUgPSBwdHNbIHB0cy5sZW5ndGggLSAxIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBsYXN0ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjcHgwID0gbGFzdGUueDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjcHkwID0gbGFzdGUueTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y2FzZSAnYic6IC8vIGJlemllckN1cnZlVG9cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjcHggPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3B5ID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRZO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNweDEgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3B5MSA9IG91dGxpbmVbIGkgKysgXSAqIHNjYWxlICsgb2Zmc2V0WTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRjcHgyID0gb3V0bGluZVsgaSArKyBdICogc2NhbGUgKyBvZmZzZXRYO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGNweTIgPSBvdXRsaW5lWyBpICsrIF0gKiBzY2FsZSArIG9mZnNldFk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cGF0aC5iZXppZXJDdXJ2ZVRvKCBjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCBjcHgsIGNweSApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGxhc3RlID0gcHRzWyBwdHMubGVuZ3RoIC0gMSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggbGFzdGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3B4MCA9IGxhc3RlLng7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0Y3B5MCA9IGxhc3RlLnk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHJldHVybiB7IG9mZnNldFg6IGdseXBoLmhhICogc2NhbGUsIHBhdGg6IHBhdGggfTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly9cXG5cXG5cXHRcXHRcXHRpZiAoIHNpemUgPT09IHVuZGVmaW5lZCApIHNpemUgPSAxMDA7XFxuXFx0XFx0XFx0aWYgKCBkaXZpc2lvbnMgPT09IHVuZGVmaW5lZCApIGRpdmlzaW9ucyA9IDQ7XFxuXFxuXFx0XFx0XFx0dmFyIGRhdGEgPSB0aGlzLmRhdGE7XFxuXFxuXFx0XFx0XFx0dmFyIHBhdGhzID0gY3JlYXRlUGF0aHMoIHRleHQgKTtcXG5cXHRcXHRcXHR2YXIgc2hhcGVzID0gW107XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIHAgPSAwLCBwbCA9IHBhdGhzLmxlbmd0aDsgcCA8IHBsOyBwICsrICkge1xcblxcblxcdFxcdFxcdFxcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KCBzaGFwZXMsIHBhdGhzWyBwIF0udG9TaGFwZXMoKSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gc2hhcGVzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBGb250TG9hZGVyKCBtYW5hZ2VyICkge1xcblxcblxcdFxcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBGb250TG9hZGVyLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGxvYWQ6IGZ1bmN0aW9uICggdXJsLCBvbkxvYWQsIG9uUHJvZ3Jlc3MsIG9uRXJyb3IgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXG5cXG5cXHRcXHRcXHR2YXIgbG9hZGVyID0gbmV3IEZpbGVMb2FkZXIoIHRoaXMubWFuYWdlciApO1xcblxcdFxcdFxcdGxvYWRlci5zZXRQYXRoKCB0aGlzLnBhdGggKTtcXG5cXHRcXHRcXHRsb2FkZXIubG9hZCggdXJsLCBmdW5jdGlvbiAoIHRleHQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGpzb247XFxuXFxuXFx0XFx0XFx0XFx0dHJ5IHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRqc29uID0gSlNPTi5wYXJzZSggdGV4dCApO1xcblxcblxcdFxcdFxcdFxcdH0gY2F0Y2ggKCBlICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZvbnRMb2FkZXI6IHR5cGVmYWNlLmpzIHN1cHBvcnQgaXMgYmVpbmcgZGVwcmVjYXRlZC4gVXNlIHR5cGVmYWNlLmpzb24gaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0XFx0XFx0anNvbiA9IEpTT04ucGFyc2UoIHRleHQuc3Vic3RyaW5nKCA2NSwgdGV4dC5sZW5ndGggLSAyICkgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGZvbnQgPSBzY29wZS5wYXJzZSgganNvbiApO1xcblxcblxcdFxcdFxcdFxcdGlmICggb25Mb2FkICkgb25Mb2FkKCBmb250ICk7XFxuXFxuXFx0XFx0XFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cGFyc2U6IGZ1bmN0aW9uICgganNvbiApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IEZvbnQoIGpzb24gKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFBhdGg6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5wYXRoID0gdmFsdWU7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdHZhciBjb250ZXh0O1xcblxcblxcdHZhciBBdWRpb0NvbnRleHQgPSB7XFxuXFxuXFx0XFx0Z2V0Q29udGV4dDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGlmICggY29udGV4dCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnRleHQgPSBuZXcgKCB3aW5kb3cuQXVkaW9Db250ZXh0IHx8IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgKSgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gY29udGV4dDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldENvbnRleHQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0Y29udGV4dCA9IHZhbHVlO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgUmVlY2UgQWFyb24gTGVjcml2YWluIC8gaHR0cDovL3JlZWNlbm90ZXMuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEF1ZGlvTG9hZGVyKCBtYW5hZ2VyICkge1xcblxcblxcdFxcdHRoaXMubWFuYWdlciA9ICggbWFuYWdlciAhPT0gdW5kZWZpbmVkICkgPyBtYW5hZ2VyIDogRGVmYXVsdExvYWRpbmdNYW5hZ2VyO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBBdWRpb0xvYWRlci5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRsb2FkOiBmdW5jdGlvbiAoIHVybCwgb25Mb2FkLCBvblByb2dyZXNzLCBvbkVycm9yICkge1xcblxcblxcdFxcdFxcdHZhciBsb2FkZXIgPSBuZXcgRmlsZUxvYWRlciggdGhpcy5tYW5hZ2VyICk7XFxuXFx0XFx0XFx0bG9hZGVyLnNldFJlc3BvbnNlVHlwZSggJ2FycmF5YnVmZmVyJyApO1xcblxcdFxcdFxcdGxvYWRlci5sb2FkKCB1cmwsIGZ1bmN0aW9uICggYnVmZmVyICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBjb250ZXh0ID0gQXVkaW9Db250ZXh0LmdldENvbnRleHQoKTtcXG5cXG5cXHRcXHRcXHRcXHRjb250ZXh0LmRlY29kZUF1ZGlvRGF0YSggYnVmZmVyLCBmdW5jdGlvbiAoIGF1ZGlvQnVmZmVyICkge1xcblxcblxcdFxcdFxcdFxcdFxcdG9uTG9hZCggYXVkaW9CdWZmZXIgKTtcXG5cXG5cXHRcXHRcXHRcXHR9ICk7XFxuXFxuXFx0XFx0XFx0fSwgb25Qcm9ncmVzcywgb25FcnJvciApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBTdGVyZW9DYW1lcmEoKSB7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ1N0ZXJlb0NhbWVyYSc7XFxuXFxuXFx0XFx0dGhpcy5hc3BlY3QgPSAxO1xcblxcblxcdFxcdHRoaXMuZXllU2VwID0gMC4wNjQ7XFxuXFxuXFx0XFx0dGhpcy5jYW1lcmFMID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCk7XFxuXFx0XFx0dGhpcy5jYW1lcmFMLmxheWVycy5lbmFibGUoIDEgKTtcXG5cXHRcXHR0aGlzLmNhbWVyYUwubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMuY2FtZXJhUiA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSgpO1xcblxcdFxcdHRoaXMuY2FtZXJhUi5sYXllcnMuZW5hYmxlKCAyICk7XFxuXFx0XFx0dGhpcy5jYW1lcmFSLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggU3RlcmVvQ2FtZXJhLnByb3RvdHlwZSwge1xcblxcblxcdFxcdHVwZGF0ZTogKCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGluc3RhbmNlLCBmb2N1cywgZm92LCBhc3BlY3QsIG5lYXIsIGZhciwgem9vbSwgZXllU2VwO1xcblxcblxcdFxcdFxcdHZhciBleWVSaWdodCA9IG5ldyBNYXRyaXg0KCk7XFxuXFx0XFx0XFx0dmFyIGV5ZUxlZnQgPSBuZXcgTWF0cml4NCgpO1xcblxcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoIGNhbWVyYSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbmVlZHNVcGRhdGUgPSBpbnN0YW5jZSAhPT0gdGhpcyB8fCBmb2N1cyAhPT0gY2FtZXJhLmZvY3VzIHx8IGZvdiAhPT0gY2FtZXJhLmZvdiB8fFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGFzcGVjdCAhPT0gY2FtZXJhLmFzcGVjdCAqIHRoaXMuYXNwZWN0IHx8IG5lYXIgIT09IGNhbWVyYS5uZWFyIHx8XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0ZmFyICE9PSBjYW1lcmEuZmFyIHx8IHpvb20gIT09IGNhbWVyYS56b29tIHx8IGV5ZVNlcCAhPT0gdGhpcy5leWVTZXA7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBuZWVkc1VwZGF0ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpbnN0YW5jZSA9IHRoaXM7XFxuXFx0XFx0XFx0XFx0XFx0Zm9jdXMgPSBjYW1lcmEuZm9jdXM7XFxuXFx0XFx0XFx0XFx0XFx0Zm92ID0gY2FtZXJhLmZvdjtcXG5cXHRcXHRcXHRcXHRcXHRhc3BlY3QgPSBjYW1lcmEuYXNwZWN0ICogdGhpcy5hc3BlY3Q7XFxuXFx0XFx0XFx0XFx0XFx0bmVhciA9IGNhbWVyYS5uZWFyO1xcblxcdFxcdFxcdFxcdFxcdGZhciA9IGNhbWVyYS5mYXI7XFxuXFx0XFx0XFx0XFx0XFx0em9vbSA9IGNhbWVyYS56b29tO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIE9mZi1heGlzIHN0ZXJlb3Njb3BpYyBlZmZlY3QgYmFzZWQgb25cXG5cXHRcXHRcXHRcXHRcXHQvLyBodHRwOi8vcGF1bGJvdXJrZS5uZXQvc3RlcmVvZ3JhcGhpY3Mvc3RlcmVvcmVuZGVyL1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBwcm9qZWN0aW9uTWF0cml4ID0gY2FtZXJhLnByb2plY3Rpb25NYXRyaXguY2xvbmUoKTtcXG5cXHRcXHRcXHRcXHRcXHRleWVTZXAgPSB0aGlzLmV5ZVNlcCAvIDI7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGV5ZVNlcE9uUHJvamVjdGlvbiA9IGV5ZVNlcCAqIG5lYXIgLyBmb2N1cztcXG5cXHRcXHRcXHRcXHRcXHR2YXIgeW1heCA9ICggbmVhciAqIE1hdGgudGFuKCBfTWF0aC5ERUcyUkFEICogZm92ICogMC41ICkgKSAvIHpvb207XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHhtaW4sIHhtYXg7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdHJhbnNsYXRlIHhPZmZzZXRcXG5cXG5cXHRcXHRcXHRcXHRcXHRleWVMZWZ0LmVsZW1lbnRzWyAxMiBdID0gLSBleWVTZXA7XFxuXFx0XFx0XFx0XFx0XFx0ZXllUmlnaHQuZWxlbWVudHNbIDEyIF0gPSBleWVTZXA7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gZm9yIGxlZnQgZXllXFxuXFxuXFx0XFx0XFx0XFx0XFx0eG1pbiA9IC0geW1heCAqIGFzcGVjdCArIGV5ZVNlcE9uUHJvamVjdGlvbjtcXG5cXHRcXHRcXHRcXHRcXHR4bWF4ID0geW1heCAqIGFzcGVjdCArIGV5ZVNlcE9uUHJvamVjdGlvbjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyAwIF0gPSAyICogbmVhciAvICggeG1heCAtIHhtaW4gKTtcXG5cXHRcXHRcXHRcXHRcXHRwcm9qZWN0aW9uTWF0cml4LmVsZW1lbnRzWyA4IF0gPSAoIHhtYXggKyB4bWluICkgLyAoIHhtYXggLSB4bWluICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5jYW1lcmFMLnByb2plY3Rpb25NYXRyaXguY29weSggcHJvamVjdGlvbk1hdHJpeCApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGZvciByaWdodCBleWVcXG5cXG5cXHRcXHRcXHRcXHRcXHR4bWluID0gLSB5bWF4ICogYXNwZWN0IC0gZXllU2VwT25Qcm9qZWN0aW9uO1xcblxcdFxcdFxcdFxcdFxcdHhtYXggPSB5bWF4ICogYXNwZWN0IC0gZXllU2VwT25Qcm9qZWN0aW9uO1xcblxcblxcdFxcdFxcdFxcdFxcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDAgXSA9IDIgKiBuZWFyIC8gKCB4bWF4IC0geG1pbiApO1xcblxcdFxcdFxcdFxcdFxcdHByb2plY3Rpb25NYXRyaXguZWxlbWVudHNbIDggXSA9ICggeG1heCArIHhtaW4gKSAvICggeG1heCAtIHhtaW4gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmNhbWVyYVIucHJvamVjdGlvbk1hdHJpeC5jb3B5KCBwcm9qZWN0aW9uTWF0cml4ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRoaXMuY2FtZXJhTC5tYXRyaXhXb3JsZC5jb3B5KCBjYW1lcmEubWF0cml4V29ybGQgKS5tdWx0aXBseSggZXllTGVmdCApO1xcblxcdFxcdFxcdFxcdHRoaXMuY2FtZXJhUi5tYXRyaXhXb3JsZC5jb3B5KCBjYW1lcmEubWF0cml4V29ybGQgKS5tdWx0aXBseSggZXllUmlnaHQgKTtcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0gKSgpXFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIENhbWVyYSBmb3IgcmVuZGVyaW5nIGN1YmUgbWFwc1xcblxcdCAqXFx0LSByZW5kZXJzIHNjZW5lIGludG8gYXhpcy1hbGlnbmVkIGN1YmVcXG5cXHQgKlxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gQ3ViZUNhbWVyYSggbmVhciwgZmFyLCBjdWJlUmVzb2x1dGlvbiApIHtcXG5cXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0N1YmVDYW1lcmEnO1xcblxcblxcdFxcdHZhciBmb3YgPSA5MCwgYXNwZWN0ID0gMTtcXG5cXG5cXHRcXHR2YXIgY2FtZXJhUFggPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcXG5cXHRcXHRjYW1lcmFQWC51cC5zZXQoIDAsIC0gMSwgMCApO1xcblxcdFxcdGNhbWVyYVBYLmxvb2tBdCggbmV3IFZlY3RvcjMoIDEsIDAsIDAgKSApO1xcblxcdFxcdHRoaXMuYWRkKCBjYW1lcmFQWCApO1xcblxcblxcdFxcdHZhciBjYW1lcmFOWCA9IG5ldyBQZXJzcGVjdGl2ZUNhbWVyYSggZm92LCBhc3BlY3QsIG5lYXIsIGZhciApO1xcblxcdFxcdGNhbWVyYU5YLnVwLnNldCggMCwgLSAxLCAwICk7XFxuXFx0XFx0Y2FtZXJhTlgubG9va0F0KCBuZXcgVmVjdG9yMyggLSAxLCAwLCAwICkgKTtcXG5cXHRcXHR0aGlzLmFkZCggY2FtZXJhTlggKTtcXG5cXG5cXHRcXHR2YXIgY2FtZXJhUFkgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcXG5cXHRcXHRjYW1lcmFQWS51cC5zZXQoIDAsIDAsIDEgKTtcXG5cXHRcXHRjYW1lcmFQWS5sb29rQXQoIG5ldyBWZWN0b3IzKCAwLCAxLCAwICkgKTtcXG5cXHRcXHR0aGlzLmFkZCggY2FtZXJhUFkgKTtcXG5cXG5cXHRcXHR2YXIgY2FtZXJhTlkgPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcXG5cXHRcXHRjYW1lcmFOWS51cC5zZXQoIDAsIDAsIC0gMSApO1xcblxcdFxcdGNhbWVyYU5ZLmxvb2tBdCggbmV3IFZlY3RvcjMoIDAsIC0gMSwgMCApICk7XFxuXFx0XFx0dGhpcy5hZGQoIGNhbWVyYU5ZICk7XFxuXFxuXFx0XFx0dmFyIGNhbWVyYVBaID0gbmV3IFBlcnNwZWN0aXZlQ2FtZXJhKCBmb3YsIGFzcGVjdCwgbmVhciwgZmFyICk7XFxuXFx0XFx0Y2FtZXJhUFoudXAuc2V0KCAwLCAtIDEsIDAgKTtcXG5cXHRcXHRjYW1lcmFQWi5sb29rQXQoIG5ldyBWZWN0b3IzKCAwLCAwLCAxICkgKTtcXG5cXHRcXHR0aGlzLmFkZCggY2FtZXJhUFogKTtcXG5cXG5cXHRcXHR2YXIgY2FtZXJhTlogPSBuZXcgUGVyc3BlY3RpdmVDYW1lcmEoIGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIgKTtcXG5cXHRcXHRjYW1lcmFOWi51cC5zZXQoIDAsIC0gMSwgMCApO1xcblxcdFxcdGNhbWVyYU5aLmxvb2tBdCggbmV3IFZlY3RvcjMoIDAsIDAsIC0gMSApICk7XFxuXFx0XFx0dGhpcy5hZGQoIGNhbWVyYU5aICk7XFxuXFxuXFx0XFx0dmFyIG9wdGlvbnMgPSB7IGZvcm1hdDogUkdCRm9ybWF0LCBtYWdGaWx0ZXI6IExpbmVhckZpbHRlciwgbWluRmlsdGVyOiBMaW5lYXJGaWx0ZXIgfTtcXG5cXG5cXHRcXHR0aGlzLnJlbmRlclRhcmdldCA9IG5ldyBXZWJHTFJlbmRlclRhcmdldEN1YmUoIGN1YmVSZXNvbHV0aW9uLCBjdWJlUmVzb2x1dGlvbiwgb3B0aW9ucyApO1xcblxcdFxcdHRoaXMucmVuZGVyVGFyZ2V0LnRleHR1cmUubmFtZSA9IFxcXCJDdWJlQ2FtZXJhXFxcIjtcXG5cXG5cXHRcXHR0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIHNjZW5lICkge1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5wYXJlbnQgPT09IG51bGwgKSB0aGlzLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XFxuXFxuXFx0XFx0XFx0dmFyIHJlbmRlclRhcmdldCA9IHRoaXMucmVuZGVyVGFyZ2V0O1xcblxcdFxcdFxcdHZhciBnZW5lcmF0ZU1pcG1hcHMgPSByZW5kZXJUYXJnZXQudGV4dHVyZS5nZW5lcmF0ZU1pcG1hcHM7XFxuXFxuXFx0XFx0XFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMDtcXG5cXHRcXHRcXHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWCwgcmVuZGVyVGFyZ2V0ICk7XFxuXFxuXFx0XFx0XFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMTtcXG5cXHRcXHRcXHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWCwgcmVuZGVyVGFyZ2V0ICk7XFxuXFxuXFx0XFx0XFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMjtcXG5cXHRcXHRcXHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWSwgcmVuZGVyVGFyZ2V0ICk7XFxuXFxuXFx0XFx0XFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gMztcXG5cXHRcXHRcXHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFOWSwgcmVuZGVyVGFyZ2V0ICk7XFxuXFxuXFx0XFx0XFx0cmVuZGVyVGFyZ2V0LmFjdGl2ZUN1YmVGYWNlID0gNDtcXG5cXHRcXHRcXHRyZW5kZXJlci5yZW5kZXIoIHNjZW5lLCBjYW1lcmFQWiwgcmVuZGVyVGFyZ2V0ICk7XFxuXFxuXFx0XFx0XFx0cmVuZGVyVGFyZ2V0LnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gZ2VuZXJhdGVNaXBtYXBzO1xcblxcblxcdFxcdFxcdHJlbmRlclRhcmdldC5hY3RpdmVDdWJlRmFjZSA9IDU7XFxuXFx0XFx0XFx0cmVuZGVyZXIucmVuZGVyKCBzY2VuZSwgY2FtZXJhTlosIHJlbmRlclRhcmdldCApO1xcblxcblxcdFxcdFxcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggbnVsbCApO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5jbGVhciA9IGZ1bmN0aW9uICggcmVuZGVyZXIsIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcmVuZGVyVGFyZ2V0ID0gdGhpcy5yZW5kZXJUYXJnZXQ7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgNjsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZW5kZXJUYXJnZXQuYWN0aXZlQ3ViZUZhY2UgPSBpO1xcblxcdFxcdFxcdFxcdHJlbmRlcmVyLnNldFJlbmRlclRhcmdldCggcmVuZGVyVGFyZ2V0ICk7XFxuXFxuXFx0XFx0XFx0XFx0cmVuZGVyZXIuY2xlYXIoIGNvbG9yLCBkZXB0aCwgc3RlbmNpbCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZW5kZXJlci5zZXRSZW5kZXJUYXJnZXQoIG51bGwgKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHRDdWJlQ2FtZXJhLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApO1xcblxcdEN1YmVDYW1lcmEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ3ViZUNhbWVyYTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEF1ZGlvTGlzdGVuZXIoKSB7XFxuXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdBdWRpb0xpc3RlbmVyJztcXG5cXG5cXHRcXHR0aGlzLmNvbnRleHQgPSBBdWRpb0NvbnRleHQuZ2V0Q29udGV4dCgpO1xcblxcblxcdFxcdHRoaXMuZ2FpbiA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XFxuXFx0XFx0dGhpcy5nYWluLmNvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xcblxcblxcdFxcdHRoaXMuZmlsdGVyID0gbnVsbDtcXG5cXG5cXHR9XFxuXFxuXFx0QXVkaW9MaXN0ZW5lci5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKCBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBBdWRpb0xpc3RlbmVyLFxcblxcblxcdFxcdGdldElucHV0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2FpbjtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHJlbW92ZUZpbHRlcjogZnVuY3Rpb24gKCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuZmlsdGVyICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuZ2Fpbi5kaXNjb25uZWN0KCB0aGlzLmZpbHRlciApO1xcblxcdFxcdFxcdFxcdHRoaXMuZmlsdGVyLmRpc2Nvbm5lY3QoIHRoaXMuY29udGV4dC5kZXN0aW5hdGlvbiApO1xcblxcdFxcdFxcdFxcdHRoaXMuZ2Fpbi5jb25uZWN0KCB0aGlzLmNvbnRleHQuZGVzdGluYXRpb24gKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmZpbHRlciA9IG51bGw7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0RmlsdGVyOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZmlsdGVyO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RmlsdGVyOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5maWx0ZXIgIT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5nYWluLmRpc2Nvbm5lY3QoIHRoaXMuZmlsdGVyICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5maWx0ZXIuZGlzY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmdhaW4uZGlzY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuZmlsdGVyID0gdmFsdWU7XFxuXFx0XFx0XFx0dGhpcy5nYWluLmNvbm5lY3QoIHRoaXMuZmlsdGVyICk7XFxuXFx0XFx0XFx0dGhpcy5maWx0ZXIuY29ubmVjdCggdGhpcy5jb250ZXh0LmRlc3RpbmF0aW9uICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRNYXN0ZXJWb2x1bWU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5nYWluLmdhaW4udmFsdWU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRNYXN0ZXJWb2x1bWU6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5nYWluLmdhaW4udmFsdWUgPSB2YWx1ZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHVwZGF0ZU1hdHJpeFdvcmxkOiAoIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgcG9zaXRpb24gPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdFxcdHZhciBxdWF0ZXJuaW9uID0gbmV3IFF1YXRlcm5pb24oKTtcXG5cXHRcXHRcXHR2YXIgc2NhbGUgPSBuZXcgVmVjdG9yMygpO1xcblxcblxcdFxcdFxcdHZhciBvcmllbnRhdGlvbiA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRPYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbGlzdGVuZXIgPSB0aGlzLmNvbnRleHQubGlzdGVuZXI7XFxuXFx0XFx0XFx0XFx0dmFyIHVwID0gdGhpcy51cDtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLm1hdHJpeFdvcmxkLmRlY29tcG9zZSggcG9zaXRpb24sIHF1YXRlcm5pb24sIHNjYWxlICk7XFxuXFxuXFx0XFx0XFx0XFx0b3JpZW50YXRpb24uc2V0KCAwLCAwLCAtIDEgKS5hcHBseVF1YXRlcm5pb24oIHF1YXRlcm5pb24gKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGxpc3RlbmVyLnBvc2l0aW9uWCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRsaXN0ZW5lci5wb3NpdGlvblguc2V0VmFsdWVBdFRpbWUoIHBvc2l0aW9uLngsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xcblxcdFxcdFxcdFxcdFxcdGxpc3RlbmVyLnBvc2l0aW9uWS5zZXRWYWx1ZUF0VGltZSggcG9zaXRpb24ueSwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICk7XFxuXFx0XFx0XFx0XFx0XFx0bGlzdGVuZXIucG9zaXRpb25aLnNldFZhbHVlQXRUaW1lKCBwb3NpdGlvbi56LCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKTtcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ZW5lci5mb3J3YXJkWC5zZXRWYWx1ZUF0VGltZSggb3JpZW50YXRpb24ueCwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICk7XFxuXFx0XFx0XFx0XFx0XFx0bGlzdGVuZXIuZm9yd2FyZFkuc2V0VmFsdWVBdFRpbWUoIG9yaWVudGF0aW9uLnksIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xcblxcdFxcdFxcdFxcdFxcdGxpc3RlbmVyLmZvcndhcmRaLnNldFZhbHVlQXRUaW1lKCBvcmllbnRhdGlvbi56LCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKTtcXG5cXHRcXHRcXHRcXHRcXHRsaXN0ZW5lci51cFguc2V0VmFsdWVBdFRpbWUoIHVwLngsIHRoaXMuY29udGV4dC5jdXJyZW50VGltZSApO1xcblxcdFxcdFxcdFxcdFxcdGxpc3RlbmVyLnVwWS5zZXRWYWx1ZUF0VGltZSggdXAueSwgdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lICk7XFxuXFx0XFx0XFx0XFx0XFx0bGlzdGVuZXIudXBaLnNldFZhbHVlQXRUaW1lKCB1cC56LCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdGxpc3RlbmVyLnNldFBvc2l0aW9uKCBwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56ICk7XFxuXFx0XFx0XFx0XFx0XFx0bGlzdGVuZXIuc2V0T3JpZW50YXRpb24oIG9yaWVudGF0aW9uLngsIG9yaWVudGF0aW9uLnksIG9yaWVudGF0aW9uLnosIHVwLngsIHVwLnksIHVwLnogKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9ICkoKVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgUmVlY2UgQWFyb24gTGVjcml2YWluIC8gaHR0cDovL3JlZWNlbm90ZXMuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEF1ZGlvKCBsaXN0ZW5lciApIHtcXG5cXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy50eXBlID0gJ0F1ZGlvJztcXG5cXG5cXHRcXHR0aGlzLmNvbnRleHQgPSBsaXN0ZW5lci5jb250ZXh0O1xcblxcblxcdFxcdHRoaXMuZ2FpbiA9IHRoaXMuY29udGV4dC5jcmVhdGVHYWluKCk7XFxuXFx0XFx0dGhpcy5nYWluLmNvbm5lY3QoIGxpc3RlbmVyLmdldElucHV0KCkgKTtcXG5cXG5cXHRcXHR0aGlzLmF1dG9wbGF5ID0gZmFsc2U7XFxuXFxuXFx0XFx0dGhpcy5idWZmZXIgPSBudWxsO1xcblxcdFxcdHRoaXMubG9vcCA9IGZhbHNlO1xcblxcdFxcdHRoaXMuc3RhcnRUaW1lID0gMDtcXG5cXHRcXHR0aGlzLm9mZnNldCA9IDA7XFxuXFx0XFx0dGhpcy5wbGF5YmFja1JhdGUgPSAxO1xcblxcdFxcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XFxuXFx0XFx0dGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPSB0cnVlO1xcblxcdFxcdHRoaXMuc291cmNlVHlwZSA9ICdlbXB0eSc7XFxuXFxuXFx0XFx0dGhpcy5maWx0ZXJzID0gW107XFxuXFxuXFx0fVxcblxcblxcdEF1ZGlvLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IEF1ZGlvLFxcblxcblxcdFxcdGdldE91dHB1dDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmdhaW47XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXROb2RlU291cmNlOiBmdW5jdGlvbiAoIGF1ZGlvTm9kZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmhhc1BsYXliYWNrQ29udHJvbCA9IGZhbHNlO1xcblxcdFxcdFxcdHRoaXMuc291cmNlVHlwZSA9ICdhdWRpb05vZGUnO1xcblxcdFxcdFxcdHRoaXMuc291cmNlID0gYXVkaW9Ob2RlO1xcblxcdFxcdFxcdHRoaXMuY29ubmVjdCgpO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0QnVmZmVyOiBmdW5jdGlvbiAoIGF1ZGlvQnVmZmVyICkge1xcblxcblxcdFxcdFxcdHRoaXMuYnVmZmVyID0gYXVkaW9CdWZmZXI7XFxuXFx0XFx0XFx0dGhpcy5zb3VyY2VUeXBlID0gJ2J1ZmZlcic7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmF1dG9wbGF5ICkgdGhpcy5wbGF5KCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwbGF5OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogQXVkaW8gaXMgYWxyZWFkeSBwbGF5aW5nLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBzb3VyY2UgPSB0aGlzLmNvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XFxuXFxuXFx0XFx0XFx0c291cmNlLmJ1ZmZlciA9IHRoaXMuYnVmZmVyO1xcblxcdFxcdFxcdHNvdXJjZS5sb29wID0gdGhpcy5sb29wO1xcblxcdFxcdFxcdHNvdXJjZS5vbmVuZGVkID0gdGhpcy5vbkVuZGVkLmJpbmQoIHRoaXMgKTtcXG5cXHRcXHRcXHRzb3VyY2UucGxheWJhY2tSYXRlLnNldFZhbHVlQXRUaW1lKCB0aGlzLnBsYXliYWNrUmF0ZSwgdGhpcy5zdGFydFRpbWUgKTtcXG5cXHRcXHRcXHR0aGlzLnN0YXJ0VGltZSA9IHRoaXMuY29udGV4dC5jdXJyZW50VGltZTtcXG5cXHRcXHRcXHRzb3VyY2Uuc3RhcnQoIHRoaXMuc3RhcnRUaW1lLCB0aGlzLm9mZnNldCApO1xcblxcblxcdFxcdFxcdHRoaXMuaXNQbGF5aW5nID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHR0aGlzLnNvdXJjZSA9IHNvdXJjZTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5jb25uZWN0KCk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwYXVzZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdGhpcy5pc1BsYXlpbmcgPT09IHRydWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5zb3VyY2Uuc3RvcCgpO1xcblxcdFxcdFxcdFxcdHRoaXMub2Zmc2V0ICs9ICggdGhpcy5jb250ZXh0LmN1cnJlbnRUaW1lIC0gdGhpcy5zdGFydFRpbWUgKSAqIHRoaXMucGxheWJhY2tSYXRlO1xcblxcdFxcdFxcdFxcdHRoaXMuaXNQbGF5aW5nID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3RvcDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuc291cmNlLnN0b3AoKTtcXG5cXHRcXHRcXHR0aGlzLm9mZnNldCA9IDA7XFxuXFx0XFx0XFx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuZmlsdGVycy5sZW5ndGggPiAwICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuc291cmNlLmNvbm5lY3QoIHRoaXMuZmlsdGVyc1sgMCBdICk7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAxLCBsID0gdGhpcy5maWx0ZXJzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5maWx0ZXJzWyBpIC0gMSBdLmNvbm5lY3QoIHRoaXMuZmlsdGVyc1sgaSBdICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRoaXMuZmlsdGVyc1sgdGhpcy5maWx0ZXJzLmxlbmd0aCAtIDEgXS5jb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnNvdXJjZS5jb25uZWN0KCB0aGlzLmdldE91dHB1dCgpICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGlzY29ubmVjdDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5maWx0ZXJzLmxlbmd0aCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5zb3VyY2UuZGlzY29ubmVjdCggdGhpcy5maWx0ZXJzWyAwIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDEsIGwgPSB0aGlzLmZpbHRlcnMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmZpbHRlcnNbIGkgLSAxIF0uZGlzY29ubmVjdCggdGhpcy5maWx0ZXJzWyBpIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5maWx0ZXJzWyB0aGlzLmZpbHRlcnMubGVuZ3RoIC0gMSBdLmRpc2Nvbm5lY3QoIHRoaXMuZ2V0T3V0cHV0KCkgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuc291cmNlLmRpc2Nvbm5lY3QoIHRoaXMuZ2V0T3V0cHV0KCkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRGaWx0ZXJzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZmlsdGVycztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldEZpbHRlcnM6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCAhIHZhbHVlICkgdmFsdWUgPSBbXTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuZGlzY29ubmVjdCgpO1xcblxcdFxcdFxcdFxcdHRoaXMuZmlsdGVycyA9IHZhbHVlO1xcblxcdFxcdFxcdFxcdHRoaXMuY29ubmVjdCgpO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5maWx0ZXJzID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0RmlsdGVyOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0RmlsdGVycygpWyAwIF07XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGaWx0ZXI6IGZ1bmN0aW9uICggZmlsdGVyICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLnNldEZpbHRlcnMoIGZpbHRlciA/IFsgZmlsdGVyIF0gOiBbXSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0UGxheWJhY2tSYXRlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5oYXNQbGF5YmFja0NvbnRyb2wgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiB0aGlzIEF1ZGlvIGhhcyBubyBwbGF5YmFjayBjb250cm9sLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMucGxheWJhY2tSYXRlID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmlzUGxheWluZyA9PT0gdHJ1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnNvdXJjZS5wbGF5YmFja1JhdGUuc2V0VmFsdWVBdFRpbWUoIHRoaXMucGxheWJhY2tSYXRlLCB0aGlzLmNvbnRleHQuY3VycmVudFRpbWUgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRQbGF5YmFja1JhdGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5wbGF5YmFja1JhdGU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRvbkVuZGVkOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldExvb3A6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5sb29wO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0TG9vcDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuaGFzUGxheWJhY2tDb250cm9sID09PSBmYWxzZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5BdWRpbzogdGhpcyBBdWRpbyBoYXMgbm8gcGxheWJhY2sgY29udHJvbC4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmxvb3AgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuaXNQbGF5aW5nID09PSB0cnVlICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuc291cmNlLmxvb3AgPSB0aGlzLmxvb3A7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0Vm9sdW1lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2Fpbi5nYWluLnZhbHVlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0Vm9sdW1lOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMuZ2Fpbi5nYWluLnZhbHVlID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFBvc2l0aW9uYWxBdWRpbyggbGlzdGVuZXIgKSB7XFxuXFxuXFx0XFx0QXVkaW8uY2FsbCggdGhpcywgbGlzdGVuZXIgKTtcXG5cXG5cXHRcXHR0aGlzLnBhbm5lciA9IHRoaXMuY29udGV4dC5jcmVhdGVQYW5uZXIoKTtcXG5cXHRcXHR0aGlzLnBhbm5lci5jb25uZWN0KCB0aGlzLmdhaW4gKTtcXG5cXG5cXHR9XFxuXFxuXFx0UG9zaXRpb25hbEF1ZGlvLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEF1ZGlvLnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IFBvc2l0aW9uYWxBdWRpbyxcXG5cXG5cXHRcXHRnZXRPdXRwdXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5wYW5uZXI7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRSZWZEaXN0YW5jZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLnBhbm5lci5yZWZEaXN0YW5jZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFJlZkRpc3RhbmNlOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMucGFubmVyLnJlZkRpc3RhbmNlID0gdmFsdWU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRSb2xsb2ZmRmFjdG9yOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3I7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRSb2xsb2ZmRmFjdG9yOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMucGFubmVyLnJvbGxvZmZGYWN0b3IgPSB2YWx1ZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldERpc3RhbmNlTW9kZWw6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldERpc3RhbmNlTW9kZWw6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5wYW5uZXIuZGlzdGFuY2VNb2RlbCA9IHZhbHVlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0TWF4RGlzdGFuY2U6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5wYW5uZXIubWF4RGlzdGFuY2U7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRNYXhEaXN0YW5jZTogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnBhbm5lci5tYXhEaXN0YW5jZSA9IHZhbHVlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dXBkYXRlTWF0cml4V29ybGQ6ICggZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBwb3NpdGlvbiA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRPYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcXG5cXG5cXHRcXHRcXHRcXHRwb3NpdGlvbi5zZXRGcm9tTWF0cml4UG9zaXRpb24oIHRoaXMubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnBhbm5lci5zZXRQb3NpdGlvbiggcG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueiApO1xcblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0fSApKClcXG5cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBBdWRpb0FuYWx5c2VyKCBhdWRpbywgZmZ0U2l6ZSApIHtcXG5cXG5cXHRcXHR0aGlzLmFuYWx5c2VyID0gYXVkaW8uY29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xcblxcdFxcdHRoaXMuYW5hbHlzZXIuZmZ0U2l6ZSA9IGZmdFNpemUgIT09IHVuZGVmaW5lZCA/IGZmdFNpemUgOiAyMDQ4O1xcblxcblxcdFxcdHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KCB0aGlzLmFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50ICk7XFxuXFxuXFx0XFx0YXVkaW8uZ2V0T3V0cHV0KCkuY29ubmVjdCggdGhpcy5hbmFseXNlciApO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBBdWRpb0FuYWx5c2VyLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGdldEZyZXF1ZW5jeURhdGE6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmFuYWx5c2VyLmdldEJ5dGVGcmVxdWVuY3lEYXRhKCB0aGlzLmRhdGEgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5kYXRhO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0QXZlcmFnZUZyZXF1ZW5jeTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciB2YWx1ZSA9IDAsIGRhdGEgPSB0aGlzLmdldEZyZXF1ZW5jeURhdGEoKTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YWx1ZSArPSBkYXRhWyBpIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB2YWx1ZSAvIGRhdGEubGVuZ3RoO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICpcXG5cXHQgKiBCdWZmZXJlZCBzY2VuZSBncmFwaCBwcm9wZXJ0eSB0aGF0IGFsbG93cyB3ZWlnaHRlZCBhY2N1bXVsYXRpb24uXFxuXFx0ICpcXG5cXHQgKlxcblxcdCAqIEBhdXRob3IgQmVuIEhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXFxuXFx0ICogQGF1dGhvciBEYXZpZCBTYXJubyAvIGh0dHA6Ly9saWdodGhhdXMudXMvXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFByb3BlcnR5TWl4ZXIoIGJpbmRpbmcsIHR5cGVOYW1lLCB2YWx1ZVNpemUgKSB7XFxuXFxuXFx0XFx0dGhpcy5iaW5kaW5nID0gYmluZGluZztcXG5cXHRcXHR0aGlzLnZhbHVlU2l6ZSA9IHZhbHVlU2l6ZTtcXG5cXG5cXHRcXHR2YXIgYnVmZmVyVHlwZSA9IEZsb2F0NjRBcnJheSxcXG5cXHRcXHRcXHRtaXhGdW5jdGlvbjtcXG5cXG5cXHRcXHRzd2l0Y2ggKCB0eXBlTmFtZSApIHtcXG5cXG5cXHRcXHRcXHRjYXNlICdxdWF0ZXJuaW9uJzpcXG5cXHRcXHRcXHRcXHRtaXhGdW5jdGlvbiA9IHRoaXMuX3NsZXJwO1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdGNhc2UgJ3N0cmluZyc6XFxuXFx0XFx0XFx0Y2FzZSAnYm9vbCc6XFxuXFx0XFx0XFx0XFx0YnVmZmVyVHlwZSA9IEFycmF5O1xcblxcdFxcdFxcdFxcdG1peEZ1bmN0aW9uID0gdGhpcy5fc2VsZWN0O1xcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0bWl4RnVuY3Rpb24gPSB0aGlzLl9sZXJwO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLmJ1ZmZlciA9IG5ldyBidWZmZXJUeXBlKCB2YWx1ZVNpemUgKiA0ICk7XFxuXFx0XFx0Ly8gbGF5b3V0OiBbIGluY29taW5nIHwgYWNjdTAgfCBhY2N1MSB8IG9yaWcgXVxcblxcdFxcdC8vXFxuXFx0XFx0Ly8gaW50ZXJwb2xhdG9ycyBjYW4gdXNlIC5idWZmZXIgYXMgdGhlaXIgLnJlc3VsdFxcblxcdFxcdC8vIHRoZSBkYXRhIHRoZW4gZ29lcyB0byAnaW5jb21pbmcnXFxuXFx0XFx0Ly9cXG5cXHRcXHQvLyAnYWNjdTAnIGFuZCAnYWNjdTEnIGFyZSB1c2VkIGZyYW1lLWludGVybGVhdmVkIGZvclxcblxcdFxcdC8vIHRoZSBjdW11bGF0aXZlIHJlc3VsdCBhbmQgYXJlIGNvbXBhcmVkIHRvIGRldGVjdFxcblxcdFxcdC8vIGNoYW5nZXNcXG5cXHRcXHQvL1xcblxcdFxcdC8vICdvcmlnJyBzdG9yZXMgdGhlIG9yaWdpbmFsIHN0YXRlIG9mIHRoZSBwcm9wZXJ0eVxcblxcblxcdFxcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbiA9IG1peEZ1bmN0aW9uO1xcblxcblxcdFxcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IDA7XFxuXFxuXFx0XFx0dGhpcy51c2VDb3VudCA9IDA7XFxuXFx0XFx0dGhpcy5yZWZlcmVuY2VDb3VudCA9IDA7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIFByb3BlcnR5TWl4ZXIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0Ly8gYWNjdW11bGF0ZSBkYXRhIGluIHRoZSAnaW5jb21pbmcnIHJlZ2lvbiBpbnRvICdhY2N1PGk+J1xcblxcdFxcdGFjY3VtdWxhdGU6IGZ1bmN0aW9uICggYWNjdUluZGV4LCB3ZWlnaHQgKSB7XFxuXFxuXFx0XFx0XFx0Ly8gbm90ZTogaGFwcGlseSBhY2N1bXVsYXRpbmcgbm90aGluZyB3aGVuIHdlaWdodCA9IDAsIHRoZSBjYWxsZXIga25vd3NcXG5cXHRcXHRcXHQvLyB0aGUgd2VpZ2h0IGFuZCBzaG91bGRuJ3QgaGF2ZSBtYWRlIHRoZSBjYWxsIGluIHRoZSBmaXJzdCBwbGFjZVxcblxcblxcdFxcdFxcdHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcXG5cXHRcXHRcXHRcXHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcXG5cXHRcXHRcXHRcXHRvZmZzZXQgPSBhY2N1SW5kZXggKiBzdHJpZGUgKyBzdHJpZGUsXFxuXFxuXFx0XFx0XFx0XFx0Y3VycmVudFdlaWdodCA9IHRoaXMuY3VtdWxhdGl2ZVdlaWdodDtcXG5cXG5cXHRcXHRcXHRpZiAoIGN1cnJlbnRXZWlnaHQgPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gYWNjdU4gOj0gaW5jb21pbmcgKiB3ZWlnaHRcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRidWZmZXJbIG9mZnNldCArIGkgXSA9IGJ1ZmZlclsgaSBdO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRjdXJyZW50V2VpZ2h0ID0gd2VpZ2h0O1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gYWNjdU4gOj0gYWNjdU4gKyBpbmNvbWluZyAqIHdlaWdodFxcblxcblxcdFxcdFxcdFxcdGN1cnJlbnRXZWlnaHQgKz0gd2VpZ2h0O1xcblxcdFxcdFxcdFxcdHZhciBtaXggPSB3ZWlnaHQgLyBjdXJyZW50V2VpZ2h0O1xcblxcdFxcdFxcdFxcdHRoaXMuX21peEJ1ZmZlclJlZ2lvbiggYnVmZmVyLCBvZmZzZXQsIDAsIG1peCwgc3RyaWRlICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuY3VtdWxhdGl2ZVdlaWdodCA9IGN1cnJlbnRXZWlnaHQ7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBhcHBseSB0aGUgc3RhdGUgb2YgJ2FjY3U8aT4nIHRvIHRoZSBiaW5kaW5nIHdoZW4gYWNjdXMgZGlmZmVyXFxuXFx0XFx0YXBwbHk6IGZ1bmN0aW9uICggYWNjdUluZGV4ICkge1xcblxcblxcdFxcdFxcdHZhciBzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcXG5cXHRcXHRcXHRcXHRidWZmZXIgPSB0aGlzLmJ1ZmZlcixcXG5cXHRcXHRcXHRcXHRvZmZzZXQgPSBhY2N1SW5kZXggKiBzdHJpZGUgKyBzdHJpZGUsXFxuXFxuXFx0XFx0XFx0XFx0d2VpZ2h0ID0gdGhpcy5jdW11bGF0aXZlV2VpZ2h0LFxcblxcblxcdFxcdFxcdFxcdGJpbmRpbmcgPSB0aGlzLmJpbmRpbmc7XFxuXFxuXFx0XFx0XFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcXG5cXG5cXHRcXHRcXHRpZiAoIHdlaWdodCA8IDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gYWNjdU4gOj0gYWNjdU4gKyBvcmlnaW5hbCAqICggMSAtIGN1bXVsYXRpdmVXZWlnaHQgKVxcblxcblxcdFxcdFxcdFxcdHZhciBvcmlnaW5hbFZhbHVlT2Zmc2V0ID0gc3RyaWRlICogMztcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl9taXhCdWZmZXJSZWdpb24oXFxuXFx0XFx0XFx0XFx0XFx0YnVmZmVyLCBvZmZzZXQsIG9yaWdpbmFsVmFsdWVPZmZzZXQsIDEgLSB3ZWlnaHQsIHN0cmlkZSApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IHN0cmlkZSwgZSA9IHN0cmlkZSArIHN0cmlkZTsgaSAhPT0gZTsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGJ1ZmZlclsgaSBdICE9PSBidWZmZXJbIGkgKyBzdHJpZGUgXSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyB2YWx1ZSBoYXMgY2hhbmdlZCAtPiB1cGRhdGUgc2NlbmUgZ3JhcGhcXG5cXG5cXHRcXHRcXHRcXHRcXHRiaW5kaW5nLnNldFZhbHVlKCBidWZmZXIsIG9mZnNldCApO1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyByZW1lbWJlciB0aGUgc3RhdGUgb2YgdGhlIGJvdW5kIHByb3BlcnR5IGFuZCBjb3B5IGl0IHRvIGJvdGggYWNjdXNcXG5cXHRcXHRzYXZlT3JpZ2luYWxTdGF0ZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBiaW5kaW5nID0gdGhpcy5iaW5kaW5nO1xcblxcblxcdFxcdFxcdHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcixcXG5cXHRcXHRcXHRcXHRzdHJpZGUgPSB0aGlzLnZhbHVlU2l6ZSxcXG5cXG5cXHRcXHRcXHRcXHRvcmlnaW5hbFZhbHVlT2Zmc2V0ID0gc3RyaWRlICogMztcXG5cXG5cXHRcXHRcXHRiaW5kaW5nLmdldFZhbHVlKCBidWZmZXIsIG9yaWdpbmFsVmFsdWVPZmZzZXQgKTtcXG5cXG5cXHRcXHRcXHQvLyBhY2N1WzAuLjFdIDo9IG9yaWcgLS0gaW5pdGlhbGx5IGRldGVjdCBjaGFuZ2VzIGFnYWluc3QgdGhlIG9yaWdpbmFsXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSBzdHJpZGUsIGUgPSBvcmlnaW5hbFZhbHVlT2Zmc2V0OyBpICE9PSBlOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdGJ1ZmZlclsgaSBdID0gYnVmZmVyWyBvcmlnaW5hbFZhbHVlT2Zmc2V0ICsgKCBpICUgc3RyaWRlICkgXTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5jdW11bGF0aXZlV2VpZ2h0ID0gMDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIGFwcGx5IHRoZSBzdGF0ZSBwcmV2aW91c2x5IHRha2VuIHZpYSAnc2F2ZU9yaWdpbmFsU3RhdGUnIHRvIHRoZSBiaW5kaW5nXFxuXFx0XFx0cmVzdG9yZU9yaWdpbmFsU3RhdGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgb3JpZ2luYWxWYWx1ZU9mZnNldCA9IHRoaXMudmFsdWVTaXplICogMztcXG5cXHRcXHRcXHR0aGlzLmJpbmRpbmcuc2V0VmFsdWUoIHRoaXMuYnVmZmVyLCBvcmlnaW5hbFZhbHVlT2Zmc2V0ICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXG5cXHRcXHQvLyBtaXggZnVuY3Rpb25zXFxuXFxuXFx0XFx0X3NlbGVjdDogZnVuY3Rpb24gKCBidWZmZXIsIGRzdE9mZnNldCwgc3JjT2Zmc2V0LCB0LCBzdHJpZGUgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCB0ID49IDAuNSApIHtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IHN0cmlkZTsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRidWZmZXJbIGRzdE9mZnNldCArIGkgXSA9IGJ1ZmZlclsgc3JjT2Zmc2V0ICsgaSBdO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2xlcnA6IGZ1bmN0aW9uICggYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCApIHtcXG5cXG5cXHRcXHRcXHRRdWF0ZXJuaW9uLnNsZXJwRmxhdCggYnVmZmVyLCBkc3RPZmZzZXQsIGJ1ZmZlciwgZHN0T2Zmc2V0LCBidWZmZXIsIHNyY09mZnNldCwgdCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2xlcnA6IGZ1bmN0aW9uICggYnVmZmVyLCBkc3RPZmZzZXQsIHNyY09mZnNldCwgdCwgc3RyaWRlICkge1xcblxcblxcdFxcdFxcdHZhciBzID0gMSAtIHQ7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpICE9PSBzdHJpZGU7ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGogPSBkc3RPZmZzZXQgKyBpO1xcblxcblxcdFxcdFxcdFxcdGJ1ZmZlclsgaiBdID0gYnVmZmVyWyBqIF0gKiBzICsgYnVmZmVyWyBzcmNPZmZzZXQgKyBpIF0gKiB0O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqXFxuXFx0ICogQSByZWZlcmVuY2UgdG8gYSByZWFsIHByb3BlcnR5IGluIHRoZSBzY2VuZSBncmFwaC5cXG5cXHQgKlxcblxcdCAqXFxuXFx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cXG5cXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gQ29tcG9zaXRlKCB0YXJnZXRHcm91cCwgcGF0aCwgb3B0aW9uYWxQYXJzZWRQYXRoICkge1xcblxcblxcdFxcdHZhciBwYXJzZWRQYXRoID0gb3B0aW9uYWxQYXJzZWRQYXRoIHx8IFByb3BlcnR5QmluZGluZy5wYXJzZVRyYWNrTmFtZSggcGF0aCApO1xcblxcblxcdFxcdHRoaXMuX3RhcmdldEdyb3VwID0gdGFyZ2V0R3JvdXA7XFxuXFx0XFx0dGhpcy5fYmluZGluZ3MgPSB0YXJnZXRHcm91cC5zdWJzY3JpYmVfKCBwYXRoLCBwYXJzZWRQYXRoICk7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIENvbXBvc2l0ZS5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRnZXRWYWx1ZTogZnVuY3Rpb24gKCBhcnJheSwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdHRoaXMuYmluZCgpOyAvLyBiaW5kIGFsbCBiaW5kaW5nXFxuXFxuXFx0XFx0XFx0dmFyIGZpcnN0VmFsaWRJbmRleCA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxcXG5cXHRcXHRcXHRcXHRiaW5kaW5nID0gdGhpcy5fYmluZGluZ3NbIGZpcnN0VmFsaWRJbmRleCBdO1xcblxcblxcdFxcdFxcdC8vIGFuZCBvbmx5IGNhbGwgLmdldFZhbHVlIG9uIHRoZSBmaXJzdFxcblxcdFxcdFxcdGlmICggYmluZGluZyAhPT0gdW5kZWZpbmVkICkgYmluZGluZy5nZXRWYWx1ZSggYXJyYXksIG9mZnNldCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0VmFsdWU6IGZ1bmN0aW9uICggYXJyYXksIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxcXG5cXHRcXHRcXHRcXHRcXHQgIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YmluZGluZ3NbIGkgXS5zZXRWYWx1ZSggYXJyYXksIG9mZnNldCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGJpbmQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IHRoaXMuX3RhcmdldEdyb3VwLm5DYWNoZWRPYmplY3RzXyxcXG5cXHRcXHRcXHRcXHRcXHQgIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YmluZGluZ3NbIGkgXS5iaW5kKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3M7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSB0aGlzLl90YXJnZXRHcm91cC5uQ2FjaGVkT2JqZWN0c18sXFxuXFx0XFx0XFx0XFx0XFx0ICBuID0gYmluZGluZ3MubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdGJpbmRpbmdzWyBpIF0udW5iaW5kKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFxuXFx0ZnVuY3Rpb24gUHJvcGVydHlCaW5kaW5nKCByb290Tm9kZSwgcGF0aCwgcGFyc2VkUGF0aCApIHtcXG5cXG5cXHRcXHR0aGlzLnBhdGggPSBwYXRoO1xcblxcdFxcdHRoaXMucGFyc2VkUGF0aCA9IHBhcnNlZFBhdGggfHwgUHJvcGVydHlCaW5kaW5nLnBhcnNlVHJhY2tOYW1lKCBwYXRoICk7XFxuXFxuXFx0XFx0dGhpcy5ub2RlID0gUHJvcGVydHlCaW5kaW5nLmZpbmROb2RlKCByb290Tm9kZSwgdGhpcy5wYXJzZWRQYXRoLm5vZGVOYW1lICkgfHwgcm9vdE5vZGU7XFxuXFxuXFx0XFx0dGhpcy5yb290Tm9kZSA9IHJvb3ROb2RlO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBQcm9wZXJ0eUJpbmRpbmcsIHtcXG5cXG5cXHRcXHRDb21wb3NpdGU6IENvbXBvc2l0ZSxcXG5cXG5cXHRcXHRjcmVhdGU6IGZ1bmN0aW9uICggcm9vdCwgcGF0aCwgcGFyc2VkUGF0aCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoICEgKCByb290ICYmIHJvb3QuaXNBbmltYXRpb25PYmplY3RHcm91cCApICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBuZXcgUHJvcGVydHlCaW5kaW5nKCByb290LCBwYXRoLCBwYXJzZWRQYXRoICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gbmV3IFByb3BlcnR5QmluZGluZy5Db21wb3NpdGUoIHJvb3QsIHBhdGgsIHBhcnNlZFBhdGggKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvKipcXG5cXHRcXHQgKiBSZXBsYWNlcyBzcGFjZXMgd2l0aCB1bmRlcnNjb3JlcyBhbmQgcmVtb3ZlcyB1bnN1cHBvcnRlZCBjaGFyYWN0ZXJzIGZyb21cXG5cXHRcXHQgKiBub2RlIG5hbWVzLCB0byBlbnN1cmUgY29tcGF0aWJpbGl0eSB3aXRoIHBhcnNlVHJhY2tOYW1lKCkuXFxuXFx0XFx0ICpcXG5cXHRcXHQgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgTm9kZSBuYW1lIHRvIGJlIHNhbml0aXplZC5cXG5cXHRcXHQgKiBAcmV0dXJuIHtzdHJpbmd9XFxuXFx0XFx0ICovXFxuXFx0XFx0c2FuaXRpemVOb2RlTmFtZTogZnVuY3Rpb24gKCBuYW1lICkge1xcblxcblxcdFxcdFxcdHJldHVybiBuYW1lLnJlcGxhY2UoIC9cXFxccy9nLCAnXycgKS5yZXBsYWNlKCAvW15cXFxcdy1dL2csICcnICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRwYXJzZVRyYWNrTmFtZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdC8vIFBhcmVudCBkaXJlY3RvcmllcywgZGVsaW1pdGVkIGJ5ICcvJyBvciAnOicuIEN1cnJlbnRseSB1bnVzZWQsIGJ1dCBtdXN0XFxuXFx0XFx0XFx0Ly8gYmUgbWF0Y2hlZCB0byBwYXJzZSB0aGUgcmVzdCBvZiB0aGUgdHJhY2sgbmFtZS5cXG5cXHRcXHRcXHR2YXIgZGlyZWN0b3J5UmUgPSAvKCg/OltcXFxcdy1dK1tcXFxcLzpdKSopLztcXG5cXG5cXHRcXHRcXHQvLyBUYXJnZXQgbm9kZS4gTWF5IGNvbnRhaW4gd29yZCBjaGFyYWN0ZXJzIChhLXpBLVowLTlfKSBhbmQgJy4nIG9yICctJy5cXG5cXHRcXHRcXHR2YXIgbm9kZVJlID0gLyhbXFxcXHctXFxcXC5dKyk/LztcXG5cXG5cXHRcXHRcXHQvLyBPYmplY3Qgb24gdGFyZ2V0IG5vZGUsIGFuZCBhY2Nlc3Nvci4gTmFtZSBtYXkgY29udGFpbiBvbmx5IHdvcmRcXG5cXHRcXHRcXHQvLyBjaGFyYWN0ZXJzLiBBY2Nlc3NvciBtYXkgY29udGFpbiBhbnkgY2hhcmFjdGVyIGV4Y2VwdCBjbG9zaW5nIGJyYWNrZXQuXFxuXFx0XFx0XFx0dmFyIG9iamVjdFJlID0gLyg/OlxcXFwuKFtcXFxcdy1dKykoPzpcXFxcWyguKylcXFxcXSk/KT8vO1xcblxcblxcdFxcdFxcdC8vIFByb3BlcnR5IGFuZCBhY2Nlc3Nvci4gTWF5IGNvbnRhaW4gb25seSB3b3JkIGNoYXJhY3RlcnMuIEFjY2Vzc29yIG1heVxcblxcdFxcdFxcdC8vIGNvbnRhaW4gYW55IG5vbi1icmFja2V0IGNoYXJhY3RlcnMuXFxuXFx0XFx0XFx0dmFyIHByb3BlcnR5UmUgPSAvXFxcXC4oW1xcXFx3LV0rKSg/OlxcXFxbKC4rKVxcXFxdKT8vO1xcblxcblxcdFxcdFxcdHZhciB0cmFja1JlID0gbmV3IFJlZ0V4cCggJydcXG5cXHRcXHRcXHRcXHQrICdeJ1xcblxcdFxcdFxcdFxcdCsgZGlyZWN0b3J5UmUuc291cmNlXFxuXFx0XFx0XFx0XFx0KyBub2RlUmUuc291cmNlXFxuXFx0XFx0XFx0XFx0KyBvYmplY3RSZS5zb3VyY2VcXG5cXHRcXHRcXHRcXHQrIHByb3BlcnR5UmUuc291cmNlXFxuXFx0XFx0XFx0XFx0KyAnJCdcXG5cXHRcXHRcXHQpO1xcblxcblxcdFxcdFxcdHZhciBzdXBwb3J0ZWRPYmplY3ROYW1lcyA9IFsgJ21hdGVyaWFsJywgJ21hdGVyaWFscycsICdib25lcycgXTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gKCB0cmFja05hbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG1hdGNoZXMgPSB0cmFja1JlLmV4ZWMoIHRyYWNrTmFtZSApO1xcblxcblxcdFxcdFxcdFxcdGlmICggISBtYXRjaGVzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvciggJ1Byb3BlcnR5QmluZGluZzogQ2Fubm90IHBhcnNlIHRyYWNrTmFtZTogJyArIHRyYWNrTmFtZSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgcmVzdWx0cyA9IHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBkaXJlY3RvcnlOYW1lOiBtYXRjaGVzWyAxIF0sIC8vICh0c2NodykgY3VycmVudGx5IHVudXNlZFxcblxcdFxcdFxcdFxcdFxcdG5vZGVOYW1lOiBtYXRjaGVzWyAyIF0sXFxuXFx0XFx0XFx0XFx0XFx0b2JqZWN0TmFtZTogbWF0Y2hlc1sgMyBdLFxcblxcdFxcdFxcdFxcdFxcdG9iamVjdEluZGV4OiBtYXRjaGVzWyA0IF0sXFxuXFx0XFx0XFx0XFx0XFx0cHJvcGVydHlOYW1lOiBtYXRjaGVzWyA1IF0sIC8vIHJlcXVpcmVkXFxuXFx0XFx0XFx0XFx0XFx0cHJvcGVydHlJbmRleDogbWF0Y2hlc1sgNiBdXFxuXFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgbGFzdERvdCA9IHJlc3VsdHMubm9kZU5hbWUgJiYgcmVzdWx0cy5ub2RlTmFtZS5sYXN0SW5kZXhPZiggJy4nICk7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBsYXN0RG90ICE9PSB1bmRlZmluZWQgJiYgbGFzdERvdCAhPT0gLSAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBvYmplY3ROYW1lID0gcmVzdWx0cy5ub2RlTmFtZS5zdWJzdHJpbmcoIGxhc3REb3QgKyAxICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gT2JqZWN0IG5hbWVzIG11c3QgYmUgY2hlY2tlZCBhZ2FpbnN0IGEgd2hpdGVsaXN0LiBPdGhlcndpc2UsIHRoZXJlXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaXMgbm8gd2F5IHRvIHBhcnNlICdmb28uYmFyLmJheic6ICdiYXonIG11c3QgYmUgYSBwcm9wZXJ0eSwgYnV0XFxuXFx0XFx0XFx0XFx0XFx0Ly8gJ2JhcicgY291bGQgYmUgdGhlIG9iamVjdE5hbWUsIG9yIHBhcnQgb2YgYSBub2RlTmFtZSAod2hpY2ggY2FuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gaW5jbHVkZSAnLicgY2hhcmFjdGVycykuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBzdXBwb3J0ZWRPYmplY3ROYW1lcy5pbmRleE9mKCBvYmplY3ROYW1lICkgIT09IC0gMSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXN1bHRzLm5vZGVOYW1lID0gcmVzdWx0cy5ub2RlTmFtZS5zdWJzdHJpbmcoIDAsIGxhc3REb3QgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXN1bHRzLm9iamVjdE5hbWUgPSBvYmplY3ROYW1lO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCByZXN1bHRzLnByb3BlcnR5TmFtZSA9PT0gbnVsbCB8fCByZXN1bHRzLnByb3BlcnR5TmFtZS5sZW5ndGggPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCAnUHJvcGVydHlCaW5kaW5nOiBjYW4gbm90IHBhcnNlIHByb3BlcnR5TmFtZSBmcm9tIHRyYWNrTmFtZTogJyArIHRyYWNrTmFtZSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gcmVzdWx0cztcXG5cXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdH0oKSxcXG5cXG5cXHRcXHRmaW5kTm9kZTogZnVuY3Rpb24gKCByb290LCBub2RlTmFtZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoICEgbm9kZU5hbWUgfHwgbm9kZU5hbWUgPT09IFxcXCJcXFwiIHx8IG5vZGVOYW1lID09PSBcXFwicm9vdFxcXCIgfHwgbm9kZU5hbWUgPT09IFxcXCIuXFxcIiB8fCBub2RlTmFtZSA9PT0gLSAxIHx8IG5vZGVOYW1lID09PSByb290Lm5hbWUgfHwgbm9kZU5hbWUgPT09IHJvb3QudXVpZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gcm9vdDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gc2VhcmNoIGludG8gc2tlbGV0b24gYm9uZXMuXFxuXFx0XFx0XFx0aWYgKCByb290LnNrZWxldG9uICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBzZWFyY2hTa2VsZXRvbiA9IGZ1bmN0aW9uICggc2tlbGV0b24gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgc2tlbGV0b24uYm9uZXMubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBib25lID0gc2tlbGV0b24uYm9uZXNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGJvbmUubmFtZSA9PT0gbm9kZU5hbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIGJvbmU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdHZhciBib25lID0gc2VhcmNoU2tlbGV0b24oIHJvb3Quc2tlbGV0b24gKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGJvbmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGJvbmU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBzZWFyY2ggaW50byBub2RlIHN1YnRyZWUuXFxuXFx0XFx0XFx0aWYgKCByb290LmNoaWxkcmVuICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBzZWFyY2hOb2RlU3VidHJlZSA9IGZ1bmN0aW9uICggY2hpbGRyZW4gKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBjaGlsZE5vZGUgPSBjaGlsZHJlblsgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggY2hpbGROb2RlLm5hbWUgPT09IG5vZGVOYW1lIHx8IGNoaWxkTm9kZS51dWlkID09PSBub2RlTmFtZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gY2hpbGROb2RlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgcmVzdWx0ID0gc2VhcmNoTm9kZVN1YnRyZWUoIGNoaWxkTm9kZS5jaGlsZHJlbiApO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGlmICggcmVzdWx0ICkgcmV0dXJuIHJlc3VsdDtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFxuXFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgc3ViVHJlZU5vZGUgPSBzZWFyY2hOb2RlU3VidHJlZSggcm9vdC5jaGlsZHJlbiApO1xcblxcblxcdFxcdFxcdFxcdGlmICggc3ViVHJlZU5vZGUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHN1YlRyZWVOb2RlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuYXNzaWduKCBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLCB7IC8vIHByb3RvdHlwZSwgY29udGludWVkXFxuXFxuXFx0XFx0Ly8gdGhlc2UgYXJlIHVzZWQgdG8gXFxcImJpbmRcXFwiIGEgbm9uZXhpc3RlbnQgcHJvcGVydHlcXG5cXHRcXHRfZ2V0VmFsdWVfdW5hdmFpbGFibGU6IGZ1bmN0aW9uICgpIHt9LFxcblxcdFxcdF9zZXRWYWx1ZV91bmF2YWlsYWJsZTogZnVuY3Rpb24gKCkge30sXFxuXFxuXFx0XFx0QmluZGluZ1R5cGU6IHtcXG5cXHRcXHRcXHREaXJlY3Q6IDAsXFxuXFx0XFx0XFx0RW50aXJlQXJyYXk6IDEsXFxuXFx0XFx0XFx0QXJyYXlFbGVtZW50OiAyLFxcblxcdFxcdFxcdEhhc0Zyb21Ub0FycmF5OiAzXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRWZXJzaW9uaW5nOiB7XFxuXFx0XFx0XFx0Tm9uZTogMCxcXG5cXHRcXHRcXHROZWVkc1VwZGF0ZTogMSxcXG5cXHRcXHRcXHRNYXRyaXhXb3JsZE5lZWRzVXBkYXRlOiAyXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRHZXR0ZXJCeUJpbmRpbmdUeXBlOiBbXFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gZ2V0VmFsdWVfZGlyZWN0KCBidWZmZXIsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRcXHRidWZmZXJbIG9mZnNldCBdID0gdGhpcy5ub2RlWyB0aGlzLnByb3BlcnR5TmFtZSBdO1xcblxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gZ2V0VmFsdWVfYXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBzb3VyY2UgPSB0aGlzLnJlc29sdmVkUHJvcGVydHk7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gc291cmNlLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRidWZmZXJbIG9mZnNldCArKyBdID0gc291cmNlWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0ZnVuY3Rpb24gZ2V0VmFsdWVfYXJyYXlFbGVtZW50KCBidWZmZXIsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRcXHRidWZmZXJbIG9mZnNldCBdID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXTtcXG5cXG5cXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdGZ1bmN0aW9uIGdldFZhbHVlX3RvQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS50b0FycmF5KCBidWZmZXIsIG9mZnNldCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRdLFxcblxcblxcdFxcdFNldHRlckJ5QmluZGluZ1R5cGVBbmRWZXJzaW9uaW5nOiBbXFxuXFxuXFx0XFx0XFx0W1xcblxcdFxcdFxcdFxcdC8vIERpcmVjdFxcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIHNldFZhbHVlX2RpcmVjdCggYnVmZmVyLCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy50YXJnZXRPYmplY3RbIHRoaXMucHJvcGVydHlOYW1lIF0gPSBidWZmZXJbIG9mZnNldCBdO1xcblxcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gc2V0VmFsdWVfZGlyZWN0X3NldE5lZWRzVXBkYXRlKCBidWZmZXIsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRhcmdldE9iamVjdFsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gc2V0VmFsdWVfZGlyZWN0X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMudGFyZ2V0T2JqZWN0WyB0aGlzLnByb3BlcnR5TmFtZSBdID0gYnVmZmVyWyBvZmZzZXQgXTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnRhcmdldE9iamVjdC5tYXRyaXhXb3JsZE5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XSwgW1xcblxcblxcdFxcdFxcdFxcdC8vIEVudGlyZUFycmF5XFxuXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IGRlc3QubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGRlc3RbIGkgXSA9IGJ1ZmZlclsgb2Zmc2V0ICsrIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IGRlc3QubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGRlc3RbIGkgXSA9IGJ1ZmZlclsgb2Zmc2V0ICsrIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMudGFyZ2V0T2JqZWN0Lm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIHNldFZhbHVlX2FycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBkZXN0ID0gdGhpcy5yZXNvbHZlZFByb3BlcnR5O1xcblxcblxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IGRlc3QubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGRlc3RbIGkgXSA9IGJ1ZmZlclsgb2Zmc2V0ICsrIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRdLCBbXFxuXFxuXFx0XFx0XFx0XFx0Ly8gQXJyYXlFbGVtZW50XFxuXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlFbGVtZW50KCBidWZmZXIsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnJlc29sdmVkUHJvcGVydHlbIHRoaXMucHJvcGVydHlJbmRleCBdID0gYnVmZmVyWyBvZmZzZXQgXTtcXG5cXG5cXHRcXHRcXHRcXHR9LFxcblxcblxcdFxcdFxcdFxcdGZ1bmN0aW9uIHNldFZhbHVlX2FycmF5RWxlbWVudF9zZXROZWVkc1VwZGF0ZSggYnVmZmVyLCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5WyB0aGlzLnByb3BlcnR5SW5kZXggXSA9IGJ1ZmZlclsgb2Zmc2V0IF07XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gc2V0VmFsdWVfYXJyYXlFbGVtZW50X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eVsgdGhpcy5wcm9wZXJ0eUluZGV4IF0gPSBidWZmZXJbIG9mZnNldCBdO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMudGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRdLCBbXFxuXFxuXFx0XFx0XFx0XFx0Ly8gSGFzVG9Gcm9tQXJyYXlcXG5cXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBzZXRWYWx1ZV9mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XFxuXFxuXFx0XFx0XFx0XFx0fSxcXG5cXG5cXHRcXHRcXHRcXHRmdW5jdGlvbiBzZXRWYWx1ZV9mcm9tQXJyYXlfc2V0TmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy50YXJnZXRPYmplY3QubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdH0sXFxuXFxuXFx0XFx0XFx0XFx0ZnVuY3Rpb24gc2V0VmFsdWVfZnJvbUFycmF5X3NldE1hdHJpeFdvcmxkTmVlZHNVcGRhdGUoIGJ1ZmZlciwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eS5mcm9tQXJyYXkoIGJ1ZmZlciwgb2Zmc2V0ICk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy50YXJnZXRPYmplY3QubWF0cml4V29ybGROZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdF1cXG5cXG5cXHRcXHRdLFxcblxcblxcdFxcdGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZV91bmJvdW5kKCB0YXJnZXRBcnJheSwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdHRoaXMuYmluZCgpO1xcblxcdFxcdFxcdHRoaXMuZ2V0VmFsdWUoIHRhcmdldEFycmF5LCBvZmZzZXQgKTtcXG5cXG5cXHRcXHRcXHQvLyBOb3RlOiBUaGlzIGNsYXNzIHVzZXMgYSBTdGF0ZSBwYXR0ZXJuIG9uIGEgcGVyLW1ldGhvZCBiYXNpczpcXG5cXHRcXHRcXHQvLyAnYmluZCcgc2V0cyAndGhpcy5nZXRWYWx1ZScgLyAnc2V0VmFsdWUnIGFuZCBzaGFkb3dzIHRoZVxcblxcdFxcdFxcdC8vIHByb3RvdHlwZSB2ZXJzaW9uIG9mIHRoZXNlIG1ldGhvZHMgd2l0aCBvbmUgdGhhdCByZXByZXNlbnRzXFxuXFx0XFx0XFx0Ly8gdGhlIGJvdW5kIHN0YXRlLiBXaGVuIHRoZSBwcm9wZXJ0eSBpcyBub3QgZm91bmQsIHRoZSBtZXRob2RzXFxuXFx0XFx0XFx0Ly8gYmVjb21lIG5vLW9wcy5cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZV91bmJvdW5kKCBzb3VyY2VBcnJheSwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdHRoaXMuYmluZCgpO1xcblxcdFxcdFxcdHRoaXMuc2V0VmFsdWUoIHNvdXJjZUFycmF5LCBvZmZzZXQgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIGNyZWF0ZSBnZXR0ZXIgLyBzZXR0ZXIgcGFpciBmb3IgYSBwcm9wZXJ0eSBpbiB0aGUgc2NlbmUgZ3JhcGhcXG5cXHRcXHRiaW5kOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHRhcmdldE9iamVjdCA9IHRoaXMubm9kZSxcXG5cXHRcXHRcXHRcXHRwYXJzZWRQYXRoID0gdGhpcy5wYXJzZWRQYXRoLFxcblxcblxcdFxcdFxcdFxcdG9iamVjdE5hbWUgPSBwYXJzZWRQYXRoLm9iamVjdE5hbWUsXFxuXFx0XFx0XFx0XFx0cHJvcGVydHlOYW1lID0gcGFyc2VkUGF0aC5wcm9wZXJ0eU5hbWUsXFxuXFx0XFx0XFx0XFx0cHJvcGVydHlJbmRleCA9IHBhcnNlZFBhdGgucHJvcGVydHlJbmRleDtcXG5cXG5cXHRcXHRcXHRpZiAoICEgdGFyZ2V0T2JqZWN0ICkge1xcblxcblxcdFxcdFxcdFxcdHRhcmdldE9iamVjdCA9IFByb3BlcnR5QmluZGluZy5maW5kTm9kZSggdGhpcy5yb290Tm9kZSwgcGFyc2VkUGF0aC5ub2RlTmFtZSApIHx8IHRoaXMucm9vdE5vZGU7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5ub2RlID0gdGFyZ2V0T2JqZWN0O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBzZXQgZmFpbCBzdGF0ZSBzbyB3ZSBjYW4ganVzdCAncmV0dXJuJyBvbiBlcnJvclxcblxcdFxcdFxcdHRoaXMuZ2V0VmFsdWUgPSB0aGlzLl9nZXRWYWx1ZV91bmF2YWlsYWJsZTtcXG5cXHRcXHRcXHR0aGlzLnNldFZhbHVlID0gdGhpcy5fc2V0VmFsdWVfdW5hdmFpbGFibGU7XFxuXFxuXFx0XFx0XFx0Ly8gZW5zdXJlIHRoZXJlIGlzIGEgdmFsdWUgbm9kZVxcblxcdFxcdFxcdGlmICggISB0YXJnZXRPYmplY3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogVHJ5aW5nIHRvIHVwZGF0ZSBub2RlIGZvciB0cmFjazogJyArIHRoaXMucGF0aCArICcgYnV0IGl0IHdhc25cXFxcJ3QgZm91bmQuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBvYmplY3ROYW1lICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBvYmplY3RJbmRleCA9IHBhcnNlZFBhdGgub2JqZWN0SW5kZXg7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gc3BlY2lhbCBjYXNlcyB3ZXJlIHdlIG5lZWQgdG8gcmVhY2ggZGVlcGVyIGludG8gdGhlIGhpZXJhcmNoeSB0byBnZXQgdGhlIGZhY2UgbWF0ZXJpYWxzLi4uLlxcblxcdFxcdFxcdFxcdHN3aXRjaCAoIG9iamVjdE5hbWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y2FzZSAnbWF0ZXJpYWxzJzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoICEgdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBtYXRlcmlhbCBhcyBub2RlIGRvZXMgbm90IGhhdmUgYSBtYXRlcmlhbC4nLCB0aGlzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoICEgdGFyZ2V0T2JqZWN0Lm1hdGVyaWFsLm1hdGVyaWFscyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbWF0ZXJpYWwubWF0ZXJpYWxzIGFzIG5vZGUubWF0ZXJpYWwgZG9lcyBub3QgaGF2ZSBhIG1hdGVyaWFscyBhcnJheS4nLCB0aGlzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3QubWF0ZXJpYWwubWF0ZXJpYWxzO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGNhc2UgJ2JvbmVzJzpcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoICEgdGFyZ2V0T2JqZWN0LnNrZWxldG9uICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBib25lcyBhcyBub2RlIGRvZXMgbm90IGhhdmUgYSBza2VsZXRvbi4nLCB0aGlzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBwb3RlbnRpYWwgZnV0dXJlIG9wdGltaXphdGlvbjogc2tpcCB0aGlzIGlmIHByb3BlcnR5SW5kZXggaXMgYWxyZWFkeSBhbiBpbnRlZ2VyXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gYW5kIGNvbnZlcnQgdGhlIGludGVnZXIgc3RyaW5nIHRvIGEgdHJ1ZSBpbnRlZ2VyLlxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdC5za2VsZXRvbi5ib25lcztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBzdXBwb3J0IHJlc29sdmluZyBtb3JwaFRhcmdldCBuYW1lcyBpbnRvIGluZGljZXMuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwOyBpIDwgdGFyZ2V0T2JqZWN0Lmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHRhcmdldE9iamVjdFsgaSBdLm5hbWUgPT09IG9iamVjdEluZGV4ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdEluZGV4ID0gaTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRicmVhaztcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdGRlZmF1bHQ6XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0YXJnZXRPYmplY3RbIG9iamVjdE5hbWUgXSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9wZXJ0eUJpbmRpbmc6IENhbiBub3QgYmluZCB0byBvYmplY3ROYW1lIG9mIG5vZGUgdW5kZWZpbmVkLicsIHRoaXMgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRhcmdldE9iamVjdCA9IHRhcmdldE9iamVjdFsgb2JqZWN0TmFtZSBdO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIG9iamVjdEluZGV4ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCB0YXJnZXRPYmplY3RbIG9iamVjdEluZGV4IF0gPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBUcnlpbmcgdG8gYmluZCB0byBvYmplY3RJbmRleCBvZiBvYmplY3ROYW1lLCBidXQgaXMgdW5kZWZpbmVkLicsIHRoaXMsIHRhcmdldE9iamVjdCApO1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGFyZ2V0T2JqZWN0ID0gdGFyZ2V0T2JqZWN0WyBvYmplY3RJbmRleCBdO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gcmVzb2x2ZSBwcm9wZXJ0eVxcblxcdFxcdFxcdHZhciBub2RlUHJvcGVydHkgPSB0YXJnZXRPYmplY3RbIHByb3BlcnR5TmFtZSBdO1xcblxcblxcdFxcdFxcdGlmICggbm9kZVByb3BlcnR5ID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG5vZGVOYW1lID0gcGFyc2VkUGF0aC5ub2RlTmFtZTtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBUcnlpbmcgdG8gdXBkYXRlIHByb3BlcnR5IGZvciB0cmFjazogJyArIG5vZGVOYW1lICtcXG5cXHRcXHRcXHRcXHRcXHQnLicgKyBwcm9wZXJ0eU5hbWUgKyAnIGJ1dCBpdCB3YXNuXFxcXCd0IGZvdW5kLicsIHRhcmdldE9iamVjdCApO1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gZGV0ZXJtaW5lIHZlcnNpb25pbmcgc2NoZW1lXFxuXFx0XFx0XFx0dmFyIHZlcnNpb25pbmcgPSB0aGlzLlZlcnNpb25pbmcuTm9uZTtcXG5cXG5cXHRcXHRcXHRpZiAoIHRhcmdldE9iamVjdC5uZWVkc1VwZGF0ZSAhPT0gdW5kZWZpbmVkICkgeyAvLyBtYXRlcmlhbFxcblxcblxcdFxcdFxcdFxcdHZlcnNpb25pbmcgPSB0aGlzLlZlcnNpb25pbmcuTmVlZHNVcGRhdGU7XFxuXFx0XFx0XFx0XFx0dGhpcy50YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3Q7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggdGFyZ2V0T2JqZWN0Lm1hdHJpeFdvcmxkTmVlZHNVcGRhdGUgIT09IHVuZGVmaW5lZCApIHsgLy8gbm9kZSB0cmFuc2Zvcm1cXG5cXG5cXHRcXHRcXHRcXHR2ZXJzaW9uaW5nID0gdGhpcy5WZXJzaW9uaW5nLk1hdHJpeFdvcmxkTmVlZHNVcGRhdGU7XFxuXFx0XFx0XFx0XFx0dGhpcy50YXJnZXRPYmplY3QgPSB0YXJnZXRPYmplY3Q7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGRldGVybWluZSBob3cgdGhlIHByb3BlcnR5IGdldHMgYm91bmRcXG5cXHRcXHRcXHR2YXIgYmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkRpcmVjdDtcXG5cXG5cXHRcXHRcXHRpZiAoIHByb3BlcnR5SW5kZXggIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBhY2Nlc3MgYSBzdWIgZWxlbWVudCBvZiB0aGUgcHJvcGVydHkgYXJyYXkgKG9ubHkgcHJpbWl0aXZlcyBhcmUgc3VwcG9ydGVkIHJpZ2h0IG5vdylcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHByb3BlcnR5TmFtZSA9PT0gXFxcIm1vcnBoVGFyZ2V0SW5mbHVlbmNlc1xcXCIgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gcG90ZW50aWFsIG9wdGltaXphdGlvbiwgc2tpcCB0aGlzIGlmIHByb3BlcnR5SW5kZXggaXMgYWxyZWFkeSBhbiBpbnRlZ2VyLCBhbmQgY29udmVydCB0aGUgaW50ZWdlciBzdHJpbmcgdG8gYSB0cnVlIGludGVnZXIuXFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gc3VwcG9ydCByZXNvbHZpbmcgbW9ycGhUYXJnZXQgbmFtZXMgaW50byBpbmRpY2VzLlxcblxcdFxcdFxcdFxcdFxcdGlmICggISB0YXJnZXRPYmplY3QuZ2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBiZWNhdXNlIG5vZGUgZG9lcyBub3QgaGF2ZSBhIGdlb21ldHJ5LicsIHRoaXMgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCAhIHRhcmdldE9iamVjdC5nZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlByb3BlcnR5QmluZGluZzogQ2FuIG5vdCBiaW5kIHRvIG1vcnBoVGFyZ2V0SW5mbHVlbmNlcyBiZWNhdXNlIG5vZGUgZG9lcyBub3QgaGF2ZSBhIGdlb21ldHJ5Lm1vcnBoQXR0cmlidXRlcy4nLCB0aGlzICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCB0aGlzLm5vZGUuZ2VvbWV0cnkubW9ycGhBdHRyaWJ1dGVzLnBvc2l0aW9uLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHRhcmdldE9iamVjdC5nZW9tZXRyeS5tb3JwaEF0dHJpYnV0ZXMucG9zaXRpb25bIGkgXS5uYW1lID09PSBwcm9wZXJ0eUluZGV4ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdHByb3BlcnR5SW5kZXggPSBpO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoICEgdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoVGFyZ2V0cyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvcGVydHlCaW5kaW5nOiBDYW4gbm90IGJpbmQgdG8gbW9ycGhUYXJnZXRJbmZsdWVuY2VzIGJlY2F1c2Ugbm9kZSBkb2VzIG5vdCBoYXZlIGEgZ2VvbWV0cnkubW9ycGhUYXJnZXRzLicsIHRoaXMgKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IHRoaXMubm9kZS5nZW9tZXRyeS5tb3JwaFRhcmdldHMubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGlmICggdGFyZ2V0T2JqZWN0Lmdlb21ldHJ5Lm1vcnBoVGFyZ2V0c1sgaSBdLm5hbWUgPT09IHByb3BlcnR5SW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0cHJvcGVydHlJbmRleCA9IGk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5BcnJheUVsZW1lbnQ7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5yZXNvbHZlZFByb3BlcnR5ID0gbm9kZVByb3BlcnR5O1xcblxcdFxcdFxcdFxcdHRoaXMucHJvcGVydHlJbmRleCA9IHByb3BlcnR5SW5kZXg7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggbm9kZVByb3BlcnR5LmZyb21BcnJheSAhPT0gdW5kZWZpbmVkICYmIG5vZGVQcm9wZXJ0eS50b0FycmF5ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gbXVzdCB1c2UgY29weSBmb3IgT2JqZWN0M0QuRXVsZXIvUXVhdGVybmlvblxcblxcblxcdFxcdFxcdFxcdGJpbmRpbmdUeXBlID0gdGhpcy5CaW5kaW5nVHlwZS5IYXNGcm9tVG9BcnJheTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnJlc29sdmVkUHJvcGVydHkgPSBub2RlUHJvcGVydHk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggbm9kZVByb3BlcnR5ICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0YmluZGluZ1R5cGUgPSB0aGlzLkJpbmRpbmdUeXBlLkVudGlyZUFycmF5O1xcblxcblxcdFxcdFxcdFxcdHRoaXMucmVzb2x2ZWRQcm9wZXJ0eSA9IG5vZGVQcm9wZXJ0eTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHQvLyBzZWxlY3QgZ2V0dGVyIC8gc2V0dGVyXFxuXFx0XFx0XFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuR2V0dGVyQnlCaW5kaW5nVHlwZVsgYmluZGluZ1R5cGUgXTtcXG5cXHRcXHRcXHR0aGlzLnNldFZhbHVlID0gdGhpcy5TZXR0ZXJCeUJpbmRpbmdUeXBlQW5kVmVyc2lvbmluZ1sgYmluZGluZ1R5cGUgXVsgdmVyc2lvbmluZyBdO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0dW5iaW5kOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5ub2RlID0gbnVsbDtcXG5cXG5cXHRcXHRcXHQvLyBiYWNrIHRvIHRoZSBwcm90b3R5cGUgdmVyc2lvbiBvZiBnZXRWYWx1ZSAvIHNldFZhbHVlXFxuXFx0XFx0XFx0Ly8gbm90ZTogYXZvaWRpbmcgdG8gbXV0YXRlIHRoZSBzaGFwZSBvZiAndGhpcycgdmlhICdkZWxldGUnXFxuXFx0XFx0XFx0dGhpcy5nZXRWYWx1ZSA9IHRoaXMuX2dldFZhbHVlX3VuYm91bmQ7XFxuXFx0XFx0XFx0dGhpcy5zZXRWYWx1ZSA9IHRoaXMuX3NldFZhbHVlX3VuYm91bmQ7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvLyFcXFxcIERFQ0xBUkUgQUxJQVMgQUZURVIgYXNzaWduIHByb3RvdHlwZSAhXFxuXFx0T2JqZWN0LmFzc2lnbiggUHJvcGVydHlCaW5kaW5nLnByb3RvdHlwZSwge1xcblxcblxcdFxcdC8vIGluaXRpYWwgc3RhdGUgb2YgdGhlc2UgbWV0aG9kcyB0aGF0IGNhbGxzICdiaW5kJ1xcblxcdFxcdF9nZXRWYWx1ZV91bmJvdW5kOiBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLmdldFZhbHVlLFxcblxcdFxcdF9zZXRWYWx1ZV91bmJvdW5kOiBQcm9wZXJ0eUJpbmRpbmcucHJvdG90eXBlLnNldFZhbHVlLFxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKlxcblxcdCAqIEEgZ3JvdXAgb2Ygb2JqZWN0cyB0aGF0IHJlY2VpdmVzIGEgc2hhcmVkIGFuaW1hdGlvbiBzdGF0ZS5cXG5cXHQgKlxcblxcdCAqIFVzYWdlOlxcblxcdCAqXFxuXFx0ICogXFx0LVxcdEFkZCBvYmplY3RzIHlvdSB3b3VsZCBvdGhlcndpc2UgcGFzcyBhcyAncm9vdCcgdG8gdGhlXFxuXFx0ICogXFx0XFx0Y29uc3RydWN0b3Igb3IgdGhlIC5jbGlwQWN0aW9uIG1ldGhvZCBvZiBBbmltYXRpb25NaXhlci5cXG5cXHQgKlxcblxcdCAqIFxcdC1cXHRJbnN0ZWFkIHBhc3MgdGhpcyBvYmplY3QgYXMgJ3Jvb3QnLlxcblxcdCAqXFxuXFx0ICogXFx0LVxcdFlvdSBjYW4gYWxzbyBhZGQgYW5kIHJlbW92ZSBvYmplY3RzIGxhdGVyIHdoZW4gdGhlIG1peGVyXFxuXFx0ICogXFx0XFx0aXMgcnVubmluZy5cXG5cXHQgKlxcblxcdCAqIE5vdGU6XFxuXFx0ICpcXG5cXHQgKiAgXFx0T2JqZWN0cyBvZiB0aGlzIGNsYXNzIGFwcGVhciBhcyBvbmUgb2JqZWN0IHRvIHRoZSBtaXhlcixcXG5cXHQgKiAgXFx0c28gY2FjaGUgY29udHJvbCBvZiB0aGUgaW5kaXZpZHVhbCBvYmplY3RzIG11c3QgYmUgZG9uZVxcblxcdCAqICBcXHRvbiB0aGUgZ3JvdXAuXFxuXFx0ICpcXG5cXHQgKiBMaW1pdGF0aW9uOlxcblxcdCAqXFxuXFx0ICogXFx0LSBcXHRUaGUgYW5pbWF0ZWQgcHJvcGVydGllcyBtdXN0IGJlIGNvbXBhdGlibGUgYW1vbmcgdGhlXFxuXFx0ICogXFx0XFx0YWxsIG9iamVjdHMgaW4gdGhlIGdyb3VwLlxcblxcdCAqXFxuXFx0ICogIC1cXHRBIHNpbmdsZSBwcm9wZXJ0eSBjYW4gZWl0aGVyIGJlIGNvbnRyb2xsZWQgdGhyb3VnaCBhXFxuXFx0ICogIFxcdHRhcmdldCBncm91cCBvciBkaXJlY3RseSwgYnV0IG5vdCBib3RoLlxcblxcdCAqXFxuXFx0ICogQGF1dGhvciB0c2Nod1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEFuaW1hdGlvbk9iamVjdEdyb3VwKCkge1xcblxcblxcdFxcdHRoaXMudXVpZCA9IF9NYXRoLmdlbmVyYXRlVVVJRCgpO1xcblxcblxcdFxcdC8vIGNhY2hlZCBvYmplY3RzIGZvbGxvd2VkIGJ5IHRoZSBhY3RpdmUgb25lc1xcblxcdFxcdHRoaXMuX29iamVjdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XFxuXFxuXFx0XFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSAwO1xcdFxcdFxcdC8vIHRocmVzaG9sZFxcblxcdFxcdC8vIG5vdGU6IHJlYWQgYnkgUHJvcGVydHlCaW5kaW5nLkNvbXBvc2l0ZVxcblxcblxcdFxcdHZhciBpbmRpY2VzID0ge307XFxuXFx0XFx0dGhpcy5faW5kaWNlc0J5VVVJRCA9IGluZGljZXM7XFx0XFx0Ly8gZm9yIGJvb2trZWVwaW5nXFxuXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRpbmRpY2VzWyBhcmd1bWVudHNbIGkgXS51dWlkIF0gPSBpO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl9wYXRocyA9IFtdO1xcdFxcdFxcdFxcdFxcdC8vIGluc2lkZTogc3RyaW5nXFxuXFx0XFx0dGhpcy5fcGFyc2VkUGF0aHMgPSBbXTtcXHRcXHRcXHRcXHQvLyBpbnNpZGU6IHsgd2UgZG9uJ3QgY2FyZSwgaGVyZSB9XFxuXFx0XFx0dGhpcy5fYmluZGluZ3MgPSBbXTsgXFx0XFx0XFx0XFx0Ly8gaW5zaWRlOiBBcnJheTwgUHJvcGVydHlCaW5kaW5nID5cXG5cXHRcXHR0aGlzLl9iaW5kaW5nc0luZGljZXNCeVBhdGggPSB7fTsgXFx0Ly8gaW5zaWRlOiBpbmRpY2VzIGluIHRoZXNlIGFycmF5c1xcblxcblxcdFxcdHZhciBzY29wZSA9IHRoaXM7XFxuXFxuXFx0XFx0dGhpcy5zdGF0cyA9IHtcXG5cXG5cXHRcXHRcXHRvYmplY3RzOiB7XFxuXFx0XFx0XFx0XFx0Z2V0IHRvdGFsKCkge1xcblxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBzY29wZS5fb2JqZWN0cy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRcXHRnZXQgaW5Vc2UoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMudG90YWwgLSBzY29wZS5uQ2FjaGVkT2JqZWN0c187XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0Z2V0IGJpbmRpbmdzUGVyT2JqZWN0KCkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBzY29wZS5fYmluZGluZ3MubGVuZ3RoO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9O1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBBbmltYXRpb25PYmplY3RHcm91cC5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRpc0FuaW1hdGlvbk9iamVjdEdyb3VwOiB0cnVlLFxcblxcblxcdFxcdGFkZDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcXG5cXHRcXHRcXHRcXHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxcblxcdFxcdFxcdFxcdG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sXFxuXFx0XFx0XFx0XFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXFxuXFx0XFx0XFx0XFx0cGF0aHMgPSB0aGlzLl9wYXRocyxcXG5cXHRcXHRcXHRcXHRwYXJzZWRQYXRocyA9IHRoaXMuX3BhcnNlZFBhdGhzLFxcblxcdFxcdFxcdFxcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXFxuXFx0XFx0XFx0XFx0bkJpbmRpbmdzID0gYmluZGluZ3MubGVuZ3RoO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxcblxcdFxcdFxcdFxcdFxcdHV1aWQgPSBvYmplY3QudXVpZCxcXG5cXHRcXHRcXHRcXHRcXHRpbmRleCA9IGluZGljZXNCeVVVSURbIHV1aWQgXSxcXG5cXHRcXHRcXHRcXHRcXHRrbm93bk9iamVjdCA9IHVuZGVmaW5lZDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGluZGV4ID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8gdW5rbm93biBvYmplY3QgLT4gYWRkIGl0IHRvIHRoZSBBQ1RJVkUgcmVnaW9uXFxuXFxuXFx0XFx0XFx0XFx0XFx0aW5kZXggPSBuT2JqZWN0cyArKztcXG5cXHRcXHRcXHRcXHRcXHRpbmRpY2VzQnlVVUlEWyB1dWlkIF0gPSBpbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRvYmplY3RzLnB1c2goIG9iamVjdCApO1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YmluZGluZ3NbIGogXS5wdXNoKCBuZXcgUHJvcGVydHlCaW5kaW5nKCBvYmplY3QsIHBhdGhzWyBqIF0sIHBhcnNlZFBhdGhzWyBqIF0gKSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKCBpbmRleCA8IG5DYWNoZWRPYmplY3RzICkge1xcblxcblxcdFxcdFxcdFxcdFxcdGtub3duT2JqZWN0ID0gb2JqZWN0c1sgaW5kZXggXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBtb3ZlIGV4aXN0aW5nIG9iamVjdCB0byB0aGUgQUNUSVZFIHJlZ2lvblxcblxcblxcdFxcdFxcdFxcdFxcdHZhciBmaXJzdEFjdGl2ZUluZGV4ID0gLS0gbkNhY2hlZE9iamVjdHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0bGFzdENhY2hlZE9iamVjdCA9IG9iamVjdHNbIGZpcnN0QWN0aXZlSW5kZXggXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpbmRpY2VzQnlVVUlEWyBsYXN0Q2FjaGVkT2JqZWN0LnV1aWQgXSA9IGluZGV4O1xcblxcdFxcdFxcdFxcdFxcdG9iamVjdHNbIGluZGV4IF0gPSBsYXN0Q2FjaGVkT2JqZWN0O1xcblxcblxcdFxcdFxcdFxcdFxcdGluZGljZXNCeVVVSURbIHV1aWQgXSA9IGZpcnN0QWN0aXZlSW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0b2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdID0gb2JqZWN0O1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGFjY291bnRpbmcgaXMgZG9uZSwgbm93IGRvIHRoZSBzYW1lIGZvciBhbGwgYmluZGluZ3NcXG5cXG5cXHRcXHRcXHRcXHRcXHRmb3IgKCB2YXIgaiA9IDAsIG0gPSBuQmluZGluZ3M7IGogIT09IG07ICsrIGogKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGJpbmRpbmdzRm9yUGF0aCA9IGJpbmRpbmdzWyBqIF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bGFzdENhY2hlZCA9IGJpbmRpbmdzRm9yUGF0aFsgZmlyc3RBY3RpdmVJbmRleCBdLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJpbmRpbmcgPSBiaW5kaW5nc0ZvclBhdGhbIGluZGV4IF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gbGFzdENhY2hlZDtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGJpbmRpbmcgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBzaW5jZSB3ZSBkbyBub3QgYm90aGVyIHRvIGNyZWF0ZSBuZXcgYmluZGluZ3NcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBmb3Igb2JqZWN0cyB0aGF0IGFyZSBjYWNoZWQsIHRoZSBiaW5kaW5nIG1heVxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIG9yIG1heSBub3QgZXhpc3RcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiaW5kaW5nID0gbmV3IFByb3BlcnR5QmluZGluZyggb2JqZWN0LCBwYXRoc1sgaiBdLCBwYXJzZWRQYXRoc1sgaiBdICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJpbmRpbmdzRm9yUGF0aFsgZmlyc3RBY3RpdmVJbmRleCBdID0gYmluZGluZztcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICggb2JqZWN0c1sgaW5kZXggXSAhPT0ga25vd25PYmplY3QgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkFuaW1hdGlvbk9iamVjdEdyb3VwOiBEaWZmZXJlbnQgb2JqZWN0cyB3aXRoIHRoZSBzYW1lIFVVSUQgJyArXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0J2RldGVjdGVkLiBDbGVhbiB0aGUgY2FjaGVzIG9yIHJlY3JlYXRlIHlvdXIgaW5mcmFzdHJ1Y3R1cmUgd2hlbiByZWxvYWRpbmcgc2NlbmVzLicgKTtcXG5cXG5cXHRcXHRcXHRcXHR9IC8vIGVsc2UgdGhlIG9iamVjdCBpcyBhbHJlYWR5IHdoZXJlIHdlIHdhbnQgaXQgdG8gYmVcXG5cXG5cXHRcXHRcXHR9IC8vIGZvciBhcmd1bWVudHNcXG5cXG5cXHRcXHRcXHR0aGlzLm5DYWNoZWRPYmplY3RzXyA9IG5DYWNoZWRPYmplY3RzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0cmVtb3ZlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIG9iamVjdHMgPSB0aGlzLl9vYmplY3RzLFxcblxcdFxcdFxcdFxcdG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sXFxuXFx0XFx0XFx0XFx0aW5kaWNlc0J5VVVJRCA9IHRoaXMuX2luZGljZXNCeVVVSUQsXFxuXFx0XFx0XFx0XFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcXG5cXHRcXHRcXHRcXHRuQmluZGluZ3MgPSBiaW5kaW5ncy5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgb2JqZWN0ID0gYXJndW1lbnRzWyBpIF0sXFxuXFx0XFx0XFx0XFx0XFx0dXVpZCA9IG9iamVjdC51dWlkLFxcblxcdFxcdFxcdFxcdFxcdGluZGV4ID0gaW5kaWNlc0J5VVVJRFsgdXVpZCBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpbmRleCA+PSBuQ2FjaGVkT2JqZWN0cyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBtb3ZlIGV4aXN0aW5nIG9iamVjdCBpbnRvIHRoZSBDQUNIRUQgcmVnaW9uXFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGxhc3RDYWNoZWRJbmRleCA9IG5DYWNoZWRPYmplY3RzICsrLFxcblxcdFxcdFxcdFxcdFxcdFxcdGZpcnN0QWN0aXZlT2JqZWN0ID0gb2JqZWN0c1sgbGFzdENhY2hlZEluZGV4IF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aW5kaWNlc0J5VVVJRFsgZmlyc3RBY3RpdmVPYmplY3QudXVpZCBdID0gaW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0b2JqZWN0c1sgaW5kZXggXSA9IGZpcnN0QWN0aXZlT2JqZWN0O1xcblxcblxcdFxcdFxcdFxcdFxcdGluZGljZXNCeVVVSURbIHV1aWQgXSA9IGxhc3RDYWNoZWRJbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRvYmplY3RzWyBsYXN0Q2FjaGVkSW5kZXggXSA9IG9iamVjdDtcXG5cXG5cXHRcXHRcXHRcXHRcXHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHZhciBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1sgaiBdLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGZpcnN0QWN0aXZlID0gYmluZGluZ3NGb3JQYXRoWyBsYXN0Q2FjaGVkSW5kZXggXSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiaW5kaW5nID0gYmluZGluZ3NGb3JQYXRoWyBpbmRleCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGZpcnN0QWN0aXZlO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJpbmRpbmdzRm9yUGF0aFsgbGFzdENhY2hlZEluZGV4IF0gPSBiaW5kaW5nO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSAvLyBmb3IgYXJndW1lbnRzXFxuXFxuXFx0XFx0XFx0dGhpcy5uQ2FjaGVkT2JqZWN0c18gPSBuQ2FjaGVkT2JqZWN0cztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIHJlbW92ZSAmIGZvcmdldFxcblxcdFxcdHVuY2FjaGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgb2JqZWN0cyA9IHRoaXMuX29iamVjdHMsXFxuXFx0XFx0XFx0XFx0bk9iamVjdHMgPSBvYmplY3RzLmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRuQ2FjaGVkT2JqZWN0cyA9IHRoaXMubkNhY2hlZE9iamVjdHNfLFxcblxcdFxcdFxcdFxcdGluZGljZXNCeVVVSUQgPSB0aGlzLl9pbmRpY2VzQnlVVUlELFxcblxcdFxcdFxcdFxcdGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXFxuXFx0XFx0XFx0XFx0bkJpbmRpbmdzID0gYmluZGluZ3MubGVuZ3RoO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG9iamVjdCA9IGFyZ3VtZW50c1sgaSBdLFxcblxcdFxcdFxcdFxcdFxcdHV1aWQgPSBvYmplY3QudXVpZCxcXG5cXHRcXHRcXHRcXHRcXHRpbmRleCA9IGluZGljZXNCeVVVSURbIHV1aWQgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0ZGVsZXRlIGluZGljZXNCeVVVSURbIHV1aWQgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGluZGV4IDwgbkNhY2hlZE9iamVjdHMgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gb2JqZWN0IGlzIGNhY2hlZCwgc2hyaW5rIHRoZSBDQUNIRUQgcmVnaW9uXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIGZpcnN0QWN0aXZlSW5kZXggPSAtLSBuQ2FjaGVkT2JqZWN0cyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRsYXN0Q2FjaGVkT2JqZWN0ID0gb2JqZWN0c1sgZmlyc3RBY3RpdmVJbmRleCBdLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGxhc3RJbmRleCA9IC0tIG5PYmplY3RzLFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGxhc3RPYmplY3QgPSBvYmplY3RzWyBsYXN0SW5kZXggXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBsYXN0IGNhY2hlZCBvYmplY3QgdGFrZXMgdGhpcyBvYmplY3QncyBwbGFjZVxcblxcdFxcdFxcdFxcdFxcdFxcdGluZGljZXNCeVVVSURbIGxhc3RDYWNoZWRPYmplY3QudXVpZCBdID0gaW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RDYWNoZWRPYmplY3Q7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gbGFzdCBvYmplY3QgZ29lcyB0byB0aGUgYWN0aXZhdGVkIHNsb3QgYW5kIHBvcFxcblxcdFxcdFxcdFxcdFxcdFxcdGluZGljZXNCeVVVSURbIGxhc3RPYmplY3QudXVpZCBdID0gZmlyc3RBY3RpdmVJbmRleDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRvYmplY3RzWyBmaXJzdEFjdGl2ZUluZGV4IF0gPSBsYXN0T2JqZWN0O1xcblxcdFxcdFxcdFxcdFxcdFxcdG9iamVjdHMucG9wKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gYWNjb3VudGluZyBpcyBkb25lLCBub3cgZG8gdGhlIHNhbWUgZm9yIGFsbCBiaW5kaW5nc1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMCwgbSA9IG5CaW5kaW5nczsgaiAhPT0gbTsgKysgaiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR2YXIgYmluZGluZ3NGb3JQYXRoID0gYmluZGluZ3NbIGogXSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRcXHRsYXN0Q2FjaGVkID0gYmluZGluZ3NGb3JQYXRoWyBmaXJzdEFjdGl2ZUluZGV4IF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0XFx0bGFzdCA9IGJpbmRpbmdzRm9yUGF0aFsgbGFzdEluZGV4IF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YmluZGluZ3NGb3JQYXRoWyBpbmRleCBdID0gbGFzdENhY2hlZDtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRiaW5kaW5nc0ZvclBhdGhbIGZpcnN0QWN0aXZlSW5kZXggXSA9IGxhc3Q7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YmluZGluZ3NGb3JQYXRoLnBvcCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIG9iamVjdCBpcyBhY3RpdmUsIGp1c3Qgc3dhcCB3aXRoIHRoZSBsYXN0IGFuZCBwb3BcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgbGFzdEluZGV4ID0gLS0gbk9iamVjdHMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0bGFzdE9iamVjdCA9IG9iamVjdHNbIGxhc3RJbmRleCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGluZGljZXNCeVVVSURbIGxhc3RPYmplY3QudXVpZCBdID0gaW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0c1sgaW5kZXggXSA9IGxhc3RPYmplY3Q7XFxuXFx0XFx0XFx0XFx0XFx0XFx0b2JqZWN0cy5wb3AoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBhY2NvdW50aW5nIGlzIGRvbmUsIG5vdyBkbyB0aGUgc2FtZSBmb3IgYWxsIGJpbmRpbmdzXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwLCBtID0gbkJpbmRpbmdzOyBqICE9PSBtOyArKyBqICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHZhciBiaW5kaW5nc0ZvclBhdGggPSBiaW5kaW5nc1sgaiBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGJpbmRpbmdzRm9yUGF0aFsgaW5kZXggXSA9IGJpbmRpbmdzRm9yUGF0aFsgbGFzdEluZGV4IF07XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0YmluZGluZ3NGb3JQYXRoLnBvcCgpO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR9IC8vIGNhY2hlZCBvciBhY3RpdmVcXG5cXG5cXHRcXHRcXHRcXHR9IC8vIGlmIG9iamVjdCBpcyBrbm93blxcblxcblxcdFxcdFxcdH0gLy8gZm9yIGFyZ3VtZW50c1xcblxcblxcdFxcdFxcdHRoaXMubkNhY2hlZE9iamVjdHNfID0gbkNhY2hlZE9iamVjdHM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBJbnRlcm5hbCBpbnRlcmZhY2UgdXNlZCBieSBiZWZyaWVuZGVkIFByb3BlcnR5QmluZGluZy5Db21wb3NpdGU6XFxuXFxuXFx0XFx0c3Vic2NyaWJlXzogZnVuY3Rpb24gKCBwYXRoLCBwYXJzZWRQYXRoICkge1xcblxcblxcdFxcdFxcdC8vIHJldHVybnMgYW4gYXJyYXkgb2YgYmluZGluZ3MgZm9yIHRoZSBnaXZlbiBwYXRoIHRoYXQgaXMgY2hhbmdlZFxcblxcdFxcdFxcdC8vIGFjY29yZGluZyB0byB0aGUgY29udGFpbmVkIG9iamVjdHMgaW4gdGhlIGdyb3VwXFxuXFxuXFx0XFx0XFx0dmFyIGluZGljZXNCeVBhdGggPSB0aGlzLl9iaW5kaW5nc0luZGljZXNCeVBhdGgsXFxuXFx0XFx0XFx0XFx0aW5kZXggPSBpbmRpY2VzQnlQYXRoWyBwYXRoIF0sXFxuXFx0XFx0XFx0XFx0YmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncztcXG5cXG5cXHRcXHRcXHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSByZXR1cm4gYmluZGluZ3NbIGluZGV4IF07XFxuXFxuXFx0XFx0XFx0dmFyIHBhdGhzID0gdGhpcy5fcGF0aHMsXFxuXFx0XFx0XFx0XFx0cGFyc2VkUGF0aHMgPSB0aGlzLl9wYXJzZWRQYXRocyxcXG5cXHRcXHRcXHRcXHRvYmplY3RzID0gdGhpcy5fb2JqZWN0cyxcXG5cXHRcXHRcXHRcXHRuT2JqZWN0cyA9IG9iamVjdHMubGVuZ3RoLFxcblxcdFxcdFxcdFxcdG5DYWNoZWRPYmplY3RzID0gdGhpcy5uQ2FjaGVkT2JqZWN0c18sXFxuXFx0XFx0XFx0XFx0YmluZGluZ3NGb3JQYXRoID0gbmV3IEFycmF5KCBuT2JqZWN0cyApO1xcblxcblxcdFxcdFxcdGluZGV4ID0gYmluZGluZ3MubGVuZ3RoO1xcblxcblxcdFxcdFxcdGluZGljZXNCeVBhdGhbIHBhdGggXSA9IGluZGV4O1xcblxcblxcdFxcdFxcdHBhdGhzLnB1c2goIHBhdGggKTtcXG5cXHRcXHRcXHRwYXJzZWRQYXRocy5wdXNoKCBwYXJzZWRQYXRoICk7XFxuXFx0XFx0XFx0YmluZGluZ3MucHVzaCggYmluZGluZ3NGb3JQYXRoICk7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSBuQ2FjaGVkT2JqZWN0cywgbiA9IG9iamVjdHMubGVuZ3RoOyBpICE9PSBuOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBvYmplY3QgPSBvYmplY3RzWyBpIF07XFxuXFx0XFx0XFx0XFx0YmluZGluZ3NGb3JQYXRoWyBpIF0gPSBuZXcgUHJvcGVydHlCaW5kaW5nKCBvYmplY3QsIHBhdGgsIHBhcnNlZFBhdGggKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGJpbmRpbmdzRm9yUGF0aDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHVuc3Vic2NyaWJlXzogZnVuY3Rpb24gKCBwYXRoICkge1xcblxcblxcdFxcdFxcdC8vIHRlbGxzIHRoZSBncm91cCB0byBmb3JnZXQgYWJvdXQgYSBwcm9wZXJ0eSBwYXRoIGFuZCBubyBsb25nZXJcXG5cXHRcXHRcXHQvLyB1cGRhdGUgdGhlIGFycmF5IHByZXZpb3VzbHkgb2J0YWluZWQgd2l0aCAnc3Vic2NyaWJlXydcXG5cXG5cXHRcXHRcXHR2YXIgaW5kaWNlc0J5UGF0aCA9IHRoaXMuX2JpbmRpbmdzSW5kaWNlc0J5UGF0aCxcXG5cXHRcXHRcXHRcXHRpbmRleCA9IGluZGljZXNCeVBhdGhbIHBhdGggXTtcXG5cXG5cXHRcXHRcXHRpZiAoIGluZGV4ICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHBhdGhzID0gdGhpcy5fcGF0aHMsXFxuXFx0XFx0XFx0XFx0XFx0cGFyc2VkUGF0aHMgPSB0aGlzLl9wYXJzZWRQYXRocyxcXG5cXHRcXHRcXHRcXHRcXHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxcblxcdFxcdFxcdFxcdFxcdGxhc3RCaW5kaW5nc0luZGV4ID0gYmluZGluZ3MubGVuZ3RoIC0gMSxcXG5cXHRcXHRcXHRcXHRcXHRsYXN0QmluZGluZ3MgPSBiaW5kaW5nc1sgbGFzdEJpbmRpbmdzSW5kZXggXSxcXG5cXHRcXHRcXHRcXHRcXHRsYXN0QmluZGluZ3NQYXRoID0gcGF0aFsgbGFzdEJpbmRpbmdzSW5kZXggXTtcXG5cXG5cXHRcXHRcXHRcXHRpbmRpY2VzQnlQYXRoWyBsYXN0QmluZGluZ3NQYXRoIF0gPSBpbmRleDtcXG5cXG5cXHRcXHRcXHRcXHRiaW5kaW5nc1sgaW5kZXggXSA9IGxhc3RCaW5kaW5ncztcXG5cXHRcXHRcXHRcXHRiaW5kaW5ncy5wb3AoKTtcXG5cXG5cXHRcXHRcXHRcXHRwYXJzZWRQYXRoc1sgaW5kZXggXSA9IHBhcnNlZFBhdGhzWyBsYXN0QmluZGluZ3NJbmRleCBdO1xcblxcdFxcdFxcdFxcdHBhcnNlZFBhdGhzLnBvcCgpO1xcblxcblxcdFxcdFxcdFxcdHBhdGhzWyBpbmRleCBdID0gcGF0aHNbIGxhc3RCaW5kaW5nc0luZGV4IF07XFxuXFx0XFx0XFx0XFx0cGF0aHMucG9wKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICpcXG5cXHQgKiBBY3Rpb24gcHJvdmlkZWQgYnkgQW5pbWF0aW9uTWl4ZXIgZm9yIHNjaGVkdWxpbmcgY2xpcCBwbGF5YmFjayBvbiBzcGVjaWZpY1xcblxcdCAqIG9iamVjdHMuXFxuXFx0ICpcXG5cXHQgKiBAYXV0aG9yIEJlbiBIb3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvL1xcblxcdCAqIEBhdXRob3IgRGF2aWQgU2Fybm8gLyBodHRwOi8vbGlnaHRoYXVzLnVzL1xcblxcdCAqIEBhdXRob3IgdHNjaHdcXG5cXHQgKlxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEFuaW1hdGlvbkFjdGlvbiggbWl4ZXIsIGNsaXAsIGxvY2FsUm9vdCApIHtcXG5cXG5cXHRcXHR0aGlzLl9taXhlciA9IG1peGVyO1xcblxcdFxcdHRoaXMuX2NsaXAgPSBjbGlwO1xcblxcdFxcdHRoaXMuX2xvY2FsUm9vdCA9IGxvY2FsUm9vdCB8fCBudWxsO1xcblxcblxcdFxcdHZhciB0cmFja3MgPSBjbGlwLnRyYWNrcyxcXG5cXHRcXHRcXHRuVHJhY2tzID0gdHJhY2tzLmxlbmd0aCxcXG5cXHRcXHRcXHRpbnRlcnBvbGFudHMgPSBuZXcgQXJyYXkoIG5UcmFja3MgKTtcXG5cXG5cXHRcXHR2YXIgaW50ZXJwb2xhbnRTZXR0aW5ncyA9IHtcXG5cXHRcXHRcXHRlbmRpbmdTdGFydDogWmVyb0N1cnZhdHVyZUVuZGluZyxcXG5cXHRcXHRcXHRlbmRpbmdFbmQ6IFplcm9DdXJ2YXR1cmVFbmRpbmdcXG5cXHRcXHR9O1xcblxcblxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gblRyYWNrczsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgaW50ZXJwb2xhbnQgPSB0cmFja3NbIGkgXS5jcmVhdGVJbnRlcnBvbGFudCggbnVsbCApO1xcblxcdFxcdFxcdGludGVycG9sYW50c1sgaSBdID0gaW50ZXJwb2xhbnQ7XFxuXFx0XFx0XFx0aW50ZXJwb2xhbnQuc2V0dGluZ3MgPSBpbnRlcnBvbGFudFNldHRpbmdzO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl9pbnRlcnBvbGFudFNldHRpbmdzID0gaW50ZXJwb2xhbnRTZXR0aW5ncztcXG5cXG5cXHRcXHR0aGlzLl9pbnRlcnBvbGFudHMgPSBpbnRlcnBvbGFudHM7XFx0Ly8gYm91bmQgYnkgdGhlIG1peGVyXFxuXFxuXFx0XFx0Ly8gaW5zaWRlOiBQcm9wZXJ0eU1peGVyIChtYW5hZ2VkIGJ5IHRoZSBtaXhlcilcXG5cXHRcXHR0aGlzLl9wcm9wZXJ0eUJpbmRpbmdzID0gbmV3IEFycmF5KCBuVHJhY2tzICk7XFxuXFxuXFx0XFx0dGhpcy5fY2FjaGVJbmRleCA9IG51bGw7XFx0XFx0XFx0Ly8gZm9yIHRoZSBtZW1vcnkgbWFuYWdlclxcblxcdFxcdHRoaXMuX2J5Q2xpcENhY2hlSW5kZXggPSBudWxsO1xcdFxcdC8vIGZvciB0aGUgbWVtb3J5IG1hbmFnZXJcXG5cXG5cXHRcXHR0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudCA9IG51bGw7XFxuXFx0XFx0dGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQgPSBudWxsO1xcblxcblxcdFxcdHRoaXMubG9vcCA9IExvb3BSZXBlYXQ7XFxuXFx0XFx0dGhpcy5fbG9vcENvdW50ID0gLSAxO1xcblxcblxcdFxcdC8vIGdsb2JhbCBtaXhlciB0aW1lIHdoZW4gdGhlIGFjdGlvbiBpcyB0byBiZSBzdGFydGVkXFxuXFx0XFx0Ly8gaXQncyBzZXQgYmFjayB0byAnbnVsbCcgdXBvbiBzdGFydCBvZiB0aGUgYWN0aW9uXFxuXFx0XFx0dGhpcy5fc3RhcnRUaW1lID0gbnVsbDtcXG5cXG5cXHRcXHQvLyBzY2FsZWQgbG9jYWwgdGltZSBvZiB0aGUgYWN0aW9uXFxuXFx0XFx0Ly8gZ2V0cyBjbGFtcGVkIG9yIHdyYXBwZWQgdG8gMC4uY2xpcC5kdXJhdGlvbiBhY2NvcmRpbmcgdG8gbG9vcFxcblxcdFxcdHRoaXMudGltZSA9IDA7XFxuXFxuXFx0XFx0dGhpcy50aW1lU2NhbGUgPSAxO1xcblxcdFxcdHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSA9IDE7XFxuXFxuXFx0XFx0dGhpcy53ZWlnaHQgPSAxO1xcblxcdFxcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IDE7XFxuXFxuXFx0XFx0dGhpcy5yZXBldGl0aW9ucyA9IEluZmluaXR5OyBcXHRcXHQvLyBuby4gb2YgcmVwZXRpdGlvbnMgd2hlbiBsb29waW5nXFxuXFxuXFx0XFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcXHRcXHRcXHRcXHQvLyB0cnVlIC0+IHplcm8gZWZmZWN0aXZlIHRpbWUgc2NhbGVcXG5cXHRcXHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xcdFxcdFxcdFxcdC8vIGZhbHNlIC0+IHplcm8gZWZmZWN0aXZlIHdlaWdodFxcblxcblxcdFxcdHRoaXMuY2xhbXBXaGVuRmluaXNoZWQgXFx0PSBmYWxzZTtcXHQvLyBrZWVwIGZlZWRpbmcgdGhlIGxhc3QgZnJhbWU/XFxuXFxuXFx0XFx0dGhpcy56ZXJvU2xvcGVBdFN0YXJ0IFxcdD0gdHJ1ZTtcXHRcXHQvLyBmb3Igc21vb3RoIGludGVycG9sYXRpb24gdy9vIHNlcGFyYXRlXFxuXFx0XFx0dGhpcy56ZXJvU2xvcGVBdEVuZFxcdFxcdD0gdHJ1ZTtcXHRcXHQvLyBjbGlwcyBmb3Igc3RhcnQsIGxvb3AgYW5kIGVuZFxcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBBbmltYXRpb25BY3Rpb24ucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0Ly8gU3RhdGUgJiBTY2hlZHVsaW5nXFxuXFxuXFx0XFx0cGxheTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMuX21peGVyLl9hY3RpdmF0ZUFjdGlvbiggdGhpcyApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3RvcDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMuX21peGVyLl9kZWFjdGl2YXRlQWN0aW9uKCB0aGlzICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMucmVzZXQoKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHJlc2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5wYXVzZWQgPSBmYWxzZTtcXG5cXHRcXHRcXHR0aGlzLmVuYWJsZWQgPSB0cnVlO1xcblxcblxcdFxcdFxcdHRoaXMudGltZSA9IDA7XFx0XFx0XFx0Ly8gcmVzdGFydCBjbGlwXFxuXFx0XFx0XFx0dGhpcy5fbG9vcENvdW50ID0gLSAxO1xcdC8vIGZvcmdldCBwcmV2aW91cyBsb29wc1xcblxcdFxcdFxcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7XFx0Ly8gZm9yZ2V0IHNjaGVkdWxpbmdcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5zdG9wRmFkaW5nKCkuc3RvcFdhcnBpbmcoKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGlzUnVubmluZzogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmVuYWJsZWQgJiYgISB0aGlzLnBhdXNlZCAmJiB0aGlzLnRpbWVTY2FsZSAhPT0gMCAmJlxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3N0YXJ0VGltZSA9PT0gbnVsbCAmJiB0aGlzLl9taXhlci5faXNBY3RpdmVBY3Rpb24oIHRoaXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIHJldHVybiB0cnVlIHdoZW4gcGxheSBoYXMgYmVlbiBjYWxsZWRcXG5cXHRcXHRpc1NjaGVkdWxlZDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLl9taXhlci5faXNBY3RpdmVBY3Rpb24oIHRoaXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHN0YXJ0QXQ6IGZ1bmN0aW9uICggdGltZSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLl9zdGFydFRpbWUgPSB0aW1lO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0TG9vcDogZnVuY3Rpb24gKCBtb2RlLCByZXBldGl0aW9ucyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmxvb3AgPSBtb2RlO1xcblxcdFxcdFxcdHRoaXMucmVwZXRpdGlvbnMgPSByZXBldGl0aW9ucztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIFdlaWdodFxcblxcblxcdFxcdC8vIHNldCB0aGUgd2VpZ2h0IHN0b3BwaW5nIGFueSBzY2hlZHVsZWQgZmFkaW5nXFxuXFx0XFx0Ly8gYWx0aG91Z2ggLmVuYWJsZWQgPSBmYWxzZSB5aWVsZHMgYW4gZWZmZWN0aXZlIHdlaWdodCBvZiB6ZXJvLCB0aGlzXFxuXFx0XFx0Ly8gbWV0aG9kIGRvZXMgKm5vdCogY2hhbmdlIC5lbmFibGVkLCBiZWNhdXNlIGl0IHdvdWxkIGJlIGNvbmZ1c2luZ1xcblxcdFxcdHNldEVmZmVjdGl2ZVdlaWdodDogZnVuY3Rpb24gKCB3ZWlnaHQgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy53ZWlnaHQgPSB3ZWlnaHQ7XFxuXFxuXFx0XFx0XFx0Ly8gbm90ZTogc2FtZSBsb2dpYyBhcyB3aGVuIHVwZGF0ZWQgYXQgcnVudGltZVxcblxcdFxcdFxcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IHRoaXMuZW5hYmxlZCA/IHdlaWdodCA6IDA7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuc3RvcEZhZGluZygpO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gcmV0dXJuIHRoZSB3ZWlnaHQgY29uc2lkZXJpbmcgZmFkaW5nIGFuZCAuZW5hYmxlZFxcblxcdFxcdGdldEVmZmVjdGl2ZVdlaWdodDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLl9lZmZlY3RpdmVXZWlnaHQ7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRmYWRlSW46IGZ1bmN0aW9uICggZHVyYXRpb24gKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX3NjaGVkdWxlRmFkaW5nKCBkdXJhdGlvbiwgMCwgMSApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZmFkZU91dDogZnVuY3Rpb24gKCBkdXJhdGlvbiApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fc2NoZWR1bGVGYWRpbmcoIGR1cmF0aW9uLCAxLCAwICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjcm9zc0ZhZGVGcm9tOiBmdW5jdGlvbiAoIGZhZGVPdXRBY3Rpb24sIGR1cmF0aW9uLCB3YXJwICkge1xcblxcblxcdFxcdFxcdGZhZGVPdXRBY3Rpb24uZmFkZU91dCggZHVyYXRpb24gKTtcXG5cXHRcXHRcXHR0aGlzLmZhZGVJbiggZHVyYXRpb24gKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHdhcnAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGZhZGVJbkR1cmF0aW9uID0gdGhpcy5fY2xpcC5kdXJhdGlvbixcXG5cXHRcXHRcXHRcXHRcXHRmYWRlT3V0RHVyYXRpb24gPSBmYWRlT3V0QWN0aW9uLl9jbGlwLmR1cmF0aW9uLFxcblxcblxcdFxcdFxcdFxcdFxcdHN0YXJ0RW5kUmF0aW8gPSBmYWRlT3V0RHVyYXRpb24gLyBmYWRlSW5EdXJhdGlvbixcXG5cXHRcXHRcXHRcXHRcXHRlbmRTdGFydFJhdGlvID0gZmFkZUluRHVyYXRpb24gLyBmYWRlT3V0RHVyYXRpb247XFxuXFxuXFx0XFx0XFx0XFx0ZmFkZU91dEFjdGlvbi53YXJwKCAxLjAsIHN0YXJ0RW5kUmF0aW8sIGR1cmF0aW9uICk7XFxuXFx0XFx0XFx0XFx0dGhpcy53YXJwKCBlbmRTdGFydFJhdGlvLCAxLjAsIGR1cmF0aW9uICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y3Jvc3NGYWRlVG86IGZ1bmN0aW9uICggZmFkZUluQWN0aW9uLCBkdXJhdGlvbiwgd2FycCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gZmFkZUluQWN0aW9uLmNyb3NzRmFkZUZyb20oIHRoaXMsIGR1cmF0aW9uLCB3YXJwICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzdG9wRmFkaW5nOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHdlaWdodEludGVycG9sYW50ID0gdGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQ7XFxuXFxuXFx0XFx0XFx0aWYgKCB3ZWlnaHRJbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLl93ZWlnaHRJbnRlcnBvbGFudCA9IG51bGw7XFxuXFx0XFx0XFx0XFx0dGhpcy5fbWl4ZXIuX3Rha2VCYWNrQ29udHJvbEludGVycG9sYW50KCB3ZWlnaHRJbnRlcnBvbGFudCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIFRpbWUgU2NhbGUgQ29udHJvbFxcblxcblxcdFxcdC8vIHNldCB0aGUgdGltZSBzY2FsZSBzdG9wcGluZyBhbnkgc2NoZWR1bGVkIHdhcnBpbmdcXG5cXHRcXHQvLyBhbHRob3VnaCAucGF1c2VkID0gdHJ1ZSB5aWVsZHMgYW4gZWZmZWN0aXZlIHRpbWUgc2NhbGUgb2YgemVybywgdGhpc1xcblxcdFxcdC8vIG1ldGhvZCBkb2VzICpub3QqIGNoYW5nZSAucGF1c2VkLCBiZWNhdXNlIGl0IHdvdWxkIGJlIGNvbmZ1c2luZ1xcblxcdFxcdHNldEVmZmVjdGl2ZVRpbWVTY2FsZTogZnVuY3Rpb24gKCB0aW1lU2NhbGUgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy50aW1lU2NhbGUgPSB0aW1lU2NhbGU7XFxuXFx0XFx0XFx0dGhpcy5fZWZmZWN0aXZlVGltZVNjYWxlID0gdGhpcy5wYXVzZWQgPyAwIDogdGltZVNjYWxlO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLnN0b3BXYXJwaW5nKCk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyByZXR1cm4gdGhlIHRpbWUgc2NhbGUgY29uc2lkZXJpbmcgd2FycGluZyBhbmQgLnBhdXNlZFxcblxcdFxcdGdldEVmZmVjdGl2ZVRpbWVTY2FsZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGU7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXREdXJhdGlvbjogZnVuY3Rpb24gKCBkdXJhdGlvbiApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnRpbWVTY2FsZSA9IHRoaXMuX2NsaXAuZHVyYXRpb24gLyBkdXJhdGlvbjtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3luY1dpdGg6IGZ1bmN0aW9uICggYWN0aW9uICkge1xcblxcblxcdFxcdFxcdHRoaXMudGltZSA9IGFjdGlvbi50aW1lO1xcblxcdFxcdFxcdHRoaXMudGltZVNjYWxlID0gYWN0aW9uLnRpbWVTY2FsZTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5zdG9wV2FycGluZygpO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0aGFsdDogZnVuY3Rpb24gKCBkdXJhdGlvbiApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy53YXJwKCB0aGlzLl9lZmZlY3RpdmVUaW1lU2NhbGUsIDAsIGR1cmF0aW9uICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHR3YXJwOiBmdW5jdGlvbiAoIHN0YXJ0VGltZVNjYWxlLCBlbmRUaW1lU2NhbGUsIGR1cmF0aW9uICkge1xcblxcblxcdFxcdFxcdHZhciBtaXhlciA9IHRoaXMuX21peGVyLCBub3cgPSBtaXhlci50aW1lLFxcblxcdFxcdFxcdFxcdGludGVycG9sYW50ID0gdGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQsXFxuXFxuXFx0XFx0XFx0XFx0dGltZVNjYWxlID0gdGhpcy50aW1lU2NhbGU7XFxuXFxuXFx0XFx0XFx0aWYgKCBpbnRlcnBvbGFudCA9PT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRpbnRlcnBvbGFudCA9IG1peGVyLl9sZW5kQ29udHJvbEludGVycG9sYW50KCk7XFxuXFx0XFx0XFx0XFx0dGhpcy5fdGltZVNjYWxlSW50ZXJwb2xhbnQgPSBpbnRlcnBvbGFudDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dmFyIHRpbWVzID0gaW50ZXJwb2xhbnQucGFyYW1ldGVyUG9zaXRpb25zLFxcblxcdFxcdFxcdFxcdHZhbHVlcyA9IGludGVycG9sYW50LnNhbXBsZVZhbHVlcztcXG5cXG5cXHRcXHRcXHR0aW1lc1sgMCBdID0gbm93O1xcblxcdFxcdFxcdHRpbWVzWyAxIF0gPSBub3cgKyBkdXJhdGlvbjtcXG5cXG5cXHRcXHRcXHR2YWx1ZXNbIDAgXSA9IHN0YXJ0VGltZVNjYWxlIC8gdGltZVNjYWxlO1xcblxcdFxcdFxcdHZhbHVlc1sgMSBdID0gZW5kVGltZVNjYWxlIC8gdGltZVNjYWxlO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3RvcFdhcnBpbmc6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdGltZVNjYWxlSW50ZXJwb2xhbnQgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudDtcXG5cXG5cXHRcXHRcXHRpZiAoIHRpbWVTY2FsZUludGVycG9sYW50ICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX3RpbWVTY2FsZUludGVycG9sYW50ID0gbnVsbDtcXG5cXHRcXHRcXHRcXHR0aGlzLl9taXhlci5fdGFrZUJhY2tDb250cm9sSW50ZXJwb2xhbnQoIHRpbWVTY2FsZUludGVycG9sYW50ICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gT2JqZWN0IEFjY2Vzc29yc1xcblxcblxcdFxcdGdldE1peGVyOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX21peGVyO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0Q2xpcDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLl9jbGlwO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0Um9vdDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLl9sb2NhbFJvb3QgfHwgdGhpcy5fbWl4ZXIuX3Jvb3Q7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBJbnRlcm5hXFxuXFxuXFx0XFx0X3VwZGF0ZTogZnVuY3Rpb24gKCB0aW1lLCBkZWx0YVRpbWUsIHRpbWVEaXJlY3Rpb24sIGFjY3VJbmRleCApIHtcXG5cXG5cXHRcXHRcXHQvLyBjYWxsZWQgYnkgdGhlIG1peGVyXFxuXFxuXFx0XFx0XFx0aWYgKCAhIHRoaXMuZW5hYmxlZCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBjYWxsIC5fdXBkYXRlV2VpZ2h0KCkgdG8gdXBkYXRlIC5fZWZmZWN0aXZlV2VpZ2h0XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5fdXBkYXRlV2VpZ2h0KCB0aW1lICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR2YXIgc3RhcnRUaW1lID0gdGhpcy5fc3RhcnRUaW1lO1xcblxcblxcdFxcdFxcdGlmICggc3RhcnRUaW1lICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdC8vIGNoZWNrIGZvciBzY2hlZHVsZWQgc3RhcnQgb2YgYWN0aW9uXFxuXFxuXFx0XFx0XFx0XFx0dmFyIHRpbWVSdW5uaW5nID0gKCB0aW1lIC0gc3RhcnRUaW1lICkgKiB0aW1lRGlyZWN0aW9uO1xcblxcdFxcdFxcdFxcdGlmICggdGltZVJ1bm5pbmcgPCAwIHx8IHRpbWVEaXJlY3Rpb24gPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuOyAvLyB5ZXQgdG8gY29tZSAvIGRvbid0IGRlY2lkZSB3aGVuIGRlbHRhID0gMFxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyBzdGFydFxcblxcblxcdFxcdFxcdFxcdHRoaXMuX3N0YXJ0VGltZSA9IG51bGw7IC8vIHVuc2NoZWR1bGVcXG5cXHRcXHRcXHRcXHRkZWx0YVRpbWUgPSB0aW1lRGlyZWN0aW9uICogdGltZVJ1bm5pbmc7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdC8vIGFwcGx5IHRpbWUgc2NhbGUgYW5kIGFkdmFuY2UgdGltZVxcblxcblxcdFxcdFxcdGRlbHRhVGltZSAqPSB0aGlzLl91cGRhdGVUaW1lU2NhbGUoIHRpbWUgKTtcXG5cXHRcXHRcXHR2YXIgY2xpcFRpbWUgPSB0aGlzLl91cGRhdGVUaW1lKCBkZWx0YVRpbWUgKTtcXG5cXG5cXHRcXHRcXHQvLyBub3RlOiBfdXBkYXRlVGltZSBtYXkgZGlzYWJsZSB0aGUgYWN0aW9uIHJlc3VsdGluZyBpblxcblxcdFxcdFxcdC8vIGFuIGVmZmVjdGl2ZSB3ZWlnaHQgb2YgMFxcblxcblxcdFxcdFxcdHZhciB3ZWlnaHQgPSB0aGlzLl91cGRhdGVXZWlnaHQoIHRpbWUgKTtcXG5cXG5cXHRcXHRcXHRpZiAoIHdlaWdodCA+IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGludGVycG9sYW50cyA9IHRoaXMuX2ludGVycG9sYW50cztcXG5cXHRcXHRcXHRcXHR2YXIgcHJvcGVydHlNaXhlcnMgPSB0aGlzLl9wcm9wZXJ0eUJpbmRpbmdzO1xcblxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBqID0gMCwgbSA9IGludGVycG9sYW50cy5sZW5ndGg7IGogIT09IG07ICsrIGogKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aW50ZXJwb2xhbnRzWyBqIF0uZXZhbHVhdGUoIGNsaXBUaW1lICk7XFxuXFx0XFx0XFx0XFx0XFx0cHJvcGVydHlNaXhlcnNbIGogXS5hY2N1bXVsYXRlKCBhY2N1SW5kZXgsIHdlaWdodCApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfdXBkYXRlV2VpZ2h0OiBmdW5jdGlvbiAoIHRpbWUgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHdlaWdodCA9IDA7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmVuYWJsZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0d2VpZ2h0ID0gdGhpcy53ZWlnaHQ7XFxuXFx0XFx0XFx0XFx0dmFyIGludGVycG9sYW50ID0gdGhpcy5fd2VpZ2h0SW50ZXJwb2xhbnQ7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBpbnRlcnBvbGFudCAhPT0gbnVsbCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgaW50ZXJwb2xhbnRWYWx1ZSA9IGludGVycG9sYW50LmV2YWx1YXRlKCB0aW1lIClbIDAgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR3ZWlnaHQgKj0gaW50ZXJwb2xhbnRWYWx1ZTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIHRpbWUgPiBpbnRlcnBvbGFudC5wYXJhbWV0ZXJQb3NpdGlvbnNbIDEgXSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnN0b3BGYWRpbmcoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIGludGVycG9sYW50VmFsdWUgPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0Ly8gZmFkZWQgb3V0LCBkaXNhYmxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5lbmFibGVkID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX2VmZmVjdGl2ZVdlaWdodCA9IHdlaWdodDtcXG5cXHRcXHRcXHRyZXR1cm4gd2VpZ2h0O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3VwZGF0ZVRpbWVTY2FsZTogZnVuY3Rpb24gKCB0aW1lICkge1xcblxcblxcdFxcdFxcdHZhciB0aW1lU2NhbGUgPSAwO1xcblxcblxcdFxcdFxcdGlmICggISB0aGlzLnBhdXNlZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aW1lU2NhbGUgPSB0aGlzLnRpbWVTY2FsZTtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgaW50ZXJwb2xhbnQgPSB0aGlzLl90aW1lU2NhbGVJbnRlcnBvbGFudDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGludGVycG9sYW50ICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBpbnRlcnBvbGFudFZhbHVlID0gaW50ZXJwb2xhbnQuZXZhbHVhdGUoIHRpbWUgKVsgMCBdO1xcblxcblxcdFxcdFxcdFxcdFxcdHRpbWVTY2FsZSAqPSBpbnRlcnBvbGFudFZhbHVlO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdGltZSA+IGludGVycG9sYW50LnBhcmFtZXRlclBvc2l0aW9uc1sgMSBdICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc3RvcFdhcnBpbmcoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZiAoIHRpbWVTY2FsZSA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyBtb3Rpb24gaGFzIGhhbHRlZCwgcGF1c2VcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnBhdXNlZCA9IHRydWU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHQvLyB3YXJwIGRvbmUgLSBhcHBseSBmaW5hbCB0aW1lIHNjYWxlXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy50aW1lU2NhbGUgPSB0aW1lU2NhbGU7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX2VmZmVjdGl2ZVRpbWVTY2FsZSA9IHRpbWVTY2FsZTtcXG5cXHRcXHRcXHRyZXR1cm4gdGltZVNjYWxlO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3VwZGF0ZVRpbWU6IGZ1bmN0aW9uICggZGVsdGFUaW1lICkge1xcblxcblxcdFxcdFxcdHZhciB0aW1lID0gdGhpcy50aW1lICsgZGVsdGFUaW1lO1xcblxcblxcdFxcdFxcdGlmICggZGVsdGFUaW1lID09PSAwICkgcmV0dXJuIHRpbWU7XFxuXFxuXFx0XFx0XFx0dmFyIGR1cmF0aW9uID0gdGhpcy5fY2xpcC5kdXJhdGlvbixcXG5cXG5cXHRcXHRcXHRcXHRsb29wID0gdGhpcy5sb29wLFxcblxcdFxcdFxcdFxcdGxvb3BDb3VudCA9IHRoaXMuX2xvb3BDb3VudDtcXG5cXG5cXHRcXHRcXHRpZiAoIGxvb3AgPT09IExvb3BPbmNlICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggbG9vcENvdW50ID09PSAtIDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8ganVzdCBzdGFydGVkXFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fbG9vcENvdW50ID0gMDtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9zZXRFbmRpbmdzKCB0cnVlLCB0cnVlLCBmYWxzZSApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRoYW5kbGVfc3RvcDoge1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdGltZSA+PSBkdXJhdGlvbiApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aW1lID0gZHVyYXRpb247XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGlmICggdGltZSA8IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGltZSA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIGJyZWFrIGhhbmRsZV9zdG9wO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggdGhpcy5jbGFtcFdoZW5GaW5pc2hlZCApIHRoaXMucGF1c2VkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHRlbHNlIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0eXBlOiAnZmluaXNoZWQnLCBhY3Rpb246IHRoaXMsXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZGlyZWN0aW9uOiBkZWx0YVRpbWUgPCAwID8gLSAxIDogMVxcblxcdFxcdFxcdFxcdFxcdH0gKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHsgLy8gcmVwZXRpdGl2ZSBSZXBlYXQgb3IgUGluZ1BvbmdcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcGluZ1BvbmcgPSAoIGxvb3AgPT09IExvb3BQaW5nUG9uZyApO1xcblxcblxcdFxcdFxcdFxcdGlmICggbG9vcENvdW50ID09PSAtIDEgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ly8ganVzdCBzdGFydGVkXFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBkZWx0YVRpbWUgPj0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRsb29wQ291bnQgPSAwO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX3NldEVuZGluZ3MoIHRydWUsIHRoaXMucmVwZXRpdGlvbnMgPT09IDAsIHBpbmdQb25nICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyB3aGVuIGxvb3BpbmcgaW4gcmV2ZXJzZSBkaXJlY3Rpb24sIHRoZSBpbml0aWFsXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gdHJhbnNpdGlvbiB0aHJvdWdoIHplcm8gY291bnRzIGFzIGEgcmVwZXRpdGlvbixcXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBzbyBsZWF2ZSBsb29wQ291bnQgYXQgLTFcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9zZXRFbmRpbmdzKCB0aGlzLnJlcGV0aXRpb25zID09PSAwLCB0cnVlLCBwaW5nUG9uZyApO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCB0aW1lID49IGR1cmF0aW9uIHx8IHRpbWUgPCAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHdyYXAgYXJvdW5kXFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGxvb3BEZWx0YSA9IE1hdGguZmxvb3IoIHRpbWUgLyBkdXJhdGlvbiApOyAvLyBzaWduZWRcXG5cXHRcXHRcXHRcXHRcXHR0aW1lIC09IGR1cmF0aW9uICogbG9vcERlbHRhO1xcblxcblxcdFxcdFxcdFxcdFxcdGxvb3BDb3VudCArPSBNYXRoLmFicyggbG9vcERlbHRhICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHBlbmRpbmcgPSB0aGlzLnJlcGV0aXRpb25zIC0gbG9vcENvdW50O1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggcGVuZGluZyA8IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8gaGF2ZSB0byBzdG9wIChzd2l0Y2ggc3RhdGUsIGNsYW1wIHRpbWUsIGZpcmUgZXZlbnQpXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCB0aGlzLmNsYW1wV2hlbkZpbmlzaGVkICkgdGhpcy5wYXVzZWQgPSB0cnVlO1xcblxcdFxcdFxcdFxcdFxcdFxcdGVsc2UgdGhpcy5lbmFibGVkID0gZmFsc2U7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGltZSA9IGRlbHRhVGltZSA+IDAgPyBkdXJhdGlvbiA6IDA7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fbWl4ZXIuZGlzcGF0Y2hFdmVudCgge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHR5cGU6ICdmaW5pc2hlZCcsIGFjdGlvbjogdGhpcyxcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHRkaXJlY3Rpb246IGRlbHRhVGltZSA+IDAgPyAxIDogLSAxXFxuXFx0XFx0XFx0XFx0XFx0XFx0fSApO1xcblxcblxcdFxcdFxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0Ly8ga2VlcCBydW5uaW5nXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBwZW5kaW5nID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIGVudGVyaW5nIHRoZSBsYXN0IHJvdW5kXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dmFyIGF0U3RhcnQgPSBkZWx0YVRpbWUgPCAwO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX3NldEVuZGluZ3MoIGF0U3RhcnQsICEgYXRTdGFydCwgcGluZ1BvbmcgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX3NldEVuZGluZ3MoIGZhbHNlLCBmYWxzZSwgcGluZ1BvbmcgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fbG9vcENvdW50ID0gbG9vcENvdW50O1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuX21peGVyLmRpc3BhdGNoRXZlbnQoIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0eXBlOiAnbG9vcCcsIGFjdGlvbjogdGhpcywgbG9vcERlbHRhOiBsb29wRGVsdGFcXG5cXHRcXHRcXHRcXHRcXHRcXHR9ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIHBpbmdQb25nICYmICggbG9vcENvdW50ICYgMSApID09PSAxICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIGludmVydCB0aW1lIGZvciB0aGUgXFxcInBvbmcgcm91bmRcXFwiXFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy50aW1lID0gdGltZTtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZHVyYXRpb24gLSB0aW1lO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy50aW1lID0gdGltZTtcXG5cXHRcXHRcXHRyZXR1cm4gdGltZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9zZXRFbmRpbmdzOiBmdW5jdGlvbiAoIGF0U3RhcnQsIGF0RW5kLCBwaW5nUG9uZyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgc2V0dGluZ3MgPSB0aGlzLl9pbnRlcnBvbGFudFNldHRpbmdzO1xcblxcblxcdFxcdFxcdGlmICggcGluZ1BvbmcgKSB7XFxuXFxuXFx0XFx0XFx0XFx0c2V0dGluZ3MuZW5kaW5nU3RhcnQgXFx0PSBaZXJvU2xvcGVFbmRpbmc7XFxuXFx0XFx0XFx0XFx0c2V0dGluZ3MuZW5kaW5nRW5kXFx0XFx0PSBaZXJvU2xvcGVFbmRpbmc7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBhc3N1bWluZyBmb3IgTG9vcE9uY2UgYXRTdGFydCA9PSBhdEVuZCA9PSB0cnVlXFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBhdFN0YXJ0ICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHNldHRpbmdzLmVuZGluZ1N0YXJ0ID0gdGhpcy56ZXJvU2xvcGVBdFN0YXJ0ID8gWmVyb1Nsb3BlRW5kaW5nIDogWmVyb0N1cnZhdHVyZUVuZGluZztcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHNldHRpbmdzLmVuZGluZ1N0YXJ0ID0gV3JhcEFyb3VuZEVuZGluZztcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBhdEVuZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRzZXR0aW5ncy5lbmRpbmdFbmQgPSB0aGlzLnplcm9TbG9wZUF0RW5kID8gWmVyb1Nsb3BlRW5kaW5nIDogWmVyb0N1cnZhdHVyZUVuZGluZztcXG5cXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdFxcdHNldHRpbmdzLmVuZGluZ0VuZCBcXHQgPSBXcmFwQXJvdW5kRW5kaW5nO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfc2NoZWR1bGVGYWRpbmc6IGZ1bmN0aW9uICggZHVyYXRpb24sIHdlaWdodE5vdywgd2VpZ2h0VGhlbiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgbWl4ZXIgPSB0aGlzLl9taXhlciwgbm93ID0gbWl4ZXIudGltZSxcXG5cXHRcXHRcXHRcXHRpbnRlcnBvbGFudCA9IHRoaXMuX3dlaWdodEludGVycG9sYW50O1xcblxcblxcdFxcdFxcdGlmICggaW50ZXJwb2xhbnQgPT09IG51bGwgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aW50ZXJwb2xhbnQgPSBtaXhlci5fbGVuZENvbnRyb2xJbnRlcnBvbGFudCgpO1xcblxcdFxcdFxcdFxcdHRoaXMuX3dlaWdodEludGVycG9sYW50ID0gaW50ZXJwb2xhbnQ7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciB0aW1lcyA9IGludGVycG9sYW50LnBhcmFtZXRlclBvc2l0aW9ucyxcXG5cXHRcXHRcXHRcXHR2YWx1ZXMgPSBpbnRlcnBvbGFudC5zYW1wbGVWYWx1ZXM7XFxuXFxuXFx0XFx0XFx0dGltZXNbIDAgXSA9IG5vdzsgXFx0XFx0XFx0XFx0dmFsdWVzWyAwIF0gPSB3ZWlnaHROb3c7XFxuXFx0XFx0XFx0dGltZXNbIDEgXSA9IG5vdyArIGR1cmF0aW9uO1xcdHZhbHVlc1sgMSBdID0gd2VpZ2h0VGhlbjtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqXFxuXFx0ICogUGxheWVyIGZvciBBbmltYXRpb25DbGlwcy5cXG5cXHQgKlxcblxcdCAqXFxuXFx0ICogQGF1dGhvciBCZW4gSG91c3RvbiAvIGh0dHA6Ly9jbGFyYS5pby9cXG5cXHQgKiBAYXV0aG9yIERhdmlkIFNhcm5vIC8gaHR0cDovL2xpZ2h0aGF1cy51cy9cXG5cXHQgKiBAYXV0aG9yIHRzY2h3XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gQW5pbWF0aW9uTWl4ZXIoIHJvb3QgKSB7XFxuXFxuXFx0XFx0dGhpcy5fcm9vdCA9IHJvb3Q7XFxuXFx0XFx0dGhpcy5faW5pdE1lbW9yeU1hbmFnZXIoKTtcXG5cXHRcXHR0aGlzLl9hY2N1SW5kZXggPSAwO1xcblxcblxcdFxcdHRoaXMudGltZSA9IDA7XFxuXFxuXFx0XFx0dGhpcy50aW1lU2NhbGUgPSAxLjA7XFxuXFxuXFx0fVxcblxcblxcdEFuaW1hdGlvbk1peGVyLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEV2ZW50RGlzcGF0Y2hlci5wcm90b3R5cGUgKSwge1xcblxcblxcdFxcdGNvbnN0cnVjdG9yOiBBbmltYXRpb25NaXhlcixcXG5cXG5cXHRcXHRfYmluZEFjdGlvbjogZnVuY3Rpb24gKCBhY3Rpb24sIHByb3RvdHlwZUFjdGlvbiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcm9vdCA9IGFjdGlvbi5fbG9jYWxSb290IHx8IHRoaXMuX3Jvb3QsXFxuXFx0XFx0XFx0XFx0dHJhY2tzID0gYWN0aW9uLl9jbGlwLnRyYWNrcyxcXG5cXHRcXHRcXHRcXHRuVHJhY2tzID0gdHJhY2tzLmxlbmd0aCxcXG5cXHRcXHRcXHRcXHRiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5ncyxcXG5cXHRcXHRcXHRcXHRpbnRlcnBvbGFudHMgPSBhY3Rpb24uX2ludGVycG9sYW50cyxcXG5cXHRcXHRcXHRcXHRyb290VXVpZCA9IHJvb3QudXVpZCxcXG5cXHRcXHRcXHRcXHRiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcXG5cXHRcXHRcXHRcXHRiaW5kaW5nc0J5TmFtZSA9IGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdO1xcblxcblxcdFxcdFxcdGlmICggYmluZGluZ3NCeU5hbWUgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRiaW5kaW5nc0J5TmFtZSA9IHt9O1xcblxcdFxcdFxcdFxcdGJpbmRpbmdzQnlSb290WyByb290VXVpZCBdID0gYmluZGluZ3NCeU5hbWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gblRyYWNrczsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgdHJhY2sgPSB0cmFja3NbIGkgXSxcXG5cXHRcXHRcXHRcXHRcXHR0cmFja05hbWUgPSB0cmFjay5uYW1lLFxcblxcdFxcdFxcdFxcdFxcdGJpbmRpbmcgPSBiaW5kaW5nc0J5TmFtZVsgdHJhY2tOYW1lIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBiaW5kaW5nICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YmluZGluZ3NbIGkgXSA9IGJpbmRpbmc7XFxuXFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIGJpbmRpbmcgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHQvLyBleGlzdGluZyBiaW5kaW5nLCBtYWtlIHN1cmUgdGhlIGNhY2hlIGtub3dzXFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBiaW5kaW5nLl9jYWNoZUluZGV4ID09PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCsrIGJpbmRpbmcucmVmZXJlbmNlQ291bnQ7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fYWRkSW5hY3RpdmVCaW5kaW5nKCBiaW5kaW5nLCByb290VXVpZCwgdHJhY2tOYW1lICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdFxcdGNvbnRpbnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgcGF0aCA9IHByb3RvdHlwZUFjdGlvbiAmJiBwcm90b3R5cGVBY3Rpb24uXFxuXFx0XFx0XFx0XFx0XFx0XFx0X3Byb3BlcnR5QmluZGluZ3NbIGkgXS5iaW5kaW5nLnBhcnNlZFBhdGg7XFxuXFxuXFx0XFx0XFx0XFx0XFx0YmluZGluZyA9IG5ldyBQcm9wZXJ0eU1peGVyKFxcblxcdFxcdFxcdFxcdFxcdFxcdFByb3BlcnR5QmluZGluZy5jcmVhdGUoIHJvb3QsIHRyYWNrTmFtZSwgcGF0aCApLFxcblxcdFxcdFxcdFxcdFxcdFxcdHRyYWNrLlZhbHVlVHlwZU5hbWUsIHRyYWNrLmdldFZhbHVlU2l6ZSgpICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0KysgYmluZGluZy5yZWZlcmVuY2VDb3VudDtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9hZGRJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcsIHJvb3RVdWlkLCB0cmFja05hbWUgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRiaW5kaW5nc1sgaSBdID0gYmluZGluZztcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aW50ZXJwb2xhbnRzWyBpIF0ucmVzdWx0QnVmZmVyID0gYmluZGluZy5idWZmZXI7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2FjdGl2YXRlQWN0aW9uOiBmdW5jdGlvbiAoIGFjdGlvbiApIHtcXG5cXG5cXHRcXHRcXHRpZiAoICEgdGhpcy5faXNBY3RpdmVBY3Rpb24oIGFjdGlvbiApICkge1xcblxcblxcdFxcdFxcdFxcdGlmICggYWN0aW9uLl9jYWNoZUluZGV4ID09PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdFxcdC8vIHRoaXMgYWN0aW9uIGhhcyBiZWVuIGZvcmdvdHRlbiBieSB0aGUgY2FjaGUsIGJ1dCB0aGUgdXNlclxcblxcdFxcdFxcdFxcdFxcdC8vIGFwcGVhcnMgdG8gYmUgc3RpbGwgdXNpbmcgaXQgLT4gcmViaW5kXFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIHJvb3RVdWlkID0gKCBhY3Rpb24uX2xvY2FsUm9vdCB8fCB0aGlzLl9yb290ICkudXVpZCxcXG5cXHRcXHRcXHRcXHRcXHRcXHRjbGlwVXVpZCA9IGFjdGlvbi5fY2xpcC51dWlkLFxcblxcdFxcdFxcdFxcdFxcdFxcdGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9iaW5kQWN0aW9uKCBhY3Rpb24sXFxuXFx0XFx0XFx0XFx0XFx0XFx0YWN0aW9uc0ZvckNsaXAgJiYgYWN0aW9uc0ZvckNsaXAua25vd25BY3Rpb25zWyAwIF0gKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9hZGRJbmFjdGl2ZUFjdGlvbiggYWN0aW9uLCBjbGlwVXVpZCwgcm9vdFV1aWQgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGJpbmRpbmdzID0gYWN0aW9uLl9wcm9wZXJ0eUJpbmRpbmdzO1xcblxcblxcdFxcdFxcdFxcdC8vIGluY3JlbWVudCByZWZlcmVuY2UgY291bnRzIC8gc29ydCBvdXQgc3RhdGVcXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICggYmluZGluZy51c2VDb3VudCArKyA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9sZW5kQmluZGluZyggYmluZGluZyApO1xcblxcdFxcdFxcdFxcdFxcdFxcdGJpbmRpbmcuc2F2ZU9yaWdpbmFsU3RhdGUoKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRoaXMuX2xlbmRBY3Rpb24oIGFjdGlvbiApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9kZWFjdGl2YXRlQWN0aW9uOiBmdW5jdGlvbiAoIGFjdGlvbiApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHRoaXMuX2lzQWN0aXZlQWN0aW9uKCBhY3Rpb24gKSApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYmluZGluZ3MgPSBhY3Rpb24uX3Byb3BlcnR5QmluZGluZ3M7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gZGVjcmVtZW50IHJlZmVyZW5jZSBjb3VudHMgLyBzb3J0IG91dCBzdGF0ZVxcblxcdFxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbiA9IGJpbmRpbmdzLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgYmluZGluZyA9IGJpbmRpbmdzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCAtLSBiaW5kaW5nLnVzZUNvdW50ID09PSAwICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdGJpbmRpbmcucmVzdG9yZU9yaWdpbmFsU3RhdGUoKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl90YWtlQmFja0JpbmRpbmcoIGJpbmRpbmcgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdHRoaXMuX3Rha2VCYWNrQWN0aW9uKCBhY3Rpb24gKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBNZW1vcnkgbWFuYWdlclxcblxcblxcdFxcdF9pbml0TWVtb3J5TWFuYWdlcjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHRoaXMuX2FjdGlvbnMgPSBbXTsgLy8gJ25BY3RpdmVBY3Rpb25zJyBmb2xsb3dlZCBieSBpbmFjdGl2ZSBvbmVzXFxuXFx0XFx0XFx0dGhpcy5fbkFjdGl2ZUFjdGlvbnMgPSAwO1xcblxcblxcdFxcdFxcdHRoaXMuX2FjdGlvbnNCeUNsaXAgPSB7fTtcXG5cXHRcXHRcXHQvLyBpbnNpZGU6XFxuXFx0XFx0XFx0Ly8ge1xcblxcdFxcdFxcdC8vIFxcdFxcdGtub3duQWN0aW9uczogQXJyYXk8IEFuaW1hdGlvbkFjdGlvbiA+XFx0LSB1c2VkIGFzIHByb3RvdHlwZXNcXG5cXHRcXHRcXHQvLyBcXHRcXHRhY3Rpb25CeVJvb3Q6IEFuaW1hdGlvbkFjdGlvblxcdFxcdFxcdC0gbG9va3VwXFxuXFx0XFx0XFx0Ly8gfVxcblxcblxcblxcdFxcdFxcdHRoaXMuX2JpbmRpbmdzID0gW107IC8vICduQWN0aXZlQmluZGluZ3MnIGZvbGxvd2VkIGJ5IGluYWN0aXZlIG9uZXNcXG5cXHRcXHRcXHR0aGlzLl9uQWN0aXZlQmluZGluZ3MgPSAwO1xcblxcblxcdFxcdFxcdHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSA9IHt9OyAvLyBpbnNpZGU6IE1hcDwgbmFtZSwgUHJvcGVydHlNaXhlciA+XFxuXFxuXFxuXFx0XFx0XFx0dGhpcy5fY29udHJvbEludGVycG9sYW50cyA9IFtdOyAvLyBzYW1lIGdhbWUgYXMgYWJvdmVcXG5cXHRcXHRcXHR0aGlzLl9uQWN0aXZlQ29udHJvbEludGVycG9sYW50cyA9IDA7XFxuXFxuXFx0XFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXG5cXG5cXHRcXHRcXHR0aGlzLnN0YXRzID0ge1xcblxcblxcdFxcdFxcdFxcdGFjdGlvbnM6IHtcXG5cXHRcXHRcXHRcXHRcXHRnZXQgdG90YWwoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHNjb3BlLl9hY3Rpb25zLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcdGdldCBpblVzZSgpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gc2NvcGUuX25BY3RpdmVBY3Rpb25zO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdGJpbmRpbmdzOiB7XFxuXFx0XFx0XFx0XFx0XFx0Z2V0IHRvdGFsKCkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBzY29wZS5fYmluZGluZ3MubGVuZ3RoO1xcblxcblxcdFxcdFxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0XFx0XFx0Z2V0IGluVXNlKCkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBzY29wZS5fbkFjdGl2ZUJpbmRpbmdzO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdGNvbnRyb2xJbnRlcnBvbGFudHM6IHtcXG5cXHRcXHRcXHRcXHRcXHRnZXQgdG90YWwoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIHNjb3BlLl9jb250cm9sSW50ZXJwb2xhbnRzLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9LFxcblxcdFxcdFxcdFxcdFxcdGdldCBpblVzZSgpIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gc2NvcGUuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzO1xcblxcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIE1lbW9yeSBtYW5hZ2VtZW50IGZvciBBbmltYXRpb25BY3Rpb24gb2JqZWN0c1xcblxcblxcdFxcdF9pc0FjdGl2ZUFjdGlvbjogZnVuY3Rpb24gKCBhY3Rpb24gKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGluZGV4ID0gYWN0aW9uLl9jYWNoZUluZGV4O1xcblxcdFxcdFxcdHJldHVybiBpbmRleCAhPT0gbnVsbCAmJiBpbmRleCA8IHRoaXMuX25BY3RpdmVBY3Rpb25zO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2FkZEluYWN0aXZlQWN0aW9uOiBmdW5jdGlvbiAoIGFjdGlvbiwgY2xpcFV1aWQsIHJvb3RVdWlkICkge1xcblxcblxcdFxcdFxcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcXG5cXHRcXHRcXHRcXHRhY3Rpb25zQnlDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcCxcXG5cXHRcXHRcXHRcXHRhY3Rpb25zRm9yQ2xpcCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XFxuXFxuXFx0XFx0XFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGFjdGlvbnNGb3JDbGlwID0ge1xcblxcblxcdFxcdFxcdFxcdFxcdGtub3duQWN0aW9uczogWyBhY3Rpb24gXSxcXG5cXHRcXHRcXHRcXHRcXHRhY3Rpb25CeVJvb3Q6IHt9XFxuXFxuXFx0XFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHRcXHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSAwO1xcblxcblxcdFxcdFxcdFxcdGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF0gPSBhY3Rpb25zRm9yQ2xpcDtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHZhciBrbm93bkFjdGlvbnMgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnM7XFxuXFxuXFx0XFx0XFx0XFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0ga25vd25BY3Rpb25zLmxlbmd0aDtcXG5cXHRcXHRcXHRcXHRrbm93bkFjdGlvbnMucHVzaCggYWN0aW9uICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGFjdGlvbi5fY2FjaGVJbmRleCA9IGFjdGlvbnMubGVuZ3RoO1xcblxcdFxcdFxcdGFjdGlvbnMucHVzaCggYWN0aW9uICk7XFxuXFxuXFx0XFx0XFx0YWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290WyByb290VXVpZCBdID0gYWN0aW9uO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3JlbW92ZUluYWN0aXZlQWN0aW9uOiBmdW5jdGlvbiAoIGFjdGlvbiApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXFxuXFx0XFx0XFx0XFx0bGFzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgYWN0aW9ucy5sZW5ndGggLSAxIF0sXFxuXFx0XFx0XFx0XFx0Y2FjaGVJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleDtcXG5cXG5cXHRcXHRcXHRsYXN0SW5hY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBjYWNoZUluZGV4O1xcblxcdFxcdFxcdGFjdGlvbnNbIGNhY2hlSW5kZXggXSA9IGxhc3RJbmFjdGl2ZUFjdGlvbjtcXG5cXHRcXHRcXHRhY3Rpb25zLnBvcCgpO1xcblxcblxcdFxcdFxcdGFjdGlvbi5fY2FjaGVJbmRleCA9IG51bGw7XFxuXFxuXFxuXFx0XFx0XFx0dmFyIGNsaXBVdWlkID0gYWN0aW9uLl9jbGlwLnV1aWQsXFxuXFx0XFx0XFx0XFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXAsXFxuXFx0XFx0XFx0XFx0YWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdLFxcblxcdFxcdFxcdFxcdGtub3duQWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnMsXFxuXFxuXFx0XFx0XFx0XFx0bGFzdEtub3duQWN0aW9uID1cXG5cXHRcXHRcXHRcXHRcXHRrbm93bkFjdGlvbnNGb3JDbGlwWyBrbm93bkFjdGlvbnNGb3JDbGlwLmxlbmd0aCAtIDEgXSxcXG5cXG5cXHRcXHRcXHRcXHRieUNsaXBDYWNoZUluZGV4ID0gYWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4O1xcblxcblxcdFxcdFxcdGxhc3RLbm93bkFjdGlvbi5fYnlDbGlwQ2FjaGVJbmRleCA9IGJ5Q2xpcENhY2hlSW5kZXg7XFxuXFx0XFx0XFx0a25vd25BY3Rpb25zRm9yQ2xpcFsgYnlDbGlwQ2FjaGVJbmRleCBdID0gbGFzdEtub3duQWN0aW9uO1xcblxcdFxcdFxcdGtub3duQWN0aW9uc0ZvckNsaXAucG9wKCk7XFxuXFxuXFx0XFx0XFx0YWN0aW9uLl9ieUNsaXBDYWNoZUluZGV4ID0gbnVsbDtcXG5cXG5cXG5cXHRcXHRcXHR2YXIgYWN0aW9uQnlSb290ID0gYWN0aW9uc0ZvckNsaXAuYWN0aW9uQnlSb290LFxcblxcdFxcdFxcdFxcdHJvb3RVdWlkID0gKCBhY3Rpb24uX2xvY2FsUm9vdCB8fCB0aGlzLl9yb290ICkudXVpZDtcXG5cXG5cXHRcXHRcXHRkZWxldGUgYWN0aW9uQnlSb290WyByb290VXVpZCBdO1xcblxcblxcdFxcdFxcdGlmICgga25vd25BY3Rpb25zRm9yQ2xpcC5sZW5ndGggPT09IDAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0ZGVsZXRlIGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb24oIGFjdGlvbiApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3JlbW92ZUluYWN0aXZlQmluZGluZ3NGb3JBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uICkge1xcblxcblxcdFxcdFxcdHZhciBiaW5kaW5ncyA9IGFjdGlvbi5fcHJvcGVydHlCaW5kaW5ncztcXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIG4gPSBiaW5kaW5ncy5sZW5ndGg7IGkgIT09IG47ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdGlmICggLS0gYmluZGluZy5yZWZlcmVuY2VDb3VudCA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9yZW1vdmVJbmFjdGl2ZUJpbmRpbmcoIGJpbmRpbmcgKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X2xlbmRBY3Rpb246IGZ1bmN0aW9uICggYWN0aW9uICkge1xcblxcblxcdFxcdFxcdC8vIFsgYWN0aXZlIGFjdGlvbnMgfCAgaW5hY3RpdmUgYWN0aW9ucyAgXVxcblxcdFxcdFxcdC8vIFsgIGFjdGl2ZSBhY3Rpb25zID58IGluYWN0aXZlIGFjdGlvbnMgXVxcblxcdFxcdFxcdC8vICAgICAgICAgICAgICAgICBzICAgICAgICBhXFxuXFx0XFx0XFx0Ly8gICAgICAgICAgICAgICAgICA8LXN3YXAtPlxcblxcdFxcdFxcdC8vICAgICAgICAgICAgICAgICBhICAgICAgICBzXFxuXFxuXFx0XFx0XFx0dmFyIGFjdGlvbnMgPSB0aGlzLl9hY3Rpb25zLFxcblxcdFxcdFxcdFxcdHByZXZJbmRleCA9IGFjdGlvbi5fY2FjaGVJbmRleCxcXG5cXG5cXHRcXHRcXHRcXHRsYXN0QWN0aXZlSW5kZXggPSB0aGlzLl9uQWN0aXZlQWN0aW9ucyArKyxcXG5cXG5cXHRcXHRcXHRcXHRmaXJzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgbGFzdEFjdGl2ZUluZGV4IF07XFxuXFxuXFx0XFx0XFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xcblxcdFxcdFxcdGFjdGlvbnNbIGxhc3RBY3RpdmVJbmRleCBdID0gYWN0aW9uO1xcblxcblxcdFxcdFxcdGZpcnN0SW5hY3RpdmVBY3Rpb24uX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XFxuXFx0XFx0XFx0YWN0aW9uc1sgcHJldkluZGV4IF0gPSBmaXJzdEluYWN0aXZlQWN0aW9uO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0X3Rha2VCYWNrQWN0aW9uOiBmdW5jdGlvbiAoIGFjdGlvbiApIHtcXG5cXG5cXHRcXHRcXHQvLyBbICBhY3RpdmUgYWN0aW9ucyAgfCBpbmFjdGl2ZSBhY3Rpb25zIF1cXG5cXHRcXHRcXHQvLyBbIGFjdGl2ZSBhY3Rpb25zIHw8IGluYWN0aXZlIGFjdGlvbnMgIF1cXG5cXHRcXHRcXHQvLyAgICAgICAgYSAgICAgICAgc1xcblxcdFxcdFxcdC8vICAgICAgICAgPC1zd2FwLT5cXG5cXHRcXHRcXHQvLyAgICAgICAgcyAgICAgICAgYVxcblxcblxcdFxcdFxcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcXG5cXHRcXHRcXHRcXHRwcmV2SW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXgsXFxuXFxuXFx0XFx0XFx0XFx0Zmlyc3RJbmFjdGl2ZUluZGV4ID0gLS0gdGhpcy5fbkFjdGl2ZUFjdGlvbnMsXFxuXFxuXFx0XFx0XFx0XFx0bGFzdEFjdGl2ZUFjdGlvbiA9IGFjdGlvbnNbIGZpcnN0SW5hY3RpdmVJbmRleCBdO1xcblxcblxcdFxcdFxcdGFjdGlvbi5fY2FjaGVJbmRleCA9IGZpcnN0SW5hY3RpdmVJbmRleDtcXG5cXHRcXHRcXHRhY3Rpb25zWyBmaXJzdEluYWN0aXZlSW5kZXggXSA9IGFjdGlvbjtcXG5cXG5cXHRcXHRcXHRsYXN0QWN0aXZlQWN0aW9uLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xcblxcdFxcdFxcdGFjdGlvbnNbIHByZXZJbmRleCBdID0gbGFzdEFjdGl2ZUFjdGlvbjtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIE1lbW9yeSBtYW5hZ2VtZW50IGZvciBQcm9wZXJ0eU1peGVyIG9iamVjdHNcXG5cXG5cXHRcXHRfYWRkSW5hY3RpdmVCaW5kaW5nOiBmdW5jdGlvbiAoIGJpbmRpbmcsIHJvb3RVdWlkLCB0cmFja05hbWUgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGJpbmRpbmdzQnlSb290ID0gdGhpcy5fYmluZGluZ3NCeVJvb3RBbmROYW1lLFxcblxcdFxcdFxcdFxcdGJpbmRpbmdCeU5hbWUgPSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXSxcXG5cXG5cXHRcXHRcXHRcXHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzO1xcblxcblxcdFxcdFxcdGlmICggYmluZGluZ0J5TmFtZSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGJpbmRpbmdCeU5hbWUgPSB7fTtcXG5cXHRcXHRcXHRcXHRiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXSA9IGJpbmRpbmdCeU5hbWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGJpbmRpbmdCeU5hbWVbIHRyYWNrTmFtZSBdID0gYmluZGluZztcXG5cXG5cXHRcXHRcXHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gYmluZGluZ3MubGVuZ3RoO1xcblxcdFxcdFxcdGJpbmRpbmdzLnB1c2goIGJpbmRpbmcgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9yZW1vdmVJbmFjdGl2ZUJpbmRpbmc6IGZ1bmN0aW9uICggYmluZGluZyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcXG5cXHRcXHRcXHRcXHRwcm9wQmluZGluZyA9IGJpbmRpbmcuYmluZGluZyxcXG5cXHRcXHRcXHRcXHRyb290VXVpZCA9IHByb3BCaW5kaW5nLnJvb3ROb2RlLnV1aWQsXFxuXFx0XFx0XFx0XFx0dHJhY2tOYW1lID0gcHJvcEJpbmRpbmcucGF0aCxcXG5cXHRcXHRcXHRcXHRiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcXG5cXHRcXHRcXHRcXHRiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF0sXFxuXFxuXFx0XFx0XFx0XFx0bGFzdEluYWN0aXZlQmluZGluZyA9IGJpbmRpbmdzWyBiaW5kaW5ncy5sZW5ndGggLSAxIF0sXFxuXFx0XFx0XFx0XFx0Y2FjaGVJbmRleCA9IGJpbmRpbmcuX2NhY2hlSW5kZXg7XFxuXFxuXFx0XFx0XFx0bGFzdEluYWN0aXZlQmluZGluZy5fY2FjaGVJbmRleCA9IGNhY2hlSW5kZXg7XFxuXFx0XFx0XFx0YmluZGluZ3NbIGNhY2hlSW5kZXggXSA9IGxhc3RJbmFjdGl2ZUJpbmRpbmc7XFxuXFx0XFx0XFx0YmluZGluZ3MucG9wKCk7XFxuXFxuXFx0XFx0XFx0ZGVsZXRlIGJpbmRpbmdCeU5hbWVbIHRyYWNrTmFtZSBdO1xcblxcblxcdFxcdFxcdHJlbW92ZV9lbXB0eV9tYXA6IHtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgXyBpbiBiaW5kaW5nQnlOYW1lICkgYnJlYWsgcmVtb3ZlX2VtcHR5X21hcDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xcblxcblxcdFxcdFxcdFxcdGRlbGV0ZSBiaW5kaW5nc0J5Um9vdFsgcm9vdFV1aWQgXTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfbGVuZEJpbmRpbmc6IGZ1bmN0aW9uICggYmluZGluZyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYmluZGluZ3MgPSB0aGlzLl9iaW5kaW5ncyxcXG5cXHRcXHRcXHRcXHRwcmV2SW5kZXggPSBiaW5kaW5nLl9jYWNoZUluZGV4LFxcblxcblxcdFxcdFxcdFxcdGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVCaW5kaW5ncyArKyxcXG5cXG5cXHRcXHRcXHRcXHRmaXJzdEluYWN0aXZlQmluZGluZyA9IGJpbmRpbmdzWyBsYXN0QWN0aXZlSW5kZXggXTtcXG5cXG5cXHRcXHRcXHRiaW5kaW5nLl9jYWNoZUluZGV4ID0gbGFzdEFjdGl2ZUluZGV4O1xcblxcdFxcdFxcdGJpbmRpbmdzWyBsYXN0QWN0aXZlSW5kZXggXSA9IGJpbmRpbmc7XFxuXFxuXFx0XFx0XFx0Zmlyc3RJbmFjdGl2ZUJpbmRpbmcuX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XFxuXFx0XFx0XFx0YmluZGluZ3NbIHByZXZJbmRleCBdID0gZmlyc3RJbmFjdGl2ZUJpbmRpbmc7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRfdGFrZUJhY2tCaW5kaW5nOiBmdW5jdGlvbiAoIGJpbmRpbmcgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXFxuXFx0XFx0XFx0XFx0cHJldkluZGV4ID0gYmluZGluZy5fY2FjaGVJbmRleCxcXG5cXG5cXHRcXHRcXHRcXHRmaXJzdEluYWN0aXZlSW5kZXggPSAtLSB0aGlzLl9uQWN0aXZlQmluZGluZ3MsXFxuXFxuXFx0XFx0XFx0XFx0bGFzdEFjdGl2ZUJpbmRpbmcgPSBiaW5kaW5nc1sgZmlyc3RJbmFjdGl2ZUluZGV4IF07XFxuXFxuXFx0XFx0XFx0YmluZGluZy5fY2FjaGVJbmRleCA9IGZpcnN0SW5hY3RpdmVJbmRleDtcXG5cXHRcXHRcXHRiaW5kaW5nc1sgZmlyc3RJbmFjdGl2ZUluZGV4IF0gPSBiaW5kaW5nO1xcblxcblxcdFxcdFxcdGxhc3RBY3RpdmVCaW5kaW5nLl9jYWNoZUluZGV4ID0gcHJldkluZGV4O1xcblxcdFxcdFxcdGJpbmRpbmdzWyBwcmV2SW5kZXggXSA9IGxhc3RBY3RpdmVCaW5kaW5nO1xcblxcblxcdFxcdH0sXFxuXFxuXFxuXFx0XFx0Ly8gTWVtb3J5IG1hbmFnZW1lbnQgb2YgSW50ZXJwb2xhbnRzIGZvciB3ZWlnaHQgYW5kIHRpbWUgc2NhbGVcXG5cXG5cXHRcXHRfbGVuZENvbnRyb2xJbnRlcnBvbGFudDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHZhciBpbnRlcnBvbGFudHMgPSB0aGlzLl9jb250cm9sSW50ZXJwb2xhbnRzLFxcblxcdFxcdFxcdFxcdGxhc3RBY3RpdmVJbmRleCA9IHRoaXMuX25BY3RpdmVDb250cm9sSW50ZXJwb2xhbnRzICsrLFxcblxcdFxcdFxcdFxcdGludGVycG9sYW50ID0gaW50ZXJwb2xhbnRzWyBsYXN0QWN0aXZlSW5kZXggXTtcXG5cXG5cXHRcXHRcXHRpZiAoIGludGVycG9sYW50ID09PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aW50ZXJwb2xhbnQgPSBuZXcgTGluZWFySW50ZXJwb2xhbnQoXFxuXFx0XFx0XFx0XFx0XFx0bmV3IEZsb2F0MzJBcnJheSggMiApLCBuZXcgRmxvYXQzMkFycmF5KCAyICksXFxuXFx0XFx0XFx0XFx0XFx0MSwgdGhpcy5fY29udHJvbEludGVycG9sYW50c1Jlc3VsdEJ1ZmZlciApO1xcblxcblxcdFxcdFxcdFxcdGludGVycG9sYW50Ll9fY2FjaGVJbmRleCA9IGxhc3RBY3RpdmVJbmRleDtcXG5cXHRcXHRcXHRcXHRpbnRlcnBvbGFudHNbIGxhc3RBY3RpdmVJbmRleCBdID0gaW50ZXJwb2xhbnQ7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHJldHVybiBpbnRlcnBvbGFudDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdF90YWtlQmFja0NvbnRyb2xJbnRlcnBvbGFudDogZnVuY3Rpb24gKCBpbnRlcnBvbGFudCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgaW50ZXJwb2xhbnRzID0gdGhpcy5fY29udHJvbEludGVycG9sYW50cyxcXG5cXHRcXHRcXHRcXHRwcmV2SW5kZXggPSBpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXgsXFxuXFxuXFx0XFx0XFx0XFx0Zmlyc3RJbmFjdGl2ZUluZGV4ID0gLS0gdGhpcy5fbkFjdGl2ZUNvbnRyb2xJbnRlcnBvbGFudHMsXFxuXFxuXFx0XFx0XFx0XFx0bGFzdEFjdGl2ZUludGVycG9sYW50ID0gaW50ZXJwb2xhbnRzWyBmaXJzdEluYWN0aXZlSW5kZXggXTtcXG5cXG5cXHRcXHRcXHRpbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBmaXJzdEluYWN0aXZlSW5kZXg7XFxuXFx0XFx0XFx0aW50ZXJwb2xhbnRzWyBmaXJzdEluYWN0aXZlSW5kZXggXSA9IGludGVycG9sYW50O1xcblxcblxcdFxcdFxcdGxhc3RBY3RpdmVJbnRlcnBvbGFudC5fX2NhY2hlSW5kZXggPSBwcmV2SW5kZXg7XFxuXFx0XFx0XFx0aW50ZXJwb2xhbnRzWyBwcmV2SW5kZXggXSA9IGxhc3RBY3RpdmVJbnRlcnBvbGFudDtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdF9jb250cm9sSW50ZXJwb2xhbnRzUmVzdWx0QnVmZmVyOiBuZXcgRmxvYXQzMkFycmF5KCAxICksXFxuXFxuXFx0XFx0Ly8gcmV0dXJuIGFuIGFjdGlvbiBmb3IgYSBjbGlwIG9wdGlvbmFsbHkgdXNpbmcgYSBjdXN0b20gcm9vdCB0YXJnZXRcXG5cXHRcXHQvLyBvYmplY3QgKHRoaXMgbWV0aG9kIGFsbG9jYXRlcyBhIGxvdCBvZiBkeW5hbWljIG1lbW9yeSBpbiBjYXNlIGFcXG5cXHRcXHQvLyBwcmV2aW91c2x5IHVua25vd24gY2xpcC9yb290IGNvbWJpbmF0aW9uIGlzIHNwZWNpZmllZClcXG5cXHRcXHRjbGlwQWN0aW9uOiBmdW5jdGlvbiAoIGNsaXAsIG9wdGlvbmFsUm9vdCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcm9vdCA9IG9wdGlvbmFsUm9vdCB8fCB0aGlzLl9yb290LFxcblxcdFxcdFxcdFxcdHJvb3RVdWlkID0gcm9vdC51dWlkLFxcblxcblxcdFxcdFxcdFxcdGNsaXBPYmplY3QgPSB0eXBlb2YgY2xpcCA9PT0gJ3N0cmluZycgP1xcblxcdFxcdFxcdFxcdFxcdEFuaW1hdGlvbkNsaXAuZmluZEJ5TmFtZSggcm9vdCwgY2xpcCApIDogY2xpcCxcXG5cXG5cXHRcXHRcXHRcXHRjbGlwVXVpZCA9IGNsaXBPYmplY3QgIT09IG51bGwgPyBjbGlwT2JqZWN0LnV1aWQgOiBjbGlwLFxcblxcblxcdFxcdFxcdFxcdGFjdGlvbnNGb3JDbGlwID0gdGhpcy5fYWN0aW9uc0J5Q2xpcFsgY2xpcFV1aWQgXSxcXG5cXHRcXHRcXHRcXHRwcm90b3R5cGVBY3Rpb24gPSBudWxsO1xcblxcblxcdFxcdFxcdGlmICggYWN0aW9uc0ZvckNsaXAgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgZXhpc3RpbmdBY3Rpb24gPVxcblxcdFxcdFxcdFxcdFxcdFxcdGFjdGlvbnNGb3JDbGlwLmFjdGlvbkJ5Um9vdFsgcm9vdFV1aWQgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGV4aXN0aW5nQWN0aW9uICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGV4aXN0aW5nQWN0aW9uO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHQvLyB3ZSBrbm93IHRoZSBjbGlwLCBzbyB3ZSBkb24ndCBoYXZlIHRvIHBhcnNlIGFsbFxcblxcdFxcdFxcdFxcdC8vIHRoZSBiaW5kaW5ncyBhZ2FpbiBidXQgY2FuIGp1c3QgY29weVxcblxcdFxcdFxcdFxcdHByb3RvdHlwZUFjdGlvbiA9IGFjdGlvbnNGb3JDbGlwLmtub3duQWN0aW9uc1sgMCBdO1xcblxcblxcdFxcdFxcdFxcdC8vIGFsc28sIHRha2UgdGhlIGNsaXAgZnJvbSB0aGUgcHJvdG90eXBlIGFjdGlvblxcblxcdFxcdFxcdFxcdGlmICggY2xpcE9iamVjdCA9PT0gbnVsbCApXFxuXFx0XFx0XFx0XFx0XFx0Y2xpcE9iamVjdCA9IHByb3RvdHlwZUFjdGlvbi5fY2xpcDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gY2xpcCBtdXN0IGJlIGtub3duIHdoZW4gc3BlY2lmaWVkIHZpYSBzdHJpbmdcXG5cXHRcXHRcXHRpZiAoIGNsaXBPYmplY3QgPT09IG51bGwgKSByZXR1cm4gbnVsbDtcXG5cXG5cXHRcXHRcXHQvLyBhbGxvY2F0ZSBhbGwgcmVzb3VyY2VzIHJlcXVpcmVkIHRvIHJ1biBpdFxcblxcdFxcdFxcdHZhciBuZXdBY3Rpb24gPSBuZXcgQW5pbWF0aW9uQWN0aW9uKCB0aGlzLCBjbGlwT2JqZWN0LCBvcHRpb25hbFJvb3QgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9iaW5kQWN0aW9uKCBuZXdBY3Rpb24sIHByb3RvdHlwZUFjdGlvbiApO1xcblxcblxcdFxcdFxcdC8vIGFuZCBtYWtlIHRoZSBhY3Rpb24ga25vd24gdG8gdGhlIG1lbW9yeSBtYW5hZ2VyXFxuXFx0XFx0XFx0dGhpcy5fYWRkSW5hY3RpdmVBY3Rpb24oIG5ld0FjdGlvbiwgY2xpcFV1aWQsIHJvb3RVdWlkICk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ld0FjdGlvbjtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIGdldCBhbiBleGlzdGluZyBhY3Rpb25cXG5cXHRcXHRleGlzdGluZ0FjdGlvbjogZnVuY3Rpb24gKCBjbGlwLCBvcHRpb25hbFJvb3QgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIHJvb3QgPSBvcHRpb25hbFJvb3QgfHwgdGhpcy5fcm9vdCxcXG5cXHRcXHRcXHRcXHRyb290VXVpZCA9IHJvb3QudXVpZCxcXG5cXG5cXHRcXHRcXHRcXHRjbGlwT2JqZWN0ID0gdHlwZW9mIGNsaXAgPT09ICdzdHJpbmcnID9cXG5cXHRcXHRcXHRcXHRcXHRBbmltYXRpb25DbGlwLmZpbmRCeU5hbWUoIHJvb3QsIGNsaXAgKSA6IGNsaXAsXFxuXFxuXFx0XFx0XFx0XFx0Y2xpcFV1aWQgPSBjbGlwT2JqZWN0ID8gY2xpcE9iamVjdC51dWlkIDogY2xpcCxcXG5cXG5cXHRcXHRcXHRcXHRhY3Rpb25zRm9yQ2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF07XFxuXFxuXFx0XFx0XFx0aWYgKCBhY3Rpb25zRm9yQ2xpcCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiBhY3Rpb25zRm9yQ2xpcC5hY3Rpb25CeVJvb3RbIHJvb3RVdWlkIF0gfHwgbnVsbDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG51bGw7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBkZWFjdGl2YXRlcyBhbGwgcHJldmlvdXNseSBzY2hlZHVsZWQgYWN0aW9uc1xcblxcdFxcdHN0b3BBbGxBY3Rpb246IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXFxuXFx0XFx0XFx0XFx0bkFjdGlvbnMgPSB0aGlzLl9uQWN0aXZlQWN0aW9ucyxcXG5cXHRcXHRcXHRcXHRiaW5kaW5ncyA9IHRoaXMuX2JpbmRpbmdzLFxcblxcdFxcdFxcdFxcdG5CaW5kaW5ncyA9IHRoaXMuX25BY3RpdmVCaW5kaW5ncztcXG5cXG5cXHRcXHRcXHR0aGlzLl9uQWN0aXZlQWN0aW9ucyA9IDA7XFxuXFx0XFx0XFx0dGhpcy5fbkFjdGl2ZUJpbmRpbmdzID0gMDtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5BY3Rpb25zOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdGFjdGlvbnNbIGkgXS5yZXNldCgpO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgIT09IG5CaW5kaW5nczsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRiaW5kaW5nc1sgaSBdLnVzZUNvdW50ID0gMDtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyBhZHZhbmNlIHRoZSB0aW1lIGFuZCB1cGRhdGUgYXBwbHkgdGhlIGFuaW1hdGlvblxcblxcdFxcdHVwZGF0ZTogZnVuY3Rpb24gKCBkZWx0YVRpbWUgKSB7XFxuXFxuXFx0XFx0XFx0ZGVsdGFUaW1lICo9IHRoaXMudGltZVNjYWxlO1xcblxcblxcdFxcdFxcdHZhciBhY3Rpb25zID0gdGhpcy5fYWN0aW9ucyxcXG5cXHRcXHRcXHRcXHRuQWN0aW9ucyA9IHRoaXMuX25BY3RpdmVBY3Rpb25zLFxcblxcblxcdFxcdFxcdFxcdHRpbWUgPSB0aGlzLnRpbWUgKz0gZGVsdGFUaW1lLFxcblxcdFxcdFxcdFxcdHRpbWVEaXJlY3Rpb24gPSBNYXRoLnNpZ24oIGRlbHRhVGltZSApLFxcblxcblxcdFxcdFxcdFxcdGFjY3VJbmRleCA9IHRoaXMuX2FjY3VJbmRleCBePSAxO1xcblxcblxcdFxcdFxcdC8vIHJ1biBhY3RpdmUgYWN0aW9uc1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbkFjdGlvbnM7ICsrIGkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGFjdGlvbiA9IGFjdGlvbnNbIGkgXTtcXG5cXG5cXHRcXHRcXHRcXHRhY3Rpb24uX3VwZGF0ZSggdGltZSwgZGVsdGFUaW1lLCB0aW1lRGlyZWN0aW9uLCBhY2N1SW5kZXggKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Ly8gdXBkYXRlIHNjZW5lIGdyYXBoXFxuXFxuXFx0XFx0XFx0dmFyIGJpbmRpbmdzID0gdGhpcy5fYmluZGluZ3MsXFxuXFx0XFx0XFx0XFx0bkJpbmRpbmdzID0gdGhpcy5fbkFjdGl2ZUJpbmRpbmdzO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMDsgaSAhPT0gbkJpbmRpbmdzOyArKyBpICkge1xcblxcblxcdFxcdFxcdFxcdGJpbmRpbmdzWyBpIF0uYXBwbHkoIGFjY3VJbmRleCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIHJldHVybiB0aGlzIG1peGVyJ3Mgcm9vdCB0YXJnZXQgb2JqZWN0XFxuXFx0XFx0Z2V0Um9vdDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLl9yb290O1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Ly8gZnJlZSBhbGwgcmVzb3VyY2VzIHNwZWNpZmljIHRvIGEgcGFydGljdWxhciBjbGlwXFxuXFx0XFx0dW5jYWNoZUNsaXA6IGZ1bmN0aW9uICggY2xpcCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYWN0aW9ucyA9IHRoaXMuX2FjdGlvbnMsXFxuXFx0XFx0XFx0XFx0Y2xpcFV1aWQgPSBjbGlwLnV1aWQsXFxuXFx0XFx0XFx0XFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXAsXFxuXFx0XFx0XFx0XFx0YWN0aW9uc0ZvckNsaXAgPSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xcblxcblxcdFxcdFxcdGlmICggYWN0aW9uc0ZvckNsaXAgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBub3RlOiBqdXN0IGNhbGxpbmcgX3JlbW92ZUluYWN0aXZlQWN0aW9uIHdvdWxkIG1lc3MgdXAgdGhlXFxuXFx0XFx0XFx0XFx0Ly8gaXRlcmF0aW9uIHN0YXRlIGFuZCBhbHNvIHJlcXVpcmUgdXBkYXRpbmcgdGhlIHN0YXRlIHdlIGNhblxcblxcdFxcdFxcdFxcdC8vIGp1c3QgdGhyb3cgYXdheVxcblxcblxcdFxcdFxcdFxcdHZhciBhY3Rpb25zVG9SZW1vdmUgPSBhY3Rpb25zRm9yQ2xpcC5rbm93bkFjdGlvbnM7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBuID0gYWN0aW9uc1RvUmVtb3ZlLmxlbmd0aDsgaSAhPT0gbjsgKysgaSApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgYWN0aW9uID0gYWN0aW9uc1RvUmVtb3ZlWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fZGVhY3RpdmF0ZUFjdGlvbiggYWN0aW9uICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dmFyIGNhY2hlSW5kZXggPSBhY3Rpb24uX2NhY2hlSW5kZXgsXFxuXFx0XFx0XFx0XFx0XFx0XFx0bGFzdEluYWN0aXZlQWN0aW9uID0gYWN0aW9uc1sgYWN0aW9ucy5sZW5ndGggLSAxIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0YWN0aW9uLl9jYWNoZUluZGV4ID0gbnVsbDtcXG5cXHRcXHRcXHRcXHRcXHRhY3Rpb24uX2J5Q2xpcENhY2hlSW5kZXggPSBudWxsO1xcblxcblxcdFxcdFxcdFxcdFxcdGxhc3RJbmFjdGl2ZUFjdGlvbi5fY2FjaGVJbmRleCA9IGNhY2hlSW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0YWN0aW9uc1sgY2FjaGVJbmRleCBdID0gbGFzdEluYWN0aXZlQWN0aW9uO1xcblxcdFxcdFxcdFxcdFxcdGFjdGlvbnMucG9wKCk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fcmVtb3ZlSW5hY3RpdmVCaW5kaW5nc0ZvckFjdGlvbiggYWN0aW9uICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGRlbGV0ZSBhY3Rpb25zQnlDbGlwWyBjbGlwVXVpZCBdO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIGZyZWUgYWxsIHJlc291cmNlcyBzcGVjaWZpYyB0byBhIHBhcnRpY3VsYXIgcm9vdCB0YXJnZXQgb2JqZWN0XFxuXFx0XFx0dW5jYWNoZVJvb3Q6IGZ1bmN0aW9uICggcm9vdCApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcm9vdFV1aWQgPSByb290LnV1aWQsXFxuXFx0XFx0XFx0XFx0YWN0aW9uc0J5Q2xpcCA9IHRoaXMuX2FjdGlvbnNCeUNsaXA7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGNsaXBVdWlkIGluIGFjdGlvbnNCeUNsaXAgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGFjdGlvbkJ5Um9vdCA9IGFjdGlvbnNCeUNsaXBbIGNsaXBVdWlkIF0uYWN0aW9uQnlSb290LFxcblxcdFxcdFxcdFxcdFxcdGFjdGlvbiA9IGFjdGlvbkJ5Um9vdFsgcm9vdFV1aWQgXTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoIGFjdGlvbiAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oIGFjdGlvbiApO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3JlbW92ZUluYWN0aXZlQWN0aW9uKCBhY3Rpb24gKTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHZhciBiaW5kaW5nc0J5Um9vdCA9IHRoaXMuX2JpbmRpbmdzQnlSb290QW5kTmFtZSxcXG5cXHRcXHRcXHRcXHRiaW5kaW5nQnlOYW1lID0gYmluZGluZ3NCeVJvb3RbIHJvb3RVdWlkIF07XFxuXFxuXFx0XFx0XFx0aWYgKCBiaW5kaW5nQnlOYW1lICE9PSB1bmRlZmluZWQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIHRyYWNrTmFtZSBpbiBiaW5kaW5nQnlOYW1lICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHZhciBiaW5kaW5nID0gYmluZGluZ0J5TmFtZVsgdHJhY2tOYW1lIF07XFxuXFx0XFx0XFx0XFx0XFx0YmluZGluZy5yZXN0b3JlT3JpZ2luYWxTdGF0ZSgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3JlbW92ZUluYWN0aXZlQmluZGluZyggYmluZGluZyApO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyByZW1vdmUgYSB0YXJnZXRlZCBjbGlwIGZyb20gdGhlIGNhY2hlXFxuXFx0XFx0dW5jYWNoZUFjdGlvbjogZnVuY3Rpb24gKCBjbGlwLCBvcHRpb25hbFJvb3QgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGFjdGlvbiA9IHRoaXMuZXhpc3RpbmdBY3Rpb24oIGNsaXAsIG9wdGlvbmFsUm9vdCApO1xcblxcblxcdFxcdFxcdGlmICggYWN0aW9uICE9PSBudWxsICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuX2RlYWN0aXZhdGVBY3Rpb24oIGFjdGlvbiApO1xcblxcdFxcdFxcdFxcdHRoaXMuX3JlbW92ZUluYWN0aXZlQWN0aW9uKCBhY3Rpb24gKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFVuaWZvcm0oIHZhbHVlICkge1xcblxcblxcdFxcdGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Vbmlmb3JtOiBUeXBlIHBhcmFtZXRlciBpcyBubyBsb25nZXIgbmVlZGVkLicgKTtcXG5cXHRcXHRcXHR2YWx1ZSA9IGFyZ3VtZW50c1sgMSBdO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLnZhbHVlID0gdmFsdWU7XFxuXFxuXFx0fVxcblxcblxcdFVuaWZvcm0ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdHJldHVybiBuZXcgVW5pZm9ybSggdGhpcy52YWx1ZS5jbG9uZSA9PT0gdW5kZWZpbmVkID8gdGhpcy52YWx1ZSA6IHRoaXMudmFsdWUuY2xvbmUoKSApO1xcblxcblxcdH07XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkoKSB7XFxuXFxuXFx0XFx0QnVmZmVyR2VvbWV0cnkuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMudHlwZSA9ICdJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeSc7XFxuXFx0XFx0dGhpcy5tYXhJbnN0YW5jZWRDb3VudCA9IHVuZGVmaW5lZDtcXG5cXG5cXHR9XFxuXFxuXFx0SW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQnVmZmVyR2VvbWV0cnkucHJvdG90eXBlICksIHtcXG5cXG5cXHRcXHRjb25zdHJ1Y3RvcjogSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnksXFxuXFxuXFx0XFx0aXNJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeTogdHJ1ZSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRcXHRCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUuY29weS5jYWxsKCB0aGlzLCBzb3VyY2UgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLm1heEluc3RhbmNlZENvdW50ID0gc291cmNlLm1heEluc3RhbmNlZENvdW50O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSggaW50ZXJsZWF2ZWRCdWZmZXIsIGl0ZW1TaXplLCBvZmZzZXQsIG5vcm1hbGl6ZWQgKSB7XFxuXFxuXFx0XFx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XFxuXFxuXFx0XFx0dGhpcy5kYXRhID0gaW50ZXJsZWF2ZWRCdWZmZXI7XFxuXFx0XFx0dGhpcy5pdGVtU2l6ZSA9IGl0ZW1TaXplO1xcblxcdFxcdHRoaXMub2Zmc2V0ID0gb2Zmc2V0O1xcblxcblxcdFxcdHRoaXMubm9ybWFsaXplZCA9IG5vcm1hbGl6ZWQgPT09IHRydWU7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZS5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRjb3VudDoge1xcblxcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmRhdGEuY291bnQ7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0YXJyYXk6IHtcXG5cXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5O1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdE9iamVjdC5hc3NpZ24oIEludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGU6IHRydWUsXFxuXFxuXFx0XFx0c2V0WDogZnVuY3Rpb24gKCBpbmRleCwgeCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0IF0gPSB4O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0WTogZnVuY3Rpb24gKCBpbmRleCwgeSApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMSBdID0geTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFo6IGZ1bmN0aW9uICggaW5kZXgsIHogKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDIgXSA9IHo7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRXOiBmdW5jdGlvbiAoIGluZGV4LCB3ICkge1xcblxcblxcdFxcdFxcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAzIF0gPSB3O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0WDogZnVuY3Rpb24gKCBpbmRleCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCBdO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0WTogZnVuY3Rpb24gKCBpbmRleCApIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5kYXRhLmFycmF5WyBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldCArIDEgXTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldFo6IGZ1bmN0aW9uICggaW5kZXggKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKiB0aGlzLmRhdGEuc3RyaWRlICsgdGhpcy5vZmZzZXQgKyAyIF07XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRnZXRXOiBmdW5jdGlvbiAoIGluZGV4ICkge1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0ICsgMyBdO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0WFk6IGZ1bmN0aW9uICggaW5kZXgsIHgsIHkgKSB7XFxuXFxuXFx0XFx0XFx0aW5kZXggPSBpbmRleCAqIHRoaXMuZGF0YS5zdHJpZGUgKyB0aGlzLm9mZnNldDtcXG5cXG5cXHRcXHRcXHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMCBdID0geDtcXG5cXHRcXHRcXHR0aGlzLmRhdGEuYXJyYXlbIGluZGV4ICsgMSBdID0geTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHNldFhZWjogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiApIHtcXG5cXG5cXHRcXHRcXHRpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xcblxcblxcdFxcdFxcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xcblxcdFxcdFxcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xcblxcdFxcdFxcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0WFlaVzogZnVuY3Rpb24gKCBpbmRleCwgeCwgeSwgeiwgdyApIHtcXG5cXG5cXHRcXHRcXHRpbmRleCA9IGluZGV4ICogdGhpcy5kYXRhLnN0cmlkZSArIHRoaXMub2Zmc2V0O1xcblxcblxcdFxcdFxcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAwIF0gPSB4O1xcblxcdFxcdFxcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAxIF0gPSB5O1xcblxcdFxcdFxcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAyIF0gPSB6O1xcblxcdFxcdFxcdHRoaXMuZGF0YS5hcnJheVsgaW5kZXggKyAzIF0gPSB3O1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBiZW5hYWRhbXMgLyBodHRwczovL3R3aXR0ZXIuY29tL2Jlbl9hX2FkYW1zXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gSW50ZXJsZWF2ZWRCdWZmZXIoIGFycmF5LCBzdHJpZGUgKSB7XFxuXFxuXFx0XFx0dGhpcy51dWlkID0gX01hdGguZ2VuZXJhdGVVVUlEKCk7XFxuXFxuXFx0XFx0dGhpcy5hcnJheSA9IGFycmF5O1xcblxcdFxcdHRoaXMuc3RyaWRlID0gc3RyaWRlO1xcblxcdFxcdHRoaXMuY291bnQgPSBhcnJheSAhPT0gdW5kZWZpbmVkID8gYXJyYXkubGVuZ3RoIC8gc3RyaWRlIDogMDtcXG5cXG5cXHRcXHR0aGlzLmR5bmFtaWMgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLnVwZGF0ZVJhbmdlID0geyBvZmZzZXQ6IDAsIGNvdW50OiAtIDEgfTtcXG5cXG5cXHRcXHR0aGlzLm9uVXBsb2FkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7fTtcXG5cXG5cXHRcXHR0aGlzLnZlcnNpb24gPSAwO1xcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSwgJ25lZWRzVXBkYXRlJywge1xcblxcblxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIHZhbHVlID09PSB0cnVlICkgdGhpcy52ZXJzaW9uICsrO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggSW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0aXNJbnRlcmxlYXZlZEJ1ZmZlcjogdHJ1ZSxcXG5cXG5cXHRcXHRzZXRBcnJheTogZnVuY3Rpb24gKCBhcnJheSApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIEFycmF5LmlzQXJyYXkoIGFycmF5ICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhyb3cgbmV3IFR5cGVFcnJvciggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogYXJyYXkgc2hvdWxkIGJlIGEgVHlwZWQgQXJyYXkuJyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLmNvdW50ID0gYXJyYXkgIT09IHVuZGVmaW5lZCA/IGFycmF5Lmxlbmd0aCAvIHRoaXMuc3RyaWRlIDogMDtcXG5cXHRcXHRcXHR0aGlzLmFycmF5ID0gYXJyYXk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXREeW5hbWljOiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdHRoaXMuZHluYW1pYyA9IHZhbHVlO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5hcnJheSA9IG5ldyBzb3VyY2UuYXJyYXkuY29uc3RydWN0b3IoIHNvdXJjZS5hcnJheSApO1xcblxcdFxcdFxcdHRoaXMuY291bnQgPSBzb3VyY2UuY291bnQ7XFxuXFx0XFx0XFx0dGhpcy5zdHJpZGUgPSBzb3VyY2Uuc3RyaWRlO1xcblxcdFxcdFxcdHRoaXMuZHluYW1pYyA9IHNvdXJjZS5keW5hbWljO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weUF0OiBmdW5jdGlvbiAoIGluZGV4MSwgYXR0cmlidXRlLCBpbmRleDIgKSB7XFxuXFxuXFx0XFx0XFx0aW5kZXgxICo9IHRoaXMuc3RyaWRlO1xcblxcdFxcdFxcdGluZGV4MiAqPSBhdHRyaWJ1dGUuc3RyaWRlO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IHRoaXMuc3RyaWRlOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmFycmF5WyBpbmRleDEgKyBpIF0gPSBhdHRyaWJ1dGUuYXJyYXlbIGluZGV4MiArIGkgXTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIG9mZnNldCA9PT0gdW5kZWZpbmVkICkgb2Zmc2V0ID0gMDtcXG5cXG5cXHRcXHRcXHR0aGlzLmFycmF5LnNldCggdmFsdWUsIG9mZnNldCApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2xvbmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IoKS5jb3B5KCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRvblVwbG9hZDogZnVuY3Rpb24gKCBjYWxsYmFjayApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm9uVXBsb2FkQ2FsbGJhY2sgPSBjYWxsYmFjaztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYmVuYWFkYW1zIC8gaHR0cHM6Ly90d2l0dGVyLmNvbS9iZW5fYV9hZGFtc1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyKCBhcnJheSwgc3RyaWRlLCBtZXNoUGVyQXR0cmlidXRlICkge1xcblxcblxcdFxcdEludGVybGVhdmVkQnVmZmVyLmNhbGwoIHRoaXMsIGFycmF5LCBzdHJpZGUgKTtcXG5cXG5cXHRcXHR0aGlzLm1lc2hQZXJBdHRyaWJ1dGUgPSBtZXNoUGVyQXR0cmlidXRlIHx8IDE7XFxuXFxuXFx0fVxcblxcblxcdEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5hc3NpZ24oIE9iamVjdC5jcmVhdGUoIEludGVybGVhdmVkQnVmZmVyLnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IEluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyLFxcblxcblxcdFxcdGlzSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXI6IHRydWUsXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBzb3VyY2UgKSB7XFxuXFxuXFx0XFx0XFx0SW50ZXJsZWF2ZWRCdWZmZXIucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGJlbmFhZGFtcyAvIGh0dHBzOi8vdHdpdHRlci5jb20vYmVuX2FfYWRhbXNcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSwgbWVzaFBlckF0dHJpYnV0ZSApIHtcXG5cXG5cXHRcXHRCdWZmZXJBdHRyaWJ1dGUuY2FsbCggdGhpcywgYXJyYXksIGl0ZW1TaXplICk7XFxuXFxuXFx0XFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gbWVzaFBlckF0dHJpYnV0ZSB8fCAxO1xcblxcblxcdH1cXG5cXG5cXHRJbnN0YW5jZWRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlID0gT2JqZWN0LmFzc2lnbiggT2JqZWN0LmNyZWF0ZSggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSApLCB7XFxuXFxuXFx0XFx0Y29uc3RydWN0b3I6IEluc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZSxcXG5cXG5cXHRcXHRpc0luc3RhbmNlZEJ1ZmZlckF0dHJpYnV0ZTogdHJ1ZSxcXG5cXG5cXHRcXHRjb3B5OiBmdW5jdGlvbiAoIHNvdXJjZSApIHtcXG5cXG5cXHRcXHRcXHRCdWZmZXJBdHRyaWJ1dGUucHJvdG90eXBlLmNvcHkuY2FsbCggdGhpcywgc291cmNlICk7XFxuXFxuXFx0XFx0XFx0dGhpcy5tZXNoUGVyQXR0cmlidXRlID0gc291cmNlLm1lc2hQZXJBdHRyaWJ1dGU7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgYmhvdXN0b24gLyBodHRwOi8vY2xhcmEuaW8vXFxuXFx0ICogQGF1dGhvciBzdGVwaG9taSAvIGh0dHA6Ly9zdGVwaGFuZWdpbmllci5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gUmF5Y2FzdGVyKCBvcmlnaW4sIGRpcmVjdGlvbiwgbmVhciwgZmFyICkge1xcblxcblxcdFxcdHRoaXMucmF5ID0gbmV3IFJheSggb3JpZ2luLCBkaXJlY3Rpb24gKTtcXG5cXHRcXHQvLyBkaXJlY3Rpb24gaXMgYXNzdW1lZCB0byBiZSBub3JtYWxpemVkIChmb3IgYWNjdXJhdGUgZGlzdGFuY2UgY2FsY3VsYXRpb25zKVxcblxcblxcdFxcdHRoaXMubmVhciA9IG5lYXIgfHwgMDtcXG5cXHRcXHR0aGlzLmZhciA9IGZhciB8fCBJbmZpbml0eTtcXG5cXG5cXHRcXHR0aGlzLnBhcmFtcyA9IHtcXG5cXHRcXHRcXHRNZXNoOiB7fSxcXG5cXHRcXHRcXHRMaW5lOiB7fSxcXG5cXHRcXHRcXHRMT0Q6IHt9LFxcblxcdFxcdFxcdFBvaW50czogeyB0aHJlc2hvbGQ6IDEgfSxcXG5cXHRcXHRcXHRTcHJpdGU6IHt9XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcy5wYXJhbXMsIHtcXG5cXHRcXHRcXHRQb2ludENsb3VkOiB7XFxuXFx0XFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmF5Y2FzdGVyOiBwYXJhbXMuUG9pbnRDbG91ZCBoYXMgYmVlbiByZW5hbWVkIHRvIHBhcmFtcy5Qb2ludHMuJyApO1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiB0aGlzLlBvaW50cztcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gYXNjU29ydCggYSwgYiApIHtcXG5cXG5cXHRcXHRyZXR1cm4gYS5kaXN0YW5jZSAtIGIuZGlzdGFuY2U7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGludGVyc2VjdE9iamVjdCggb2JqZWN0LCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHJlY3Vyc2l2ZSApIHtcXG5cXG5cXHRcXHRpZiAoIG9iamVjdC52aXNpYmxlID09PSBmYWxzZSApIHJldHVybjtcXG5cXG5cXHRcXHRvYmplY3QucmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICk7XFxuXFxuXFx0XFx0aWYgKCByZWN1cnNpdmUgPT09IHRydWUgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGNoaWxkcmVuID0gb2JqZWN0LmNoaWxkcmVuO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0aW50ZXJzZWN0T2JqZWN0KCBjaGlsZHJlblsgaSBdLCByYXljYXN0ZXIsIGludGVyc2VjdHMsIHRydWUgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0fVxcblxcblxcdH1cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBSYXljYXN0ZXIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0bGluZVByZWNpc2lvbjogMSxcXG5cXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggb3JpZ2luLCBkaXJlY3Rpb24gKSB7XFxuXFxuXFx0XFx0XFx0Ly8gZGlyZWN0aW9uIGlzIGFzc3VtZWQgdG8gYmUgbm9ybWFsaXplZCAoZm9yIGFjY3VyYXRlIGRpc3RhbmNlIGNhbGN1bGF0aW9ucylcXG5cXG5cXHRcXHRcXHR0aGlzLnJheS5zZXQoIG9yaWdpbiwgZGlyZWN0aW9uICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tQ2FtZXJhOiBmdW5jdGlvbiAoIGNvb3JkcywgY2FtZXJhICkge1xcblxcblxcdFxcdFxcdGlmICggKCBjYW1lcmEgJiYgY2FtZXJhLmlzUGVyc3BlY3RpdmVDYW1lcmEgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnJheS5vcmlnaW4uc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCBjYW1lcmEubWF0cml4V29ybGQgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnJheS5kaXJlY3Rpb24uc2V0KCBjb29yZHMueCwgY29vcmRzLnksIDAuNSApLnVucHJvamVjdCggY2FtZXJhICkuc3ViKCB0aGlzLnJheS5vcmlnaW4gKS5ub3JtYWxpemUoKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCAoIGNhbWVyYSAmJiBjYW1lcmEuaXNPcnRob2dyYXBoaWNDYW1lcmEgKSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnJheS5vcmlnaW4uc2V0KCBjb29yZHMueCwgY29vcmRzLnksICggY2FtZXJhLm5lYXIgKyBjYW1lcmEuZmFyICkgLyAoIGNhbWVyYS5uZWFyIC0gY2FtZXJhLmZhciApICkudW5wcm9qZWN0KCBjYW1lcmEgKTsgLy8gc2V0IG9yaWdpbiBpbiBwbGFuZSBvZiBjYW1lcmFcXG5cXHRcXHRcXHRcXHR0aGlzLnJheS5kaXJlY3Rpb24uc2V0KCAwLCAwLCAtIDEgKS50cmFuc2Zvcm1EaXJlY3Rpb24oIGNhbWVyYS5tYXRyaXhXb3JsZCApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlJheWNhc3RlcjogVW5zdXBwb3J0ZWQgY2FtZXJhIHR5cGUuJyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGludGVyc2VjdE9iamVjdDogZnVuY3Rpb24gKCBvYmplY3QsIHJlY3Vyc2l2ZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgaW50ZXJzZWN0cyA9IFtdO1xcblxcblxcdFxcdFxcdGludGVyc2VjdE9iamVjdCggb2JqZWN0LCB0aGlzLCBpbnRlcnNlY3RzLCByZWN1cnNpdmUgKTtcXG5cXG5cXHRcXHRcXHRpbnRlcnNlY3RzLnNvcnQoIGFzY1NvcnQgKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gaW50ZXJzZWN0cztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGludGVyc2VjdE9iamVjdHM6IGZ1bmN0aW9uICggb2JqZWN0cywgcmVjdXJzaXZlICkge1xcblxcblxcdFxcdFxcdHZhciBpbnRlcnNlY3RzID0gW107XFxuXFxuXFx0XFx0XFx0aWYgKCBBcnJheS5pc0FycmF5KCBvYmplY3RzICkgPT09IGZhbHNlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlJheWNhc3Rlci5pbnRlcnNlY3RPYmplY3RzOiBvYmplY3RzIGlzIG5vdCBhbiBBcnJheS4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGludGVyc2VjdHM7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IG9iamVjdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRpbnRlcnNlY3RPYmplY3QoIG9iamVjdHNbIGkgXSwgdGhpcywgaW50ZXJzZWN0cywgcmVjdXJzaXZlICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGludGVyc2VjdHMuc29ydCggYXNjU29ydCApO1xcblxcblxcdFxcdFxcdHJldHVybiBpbnRlcnNlY3RzO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBDbG9jayggYXV0b1N0YXJ0ICkge1xcblxcblxcdFxcdHRoaXMuYXV0b1N0YXJ0ID0gKCBhdXRvU3RhcnQgIT09IHVuZGVmaW5lZCApID8gYXV0b1N0YXJ0IDogdHJ1ZTtcXG5cXG5cXHRcXHR0aGlzLnN0YXJ0VGltZSA9IDA7XFxuXFx0XFx0dGhpcy5vbGRUaW1lID0gMDtcXG5cXHRcXHR0aGlzLmVsYXBzZWRUaW1lID0gMDtcXG5cXG5cXHRcXHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggQ2xvY2sucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0c3RhcnQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnN0YXJ0VGltZSA9ICggdHlwZW9mIHBlcmZvcm1hbmNlID09PSAndW5kZWZpbmVkJyA/IERhdGUgOiBwZXJmb3JtYW5jZSApLm5vdygpOyAvLyBzZWUgIzEwNzMyXFxuXFxuXFx0XFx0XFx0dGhpcy5vbGRUaW1lID0gdGhpcy5zdGFydFRpbWU7XFxuXFx0XFx0XFx0dGhpcy5lbGFwc2VkVGltZSA9IDA7XFxuXFx0XFx0XFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdHN0b3A6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmdldEVsYXBzZWRUaW1lKCk7XFxuXFx0XFx0XFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XFxuXFx0XFx0XFx0dGhpcy5hdXRvU3RhcnQgPSBmYWxzZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldEVsYXBzZWRUaW1lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5nZXREZWx0YSgpO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmVsYXBzZWRUaW1lO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Z2V0RGVsdGE6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgZGlmZiA9IDA7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLmF1dG9TdGFydCAmJiAhIHRoaXMucnVubmluZyApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnN0YXJ0KCk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIDA7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICggdGhpcy5ydW5uaW5nICkge1xcblxcblxcdFxcdFxcdFxcdHZhciBuZXdUaW1lID0gKCB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICd1bmRlZmluZWQnID8gRGF0ZSA6IHBlcmZvcm1hbmNlICkubm93KCk7XFxuXFxuXFx0XFx0XFx0XFx0ZGlmZiA9ICggbmV3VGltZSAtIHRoaXMub2xkVGltZSApIC8gMTAwMDtcXG5cXHRcXHRcXHRcXHR0aGlzLm9sZFRpbWUgPSBuZXdUaW1lO1xcblxcblxcdFxcdFxcdFxcdHRoaXMuZWxhcHNlZFRpbWUgKz0gZGlmZjtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGRpZmY7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxuXFx0ICpcXG5cXHQgKiBSZWY6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1NwaGVyaWNhbF9jb29yZGluYXRlX3N5c3RlbVxcblxcdCAqXFxuXFx0ICogVGhlIHBvbGVzIChwaGkpIGFyZSBhdCB0aGUgcG9zaXRpdmUgYW5kIG5lZ2F0aXZlIHkgYXhpcy5cXG5cXHQgKiBUaGUgZXF1YXRvciBzdGFydHMgYXQgcG9zaXRpdmUgei5cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBTcGhlcmljYWwoIHJhZGl1cywgcGhpLCB0aGV0YSApIHtcXG5cXG5cXHRcXHR0aGlzLnJhZGl1cyA9ICggcmFkaXVzICE9PSB1bmRlZmluZWQgKSA/IHJhZGl1cyA6IDEuMDtcXG5cXHRcXHR0aGlzLnBoaSA9ICggcGhpICE9PSB1bmRlZmluZWQgKSA/IHBoaSA6IDA7IC8vIHVwIC8gZG93biB0b3dhcmRzIHRvcCBhbmQgYm90dG9tIHBvbGVcXG5cXHRcXHR0aGlzLnRoZXRhID0gKCB0aGV0YSAhPT0gdW5kZWZpbmVkICkgPyB0aGV0YSA6IDA7IC8vIGFyb3VuZCB0aGUgZXF1YXRvciBvZiB0aGUgc3BoZXJlXFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fVxcblxcblxcdE9iamVjdC5hc3NpZ24oIFNwaGVyaWNhbC5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggcmFkaXVzLCBwaGksIHRoZXRhICkge1xcblxcblxcdFxcdFxcdHRoaXMucmFkaXVzID0gcmFkaXVzO1xcblxcdFxcdFxcdHRoaXMucGhpID0gcGhpO1xcblxcdFxcdFxcdHRoaXMudGhldGEgPSB0aGV0YTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNsb25lOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkuY29weSggdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y29weTogZnVuY3Rpb24gKCBvdGhlciApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnJhZGl1cyA9IG90aGVyLnJhZGl1cztcXG5cXHRcXHRcXHR0aGlzLnBoaSA9IG90aGVyLnBoaTtcXG5cXHRcXHRcXHR0aGlzLnRoZXRhID0gb3RoZXIudGhldGE7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHQvLyByZXN0cmljdCBwaGkgdG8gYmUgYmV0d2VlIEVQUyBhbmQgUEktRVBTXFxuXFx0XFx0bWFrZVNhZmU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgRVBTID0gMC4wMDAwMDE7XFxuXFx0XFx0XFx0dGhpcy5waGkgPSBNYXRoLm1heCggRVBTLCBNYXRoLm1pbiggTWF0aC5QSSAtIEVQUywgdGhpcy5waGkgKSApO1xcblxcblxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2V0RnJvbVZlY3RvcjM6IGZ1bmN0aW9uICggdmVjMyApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLnJhZGl1cyA9IHZlYzMubGVuZ3RoKCk7XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLnJhZGl1cyA9PT0gMCApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnRoZXRhID0gMDtcXG5cXHRcXHRcXHRcXHR0aGlzLnBoaSA9IDA7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnRoZXRhID0gTWF0aC5hdGFuMiggdmVjMy54LCB2ZWMzLnogKTsgLy8gZXF1YXRvciBhbmdsZSBhcm91bmQgeS11cCBheGlzXFxuXFx0XFx0XFx0XFx0dGhpcy5waGkgPSBNYXRoLmFjb3MoIF9NYXRoLmNsYW1wKCB2ZWMzLnkgLyB0aGlzLnJhZGl1cywgLSAxLCAxICkgKTsgLy8gcG9sYXIgYW5nbGVcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqXFxuXFx0ICogUmVmOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9DeWxpbmRyaWNhbF9jb29yZGluYXRlX3N5c3RlbVxcblxcdCAqXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gQ3lsaW5kcmljYWwoIHJhZGl1cywgdGhldGEsIHkgKSB7XFxuXFxuXFx0XFx0dGhpcy5yYWRpdXMgPSAoIHJhZGl1cyAhPT0gdW5kZWZpbmVkICkgPyByYWRpdXMgOiAxLjA7IC8vIGRpc3RhbmNlIGZyb20gdGhlIG9yaWdpbiB0byBhIHBvaW50IGluIHRoZSB4LXogcGxhbmVcXG5cXHRcXHR0aGlzLnRoZXRhID0gKCB0aGV0YSAhPT0gdW5kZWZpbmVkICkgPyB0aGV0YSA6IDA7IC8vIGNvdW50ZXJjbG9ja3dpc2UgYW5nbGUgaW4gdGhlIHgteiBwbGFuZSBtZWFzdXJlZCBpbiByYWRpYW5zIGZyb20gdGhlIHBvc2l0aXZlIHotYXhpc1xcblxcdFxcdHRoaXMueSA9ICggeSAhPT0gdW5kZWZpbmVkICkgPyB5IDogMDsgLy8gaGVpZ2h0IGFib3ZlIHRoZSB4LXogcGxhbmVcXG5cXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggQ3lsaW5kcmljYWwucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoIHJhZGl1cywgdGhldGEsIHkgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5yYWRpdXMgPSByYWRpdXM7XFxuXFx0XFx0XFx0dGhpcy50aGV0YSA9IHRoZXRhO1xcblxcdFxcdFxcdHRoaXMueSA9IHk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRjbG9uZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpLmNvcHkoIHRoaXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNvcHk6IGZ1bmN0aW9uICggb3RoZXIgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5yYWRpdXMgPSBvdGhlci5yYWRpdXM7XFxuXFx0XFx0XFx0dGhpcy50aGV0YSA9IG90aGVyLnRoZXRhO1xcblxcdFxcdFxcdHRoaXMueSA9IG90aGVyLnk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzZXRGcm9tVmVjdG9yMzogZnVuY3Rpb24gKCB2ZWMzICkge1xcblxcblxcdFxcdFxcdHRoaXMucmFkaXVzID0gTWF0aC5zcXJ0KCB2ZWMzLnggKiB2ZWMzLnggKyB2ZWMzLnogKiB2ZWMzLnogKTtcXG5cXHRcXHRcXHR0aGlzLnRoZXRhID0gTWF0aC5hdGFuMiggdmVjMy54LCB2ZWMzLnogKTtcXG5cXHRcXHRcXHR0aGlzLnkgPSB2ZWMzLnk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEltbWVkaWF0ZVJlbmRlck9iamVjdCggbWF0ZXJpYWwgKSB7XFxuXFxuXFx0XFx0T2JqZWN0M0QuY2FsbCggdGhpcyApO1xcblxcblxcdFxcdHRoaXMubWF0ZXJpYWwgPSBtYXRlcmlhbDtcXG5cXHRcXHR0aGlzLnJlbmRlciA9IGZ1bmN0aW9uICggLyogcmVuZGVyQ2FsbGJhY2sgKi8gKSB7fTtcXG5cXG5cXHR9XFxuXFxuXFx0SW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApO1xcblxcdEltbWVkaWF0ZVJlbmRlck9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBJbW1lZGlhdGVSZW5kZXJPYmplY3Q7XFxuXFxuXFx0SW1tZWRpYXRlUmVuZGVyT2JqZWN0LnByb3RvdHlwZS5pc0ltbWVkaWF0ZVJlbmRlck9iamVjdCA9IHRydWU7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBWZXJ0ZXhOb3JtYWxzSGVscGVyKCBvYmplY3QsIHNpemUsIGhleCwgbGluZXdpZHRoICkge1xcblxcblxcdFxcdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xcblxcblxcdFxcdHRoaXMuc2l6ZSA9ICggc2l6ZSAhPT0gdW5kZWZpbmVkICkgPyBzaXplIDogMTtcXG5cXG5cXHRcXHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmMDAwMDtcXG5cXG5cXHRcXHR2YXIgd2lkdGggPSAoIGxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgPyBsaW5ld2lkdGggOiAxO1xcblxcblxcdFxcdC8vXFxuXFxuXFx0XFx0dmFyIG5Ob3JtYWxzID0gMDtcXG5cXG5cXHRcXHR2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcXG5cXG5cXHRcXHRpZiAoIG9iakdlb21ldHJ5ICYmIG9iakdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0bk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5mYWNlcy5sZW5ndGggKiAzO1xcblxcblxcdFxcdH0gZWxzZSBpZiAoIG9iakdlb21ldHJ5ICYmIG9iakdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0bk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbC5jb3VudDtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly9cXG5cXG5cXHRcXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXG5cXG5cXHRcXHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5Ob3JtYWxzICogMiAqIDMsIDMgKTtcXG5cXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucyApO1xcblxcblxcdFxcdExpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgbGluZXdpZHRoOiB3aWR0aCB9ICkgKTtcXG5cXG5cXHRcXHQvL1xcblxcblxcdFxcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMudXBkYXRlKCk7XFxuXFxuXFx0fVxcblxcblxcdFZlcnRleE5vcm1hbHNIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xcblxcdFZlcnRleE5vcm1hbHNIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVmVydGV4Tm9ybWFsc0hlbHBlcjtcXG5cXG5cXHRWZXJ0ZXhOb3JtYWxzSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSAoIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dmFyIG5vcm1hbE1hdHJpeCA9IG5ldyBNYXRyaXgzKCk7XFxuXFxuXFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcXG5cXG5cXHRcXHRcXHR2YXIga2V5cyA9IFsgJ2EnLCAnYicsICdjJyBdO1xcblxcblxcdFxcdFxcdHRoaXMub2JqZWN0LnVwZGF0ZU1hdHJpeFdvcmxkKCB0cnVlICk7XFxuXFxuXFx0XFx0XFx0bm9ybWFsTWF0cml4LmdldE5vcm1hbE1hdHJpeCggdGhpcy5vYmplY3QubWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHR2YXIgbWF0cml4V29ybGQgPSB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZDtcXG5cXG5cXHRcXHRcXHR2YXIgcG9zaXRpb24gPSB0aGlzLmdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XFxuXFxuXFx0XFx0XFx0Ly9cXG5cXG5cXHRcXHRcXHR2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcXG5cXG5cXHRcXHRcXHRpZiAoIG9iakdlb21ldHJ5ICYmIG9iakdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHZlcnRpY2VzID0gb2JqR2VvbWV0cnkudmVydGljZXM7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGZhY2VzID0gb2JqR2VvbWV0cnkuZmFjZXM7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGlkeCA9IDA7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gZmFjZXMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgZmFjZSA9IGZhY2VzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IGZhY2UudmVydGV4Tm9ybWFscy5sZW5ndGg7IGogPCBqbDsgaiArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2YXIgdmVydGV4ID0gdmVydGljZXNbIGZhY2VbIGtleXNbIGogXSBdIF07XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0dmFyIG5vcm1hbCA9IGZhY2UudmVydGV4Tm9ybWFsc1sgaiBdO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHYxLmNvcHkoIHZlcnRleCApLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHR2Mi5jb3B5KCBub3JtYWwgKS5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKS5hZGQoIHYxICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRcXHRpZHggPSBpZHggKyAxO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2Mi54LCB2Mi55LCB2Mi56ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0XFx0aWR4ID0gaWR4ICsgMTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH0gZWxzZSBpZiAoIG9iakdlb21ldHJ5ICYmIG9iakdlb21ldHJ5LmlzQnVmZmVyR2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG9ialBvcyA9IG9iakdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XFxuXFxuXFx0XFx0XFx0XFx0dmFyIG9iak5vcm0gPSBvYmpHZW9tZXRyeS5hdHRyaWJ1dGVzLm5vcm1hbDtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgaWR4ID0gMDtcXG5cXG5cXHRcXHRcXHRcXHQvLyBmb3Igc2ltcGxpY2l0eSwgaWdub3JlIGluZGV4IGFuZCBkcmF3Y2FsbHMsIGFuZCByZW5kZXIgZXZlcnkgbm9ybWFsXFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGogPSAwLCBqbCA9IG9ialBvcy5jb3VudDsgaiA8IGpsOyBqICsrICkge1xcblxcblxcdFxcdFxcdFxcdFxcdHYxLnNldCggb2JqUG9zLmdldFgoIGogKSwgb2JqUG9zLmdldFkoIGogKSwgb2JqUG9zLmdldFooIGogKSApLmFwcGx5TWF0cml4NCggbWF0cml4V29ybGQgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2Mi5zZXQoIG9iak5vcm0uZ2V0WCggaiApLCBvYmpOb3JtLmdldFkoIGogKSwgb2JqTm9ybS5nZXRaKCBqICkgKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2Mi5hcHBseU1hdHJpeDMoIG5vcm1hbE1hdHJpeCApLm5vcm1hbGl6ZSgpLm11bHRpcGx5U2NhbGFyKCB0aGlzLnNpemUgKS5hZGQoIHYxICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYxLngsIHYxLnksIHYxLnogKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZHggPSBpZHggKyAxO1xcblxcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uLnNldFhZWiggaWR4LCB2Mi54LCB2Mi55LCB2Mi56ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWR4ID0gaWR4ICsgMTtcXG5cXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdH0oKSApO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBTcG90TGlnaHRIZWxwZXIoIGxpZ2h0LCBjb2xvciApIHtcXG5cXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy5saWdodCA9IGxpZ2h0O1xcblxcdFxcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcXG5cXG5cXHRcXHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xcblxcdFxcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMuY29sb3IgPSBjb2xvcjtcXG5cXG5cXHRcXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXG5cXG5cXHRcXHR2YXIgcG9zaXRpb25zID0gW1xcblxcdFxcdFxcdDAsIDAsIDAsIFxcdDAsIDAsIDEsXFxuXFx0XFx0XFx0MCwgMCwgMCwgXFx0MSwgMCwgMSxcXG5cXHRcXHRcXHQwLCAwLCAwLFxcdC0gMSwgMCwgMSxcXG5cXHRcXHRcXHQwLCAwLCAwLCBcXHQwLCAxLCAxLFxcblxcdFxcdFxcdDAsIDAsIDAsIFxcdDAsIC0gMSwgMVxcblxcdFxcdF07XFxuXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwLCBqID0gMSwgbCA9IDMyOyBpIDwgbDsgaSArKywgaiArKyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgcDEgPSAoIGkgLyBsICkgKiBNYXRoLlBJICogMjtcXG5cXHRcXHRcXHR2YXIgcDIgPSAoIGogLyBsICkgKiBNYXRoLlBJICogMjtcXG5cXG5cXHRcXHRcXHRwb3NpdGlvbnMucHVzaChcXG5cXHRcXHRcXHRcXHRNYXRoLmNvcyggcDEgKSwgTWF0aC5zaW4oIHAxICksIDEsXFxuXFx0XFx0XFx0XFx0TWF0aC5jb3MoIHAyICksIE1hdGguc2luKCBwMiApLCAxXFxuXFx0XFx0XFx0KTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCAzICkgKTtcXG5cXG5cXHRcXHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgZm9nOiBmYWxzZSB9ICk7XFxuXFxuXFx0XFx0dGhpcy5jb25lID0gbmV3IExpbmVTZWdtZW50cyggZ2VvbWV0cnksIG1hdGVyaWFsICk7XFxuXFx0XFx0dGhpcy5hZGQoIHRoaXMuY29uZSApO1xcblxcblxcdFxcdHRoaXMudXBkYXRlKCk7XFxuXFxuXFx0fVxcblxcblxcdFNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBPYmplY3QzRC5wcm90b3R5cGUgKTtcXG5cXHRTcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU3BvdExpZ2h0SGVscGVyO1xcblxcblxcdFNwb3RMaWdodEhlbHBlci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHR0aGlzLmNvbmUuZ2VvbWV0cnkuZGlzcG9zZSgpO1xcblxcdFxcdHRoaXMuY29uZS5tYXRlcmlhbC5kaXNwb3NlKCk7XFxuXFxuXFx0fTtcXG5cXG5cXHRTcG90TGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR2YXIgdmVjdG9yMiA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmxpZ2h0LnVwZGF0ZU1hdHJpeFdvcmxkKCk7XFxuXFxuXFx0XFx0XFx0dmFyIGNvbmVMZW5ndGggPSB0aGlzLmxpZ2h0LmRpc3RhbmNlID8gdGhpcy5saWdodC5kaXN0YW5jZSA6IDEwMDA7XFxuXFx0XFx0XFx0dmFyIGNvbmVXaWR0aCA9IGNvbmVMZW5ndGggKiBNYXRoLnRhbiggdGhpcy5saWdodC5hbmdsZSApO1xcblxcblxcdFxcdFxcdHRoaXMuY29uZS5zY2FsZS5zZXQoIGNvbmVXaWR0aCwgY29uZVdpZHRoLCBjb25lTGVuZ3RoICk7XFxuXFxuXFx0XFx0XFx0dmVjdG9yLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdHZlY3RvcjIuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0LnRhcmdldC5tYXRyaXhXb3JsZCApO1xcblxcblxcdFxcdFxcdHRoaXMuY29uZS5sb29rQXQoIHZlY3RvcjIuc3ViKCB2ZWN0b3IgKSApO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5jb2xvciAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5zZXQoIHRoaXMuY29sb3IgKTtcXG5cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdFxcdHRoaXMuY29uZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH07XFxuXFxuXFx0fSgpO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgU2VhbiBHcmlmZmluIC8gaHR0cDovL3R3aXR0ZXIuY29tL3NncmlmXFxuXFx0ICogQGF1dGhvciBNaWNoYWVsIEd1ZXJyZXJvIC8gaHR0cDovL3JlYWxpdHltZWx0ZG93bi5jb21cXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqIEBhdXRob3IgaWtlcnIgLyBodHRwOi8vdmVyb2xkLmNvbVxcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gZ2V0Qm9uZUxpc3QoIG9iamVjdCApIHtcXG5cXG5cXHRcXHR2YXIgYm9uZUxpc3QgPSBbXTtcXG5cXG5cXHRcXHRpZiAoIG9iamVjdCAmJiBvYmplY3QuaXNCb25lICkge1xcblxcblxcdFxcdFxcdGJvbmVMaXN0LnB1c2goIG9iamVjdCApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRmb3IgKCB2YXIgaSA9IDA7IGkgPCBvYmplY3QuY2hpbGRyZW4ubGVuZ3RoOyBpICsrICkge1xcblxcblxcdFxcdFxcdGJvbmVMaXN0LnB1c2guYXBwbHkoIGJvbmVMaXN0LCBnZXRCb25lTGlzdCggb2JqZWN0LmNoaWxkcmVuWyBpIF0gKSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gYm9uZUxpc3Q7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFNrZWxldG9uSGVscGVyKCBvYmplY3QgKSB7XFxuXFxuXFx0XFx0dmFyIGJvbmVzID0gZ2V0Qm9uZUxpc3QoIG9iamVjdCApO1xcblxcblxcdFxcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcblxcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdO1xcblxcdFxcdHZhciBjb2xvcnMgPSBbXTtcXG5cXG5cXHRcXHR2YXIgY29sb3IxID0gbmV3IENvbG9yKCAwLCAwLCAxICk7XFxuXFx0XFx0dmFyIGNvbG9yMiA9IG5ldyBDb2xvciggMCwgMSwgMCApO1xcblxcblxcdFxcdGZvciAoIHZhciBpID0gMDsgaSA8IGJvbmVzLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYm9uZSA9IGJvbmVzWyBpIF07XFxuXFxuXFx0XFx0XFx0aWYgKCBib25lLnBhcmVudCAmJiBib25lLnBhcmVudC5pc0JvbmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xcblxcdFxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIDAsIDAsIDAgKTtcXG5cXHRcXHRcXHRcXHRjb2xvcnMucHVzaCggY29sb3IxLnIsIGNvbG9yMS5nLCBjb2xvcjEuYiApO1xcblxcdFxcdFxcdFxcdGNvbG9ycy5wdXNoKCBjb2xvcjIuciwgY29sb3IyLmcsIGNvbG9yMi5iICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcXG5cXG5cXHRcXHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBWZXJ0ZXhDb2xvcnMsIGRlcHRoVGVzdDogZmFsc2UsIGRlcHRoV3JpdGU6IGZhbHNlLCB0cmFuc3BhcmVudDogdHJ1ZSB9ICk7XFxuXFxuXFx0XFx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xcblxcblxcdFxcdHRoaXMucm9vdCA9IG9iamVjdDtcXG5cXHRcXHR0aGlzLmJvbmVzID0gYm9uZXM7XFxuXFxuXFx0XFx0dGhpcy5tYXRyaXggPSBvYmplY3QubWF0cml4V29ybGQ7XFxuXFx0XFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XFxuXFxuXFx0fVxcblxcblxcdFNrZWxldG9uSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcXG5cXHRTa2VsZXRvbkhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTa2VsZXRvbkhlbHBlcjtcXG5cXG5cXHRTa2VsZXRvbkhlbHBlci5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0dmFyIGJvbmVNYXRyaXggPSBuZXcgTWF0cml4NCgpO1xcblxcdFxcdHZhciBtYXRyaXhXb3JsZEludiA9IG5ldyBNYXRyaXg0KCk7XFxuXFxuXFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZU1hdHJpeFdvcmxkKCBmb3JjZSApIHtcXG5cXG5cXHRcXHRcXHR2YXIgYm9uZXMgPSB0aGlzLmJvbmVzO1xcblxcblxcdFxcdFxcdHZhciBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XFxuXFx0XFx0XFx0dmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XFxuXFxuXFx0XFx0XFx0bWF0cml4V29ybGRJbnYuZ2V0SW52ZXJzZSggdGhpcy5yb290Lm1hdHJpeFdvcmxkICk7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBqID0gMDsgaSA8IGJvbmVzLmxlbmd0aDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgYm9uZSA9IGJvbmVzWyBpIF07XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCBib25lLnBhcmVudCAmJiBib25lLnBhcmVudC5pc0JvbmUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0XFx0Ym9uZU1hdHJpeC5tdWx0aXBseU1hdHJpY2VzKCBtYXRyaXhXb3JsZEludiwgYm9uZS5tYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdFxcdFxcdHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGJvbmVNYXRyaXggKTtcXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi5zZXRYWVooIGosIHZlY3Rvci54LCB2ZWN0b3IueSwgdmVjdG9yLnogKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRib25lTWF0cml4Lm11bHRpcGx5TWF0cmljZXMoIG1hdHJpeFdvcmxkSW52LCBib25lLnBhcmVudC5tYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdFxcdFxcdHZlY3Rvci5zZXRGcm9tTWF0cml4UG9zaXRpb24oIGJvbmVNYXRyaXggKTtcXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi5zZXRYWVooIGogKyAxLCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56ICk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aiArPSAyO1xcblxcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Z2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICkubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdFxcdE9iamVjdDNELnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZC5jYWxsKCB0aGlzLCBmb3JjZSApO1xcblxcblxcdFxcdH07XFxuXFxuXFx0fSgpO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBQb2ludExpZ2h0SGVscGVyKCBsaWdodCwgc3BoZXJlU2l6ZSwgY29sb3IgKSB7XFxuXFxuXFx0XFx0dGhpcy5saWdodCA9IGxpZ2h0O1xcblxcdFxcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcXG5cXG5cXHRcXHR0aGlzLmNvbG9yID0gY29sb3I7XFxuXFxuXFx0XFx0dmFyIGdlb21ldHJ5ID0gbmV3IFNwaGVyZUJ1ZmZlckdlb21ldHJ5KCBzcGhlcmVTaXplLCA0LCAyICk7XFxuXFx0XFx0dmFyIG1hdGVyaWFsID0gbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IHdpcmVmcmFtZTogdHJ1ZSwgZm9nOiBmYWxzZSB9ICk7XFxuXFxuXFx0XFx0TWVzaC5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcXG5cXG5cXHRcXHR0aGlzLm1hdHJpeCA9IHRoaXMubGlnaHQubWF0cml4V29ybGQ7XFxuXFx0XFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XFxuXFxuXFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXG5cXG5cXHRcXHQvKlxcblxcdFxcdHZhciBkaXN0YW5jZUdlb21ldHJ5ID0gbmV3IFRIUkVFLkljb3NhaGVkcm9uR2VvbWV0cnkoIDEsIDIgKTtcXG5cXHRcXHR2YXIgZGlzdGFuY2VNYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogaGV4Q29sb3IsIGZvZzogZmFsc2UsIHdpcmVmcmFtZTogdHJ1ZSwgb3BhY2l0eTogMC4xLCB0cmFuc3BhcmVudDogdHJ1ZSB9ICk7XFxuXFxuXFx0XFx0dGhpcy5saWdodFNwaGVyZSA9IG5ldyBUSFJFRS5NZXNoKCBidWxiR2VvbWV0cnksIGJ1bGJNYXRlcmlhbCApO1xcblxcdFxcdHRoaXMubGlnaHREaXN0YW5jZSA9IG5ldyBUSFJFRS5NZXNoKCBkaXN0YW5jZUdlb21ldHJ5LCBkaXN0YW5jZU1hdGVyaWFsICk7XFxuXFxuXFx0XFx0dmFyIGQgPSBsaWdodC5kaXN0YW5jZTtcXG5cXG5cXHRcXHRpZiAoIGQgPT09IDAuMCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmxpZ2h0RGlzdGFuY2UudmlzaWJsZSA9IGZhbHNlO1xcblxcblxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5saWdodERpc3RhbmNlLnNjYWxlLnNldCggZCwgZCwgZCApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLmFkZCggdGhpcy5saWdodERpc3RhbmNlICk7XFxuXFx0XFx0Ki9cXG5cXG5cXHR9XFxuXFxuXFx0UG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNZXNoLnByb3RvdHlwZSApO1xcblxcdFBvaW50TGlnaHRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9pbnRMaWdodEhlbHBlcjtcXG5cXG5cXHRQb2ludExpZ2h0SGVscGVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdHRoaXMuZ2VvbWV0cnkuZGlzcG9zZSgpO1xcblxcdFxcdHRoaXMubWF0ZXJpYWwuZGlzcG9zZSgpO1xcblxcblxcdH07XFxuXFxuXFx0UG9pbnRMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdGlmICggdGhpcy5jb2xvciAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdHRoaXMubWF0ZXJpYWwuY29sb3Iuc2V0KCB0aGlzLmNvbG9yICk7XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHR0aGlzLm1hdGVyaWFsLmNvbG9yLmNvcHkoIHRoaXMubGlnaHQuY29sb3IgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0LypcXG5cXHRcXHR2YXIgZCA9IHRoaXMubGlnaHQuZGlzdGFuY2U7XFxuXFxuXFx0XFx0aWYgKCBkID09PSAwLjAgKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5saWdodERpc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcXG5cXG5cXHRcXHR9IGVsc2Uge1xcblxcblxcdFxcdFxcdHRoaXMubGlnaHREaXN0YW5jZS52aXNpYmxlID0gdHJ1ZTtcXG5cXHRcXHRcXHR0aGlzLmxpZ2h0RGlzdGFuY2Uuc2NhbGUuc2V0KCBkLCBkLCBkICk7XFxuXFxuXFx0XFx0fVxcblxcdFxcdCovXFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGFiZWxuYXRpb24gLyBodHRwOi8vZ2l0aHViLmNvbS9hYmVsbmF0aW9uXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cDovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIFJlY3RBcmVhTGlnaHRIZWxwZXIoIGxpZ2h0LCBjb2xvciApIHtcXG5cXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0dGhpcy5saWdodCA9IGxpZ2h0O1xcblxcdFxcdHRoaXMubGlnaHQudXBkYXRlTWF0cml4V29ybGQoKTtcXG5cXG5cXHRcXHR0aGlzLm1hdHJpeCA9IGxpZ2h0Lm1hdHJpeFdvcmxkO1xcblxcdFxcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMuY29sb3IgPSBjb2xvcjtcXG5cXG5cXHRcXHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgZm9nOiBmYWxzZSB9ICk7XFxuXFxuXFx0XFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxuXFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgQnVmZmVyQXR0cmlidXRlKCBuZXcgRmxvYXQzMkFycmF5KCA1ICogMyApLCAzICkgKTtcXG5cXG5cXHRcXHR0aGlzLmxpbmUgPSBuZXcgTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XFxuXFx0XFx0dGhpcy5hZGQoIHRoaXMubGluZSApO1xcblxcblxcblxcdFxcdHRoaXMudXBkYXRlKCk7XFxuXFxuXFx0fVxcblxcblxcdFJlY3RBcmVhTGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICk7XFxuXFx0UmVjdEFyZWFMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBSZWN0QXJlYUxpZ2h0SGVscGVyO1xcblxcblxcdFJlY3RBcmVhTGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dGhpcy5jaGlsZHJlblsgMCBdLmdlb21ldHJ5LmRpc3Bvc2UoKTtcXG5cXHRcXHR0aGlzLmNoaWxkcmVuWyAwIF0ubWF0ZXJpYWwuZGlzcG9zZSgpO1xcblxcblxcdH07XFxuXFxuXFx0UmVjdEFyZWFMaWdodEhlbHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdC8vIGNhbGN1bGF0ZSBuZXcgZGltZW5zaW9ucyBvZiB0aGUgaGVscGVyXFxuXFxuXFx0XFx0dmFyIGh4ID0gdGhpcy5saWdodC53aWR0aCAqIDAuNTtcXG5cXHRcXHR2YXIgaHkgPSB0aGlzLmxpZ2h0LmhlaWdodCAqIDAuNTtcXG5cXG5cXHRcXHR2YXIgcG9zaXRpb24gPSB0aGlzLmxpbmUuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcXG5cXHRcXHR2YXIgYXJyYXkgPSBwb3NpdGlvbi5hcnJheTtcXG5cXG5cXHRcXHQvLyB1cGRhdGUgdmVydGljZXNcXG5cXG5cXHRcXHRhcnJheVsgMCBdID0gaHg7IGFycmF5WyAxIF0gPSAtIGh5OyBhcnJheVsgMiBdID0gMDtcXG5cXHRcXHRhcnJheVsgMyBdID0gaHg7IGFycmF5WyA0IF0gPSBoeTsgYXJyYXlbIDUgXSA9IDA7XFxuXFx0XFx0YXJyYXlbIDYgXSA9IC0gaHg7IGFycmF5WyA3IF0gPSBoeTsgYXJyYXlbIDggXSA9IDA7XFxuXFx0XFx0YXJyYXlbIDkgXSA9IC0gaHg7IGFycmF5WyAxMCBdID0gLSBoeTsgYXJyYXlbIDExIF0gPSAwO1xcblxcdFxcdGFycmF5WyAxMiBdID0gaHg7IGFycmF5WyAxMyBdID0gLSBoeTsgYXJyYXlbIDE0IF0gPSAwO1xcblxcblxcdFxcdHBvc2l0aW9uLm5lZWRzVXBkYXRlID0gdHJ1ZTtcXG5cXG5cXHRcXHRpZiAoIHRoaXMuY29sb3IgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmxpbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCB0aGlzLmNvbG9yICk7XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHR0aGlzLmxpbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgYWx0ZXJlZHEgLyBodHRwOi8vYWx0ZXJlZHF1YWxpYS5jb20vXFxuXFx0ICogQGF1dGhvciBtcmRvb2IgLyBodHRwOi8vbXJkb29iLmNvbS9cXG5cXHQgKiBAYXV0aG9yIE11Z2VuODcgLyBodHRwczovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEhlbWlzcGhlcmVMaWdodEhlbHBlciggbGlnaHQsIHNpemUsIGNvbG9yICkge1xcblxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XFxuXFx0XFx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xcblxcblxcdFxcdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XFxuXFx0XFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XFxuXFxuXFx0XFx0dGhpcy5jb2xvciA9IGNvbG9yO1xcblxcblxcdFxcdHZhciBnZW9tZXRyeSA9IG5ldyBPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnkoIHNpemUgKTtcXG5cXHRcXHRnZW9tZXRyeS5yb3RhdGVZKCBNYXRoLlBJICogMC41ICk7XFxuXFxuXFx0XFx0dGhpcy5tYXRlcmlhbCA9IG5ldyBNZXNoQmFzaWNNYXRlcmlhbCggeyB3aXJlZnJhbWU6IHRydWUsIGZvZzogZmFsc2UgfSApO1xcblxcdFxcdGlmICggdGhpcy5jb2xvciA9PT0gdW5kZWZpbmVkICkgdGhpcy5tYXRlcmlhbC52ZXJ0ZXhDb2xvcnMgPSBWZXJ0ZXhDb2xvcnM7XFxuXFxuXFx0XFx0dmFyIHBvc2l0aW9uID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICk7XFxuXFx0XFx0dmFyIGNvbG9ycyA9IG5ldyBGbG9hdDMyQXJyYXkoIHBvc2l0aW9uLmNvdW50ICogMyApO1xcblxcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ2NvbG9yJywgbmV3IEJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcXG5cXG5cXHRcXHR0aGlzLmFkZCggbmV3IE1lc2goIGdlb21ldHJ5LCB0aGlzLm1hdGVyaWFsICkgKTtcXG5cXG5cXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcblxcdH1cXG5cXG5cXHRIZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICk7XFxuXFx0SGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhlbWlzcGhlcmVMaWdodEhlbHBlcjtcXG5cXG5cXHRIZW1pc3BoZXJlTGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dGhpcy5jaGlsZHJlblsgMCBdLmdlb21ldHJ5LmRpc3Bvc2UoKTtcXG5cXHRcXHR0aGlzLmNoaWxkcmVuWyAwIF0ubWF0ZXJpYWwuZGlzcG9zZSgpO1xcblxcblxcdH07XFxuXFxuXFx0SGVtaXNwaGVyZUxpZ2h0SGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dmFyIHZlY3RvciA9IG5ldyBWZWN0b3IzKCk7XFxuXFxuXFx0XFx0dmFyIGNvbG9yMSA9IG5ldyBDb2xvcigpO1xcblxcdFxcdHZhciBjb2xvcjIgPSBuZXcgQ29sb3IoKTtcXG5cXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xcblxcblxcdFxcdFxcdHZhciBtZXNoID0gdGhpcy5jaGlsZHJlblsgMCBdO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5jb2xvciAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMubWF0ZXJpYWwuY29sb3Iuc2V0KCB0aGlzLmNvbG9yICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgY29sb3JzID0gbWVzaC5nZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdjb2xvcicgKTtcXG5cXG5cXHRcXHRcXHRcXHRjb2xvcjEuY29weSggdGhpcy5saWdodC5jb2xvciApO1xcblxcdFxcdFxcdFxcdGNvbG9yMi5jb3B5KCB0aGlzLmxpZ2h0Lmdyb3VuZENvbG9yICk7XFxuXFxuXFx0XFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gY29sb3JzLmNvdW50OyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHR2YXIgY29sb3IgPSAoIGkgPCAoIGwgLyAyICkgKSA/IGNvbG9yMSA6IGNvbG9yMjtcXG5cXG5cXHRcXHRcXHRcXHRcXHRjb2xvcnMuc2V0WFlaKCBpLCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGNvbG9ycy5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdG1lc2gubG9va0F0KCB2ZWN0b3Iuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCB0aGlzLmxpZ2h0Lm1hdHJpeFdvcmxkICkubmVnYXRlKCkgKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdH0oKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEdyaWRIZWxwZXIoIHNpemUsIGRpdmlzaW9ucywgY29sb3IxLCBjb2xvcjIgKSB7XFxuXFxuXFx0XFx0c2l6ZSA9IHNpemUgfHwgMTA7XFxuXFx0XFx0ZGl2aXNpb25zID0gZGl2aXNpb25zIHx8IDEwO1xcblxcdFxcdGNvbG9yMSA9IG5ldyBDb2xvciggY29sb3IxICE9PSB1bmRlZmluZWQgPyBjb2xvcjEgOiAweDQ0NDQ0NCApO1xcblxcdFxcdGNvbG9yMiA9IG5ldyBDb2xvciggY29sb3IyICE9PSB1bmRlZmluZWQgPyBjb2xvcjIgOiAweDg4ODg4OCApO1xcblxcblxcdFxcdHZhciBjZW50ZXIgPSBkaXZpc2lvbnMgLyAyO1xcblxcdFxcdHZhciBzdGVwID0gc2l6ZSAvIGRpdmlzaW9ucztcXG5cXHRcXHR2YXIgaGFsZlNpemUgPSBzaXplIC8gMjtcXG5cXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXSwgY29sb3JzID0gW107XFxuXFxuXFx0XFx0Zm9yICggdmFyIGkgPSAwLCBqID0gMCwgayA9IC0gaGFsZlNpemU7IGkgPD0gZGl2aXNpb25zOyBpICsrLCBrICs9IHN0ZXAgKSB7XFxuXFxuXFx0XFx0XFx0dmVydGljZXMucHVzaCggLSBoYWxmU2l6ZSwgMCwgaywgaGFsZlNpemUsIDAsIGsgKTtcXG5cXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCBrLCAwLCAtIGhhbGZTaXplLCBrLCAwLCBoYWxmU2l6ZSApO1xcblxcblxcdFxcdFxcdHZhciBjb2xvciA9IGkgPT09IGNlbnRlciA/IGNvbG9yMSA6IGNvbG9yMjtcXG5cXG5cXHRcXHRcXHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xcblxcdFxcdFxcdGNvbG9yLnRvQXJyYXkoIGNvbG9ycywgaiApOyBqICs9IDM7XFxuXFx0XFx0XFx0Y29sb3IudG9BcnJheSggY29sb3JzLCBqICk7IGogKz0gMztcXG5cXHRcXHRcXHRjb2xvci50b0FycmF5KCBjb2xvcnMsIGogKTsgaiArPSAzO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcXG5cXG5cXHRcXHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBWZXJ0ZXhDb2xvcnMgfSApO1xcblxcblxcdFxcdExpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcXG5cXG5cXHR9XFxuXFxuXFx0R3JpZEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XFxuXFx0R3JpZEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmlkSGVscGVyO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cDovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqIEBhdXRob3IgSGVjdGF0ZSAvIGh0dHA6Ly93d3cuZ2l0aHViLmNvbS9IZWN0YXRlXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gUG9sYXJHcmlkSGVscGVyKCByYWRpdXMsIHJhZGlhbHMsIGNpcmNsZXMsIGRpdmlzaW9ucywgY29sb3IxLCBjb2xvcjIgKSB7XFxuXFxuXFx0XFx0cmFkaXVzID0gcmFkaXVzIHx8IDEwO1xcblxcdFxcdHJhZGlhbHMgPSByYWRpYWxzIHx8IDE2O1xcblxcdFxcdGNpcmNsZXMgPSBjaXJjbGVzIHx8IDg7XFxuXFx0XFx0ZGl2aXNpb25zID0gZGl2aXNpb25zIHx8IDY0O1xcblxcdFxcdGNvbG9yMSA9IG5ldyBDb2xvciggY29sb3IxICE9PSB1bmRlZmluZWQgPyBjb2xvcjEgOiAweDQ0NDQ0NCApO1xcblxcdFxcdGNvbG9yMiA9IG5ldyBDb2xvciggY29sb3IyICE9PSB1bmRlZmluZWQgPyBjb2xvcjIgOiAweDg4ODg4OCApO1xcblxcblxcdFxcdHZhciB2ZXJ0aWNlcyA9IFtdO1xcblxcdFxcdHZhciBjb2xvcnMgPSBbXTtcXG5cXG5cXHRcXHR2YXIgeCwgejtcXG5cXHRcXHR2YXIgdiwgaSwgaiwgciwgY29sb3I7XFxuXFxuXFx0XFx0Ly8gY3JlYXRlIHRoZSByYWRpYWxzXFxuXFxuXFx0XFx0Zm9yICggaSA9IDA7IGkgPD0gcmFkaWFsczsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHR2ID0gKCBpIC8gcmFkaWFscyApICogKCBNYXRoLlBJICogMiApO1xcblxcblxcdFxcdFxcdHggPSBNYXRoLnNpbiggdiApICogcmFkaXVzO1xcblxcdFxcdFxcdHogPSBNYXRoLmNvcyggdiApICogcmFkaXVzO1xcblxcblxcdFxcdFxcdHZlcnRpY2VzLnB1c2goIDAsIDAsIDAgKTtcXG5cXHRcXHRcXHR2ZXJ0aWNlcy5wdXNoKCB4LCAwLCB6ICk7XFxuXFxuXFx0XFx0XFx0Y29sb3IgPSAoIGkgJiAxICkgPyBjb2xvcjEgOiBjb2xvcjI7XFxuXFxuXFx0XFx0XFx0Y29sb3JzLnB1c2goIGNvbG9yLnIsIGNvbG9yLmcsIGNvbG9yLmIgKTtcXG5cXHRcXHRcXHRjb2xvcnMucHVzaCggY29sb3IuciwgY29sb3IuZywgY29sb3IuYiApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBjcmVhdGUgdGhlIGNpcmNsZXNcXG5cXG5cXHRcXHRmb3IgKCBpID0gMDsgaSA8PSBjaXJjbGVzOyBpICsrICkge1xcblxcblxcdFxcdFxcdGNvbG9yID0gKCBpICYgMSApID8gY29sb3IxIDogY29sb3IyO1xcblxcblxcdFxcdFxcdHIgPSByYWRpdXMgLSAoIHJhZGl1cyAvIGNpcmNsZXMgKiBpICk7XFxuXFxuXFx0XFx0XFx0Zm9yICggaiA9IDA7IGogPCBkaXZpc2lvbnM7IGogKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gZmlyc3QgdmVydGV4XFxuXFxuXFx0XFx0XFx0XFx0diA9ICggaiAvIGRpdmlzaW9ucyApICogKCBNYXRoLlBJICogMiApO1xcblxcblxcdFxcdFxcdFxcdHggPSBNYXRoLnNpbiggdiApICogcjtcXG5cXHRcXHRcXHRcXHR6ID0gTWF0aC5jb3MoIHYgKSAqIHI7XFxuXFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggeCwgMCwgeiApO1xcblxcdFxcdFxcdFxcdGNvbG9ycy5wdXNoKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gc2Vjb25kIHZlcnRleFxcblxcblxcdFxcdFxcdFxcdHYgPSAoICggaiArIDEgKSAvIGRpdmlzaW9ucyApICogKCBNYXRoLlBJICogMiApO1xcblxcblxcdFxcdFxcdFxcdHggPSBNYXRoLnNpbiggdiApICogcjtcXG5cXHRcXHRcXHRcXHR6ID0gTWF0aC5jb3MoIHYgKSAqIHI7XFxuXFxuXFx0XFx0XFx0XFx0dmVydGljZXMucHVzaCggeCwgMCwgeiApO1xcblxcdFxcdFxcdFxcdGNvbG9ycy5wdXNoKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcXG5cXG5cXHRcXHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgdmVydGV4Q29sb3JzOiBWZXJ0ZXhDb2xvcnMgfSApO1xcblxcblxcdFxcdExpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcXG5cXG5cXHR9XFxuXFxuXFx0UG9sYXJHcmlkSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcXG5cXHRQb2xhckdyaWRIZWxwZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9sYXJHcmlkSGVscGVyO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gRmFjZU5vcm1hbHNIZWxwZXIoIG9iamVjdCwgc2l6ZSwgaGV4LCBsaW5ld2lkdGggKSB7XFxuXFxuXFx0XFx0Ly8gRmFjZU5vcm1hbHNIZWxwZXIgb25seSBzdXBwb3J0cyBUSFJFRS5HZW9tZXRyeVxcblxcblxcdFxcdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xcblxcblxcdFxcdHRoaXMuc2l6ZSA9ICggc2l6ZSAhPT0gdW5kZWZpbmVkICkgPyBzaXplIDogMTtcXG5cXG5cXHRcXHR2YXIgY29sb3IgPSAoIGhleCAhPT0gdW5kZWZpbmVkICkgPyBoZXggOiAweGZmZmYwMDtcXG5cXG5cXHRcXHR2YXIgd2lkdGggPSAoIGxpbmV3aWR0aCAhPT0gdW5kZWZpbmVkICkgPyBsaW5ld2lkdGggOiAxO1xcblxcblxcdFxcdC8vXFxuXFxuXFx0XFx0dmFyIG5Ob3JtYWxzID0gMDtcXG5cXG5cXHRcXHR2YXIgb2JqR2VvbWV0cnkgPSB0aGlzLm9iamVjdC5nZW9tZXRyeTtcXG5cXG5cXHRcXHRpZiAoIG9iakdlb21ldHJ5ICYmIG9iakdlb21ldHJ5LmlzR2VvbWV0cnkgKSB7XFxuXFxuXFx0XFx0XFx0bk5vcm1hbHMgPSBvYmpHZW9tZXRyeS5mYWNlcy5sZW5ndGg7XFxuXFxuXFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5GYWNlTm9ybWFsc0hlbHBlcjogb25seSBUSFJFRS5HZW9tZXRyeSBpcyBzdXBwb3J0ZWQuIFVzZSBUSFJFRS5WZXJ0ZXhOb3JtYWxzSGVscGVyLCBpbnN0ZWFkLicgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly9cXG5cXG5cXHRcXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXG5cXG5cXHRcXHR2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIG5Ob3JtYWxzICogMiAqIDMsIDMgKTtcXG5cXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIHBvc2l0aW9ucyApO1xcblxcblxcdFxcdExpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciwgbGluZXdpZHRoOiB3aWR0aCB9ICkgKTtcXG5cXG5cXHRcXHQvL1xcblxcblxcdFxcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xcblxcdFxcdHRoaXMudXBkYXRlKCk7XFxuXFxuXFx0fVxcblxcblxcdEZhY2VOb3JtYWxzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcXG5cXHRGYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBGYWNlTm9ybWFsc0hlbHBlcjtcXG5cXG5cXHRGYWNlTm9ybWFsc0hlbHBlci5wcm90b3R5cGUudXBkYXRlID0gKCBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dmFyIHYxID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR2YXIgdjIgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHZhciBub3JtYWxNYXRyaXggPSBuZXcgTWF0cml4MygpO1xcblxcblxcdFxcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XFxuXFxuXFx0XFx0XFx0dGhpcy5vYmplY3QudXBkYXRlTWF0cml4V29ybGQoIHRydWUgKTtcXG5cXG5cXHRcXHRcXHRub3JtYWxNYXRyaXguZ2V0Tm9ybWFsTWF0cml4KCB0aGlzLm9iamVjdC5tYXRyaXhXb3JsZCApO1xcblxcblxcdFxcdFxcdHZhciBtYXRyaXhXb3JsZCA9IHRoaXMub2JqZWN0Lm1hdHJpeFdvcmxkO1xcblxcblxcdFxcdFxcdHZhciBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcXG5cXG5cXHRcXHRcXHQvL1xcblxcblxcdFxcdFxcdHZhciBvYmpHZW9tZXRyeSA9IHRoaXMub2JqZWN0Lmdlb21ldHJ5O1xcblxcblxcdFxcdFxcdHZhciB2ZXJ0aWNlcyA9IG9iakdlb21ldHJ5LnZlcnRpY2VzO1xcblxcblxcdFxcdFxcdHZhciBmYWNlcyA9IG9iakdlb21ldHJ5LmZhY2VzO1xcblxcblxcdFxcdFxcdHZhciBpZHggPSAwO1xcblxcblxcdFxcdFxcdGZvciAoIHZhciBpID0gMCwgbCA9IGZhY2VzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIGZhY2UgPSBmYWNlc1sgaSBdO1xcblxcblxcdFxcdFxcdFxcdHZhciBub3JtYWwgPSBmYWNlLm5vcm1hbDtcXG5cXG5cXHRcXHRcXHRcXHR2MS5jb3B5KCB2ZXJ0aWNlc1sgZmFjZS5hIF0gKVxcblxcdFxcdFxcdFxcdFxcdC5hZGQoIHZlcnRpY2VzWyBmYWNlLmIgXSApXFxuXFx0XFx0XFx0XFx0XFx0LmFkZCggdmVydGljZXNbIGZhY2UuYyBdIClcXG5cXHRcXHRcXHRcXHRcXHQuZGl2aWRlU2NhbGFyKCAzIClcXG5cXHRcXHRcXHRcXHRcXHQuYXBwbHlNYXRyaXg0KCBtYXRyaXhXb3JsZCApO1xcblxcblxcdFxcdFxcdFxcdHYyLmNvcHkoIG5vcm1hbCApLmFwcGx5TWF0cml4Myggbm9ybWFsTWF0cml4ICkubm9ybWFsaXplKCkubXVsdGlwbHlTY2FsYXIoIHRoaXMuc2l6ZSApLmFkZCggdjEgKTtcXG5cXG5cXHRcXHRcXHRcXHRwb3NpdGlvbi5zZXRYWVooIGlkeCwgdjEueCwgdjEueSwgdjEueiApO1xcblxcblxcdFxcdFxcdFxcdGlkeCA9IGlkeCArIDE7XFxuXFxuXFx0XFx0XFx0XFx0cG9zaXRpb24uc2V0WFlaKCBpZHgsIHYyLngsIHYyLnksIHYyLnogKTtcXG5cXG5cXHRcXHRcXHRcXHRpZHggPSBpZHggKyAxO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0fTtcXG5cXG5cXHR9KCkgKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBXZXN0TGFuZ2xleSAvIGh0dHA6Ly9naXRodWIuY29tL1dlc3RMYW5nbGV5XFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gRGlyZWN0aW9uYWxMaWdodEhlbHBlciggbGlnaHQsIHNpemUsIGNvbG9yICkge1xcblxcblxcdFxcdE9iamVjdDNELmNhbGwoIHRoaXMgKTtcXG5cXG5cXHRcXHR0aGlzLmxpZ2h0ID0gbGlnaHQ7XFxuXFx0XFx0dGhpcy5saWdodC51cGRhdGVNYXRyaXhXb3JsZCgpO1xcblxcblxcdFxcdHRoaXMubWF0cml4ID0gbGlnaHQubWF0cml4V29ybGQ7XFxuXFx0XFx0dGhpcy5tYXRyaXhBdXRvVXBkYXRlID0gZmFsc2U7XFxuXFxuXFx0XFx0dGhpcy5jb2xvciA9IGNvbG9yO1xcblxcblxcdFxcdGlmICggc2l6ZSA9PT0gdW5kZWZpbmVkICkgc2l6ZSA9IDE7XFxuXFxuXFx0XFx0dmFyIGdlb21ldHJ5ID0gbmV3IEJ1ZmZlckdlb21ldHJ5KCk7XFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggW1xcblxcdFxcdFxcdC0gc2l6ZSwgc2l6ZSwgMCxcXG5cXHRcXHRcXHRzaXplLCBzaXplLCAwLFxcblxcdFxcdFxcdHNpemUsIC0gc2l6ZSwgMCxcXG5cXHRcXHRcXHQtIHNpemUsIC0gc2l6ZSwgMCxcXG5cXHRcXHRcXHQtIHNpemUsIHNpemUsIDBcXG5cXHRcXHRdLCAzICkgKTtcXG5cXG5cXHRcXHR2YXIgbWF0ZXJpYWwgPSBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgZm9nOiBmYWxzZSB9ICk7XFxuXFxuXFx0XFx0dGhpcy5saWdodFBsYW5lID0gbmV3IExpbmUoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xcblxcdFxcdHRoaXMuYWRkKCB0aGlzLmxpZ2h0UGxhbmUgKTtcXG5cXG5cXHRcXHRnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIFsgMCwgMCwgMCwgMCwgMCwgMSBdLCAzICkgKTtcXG5cXG5cXHRcXHR0aGlzLnRhcmdldExpbmUgPSBuZXcgTGluZSggZ2VvbWV0cnksIG1hdGVyaWFsICk7XFxuXFx0XFx0dGhpcy5hZGQoIHRoaXMudGFyZ2V0TGluZSApO1xcblxcblxcdFxcdHRoaXMudXBkYXRlKCk7XFxuXFxuXFx0fVxcblxcblxcdERpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggT2JqZWN0M0QucHJvdG90eXBlICk7XFxuXFx0RGlyZWN0aW9uYWxMaWdodEhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBEaXJlY3Rpb25hbExpZ2h0SGVscGVyO1xcblxcblxcdERpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dGhpcy5saWdodFBsYW5lLmdlb21ldHJ5LmRpc3Bvc2UoKTtcXG5cXHRcXHR0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuZGlzcG9zZSgpO1xcblxcdFxcdHRoaXMudGFyZ2V0TGluZS5nZW9tZXRyeS5kaXNwb3NlKCk7XFxuXFx0XFx0dGhpcy50YXJnZXRMaW5lLm1hdGVyaWFsLmRpc3Bvc2UoKTtcXG5cXG5cXHR9O1xcblxcblxcdERpcmVjdGlvbmFsTGlnaHRIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHR2YXIgdjEgPSBuZXcgVmVjdG9yMygpO1xcblxcdFxcdHZhciB2MiA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dmFyIHYzID0gbmV3IFZlY3RvcjMoKTtcXG5cXG5cXHRcXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKCkge1xcblxcblxcdFxcdFxcdHYxLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC5tYXRyaXhXb3JsZCApO1xcblxcdFxcdFxcdHYyLnNldEZyb21NYXRyaXhQb3NpdGlvbiggdGhpcy5saWdodC50YXJnZXQubWF0cml4V29ybGQgKTtcXG5cXHRcXHRcXHR2My5zdWJWZWN0b3JzKCB2MiwgdjEgKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmxpZ2h0UGxhbmUubG9va0F0KCB2MyApO1xcblxcblxcdFxcdFxcdGlmICggdGhpcy5jb2xvciAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHRoaXMubGlnaHRQbGFuZS5tYXRlcmlhbC5jb2xvci5zZXQoIHRoaXMuY29sb3IgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnRhcmdldExpbmUubWF0ZXJpYWwuY29sb3Iuc2V0KCB0aGlzLmNvbG9yICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLmxpZ2h0UGxhbmUubWF0ZXJpYWwuY29sb3IuY29weSggdGhpcy5saWdodC5jb2xvciApO1xcblxcdFxcdFxcdFxcdHRoaXMudGFyZ2V0TGluZS5tYXRlcmlhbC5jb2xvci5jb3B5KCB0aGlzLmxpZ2h0LmNvbG9yICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMudGFyZ2V0TGluZS5sb29rQXQoIHYzICk7XFxuXFx0XFx0XFx0dGhpcy50YXJnZXRMaW5lLnNjYWxlLnogPSB2My5sZW5ndGgoKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdH0oKTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIGFsdGVyZWRxIC8gaHR0cDovL2FsdGVyZWRxdWFsaWEuY29tL1xcblxcdCAqIEBhdXRob3IgTXVnZW44NyAvIGh0dHBzOi8vZ2l0aHViLmNvbS9NdWdlbjg3XFxuXFx0ICpcXG5cXHQgKlxcdC0gc2hvd3MgZnJ1c3R1bSwgbGluZSBvZiBzaWdodCBhbmQgdXAgb2YgdGhlIGNhbWVyYVxcblxcdCAqXFx0LSBzdWl0YWJsZSBmb3IgZmFzdCB1cGRhdGVzXFxuXFx0ICogXFx0LSBiYXNlZCBvbiBmcnVzdHVtIHZpc3VhbGl6YXRpb24gaW4gbGlnaHRnbC5qcyBzaGFkb3dtYXAgZXhhbXBsZVxcblxcdCAqXFx0XFx0aHR0cDovL2V2YW53LmdpdGh1Yi5jb20vbGlnaHRnbC5qcy90ZXN0cy9zaGFkb3dtYXAuaHRtbFxcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIENhbWVyYUhlbHBlciggY2FtZXJhICkge1xcblxcblxcdFxcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcblxcdFxcdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHhmZmZmZmYsIHZlcnRleENvbG9yczogRmFjZUNvbG9ycyB9ICk7XFxuXFxuXFx0XFx0dmFyIHZlcnRpY2VzID0gW107XFxuXFx0XFx0dmFyIGNvbG9ycyA9IFtdO1xcblxcblxcdFxcdHZhciBwb2ludE1hcCA9IHt9O1xcblxcblxcdFxcdC8vIGNvbG9yc1xcblxcblxcdFxcdHZhciBjb2xvckZydXN0dW0gPSBuZXcgQ29sb3IoIDB4ZmZhYTAwICk7XFxuXFx0XFx0dmFyIGNvbG9yQ29uZSA9IG5ldyBDb2xvciggMHhmZjAwMDAgKTtcXG5cXHRcXHR2YXIgY29sb3JVcCA9IG5ldyBDb2xvciggMHgwMGFhZmYgKTtcXG5cXHRcXHR2YXIgY29sb3JUYXJnZXQgPSBuZXcgQ29sb3IoIDB4ZmZmZmZmICk7XFxuXFx0XFx0dmFyIGNvbG9yQ3Jvc3MgPSBuZXcgQ29sb3IoIDB4MzMzMzMzICk7XFxuXFxuXFx0XFx0Ly8gbmVhclxcblxcblxcdFxcdGFkZExpbmUoICduMScsICduMicsIGNvbG9yRnJ1c3R1bSApO1xcblxcdFxcdGFkZExpbmUoICduMicsICduNCcsIGNvbG9yRnJ1c3R1bSApO1xcblxcdFxcdGFkZExpbmUoICduNCcsICduMycsIGNvbG9yRnJ1c3R1bSApO1xcblxcdFxcdGFkZExpbmUoICduMycsICduMScsIGNvbG9yRnJ1c3R1bSApO1xcblxcblxcdFxcdC8vIGZhclxcblxcblxcdFxcdGFkZExpbmUoICdmMScsICdmMicsIGNvbG9yRnJ1c3R1bSApO1xcblxcdFxcdGFkZExpbmUoICdmMicsICdmNCcsIGNvbG9yRnJ1c3R1bSApO1xcblxcdFxcdGFkZExpbmUoICdmNCcsICdmMycsIGNvbG9yRnJ1c3R1bSApO1xcblxcdFxcdGFkZExpbmUoICdmMycsICdmMScsIGNvbG9yRnJ1c3R1bSApO1xcblxcblxcdFxcdC8vIHNpZGVzXFxuXFxuXFx0XFx0YWRkTGluZSggJ24xJywgJ2YxJywgY29sb3JGcnVzdHVtICk7XFxuXFx0XFx0YWRkTGluZSggJ24yJywgJ2YyJywgY29sb3JGcnVzdHVtICk7XFxuXFx0XFx0YWRkTGluZSggJ24zJywgJ2YzJywgY29sb3JGcnVzdHVtICk7XFxuXFx0XFx0YWRkTGluZSggJ240JywgJ2Y0JywgY29sb3JGcnVzdHVtICk7XFxuXFxuXFx0XFx0Ly8gY29uZVxcblxcblxcdFxcdGFkZExpbmUoICdwJywgJ24xJywgY29sb3JDb25lICk7XFxuXFx0XFx0YWRkTGluZSggJ3AnLCAnbjInLCBjb2xvckNvbmUgKTtcXG5cXHRcXHRhZGRMaW5lKCAncCcsICduMycsIGNvbG9yQ29uZSApO1xcblxcdFxcdGFkZExpbmUoICdwJywgJ240JywgY29sb3JDb25lICk7XFxuXFxuXFx0XFx0Ly8gdXBcXG5cXG5cXHRcXHRhZGRMaW5lKCAndTEnLCAndTInLCBjb2xvclVwICk7XFxuXFx0XFx0YWRkTGluZSggJ3UyJywgJ3UzJywgY29sb3JVcCApO1xcblxcdFxcdGFkZExpbmUoICd1MycsICd1MScsIGNvbG9yVXAgKTtcXG5cXG5cXHRcXHQvLyB0YXJnZXRcXG5cXG5cXHRcXHRhZGRMaW5lKCAnYycsICd0JywgY29sb3JUYXJnZXQgKTtcXG5cXHRcXHRhZGRMaW5lKCAncCcsICdjJywgY29sb3JDcm9zcyApO1xcblxcblxcdFxcdC8vIGNyb3NzXFxuXFxuXFx0XFx0YWRkTGluZSggJ2NuMScsICdjbjInLCBjb2xvckNyb3NzICk7XFxuXFx0XFx0YWRkTGluZSggJ2NuMycsICdjbjQnLCBjb2xvckNyb3NzICk7XFxuXFxuXFx0XFx0YWRkTGluZSggJ2NmMScsICdjZjInLCBjb2xvckNyb3NzICk7XFxuXFx0XFx0YWRkTGluZSggJ2NmMycsICdjZjQnLCBjb2xvckNyb3NzICk7XFxuXFxuXFx0XFx0ZnVuY3Rpb24gYWRkTGluZSggYSwgYiwgY29sb3IgKSB7XFxuXFxuXFx0XFx0XFx0YWRkUG9pbnQoIGEsIGNvbG9yICk7XFxuXFx0XFx0XFx0YWRkUG9pbnQoIGIsIGNvbG9yICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdFxcdGZ1bmN0aW9uIGFkZFBvaW50KCBpZCwgY29sb3IgKSB7XFxuXFxuXFx0XFx0XFx0dmVydGljZXMucHVzaCggMCwgMCwgMCApO1xcblxcdFxcdFxcdGNvbG9ycy5wdXNoKCBjb2xvci5yLCBjb2xvci5nLCBjb2xvci5iICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBwb2ludE1hcFsgaWQgXSA9PT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdHBvaW50TWFwWyBpZCBdID0gW107XFxuXFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHBvaW50TWFwWyBpZCBdLnB1c2goICggdmVydGljZXMubGVuZ3RoIC8gMyApIC0gMSApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCB2ZXJ0aWNlcywgMyApICk7XFxuXFx0XFx0Z2VvbWV0cnkuYWRkQXR0cmlidXRlKCAnY29sb3InLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggY29sb3JzLCAzICkgKTtcXG5cXG5cXHRcXHRMaW5lU2VnbWVudHMuY2FsbCggdGhpcywgZ2VvbWV0cnksIG1hdGVyaWFsICk7XFxuXFxuXFx0XFx0dGhpcy5jYW1lcmEgPSBjYW1lcmE7XFxuXFx0XFx0aWYgKCB0aGlzLmNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4ICkgdGhpcy5jYW1lcmEudXBkYXRlUHJvamVjdGlvbk1hdHJpeCgpO1xcblxcblxcdFxcdHRoaXMubWF0cml4ID0gY2FtZXJhLm1hdHJpeFdvcmxkO1xcblxcdFxcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMucG9pbnRNYXAgPSBwb2ludE1hcDtcXG5cXG5cXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcblxcdH1cXG5cXG5cXHRDYW1lcmFIZWxwZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZVNlZ21lbnRzLnByb3RvdHlwZSApO1xcblxcdENhbWVyYUhlbHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDYW1lcmFIZWxwZXI7XFxuXFxuXFx0Q2FtZXJhSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0dmFyIGdlb21ldHJ5LCBwb2ludE1hcDtcXG5cXG5cXHRcXHR2YXIgdmVjdG9yID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHR2YXIgY2FtZXJhID0gbmV3IENhbWVyYSgpO1xcblxcblxcdFxcdGZ1bmN0aW9uIHNldFBvaW50KCBwb2ludCwgeCwgeSwgeiApIHtcXG5cXG5cXHRcXHRcXHR2ZWN0b3Iuc2V0KCB4LCB5LCB6ICkudW5wcm9qZWN0KCBjYW1lcmEgKTtcXG5cXG5cXHRcXHRcXHR2YXIgcG9pbnRzID0gcG9pbnRNYXBbIHBvaW50IF07XFxuXFxuXFx0XFx0XFx0aWYgKCBwb2ludHMgIT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcG9zaXRpb24gPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcXG5cXG5cXHRcXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbi5zZXRYWVooIHBvaW50c1sgaSBdLCB2ZWN0b3IueCwgdmVjdG9yLnksIHZlY3Rvci56ICk7XFxuXFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcXG5cXG5cXHRcXHRcXHRnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XFxuXFx0XFx0XFx0cG9pbnRNYXAgPSB0aGlzLnBvaW50TWFwO1xcblxcblxcdFxcdFxcdHZhciB3ID0gMSwgaCA9IDE7XFxuXFxuXFx0XFx0XFx0Ly8gd2UgbmVlZCBqdXN0IGNhbWVyYSBwcm9qZWN0aW9uIG1hdHJpeFxcblxcdFxcdFxcdC8vIHdvcmxkIG1hdHJpeCBtdXN0IGJlIGlkZW50aXR5XFxuXFxuXFx0XFx0XFx0Y2FtZXJhLnByb2plY3Rpb25NYXRyaXguY29weSggdGhpcy5jYW1lcmEucHJvamVjdGlvbk1hdHJpeCApO1xcblxcblxcdFxcdFxcdC8vIGNlbnRlciAvIHRhcmdldFxcblxcblxcdFxcdFxcdHNldFBvaW50KCAnYycsIDAsIDAsIC0gMSApO1xcblxcdFxcdFxcdHNldFBvaW50KCAndCcsIDAsIDAsIDEgKTtcXG5cXG5cXHRcXHRcXHQvLyBuZWFyXFxuXFxuXFx0XFx0XFx0c2V0UG9pbnQoICduMScsIC0gdywgLSBoLCAtIDEgKTtcXG5cXHRcXHRcXHRzZXRQb2ludCggJ24yJywgdywgLSBoLCAtIDEgKTtcXG5cXHRcXHRcXHRzZXRQb2ludCggJ24zJywgLSB3LCBoLCAtIDEgKTtcXG5cXHRcXHRcXHRzZXRQb2ludCggJ240JywgdywgaCwgLSAxICk7XFxuXFxuXFx0XFx0XFx0Ly8gZmFyXFxuXFxuXFx0XFx0XFx0c2V0UG9pbnQoICdmMScsIC0gdywgLSBoLCAxICk7XFxuXFx0XFx0XFx0c2V0UG9pbnQoICdmMicsIHcsIC0gaCwgMSApO1xcblxcdFxcdFxcdHNldFBvaW50KCAnZjMnLCAtIHcsIGgsIDEgKTtcXG5cXHRcXHRcXHRzZXRQb2ludCggJ2Y0JywgdywgaCwgMSApO1xcblxcblxcdFxcdFxcdC8vIHVwXFxuXFxuXFx0XFx0XFx0c2V0UG9pbnQoICd1MScsIHcgKiAwLjcsIGggKiAxLjEsIC0gMSApO1xcblxcdFxcdFxcdHNldFBvaW50KCAndTInLCAtIHcgKiAwLjcsIGggKiAxLjEsIC0gMSApO1xcblxcdFxcdFxcdHNldFBvaW50KCAndTMnLCAwLCBoICogMiwgLSAxICk7XFxuXFxuXFx0XFx0XFx0Ly8gY3Jvc3NcXG5cXG5cXHRcXHRcXHRzZXRQb2ludCggJ2NmMScsIC0gdywgMCwgMSApO1xcblxcdFxcdFxcdHNldFBvaW50KCAnY2YyJywgdywgMCwgMSApO1xcblxcdFxcdFxcdHNldFBvaW50KCAnY2YzJywgMCwgLSBoLCAxICk7XFxuXFx0XFx0XFx0c2V0UG9pbnQoICdjZjQnLCAwLCBoLCAxICk7XFxuXFxuXFx0XFx0XFx0c2V0UG9pbnQoICdjbjEnLCAtIHcsIDAsIC0gMSApO1xcblxcdFxcdFxcdHNldFBvaW50KCAnY24yJywgdywgMCwgLSAxICk7XFxuXFx0XFx0XFx0c2V0UG9pbnQoICdjbjMnLCAwLCAtIGgsIC0gMSApO1xcblxcdFxcdFxcdHNldFBvaW50KCAnY240JywgMCwgaCwgLSAxICk7XFxuXFxuXFx0XFx0XFx0Z2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAncG9zaXRpb24nICkubmVlZHNVcGRhdGUgPSB0cnVlO1xcblxcblxcdFxcdH07XFxuXFxuXFx0fSgpO1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICogQGF1dGhvciBNdWdlbjg3IC8gaHR0cDovL2dpdGh1Yi5jb20vTXVnZW44N1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEJveEhlbHBlciggb2JqZWN0LCBjb2xvciApIHtcXG5cXG5cXHRcXHR0aGlzLm9iamVjdCA9IG9iamVjdDtcXG5cXG5cXHRcXHRpZiAoIGNvbG9yID09PSB1bmRlZmluZWQgKSBjb2xvciA9IDB4ZmZmZjAwO1xcblxcblxcdFxcdHZhciBpbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KCBbIDAsIDEsIDEsIDIsIDIsIDMsIDMsIDAsIDQsIDUsIDUsIDYsIDYsIDcsIDcsIDQsIDAsIDQsIDEsIDUsIDIsIDYsIDMsIDcgXSApO1xcblxcdFxcdHZhciBwb3NpdGlvbnMgPSBuZXcgRmxvYXQzMkFycmF5KCA4ICogMyApO1xcblxcblxcdFxcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcblxcdFxcdGdlb21ldHJ5LnNldEluZGV4KCBuZXcgQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgMyApICk7XFxuXFxuXFx0XFx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yIH0gKSApO1xcblxcblxcdFxcdHRoaXMubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xcblxcblxcdFxcdHRoaXMudXBkYXRlKCk7XFxuXFxuXFx0fVxcblxcblxcdEJveEhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lU2VnbWVudHMucHJvdG90eXBlICk7XFxuXFx0Qm94SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJveEhlbHBlcjtcXG5cXG5cXHRCb3hIZWxwZXIucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdHZhciBib3ggPSBuZXcgQm94MygpO1xcblxcblxcdFxcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoIG9iamVjdCApIHtcXG5cXG5cXHRcXHRcXHRpZiAoIG9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveEhlbHBlcjogLnVwZGF0ZSgpIGhhcyBubyBsb25nZXIgYXJndW1lbnRzLicgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCB0aGlzLm9iamVjdCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGJveC5zZXRGcm9tT2JqZWN0KCB0aGlzLm9iamVjdCApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoIGJveC5pc0VtcHR5KCkgKSByZXR1cm47XFxuXFxuXFx0XFx0XFx0dmFyIG1pbiA9IGJveC5taW47XFxuXFx0XFx0XFx0dmFyIG1heCA9IGJveC5tYXg7XFxuXFxuXFx0XFx0XFx0LypcXG5cXHRcXHRcXHQgIDVfX19fNFxcblxcdFxcdFxcdDEvX19fMC98XFxuXFx0XFx0XFx0fCA2X198XzdcXG5cXHRcXHRcXHQyL19fXzMvXFxuXFxuXFx0XFx0XFx0MDogbWF4LngsIG1heC55LCBtYXguelxcblxcdFxcdFxcdDE6IG1pbi54LCBtYXgueSwgbWF4LnpcXG5cXHRcXHRcXHQyOiBtaW4ueCwgbWluLnksIG1heC56XFxuXFx0XFx0XFx0MzogbWF4LngsIG1pbi55LCBtYXguelxcblxcdFxcdFxcdDQ6IG1heC54LCBtYXgueSwgbWluLnpcXG5cXHRcXHRcXHQ1OiBtaW4ueCwgbWF4LnksIG1pbi56XFxuXFx0XFx0XFx0NjogbWluLngsIG1pbi55LCBtaW4uelxcblxcdFxcdFxcdDc6IG1heC54LCBtaW4ueSwgbWluLnpcXG5cXHRcXHRcXHQqL1xcblxcblxcdFxcdFxcdHZhciBwb3NpdGlvbiA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcXG5cXHRcXHRcXHR2YXIgYXJyYXkgPSBwb3NpdGlvbi5hcnJheTtcXG5cXG5cXHRcXHRcXHRhcnJheVsgMCBdID0gbWF4Lng7IGFycmF5WyAxIF0gPSBtYXgueTsgYXJyYXlbIDIgXSA9IG1heC56O1xcblxcdFxcdFxcdGFycmF5WyAzIF0gPSBtaW4ueDsgYXJyYXlbIDQgXSA9IG1heC55OyBhcnJheVsgNSBdID0gbWF4Lno7XFxuXFx0XFx0XFx0YXJyYXlbIDYgXSA9IG1pbi54OyBhcnJheVsgNyBdID0gbWluLnk7IGFycmF5WyA4IF0gPSBtYXguejtcXG5cXHRcXHRcXHRhcnJheVsgOSBdID0gbWF4Lng7IGFycmF5WyAxMCBdID0gbWluLnk7IGFycmF5WyAxMSBdID0gbWF4Lno7XFxuXFx0XFx0XFx0YXJyYXlbIDEyIF0gPSBtYXgueDsgYXJyYXlbIDEzIF0gPSBtYXgueTsgYXJyYXlbIDE0IF0gPSBtaW4uejtcXG5cXHRcXHRcXHRhcnJheVsgMTUgXSA9IG1pbi54OyBhcnJheVsgMTYgXSA9IG1heC55OyBhcnJheVsgMTcgXSA9IG1pbi56O1xcblxcdFxcdFxcdGFycmF5WyAxOCBdID0gbWluLng7IGFycmF5WyAxOSBdID0gbWluLnk7IGFycmF5WyAyMCBdID0gbWluLno7XFxuXFx0XFx0XFx0YXJyYXlbIDIxIF0gPSBtYXgueDsgYXJyYXlbIDIyIF0gPSBtaW4ueTsgYXJyYXlbIDIzIF0gPSBtaW4uejtcXG5cXG5cXHRcXHRcXHRwb3NpdGlvbi5uZWVkc1VwZGF0ZSA9IHRydWU7XFxuXFxuXFx0XFx0XFx0dGhpcy5nZW9tZXRyeS5jb21wdXRlQm91bmRpbmdTcGhlcmUoKTtcXG5cXG5cXHRcXHR9O1xcblxcblxcdH0gKSgpO1xcblxcblxcdEJveEhlbHBlci5wcm90b3R5cGUuc2V0RnJvbU9iamVjdCA9IGZ1bmN0aW9uICggb2JqZWN0ICkge1xcblxcblxcdFxcdHRoaXMub2JqZWN0ID0gb2JqZWN0O1xcblxcdFxcdHRoaXMudXBkYXRlKCk7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXM7XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBCb3gzSGVscGVyKCBib3gsIGhleCApIHtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnQm94M0hlbHBlcic7XFxuXFxuXFx0XFx0dGhpcy5ib3ggPSBib3g7XFxuXFxuXFx0XFx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmMDA7XFxuXFxuXFx0XFx0dmFyIGluZGljZXMgPSBuZXcgVWludDE2QXJyYXkoIFsgMCwgMSwgMSwgMiwgMiwgMywgMywgMCwgNCwgNSwgNSwgNiwgNiwgNywgNywgNCwgMCwgNCwgMSwgNSwgMiwgNiwgMywgNyBdICk7XFxuXFxuXFx0XFx0dmFyIHBvc2l0aW9ucyA9IFsgMSwgMSwgMSwgLSAxLCAxLCAxLCAtIDEsIC0gMSwgMSwgMSwgLSAxLCAxLCAxLCAxLCAtIDEsIC0gMSwgMSwgLSAxLCAtIDEsIC0gMSwgLSAxLCAxLCAtIDEsIC0gMSBdO1xcblxcblxcdFxcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcblxcblxcdFxcdGdlb21ldHJ5LnNldEluZGV4KCBuZXcgQnVmZmVyQXR0cmlidXRlKCBpbmRpY2VzLCAxICkgKTtcXG5cXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xcblxcblxcdFxcdExpbmVTZWdtZW50cy5jYWxsKCB0aGlzLCBnZW9tZXRyeSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciB9ICkgKTtcXG5cXG5cXHRcXHR0aGlzLmdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xcblxcblxcdH1cXG5cXG5cXHRCb3gzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcXG5cXHRCb3gzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEJveDNIZWxwZXI7XFxuXFxuXFx0Qm94M0hlbHBlci5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQgPSBmdW5jdGlvbiAoIGZvcmNlICkge1xcblxcblxcdFxcdHZhciBib3ggPSB0aGlzLmJveDtcXG5cXG5cXHRcXHRpZiAoIGJveC5pc0VtcHR5KCkgKSByZXR1cm47XFxuXFxuXFx0XFx0Ym94LmdldENlbnRlciggdGhpcy5wb3NpdGlvbiApO1xcblxcblxcdFxcdGJveC5nZXRTaXplKCB0aGlzLnNjYWxlICk7XFxuXFxuXFx0XFx0dGhpcy5zY2FsZS5tdWx0aXBseVNjYWxhciggMC41ICk7XFxuXFxuXFx0XFx0T2JqZWN0M0QucHJvdG90eXBlLnVwZGF0ZU1hdHJpeFdvcmxkLmNhbGwoIHRoaXMsIGZvcmNlICk7XFxuXFxuXFx0fTtcXG5cXG5cXHQvKipcXG5cXHQgKiBAYXV0aG9yIFdlc3RMYW5nbGV5IC8gaHR0cDovL2dpdGh1Yi5jb20vV2VzdExhbmdsZXlcXG5cXHQgKi9cXG5cXG5cXHRmdW5jdGlvbiBQbGFuZUhlbHBlciggcGxhbmUsIHNpemUsIGhleCApIHtcXG5cXG5cXHRcXHR0aGlzLnR5cGUgPSAnUGxhbmVIZWxwZXInO1xcblxcblxcdFxcdHRoaXMucGxhbmUgPSBwbGFuZTtcXG5cXG5cXHRcXHR0aGlzLnNpemUgPSAoIHNpemUgPT09IHVuZGVmaW5lZCApID8gMSA6IHNpemU7XFxuXFxuXFx0XFx0dmFyIGNvbG9yID0gKCBoZXggIT09IHVuZGVmaW5lZCApID8gaGV4IDogMHhmZmZmMDA7XFxuXFxuXFx0XFx0dmFyIHBvc2l0aW9ucyA9IFsgMSwgLSAxLCAxLCAtIDEsIDEsIDEsIC0gMSwgLSAxLCAxLCAxLCAxLCAxLCAtIDEsIDEsIDEsIC0gMSwgLSAxLCAxLCAxLCAtIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDEsIDAsIDAsIDAgXTtcXG5cXG5cXHRcXHR2YXIgZ2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdwb3NpdGlvbicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIDMgKSApO1xcblxcdFxcdGdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xcblxcblxcdFxcdExpbmUuY2FsbCggdGhpcywgZ2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XFxuXFxuXFx0XFx0Ly9cXG5cXG5cXHRcXHR2YXIgcG9zaXRpb25zMiA9IFsgMSwgMSwgMSwgLSAxLCAxLCAxLCAtIDEsIC0gMSwgMSwgMSwgMSwgMSwgLSAxLCAtIDEsIDEsIDEsIC0gMSwgMSBdO1xcblxcblxcdFxcdHZhciBnZW9tZXRyeTIgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXG5cXHRcXHRnZW9tZXRyeTIuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zMiwgMyApICk7XFxuXFx0XFx0Z2VvbWV0cnkyLmNvbXB1dGVCb3VuZGluZ1NwaGVyZSgpO1xcblxcblxcdFxcdHRoaXMuYWRkKCBuZXcgTWVzaCggZ2VvbWV0cnkyLCBuZXcgTWVzaEJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGNvbG9yLCBvcGFjaXR5OiAwLjIsIHRyYW5zcGFyZW50OiB0cnVlLCBkZXB0aFdyaXRlOiBmYWxzZSB9ICkgKSApO1xcblxcblxcdH1cXG5cXG5cXHRQbGFuZUhlbHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBMaW5lLnByb3RvdHlwZSApO1xcblxcdFBsYW5lSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBsYW5lSGVscGVyO1xcblxcblxcdFBsYW5lSGVscGVyLnByb3RvdHlwZS51cGRhdGVNYXRyaXhXb3JsZCA9IGZ1bmN0aW9uICggZm9yY2UgKSB7XFxuXFxuXFx0XFx0dmFyIHNjYWxlID0gLSB0aGlzLnBsYW5lLmNvbnN0YW50O1xcblxcblxcdFxcdGlmICggTWF0aC5hYnMoIHNjYWxlICkgPCAxZS04ICkgc2NhbGUgPSAxZS04OyAvLyBzaWduIGRvZXMgbm90IG1hdHRlclxcblxcblxcdFxcdHRoaXMuc2NhbGUuc2V0KCAwLjUgKiB0aGlzLnNpemUsIDAuNSAqIHRoaXMuc2l6ZSwgc2NhbGUgKTtcXG5cXG5cXHRcXHR0aGlzLmxvb2tBdCggdGhpcy5wbGFuZS5ub3JtYWwgKTtcXG5cXG5cXHRcXHRPYmplY3QzRC5wcm90b3R5cGUudXBkYXRlTWF0cml4V29ybGQuY2FsbCggdGhpcywgZm9yY2UgKTtcXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgV2VzdExhbmdsZXkgLyBodHRwOi8vZ2l0aHViLmNvbS9XZXN0TGFuZ2xleVxcblxcdCAqIEBhdXRob3Igeno4NSAvIGh0dHA6Ly9naXRodWIuY29tL3p6ODVcXG5cXHQgKiBAYXV0aG9yIGJob3VzdG9uIC8gaHR0cDovL2NsYXJhLmlvXFxuXFx0ICpcXG5cXHQgKiBDcmVhdGVzIGFuIGFycm93IGZvciB2aXN1YWxpemluZyBkaXJlY3Rpb25zXFxuXFx0ICpcXG5cXHQgKiBQYXJhbWV0ZXJzOlxcblxcdCAqICBkaXIgLSBWZWN0b3IzXFxuXFx0ICogIG9yaWdpbiAtIFZlY3RvcjNcXG5cXHQgKiAgbGVuZ3RoIC0gTnVtYmVyXFxuXFx0ICogIGNvbG9yIC0gY29sb3IgaW4gaGV4IHZhbHVlXFxuXFx0ICogIGhlYWRMZW5ndGggLSBOdW1iZXJcXG5cXHQgKiAgaGVhZFdpZHRoIC0gTnVtYmVyXFxuXFx0ICovXFxuXFxuXFx0dmFyIGxpbmVHZW9tZXRyeTtcXG5cXHR2YXIgY29uZUdlb21ldHJ5O1xcblxcblxcdGZ1bmN0aW9uIEFycm93SGVscGVyKCBkaXIsIG9yaWdpbiwgbGVuZ3RoLCBjb2xvciwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICkge1xcblxcblxcdFxcdC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcXG5cXG5cXHRcXHRPYmplY3QzRC5jYWxsKCB0aGlzICk7XFxuXFxuXFx0XFx0aWYgKCBjb2xvciA9PT0gdW5kZWZpbmVkICkgY29sb3IgPSAweGZmZmYwMDtcXG5cXHRcXHRpZiAoIGxlbmd0aCA9PT0gdW5kZWZpbmVkICkgbGVuZ3RoID0gMTtcXG5cXHRcXHRpZiAoIGhlYWRMZW5ndGggPT09IHVuZGVmaW5lZCApIGhlYWRMZW5ndGggPSAwLjIgKiBsZW5ndGg7XFxuXFx0XFx0aWYgKCBoZWFkV2lkdGggPT09IHVuZGVmaW5lZCApIGhlYWRXaWR0aCA9IDAuMiAqIGhlYWRMZW5ndGg7XFxuXFxuXFx0XFx0aWYgKCBsaW5lR2VvbWV0cnkgPT09IHVuZGVmaW5lZCApIHtcXG5cXG5cXHRcXHRcXHRsaW5lR2VvbWV0cnkgPSBuZXcgQnVmZmVyR2VvbWV0cnkoKTtcXG5cXHRcXHRcXHRsaW5lR2VvbWV0cnkuYWRkQXR0cmlidXRlKCAncG9zaXRpb24nLCBuZXcgRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSggWyAwLCAwLCAwLCAwLCAxLCAwIF0sIDMgKSApO1xcblxcblxcdFxcdFxcdGNvbmVHZW9tZXRyeSA9IG5ldyBDeWxpbmRlckJ1ZmZlckdlb21ldHJ5KCAwLCAwLjUsIDEsIDUsIDEgKTtcXG5cXHRcXHRcXHRjb25lR2VvbWV0cnkudHJhbnNsYXRlKCAwLCAtIDAuNSwgMCApO1xcblxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLnBvc2l0aW9uLmNvcHkoIG9yaWdpbiApO1xcblxcblxcdFxcdHRoaXMubGluZSA9IG5ldyBMaW5lKCBsaW5lR2VvbWV0cnksIG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogY29sb3IgfSApICk7XFxuXFx0XFx0dGhpcy5saW5lLm1hdHJpeEF1dG9VcGRhdGUgPSBmYWxzZTtcXG5cXHRcXHR0aGlzLmFkZCggdGhpcy5saW5lICk7XFxuXFxuXFx0XFx0dGhpcy5jb25lID0gbmV3IE1lc2goIGNvbmVHZW9tZXRyeSwgbmV3IE1lc2hCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBjb2xvciB9ICkgKTtcXG5cXHRcXHR0aGlzLmNvbmUubWF0cml4QXV0b1VwZGF0ZSA9IGZhbHNlO1xcblxcdFxcdHRoaXMuYWRkKCB0aGlzLmNvbmUgKTtcXG5cXG5cXHRcXHR0aGlzLnNldERpcmVjdGlvbiggZGlyICk7XFxuXFx0XFx0dGhpcy5zZXRMZW5ndGgoIGxlbmd0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XFxuXFxuXFx0fVxcblxcblxcdEFycm93SGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE9iamVjdDNELnByb3RvdHlwZSApO1xcblxcdEFycm93SGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFycm93SGVscGVyO1xcblxcblxcdEFycm93SGVscGVyLnByb3RvdHlwZS5zZXREaXJlY3Rpb24gPSAoIGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHR2YXIgYXhpcyA9IG5ldyBWZWN0b3IzKCk7XFxuXFx0XFx0dmFyIHJhZGlhbnM7XFxuXFxuXFx0XFx0cmV0dXJuIGZ1bmN0aW9uIHNldERpcmVjdGlvbiggZGlyICkge1xcblxcblxcdFxcdFxcdC8vIGRpciBpcyBhc3N1bWVkIHRvIGJlIG5vcm1hbGl6ZWRcXG5cXG5cXHRcXHRcXHRpZiAoIGRpci55ID4gMC45OTk5OSApIHtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnF1YXRlcm5pb24uc2V0KCAwLCAwLCAwLCAxICk7XFxuXFxuXFx0XFx0XFx0fSBlbHNlIGlmICggZGlyLnkgPCAtIDAuOTk5OTkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dGhpcy5xdWF0ZXJuaW9uLnNldCggMSwgMCwgMCwgMCApO1xcblxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFxuXFx0XFx0XFx0XFx0YXhpcy5zZXQoIGRpci56LCAwLCAtIGRpci54ICkubm9ybWFsaXplKCk7XFxuXFxuXFx0XFx0XFx0XFx0cmFkaWFucyA9IE1hdGguYWNvcyggZGlyLnkgKTtcXG5cXG5cXHRcXHRcXHRcXHR0aGlzLnF1YXRlcm5pb24uc2V0RnJvbUF4aXNBbmdsZSggYXhpcywgcmFkaWFucyApO1xcblxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHR9O1xcblxcblxcdH0oKSApO1xcblxcblxcdEFycm93SGVscGVyLnByb3RvdHlwZS5zZXRMZW5ndGggPSBmdW5jdGlvbiAoIGxlbmd0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICkge1xcblxcblxcdFxcdGlmICggaGVhZExlbmd0aCA9PT0gdW5kZWZpbmVkICkgaGVhZExlbmd0aCA9IDAuMiAqIGxlbmd0aDtcXG5cXHRcXHRpZiAoIGhlYWRXaWR0aCA9PT0gdW5kZWZpbmVkICkgaGVhZFdpZHRoID0gMC4yICogaGVhZExlbmd0aDtcXG5cXG5cXHRcXHR0aGlzLmxpbmUuc2NhbGUuc2V0KCAxLCBNYXRoLm1heCggMCwgbGVuZ3RoIC0gaGVhZExlbmd0aCApLCAxICk7XFxuXFx0XFx0dGhpcy5saW5lLnVwZGF0ZU1hdHJpeCgpO1xcblxcblxcdFxcdHRoaXMuY29uZS5zY2FsZS5zZXQoIGhlYWRXaWR0aCwgaGVhZExlbmd0aCwgaGVhZFdpZHRoICk7XFxuXFx0XFx0dGhpcy5jb25lLnBvc2l0aW9uLnkgPSBsZW5ndGg7XFxuXFx0XFx0dGhpcy5jb25lLnVwZGF0ZU1hdHJpeCgpO1xcblxcblxcdH07XFxuXFxuXFx0QXJyb3dIZWxwZXIucHJvdG90eXBlLnNldENvbG9yID0gZnVuY3Rpb24gKCBjb2xvciApIHtcXG5cXG5cXHRcXHR0aGlzLmxpbmUubWF0ZXJpYWwuY29sb3IuY29weSggY29sb3IgKTtcXG5cXHRcXHR0aGlzLmNvbmUubWF0ZXJpYWwuY29sb3IuY29weSggY29sb3IgKTtcXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3Igc3JvdWNoZXJheSAvIGh0dHA6Ly9zcm91Y2hlcmF5Lm9yZy9cXG5cXHQgKiBAYXV0aG9yIG1yZG9vYiAvIGh0dHA6Ly9tcmRvb2IuY29tL1xcblxcdCAqL1xcblxcblxcdGZ1bmN0aW9uIEF4ZXNIZWxwZXIoIHNpemUgKSB7XFxuXFxuXFx0XFx0c2l6ZSA9IHNpemUgfHwgMTtcXG5cXG5cXHRcXHR2YXIgdmVydGljZXMgPSBbXFxuXFx0XFx0XFx0MCwgMCwgMCxcXHRzaXplLCAwLCAwLFxcblxcdFxcdFxcdDAsIDAsIDAsXFx0MCwgc2l6ZSwgMCxcXG5cXHRcXHRcXHQwLCAwLCAwLFxcdDAsIDAsIHNpemVcXG5cXHRcXHRdO1xcblxcblxcdFxcdHZhciBjb2xvcnMgPSBbXFxuXFx0XFx0XFx0MSwgMCwgMCxcXHQxLCAwLjYsIDAsXFxuXFx0XFx0XFx0MCwgMSwgMCxcXHQwLjYsIDEsIDAsXFxuXFx0XFx0XFx0MCwgMCwgMSxcXHQwLCAwLjYsIDFcXG5cXHRcXHRdO1xcblxcblxcdFxcdHZhciBnZW9tZXRyeSA9IG5ldyBCdWZmZXJHZW9tZXRyeSgpO1xcblxcdFxcdGdlb21ldHJ5LmFkZEF0dHJpYnV0ZSggJ3Bvc2l0aW9uJywgbmV3IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGUoIHZlcnRpY2VzLCAzICkgKTtcXG5cXHRcXHRnZW9tZXRyeS5hZGRBdHRyaWJ1dGUoICdjb2xvcicsIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBjb2xvcnMsIDMgKSApO1xcblxcblxcdFxcdHZhciBtYXRlcmlhbCA9IG5ldyBMaW5lQmFzaWNNYXRlcmlhbCggeyB2ZXJ0ZXhDb2xvcnM6IFZlcnRleENvbG9ycyB9ICk7XFxuXFxuXFx0XFx0TGluZVNlZ21lbnRzLmNhbGwoIHRoaXMsIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xcblxcblxcdH1cXG5cXG5cXHRBeGVzSGVscGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTZWdtZW50cy5wcm90b3R5cGUgKTtcXG5cXHRBeGVzSGVscGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEF4ZXNIZWxwZXI7XFxuXFxuXFx0LyoqXFxuXFx0ICogQGF1dGhvciBhbHRlcmVkcSAvIGh0dHA6Ly9hbHRlcmVkcXVhbGlhLmNvbS9cXG5cXHQgKi9cXG5cXG5cXHR2YXIgU2NlbmVVdGlscyA9IHtcXG5cXG5cXHRcXHRjcmVhdGVNdWx0aU1hdGVyaWFsT2JqZWN0OiBmdW5jdGlvbiAoIGdlb21ldHJ5LCBtYXRlcmlhbHMgKSB7XFxuXFxuXFx0XFx0XFx0dmFyIGdyb3VwID0gbmV3IEdyb3VwKCk7XFxuXFxuXFx0XFx0XFx0Zm9yICggdmFyIGkgPSAwLCBsID0gbWF0ZXJpYWxzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Z3JvdXAuYWRkKCBuZXcgTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsc1sgaSBdICkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGdyb3VwO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0ZGV0YWNoOiBmdW5jdGlvbiAoIGNoaWxkLCBwYXJlbnQsIHNjZW5lICkge1xcblxcblxcdFxcdFxcdGNoaWxkLmFwcGx5TWF0cml4KCBwYXJlbnQubWF0cml4V29ybGQgKTtcXG5cXHRcXHRcXHRwYXJlbnQucmVtb3ZlKCBjaGlsZCApO1xcblxcdFxcdFxcdHNjZW5lLmFkZCggY2hpbGQgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGF0dGFjaDogZnVuY3Rpb24gKCBjaGlsZCwgc2NlbmUsIHBhcmVudCApIHtcXG5cXG5cXHRcXHRcXHRjaGlsZC5hcHBseU1hdHJpeCggbmV3IE1hdHJpeDQoKS5nZXRJbnZlcnNlKCBwYXJlbnQubWF0cml4V29ybGQgKSApO1xcblxcblxcdFxcdFxcdHNjZW5lLnJlbW92ZSggY2hpbGQgKTtcXG5cXHRcXHRcXHRwYXJlbnQuYWRkKCBjaGlsZCApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9O1xcblxcblxcdC8qKlxcblxcdCAqIEBhdXRob3IgbXJkb29iIC8gaHR0cDovL21yZG9vYi5jb20vXFxuXFx0ICovXFxuXFxuXFx0ZnVuY3Rpb24gRmFjZTQoIGEsIGIsIGMsIGQsIG5vcm1hbCwgY29sb3IsIG1hdGVyaWFsSW5kZXggKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuRmFjZTQgaGFzIGJlZW4gcmVtb3ZlZC4gQSBUSFJFRS5GYWNlMyB3aWxsIGJlIGNyZWF0ZWQgaW5zdGVhZC4nICk7XFxuXFx0XFx0cmV0dXJuIG5ldyBGYWNlMyggYSwgYiwgYywgbm9ybWFsLCBjb2xvciwgbWF0ZXJpYWxJbmRleCApO1xcblxcblxcdH1cXG5cXG5cXHR2YXIgTGluZVN0cmlwID0gMDtcXG5cXG5cXHR2YXIgTGluZVBpZWNlcyA9IDE7XFxuXFxuXFx0ZnVuY3Rpb24gTWVzaEZhY2VNYXRlcmlhbCggbWF0ZXJpYWxzICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1lc2hGYWNlTWF0ZXJpYWwgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIGFuIEFycmF5IGluc3RlYWQuJyApO1xcblxcdFxcdHJldHVybiBtYXRlcmlhbHM7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIE11bHRpTWF0ZXJpYWwoIG1hdGVyaWFscyApIHtcXG5cXG5cXHRcXHRpZiAoIG1hdGVyaWFscyA9PT0gdW5kZWZpbmVkICkgbWF0ZXJpYWxzID0gW107XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTXVsdGlNYXRlcmlhbCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgYW4gQXJyYXkgaW5zdGVhZC4nICk7XFxuXFx0XFx0bWF0ZXJpYWxzLmlzTXVsdGlNYXRlcmlhbCA9IHRydWU7XFxuXFx0XFx0bWF0ZXJpYWxzLm1hdGVyaWFscyA9IG1hdGVyaWFscztcXG5cXHRcXHRtYXRlcmlhbHMuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG1hdGVyaWFscy5zbGljZSgpO1xcblxcblxcdFxcdH07XFxuXFx0XFx0cmV0dXJuIG1hdGVyaWFscztcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gUG9pbnRDbG91ZCggZ2VvbWV0cnksIG1hdGVyaWFsICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBvaW50Q2xvdWQgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5Qb2ludHMuJyApO1xcblxcdFxcdHJldHVybiBuZXcgUG9pbnRzKCBnZW9tZXRyeSwgbWF0ZXJpYWwgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gUGFydGljbGUoIG1hdGVyaWFsICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuU3ByaXRlLicgKTtcXG5cXHRcXHRyZXR1cm4gbmV3IFNwcml0ZSggbWF0ZXJpYWwgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gUGFydGljbGVTeXN0ZW0oIGdlb21ldHJ5LCBtYXRlcmlhbCApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5QYXJ0aWNsZVN5c3RlbSBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50cy4nICk7XFxuXFx0XFx0cmV0dXJuIG5ldyBQb2ludHMoIGdlb21ldHJ5LCBtYXRlcmlhbCApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBQb2ludENsb3VkTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUG9pbnRDbG91ZE1hdGVyaWFsIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuUG9pbnRzTWF0ZXJpYWwuJyApO1xcblxcdFxcdHJldHVybiBuZXcgUG9pbnRzTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gUGFydGljbGVCYXNpY01hdGVyaWFsKCBwYXJhbWV0ZXJzICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBhcnRpY2xlQmFzaWNNYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicgKTtcXG5cXHRcXHRyZXR1cm4gbmV3IFBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFBhcnRpY2xlU3lzdGVtTWF0ZXJpYWwoIHBhcmFtZXRlcnMgKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLlBvaW50c01hdGVyaWFsLicgKTtcXG5cXHRcXHRyZXR1cm4gbmV3IFBvaW50c01hdGVyaWFsKCBwYXJhbWV0ZXJzICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFZlcnRleCggeCwgeSwgeiApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZXJ0ZXggaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLlZlY3RvcjMgaW5zdGVhZC4nICk7XFxuXFx0XFx0cmV0dXJuIG5ldyBWZWN0b3IzKCB4LCB5LCB6ICk7XFxuXFxuXFx0fVxcblxcblxcdC8vXFxuXFxuXFx0ZnVuY3Rpb24gRHluYW1pY0J1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkR5bmFtaWNCdWZmZXJBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5CdWZmZXJBdHRyaWJ1dGUoKS5zZXREeW5hbWljKCB0cnVlICkgaW5zdGVhZC4nICk7XFxuXFx0XFx0cmV0dXJuIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApLnNldER5bmFtaWMoIHRydWUgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gSW50OEF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkludDhBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5JbnQ4QnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nICk7XFxuXFx0XFx0cmV0dXJuIG5ldyBJbnQ4QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gVWludDhBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5VaW50OEF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLlVpbnQ4QnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nICk7XFxuXFx0XFx0cmV0dXJuIG5ldyBVaW50OEJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFVpbnQ4Q2xhbXBlZEF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlVpbnQ4Q2xhbXBlZEF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLlVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyApO1xcblxcdFxcdHJldHVybiBuZXcgVWludDhDbGFtcGVkQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gSW50MTZBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5JbnQxNkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkludDE2QnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nICk7XFxuXFx0XFx0cmV0dXJuIG5ldyBJbnQxNkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFVpbnQxNkF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlVpbnQxNkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLlVpbnQxNkJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyApO1xcblxcdFxcdHJldHVybiBuZXcgVWludDE2QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gSW50MzJBdHRyaWJ1dGUoIGFycmF5LCBpdGVtU2l6ZSApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5JbnQzMkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLkludDMyQnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nICk7XFxuXFx0XFx0cmV0dXJuIG5ldyBJbnQzMkJ1ZmZlckF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIFVpbnQzMkF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlVpbnQzMkF0dHJpYnV0ZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgbmV3IFRIUkVFLlVpbnQzMkJ1ZmZlckF0dHJpYnV0ZSgpIGluc3RlYWQuJyApO1xcblxcdFxcdHJldHVybiBuZXcgVWludDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gRmxvYXQzMkF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZsb2F0MzJBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5GbG9hdDMyQnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nICk7XFxuXFx0XFx0cmV0dXJuIG5ldyBGbG9hdDMyQnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcXG5cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gRmxvYXQ2NEF0dHJpYnV0ZSggYXJyYXksIGl0ZW1TaXplICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkZsb2F0NjRBdHRyaWJ1dGUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5GbG9hdDY0QnVmZmVyQXR0cmlidXRlKCkgaW5zdGVhZC4nICk7XFxuXFx0XFx0cmV0dXJuIG5ldyBGbG9hdDY0QnVmZmVyQXR0cmlidXRlKCBhcnJheSwgaXRlbVNpemUgKTtcXG5cXG5cXHR9XFxuXFxuXFx0Ly9cXG5cXG5cXHRDdXJ2ZS5jcmVhdGUgPSBmdW5jdGlvbiAoIGNvbnN0cnVjdCwgZ2V0UG9pbnQgKSB7XFxuXFxuXFx0XFx0Y29uc29sZS5sb2coICdUSFJFRS5DdXJ2ZS5jcmVhdGUoKSBoYXMgYmVlbiBkZXByZWNhdGVkJyApO1xcblxcblxcdFxcdGNvbnN0cnVjdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDdXJ2ZS5wcm90b3R5cGUgKTtcXG5cXHRcXHRjb25zdHJ1Y3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY29uc3RydWN0O1xcblxcdFxcdGNvbnN0cnVjdC5wcm90b3R5cGUuZ2V0UG9pbnQgPSBnZXRQb2ludDtcXG5cXG5cXHRcXHRyZXR1cm4gY29uc3RydWN0O1xcblxcblxcdH07XFxuXFxuXFx0Ly9cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBDdXJ2ZVBhdGgucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0Y3JlYXRlUG9pbnRzR2VvbWV0cnk6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkN1cnZlUGF0aDogLmNyZWF0ZVBvaW50c0dlb21ldHJ5KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5HZW9tZXRyeSgpLnNldEZyb21Qb2ludHMoIHBvaW50cyApIGluc3RlYWQuJyApO1xcblxcblxcdFxcdFxcdC8vIGdlbmVyYXRlIGdlb21ldHJ5IGZyb20gcGF0aCBwb2ludHMgKGZvciBMaW5lIG9yIFBvaW50cyBvYmplY3RzKVxcblxcblxcdFxcdFxcdHZhciBwdHMgPSB0aGlzLmdldFBvaW50cyggZGl2aXNpb25zICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnkoIHB0cyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y3JlYXRlU3BhY2VkUG9pbnRzR2VvbWV0cnk6IGZ1bmN0aW9uICggZGl2aXNpb25zICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkN1cnZlUGF0aDogLmNyZWF0ZVNwYWNlZFBvaW50c0dlb21ldHJ5KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG5ldyBUSFJFRS5HZW9tZXRyeSgpLnNldEZyb21Qb2ludHMoIHBvaW50cyApIGluc3RlYWQuJyApO1xcblxcblxcdFxcdFxcdC8vIGdlbmVyYXRlIGdlb21ldHJ5IGZyb20gZXF1aWRpc3RhbnQgc2FtcGxpbmcgYWxvbmcgdGhlIHBhdGhcXG5cXG5cXHRcXHRcXHR2YXIgcHRzID0gdGhpcy5nZXRTcGFjZWRQb2ludHMoIGRpdmlzaW9ucyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5KCBwdHMgKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGNyZWF0ZUdlb21ldHJ5OiBmdW5jdGlvbiAoIHBvaW50cyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5DdXJ2ZVBhdGg6IC5jcmVhdGVHZW9tZXRyeSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuR2VvbWV0cnkoKS5zZXRGcm9tUG9pbnRzKCBwb2ludHMgKSBpbnN0ZWFkLicgKTtcXG5cXG5cXHRcXHRcXHR2YXIgZ2VvbWV0cnkgPSBuZXcgR2VvbWV0cnkoKTtcXG5cXG5cXHRcXHRcXHRmb3IgKCB2YXIgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcXG5cXG5cXHRcXHRcXHRcXHR2YXIgcG9pbnQgPSBwb2ludHNbIGkgXTtcXG5cXHRcXHRcXHRcXHRnZW9tZXRyeS52ZXJ0aWNlcy5wdXNoKCBuZXcgVmVjdG9yMyggcG9pbnQueCwgcG9pbnQueSwgcG9pbnQueiB8fCAwICkgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGdlb21ldHJ5O1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0Ly9cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBQYXRoLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGZyb21Qb2ludHM6IGZ1bmN0aW9uICggcG9pbnRzICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlBhdGg6IC5mcm9tUG9pbnRzKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbVBvaW50cygpLicgKTtcXG5cXHRcXHRcXHR0aGlzLnNldEZyb21Qb2ludHMoIHBvaW50cyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0Ly9cXG5cXG5cXHRmdW5jdGlvbiBDbG9zZWRTcGxpbmVDdXJ2ZTMoIHBvaW50cyApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5DbG9zZWRTcGxpbmVDdXJ2ZTMgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFRIUkVFLkNhdG11bGxSb21DdXJ2ZTMgaW5zdGVhZC4nICk7XFxuXFxuXFx0XFx0Q2F0bXVsbFJvbUN1cnZlMy5jYWxsKCB0aGlzLCBwb2ludHMgKTtcXG5cXHRcXHR0aGlzLnR5cGUgPSAnY2F0bXVsbHJvbSc7XFxuXFx0XFx0dGhpcy5jbG9zZWQgPSB0cnVlO1xcblxcblxcdH1cXG5cXG5cXHRDbG9zZWRTcGxpbmVDdXJ2ZTMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQ2F0bXVsbFJvbUN1cnZlMy5wcm90b3R5cGUgKTtcXG5cXG5cXHQvL1xcblxcblxcdGZ1bmN0aW9uIFNwbGluZUN1cnZlMyggcG9pbnRzICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNwbGluZUN1cnZlMyBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuQ2F0bXVsbFJvbUN1cnZlMyBpbnN0ZWFkLicgKTtcXG5cXG5cXHRcXHRDYXRtdWxsUm9tQ3VydmUzLmNhbGwoIHRoaXMsIHBvaW50cyApO1xcblxcdFxcdHRoaXMudHlwZSA9ICdjYXRtdWxscm9tJztcXG5cXG5cXHR9XFxuXFxuXFx0U3BsaW5lQ3VydmUzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIENhdG11bGxSb21DdXJ2ZTMucHJvdG90eXBlICk7XFxuXFxuXFx0Ly9cXG5cXG5cXHRmdW5jdGlvbiBTcGxpbmUoIHBvaW50cyApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5TcGxpbmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkNhdG11bGxSb21DdXJ2ZTMgaW5zdGVhZC4nICk7XFxuXFxuXFx0XFx0Q2F0bXVsbFJvbUN1cnZlMy5jYWxsKCB0aGlzLCBwb2ludHMgKTtcXG5cXHRcXHR0aGlzLnR5cGUgPSAnY2F0bXVsbHJvbSc7XFxuXFxuXFx0fVxcblxcblxcdFNwbGluZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDYXRtdWxsUm9tQ3VydmUzLnByb3RvdHlwZSApO1xcblxcblxcdE9iamVjdC5hc3NpZ24oIFNwbGluZS5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRpbml0RnJvbUFycmF5OiBmdW5jdGlvbiAoIC8qIGEgKi8gKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlNwbGluZTogLmluaXRGcm9tQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGdldENvbnRyb2xQb2ludHNBcnJheTogZnVuY3Rpb24gKCAvKiBvcHRpb25hbFRhcmdldCAqLyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuU3BsaW5lOiAuZ2V0Q29udHJvbFBvaW50c0FycmF5KCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRyZXBhcmFtZXRyaXplQnlBcmNMZW5ndGg6IGZ1bmN0aW9uICggLyogc2FtcGxpbmdDb2VmICovICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5TcGxpbmU6IC5yZXBhcmFtZXRyaXplQnlBcmNMZW5ndGgoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8vXFxuXFxuXFx0ZnVuY3Rpb24gQXhpc0hlbHBlciggc2l6ZSApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5BeGlzSGVscGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gVEhSRUUuQXhlc0hlbHBlci4nICk7XFxuXFx0XFx0cmV0dXJuIG5ldyBBeGVzSGVscGVyKCBzaXplICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIEJvdW5kaW5nQm94SGVscGVyKCBvYmplY3QsIGNvbG9yICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJvdW5kaW5nQm94SGVscGVyIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIENyZWF0aW5nIGEgVEhSRUUuQm94SGVscGVyIGluc3RlYWQuJyApO1xcblxcdFxcdHJldHVybiBuZXcgQm94SGVscGVyKCBvYmplY3QsIGNvbG9yICk7XFxuXFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIEVkZ2VzSGVscGVyKCBvYmplY3QsIGhleCApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5FZGdlc0hlbHBlciBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuRWRnZXNHZW9tZXRyeSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRyZXR1cm4gbmV3IExpbmVTZWdtZW50cyggbmV3IEVkZ2VzR2VvbWV0cnkoIG9iamVjdC5nZW9tZXRyeSApLCBuZXcgTGluZUJhc2ljTWF0ZXJpYWwoIHsgY29sb3I6IGhleCAhPT0gdW5kZWZpbmVkID8gaGV4IDogMHhmZmZmZmYgfSApICk7XFxuXFxuXFx0fVxcblxcblxcdEdyaWRIZWxwZXIucHJvdG90eXBlLnNldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuR3JpZEhlbHBlcjogc2V0Q29sb3JzKCkgaGFzIGJlZW4gZGVwcmVjYXRlZCwgcGFzcyB0aGVtIGluIHRoZSBjb25zdHJ1Y3RvciBpbnN0ZWFkLicgKTtcXG5cXG5cXHR9O1xcblxcblxcdFNrZWxldG9uSGVscGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlNrZWxldG9uSGVscGVyOiB1cGRhdGUoKSBubyBsb25nZXIgbmVlZHMgdG8gYmUgY2FsbGVkLicgKTtcXG5cXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIFdpcmVmcmFtZUhlbHBlciggb2JqZWN0LCBoZXggKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2lyZWZyYW1lSGVscGVyIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5XaXJlZnJhbWVHZW9tZXRyeSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRyZXR1cm4gbmV3IExpbmVTZWdtZW50cyggbmV3IFdpcmVmcmFtZUdlb21ldHJ5KCBvYmplY3QuZ2VvbWV0cnkgKSwgbmV3IExpbmVCYXNpY01hdGVyaWFsKCB7IGNvbG9yOiBoZXggIT09IHVuZGVmaW5lZCA/IGhleCA6IDB4ZmZmZmZmIH0gKSApO1xcblxcblxcdH1cXG5cXG5cXHQvL1xcblxcblxcdE9iamVjdC5hc3NpZ24oIExvYWRlci5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRleHRyYWN0VXJsQmFzZTogZnVuY3Rpb24gKCB1cmwgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTG9hZGVyOiAuZXh0cmFjdFVybEJhc2UoKSBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UoKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gTG9hZGVyVXRpbHMuZXh0cmFjdFVybEJhc2UoIHVybCApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0ZnVuY3Rpb24gWEhSTG9hZGVyKCBtYW5hZ2VyICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlhIUkxvYWRlciBoYXMgYmVlbiByZW5hbWVkIHRvIFRIUkVFLkZpbGVMb2FkZXIuJyApO1xcblxcdFxcdHJldHVybiBuZXcgRmlsZUxvYWRlciggbWFuYWdlciApO1xcblxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBCaW5hcnlUZXh0dXJlTG9hZGVyKCBtYW5hZ2VyICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJpbmFyeVRleHR1cmVMb2FkZXIgaGFzIGJlZW4gcmVuYW1lZCB0byBUSFJFRS5EYXRhVGV4dHVyZUxvYWRlci4nICk7XFxuXFx0XFx0cmV0dXJuIG5ldyBEYXRhVGV4dHVyZUxvYWRlciggbWFuYWdlciApO1xcblxcblxcdH1cXG5cXG5cXHQvL1xcblxcblxcdE9iamVjdC5hc3NpZ24oIEJveDIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDI6IC5jZW50ZXIoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRDZW50ZXIoKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0Q2VudGVyKCBvcHRpb25hbFRhcmdldCApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0ZW1wdHk6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gyOiAuZW1wdHkoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pc0VtcHR5KCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmlzRW1wdHkoKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoIGJveCApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gyOiAuaXNJbnRlcnNlY3Rpb25Cb3goKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzQm94KCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmludGVyc2VjdHNCb3goIGJveCApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0c2l6ZTogZnVuY3Rpb24gKCBvcHRpb25hbFRhcmdldCApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gyOiAuc2l6ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldFNpemUoKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0U2l6ZSggb3B0aW9uYWxUYXJnZXQgKTtcXG5cXG5cXHRcXHR9XFxuXFx0fSApO1xcblxcblxcdE9iamVjdC5hc3NpZ24oIEJveDMucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0Y2VudGVyOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDM6IC5jZW50ZXIoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRDZW50ZXIoKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZ2V0Q2VudGVyKCBvcHRpb25hbFRhcmdldCApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0ZW1wdHk6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gzOiAuZW1wdHkoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pc0VtcHR5KCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmlzRW1wdHkoKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGlzSW50ZXJzZWN0aW9uQm94OiBmdW5jdGlvbiAoIGJveCApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Cb3gzOiAuaXNJbnRlcnNlY3Rpb25Cb3goKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzQm94KCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmludGVyc2VjdHNCb3goIGJveCApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0aXNJbnRlcnNlY3Rpb25TcGhlcmU6IGZ1bmN0aW9uICggc3BoZXJlICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDM6IC5pc0ludGVyc2VjdGlvblNwaGVyZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNTcGhlcmUoKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRzaXplOiBmdW5jdGlvbiAoIG9wdGlvbmFsVGFyZ2V0ICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJveDM6IC5zaXplKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZ2V0U2l6ZSgpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXRTaXplKCBvcHRpb25hbFRhcmdldCApO1xcblxcblxcdFxcdH1cXG5cXHR9ICk7XFxuXFxuXFx0TGluZTMucHJvdG90eXBlLmNlbnRlciA9IGZ1bmN0aW9uICggb3B0aW9uYWxUYXJnZXQgKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGluZTM6IC5jZW50ZXIoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5nZXRDZW50ZXIoKS4nICk7XFxuXFx0XFx0cmV0dXJuIHRoaXMuZ2V0Q2VudGVyKCBvcHRpb25hbFRhcmdldCApO1xcblxcblxcdH07XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggX01hdGgsIHtcXG5cXG5cXHRcXHRyYW5kb20xNjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGg6IC5yYW5kb20xNigpIGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBNYXRoLnJhbmRvbSgpIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdHJldHVybiBNYXRoLnJhbmRvbSgpO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bmVhcmVzdFBvd2VyT2ZUd286IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0aDogLm5lYXJlc3RQb3dlck9mVHdvKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZmxvb3JQb3dlck9mVHdvKCkuJyApO1xcblxcdFxcdFxcdHJldHVybiBfTWF0aC5mbG9vclBvd2VyT2ZUd28oIHZhbHVlICk7XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRuZXh0UG93ZXJPZlR3bzogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRoOiAubmV4dFBvd2VyT2ZUd28oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5jZWlsUG93ZXJPZlR3bygpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gX01hdGguY2VpbFBvd2VyT2ZUd28oIHZhbHVlICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuYXNzaWduKCBNYXRyaXgzLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGZsYXR0ZW5Ub0FycmF5T2Zmc2V0OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCBcXFwiVEhSRUUuTWF0cml4MzogLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC50b0FycmF5KCkgaW5zdGVhZC5cXFwiICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMudG9BcnJheSggYXJyYXksIG9mZnNldCApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0bXVsdGlwbHlWZWN0b3IzOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDMoIG1hdHJpeCApIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXgzKCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRtdWx0aXBseVZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCAvKiBhICovICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXgzOiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGFwcGx5VG9CdWZmZXI6IGZ1bmN0aW9uICggYnVmZmVyIC8qLCBvZmZzZXQsIGxlbmd0aCAqLyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXgzOiAuYXBwbHlUb0J1ZmZlcigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBtYXRyaXguYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlICkgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuYXBwbHlUb0J1ZmZlckF0dHJpYnV0ZSggYnVmZmVyICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRhcHBseVRvVmVjdG9yM0FycmF5OiBmdW5jdGlvbiAoIC8qIGFycmF5LCBvZmZzZXQsIGxlbmd0aCAqLyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4MzogLmFwcGx5VG9WZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdE9iamVjdC5hc3NpZ24oIE1hdHJpeDQucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0ZXh0cmFjdFBvc2l0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLmV4dHJhY3RQb3NpdGlvbigpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmNvcHlQb3NpdGlvbigpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5jb3B5UG9zaXRpb24oIG0gKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGZsYXR0ZW5Ub0FycmF5T2Zmc2V0OiBmdW5jdGlvbiAoIGFycmF5LCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCBcXFwiVEhSRUUuTWF0cml4NDogLmZsYXR0ZW5Ub0FycmF5T2Zmc2V0KCkgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIC50b0FycmF5KCkgaW5zdGVhZC5cXFwiICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMudG9BcnJheSggYXJyYXksIG9mZnNldCApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0Z2V0UG9zaXRpb246IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHR2YXIgdjE7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIGZ1bmN0aW9uIGdldFBvc2l0aW9uKCkge1xcblxcblxcdFxcdFxcdFxcdGlmICggdjEgPT09IHVuZGVmaW5lZCApIHYxID0gbmV3IFZlY3RvcjMoKTtcXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuZ2V0UG9zaXRpb24oKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVmVjdG9yMy5zZXRGcm9tTWF0cml4UG9zaXRpb24oIG1hdHJpeCApIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB2MS5zZXRGcm9tTWF0cml4Q29sdW1uKCB0aGlzLCAzICk7XFxuXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHR9KCksXFxuXFx0XFx0c2V0Um90YXRpb25Gcm9tUXVhdGVybmlvbjogZnVuY3Rpb24gKCBxICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5zZXRSb3RhdGlvbkZyb21RdWF0ZXJuaW9uKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubWFrZVJvdGF0aW9uRnJvbVF1YXRlcm5pb24oIHEgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdG11bHRpcGx5VG9BcnJheTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5tdWx0aXBseVRvQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdG11bHRpcGx5VmVjdG9yMzogZnVuY3Rpb24gKCB2ZWN0b3IgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm11bHRpcGx5VmVjdG9yMygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSB2ZWN0b3IuYXBwbHlNYXRyaXg0KCBtYXRyaXggKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdmVjdG9yLmFwcGx5TWF0cml4NCggdGhpcyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0bXVsdGlwbHlWZWN0b3I0OiBmdW5jdGlvbiAoIHZlY3RvciApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3I0KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHZlY3Rvci5hcHBseU1hdHJpeDQoIG1hdHJpeCApIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdHJldHVybiB2ZWN0b3IuYXBwbHlNYXRyaXg0KCB0aGlzICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRtdWx0aXBseVZlY3RvcjNBcnJheTogZnVuY3Rpb24gKCAvKiBhICovICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAubXVsdGlwbHlWZWN0b3IzQXJyYXkoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdHJvdGF0ZUF4aXM6IGZ1bmN0aW9uICggdiApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAucm90YXRlQXhpcygpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBWZWN0b3IzLnRyYW5zZm9ybURpcmVjdGlvbiggbWF0cml4ICkgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0di50cmFuc2Zvcm1EaXJlY3Rpb24oIHRoaXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGNyb3NzVmVjdG9yOiBmdW5jdGlvbiAoIHZlY3RvciApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRyaXg0OiAuY3Jvc3NWZWN0b3IoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgdmVjdG9yLmFwcGx5TWF0cml4NCggbWF0cml4ICkgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHZlY3Rvci5hcHBseU1hdHJpeDQoIHRoaXMgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAudHJhbnNsYXRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRyb3RhdGVYOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVYKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRyb3RhdGVZOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVZKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRyb3RhdGVaOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLk1hdHJpeDQ6IC5yb3RhdGVaKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRyb3RhdGVCeUF4aXM6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuTWF0cml4NDogLnJvdGF0ZUJ5QXhpcygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0YXBwbHlUb0J1ZmZlcjogZnVuY3Rpb24gKCBidWZmZXIgLyosIG9mZnNldCwgbGVuZ3RoICovICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdHJpeDQ6IC5hcHBseVRvQnVmZmVyKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG1hdHJpeC5hcHBseVRvQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUgKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5hcHBseVRvQnVmZmVyQXR0cmlidXRlKCBidWZmZXIgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGFwcGx5VG9WZWN0b3IzQXJyYXk6IGZ1bmN0aW9uICggLyogYXJyYXksIG9mZnNldCwgbGVuZ3RoICovICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5NYXRyaXg0OiAuYXBwbHlUb1ZlY3RvcjNBcnJheSgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0bWFrZUZydXN0dW06IGZ1bmN0aW9uICggbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTWF0cml4NDogLm1ha2VGcnVzdHVtKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIC5tYWtlUGVyc3BlY3RpdmUoIGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgbmVhciwgZmFyICkgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubWFrZVBlcnNwZWN0aXZlKCBsZWZ0LCByaWdodCwgdG9wLCBib3R0b20sIG5lYXIsIGZhciApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0UGxhbmUucHJvdG90eXBlLmlzSW50ZXJzZWN0aW9uTGluZSA9IGZ1bmN0aW9uICggbGluZSApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5QbGFuZTogLmlzSW50ZXJzZWN0aW9uTGluZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNMaW5lKCkuJyApO1xcblxcdFxcdHJldHVybiB0aGlzLmludGVyc2VjdHNMaW5lKCBsaW5lICk7XFxuXFxuXFx0fTtcXG5cXG5cXHRRdWF0ZXJuaW9uLnByb3RvdHlwZS5tdWx0aXBseVZlY3RvcjMgPSBmdW5jdGlvbiAoIHZlY3RvciApIHtcXG5cXG5cXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5RdWF0ZXJuaW9uOiAubXVsdGlwbHlWZWN0b3IzKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIGlzIG5vdyB2ZWN0b3IuYXBwbHlRdWF0ZXJuaW9uKCBxdWF0ZXJuaW9uICkgaW5zdGVhZC4nICk7XFxuXFx0XFx0cmV0dXJuIHZlY3Rvci5hcHBseVF1YXRlcm5pb24oIHRoaXMgKTtcXG5cXG5cXHR9O1xcblxcblxcdE9iamVjdC5hc3NpZ24oIFJheS5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRpc0ludGVyc2VjdGlvbkJveDogZnVuY3Rpb24gKCBib3ggKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuUmF5OiAuaXNJbnRlcnNlY3Rpb25Cb3goKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5pbnRlcnNlY3RzQm94KCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmludGVyc2VjdHNCb3goIGJveCApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0aXNJbnRlcnNlY3Rpb25QbGFuZTogZnVuY3Rpb24gKCBwbGFuZSApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXk6IC5pc0ludGVyc2VjdGlvblBsYW5lKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuaW50ZXJzZWN0c1BsYW5lKCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmludGVyc2VjdHNQbGFuZSggcGxhbmUgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGlzSW50ZXJzZWN0aW9uU3BoZXJlOiBmdW5jdGlvbiAoIHNwaGVyZSApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5SYXk6IC5pc0ludGVyc2VjdGlvblNwaGVyZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmludGVyc2VjdHNTcGhlcmUoKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuYXNzaWduKCBTaGFwZS5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRleHRyYWN0QWxsUG9pbnRzOiBmdW5jdGlvbiAoIGRpdmlzaW9ucyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5TaGFwZTogLmV4dHJhY3RBbGxQb2ludHMoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLmV4dHJhY3RQb2ludHMoKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5leHRyYWN0UG9pbnRzKCBkaXZpc2lvbnMgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGV4dHJ1ZGU6IGZ1bmN0aW9uICggb3B0aW9ucyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5TaGFwZTogLmV4dHJ1ZGUoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXh0cnVkZUdlb21ldHJ5KCkgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIG5ldyBFeHRydWRlR2VvbWV0cnkoIHRoaXMsIG9wdGlvbnMgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdG1ha2VHZW9tZXRyeTogZnVuY3Rpb24gKCBvcHRpb25zICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYXBlOiAubWFrZUdlb21ldHJ5KCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFNoYXBlR2VvbWV0cnkoKSBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gbmV3IFNoYXBlR2VvbWV0cnkoIHRoaXMsIG9wdGlvbnMgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdE9iamVjdC5hc3NpZ24oIFZlY3RvcjIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0ZnJvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMjogLmZyb21BdHRyaWJ1dGUoKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5mcm9tQnVmZmVyQXR0cmlidXRlKCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmZyb21CdWZmZXJBdHRyaWJ1dGUoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0ZGlzdGFuY2VUb01hbmhhdHRhbjogZnVuY3Rpb24gKCB2ICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjI6IC5kaXN0YW5jZVRvTWFuaGF0dGFuKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFuaGF0dGFuRGlzdGFuY2VUbygpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5tYW5oYXR0YW5EaXN0YW5jZVRvKCB2ICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRsZW5ndGhNYW5oYXR0YW46IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IyOiAubGVuZ3RoTWFuaGF0dGFuKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAubWFuaGF0dGFuTGVuZ3RoKCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLm1hbmhhdHRhbkxlbmd0aCgpO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggVmVjdG9yMy5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRzZXRFdWxlckZyb21Sb3RhdGlvbk1hdHJpeDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5WZWN0b3IzOiAuc2V0RXVsZXJGcm9tUm90YXRpb25NYXRyaXgoKSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgRXVsZXIuc2V0RnJvbVJvdGF0aW9uTWF0cml4KCkgaW5zdGVhZC4nICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRzZXRFdWxlckZyb21RdWF0ZXJuaW9uOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLlZlY3RvcjM6IC5zZXRFdWxlckZyb21RdWF0ZXJuaW9uKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIEV1bGVyLnNldEZyb21RdWF0ZXJuaW9uKCkgaW5zdGVhZC4nICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRnZXRQb3NpdGlvbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggbSApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0UG9zaXRpb25Gcm9tTWF0cml4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0RnJvbU1hdHJpeFBvc2l0aW9uKCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLnNldEZyb21NYXRyaXhQb3NpdGlvbiggbSApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0Z2V0U2NhbGVGcm9tTWF0cml4OiBmdW5jdGlvbiAoIG0gKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmdldFNjYWxlRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhTY2FsZSgpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5zZXRGcm9tTWF0cml4U2NhbGUoIG0gKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGdldENvbHVtbkZyb21NYXRyaXg6IGZ1bmN0aW9uICggaW5kZXgsIG1hdHJpeCApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZ2V0Q29sdW1uRnJvbU1hdHJpeCgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLnNldEZyb21NYXRyaXhDb2x1bW4oKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuc2V0RnJvbU1hdHJpeENvbHVtbiggbWF0cml4LCBpbmRleCApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0YXBwbHlQcm9qZWN0aW9uOiBmdW5jdGlvbiAoIG0gKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmFwcGx5UHJvamVjdGlvbigpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAuYXBwbHlNYXRyaXg0KCBtICkgaW5zdGVhZC4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuYXBwbHlNYXRyaXg0KCBtICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRmcm9tQXR0cmlidXRlOiBmdW5jdGlvbiAoIGF0dHJpYnV0ZSwgaW5kZXgsIG9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5WZWN0b3IzOiAuZnJvbUF0dHJpYnV0ZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmZyb21CdWZmZXJBdHRyaWJ1dGUoKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRkaXN0YW5jZVRvTWFuaGF0dGFuOiBmdW5jdGlvbiAoIHYgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVmVjdG9yMzogLmRpc3RhbmNlVG9NYW5oYXR0YW4oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYW5oYXR0YW5EaXN0YW5jZVRvKCkuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLm1hbmhhdHRhbkRpc3RhbmNlVG8oIHYgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjM6IC5sZW5ndGhNYW5oYXR0YW4oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYW5oYXR0YW5MZW5ndGgoKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubWFuaGF0dGFuTGVuZ3RoKCk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuYXNzaWduKCBWZWN0b3I0LnByb3RvdHlwZSwge1xcblxcblxcdFxcdGZyb21BdHRyaWJ1dGU6IGZ1bmN0aW9uICggYXR0cmlidXRlLCBpbmRleCwgb2Zmc2V0ICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjQ6IC5mcm9tQXR0cmlidXRlKCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuZnJvbUJ1ZmZlckF0dHJpYnV0ZSgpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5mcm9tQnVmZmVyQXR0cmlidXRlKCBhdHRyaWJ1dGUsIGluZGV4LCBvZmZzZXQgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGxlbmd0aE1hbmhhdHRhbjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlZlY3RvcjQ6IC5sZW5ndGhNYW5oYXR0YW4oKSBoYXMgYmVlbiByZW5hbWVkIHRvIC5tYW5oYXR0YW5MZW5ndGgoKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMubWFuaGF0dGFuTGVuZ3RoKCk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvL1xcblxcblxcdEdlb21ldHJ5LnByb3RvdHlwZS5jb21wdXRlVGFuZ2VudHMgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHR9O1xcblxcblxcdE9iamVjdC5hc3NpZ24oIE9iamVjdDNELnByb3RvdHlwZSwge1xcblxcblxcdFxcdGdldENoaWxkQnlOYW1lOiBmdW5jdGlvbiAoIG5hbWUgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5nZXRDaGlsZEJ5TmFtZSgpIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdldE9iamVjdEJ5TmFtZSgpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXRPYmplY3RCeU5hbWUoIG5hbWUgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdHJlbmRlckRlcHRoOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5yZW5kZXJEZXB0aCBoYXMgYmVlbiByZW1vdmVkLiBVc2UgLnJlbmRlck9yZGVyLCBpbnN0ZWFkLicgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdHRyYW5zbGF0ZTogZnVuY3Rpb24gKCBkaXN0YW5jZSwgYXhpcyApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5PYmplY3QzRDogLnRyYW5zbGF0ZSgpIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSAudHJhbnNsYXRlT25BeGlzKCBheGlzLCBkaXN0YW5jZSApIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLnRyYW5zbGF0ZU9uQXhpcyggYXhpcywgZGlzdGFuY2UgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBPYmplY3QzRC5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRldWxlck9yZGVyOiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuT2JqZWN0M0Q6IC5ldWxlck9yZGVyIGlzIG5vdyAucm90YXRpb24ub3JkZXIuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnJvdGF0aW9uLm9yZGVyO1xcblxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAuZXVsZXJPcmRlciBpcyBub3cgLnJvdGF0aW9uLm9yZGVyLicgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnJvdGF0aW9uLm9yZGVyID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0dXNlUXVhdGVybmlvbjoge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudXNlUXVhdGVybmlvbiBoYXMgYmVlbiByZW1vdmVkLiBUaGUgbGlicmFyeSBub3cgdXNlcyBxdWF0ZXJuaW9ucyBieSBkZWZhdWx0LicgKTtcXG5cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk9iamVjdDNEOiAudXNlUXVhdGVybmlvbiBoYXMgYmVlbiByZW1vdmVkLiBUaGUgbGlicmFyeSBub3cgdXNlcyBxdWF0ZXJuaW9ucyBieSBkZWZhdWx0LicgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTE9ELnByb3RvdHlwZSwge1xcblxcblxcdFxcdG9iamVjdHM6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5MT0Q6IC5vYmplY3RzIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmxldmVscy4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMubGV2ZWxzO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggU2tlbGV0b24ucHJvdG90eXBlLCAndXNlVmVydGV4VGV4dHVyZScsIHtcXG5cXG5cXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5Ta2VsZXRvbjogdXNlVmVydGV4VGV4dHVyZSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdHNldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNrZWxldG9uOiB1c2VWZXJ0ZXhUZXh0dXJlIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCBDdXJ2ZS5wcm90b3R5cGUsICdfX2FyY0xlbmd0aERpdmlzaW9ucycsIHtcXG5cXG5cXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5DdXJ2ZTogLl9fYXJjTGVuZ3RoRGl2aXNpb25zIGlzIG5vdyAuYXJjTGVuZ3RoRGl2aXNpb25zLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5hcmNMZW5ndGhEaXZpc2lvbnM7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ3VydmU6IC5fX2FyY0xlbmd0aERpdmlzaW9ucyBpcyBub3cgLmFyY0xlbmd0aERpdmlzaW9ucy4nICk7XFxuXFx0XFx0XFx0dGhpcy5hcmNMZW5ndGhEaXZpc2lvbnMgPSB2YWx1ZTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8vXFxuXFxuXFx0UGVyc3BlY3RpdmVDYW1lcmEucHJvdG90eXBlLnNldExlbnMgPSBmdW5jdGlvbiAoIGZvY2FsTGVuZ3RoLCBmaWxtR2F1Z2UgKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCBcXFwiVEhSRUUuUGVyc3BlY3RpdmVDYW1lcmEuc2V0TGVucyBpcyBkZXByZWNhdGVkLiBcXFwiICtcXG5cXHRcXHRcXHRcXHRcXFwiVXNlIC5zZXRGb2NhbExlbmd0aCBhbmQgLmZpbG1HYXVnZSBmb3IgYSBwaG90b2dyYXBoaWMgc2V0dXAuXFxcIiApO1xcblxcblxcdFxcdGlmICggZmlsbUdhdWdlICE9PSB1bmRlZmluZWQgKSB0aGlzLmZpbG1HYXVnZSA9IGZpbG1HYXVnZTtcXG5cXHRcXHR0aGlzLnNldEZvY2FsTGVuZ3RoKCBmb2NhbExlbmd0aCApO1xcblxcblxcdH07XFxuXFxuXFx0Ly9cXG5cXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTGlnaHQucHJvdG90eXBlLCB7XFxuXFx0XFx0b25seVNoYWRvdzoge1xcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAub25seVNoYWRvdyBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRzaGFkb3dDYW1lcmFGb3Y6IHtcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFGb3YgaXMgbm93IC5zaGFkb3cuY2FtZXJhLmZvdi4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5zaGFkb3cuY2FtZXJhLmZvdiA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdHNoYWRvd0NhbWVyYUxlZnQ6IHtcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFMZWZ0IGlzIG5vdyAuc2hhZG93LmNhbWVyYS5sZWZ0LicgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnNoYWRvdy5jYW1lcmEubGVmdCA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdHNoYWRvd0NhbWVyYVJpZ2h0OiB7XFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhUmlnaHQgaXMgbm93IC5zaGFkb3cuY2FtZXJhLnJpZ2h0LicgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnNoYWRvdy5jYW1lcmEucmlnaHQgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRzaGFkb3dDYW1lcmFUb3A6IHtcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFUb3AgaXMgbm93IC5zaGFkb3cuY2FtZXJhLnRvcC4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5zaGFkb3cuY2FtZXJhLnRvcCA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdHNoYWRvd0NhbWVyYUJvdHRvbToge1xcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYUJvdHRvbSBpcyBub3cgLnNoYWRvdy5jYW1lcmEuYm90dG9tLicgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnNoYWRvdy5jYW1lcmEuYm90dG9tID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0c2hhZG93Q2FtZXJhTmVhcjoge1xcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0NhbWVyYU5lYXIgaXMgbm93IC5zaGFkb3cuY2FtZXJhLm5lYXIuJyApO1xcblxcdFxcdFxcdFxcdHRoaXMuc2hhZG93LmNhbWVyYS5uZWFyID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0c2hhZG93Q2FtZXJhRmFyOiB7XFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkxpZ2h0OiAuc2hhZG93Q2FtZXJhRmFyIGlzIG5vdyAuc2hhZG93LmNhbWVyYS5mYXIuJyApO1xcblxcdFxcdFxcdFxcdHRoaXMuc2hhZG93LmNhbWVyYS5mYXIgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRzaGFkb3dDYW1lcmFWaXNpYmxlOiB7XFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dDYW1lcmFWaXNpYmxlIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBuZXcgVEhSRUUuQ2FtZXJhSGVscGVyKCBsaWdodC5zaGFkb3cuY2FtZXJhICkgaW5zdGVhZC4nICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0c2hhZG93Qmlhczoge1xcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd0JpYXMgaXMgbm93IC5zaGFkb3cuYmlhcy4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5zaGFkb3cuYmlhcyA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdHNoYWRvd0RhcmtuZXNzOiB7XFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dEYXJrbmVzcyBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRzaGFkb3dNYXBXaWR0aDoge1xcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5MaWdodDogLnNoYWRvd01hcFdpZHRoIGlzIG5vdyAuc2hhZG93Lm1hcFNpemUud2lkdGguJyApO1xcblxcdFxcdFxcdFxcdHRoaXMuc2hhZG93Lm1hcFNpemUud2lkdGggPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRzaGFkb3dNYXBIZWlnaHQ6IHtcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuTGlnaHQ6IC5zaGFkb3dNYXBIZWlnaHQgaXMgbm93IC5zaGFkb3cubWFwU2l6ZS5oZWlnaHQuJyApO1xcblxcdFxcdFxcdFxcdHRoaXMuc2hhZG93Lm1hcFNpemUuaGVpZ2h0ID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9ICk7XFxuXFxuXFx0Ly9cXG5cXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggQnVmZmVyQXR0cmlidXRlLnByb3RvdHlwZSwge1xcblxcblxcdFxcdGxlbmd0aDoge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckF0dHJpYnV0ZTogLmxlbmd0aCBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgLmNvdW50IGluc3RlYWQuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmFycmF5Lmxlbmd0aDtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuYXNzaWduKCBCdWZmZXJHZW9tZXRyeS5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRhZGRJbmRleDogZnVuY3Rpb24gKCBpbmRleCApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZEluZGV4KCkgaGFzIGJlZW4gcmVuYW1lZCB0byAuc2V0SW5kZXgoKS4nICk7XFxuXFx0XFx0XFx0dGhpcy5zZXRJbmRleCggaW5kZXggKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGFkZERyYXdDYWxsOiBmdW5jdGlvbiAoIHN0YXJ0LCBjb3VudCwgaW5kZXhPZmZzZXQgKSB7XFxuXFxuXFx0XFx0XFx0aWYgKCBpbmRleE9mZnNldCAhPT0gdW5kZWZpbmVkICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkJ1ZmZlckdlb21ldHJ5OiAuYWRkRHJhd0NhbGwoKSBubyBsb25nZXIgc3VwcG9ydHMgaW5kZXhPZmZzZXQuJyApO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmFkZERyYXdDYWxsKCkgaXMgbm93IC5hZGRHcm91cCgpLicgKTtcXG5cXHRcXHRcXHR0aGlzLmFkZEdyb3VwKCBzdGFydCwgY291bnQgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGNsZWFyRHJhd0NhbGxzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jbGVhckRyYXdDYWxscygpIGlzIG5vdyAuY2xlYXJHcm91cHMoKS4nICk7XFxuXFx0XFx0XFx0dGhpcy5jbGVhckdyb3VwcygpO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0Y29tcHV0ZVRhbmdlbnRzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlVGFuZ2VudHMoKSBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHRcXHR9LFxcblxcdFxcdGNvbXB1dGVPZmZzZXRzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5jb21wdXRlT2Zmc2V0cygpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEJ1ZmZlckdlb21ldHJ5LnByb3RvdHlwZSwge1xcblxcblxcdFxcdGRyYXdjYWxsczoge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5CdWZmZXJHZW9tZXRyeTogLmRyYXdjYWxscyBoYXMgYmVlbiByZW5hbWVkIHRvIC5ncm91cHMuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmdyb3VwcztcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRvZmZzZXRzOiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQnVmZmVyR2VvbWV0cnk6IC5vZmZzZXRzIGhhcyBiZWVuIHJlbmFtZWQgdG8gLmdyb3Vwcy4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuZ3JvdXBzO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8vXFxuXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFVuaWZvcm0ucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0ZHluYW1pYzoge1xcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlVuaWZvcm06IC5keW5hbWljIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBvYmplY3Qub25CZWZvcmVSZW5kZXIoKSBpbnN0ZWFkLicgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRvblVwZGF0ZToge1xcblxcdFxcdFxcdHZhbHVlOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuVW5pZm9ybTogLm9uVXBkYXRlKCkgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIG9iamVjdC5vbkJlZm9yZVJlbmRlcigpIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8vXFxuXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE1hdGVyaWFsLnByb3RvdHlwZSwge1xcblxcblxcdFxcdHdyYXBBcm91bmQ6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRlcmlhbDogLndyYXBBcm91bmQgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NYXRlcmlhbDogLndyYXBBcm91bmQgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0d3JhcFJHQjoge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLk1hdGVyaWFsOiAud3JhcFJHQiBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbmV3IENvbG9yKCk7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c2hhZGluZzoge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLnNoYWRpbmcgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHRoZSBib29sZWFuIC5mbGF0U2hhZGluZyBpbnN0ZWFkLicgKTtcXG5cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS4nICsgdGhpcy50eXBlICsgJzogLnNoYWRpbmcgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIHRoZSBib29sZWFuIC5mbGF0U2hhZGluZyBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLmZsYXRTaGFkaW5nID0gKCB2YWx1ZSA9PT0gRmxhdFNoYWRpbmcgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTWVzaFBob25nTWF0ZXJpYWwucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0bWV0YWw6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbDogLm1ldGFsIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCBpbnN0ZWFkLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5NZXNoUGhvbmdNYXRlcmlhbDogLm1ldGFsIGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBUSFJFRS5NZXNoU3RhbmRhcmRNYXRlcmlhbCBpbnN0ZWFkJyApO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBTaGFkZXJNYXRlcmlhbC5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRkZXJpdmF0aXZlczoge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlNoYWRlck1hdGVyaWFsOiAuZGVyaXZhdGl2ZXMgaGFzIGJlZW4gbW92ZWQgdG8gLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXM7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuIFNoYWRlck1hdGVyaWFsOiAuZGVyaXZhdGl2ZXMgaGFzIGJlZW4gbW92ZWQgdG8gLmV4dGVuc2lvbnMuZGVyaXZhdGl2ZXMuJyApO1xcblxcdFxcdFxcdFxcdHRoaXMuZXh0ZW5zaW9ucy5kZXJpdmF0aXZlcyA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0fSApO1xcblxcblxcdC8vXFxuXFxuXFx0T2JqZWN0LmFzc2lnbiggV2ViR0xSZW5kZXJlci5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRnZXRDdXJyZW50UmVuZGVyVGFyZ2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmdldEN1cnJlbnRSZW5kZXJUYXJnZXQoKSBpcyBub3cgLmdldFJlbmRlclRhcmdldCgpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5nZXRSZW5kZXJUYXJnZXQoKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldE1heEFuaXNvdHJvcHk6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuZ2V0TWF4QW5pc290cm9weSgpIGlzIG5vdyAuY2FwYWJpbGl0aWVzLmdldE1heEFuaXNvdHJvcHkoKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuY2FwYWJpbGl0aWVzLmdldE1heEFuaXNvdHJvcHkoKTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGdldFByZWNpc2lvbjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5nZXRQcmVjaXNpb24oKSBpcyBub3cgLmNhcGFiaWxpdGllcy5wcmVjaXNpb24uJyApO1xcblxcdFxcdFxcdHJldHVybiB0aGlzLmNhcGFiaWxpdGllcy5wcmVjaXNpb247XFxuXFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRyZXNldEdMU3RhdGU6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAucmVzZXRHTFN0YXRlKCkgaXMgbm93IC5zdGF0ZS5yZXNldCgpLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5zdGF0ZS5yZXNldCgpO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3VwcG9ydHNGbG9hdFRleHR1cmVzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzRmxvYXRUZXh0dXJlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcXFwnT0VTX3RleHR1cmVfZmxvYXRcXFxcJyApLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ09FU190ZXh0dXJlX2Zsb2F0JyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0c3VwcG9ydHNIYWxmRmxvYXRUZXh0dXJlczogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0hhbGZGbG9hdFRleHR1cmVzKCkgaXMgbm93IC5leHRlbnNpb25zLmdldCggXFxcXCdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0XFxcXCcgKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdPRVNfdGV4dHVyZV9oYWxmX2Zsb2F0JyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0c3VwcG9ydHNTdGFuZGFyZERlcml2YXRpdmVzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzU3RhbmRhcmREZXJpdmF0aXZlcygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcXFwnT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXFxcXCcgKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRzdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQzogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5zdXBwb3J0c0NvbXByZXNzZWRUZXh0dXJlUzNUQygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcXFwnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3MzdGNcXFxcJyApLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ1dFQkdMX2NvbXByZXNzZWRfdGV4dHVyZV9zM3RjJyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0c3VwcG9ydHNDb21wcmVzc2VkVGV4dHVyZVBWUlRDOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQ29tcHJlc3NlZFRleHR1cmVQVlJUQygpIGlzIG5vdyAuZXh0ZW5zaW9ucy5nZXQoIFxcXFwnV0VCR0xfY29tcHJlc3NlZF90ZXh0dXJlX3B2cnRjXFxcXCcgKS4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuZXh0ZW5zaW9ucy5nZXQoICdXRUJHTF9jb21wcmVzc2VkX3RleHR1cmVfcHZydGMnICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRzdXBwb3J0c0JsZW5kTWluTWF4OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzQmxlbmRNaW5NYXgoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXFxcJ0VYVF9ibGVuZF9taW5tYXhcXFxcJyApLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ0VYVF9ibGVuZF9taW5tYXgnICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRzdXBwb3J0c1ZlcnRleFRleHR1cmVzOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnN1cHBvcnRzVmVydGV4VGV4dHVyZXMoKSBpcyBub3cgLmNhcGFiaWxpdGllcy52ZXJ0ZXhUZXh0dXJlcy4nICk7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuY2FwYWJpbGl0aWVzLnZlcnRleFRleHR1cmVzO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0c3VwcG9ydHNJbnN0YW5jZWRBcnJheXM6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc3VwcG9ydHNJbnN0YW5jZWRBcnJheXMoKSBpcyBub3cgLmV4dGVuc2lvbnMuZ2V0KCBcXFxcJ0FOR0xFX2luc3RhbmNlZF9hcnJheXNcXFxcJyApLicgKTtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5leHRlbnNpb25zLmdldCggJ0FOR0xFX2luc3RhbmNlZF9hcnJheXMnICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHRlbmFibGVTY2lzc29yVGVzdDogZnVuY3Rpb24gKCBib29sZWFuICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5lbmFibGVTY2lzc29yVGVzdCgpIGlzIG5vdyAuc2V0U2Npc3NvclRlc3QoKS4nICk7XFxuXFx0XFx0XFx0dGhpcy5zZXRTY2lzc29yVGVzdCggYm9vbGVhbiApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0aW5pdE1hdGVyaWFsOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmluaXRNYXRlcmlhbCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0YWRkUHJlUGx1Z2luOiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLmFkZFByZVBsdWdpbigpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcblxcblxcdFxcdH0sXFxuXFx0XFx0YWRkUG9zdFBsdWdpbjogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyZXI6IC5hZGRQb3N0UGx1Z2luKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0fSxcXG5cXHRcXHR1cGRhdGVTaGFkb3dNYXA6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAudXBkYXRlU2hhZG93TWFwKCkgaGFzIGJlZW4gcmVtb3ZlZC4nICk7XFxuXFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyggV2ViR0xSZW5kZXJlci5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRzaGFkb3dNYXBFbmFibGVkOiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuc2hhZG93TWFwLmVuYWJsZWQ7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcEVuYWJsZWQgaXMgbm93IC5zaGFkb3dNYXAuZW5hYmxlZC4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5zaGFkb3dNYXAuZW5hYmxlZCA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdHNoYWRvd01hcFR5cGU6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5zaGFkb3dNYXAudHlwZTtcXG5cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlcmVyOiAuc2hhZG93TWFwVHlwZSBpcyBub3cgLnNoYWRvd01hcC50eXBlLicgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnNoYWRvd01hcC50eXBlID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0c2hhZG93TWFwQ3VsbEZhY2U6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5zaGFkb3dNYXAuY3VsbEZhY2U7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcEN1bGxGYWNlIGlzIG5vdyAuc2hhZG93TWFwLmN1bGxGYWNlLicgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnNoYWRvd01hcC5jdWxsRmFjZSA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSApO1xcblxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBXZWJHTFNoYWRvd01hcC5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRjdWxsRmFjZToge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnJlbmRlclJldmVyc2VTaWRlZCA/IEN1bGxGYWNlRnJvbnQgOiBDdWxsRmFjZUJhY2s7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggY3VsbEZhY2UgKSB7XFxuXFxuXFx0XFx0XFx0XFx0dmFyIHZhbHVlID0gKCBjdWxsRmFjZSAhPT0gQ3VsbEZhY2VCYWNrICk7XFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCBcXFwiV2ViR0xSZW5kZXJlcjogLnNoYWRvd01hcC5jdWxsRmFjZSBpcyBkZXByZWNhdGVkLiBTZXQgLnNoYWRvd01hcC5yZW5kZXJSZXZlcnNlU2lkZWQgdG8gXFxcIiArIHZhbHVlICsgXFxcIi5cXFwiICk7XFxuXFx0XFx0XFx0XFx0dGhpcy5yZW5kZXJSZXZlcnNlU2lkZWQgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvL1xcblxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBXZWJHTFJlbmRlclRhcmdldC5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHR3cmFwUzoge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFMgaXMgbm93IC50ZXh0dXJlLndyYXBTLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy50ZXh0dXJlLndyYXBTO1xcblxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFMgaXMgbm93IC50ZXh0dXJlLndyYXBTLicgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnRleHR1cmUud3JhcFMgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHR3cmFwVDoge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFQgaXMgbm93IC50ZXh0dXJlLndyYXBULicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy50ZXh0dXJlLndyYXBUO1xcblxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAud3JhcFQgaXMgbm93IC50ZXh0dXJlLndyYXBULicgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnRleHR1cmUud3JhcFQgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRtYWdGaWx0ZXI6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1hZ0ZpbHRlciBpcyBub3cgLnRleHR1cmUubWFnRmlsdGVyLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy50ZXh0dXJlLm1hZ0ZpbHRlcjtcXG5cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLm1hZ0ZpbHRlciBpcyBub3cgLnRleHR1cmUubWFnRmlsdGVyLicgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnRleHR1cmUubWFnRmlsdGVyID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0bWluRmlsdGVyOiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5taW5GaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1pbkZpbHRlci4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMudGV4dHVyZS5taW5GaWx0ZXI7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5taW5GaWx0ZXIgaXMgbm93IC50ZXh0dXJlLm1pbkZpbHRlci4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy50ZXh0dXJlLm1pbkZpbHRlciA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdGFuaXNvdHJvcHk6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmFuaXNvdHJvcHkgaXMgbm93IC50ZXh0dXJlLmFuaXNvdHJvcHkuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnRleHR1cmUuYW5pc290cm9weTtcXG5cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmFuaXNvdHJvcHkgaXMgbm93IC50ZXh0dXJlLmFuaXNvdHJvcHkuJyApO1xcblxcdFxcdFxcdFxcdHRoaXMudGV4dHVyZS5hbmlzb3Ryb3B5ID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0b2Zmc2V0OiB7XFxuXFx0XFx0XFx0Z2V0OiBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5vZmZzZXQgaXMgbm93IC50ZXh0dXJlLm9mZnNldC4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMudGV4dHVyZS5vZmZzZXQ7XFxuXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRzZXQ6IGZ1bmN0aW9uICggdmFsdWUgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuV2ViR0xSZW5kZXJUYXJnZXQ6IC5vZmZzZXQgaXMgbm93IC50ZXh0dXJlLm9mZnNldC4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy50ZXh0dXJlLm9mZnNldCA9IHZhbHVlO1xcblxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdHJlcGVhdDoge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAucmVwZWF0IGlzIG5vdyAudGV4dHVyZS5yZXBlYXQuJyApO1xcblxcdFxcdFxcdFxcdHJldHVybiB0aGlzLnRleHR1cmUucmVwZWF0O1xcblxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAucmVwZWF0IGlzIG5vdyAudGV4dHVyZS5yZXBlYXQuJyApO1xcblxcdFxcdFxcdFxcdHRoaXMudGV4dHVyZS5yZXBlYXQgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRmb3JtYXQ6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmZvcm1hdCBpcyBub3cgLnRleHR1cmUuZm9ybWF0LicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy50ZXh0dXJlLmZvcm1hdDtcXG5cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmZvcm1hdCBpcyBub3cgLnRleHR1cmUuZm9ybWF0LicgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnRleHR1cmUuZm9ybWF0ID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0dHlwZToge1xcblxcdFxcdFxcdGdldDogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS4nICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMudGV4dHVyZS50eXBlO1xcblxcblxcdFxcdFxcdH0sXFxuXFx0XFx0XFx0c2V0OiBmdW5jdGlvbiAoIHZhbHVlICkge1xcblxcblxcdFxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLldlYkdMUmVuZGVyVGFyZ2V0OiAudHlwZSBpcyBub3cgLnRleHR1cmUudHlwZS4nICk7XFxuXFx0XFx0XFx0XFx0dGhpcy50ZXh0dXJlLnR5cGUgPSB2YWx1ZTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSxcXG5cXHRcXHRnZW5lcmF0ZU1pcG1hcHM6IHtcXG5cXHRcXHRcXHRnZXQ6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmdlbmVyYXRlTWlwbWFwcyBpcyBub3cgLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzLicgKTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy50ZXh0dXJlLmdlbmVyYXRlTWlwbWFwcztcXG5cXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCB2YWx1ZSApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJHTFJlbmRlclRhcmdldDogLmdlbmVyYXRlTWlwbWFwcyBpcyBub3cgLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzLicgKTtcXG5cXHRcXHRcXHRcXHR0aGlzLnRleHR1cmUuZ2VuZXJhdGVNaXBtYXBzID0gdmFsdWU7XFxuXFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0Ly9cXG5cXG5cXHRPYmplY3QuYXNzaWduKCBXZWJWUk1hbmFnZXIucHJvdG90eXBlLCB7XFxuXFxuXFx0XFx0Z2V0U3RhbmRpbmdNYXRyaXg6IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJWUk1hbmFnZXI6IC5nZXRTdGFuZGluZ01hdHJpeCgpIGhhcyBiZWVuIHJlbW92ZWQuJyApO1xcblxcblxcdFxcdH1cXG5cXG5cXHR9ICk7XFxuXFxuXFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFdlYlZSTWFuYWdlci5wcm90b3R5cGUsIHtcXG5cXG5cXHRcXHRzdGFuZGluZzoge1xcblxcdFxcdFxcdHNldDogZnVuY3Rpb24gKCAvKiB2YWx1ZSAqLyApIHtcXG5cXG5cXHRcXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5XZWJWUk1hbmFnZXI6IC5zdGFuZGluZyBoYXMgYmVlbiByZW1vdmVkLicgKTtcXG5cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdH0gKTtcXG5cXG5cXHQvL1xcblxcblxcdEF1ZGlvLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKCBmaWxlICkge1xcblxcblxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkF1ZGlvOiAubG9hZCBoYXMgYmVlbiBkZXByZWNhdGVkLiBVc2UgVEhSRUUuQXVkaW9Mb2FkZXIgaW5zdGVhZC4nICk7XFxuXFx0XFx0dmFyIHNjb3BlID0gdGhpcztcXG5cXHRcXHR2YXIgYXVkaW9Mb2FkZXIgPSBuZXcgQXVkaW9Mb2FkZXIoKTtcXG5cXHRcXHRhdWRpb0xvYWRlci5sb2FkKCBmaWxlLCBmdW5jdGlvbiAoIGJ1ZmZlciApIHtcXG5cXG5cXHRcXHRcXHRzY29wZS5zZXRCdWZmZXIoIGJ1ZmZlciApO1xcblxcblxcdFxcdH0gKTtcXG5cXHRcXHRyZXR1cm4gdGhpcztcXG5cXG5cXHR9O1xcblxcblxcdEF1ZGlvQW5hbHlzZXIucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQXVkaW9BbmFseXNlcjogLmdldERhdGEoKSBpcyBub3cgLmdldEZyZXF1ZW5jeURhdGEoKS4nICk7XFxuXFx0XFx0cmV0dXJuIHRoaXMuZ2V0RnJlcXVlbmN5RGF0YSgpO1xcblxcblxcdH07XFxuXFxuXFx0Ly9cXG5cXG5cXHRDdWJlQ2FtZXJhLnByb3RvdHlwZS51cGRhdGVDdWJlTWFwID0gZnVuY3Rpb24gKCByZW5kZXJlciwgc2NlbmUgKSB7XFxuXFxuXFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuQ3ViZUNhbWVyYTogLnVwZGF0ZUN1YmVNYXAoKSBpcyBub3cgLnVwZGF0ZSgpLicgKTtcXG5cXHRcXHRyZXR1cm4gdGhpcy51cGRhdGUoIHJlbmRlcmVyLCBzY2VuZSApO1xcblxcblxcdH07XFxuXFxuXFx0Ly9cXG5cXG5cXHR2YXIgR2VvbWV0cnlVdGlscyA9IHtcXG5cXG5cXHRcXHRtZXJnZTogZnVuY3Rpb24gKCBnZW9tZXRyeTEsIGdlb21ldHJ5MiwgbWF0ZXJpYWxJbmRleE9mZnNldCApIHtcXG5cXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oICdUSFJFRS5HZW9tZXRyeVV0aWxzOiAubWVyZ2UoKSBoYXMgYmVlbiBtb3ZlZCB0byBHZW9tZXRyeS4gVXNlIGdlb21ldHJ5Lm1lcmdlKCBnZW9tZXRyeTIsIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdHZhciBtYXRyaXg7XFxuXFxuXFx0XFx0XFx0aWYgKCBnZW9tZXRyeTIuaXNNZXNoICkge1xcblxcblxcdFxcdFxcdFxcdGdlb21ldHJ5Mi5tYXRyaXhBdXRvVXBkYXRlICYmIGdlb21ldHJ5Mi51cGRhdGVNYXRyaXgoKTtcXG5cXG5cXHRcXHRcXHRcXHRtYXRyaXggPSBnZW9tZXRyeTIubWF0cml4O1xcblxcdFxcdFxcdFxcdGdlb21ldHJ5MiA9IGdlb21ldHJ5Mi5nZW9tZXRyeTtcXG5cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0Z2VvbWV0cnkxLm1lcmdlKCBnZW9tZXRyeTIsIG1hdHJpeCwgbWF0ZXJpYWxJbmRleE9mZnNldCApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0Y2VudGVyOiBmdW5jdGlvbiAoIGdlb21ldHJ5ICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkdlb21ldHJ5VXRpbHM6IC5jZW50ZXIoKSBoYXMgYmVlbiBtb3ZlZCB0byBHZW9tZXRyeS4gVXNlIGdlb21ldHJ5LmNlbnRlcigpIGluc3RlYWQuJyApO1xcblxcdFxcdFxcdHJldHVybiBnZW9tZXRyeS5jZW50ZXIoKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fTtcXG5cXG5cXHR2YXIgSW1hZ2VVdGlscyA9IHtcXG5cXG5cXHRcXHRjcm9zc09yaWdpbjogdW5kZWZpbmVkLFxcblxcblxcdFxcdGxvYWRUZXh0dXJlOiBmdW5jdGlvbiAoIHVybCwgbWFwcGluZywgb25Mb2FkLCBvbkVycm9yICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFRIUkVFLlRleHR1cmVMb2FkZXIoKSBpbnN0ZWFkLicgKTtcXG5cXG5cXHRcXHRcXHR2YXIgbG9hZGVyID0gbmV3IFRleHR1cmVMb2FkZXIoKTtcXG5cXHRcXHRcXHRsb2FkZXIuc2V0Q3Jvc3NPcmlnaW4oIHRoaXMuY3Jvc3NPcmlnaW4gKTtcXG5cXG5cXHRcXHRcXHR2YXIgdGV4dHVyZSA9IGxvYWRlci5sb2FkKCB1cmwsIG9uTG9hZCwgdW5kZWZpbmVkLCBvbkVycm9yICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXBwaW5nICkgdGV4dHVyZS5tYXBwaW5nID0gbWFwcGluZztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGxvYWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24gKCB1cmxzLCBtYXBwaW5nLCBvbkxvYWQsIG9uRXJyb3IgKSB7XFxuXFxuXFx0XFx0XFx0Y29uc29sZS53YXJuKCAnVEhSRUUuSW1hZ2VVdGlscy5sb2FkVGV4dHVyZUN1YmUgaGFzIGJlZW4gZGVwcmVjYXRlZC4gVXNlIFRIUkVFLkN1YmVUZXh0dXJlTG9hZGVyKCkgaW5zdGVhZC4nICk7XFxuXFxuXFx0XFx0XFx0dmFyIGxvYWRlciA9IG5ldyBDdWJlVGV4dHVyZUxvYWRlcigpO1xcblxcdFxcdFxcdGxvYWRlci5zZXRDcm9zc09yaWdpbiggdGhpcy5jcm9zc09yaWdpbiApO1xcblxcblxcdFxcdFxcdHZhciB0ZXh0dXJlID0gbG9hZGVyLmxvYWQoIHVybHMsIG9uTG9hZCwgdW5kZWZpbmVkLCBvbkVycm9yICk7XFxuXFxuXFx0XFx0XFx0aWYgKCBtYXBwaW5nICkgdGV4dHVyZS5tYXBwaW5nID0gbWFwcGluZztcXG5cXG5cXHRcXHRcXHRyZXR1cm4gdGV4dHVyZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdGxvYWRDb21wcmVzc2VkVGV4dHVyZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5JbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZSBoYXMgYmVlbiByZW1vdmVkLiBVc2UgVEhSRUUuRERTTG9hZGVyIGluc3RlYWQuJyApO1xcblxcblxcdFxcdH0sXFxuXFxuXFx0XFx0bG9hZENvbXByZXNzZWRUZXh0dXJlQ3ViZTogZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5JbWFnZVV0aWxzLmxvYWRDb21wcmVzc2VkVGV4dHVyZUN1YmUgaGFzIGJlZW4gcmVtb3ZlZC4gVXNlIFRIUkVFLkREU0xvYWRlciBpbnN0ZWFkLicgKTtcXG5cXG5cXHRcXHR9XFxuXFxuXFx0fTtcXG5cXG5cXHQvL1xcblxcblxcdGZ1bmN0aW9uIFByb2plY3RvcigpIHtcXG5cXG5cXHRcXHRjb25zb2xlLmVycm9yKCAnVEhSRUUuUHJvamVjdG9yIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9yZW5kZXJlcnMvUHJvamVjdG9yLmpzLicgKTtcXG5cXG5cXHRcXHR0aGlzLnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvcjogLnByb2plY3RWZWN0b3IoKSBpcyBub3cgdmVjdG9yLnByb2plY3QoKS4nICk7XFxuXFx0XFx0XFx0dmVjdG9yLnByb2plY3QoIGNhbWVyYSApO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy51bnByb2plY3RWZWN0b3IgPSBmdW5jdGlvbiAoIHZlY3RvciwgY2FtZXJhICkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUud2FybiggJ1RIUkVFLlByb2plY3RvcjogLnVucHJvamVjdFZlY3RvcigpIGlzIG5vdyB2ZWN0b3IudW5wcm9qZWN0KCkuJyApO1xcblxcdFxcdFxcdHZlY3Rvci51bnByb2plY3QoIGNhbWVyYSApO1xcblxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5waWNraW5nUmF5ID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdFxcdGNvbnNvbGUuZXJyb3IoICdUSFJFRS5Qcm9qZWN0b3I6IC5waWNraW5nUmF5KCkgaXMgbm93IHJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKCkuJyApO1xcblxcblxcdFxcdH07XFxuXFxuXFx0fVxcblxcblxcdC8vXFxuXFxuXFx0ZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIoKSB7XFxuXFxuXFx0XFx0Y29uc29sZS5lcnJvciggJ1RIUkVFLkNhbnZhc1JlbmRlcmVyIGhhcyBiZWVuIG1vdmVkIHRvIC9leGFtcGxlcy9qcy9yZW5kZXJlcnMvQ2FudmFzUmVuZGVyZXIuanMnICk7XFxuXFxuXFx0XFx0dGhpcy5kb21FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsICdjYW52YXMnICk7XFxuXFx0XFx0dGhpcy5jbGVhciA9IGZ1bmN0aW9uICgpIHt9O1xcblxcdFxcdHRoaXMucmVuZGVyID0gZnVuY3Rpb24gKCkge307XFxuXFx0XFx0dGhpcy5zZXRDbGVhckNvbG9yID0gZnVuY3Rpb24gKCkge307XFxuXFx0XFx0dGhpcy5zZXRTaXplID0gZnVuY3Rpb24gKCkge307XFxuXFxuXFx0fVxcblxcblxcdGV4cG9ydHMuV2ViR0xSZW5kZXJUYXJnZXRDdWJlID0gV2ViR0xSZW5kZXJUYXJnZXRDdWJlO1xcblxcdGV4cG9ydHMuV2ViR0xSZW5kZXJUYXJnZXQgPSBXZWJHTFJlbmRlclRhcmdldDtcXG5cXHRleHBvcnRzLldlYkdMUmVuZGVyZXIgPSBXZWJHTFJlbmRlcmVyO1xcblxcdGV4cG9ydHMuU2hhZGVyTGliID0gU2hhZGVyTGliO1xcblxcdGV4cG9ydHMuVW5pZm9ybXNMaWIgPSBVbmlmb3Jtc0xpYjtcXG5cXHRleHBvcnRzLlVuaWZvcm1zVXRpbHMgPSBVbmlmb3Jtc1V0aWxzO1xcblxcdGV4cG9ydHMuU2hhZGVyQ2h1bmsgPSBTaGFkZXJDaHVuaztcXG5cXHRleHBvcnRzLkZvZ0V4cDIgPSBGb2dFeHAyO1xcblxcdGV4cG9ydHMuRm9nID0gRm9nO1xcblxcdGV4cG9ydHMuU2NlbmUgPSBTY2VuZTtcXG5cXHRleHBvcnRzLkxlbnNGbGFyZSA9IExlbnNGbGFyZTtcXG5cXHRleHBvcnRzLlNwcml0ZSA9IFNwcml0ZTtcXG5cXHRleHBvcnRzLkxPRCA9IExPRDtcXG5cXHRleHBvcnRzLlNraW5uZWRNZXNoID0gU2tpbm5lZE1lc2g7XFxuXFx0ZXhwb3J0cy5Ta2VsZXRvbiA9IFNrZWxldG9uO1xcblxcdGV4cG9ydHMuQm9uZSA9IEJvbmU7XFxuXFx0ZXhwb3J0cy5NZXNoID0gTWVzaDtcXG5cXHRleHBvcnRzLkxpbmVTZWdtZW50cyA9IExpbmVTZWdtZW50cztcXG5cXHRleHBvcnRzLkxpbmVMb29wID0gTGluZUxvb3A7XFxuXFx0ZXhwb3J0cy5MaW5lID0gTGluZTtcXG5cXHRleHBvcnRzLlBvaW50cyA9IFBvaW50cztcXG5cXHRleHBvcnRzLkdyb3VwID0gR3JvdXA7XFxuXFx0ZXhwb3J0cy5WaWRlb1RleHR1cmUgPSBWaWRlb1RleHR1cmU7XFxuXFx0ZXhwb3J0cy5EYXRhVGV4dHVyZSA9IERhdGFUZXh0dXJlO1xcblxcdGV4cG9ydHMuQ29tcHJlc3NlZFRleHR1cmUgPSBDb21wcmVzc2VkVGV4dHVyZTtcXG5cXHRleHBvcnRzLkN1YmVUZXh0dXJlID0gQ3ViZVRleHR1cmU7XFxuXFx0ZXhwb3J0cy5DYW52YXNUZXh0dXJlID0gQ2FudmFzVGV4dHVyZTtcXG5cXHRleHBvcnRzLkRlcHRoVGV4dHVyZSA9IERlcHRoVGV4dHVyZTtcXG5cXHRleHBvcnRzLlRleHR1cmUgPSBUZXh0dXJlO1xcblxcdGV4cG9ydHMuQ29tcHJlc3NlZFRleHR1cmVMb2FkZXIgPSBDb21wcmVzc2VkVGV4dHVyZUxvYWRlcjtcXG5cXHRleHBvcnRzLkRhdGFUZXh0dXJlTG9hZGVyID0gRGF0YVRleHR1cmVMb2FkZXI7XFxuXFx0ZXhwb3J0cy5DdWJlVGV4dHVyZUxvYWRlciA9IEN1YmVUZXh0dXJlTG9hZGVyO1xcblxcdGV4cG9ydHMuVGV4dHVyZUxvYWRlciA9IFRleHR1cmVMb2FkZXI7XFxuXFx0ZXhwb3J0cy5PYmplY3RMb2FkZXIgPSBPYmplY3RMb2FkZXI7XFxuXFx0ZXhwb3J0cy5NYXRlcmlhbExvYWRlciA9IE1hdGVyaWFsTG9hZGVyO1xcblxcdGV4cG9ydHMuQnVmZmVyR2VvbWV0cnlMb2FkZXIgPSBCdWZmZXJHZW9tZXRyeUxvYWRlcjtcXG5cXHRleHBvcnRzLkRlZmF1bHRMb2FkaW5nTWFuYWdlciA9IERlZmF1bHRMb2FkaW5nTWFuYWdlcjtcXG5cXHRleHBvcnRzLkxvYWRpbmdNYW5hZ2VyID0gTG9hZGluZ01hbmFnZXI7XFxuXFx0ZXhwb3J0cy5KU09OTG9hZGVyID0gSlNPTkxvYWRlcjtcXG5cXHRleHBvcnRzLkltYWdlTG9hZGVyID0gSW1hZ2VMb2FkZXI7XFxuXFx0ZXhwb3J0cy5JbWFnZUJpdG1hcExvYWRlciA9IEltYWdlQml0bWFwTG9hZGVyO1xcblxcdGV4cG9ydHMuRm9udExvYWRlciA9IEZvbnRMb2FkZXI7XFxuXFx0ZXhwb3J0cy5GaWxlTG9hZGVyID0gRmlsZUxvYWRlcjtcXG5cXHRleHBvcnRzLkxvYWRlciA9IExvYWRlcjtcXG5cXHRleHBvcnRzLkxvYWRlclV0aWxzID0gTG9hZGVyVXRpbHM7XFxuXFx0ZXhwb3J0cy5DYWNoZSA9IENhY2hlO1xcblxcdGV4cG9ydHMuQXVkaW9Mb2FkZXIgPSBBdWRpb0xvYWRlcjtcXG5cXHRleHBvcnRzLlNwb3RMaWdodFNoYWRvdyA9IFNwb3RMaWdodFNoYWRvdztcXG5cXHRleHBvcnRzLlNwb3RMaWdodCA9IFNwb3RMaWdodDtcXG5cXHRleHBvcnRzLlBvaW50TGlnaHQgPSBQb2ludExpZ2h0O1xcblxcdGV4cG9ydHMuUmVjdEFyZWFMaWdodCA9IFJlY3RBcmVhTGlnaHQ7XFxuXFx0ZXhwb3J0cy5IZW1pc3BoZXJlTGlnaHQgPSBIZW1pc3BoZXJlTGlnaHQ7XFxuXFx0ZXhwb3J0cy5EaXJlY3Rpb25hbExpZ2h0U2hhZG93ID0gRGlyZWN0aW9uYWxMaWdodFNoYWRvdztcXG5cXHRleHBvcnRzLkRpcmVjdGlvbmFsTGlnaHQgPSBEaXJlY3Rpb25hbExpZ2h0O1xcblxcdGV4cG9ydHMuQW1iaWVudExpZ2h0ID0gQW1iaWVudExpZ2h0O1xcblxcdGV4cG9ydHMuTGlnaHRTaGFkb3cgPSBMaWdodFNoYWRvdztcXG5cXHRleHBvcnRzLkxpZ2h0ID0gTGlnaHQ7XFxuXFx0ZXhwb3J0cy5TdGVyZW9DYW1lcmEgPSBTdGVyZW9DYW1lcmE7XFxuXFx0ZXhwb3J0cy5QZXJzcGVjdGl2ZUNhbWVyYSA9IFBlcnNwZWN0aXZlQ2FtZXJhO1xcblxcdGV4cG9ydHMuT3J0aG9ncmFwaGljQ2FtZXJhID0gT3J0aG9ncmFwaGljQ2FtZXJhO1xcblxcdGV4cG9ydHMuQ3ViZUNhbWVyYSA9IEN1YmVDYW1lcmE7XFxuXFx0ZXhwb3J0cy5BcnJheUNhbWVyYSA9IEFycmF5Q2FtZXJhO1xcblxcdGV4cG9ydHMuQ2FtZXJhID0gQ2FtZXJhO1xcblxcdGV4cG9ydHMuQXVkaW9MaXN0ZW5lciA9IEF1ZGlvTGlzdGVuZXI7XFxuXFx0ZXhwb3J0cy5Qb3NpdGlvbmFsQXVkaW8gPSBQb3NpdGlvbmFsQXVkaW87XFxuXFx0ZXhwb3J0cy5BdWRpb0NvbnRleHQgPSBBdWRpb0NvbnRleHQ7XFxuXFx0ZXhwb3J0cy5BdWRpb0FuYWx5c2VyID0gQXVkaW9BbmFseXNlcjtcXG5cXHRleHBvcnRzLkF1ZGlvID0gQXVkaW87XFxuXFx0ZXhwb3J0cy5WZWN0b3JLZXlmcmFtZVRyYWNrID0gVmVjdG9yS2V5ZnJhbWVUcmFjaztcXG5cXHRleHBvcnRzLlN0cmluZ0tleWZyYW1lVHJhY2sgPSBTdHJpbmdLZXlmcmFtZVRyYWNrO1xcblxcdGV4cG9ydHMuUXVhdGVybmlvbktleWZyYW1lVHJhY2sgPSBRdWF0ZXJuaW9uS2V5ZnJhbWVUcmFjaztcXG5cXHRleHBvcnRzLk51bWJlcktleWZyYW1lVHJhY2sgPSBOdW1iZXJLZXlmcmFtZVRyYWNrO1xcblxcdGV4cG9ydHMuQ29sb3JLZXlmcmFtZVRyYWNrID0gQ29sb3JLZXlmcmFtZVRyYWNrO1xcblxcdGV4cG9ydHMuQm9vbGVhbktleWZyYW1lVHJhY2sgPSBCb29sZWFuS2V5ZnJhbWVUcmFjaztcXG5cXHRleHBvcnRzLlByb3BlcnR5TWl4ZXIgPSBQcm9wZXJ0eU1peGVyO1xcblxcdGV4cG9ydHMuUHJvcGVydHlCaW5kaW5nID0gUHJvcGVydHlCaW5kaW5nO1xcblxcdGV4cG9ydHMuS2V5ZnJhbWVUcmFjayA9IEtleWZyYW1lVHJhY2s7XFxuXFx0ZXhwb3J0cy5BbmltYXRpb25VdGlscyA9IEFuaW1hdGlvblV0aWxzO1xcblxcdGV4cG9ydHMuQW5pbWF0aW9uT2JqZWN0R3JvdXAgPSBBbmltYXRpb25PYmplY3RHcm91cDtcXG5cXHRleHBvcnRzLkFuaW1hdGlvbk1peGVyID0gQW5pbWF0aW9uTWl4ZXI7XFxuXFx0ZXhwb3J0cy5BbmltYXRpb25DbGlwID0gQW5pbWF0aW9uQ2xpcDtcXG5cXHRleHBvcnRzLlVuaWZvcm0gPSBVbmlmb3JtO1xcblxcdGV4cG9ydHMuSW5zdGFuY2VkQnVmZmVyR2VvbWV0cnkgPSBJbnN0YW5jZWRCdWZmZXJHZW9tZXRyeTtcXG5cXHRleHBvcnRzLkJ1ZmZlckdlb21ldHJ5ID0gQnVmZmVyR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5HZW9tZXRyeSA9IEdlb21ldHJ5O1xcblxcdGV4cG9ydHMuSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUgPSBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZTtcXG5cXHRleHBvcnRzLkluc3RhbmNlZEludGVybGVhdmVkQnVmZmVyID0gSW5zdGFuY2VkSW50ZXJsZWF2ZWRCdWZmZXI7XFxuXFx0ZXhwb3J0cy5JbnRlcmxlYXZlZEJ1ZmZlciA9IEludGVybGVhdmVkQnVmZmVyO1xcblxcdGV4cG9ydHMuSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlID0gSW5zdGFuY2VkQnVmZmVyQXR0cmlidXRlO1xcblxcdGV4cG9ydHMuRmFjZTMgPSBGYWNlMztcXG5cXHRleHBvcnRzLk9iamVjdDNEID0gT2JqZWN0M0Q7XFxuXFx0ZXhwb3J0cy5SYXljYXN0ZXIgPSBSYXljYXN0ZXI7XFxuXFx0ZXhwb3J0cy5MYXllcnMgPSBMYXllcnM7XFxuXFx0ZXhwb3J0cy5FdmVudERpc3BhdGNoZXIgPSBFdmVudERpc3BhdGNoZXI7XFxuXFx0ZXhwb3J0cy5DbG9jayA9IENsb2NrO1xcblxcdGV4cG9ydHMuUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50ID0gUXVhdGVybmlvbkxpbmVhckludGVycG9sYW50O1xcblxcdGV4cG9ydHMuTGluZWFySW50ZXJwb2xhbnQgPSBMaW5lYXJJbnRlcnBvbGFudDtcXG5cXHRleHBvcnRzLkRpc2NyZXRlSW50ZXJwb2xhbnQgPSBEaXNjcmV0ZUludGVycG9sYW50O1xcblxcdGV4cG9ydHMuQ3ViaWNJbnRlcnBvbGFudCA9IEN1YmljSW50ZXJwb2xhbnQ7XFxuXFx0ZXhwb3J0cy5JbnRlcnBvbGFudCA9IEludGVycG9sYW50O1xcblxcdGV4cG9ydHMuVHJpYW5nbGUgPSBUcmlhbmdsZTtcXG5cXHRleHBvcnRzLk1hdGggPSBfTWF0aDtcXG5cXHRleHBvcnRzLlNwaGVyaWNhbCA9IFNwaGVyaWNhbDtcXG5cXHRleHBvcnRzLkN5bGluZHJpY2FsID0gQ3lsaW5kcmljYWw7XFxuXFx0ZXhwb3J0cy5QbGFuZSA9IFBsYW5lO1xcblxcdGV4cG9ydHMuRnJ1c3R1bSA9IEZydXN0dW07XFxuXFx0ZXhwb3J0cy5TcGhlcmUgPSBTcGhlcmU7XFxuXFx0ZXhwb3J0cy5SYXkgPSBSYXk7XFxuXFx0ZXhwb3J0cy5NYXRyaXg0ID0gTWF0cml4NDtcXG5cXHRleHBvcnRzLk1hdHJpeDMgPSBNYXRyaXgzO1xcblxcdGV4cG9ydHMuQm94MyA9IEJveDM7XFxuXFx0ZXhwb3J0cy5Cb3gyID0gQm94MjtcXG5cXHRleHBvcnRzLkxpbmUzID0gTGluZTM7XFxuXFx0ZXhwb3J0cy5FdWxlciA9IEV1bGVyO1xcblxcdGV4cG9ydHMuVmVjdG9yNCA9IFZlY3RvcjQ7XFxuXFx0ZXhwb3J0cy5WZWN0b3IzID0gVmVjdG9yMztcXG5cXHRleHBvcnRzLlZlY3RvcjIgPSBWZWN0b3IyO1xcblxcdGV4cG9ydHMuUXVhdGVybmlvbiA9IFF1YXRlcm5pb247XFxuXFx0ZXhwb3J0cy5Db2xvciA9IENvbG9yO1xcblxcdGV4cG9ydHMuSW1tZWRpYXRlUmVuZGVyT2JqZWN0ID0gSW1tZWRpYXRlUmVuZGVyT2JqZWN0O1xcblxcdGV4cG9ydHMuVmVydGV4Tm9ybWFsc0hlbHBlciA9IFZlcnRleE5vcm1hbHNIZWxwZXI7XFxuXFx0ZXhwb3J0cy5TcG90TGlnaHRIZWxwZXIgPSBTcG90TGlnaHRIZWxwZXI7XFxuXFx0ZXhwb3J0cy5Ta2VsZXRvbkhlbHBlciA9IFNrZWxldG9uSGVscGVyO1xcblxcdGV4cG9ydHMuUG9pbnRMaWdodEhlbHBlciA9IFBvaW50TGlnaHRIZWxwZXI7XFxuXFx0ZXhwb3J0cy5SZWN0QXJlYUxpZ2h0SGVscGVyID0gUmVjdEFyZWFMaWdodEhlbHBlcjtcXG5cXHRleHBvcnRzLkhlbWlzcGhlcmVMaWdodEhlbHBlciA9IEhlbWlzcGhlcmVMaWdodEhlbHBlcjtcXG5cXHRleHBvcnRzLkdyaWRIZWxwZXIgPSBHcmlkSGVscGVyO1xcblxcdGV4cG9ydHMuUG9sYXJHcmlkSGVscGVyID0gUG9sYXJHcmlkSGVscGVyO1xcblxcdGV4cG9ydHMuRmFjZU5vcm1hbHNIZWxwZXIgPSBGYWNlTm9ybWFsc0hlbHBlcjtcXG5cXHRleHBvcnRzLkRpcmVjdGlvbmFsTGlnaHRIZWxwZXIgPSBEaXJlY3Rpb25hbExpZ2h0SGVscGVyO1xcblxcdGV4cG9ydHMuQ2FtZXJhSGVscGVyID0gQ2FtZXJhSGVscGVyO1xcblxcdGV4cG9ydHMuQm94SGVscGVyID0gQm94SGVscGVyO1xcblxcdGV4cG9ydHMuQm94M0hlbHBlciA9IEJveDNIZWxwZXI7XFxuXFx0ZXhwb3J0cy5QbGFuZUhlbHBlciA9IFBsYW5lSGVscGVyO1xcblxcdGV4cG9ydHMuQXJyb3dIZWxwZXIgPSBBcnJvd0hlbHBlcjtcXG5cXHRleHBvcnRzLkF4ZXNIZWxwZXIgPSBBeGVzSGVscGVyO1xcblxcdGV4cG9ydHMuU2hhcGUgPSBTaGFwZTtcXG5cXHRleHBvcnRzLlBhdGggPSBQYXRoO1xcblxcdGV4cG9ydHMuU2hhcGVQYXRoID0gU2hhcGVQYXRoO1xcblxcdGV4cG9ydHMuRm9udCA9IEZvbnQ7XFxuXFx0ZXhwb3J0cy5DdXJ2ZVBhdGggPSBDdXJ2ZVBhdGg7XFxuXFx0ZXhwb3J0cy5DdXJ2ZSA9IEN1cnZlO1xcblxcdGV4cG9ydHMuU2hhcGVVdGlscyA9IFNoYXBlVXRpbHM7XFxuXFx0ZXhwb3J0cy5TY2VuZVV0aWxzID0gU2NlbmVVdGlscztcXG5cXHRleHBvcnRzLldlYkdMVXRpbHMgPSBXZWJHTFV0aWxzO1xcblxcdGV4cG9ydHMuV2lyZWZyYW1lR2VvbWV0cnkgPSBXaXJlZnJhbWVHZW9tZXRyeTtcXG5cXHRleHBvcnRzLlBhcmFtZXRyaWNHZW9tZXRyeSA9IFBhcmFtZXRyaWNHZW9tZXRyeTtcXG5cXHRleHBvcnRzLlBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeSA9IFBhcmFtZXRyaWNCdWZmZXJHZW9tZXRyeTtcXG5cXHRleHBvcnRzLlRldHJhaGVkcm9uR2VvbWV0cnkgPSBUZXRyYWhlZHJvbkdlb21ldHJ5O1xcblxcdGV4cG9ydHMuVGV0cmFoZWRyb25CdWZmZXJHZW9tZXRyeSA9IFRldHJhaGVkcm9uQnVmZmVyR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5PY3RhaGVkcm9uR2VvbWV0cnkgPSBPY3RhaGVkcm9uR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5PY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnkgPSBPY3RhaGVkcm9uQnVmZmVyR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5JY29zYWhlZHJvbkdlb21ldHJ5ID0gSWNvc2FoZWRyb25HZW9tZXRyeTtcXG5cXHRleHBvcnRzLkljb3NhaGVkcm9uQnVmZmVyR2VvbWV0cnkgPSBJY29zYWhlZHJvbkJ1ZmZlckdlb21ldHJ5O1xcblxcdGV4cG9ydHMuRG9kZWNhaGVkcm9uR2VvbWV0cnkgPSBEb2RlY2FoZWRyb25HZW9tZXRyeTtcXG5cXHRleHBvcnRzLkRvZGVjYWhlZHJvbkJ1ZmZlckdlb21ldHJ5ID0gRG9kZWNhaGVkcm9uQnVmZmVyR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5Qb2x5aGVkcm9uR2VvbWV0cnkgPSBQb2x5aGVkcm9uR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5Qb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnkgPSBQb2x5aGVkcm9uQnVmZmVyR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5UdWJlR2VvbWV0cnkgPSBUdWJlR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5UdWJlQnVmZmVyR2VvbWV0cnkgPSBUdWJlQnVmZmVyR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5Ub3J1c0tub3RHZW9tZXRyeSA9IFRvcnVzS25vdEdlb21ldHJ5O1xcblxcdGV4cG9ydHMuVG9ydXNLbm90QnVmZmVyR2VvbWV0cnkgPSBUb3J1c0tub3RCdWZmZXJHZW9tZXRyeTtcXG5cXHRleHBvcnRzLlRvcnVzR2VvbWV0cnkgPSBUb3J1c0dlb21ldHJ5O1xcblxcdGV4cG9ydHMuVG9ydXNCdWZmZXJHZW9tZXRyeSA9IFRvcnVzQnVmZmVyR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5UZXh0R2VvbWV0cnkgPSBUZXh0R2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5UZXh0QnVmZmVyR2VvbWV0cnkgPSBUZXh0QnVmZmVyR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5TcGhlcmVHZW9tZXRyeSA9IFNwaGVyZUdlb21ldHJ5O1xcblxcdGV4cG9ydHMuU3BoZXJlQnVmZmVyR2VvbWV0cnkgPSBTcGhlcmVCdWZmZXJHZW9tZXRyeTtcXG5cXHRleHBvcnRzLlJpbmdHZW9tZXRyeSA9IFJpbmdHZW9tZXRyeTtcXG5cXHRleHBvcnRzLlJpbmdCdWZmZXJHZW9tZXRyeSA9IFJpbmdCdWZmZXJHZW9tZXRyeTtcXG5cXHRleHBvcnRzLlBsYW5lR2VvbWV0cnkgPSBQbGFuZUdlb21ldHJ5O1xcblxcdGV4cG9ydHMuUGxhbmVCdWZmZXJHZW9tZXRyeSA9IFBsYW5lQnVmZmVyR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5MYXRoZUdlb21ldHJ5ID0gTGF0aGVHZW9tZXRyeTtcXG5cXHRleHBvcnRzLkxhdGhlQnVmZmVyR2VvbWV0cnkgPSBMYXRoZUJ1ZmZlckdlb21ldHJ5O1xcblxcdGV4cG9ydHMuU2hhcGVHZW9tZXRyeSA9IFNoYXBlR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5TaGFwZUJ1ZmZlckdlb21ldHJ5ID0gU2hhcGVCdWZmZXJHZW9tZXRyeTtcXG5cXHRleHBvcnRzLkV4dHJ1ZGVHZW9tZXRyeSA9IEV4dHJ1ZGVHZW9tZXRyeTtcXG5cXHRleHBvcnRzLkV4dHJ1ZGVCdWZmZXJHZW9tZXRyeSA9IEV4dHJ1ZGVCdWZmZXJHZW9tZXRyeTtcXG5cXHRleHBvcnRzLkVkZ2VzR2VvbWV0cnkgPSBFZGdlc0dlb21ldHJ5O1xcblxcdGV4cG9ydHMuQ29uZUdlb21ldHJ5ID0gQ29uZUdlb21ldHJ5O1xcblxcdGV4cG9ydHMuQ29uZUJ1ZmZlckdlb21ldHJ5ID0gQ29uZUJ1ZmZlckdlb21ldHJ5O1xcblxcdGV4cG9ydHMuQ3lsaW5kZXJHZW9tZXRyeSA9IEN5bGluZGVyR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5DeWxpbmRlckJ1ZmZlckdlb21ldHJ5ID0gQ3lsaW5kZXJCdWZmZXJHZW9tZXRyeTtcXG5cXHRleHBvcnRzLkNpcmNsZUdlb21ldHJ5ID0gQ2lyY2xlR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5DaXJjbGVCdWZmZXJHZW9tZXRyeSA9IENpcmNsZUJ1ZmZlckdlb21ldHJ5O1xcblxcdGV4cG9ydHMuQm94R2VvbWV0cnkgPSBCb3hHZW9tZXRyeTtcXG5cXHRleHBvcnRzLkJveEJ1ZmZlckdlb21ldHJ5ID0gQm94QnVmZmVyR2VvbWV0cnk7XFxuXFx0ZXhwb3J0cy5TaGFkb3dNYXRlcmlhbCA9IFNoYWRvd01hdGVyaWFsO1xcblxcdGV4cG9ydHMuU3ByaXRlTWF0ZXJpYWwgPSBTcHJpdGVNYXRlcmlhbDtcXG5cXHRleHBvcnRzLlJhd1NoYWRlck1hdGVyaWFsID0gUmF3U2hhZGVyTWF0ZXJpYWw7XFxuXFx0ZXhwb3J0cy5TaGFkZXJNYXRlcmlhbCA9IFNoYWRlck1hdGVyaWFsO1xcblxcdGV4cG9ydHMuUG9pbnRzTWF0ZXJpYWwgPSBQb2ludHNNYXRlcmlhbDtcXG5cXHRleHBvcnRzLk1lc2hQaHlzaWNhbE1hdGVyaWFsID0gTWVzaFBoeXNpY2FsTWF0ZXJpYWw7XFxuXFx0ZXhwb3J0cy5NZXNoU3RhbmRhcmRNYXRlcmlhbCA9IE1lc2hTdGFuZGFyZE1hdGVyaWFsO1xcblxcdGV4cG9ydHMuTWVzaFBob25nTWF0ZXJpYWwgPSBNZXNoUGhvbmdNYXRlcmlhbDtcXG5cXHRleHBvcnRzLk1lc2hUb29uTWF0ZXJpYWwgPSBNZXNoVG9vbk1hdGVyaWFsO1xcblxcdGV4cG9ydHMuTWVzaE5vcm1hbE1hdGVyaWFsID0gTWVzaE5vcm1hbE1hdGVyaWFsO1xcblxcdGV4cG9ydHMuTWVzaExhbWJlcnRNYXRlcmlhbCA9IE1lc2hMYW1iZXJ0TWF0ZXJpYWw7XFxuXFx0ZXhwb3J0cy5NZXNoRGVwdGhNYXRlcmlhbCA9IE1lc2hEZXB0aE1hdGVyaWFsO1xcblxcdGV4cG9ydHMuTWVzaERpc3RhbmNlTWF0ZXJpYWwgPSBNZXNoRGlzdGFuY2VNYXRlcmlhbDtcXG5cXHRleHBvcnRzLk1lc2hCYXNpY01hdGVyaWFsID0gTWVzaEJhc2ljTWF0ZXJpYWw7XFxuXFx0ZXhwb3J0cy5MaW5lRGFzaGVkTWF0ZXJpYWwgPSBMaW5lRGFzaGVkTWF0ZXJpYWw7XFxuXFx0ZXhwb3J0cy5MaW5lQmFzaWNNYXRlcmlhbCA9IExpbmVCYXNpY01hdGVyaWFsO1xcblxcdGV4cG9ydHMuTWF0ZXJpYWwgPSBNYXRlcmlhbDtcXG5cXHRleHBvcnRzLkZsb2F0NjRCdWZmZXJBdHRyaWJ1dGUgPSBGbG9hdDY0QnVmZmVyQXR0cmlidXRlO1xcblxcdGV4cG9ydHMuRmxvYXQzMkJ1ZmZlckF0dHJpYnV0ZSA9IEZsb2F0MzJCdWZmZXJBdHRyaWJ1dGU7XFxuXFx0ZXhwb3J0cy5VaW50MzJCdWZmZXJBdHRyaWJ1dGUgPSBVaW50MzJCdWZmZXJBdHRyaWJ1dGU7XFxuXFx0ZXhwb3J0cy5JbnQzMkJ1ZmZlckF0dHJpYnV0ZSA9IEludDMyQnVmZmVyQXR0cmlidXRlO1xcblxcdGV4cG9ydHMuVWludDE2QnVmZmVyQXR0cmlidXRlID0gVWludDE2QnVmZmVyQXR0cmlidXRlO1xcblxcdGV4cG9ydHMuSW50MTZCdWZmZXJBdHRyaWJ1dGUgPSBJbnQxNkJ1ZmZlckF0dHJpYnV0ZTtcXG5cXHRleHBvcnRzLlVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZSA9IFVpbnQ4Q2xhbXBlZEJ1ZmZlckF0dHJpYnV0ZTtcXG5cXHRleHBvcnRzLlVpbnQ4QnVmZmVyQXR0cmlidXRlID0gVWludDhCdWZmZXJBdHRyaWJ1dGU7XFxuXFx0ZXhwb3J0cy5JbnQ4QnVmZmVyQXR0cmlidXRlID0gSW50OEJ1ZmZlckF0dHJpYnV0ZTtcXG5cXHRleHBvcnRzLkJ1ZmZlckF0dHJpYnV0ZSA9IEJ1ZmZlckF0dHJpYnV0ZTtcXG5cXHRleHBvcnRzLkFyY0N1cnZlID0gQXJjQ3VydmU7XFxuXFx0ZXhwb3J0cy5DYXRtdWxsUm9tQ3VydmUzID0gQ2F0bXVsbFJvbUN1cnZlMztcXG5cXHRleHBvcnRzLkN1YmljQmV6aWVyQ3VydmUgPSBDdWJpY0JlemllckN1cnZlO1xcblxcdGV4cG9ydHMuQ3ViaWNCZXppZXJDdXJ2ZTMgPSBDdWJpY0JlemllckN1cnZlMztcXG5cXHRleHBvcnRzLkVsbGlwc2VDdXJ2ZSA9IEVsbGlwc2VDdXJ2ZTtcXG5cXHRleHBvcnRzLkxpbmVDdXJ2ZSA9IExpbmVDdXJ2ZTtcXG5cXHRleHBvcnRzLkxpbmVDdXJ2ZTMgPSBMaW5lQ3VydmUzO1xcblxcdGV4cG9ydHMuUXVhZHJhdGljQmV6aWVyQ3VydmUgPSBRdWFkcmF0aWNCZXppZXJDdXJ2ZTtcXG5cXHRleHBvcnRzLlF1YWRyYXRpY0JlemllckN1cnZlMyA9IFF1YWRyYXRpY0JlemllckN1cnZlMztcXG5cXHRleHBvcnRzLlNwbGluZUN1cnZlID0gU3BsaW5lQ3VydmU7XFxuXFx0ZXhwb3J0cy5SRVZJU0lPTiA9IFJFVklTSU9OO1xcblxcdGV4cG9ydHMuTU9VU0UgPSBNT1VTRTtcXG5cXHRleHBvcnRzLkN1bGxGYWNlTm9uZSA9IEN1bGxGYWNlTm9uZTtcXG5cXHRleHBvcnRzLkN1bGxGYWNlQmFjayA9IEN1bGxGYWNlQmFjaztcXG5cXHRleHBvcnRzLkN1bGxGYWNlRnJvbnQgPSBDdWxsRmFjZUZyb250O1xcblxcdGV4cG9ydHMuQ3VsbEZhY2VGcm9udEJhY2sgPSBDdWxsRmFjZUZyb250QmFjaztcXG5cXHRleHBvcnRzLkZyb250RmFjZURpcmVjdGlvbkNXID0gRnJvbnRGYWNlRGlyZWN0aW9uQ1c7XFxuXFx0ZXhwb3J0cy5Gcm9udEZhY2VEaXJlY3Rpb25DQ1cgPSBGcm9udEZhY2VEaXJlY3Rpb25DQ1c7XFxuXFx0ZXhwb3J0cy5CYXNpY1NoYWRvd01hcCA9IEJhc2ljU2hhZG93TWFwO1xcblxcdGV4cG9ydHMuUENGU2hhZG93TWFwID0gUENGU2hhZG93TWFwO1xcblxcdGV4cG9ydHMuUENGU29mdFNoYWRvd01hcCA9IFBDRlNvZnRTaGFkb3dNYXA7XFxuXFx0ZXhwb3J0cy5Gcm9udFNpZGUgPSBGcm9udFNpZGU7XFxuXFx0ZXhwb3J0cy5CYWNrU2lkZSA9IEJhY2tTaWRlO1xcblxcdGV4cG9ydHMuRG91YmxlU2lkZSA9IERvdWJsZVNpZGU7XFxuXFx0ZXhwb3J0cy5GbGF0U2hhZGluZyA9IEZsYXRTaGFkaW5nO1xcblxcdGV4cG9ydHMuU21vb3RoU2hhZGluZyA9IFNtb290aFNoYWRpbmc7XFxuXFx0ZXhwb3J0cy5Ob0NvbG9ycyA9IE5vQ29sb3JzO1xcblxcdGV4cG9ydHMuRmFjZUNvbG9ycyA9IEZhY2VDb2xvcnM7XFxuXFx0ZXhwb3J0cy5WZXJ0ZXhDb2xvcnMgPSBWZXJ0ZXhDb2xvcnM7XFxuXFx0ZXhwb3J0cy5Ob0JsZW5kaW5nID0gTm9CbGVuZGluZztcXG5cXHRleHBvcnRzLk5vcm1hbEJsZW5kaW5nID0gTm9ybWFsQmxlbmRpbmc7XFxuXFx0ZXhwb3J0cy5BZGRpdGl2ZUJsZW5kaW5nID0gQWRkaXRpdmVCbGVuZGluZztcXG5cXHRleHBvcnRzLlN1YnRyYWN0aXZlQmxlbmRpbmcgPSBTdWJ0cmFjdGl2ZUJsZW5kaW5nO1xcblxcdGV4cG9ydHMuTXVsdGlwbHlCbGVuZGluZyA9IE11bHRpcGx5QmxlbmRpbmc7XFxuXFx0ZXhwb3J0cy5DdXN0b21CbGVuZGluZyA9IEN1c3RvbUJsZW5kaW5nO1xcblxcdGV4cG9ydHMuQWRkRXF1YXRpb24gPSBBZGRFcXVhdGlvbjtcXG5cXHRleHBvcnRzLlN1YnRyYWN0RXF1YXRpb24gPSBTdWJ0cmFjdEVxdWF0aW9uO1xcblxcdGV4cG9ydHMuUmV2ZXJzZVN1YnRyYWN0RXF1YXRpb24gPSBSZXZlcnNlU3VidHJhY3RFcXVhdGlvbjtcXG5cXHRleHBvcnRzLk1pbkVxdWF0aW9uID0gTWluRXF1YXRpb247XFxuXFx0ZXhwb3J0cy5NYXhFcXVhdGlvbiA9IE1heEVxdWF0aW9uO1xcblxcdGV4cG9ydHMuWmVyb0ZhY3RvciA9IFplcm9GYWN0b3I7XFxuXFx0ZXhwb3J0cy5PbmVGYWN0b3IgPSBPbmVGYWN0b3I7XFxuXFx0ZXhwb3J0cy5TcmNDb2xvckZhY3RvciA9IFNyY0NvbG9yRmFjdG9yO1xcblxcdGV4cG9ydHMuT25lTWludXNTcmNDb2xvckZhY3RvciA9IE9uZU1pbnVzU3JjQ29sb3JGYWN0b3I7XFxuXFx0ZXhwb3J0cy5TcmNBbHBoYUZhY3RvciA9IFNyY0FscGhhRmFjdG9yO1xcblxcdGV4cG9ydHMuT25lTWludXNTcmNBbHBoYUZhY3RvciA9IE9uZU1pbnVzU3JjQWxwaGFGYWN0b3I7XFxuXFx0ZXhwb3J0cy5Ec3RBbHBoYUZhY3RvciA9IERzdEFscGhhRmFjdG9yO1xcblxcdGV4cG9ydHMuT25lTWludXNEc3RBbHBoYUZhY3RvciA9IE9uZU1pbnVzRHN0QWxwaGFGYWN0b3I7XFxuXFx0ZXhwb3J0cy5Ec3RDb2xvckZhY3RvciA9IERzdENvbG9yRmFjdG9yO1xcblxcdGV4cG9ydHMuT25lTWludXNEc3RDb2xvckZhY3RvciA9IE9uZU1pbnVzRHN0Q29sb3JGYWN0b3I7XFxuXFx0ZXhwb3J0cy5TcmNBbHBoYVNhdHVyYXRlRmFjdG9yID0gU3JjQWxwaGFTYXR1cmF0ZUZhY3RvcjtcXG5cXHRleHBvcnRzLk5ldmVyRGVwdGggPSBOZXZlckRlcHRoO1xcblxcdGV4cG9ydHMuQWx3YXlzRGVwdGggPSBBbHdheXNEZXB0aDtcXG5cXHRleHBvcnRzLkxlc3NEZXB0aCA9IExlc3NEZXB0aDtcXG5cXHRleHBvcnRzLkxlc3NFcXVhbERlcHRoID0gTGVzc0VxdWFsRGVwdGg7XFxuXFx0ZXhwb3J0cy5FcXVhbERlcHRoID0gRXF1YWxEZXB0aDtcXG5cXHRleHBvcnRzLkdyZWF0ZXJFcXVhbERlcHRoID0gR3JlYXRlckVxdWFsRGVwdGg7XFxuXFx0ZXhwb3J0cy5HcmVhdGVyRGVwdGggPSBHcmVhdGVyRGVwdGg7XFxuXFx0ZXhwb3J0cy5Ob3RFcXVhbERlcHRoID0gTm90RXF1YWxEZXB0aDtcXG5cXHRleHBvcnRzLk11bHRpcGx5T3BlcmF0aW9uID0gTXVsdGlwbHlPcGVyYXRpb247XFxuXFx0ZXhwb3J0cy5NaXhPcGVyYXRpb24gPSBNaXhPcGVyYXRpb247XFxuXFx0ZXhwb3J0cy5BZGRPcGVyYXRpb24gPSBBZGRPcGVyYXRpb247XFxuXFx0ZXhwb3J0cy5Ob1RvbmVNYXBwaW5nID0gTm9Ub25lTWFwcGluZztcXG5cXHRleHBvcnRzLkxpbmVhclRvbmVNYXBwaW5nID0gTGluZWFyVG9uZU1hcHBpbmc7XFxuXFx0ZXhwb3J0cy5SZWluaGFyZFRvbmVNYXBwaW5nID0gUmVpbmhhcmRUb25lTWFwcGluZztcXG5cXHRleHBvcnRzLlVuY2hhcnRlZDJUb25lTWFwcGluZyA9IFVuY2hhcnRlZDJUb25lTWFwcGluZztcXG5cXHRleHBvcnRzLkNpbmVvblRvbmVNYXBwaW5nID0gQ2luZW9uVG9uZU1hcHBpbmc7XFxuXFx0ZXhwb3J0cy5VVk1hcHBpbmcgPSBVVk1hcHBpbmc7XFxuXFx0ZXhwb3J0cy5DdWJlUmVmbGVjdGlvbk1hcHBpbmcgPSBDdWJlUmVmbGVjdGlvbk1hcHBpbmc7XFxuXFx0ZXhwb3J0cy5DdWJlUmVmcmFjdGlvbk1hcHBpbmcgPSBDdWJlUmVmcmFjdGlvbk1hcHBpbmc7XFxuXFx0ZXhwb3J0cy5FcXVpcmVjdGFuZ3VsYXJSZWZsZWN0aW9uTWFwcGluZyA9IEVxdWlyZWN0YW5ndWxhclJlZmxlY3Rpb25NYXBwaW5nO1xcblxcdGV4cG9ydHMuRXF1aXJlY3Rhbmd1bGFyUmVmcmFjdGlvbk1hcHBpbmcgPSBFcXVpcmVjdGFuZ3VsYXJSZWZyYWN0aW9uTWFwcGluZztcXG5cXHRleHBvcnRzLlNwaGVyaWNhbFJlZmxlY3Rpb25NYXBwaW5nID0gU3BoZXJpY2FsUmVmbGVjdGlvbk1hcHBpbmc7XFxuXFx0ZXhwb3J0cy5DdWJlVVZSZWZsZWN0aW9uTWFwcGluZyA9IEN1YmVVVlJlZmxlY3Rpb25NYXBwaW5nO1xcblxcdGV4cG9ydHMuQ3ViZVVWUmVmcmFjdGlvbk1hcHBpbmcgPSBDdWJlVVZSZWZyYWN0aW9uTWFwcGluZztcXG5cXHRleHBvcnRzLlJlcGVhdFdyYXBwaW5nID0gUmVwZWF0V3JhcHBpbmc7XFxuXFx0ZXhwb3J0cy5DbGFtcFRvRWRnZVdyYXBwaW5nID0gQ2xhbXBUb0VkZ2VXcmFwcGluZztcXG5cXHRleHBvcnRzLk1pcnJvcmVkUmVwZWF0V3JhcHBpbmcgPSBNaXJyb3JlZFJlcGVhdFdyYXBwaW5nO1xcblxcdGV4cG9ydHMuTmVhcmVzdEZpbHRlciA9IE5lYXJlc3RGaWx0ZXI7XFxuXFx0ZXhwb3J0cy5OZWFyZXN0TWlwTWFwTmVhcmVzdEZpbHRlciA9IE5lYXJlc3RNaXBNYXBOZWFyZXN0RmlsdGVyO1xcblxcdGV4cG9ydHMuTmVhcmVzdE1pcE1hcExpbmVhckZpbHRlciA9IE5lYXJlc3RNaXBNYXBMaW5lYXJGaWx0ZXI7XFxuXFx0ZXhwb3J0cy5MaW5lYXJGaWx0ZXIgPSBMaW5lYXJGaWx0ZXI7XFxuXFx0ZXhwb3J0cy5MaW5lYXJNaXBNYXBOZWFyZXN0RmlsdGVyID0gTGluZWFyTWlwTWFwTmVhcmVzdEZpbHRlcjtcXG5cXHRleHBvcnRzLkxpbmVhck1pcE1hcExpbmVhckZpbHRlciA9IExpbmVhck1pcE1hcExpbmVhckZpbHRlcjtcXG5cXHRleHBvcnRzLlVuc2lnbmVkQnl0ZVR5cGUgPSBVbnNpZ25lZEJ5dGVUeXBlO1xcblxcdGV4cG9ydHMuQnl0ZVR5cGUgPSBCeXRlVHlwZTtcXG5cXHRleHBvcnRzLlNob3J0VHlwZSA9IFNob3J0VHlwZTtcXG5cXHRleHBvcnRzLlVuc2lnbmVkU2hvcnRUeXBlID0gVW5zaWduZWRTaG9ydFR5cGU7XFxuXFx0ZXhwb3J0cy5JbnRUeXBlID0gSW50VHlwZTtcXG5cXHRleHBvcnRzLlVuc2lnbmVkSW50VHlwZSA9IFVuc2lnbmVkSW50VHlwZTtcXG5cXHRleHBvcnRzLkZsb2F0VHlwZSA9IEZsb2F0VHlwZTtcXG5cXHRleHBvcnRzLkhhbGZGbG9hdFR5cGUgPSBIYWxmRmxvYXRUeXBlO1xcblxcdGV4cG9ydHMuVW5zaWduZWRTaG9ydDQ0NDRUeXBlID0gVW5zaWduZWRTaG9ydDQ0NDRUeXBlO1xcblxcdGV4cG9ydHMuVW5zaWduZWRTaG9ydDU1NTFUeXBlID0gVW5zaWduZWRTaG9ydDU1NTFUeXBlO1xcblxcdGV4cG9ydHMuVW5zaWduZWRTaG9ydDU2NVR5cGUgPSBVbnNpZ25lZFNob3J0NTY1VHlwZTtcXG5cXHRleHBvcnRzLlVuc2lnbmVkSW50MjQ4VHlwZSA9IFVuc2lnbmVkSW50MjQ4VHlwZTtcXG5cXHRleHBvcnRzLkFscGhhRm9ybWF0ID0gQWxwaGFGb3JtYXQ7XFxuXFx0ZXhwb3J0cy5SR0JGb3JtYXQgPSBSR0JGb3JtYXQ7XFxuXFx0ZXhwb3J0cy5SR0JBRm9ybWF0ID0gUkdCQUZvcm1hdDtcXG5cXHRleHBvcnRzLkx1bWluYW5jZUZvcm1hdCA9IEx1bWluYW5jZUZvcm1hdDtcXG5cXHRleHBvcnRzLkx1bWluYW5jZUFscGhhRm9ybWF0ID0gTHVtaW5hbmNlQWxwaGFGb3JtYXQ7XFxuXFx0ZXhwb3J0cy5SR0JFRm9ybWF0ID0gUkdCRUZvcm1hdDtcXG5cXHRleHBvcnRzLkRlcHRoRm9ybWF0ID0gRGVwdGhGb3JtYXQ7XFxuXFx0ZXhwb3J0cy5EZXB0aFN0ZW5jaWxGb3JtYXQgPSBEZXB0aFN0ZW5jaWxGb3JtYXQ7XFxuXFx0ZXhwb3J0cy5SR0JfUzNUQ19EWFQxX0Zvcm1hdCA9IFJHQl9TM1RDX0RYVDFfRm9ybWF0O1xcblxcdGV4cG9ydHMuUkdCQV9TM1RDX0RYVDFfRm9ybWF0ID0gUkdCQV9TM1RDX0RYVDFfRm9ybWF0O1xcblxcdGV4cG9ydHMuUkdCQV9TM1RDX0RYVDNfRm9ybWF0ID0gUkdCQV9TM1RDX0RYVDNfRm9ybWF0O1xcblxcdGV4cG9ydHMuUkdCQV9TM1RDX0RYVDVfRm9ybWF0ID0gUkdCQV9TM1RDX0RYVDVfRm9ybWF0O1xcblxcdGV4cG9ydHMuUkdCX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSBSR0JfUFZSVENfNEJQUFYxX0Zvcm1hdDtcXG5cXHRleHBvcnRzLlJHQl9QVlJUQ18yQlBQVjFfRm9ybWF0ID0gUkdCX1BWUlRDXzJCUFBWMV9Gb3JtYXQ7XFxuXFx0ZXhwb3J0cy5SR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQgPSBSR0JBX1BWUlRDXzRCUFBWMV9Gb3JtYXQ7XFxuXFx0ZXhwb3J0cy5SR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQgPSBSR0JBX1BWUlRDXzJCUFBWMV9Gb3JtYXQ7XFxuXFx0ZXhwb3J0cy5SR0JfRVRDMV9Gb3JtYXQgPSBSR0JfRVRDMV9Gb3JtYXQ7XFxuXFx0ZXhwb3J0cy5Mb29wT25jZSA9IExvb3BPbmNlO1xcblxcdGV4cG9ydHMuTG9vcFJlcGVhdCA9IExvb3BSZXBlYXQ7XFxuXFx0ZXhwb3J0cy5Mb29wUGluZ1BvbmcgPSBMb29wUGluZ1Bvbmc7XFxuXFx0ZXhwb3J0cy5JbnRlcnBvbGF0ZURpc2NyZXRlID0gSW50ZXJwb2xhdGVEaXNjcmV0ZTtcXG5cXHRleHBvcnRzLkludGVycG9sYXRlTGluZWFyID0gSW50ZXJwb2xhdGVMaW5lYXI7XFxuXFx0ZXhwb3J0cy5JbnRlcnBvbGF0ZVNtb290aCA9IEludGVycG9sYXRlU21vb3RoO1xcblxcdGV4cG9ydHMuWmVyb0N1cnZhdHVyZUVuZGluZyA9IFplcm9DdXJ2YXR1cmVFbmRpbmc7XFxuXFx0ZXhwb3J0cy5aZXJvU2xvcGVFbmRpbmcgPSBaZXJvU2xvcGVFbmRpbmc7XFxuXFx0ZXhwb3J0cy5XcmFwQXJvdW5kRW5kaW5nID0gV3JhcEFyb3VuZEVuZGluZztcXG5cXHRleHBvcnRzLlRyaWFuZ2xlc0RyYXdNb2RlID0gVHJpYW5nbGVzRHJhd01vZGU7XFxuXFx0ZXhwb3J0cy5UcmlhbmdsZVN0cmlwRHJhd01vZGUgPSBUcmlhbmdsZVN0cmlwRHJhd01vZGU7XFxuXFx0ZXhwb3J0cy5UcmlhbmdsZUZhbkRyYXdNb2RlID0gVHJpYW5nbGVGYW5EcmF3TW9kZTtcXG5cXHRleHBvcnRzLkxpbmVhckVuY29kaW5nID0gTGluZWFyRW5jb2Rpbmc7XFxuXFx0ZXhwb3J0cy5zUkdCRW5jb2RpbmcgPSBzUkdCRW5jb2Rpbmc7XFxuXFx0ZXhwb3J0cy5HYW1tYUVuY29kaW5nID0gR2FtbWFFbmNvZGluZztcXG5cXHRleHBvcnRzLlJHQkVFbmNvZGluZyA9IFJHQkVFbmNvZGluZztcXG5cXHRleHBvcnRzLkxvZ0x1dkVuY29kaW5nID0gTG9nTHV2RW5jb2Rpbmc7XFxuXFx0ZXhwb3J0cy5SR0JNN0VuY29kaW5nID0gUkdCTTdFbmNvZGluZztcXG5cXHRleHBvcnRzLlJHQk0xNkVuY29kaW5nID0gUkdCTTE2RW5jb2Rpbmc7XFxuXFx0ZXhwb3J0cy5SR0JERW5jb2RpbmcgPSBSR0JERW5jb2Rpbmc7XFxuXFx0ZXhwb3J0cy5CYXNpY0RlcHRoUGFja2luZyA9IEJhc2ljRGVwdGhQYWNraW5nO1xcblxcdGV4cG9ydHMuUkdCQURlcHRoUGFja2luZyA9IFJHQkFEZXB0aFBhY2tpbmc7XFxuXFx0ZXhwb3J0cy5DdWJlR2VvbWV0cnkgPSBCb3hHZW9tZXRyeTtcXG5cXHRleHBvcnRzLkZhY2U0ID0gRmFjZTQ7XFxuXFx0ZXhwb3J0cy5MaW5lU3RyaXAgPSBMaW5lU3RyaXA7XFxuXFx0ZXhwb3J0cy5MaW5lUGllY2VzID0gTGluZVBpZWNlcztcXG5cXHRleHBvcnRzLk1lc2hGYWNlTWF0ZXJpYWwgPSBNZXNoRmFjZU1hdGVyaWFsO1xcblxcdGV4cG9ydHMuTXVsdGlNYXRlcmlhbCA9IE11bHRpTWF0ZXJpYWw7XFxuXFx0ZXhwb3J0cy5Qb2ludENsb3VkID0gUG9pbnRDbG91ZDtcXG5cXHRleHBvcnRzLlBhcnRpY2xlID0gUGFydGljbGU7XFxuXFx0ZXhwb3J0cy5QYXJ0aWNsZVN5c3RlbSA9IFBhcnRpY2xlU3lzdGVtO1xcblxcdGV4cG9ydHMuUG9pbnRDbG91ZE1hdGVyaWFsID0gUG9pbnRDbG91ZE1hdGVyaWFsO1xcblxcdGV4cG9ydHMuUGFydGljbGVCYXNpY01hdGVyaWFsID0gUGFydGljbGVCYXNpY01hdGVyaWFsO1xcblxcdGV4cG9ydHMuUGFydGljbGVTeXN0ZW1NYXRlcmlhbCA9IFBhcnRpY2xlU3lzdGVtTWF0ZXJpYWw7XFxuXFx0ZXhwb3J0cy5WZXJ0ZXggPSBWZXJ0ZXg7XFxuXFx0ZXhwb3J0cy5EeW5hbWljQnVmZmVyQXR0cmlidXRlID0gRHluYW1pY0J1ZmZlckF0dHJpYnV0ZTtcXG5cXHRleHBvcnRzLkludDhBdHRyaWJ1dGUgPSBJbnQ4QXR0cmlidXRlO1xcblxcdGV4cG9ydHMuVWludDhBdHRyaWJ1dGUgPSBVaW50OEF0dHJpYnV0ZTtcXG5cXHRleHBvcnRzLlVpbnQ4Q2xhbXBlZEF0dHJpYnV0ZSA9IFVpbnQ4Q2xhbXBlZEF0dHJpYnV0ZTtcXG5cXHRleHBvcnRzLkludDE2QXR0cmlidXRlID0gSW50MTZBdHRyaWJ1dGU7XFxuXFx0ZXhwb3J0cy5VaW50MTZBdHRyaWJ1dGUgPSBVaW50MTZBdHRyaWJ1dGU7XFxuXFx0ZXhwb3J0cy5JbnQzMkF0dHJpYnV0ZSA9IEludDMyQXR0cmlidXRlO1xcblxcdGV4cG9ydHMuVWludDMyQXR0cmlidXRlID0gVWludDMyQXR0cmlidXRlO1xcblxcdGV4cG9ydHMuRmxvYXQzMkF0dHJpYnV0ZSA9IEZsb2F0MzJBdHRyaWJ1dGU7XFxuXFx0ZXhwb3J0cy5GbG9hdDY0QXR0cmlidXRlID0gRmxvYXQ2NEF0dHJpYnV0ZTtcXG5cXHRleHBvcnRzLkNsb3NlZFNwbGluZUN1cnZlMyA9IENsb3NlZFNwbGluZUN1cnZlMztcXG5cXHRleHBvcnRzLlNwbGluZUN1cnZlMyA9IFNwbGluZUN1cnZlMztcXG5cXHRleHBvcnRzLlNwbGluZSA9IFNwbGluZTtcXG5cXHRleHBvcnRzLkF4aXNIZWxwZXIgPSBBeGlzSGVscGVyO1xcblxcdGV4cG9ydHMuQm91bmRpbmdCb3hIZWxwZXIgPSBCb3VuZGluZ0JveEhlbHBlcjtcXG5cXHRleHBvcnRzLkVkZ2VzSGVscGVyID0gRWRnZXNIZWxwZXI7XFxuXFx0ZXhwb3J0cy5XaXJlZnJhbWVIZWxwZXIgPSBXaXJlZnJhbWVIZWxwZXI7XFxuXFx0ZXhwb3J0cy5YSFJMb2FkZXIgPSBYSFJMb2FkZXI7XFxuXFx0ZXhwb3J0cy5CaW5hcnlUZXh0dXJlTG9hZGVyID0gQmluYXJ5VGV4dHVyZUxvYWRlcjtcXG5cXHRleHBvcnRzLkdlb21ldHJ5VXRpbHMgPSBHZW9tZXRyeVV0aWxzO1xcblxcdGV4cG9ydHMuSW1hZ2VVdGlscyA9IEltYWdlVXRpbHM7XFxuXFx0ZXhwb3J0cy5Qcm9qZWN0b3IgPSBQcm9qZWN0b3I7XFxuXFx0ZXhwb3J0cy5DYW52YXNSZW5kZXJlciA9IENhbnZhc1JlbmRlcmVyO1xcblxcblxcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XFxuXFxufSkpKTtcXG5cIiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/raw-loader/index.js!./vendor/three.js\n");

/***/ }),

/***/ "./node_modules/script-loader/addScript.js":
/*!*************************************************!*\
  !*** ./node_modules/script-loader/addScript.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(src) {\n\tfunction log(error) {\n\t\t(typeof console !== \"undefined\")\n\t\t&& (console.error || console.log)(\"[Script Loader]\", error);\n\t}\n\n\t// Check for IE =< 8\n\tfunction isIE() {\n\t\treturn typeof attachEvent !== \"undefined\" && typeof addEventListener === \"undefined\";\n\t}\n\n\ttry {\n\t\tif (typeof execScript !== \"undefined\" && isIE()) {\n\t\t\texecScript(src);\n\t\t} else if (typeof eval !== \"undefined\") {\n\t\t\teval.call(null, src);\n\t\t} else {\n\t\t\tlog(\"EvalError: No eval function available\");\n\t\t}\n\t} catch (error) {\n\t\tlog(error);\n\t}\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanM/ZjJiNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3JjKSB7XG5cdGZ1bmN0aW9uIGxvZyhlcnJvcikge1xuXHRcdCh0eXBlb2YgY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIilcblx0XHQmJiAoY29uc29sZS5lcnJvciB8fCBjb25zb2xlLmxvZykoXCJbU2NyaXB0IExvYWRlcl1cIiwgZXJyb3IpO1xuXHR9XG5cblx0Ly8gQ2hlY2sgZm9yIElFID08IDhcblx0ZnVuY3Rpb24gaXNJRSgpIHtcblx0XHRyZXR1cm4gdHlwZW9mIGF0dGFjaEV2ZW50ICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBhZGRFdmVudExpc3RlbmVyID09PSBcInVuZGVmaW5lZFwiO1xuXHR9XG5cblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIGV4ZWNTY3JpcHQgIT09IFwidW5kZWZpbmVkXCIgJiYgaXNJRSgpKSB7XG5cdFx0XHRleGVjU2NyaXB0KHNyYyk7XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgZXZhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0ZXZhbC5jYWxsKG51bGwsIHNyYyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxvZyhcIkV2YWxFcnJvcjogTm8gZXZhbCBmdW5jdGlvbiBhdmFpbGFibGVcIik7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdGxvZyhlcnJvcik7XG5cdH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/script-loader/addScript.js\n");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./js/Utils.js":
/*!**************************************************!*\
  !*** ./node_modules/script-loader!./js/Utils.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !./node_modules/raw-loader!./js/Utils.js */ \"./node_modules/raw-loader/index.js!./js/Utils.js\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9qcy9VdGlscy5qcz9mNjk1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvaW5kZXguanMhLi9qcy9VdGlscy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS9ob21lL2xpb3ovRGVza3RvcC9MaW96L0EtUm9ib3RzL2Rhc2gtbWFzdGVyL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvaG9tZS9saW96L0Rlc2t0b3AvTGlvei9BLVJvYm90cy9kYXNoLW1hc3Rlci9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvaG9tZS9saW96L0Rlc2t0b3AvTGlvei9BLVJvYm90cy9kYXNoLW1hc3Rlci9qcy9VdGlscy5qc1wiKSkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/script-loader/index.js!./js/Utils.js\n");

/***/ }),

/***/ "./node_modules/script-loader/index.js!./vendor/three.js":
/*!******************************************************!*\
  !*** ./node_modules/script-loader!./vendor/three.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ \"./node_modules/script-loader/addScript.js\")(__webpack_require__(/*! !./node_modules/raw-loader!./vendor/three.js */ \"./node_modules/raw-loader/index.js!./vendor/three.js\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi92ZW5kb3IvdGhyZWUuanM/YjM3NiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2luZGV4LmpzIS4vdmVuZG9yL3RocmVlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsicmVxdWlyZShcIiEhL2hvbWUvbGlvei9EZXNrdG9wL0xpb3ovQS1Sb2JvdHMvZGFzaC1tYXN0ZXIvbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9ob21lL2xpb3ovRGVza3RvcC9MaW96L0EtUm9ib3RzL2Rhc2gtbWFzdGVyL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9ob21lL2xpb3ovRGVza3RvcC9MaW96L0EtUm9ib3RzL2Rhc2gtbWFzdGVyL3ZlbmRvci90aHJlZS5qc1wiKSkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/script-loader/index.js!./vendor/three.js\n");

/***/ }),

/***/ "./workers/PathPlannerWorker.js":
/*!**************************************!*\
  !*** ./workers/PathPlannerWorker.js ***!
  \**************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var script_loader_vendor_three_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! script-loader!../vendor/three.js */ \"./node_modules/script-loader/index.js!./vendor/three.js\");\n/* harmony import */ var script_loader_vendor_three_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(script_loader_vendor_three_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var script_loader_js_Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! script-loader!../js/Utils.js */ \"./node_modules/script-loader/index.js!./js/Utils.js\");\n/* harmony import */ var script_loader_js_Utils_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(script_loader_js_Utils_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _js_autonomy_path_planning_PathPlanner_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../js/autonomy/path-planning/PathPlanner.js */ \"./js/autonomy/path-planning/PathPlanner.js\");\n/* harmony import */ var _js_autonomy_LanePath_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../js/autonomy/LanePath.js */ \"./js/autonomy/LanePath.js\");\n/* harmony import */ var _js_autonomy_StaticObstacle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../js/autonomy/StaticObstacle.js */ \"./js/autonomy/StaticObstacle.js\");\n/* harmony import */ var _js_autonomy_DynamicObstacle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../js/autonomy/DynamicObstacle.js */ \"./js/autonomy/DynamicObstacle.js\");\n\n\n\n\n\n\n\nfunction init() {\n  let pathPlanner;\n  try {\n    pathPlanner = new _js_autonomy_path_planning_PathPlanner_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n  } catch (e) {\n    console.log('Error initializing path planner:');\n    console.log(e);\n\n    self.postMessage({ error: true });\n\n    return;\n  }\n\n  self.onmessage = function(event) {\n    const { config, vehiclePose, vehicleStation, lanePath, startTime, staticObstacles, dynamicObstacles, reset } = event.data;\n\n    _js_autonomy_LanePath_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"].hydrate(lanePath);\n    staticObstacles.forEach(o => _js_autonomy_StaticObstacle_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"].hydrate(o));\n    dynamicObstacles.forEach(o => _js_autonomy_DynamicObstacle_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].hydrate(o));\n\n    if (reset) pathPlanner.reset();\n\n    pathPlanner.config = config;\n\n    try {\n      const { path, fromVehicleSegment, fromVehicleParams, latticeStartStation, dynamicObstacleGrid } = pathPlanner.plan(vehiclePose, vehicleStation, lanePath, startTime, staticObstacles, dynamicObstacles);\n\n      self.postMessage({ path, fromVehicleSegment, fromVehicleParams, vehiclePose, vehicleStation, latticeStartStation, config, dynamicObstacleGrid });\n    } catch (error) {\n      console.log('PathPlannerWorker error');\n      console.log(error);\n    }\n  };\n}\n\nif (typeof(window) === 'undefined') {\n  init();\n} else {\n  window.dash_initPathPlannerWorker = init;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi93b3JrZXJzL1BhdGhQbGFubmVyV29ya2VyLmpzPzRlNzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsc0JBQXNCLGNBQWM7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHFHQUFxRzs7QUFFaEg7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSx3RkFBd0Y7O0FBRXJHLHdCQUF3Qiw2SEFBNkg7QUFDckosS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBIiwiZmlsZSI6Ii4vd29ya2Vycy9QYXRoUGxhbm5lcldvcmtlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBUSFJFRSBmcm9tIFwic2NyaXB0LWxvYWRlciEuLi92ZW5kb3IvdGhyZWUuanNcIjtcbmltcG9ydCBVdGlscyBmcm9tIFwic2NyaXB0LWxvYWRlciEuLi9qcy9VdGlscy5qc1wiO1xuaW1wb3J0IFBhdGhQbGFubmVyIGZyb20gXCIuLi9qcy9hdXRvbm9teS9wYXRoLXBsYW5uaW5nL1BhdGhQbGFubmVyLmpzXCI7XG5pbXBvcnQgTGFuZVBhdGggZnJvbSBcIi4uL2pzL2F1dG9ub215L0xhbmVQYXRoLmpzXCI7XG5pbXBvcnQgU3RhdGljT2JzdGFjbGUgZnJvbSBcIi4uL2pzL2F1dG9ub215L1N0YXRpY09ic3RhY2xlLmpzXCI7XG5pbXBvcnQgRHluYW1pY09ic3RhY2xlIGZyb20gXCIuLi9qcy9hdXRvbm9teS9EeW5hbWljT2JzdGFjbGUuanNcIjtcblxuZnVuY3Rpb24gaW5pdCgpIHtcbiAgbGV0IHBhdGhQbGFubmVyO1xuICB0cnkge1xuICAgIHBhdGhQbGFubmVyID0gbmV3IFBhdGhQbGFubmVyKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zb2xlLmxvZygnRXJyb3IgaW5pdGlhbGl6aW5nIHBhdGggcGxhbm5lcjonKTtcbiAgICBjb25zb2xlLmxvZyhlKTtcblxuICAgIHNlbGYucG9zdE1lc3NhZ2UoeyBlcnJvcjogdHJ1ZSB9KTtcblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHNlbGYub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBjb25zdCB7IGNvbmZpZywgdmVoaWNsZVBvc2UsIHZlaGljbGVTdGF0aW9uLCBsYW5lUGF0aCwgc3RhcnRUaW1lLCBzdGF0aWNPYnN0YWNsZXMsIGR5bmFtaWNPYnN0YWNsZXMsIHJlc2V0IH0gPSBldmVudC5kYXRhO1xuXG4gICAgTGFuZVBhdGguaHlkcmF0ZShsYW5lUGF0aCk7XG4gICAgc3RhdGljT2JzdGFjbGVzLmZvckVhY2gobyA9PiBTdGF0aWNPYnN0YWNsZS5oeWRyYXRlKG8pKTtcbiAgICBkeW5hbWljT2JzdGFjbGVzLmZvckVhY2gobyA9PiBEeW5hbWljT2JzdGFjbGUuaHlkcmF0ZShvKSk7XG5cbiAgICBpZiAocmVzZXQpIHBhdGhQbGFubmVyLnJlc2V0KCk7XG5cbiAgICBwYXRoUGxhbm5lci5jb25maWcgPSBjb25maWc7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBwYXRoLCBmcm9tVmVoaWNsZVNlZ21lbnQsIGZyb21WZWhpY2xlUGFyYW1zLCBsYXR0aWNlU3RhcnRTdGF0aW9uLCBkeW5hbWljT2JzdGFjbGVHcmlkIH0gPSBwYXRoUGxhbm5lci5wbGFuKHZlaGljbGVQb3NlLCB2ZWhpY2xlU3RhdGlvbiwgbGFuZVBhdGgsIHN0YXJ0VGltZSwgc3RhdGljT2JzdGFjbGVzLCBkeW5hbWljT2JzdGFjbGVzKTtcblxuICAgICAgc2VsZi5wb3N0TWVzc2FnZSh7IHBhdGgsIGZyb21WZWhpY2xlU2VnbWVudCwgZnJvbVZlaGljbGVQYXJhbXMsIHZlaGljbGVQb3NlLCB2ZWhpY2xlU3RhdGlvbiwgbGF0dGljZVN0YXJ0U3RhdGlvbiwgY29uZmlnLCBkeW5hbWljT2JzdGFjbGVHcmlkIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZygnUGF0aFBsYW5uZXJXb3JrZXIgZXJyb3InKTtcbiAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICB9XG4gIH07XG59XG5cbmlmICh0eXBlb2Yod2luZG93KSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgaW5pdCgpO1xufSBlbHNlIHtcbiAgd2luZG93LmRhc2hfaW5pdFBhdGhQbGFubmVyV29ya2VyID0gaW5pdDtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./workers/PathPlannerWorker.js\n");

/***/ })

/******/ });} 
if (typeof(window) === undefined) dash_initPathPlannerWorker();
